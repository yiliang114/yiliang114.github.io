---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 事件机制

React 其实自己实现了一套事件机制，首先我们考虑一下以下代码：

```jsx
const Test = ({ list, handleClick }) =>
  list.map((item, index) => (
    <span onClick={handleClick} key={index}>
      {index}
    </span>
  ));
```

以上类似代码想必大家经常会写到，但是你是否考虑过点击事件是否绑定在了每一个标签上？事实当然不是，JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 `document` 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。

另外冒泡到 `document` 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 `event.stopPropagation` 是无效的，而应该调用 `event.preventDefault`。

那么实现合成事件的目的是什么呢？总的来说在我看来好处有两点，分别是：

- 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力
- 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。

### HTML 和 React 事件处理有什么区别?

在 HTML 中事件名必须小写：

```html
<button onclick="activateLasers()"></button>
```

而在 React 中它遵循 _camelCase_ (驼峰) 惯例：

```jsx
<button onClick={activateLasers}>
```

在 HTML 中你可以返回 `false` 以阻止默认的行为：

```html
<a href="#" onclick='console.log("The link was clicked."); return false;' />
```

而在 React 中你必须地明确地调用 `preventDefault()` ：

```js
function handleClick(event) {
  event.preventDefault();
  console.log('The link was clicked.');
}
```

### 如何在 JSX 回调中绑定方法或事件处理程序?

实现这一点有三种可能的方法：

1. **Binding in Constructor:** 在 JavaScript 类中，方法默认不被绑定。这也适用于定义为类方法的 React 事件处理程序。通常我们在构造函数中绑定它们。

```js
class Component extends React.Componenet {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // ...
  }
}
```

**Public class fields syntax:** 如果你不喜欢 bind 方案，则可以使用 _public class fields syntax_ 正确绑定回调。

```jsx
handleClick = () => {
  console.log('this is:', this);
};
```

```jsx
<button onClick={this.handleClick}>{'Click me'}</button>
```

**Arrow functions in callbacks:** 你可以在回调函数中直接使用 _arrow functions_。

```jsx
<button onClick={event => this.handleClick(event)}>{'Click me'}</button>
```

**注意：** 如果回调函数作为属性传给子组件，那么这些组件可能触发一个额外的重新渲染。在这些情况下，考虑到性能，最好使用 `.bind()` 或 _public class fields syntax_ 方案。

### 如何将参数传递给事件处理程序或回调函数?

你可以使用箭头函数来包装事件处理器并传递参数：

```jsx
<button onClick={() => this.handleClick(id)} />
```

这相当于调用 `.bind`:

```jsx
<button onClick={this.handleClick.bind(this, id)} />
```

### React 中的合成事件是什么?

`SyntheticEvent` 是对浏览器原生事件的跨浏览器包装。它的 API 与浏览器的原生事件相同，包括 `stopPropagation()` 和 `preventDefault()`，除了事件在所有浏览器中的工作方式相同。

### 在 React 中事件有何不同?

处理 React 元素中的事件有一些语法差异：

React 事件处理程序是采用驼峰而不是小写来命名的。
使用 JSX，你将传递一个函数作为事件处理程序，而不是字符串。

## 概述下 React 中的事件处理逻辑

> 为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的

### onclick 与 OnClick

### react 的自定义事件和原生事件的区别

React 并不是将 click 事件绑在该 div 的真实 DOM 上，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。
。

### React 中是怎么实现事件代理的？

React 并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点 document 上为每种事件添加唯一的 Listener，然后通过事件的 target 找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React 都会触发对应的事件处理函数。这就是所谓的 React 模拟事件系统。

尽管整个事件系统由 React 管理，但是其 API 和使用方法与原生事件一致。这种机制确保了跨浏览器的一致性：在所有浏览器（IE8 及以上）都可以使用符合 W3C 标准的 API，包括 stopPropagation()，preventDefault()等等。对于事件的冒泡（bubble）和捕获（capture）模式也都完全支持。
