---
layout: CustomPages
title: LeetCode 题解 排序
date: 2020-11-21
aside: false
draft: true
---

### [56].合并区间 merge-intervals

```
Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

```

#### 思路

- 先对数组进行排序，排序的依据就是每一项的第一个元素的大小。
- 然后我们对数组进行遍历，遍历的时候两两运算(具体运算逻辑见下)
- 判断是否相交，如果不相交，则跳过
- 如果相交，则合并两项

两个区间若能合并，则第一个区间的右端点一定不小于第二个区间的左端点。所以先把区间集合按照左端点从小到大进行排序，接着从第一个区间开始遍历，对每个区间执行如下操作：

1. 首先保存该区间的左端点 start 和右端点 end
2. 从该区间的下一个区间开始，依次比较此区间的左端点与上一个区间的右端点，若满足合并条件则记录新合并区间的右端点。注意右端点取当前区间与之前区间右端点的较大值
3. 若当前区间不再满足合并条件或者遍历到了集合末尾，就构建新合并区间，其中左端点为初始区间的左端点，右端点为当前所有合并区间右端点的最大值，然后将其加入到结果集合中，接着合并下一个区间

#### 关键点解析

- 对数组进行排序简化操作
- 如果不排序，需要借助一些 hack,这里不介绍了

#### 代码

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */

function intersected(a, b) {
  if (a[0] > b[1] || a[1] < b[0]) return false;
  return true;
}

function mergeTwo(a, b) {
  return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];
}
var merge = function(intervals) {
  // 这种算法需要先排序
  intervals.sort((a, b) => a[0] - b[0]);
  for (let i = 0; i < intervals.length - 1; i++) {
    const cur = intervals[i];
    const next = intervals[i + 1];

    if (intersected(cur, next)) {
      intervals[i] = undefined;
      intervals[i + 1] = mergeTwo(cur, next);
    }
  }
  return intervals.filter(q => q);
};
```

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */

var merge = function(intervals) {
  if (intervals.length < 2) return intervals;
  intervals = intervals.sort((a, b) => a[0] - b[0]);
  let left = intervals[0][0],
    right = intervals[0][1];

  for (let i = 1; i < intervals.length; i++) {}
};
```

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let i = nums.length - 2,
    len = nums.length - 1;
  while (i > 0) {
    if (nums[i] >= len - i) {
      len = i;
    }
    i--;
  }
  return nums[0] >= len;
};

/**
 * 从后往前找更佳
 */
```

```js
/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {Interval[]}
 */
var merge = function(intervals) {
  if (intervals.length == 0) return [];
  intervals.sort((a, b) => {
    return a.start - b.start;
  });

  let ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    if (intervals[i].end >= intervals[i + 1].start) {
      intervals[i + 1].start = Math.min(intervals[i].start, intervals[i + 1].start);
      intervals[i + 1].end = Math.max(intervals[i].end, intervals[i + 1].end);
    } else {
      ans.push(intervals[i]);
    }
  }
  ans.push(intervals[intervals.length - 1]);
  return ans;
};
```

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
export default function merge(intervals) {
  if (intervals.length === 0) return [];
  if (intervals.length === 1) return intervals;
  intervals = intervals.sort((a, b) => {
    if (a[0] !== b[0]) return a[0] - b[0];
    return a[1] - b[1];
  });
  let start = intervals[0][0];
  let end = intervals[0][1];
  const ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    const left = intervals[i];
    const right = intervals[i + 1];
    if (right[0] <= end && right[1] >= end) {
      end = right[1]; // then overlap
    } else if (right[0] > end) {
      ans.push([start, end]);
      start = right[0];
      end = right[1];
    }
    if (i === intervals.length - 2) ans.push([start, end]);
  }
  return ans;
}
```

### [75].颜色分类 sort-colors DONE

给定一个包含红色、白色和蓝色，一共  n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

#### 思路

其实就是排序，而且没有要求稳定性，就是用啥排序算法都行. 甚至直接使用 sort 函数也可以（不过要知道 sort 函数有个坑）。

#### 代码

```js
var sortColors = function(nums) {
  function swap(nums, i, j) {
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = 0; j < nums.length - i; j++) {
      if (nums[j] < nums[j - 1]) {
        swap(nums, j - 1, j);
      }
    }
  }
};
```

### [148].排序链表 DONE

给你链表的头结点  head ，请将其按 升序 排列并返回 排序后的链表 。

二分，用快慢指针法，快指针走两步，慢指针走一步，快指针越界时，慢指针正好到达中点，只需记录慢指针的前一个指针，就能断成两链。merge 函数做的事是合并两个有序的左右链

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
  if (head == null || head.next == null) return head;

  let prev = null,
    slow = head,
    fast = head;

  while (fast != null && fast.next != null) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }

  prev.next = null;

  let l1 = sortList(head);
  let l2 = sortList(slow);

  return merge(l1, l2);
};

// 合并两个有序链表
function merge(l1, l2) {
  let l = new ListNode(0),
    p = l;

  while (l1 != null && l2 != null) {
    if (l1.val < l2.val) {
      p.next = l1;
      l1 = l1.next;
    } else {
      p.next = l2;
      l2 = l2.next;
    }
    p = p.next;
  }

  if (l1 != null) p.next = l1;
  if (l2 != null) p.next = l2;

  return l.next;
}
```
