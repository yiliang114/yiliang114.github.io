---
layout: CustomPages
title: 字符串-回文
date: 2020-11-29
aside: false
draft: true
---

# 回文

回文串就是一个正读和反读都一样的字符串，比如 `level` 或者 `noon`等等就是回文串。

判断是否回文的通用方法是首尾双指针。 判断最长回文的思路主要是两个字"扩展"，如果可以充分利用回文的特点，则可以减少很多无谓的计算，典型的是《马拉车算法》。

```js
function isPalindrome(string) {
  const _string = string.replace(/\s/g, '').toLowerCase();
  return reverse(_string) === _string;
}

function reverse(string) {
  return string
    .split('')
    .reverse()
    .join('');
}
```

### 相关问题

- [125.valid-palindrome](../problems/125.valid-palindrome.md)
- [131.palindrome-partitioning](../problems/131.palindrome-partitioning.md)
- [shortest-palindrome](https://leetcode.com/problems/shortest-palindrome/)
- [516.longest-palindromic-subsequence](../problems/516.longest-palindromic-subsequence.md)

### 最长回文子串

[5.longest-palindromic-substring](https://leetcode.com/problems/longest-palindromic-substring/)

用 `dp[i][j]` 表示子串 i 到 j 是否是回文，使用动态规划求解：

```cpp
string longestPalindrome(string s) {
	int m = s.size();
	if (m == 0) {
		return "";
	}
	vector<vector<int>> dp(m, vector<int>(m, 0));
	int start = 0;
	int length = 1;

	for (int i = 0; i < m; i++) {
        // 单个字符属于回文，例如 abcd
		dp[i][i] = 1;

        // 连续两个字符相同属于回文，例如 abb
		if (i < m - 1) {
			if (s[i] == s[i + 1]) {
				dp[i][i + 1] = 1;
                start = i;
				length = 2;
			}
		}
	}

	for (int len = 2; len <= m; len++) {
		for (int i = 0; i < m - len; i++) {
			int j = i + len;
            // 扩展长度
			if (dp[i + 1][j - 1] == 1 && s[i] == s[j]) {
				dp[i][j] = 1;

				if (j - i + 1 > length) {
                    start = i;
					length = j - i + 1;
				}
			}
		}
	}

	return s.substr(start, length);
}
```

### 验证回文串 【leetcode 125】

```js
var isPalindrome = function(s) {
  s = s.replace(/[^\w]/g, '').toLowerCase();
  return (
    s
      .split('')
      .reverse()
      .join('') === s
  );
};

console.log(isPalindrome('A man, a plan, a canal: Panama'));
console.log(isPalindrome('race a car'));
```

### 最长回文子串.js 【leetcode 5】

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"

```js
var longestPalindrome = function(str) {
  const n = str.length;
  if (n < 2) return str;
  let s = 0,
    e = 0;
  // 表示子串是否是回文串
  let dp = [0];
  for (let j = 0; j < n; ++j) {
    for (let i = 0; i < j; ++i) {
      if (!(dp[i] = dp[i + 1] || str[i] != str[j]) && e - s <= j - i) (s = i), (e = j);
    }
  }
  return str.substr(s, e - s + 1);
};
```

### 回文字符串

[LeetCode : 680. Valid Palindrome II (Easy)](https://leetcode.com/problems/valid-palindrome-ii/description/)

```html
Input: "abca" Output: True Explanation: You could delete the character 'c'.
```

题目描述：可以删除一个字符，判断是否能构成回文字符串。

```java
public boolean validPalindrome(String s) {
    int i = 0, j = s.length() - 1;
    while (i < j) {
        if (s.charAt(i) != s.charAt(j)) {
            return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
        }
        i++;
        j--;
    }
    return true;
}

private boolean isPalindrome(String s, int l, int r) {
    while (l < r) {
        if (s.charAt(l++) != s.charAt(r--)) return false;
    }
    return true;
}
```

### 7. 回文子字符串个数

[647. Palindromic Substrings (Medium)](https://leetcode.com/problems/palindromic-substrings/description/)

```html
Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
```

从字符串的某一位开始，尝试着去扩展子字符串。

```java
private int cnt = 0;

public int countSubstrings(String s) {
    for (int i = 0; i < s.length(); i++) {
        extendSubstrings(s, i, i);     // 奇数长度
        extendSubstrings(s, i, i + 1); // 偶数长度
    }
    return cnt;
}

private void extendSubstrings(String s, int start, int end) {
    while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
        start--;
        end++;
        cnt++;
    }
}
```

### 8. 判断一个整数是否是回文数

[9. Palindrome Number (Easy)](https://leetcode.com/problems/palindrome-number/description/)

要求不能使用额外空间，也就不能将整数转换为字符串进行判断。

将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。

```java
public boolean isPalindrome(int x) {
    if (x == 0) {
        return true;
    }
    if (x < 0 || x % 10 == 0) {
        return false;
    }
    int right = 0;
    while (x > right) {
        right = right * 10 + x % 10;
        x /= 10;
    }
    return x == right || x == right / 10;
}
```

### 判断一个字符串是否是回文

回文是指将字符串翻转之后的值跟翻转之前的值相等。比如 `mamam`, `ava` .

这里主要的考察是 `reverse` 的实现， 刚好 JS 的数组(注意是数组，而不是字符串)就有 `reverse` 函数。直接利用现成的函数，将字符串转换成数组。

```js
function checkPalindrome(str) {
  return (
    str ===
    str
      .split('')
      .reverse()
      .join('')
  );
}
```

### 回文 number

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
  return (
    x ==
    (x + '')
      .split('')
      .reverse()
      .join('')
  );
};

console.log(isPalindrome(121));
```

### 最长回文

```js
/*
 * @lc app=leetcode id=409 lang=javascript
 *
 * [409] Longest Palindrome
 */
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindrome = function(s) {
  // abccccdd
  let res = 0;
  let hasOdd = false;
  const counts = Array('z'.charCodeAt(0) + 1).fill(0);
  for (let i = 0; i < s.length; i++) {
    counts[s.charCodeAt(i)] += 1;
  }

  for (let i = 0; i < counts.length; i++) {
    if (counts[i] % 2 === 0) {
      res += counts[i];
    } else {
      hasOdd = true;
      res += counts[i] - 1;
    }
  }

  return hasOdd ? res + 1 : res;
};
```

### 有效的回文 【leetcode 680】

#### SF/leetcode/leetcode-js/680.valid-palindrome-ii.js

```js
/*
 * @lc app=leetcode id=680 lang=javascript
 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

示例 1:

输入: "aba"
输出: True
示例 2:

输入: "abca"
输出: True
解释: 你可以删除c字符。
注意:

字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。
 *
 * [680] Valid Palindrome II
 */
/**
 * @param {string} s
 * @return {boolean}
 */
// 双指针
var validPalindrome = function(s) {
  for (let i = 0, j = s.length - 1; i < s.length; i++, j--) {
    if (s[i] !== s[j]) {
      // 去除前面左边一位 或者 后面一位
      return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
    }
  }
  return true;
};

function isPalindrome(s, i, j) {
  while (i < j) {
    if (s[i++] !== s[j--]) {
      return false;
    }
  }
  return true;
}
// 不要带 console 影响结果。。。
// console.log(validPalindrome('aba'))
// console.log(validPalindrome('abca'))
```

#### SF/leetcode/leetcode-js/682.棒球比赛.js

```js
/*
 * @lc app=leetcode.cn id=682 lang=javascript
 *
 * [682] 棒球比赛
 */
/**
 * @param {string[]} ops
 * @return {number}
 */
// ✔ Accepted
// ✔ 39 / 39 cases passed(80 ms)
// ✔ Your runtime beats 80.07 % of javascript submissions
// ✔ Your memory usage beats 75.95 % of javascript submissions(34.7 MB)
var calPoints = function(ops) {
  const stack = [];
  for (let i = 0; i < ops.length; i++) {
    switch (ops[i]) {
      case '+':
        const sLen = stack.length;
        stack.push(sLen >= 2 ? stack[sLen - 1] + stack[sLen - 2] - 0 : sLen === 1 ? stack[0] - 0 : 0);
        break;
      case 'D':
        stack.push(2 * stack[stack.length - 1]);
        break;
      case 'C':
        stack.pop();
        break;
      default:
        if (!isNaN(ops[i] - 0)) {
          stack.push(ops[i] - 0);
        }
    }
  }
  // console.log('stack', stack)
  return getSum(stack);
};

function getSum(arr) {
  return arr.reduce((sum, item) => sum + item, 0);
}

console.log(calPoints(['5', '2', 'C', 'D', '+']));
console.log(calPoints(['5', '-2', '4', 'C', 'D', '9', '+', '+']));
```

#### SF/leetcode/leetcode-js/680.js

```js
// 680. Valid Palindrome II

// Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

// Example 1:

// Input: "aba"
// Output: True
// Example 2:

// Input: "abca"
// Output: True
// Explanation: You could delete the character 'c'.
// Note:

// The string will only contain lowercase characters a-z. The maximum length of the string is 50000.

/**
 * @param {string} s
 * @return {boolean}
 */
export default function validPalindrome(s) {
  let invalid = false;
  let left = 0;
  let right = 0;
  for (let i = 0; i < Math.floor(s.length / 2); i++) {
    if (i + left > s.length - 1 - i - right) break;
    if (s[i + left] === s[s.length - 1 - i - right]) {
      continue;
    } else if (!invalid) {
      invalid = false;
      if (s[i + 1] === s[s.length - 1 - i]) {
        left++;
      } else if (s[i] === s[s.length - 2 - i]) {
        right++;
      } else {
        return false;
      }
      invalid = false;
    } else {
      return false;
    }
  }
  return left + right < 2;
}
```

#### 最长回文子串

```js
/**
Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

*/
// MEMORY LIMIT EXCEEDED....
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  var len = s.length,
    isPal = [],
    max = 1,
    start = 0,
    end = 0,
    i,
    j;

  for (i = 0; i < len; i++) {
    isPal.push(new Array(len));
    isPal[i][i] = true;
  }

  for (i = len - 1; i >= 0; i--) {
    for (j = i + 1; j < len; j++) {
      if (s.charAt(i) === s.charAt(j) && (j === i + 1 || isPal[i + 1][j - 1])) {
        isPal[i][j] = true;

        if (j - i + 1 > max) {
          start = i;
          end = j;
          max = j - i + 1;
        }
      }
    }
  }

  return s.substring(start, end + 1);
};
```
