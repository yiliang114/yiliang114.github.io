---
layout: CustomPages
title: 字符串-回文
date: 2020-11-29
aside: false
draft: true
---

## 回文

回文串就是一个正读和反读都一样的字符串，比如 `level` 或者 `noon`等等就是回文串。

1. 判断是否回文的通用方法是首尾双指针。 判断最长回文的思路主要是两个字"扩展"，如果可以充分利用回文的特点，则可以减少很多无谓的计算，典型的是《马拉车算法》。

2. 这里主要的考察是 `reverse` 的实现， 刚好 JS 的数组(注意是数组，而不是字符串)就有 `reverse` 函数。直接利用现成的函数，将字符串转换成数组。

### 判断一个字符串是否是回文

```js
var isPalindrome = function(s) {
  // \w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
  s = s.replace(/[^\w]/g, '').toLowerCase();
  return (
    s
      .split('')
      .reverse()
      .join('') === s
  );
};
```

数字的回文

```js
var isPalindrome = function(x) {
  return (
    x ==
    (x + '')
      .split('')
      .reverse()
      .join('')
  );
};
```

### [7]. 回文子字符串个数

[647. Palindromic Substrings (Medium)](https://leetcode.com/problems/palindromic-substrings/description/)

```html
Input: "aaa" Output: 6 Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
```

从字符串的某一位开始，尝试着去扩展子字符串。

```java
private int cnt = 0;

public int countSubstrings(String s) {
    for (int i = 0; i < s.length(); i++) {
        extendSubstrings(s, i, i);     // 奇数长度
        extendSubstrings(s, i, i + 1); // 偶数长度
    }
    return cnt;
}

private void extendSubstrings(String s, int start, int end) {
    while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
        start--;
        end++;
        cnt++;
    }
}
```

### [680].有效的回文 valid-palindrome-ii

给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

示例 1:

输入: "aba"
输出: True
示例 2:

输入: "abca"
输出: True
解释: 你可以删除 c 字符。
注意:

字符串只包含从 a-z 的小写字母。字符串的最大长度是 50000。

```js
// 双指针
var validPalindrome = function(s) {
  for (let i = 0, j = s.length - 1; i < s.length; i++, j--) {
    if (s[i] !== s[j]) {
      // 去除前面左边一位 或者 后面一位
      return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
    }
  }
  return true;
};

function isPalindrome(s, i, j) {
  while (i < j) {
    if (s[i++] !== s[j--]) {
      return false;
    }
  }
  return true;
}
// 不要带 console 影响结果。。。
// console.log(validPalindrome('aba'))
// console.log(validPalindrome('abca'))
```

```js
export default function validPalindrome(s) {
  let invalid = false;
  let left = 0;
  let right = 0;
  for (let i = 0; i < Math.floor(s.length / 2); i++) {
    if (i + left > s.length - 1 - i - right) break;
    if (s[i + left] === s[s.length - 1 - i - right]) {
      continue;
    } else if (!invalid) {
      invalid = false;
      if (s[i + 1] === s[s.length - 1 - i]) {
        left++;
      } else if (s[i] === s[s.length - 2 - i]) {
        right++;
      } else {
        return false;
      }
      invalid = false;
    } else {
      return false;
    }
  }
  return left + right < 2;
}
```

### [682].棒球比赛

```js
/*
 * @lc app=leetcode.cn id=682 lang=javascript
 *
 * [682] 棒球比赛
 */
/**
 * @param {string[]} ops
 * @return {number}
 */
// ✔ Accepted
// ✔ 39 / 39 cases passed(80 ms)
// ✔ Your runtime beats 80.07 % of javascript submissions
// ✔ Your memory usage beats 75.95 % of javascript submissions(34.7 MB)
var calPoints = function(ops) {
  const stack = [];
  for (let i = 0; i < ops.length; i++) {
    switch (ops[i]) {
      case '+':
        const sLen = stack.length;
        stack.push(sLen >= 2 ? stack[sLen - 1] + stack[sLen - 2] - 0 : sLen === 1 ? stack[0] - 0 : 0);
        break;
      case 'D':
        stack.push(2 * stack[stack.length - 1]);
        break;
      case 'C':
        stack.pop();
        break;
      default:
        if (!isNaN(ops[i] - 0)) {
          stack.push(ops[i] - 0);
        }
    }
  }
  // console.log('stack', stack)
  return getSum(stack);
};

function getSum(arr) {
  return arr.reduce((sum, item) => sum + item, 0);
}

console.log(calPoints(['5', '2', 'C', 'D', '+']));
console.log(calPoints(['5', '-2', '4', 'C', 'D', '9', '+', '+']));
```

### 相关问题

- [9].回文数 Palindrome Number (Easy)
- [131].palindrome-partitioning
- [516].longest-palindromic-subsequence
