---
layout: CustomPages
title: 数组
date: 2020-11-29
aside: false
draft: true
---

## 数组

常见问题：

- 两数之和
- 连续最大子数组
- 乘积最大子数组
- 买卖股票的最佳时机 1，2，3
- 买卖股票的最佳时机 1：寻找数组里面的最大上升子序列
- 买卖股票的最佳时机 2：寻找数组里面所有的上升子序列
- 买卖股票的最佳时机 3：寻找数组里面两个不重合的上升子序列，并且使他们的和最大 to-do
- 区间合并(将有交集的区间合并)
- 寻找缺失的数 1. 一个顺序的数组[1,2,3,5,6],缺少了一个数字，如何找到它？ 2. 一个 arr 的数组，只有一个数字出现了一次，其他都出现了两次，如何找到它？
- 数组的近似划分(将一个数组分成两个，但是差最小)
- 数组里面第 k 大的数
- 跳跃游戏 1，2
- 跳跃游戏 1：
- 给出一个非负整数数组，你最初定位在数组的第一个位置,
- 数组中的每个元素代表你在那个位置可以跳跃的最大长度,
- 返回 是否能到达数组的最后一个位置
- 跳跃游戏 2：
- 给出一个非负整数数组，你最初定位在数组的第一个位置,
- 数组中的每个元素代表你在那个位置可以跳跃的最大长度,
- 返回 使用最少的跳跃次数到达数组的最后一个位置
- a+. 二维矩阵
- 顺时针打印二维矩阵
- 给出一个二维矩阵，找到一个路径(从某个左上角到某个角右下)使这条路径的值最大

### 数组、字符串的子集位置查询

```js
function indexOfArray(target, tool) {
  for (var i = 0, targetLen = target.length; i < targetLen; i++) {
    for (var j = 0, toolLen = tool.length; j < toolLen; j++) {
      if (target[i + j] !== tool[j]) {
        break; // j++ 是在循环体结束后自增，使用 break 则在自增前就跳出循环了
      }
    }
    if (j === toolLen) {
      return i;
    }
  }
  return -1;
}

console.log(indexOfArray('abcdedfg', 'ed'));
```

### 根据筛选条件从目标数组中返回符合条件的子集

```js
function arrayFilter(target, tool) {
  var result = [];
  for (var i = 0, len = target.length; i < len; i++) {
    var keep = true;
    for (var key in tool) {
      if (typeof target[i][key] === 'undefined' || target[i][key] !== tool[key]) {
        keep = false;
        break;
      }
    }
    if (keep) {
      result.push(target[i]);
    }
  }
  return result;
}

function arrayFilterTest() {
  var target = [
    { name: 'Jack', age: 18, sex: 'f' },
    { name: 'Jack', age: 20 },
    { name: 'Mike', age: 25 },
  ];

  console.log('arrayFilter test: ', arrayFilter(target, { age: 20 }));
  console.log('arrayFilter test: ', arrayFilter(target, { num: 10 }));
  console.log('arrayFilter test: ', arrayFilter(target, {}));
}
```

### 合并两个有序数组

```js
function mergeSortedArray(arrA, arrB) {
  var result = [];
  var i = 0,
    j = 0,
    targetLen = arrA.length,
    toolLen = arrB.length;
  while (i < targetLen && j < toolLen) {
    if (arrA[i] < arrB[j]) {
      result.push(arrA[i++]);
    } else {
      result.push(arrB[j++]);
    }
  }
  while (i < targetLen) {
    result.push(arrA[i++]);
  }
  while (j < toolLen) {
    result.push(arrB[j++]);
  }
  return result;
}
```

### 合并数组

```js
// 给一个数组如：[[“a”,”b”,”c”],[“d”,”e”],…..]得到[ad,ae,bd,be,cd,ce]
function mapConcat(target) {
  var res = target.reduce(function(pre, next) {
    var ret = [];
    pre.forEach(function(preItem) {
      next.forEach(function(nextItem) {
        if (preItem !== nextItem) {
          // 去掉aa这种情况
          ret.push(preItem + nextItem);
        }
      });
    });
    return ret;
  });
  return res;
}

function mapConcatTest() {
  // var target = [['a', 'b', 'c'], ['d', 'e'], ['f', 'g', 'h'], ['j', 'm']];
  var target = [
    ['a', 'b', 'c'],
    ['a', 'b'],
  ];
  console.log('\nmapConcatTest:\n', mapConcat(target));
}
// mapConcatTest();

// 求整数数组的最大子串和，如 [-23, 17, -7, 11, -2, 1, -34] 的最大子串和是21，对应子串是 [17, -7, 11]
function maxSeqSum(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const len = arr.length;
  let maxSum = arr[0];
  let seqSum = arr[0];
  for (let i = 1; i < len; i++) {
    if (seqSum <= 0) {
      seqSum = arr[i];
    } else {
      seqSum += arr[i];
    }
    if (seqSum > maxSum) {
      maxSum = seqSum;
    }
  }
  return maxSum;
}
function maxSeqSumTest() {
  console.log(maxSeqSum([-23, 17, -7, 11, -2, 1, -34]));
  console.log(maxSeqSum([1, -2, 3, 10, -4, 7, 2, -5]));
  console.log(maxSeqSum([-1]));
}
// maxSeqSumTest();
```

### 数组最长无重复子串查找

查找没有重复的最长子串，若使用哈希表判断重复的话，就要重新定位，可以将哈希的 value=数组元素当前序号

```js
function longestSubArray(target) {
  var lastStart, lastLen, maxStart, maxLen;
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;

  for (var i = 1, len = target.length; i < len; i++) {
    var noRepeat = true;
    for (var j = lastStart; j < lastStart + lastLen; j++) {
      if (target[i] === target[j]) {
        noRepeat = false;
        if (maxLen < lastLen) {
          maxLen = lastLen;
          maxStart = lastStart;
        }
        i = lastStart = i - (lastStart + lastLen - j) + 1;
        lastLen = 1;
        break;
      }
    }
    if (noRepeat) {
      lastLen++;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
// 哈希版本，js实现起来简单、在数据量大的情况下会有优势
function longestSubArrayHash(target) {
  var lastStart,
    lastLen,
    maxStart,
    maxLen,
    last = {};
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;
  last[target[lastStart]] = lastStart;

  for (var i = 1, len = target.length; i < len; i++) {
    if (typeof last[target[i]] === 'undefined') {
      lastLen++;
      last[target[i]] = i;
    } else {
      if (maxLen < lastLen) {
        maxLen = lastLen;
        maxStart = lastStart;
      }
      i = lastStart = last[target[i]] + 1;
      last = {};
      last[target[lastStart]] = lastStart;
      lastLen = 1;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
function longestSubArrayTest() {
  var target = [1, 2, 3, 4, 3, 6, 8, 9, 10, 14, 15, 8, 9];
  console.log('\nlongestSubArray test:\n', longestSubArray(target));
  console.log('\nlongestSubArrayHash test:\n', longestSubArrayHash(target));
}
```

### 数组重复次数最多的子串查找

查重，输出重复次数最多的元素及其重复次数。

```js
function countSubArray(target) {
  var sub = {};
  var max = {
    num: 1,
    index: 0,
  };
  for (var i = 0, len = target.length; i < len; i++) {
    if (!sub.hasOwnProperty(target[i])) {
      sub[target[i]] = {
        num: 1,
        index: i,
      };
    } else {
      var current = sub[target[i]];
      current.num++;
      if (max.num < current.num) {
        max.num = current.num;
        max.index = current.index;
      }
    }
  }
  return {
    element: target[max.index],
    index: max.index,
    count: max.num,
  };
}
function countSubArrayTest() {
  var target = [2, 2, 2, 4, 4, 11, 11, 5, 15, 11, 17, 11, 80, 11];
  var target1 = ['qwe', 'as', 'dsfw', 'as', 'kou', 'lpi', 'as', 'jei', 'as'];
  console.log('\ncountSubArrayTest test:\n', countSubArray(target1));
}
```

### 查询字符串第一个不重复字母

查询给定字符串“abcba”，处理得到第一个不重复字母，c

```js
function queryFirstUniqueItem(target) {
  var items = {};
  var last = [];
  for (var i = 0, l = target.length; i < l; i++) {
    var item = target[i];
    if (!items.hasOwnProperty(item)) {
      last.push(i);
      items[item] = i;
    } else {
      var index = last.indexOf(items[item]);
      if (index >= 0) {
        last.splice(index, 1);
      }
    }
  }
  var ret = '';
  if (last.length) {
    ret = target[last[0]];
  }
  return ret;
}
function queryFirstUniqueItemTest() {
  var a = 'abdcbadegceg';
  var ret = queryFirstUniqueItem(a);
  console.log('ret: ', ret);
  console.log('ret: ', !ret);
}
```

### 是否有序

```js
function isSorted(array) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    let next = array[i + 1];
    if (next && current > next) {
      // exit as soon as we know the array isn't sorted
      return false;
    }
  }
  return true;
}

/// tests

import { test } from 'ava';

test(t => t.is(isSorted([]), true));
test(t => t.is(isSorted([-Infinity, -5, 0, 3, 9]), true));
test(t => t.is(isSorted([3, 9, -3, 10]), false));
```

### remove-element

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
  let index = nums.indexOf(val);
  while (index > -1) {
    nums.splice(index, 1);
    index = nums.indexOf(val);
  }
  return nums.length;
};

const nums = [3, 2, 2, 3];
const nums1 = [0, 1, 2, 2, 3, 0, 4, 2];
console.log('result', removeElement(nums, 3));
console.log('result1', removeElement(nums1, 2));
```

### search-insert-position

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  let index = nums.indexOf(target);
  if (index === -1) {
    const newNums = [...nums, target].sort(function(a, b) {
      if (a < b) return -1;
      else if (a > b) return 1;
      else return 0;
    });
    index = newNums.indexOf(target);
  }
  return index;
};
```

### plus-one

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  return (parseInt(digits.join('')) + 1 + '').split('').map(elm => parseInt(elm));
};

const nums = [6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3];
console.log('result', plusOne(nums));
```

### remove-duplicates-from-sorted-array

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const map = {};
  nums.forEach((elm, index) => {
    if (elm === nums[index + 1]) {
      nums.splice(index + 1, 1);
    }
  });
  return nums;
};

const nums = [0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4];
const nums1 = [1, 1, 2];
console.log('result', removeDuplicates(nums));
console.log('result1', removeDuplicates(nums1));
```

### 查找第 K 大的数

```js
function findKMax(a, k) {
  // 查找第 K大的数
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  let len = a.length - key;
  while (len !== k) {
    if (len > k) {
      key = partition(a, key + 1, right);
    } else {
      key = partition(a, left, key - 1);
    }
    len = a.length - key;
  }
  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让key为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把key现在所在的下标返回
}
const arr = [5, 4, 3, 2, 1, 6];
const KMax = findKMax(arr, 1);
console.log(KMax);
```

### 查找第 K 小的数

```js
function findKMin(a, k) {
  // 查找第 K 小的数
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  while (key !== k - 1) {
    if (key > k - 1) {
      key = partition(a, left, key - 1);
    } else {
      key = partition(a, key + 1, right);
    }
  }
  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让 key 为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果 key 小于 a[right]，则 right 递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果 key 大于 a[left]，则 left 递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把 key 现在所在的下标返回
}
const arr = [5, 4, 3, 2, 1, 6];
const KMin = findKMin(arr, 2);
console.log(KMin);
```

### 给定一个整数数组，求其中三个整数的最大乘积

```js
var unsortedArray = [-10, 7, 29, 30, 5, -10, -70];

computeProduct(unsortedArray); // 21000

function sortIntegers(a, b) {
  return a - b;
}

// Greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)
function computeProduct(unsorted) {
  var sortedArray = unsorted.sort(sortIntegers),
    product1 = 1,
    product2 = 1,
    array_n_element = sortedArray.length - 1;

  // Get the product of three largest integers in sorted array
  for (var x = array_n_element; x > array_n_element - 3; x--) {
    product1 = product1 * sortedArray[x];
  }

  product2 = sortedArray[0] * sortedArray[1] * sortedArray[array_n_element];

  if (product1 > product2) return product1;

  return product2;
}
```

### 数组-连续-求和

已知未排序的数组包含(n-1)个 n 个连续数字(定义了边界)，请在 O(n)时间中找到缺失的数字

```js
// The output of the function should be 8
var arrayOfIntegers = [2, 5, 1, 4, 9, 6, 3, 7];
var upperBound = 9;
var lowerBound = 1;

findMissingNumber(arrayOfIntegers, upperBound, lowerBound); // 8

function findMissingNumber(arrayOfIntegers, upperBound, lowerBound) {
  // Iterate through array to find the sum of the numbers
  var sumOfIntegers = 0;
  for (var i = 0; i < arrayOfIntegers.length; i++) {
    sumOfIntegers += arrayOfIntegers[i];
  }

  // Find theoretical sum of the consecutive numbers using a variation of Gauss Sum.
  // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2];
  // N is the upper bound and M is the lower bound

  upperLimitSum = (upperBound * (upperBound + 1)) / 2;
  lowerLimitSum = (lowerBound * (lowerBound - 1)) / 2;

  theoreticalSum = upperLimitSum - lowerLimitSum;

  return theoreticalSum - sumOfIntegers;
}
```

- **[1.3](#array--unique) Removing duplicates of an array and returning an array of only unique elements**

  ```js
  // ES6 Implementation
  var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

  Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]

  // ES5 Implementation
  var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

  uniqueArray(array); // [1, 2, 3, 5, 9, 8]

  function uniqueArray(array) {
    var hashmap = {};
    var unique = [];

    for (var i = 0; i < array.length; i++) {
      // If key returns undefined (unique), it is evaluated as false.
      if (!hashmap.hasOwnProperty(array[i])) {
        hashmap[array[i]] = 1;
        unique.push(array[i]);
      }
    }

    return unique;
  }
  ```

  **View on Codepen:** http://codepen.io/kennymkchan/pen/ZLNwze?editors=0012

- **[1.4](#array--largest-difference) Given an array of integers, find the largest difference between two elements such that the element of lesser value must come before the greater element**

  ```js
  var array = [7, 8, 4, 9, 9, 15, 3, 1, 10];
  // [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`
  // Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.

  findLargestDifference(array);

  function findLargestDifference(array) {
    // If there is only one element, there is no difference
    if (array.length <= 1) return -1;

    // currentMin will keep track of the current lowest
    var currentMin = array[0];
    var currentMaxDifference = 0;

    // We will iterate through the array and keep track of the current max difference
    // If we find a greater max difference, we will set the current max difference to that variable
    // Keep track of the current min as we iterate through the array, since we know the greatest
    // difference is yield from `largest value in future` - `smallest value before it`

    for (var i = 1; i < array.length; i++) {
      if (array[i] > currentMin && array[i] - currentMin > currentMaxDifference) {
        currentMaxDifference = array[i] - currentMin;
      } else if (array[i] <= currentMin) {
        currentMin = array[i];
      }
    }

    // If negative or 0, there is no largest difference
    if (currentMaxDifference <= 0) return -1;

    return currentMaxDifference;
  }
  ```

  **View on Codepen:** http://codepen.io/kennymkchan/pen/MJdLWJ?editors=0012

- **[1.5](#array--product-other-than-itself) Given an array of integers, return an output array such that output[i] is equal to the product of all the elements in the array other than itself. (Solve this in O(n) without division)**

  ```js
  var firstArray = [2, 2, 4, 1];
  var secondArray = [0, 0, 0, 2];
  var thirdArray = [-2, -2, -3, 2];

  productExceptSelf(firstArray); // [8, 8, 4, 16]
  productExceptSelf(secondArray); // [0, 0, 0, 0]
  productExceptSelf(thirdArray); // [12, 12, 8, -12]

  function productExceptSelf(numArray) {
    var product = 1;
    var size = numArray.length;
    var output = [];

    // From first array: [1, 2, 4, 16]
    // The last number in this case is already in the right spot (allows for us)
    // to just multiply by 1 in the next step.
    // This step essentially gets the product to the left of the index at index + 1
    for (var x = 0; x < size; x++) {
      output.push(product);
      product = product * numArray[x];
    }

    // From the back, we multiply the current output element (which represents the product
    // on the left of the index, and multiplies it by the product on the right of the element)
    var product = 1;
    for (var i = size - 1; i > -1; i--) {
      output[i] = output[i] * product;
      product = product * numArray[i];
    }

    return output;
  }
  ```

  **View on Codepen:** http://codepen.io/kennymkchan/pen/OWYdJK?editors=0012

* **[1.6](#array--intersection) Find the intersection of two arrays. An intersection would be the common elements that exists within both arrays. In this case, these elements should be unique!**

  ```js
  var firstArray = [2, 2, 4, 1];
  var secondArray = [1, 2, 0, 2];

  intersection(firstArray, secondArray); // [2, 1]

  function intersection(firstArray, secondArray) {
    // The logic here is to create a hashmap with the elements of the firstArray as the keys.
    // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash
    // If it does exist, add that element to the new array.

    var hashmap = {};
    var intersectionArray = [];

    firstArray.forEach(function(element) {
      hashmap[element] = 1;
    });

    // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added
    secondArray.forEach(function(element) {
      if (hashmap[element] === 1) {
        intersectionArray.push(element);
        hashmap[element]++;
      }
    });

    return intersectionArray;

    // Time complexity O(n), Space complexity O(n)
  }
  ```

  **View on Codepen:** http://codepen.io/kennymkchan/pen/vgwbEb?editors=0012
