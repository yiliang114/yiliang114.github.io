---
layout: CustomPages
title: 数组
date: 2020-11-29
aside: false
draft: true
---

# 数组

### 去重

```js
function uniq(array) {
  let seen = {};

  return array.reduce((result, current) => {
    if (current in seen) {
      return result;
    }
    seen[current] = true;
    return result.concat(current);
  }, []);
}

/// tests

import { test } from 'ava';

test(t => t.deepEqual(uniq([]), []));
test(t => t.deepEqual(uniq([1, 4, 2, 2, 3, 4, 8]), [1, 4, 2, 3, 8]));
```

### 数组去重

```js
function arrayUnique(target) {
  // 纯数组硬比较方式，这里要注意是否需要空对象{}的去重，暂不处理
  // var result = [target[0]];
  // for (var i = 1, targetLen = target.length; i < targetLen; i++) {
  //   for (var j = 0, resultLen = result.length; j < resultLen; j++) {
  //     if (result[j] === target[i]) {
  //       break;    // j++是在循环体结束后自增，使用break则在自增前就跳出循环了
  //     }
  //   }
  //   if (j === resultLen) {
  //     result.push(target[i]);
  //   }
  // }

  // 对于去重这种无序的集合，可使用js对象的哈希特性来提高效率，但无法直接区分数字、字符，统一转为字符了
  // Note: 数据量少的情况下，哈希算法本身的复杂度就超过了循环对比，所以性能上反而更差
  var result = [target[0]];
  var temp = Object.create(null);
  temp[target[0]] = {};
  temp[target[0]][typeof target[0]] = 1;
  // 要区分数字、字符、布尔值、null等类型，必须保存 temp[target[i]][(typeof target[i])] 作为标志
  for (var i = 1, targetLen = target.length; i < targetLen; i++) {
    if (typeof temp[target[i]] === 'undefined' || !temp[target[i]].hasOwnProperty(typeof target[i])) {
      result.push(target[i]);
      temp[target[i]] = {};
      temp[target[i]][typeof target[i]] = 1;
    }
  }
  return result;
}
```

### 整型数组去重

比如输入: `[1,13,24,11,11,14,1,2]`
输出: `[1,13,24,11,14,2]`

这道问题有不止一个解法。

- 第一种解法，主要考察个人对 Object 的使用，利用 key 来进行筛选。
- 直接使用 ES6 的 Set 去重。

```js
function unique(arr) {
  const hashTable = {};
  const data = [];
  for (let i = 0; i < arr.length; i++) {
    const key = arr[i];
    if (!hashTable[key]) {
      hashTable[key] = true;
      data.push(key);
    }
  }
  return data;
}

function unique1(arr) {
  return Array.from(new Set(arr));
}
```

### 数组、字符串的子集位置查询

```js
function indexOfArray(target, tool) {
  for (var i = 0, targetLen = target.length; i < targetLen; i++) {
    for (var j = 0, toolLen = tool.length; j < toolLen; j++) {
      if (target[i + j] !== tool[j]) {
        break; // j++是在循环体结束后自增，使用break则在自增前就跳出循环了
      }
    }
    if (j === toolLen) {
      return i;
    }
  }
  return -1;
}
function indexOfArrayTest() {
  console.log('indexOfArray test: ', indexOfArray('abcdedfg', 'e'));
}
```

### 根据筛选条件从目标数组中返回符合条件的子集

```js
function arrayFilter(target, tool) {
  var result = [];
  for (var i = 0, len = target.length; i < len; i++) {
    var keep = true;
    for (var key in tool) {
      if (typeof target[i][key] === 'undefined' || target[i][key] !== tool[key]) {
        keep = false;
        break;
      }
    }
    if (keep) {
      result.push(target[i]);
    }
  }
  return result;
}
function arrayFilterTest() {
  var target = [
    { name: 'Jack', age: 18, sex: 'f' },
    { name: 'Jack', age: 20 },
    { name: 'Mike', age: 25 },
  ];
  console.log('\narrayFilter test: \n', arrayFilter(target, { age: 20 }));
  console.log('\narrayFilter test: \n', arrayFilter(target, { num: 10 }));
  console.log('\narrayFilter test: \n', arrayFilter(target, {}));
}
```

### 合并两个有序数组

```js
function mergeSortedArray(arrA, arrB) {
  var result = [];
  var i = 0,
    j = 0,
    targetLen = arrA.length,
    toolLen = arrB.length;
  while (i < targetLen && j < toolLen) {
    if (arrA[i] < arrB[j]) {
      result.push(arrA[i++]);
    } else {
      result.push(arrB[j++]);
    }
  }
  while (i < targetLen) {
    result.push(arrA[i++]);
  }
  while (j < toolLen) {
    result.push(arrB[j++]);
  }
  return result;
}
```

### 数组最长无重复子串查找

查找没有重复的最长子串，若使用哈希表判断重复的话，就要重新定位，可以将哈希的 value=数组元素当前序号

```js
function longestSubArray(target) {
  var lastStart, lastLen, maxStart, maxLen;
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;

  for (var i = 1, len = target.length; i < len; i++) {
    var noRepeat = true;
    for (var j = lastStart; j < lastStart + lastLen; j++) {
      if (target[i] === target[j]) {
        noRepeat = false;
        if (maxLen < lastLen) {
          maxLen = lastLen;
          maxStart = lastStart;
        }
        i = lastStart = i - (lastStart + lastLen - j) + 1;
        lastLen = 1;
        break;
      }
    }
    if (noRepeat) {
      lastLen++;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
// 哈希版本，js实现起来简单、在数据量大的情况下会有优势
function longestSubArrayHash(target) {
  var lastStart,
    lastLen,
    maxStart,
    maxLen,
    last = {};
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;
  last[target[lastStart]] = lastStart;

  for (var i = 1, len = target.length; i < len; i++) {
    if (typeof last[target[i]] === 'undefined') {
      lastLen++;
      last[target[i]] = i;
    } else {
      if (maxLen < lastLen) {
        maxLen = lastLen;
        maxStart = lastStart;
      }
      i = lastStart = last[target[i]] + 1;
      last = {};
      last[target[lastStart]] = lastStart;
      lastLen = 1;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
function longestSubArrayTest() {
  var target = [1, 2, 3, 4, 3, 6, 8, 9, 10, 14, 15, 8, 9];
  console.log('\nlongestSubArray test:\n', longestSubArray(target));
  console.log('\nlongestSubArrayHash test:\n', longestSubArrayHash(target));
}
```

### 数组重复次数最多的子串查找

查重，输出重复次数最多的元素及其重复次数。

```js
function countSubArray(target) {
  var sub = {};
  var max = {
    num: 1,
    index: 0,
  };
  for (var i = 0, len = target.length; i < len; i++) {
    if (!sub.hasOwnProperty(target[i])) {
      sub[target[i]] = {
        num: 1,
        index: i,
      };
    } else {
      var current = sub[target[i]];
      current.num++;
      if (max.num < current.num) {
        max.num = current.num;
        max.index = current.index;
      }
    }
  }
  return {
    element: target[max.index],
    index: max.index,
    count: max.num,
  };
}
function countSubArrayTest() {
  var target = [2, 2, 2, 4, 4, 11, 11, 5, 15, 11, 17, 11, 80, 11];
  var target1 = ['qwe', 'as', 'dsfw', 'as', 'kou', 'lpi', 'as', 'jei', 'as'];
  console.log('\ncountSubArrayTest test:\n', countSubArray(target1));
}
```

### 查询字符串第一个不重复字母

查询给定字符串“abcba”，处理得到第一个不重复字母，c

```js
function queryFirstUniqueItem(target) {
  var items = {};
  var last = [];
  for (var i = 0, l = target.length; i < l; i++) {
    var item = target[i];
    if (!items.hasOwnProperty(item)) {
      last.push(i);
      items[item] = i;
    } else {
      var index = last.indexOf(items[item]);
      if (index >= 0) {
        last.splice(index, 1);
      }
    }
  }
  var ret = '';
  if (last.length) {
    ret = target[last[0]];
  }
  return ret;
}
function queryFirstUniqueItemTest() {
  var a = 'abdcbadegceg';
  var ret = queryFirstUniqueItem(a);
  console.log('ret: ', ret);
  console.log('ret: ', !ret);
}
```

### 合并数组

```js
// 给一个数组如：[[“a”,”b”,”c”],[“d”,”e”],…..]得到[ad,ae,bd,be,cd,ce]
function mapConcat(target) {
  var res = target.reduce(function(pre, next) {
    var ret = [];
    pre.forEach(function(preItem) {
      next.forEach(function(nextItem) {
        if (preItem !== nextItem) {
          // 去掉aa这种情况
          ret.push(preItem + nextItem);
        }
      });
    });
    return ret;
  });
  return res;
}
function mapConcatTest() {
  // var target = [['a', 'b', 'c'], ['d', 'e'], ['f', 'g', 'h'], ['j', 'm']];
  var target = [
    ['a', 'b', 'c'],
    ['a', 'b'],
  ];
  console.log('\nmapConcatTest:\n', mapConcat(target));
}
// mapConcatTest();

// 求整数数组的最大子串和，如 [-23, 17, -7, 11, -2, 1, -34] 的最大子串和是21，对应子串是 [17, -7, 11]
function maxSeqSum(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const len = arr.length;
  let maxSum = arr[0];
  let seqSum = arr[0];
  for (let i = 1; i < len; i++) {
    if (seqSum <= 0) {
      seqSum = arr[i];
    } else {
      seqSum += arr[i];
    }
    if (seqSum > maxSum) {
      maxSum = seqSum;
    }
  }
  return maxSum;
}
function maxSeqSumTest() {
  console.log(maxSeqSum([-23, 17, -7, 11, -2, 1, -34]));
  console.log(maxSeqSum([1, -2, 3, 10, -4, 7, 2, -5]));
  console.log(maxSeqSum([-1]));
}
// maxSeqSumTest();
```

### 是否有序

```js
function isSorted(array) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    let next = array[i + 1];
    if (next && current > next) {
      // exit as soon as we know the array isn't sorted
      return false;
    }
  }
  return true;
}

/// tests

import { test } from 'ava';

test(t => t.is(isSorted([]), true));
test(t => t.is(isSorted([-Infinity, -5, 0, 3, 9]), true));
test(t => t.is(isSorted([3, 9, -3, 10]), false));
```

### 41. First-Missing-Positive

```js
/**
 * https://leetcode.com/problems/first-missing-positive/
 * Difficulty:Hard
 *
 * Given an unsorted integer array, find the first missing positive integer.
 * For example,
 * Given [1,2,0] return 3,
 * and [3,4,-1,1] return 2.
 * Your algorithm should run in O(n) time and uses constant space.
 */

/**
 * 思路介绍
 * 1. 将第 i 个元素放到第 i 个坑
 * 2. 遍历所有的坑, 找到数字不对应的坑
 *
 * 例如
 *     [ 3, 4, -1, 1 ]
 * --> [ -1, 4, 3, 1 ]
 * --> [ -1, 1, 3, 4 ]
 * --> [ 1, -1, 3, 4 ]
 * --> 2
 *
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
  var n = nums.length;
  var i = 0;
  // console.log(nums);
  while (i < n) {
    var c = nums[i];
    if (c > 0 && n < n + 1 && c !== i + 1 && nums[c - 1] !== nums[i]) {
      swap(nums, c - 1, i);
      // console.log('-->', nums);
    } else {
      i++;
    }
  }

  // console.log(nums);
  for (var i = 0; i < n; i++) {
    if (nums[i] !== i + 1) return i + 1;
  }
  return n + 1;
};

function swap(nums, i, j) {
  var tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}

// console.log(firstMissingPositive([1, 2, 0]));
console.log(firstMissingPositive([3, 4, -1, 1]));
// console.log(firstMissingPositive([1, 1]));
// console.log(firstMissingPositive([2, 2]));
```

### 两数之和

```js
/*
 * @lc app=leetcode.cn id=167 lang=javascript
 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值(index1 和 index2)不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
 *
 * [167] 两数之和 II - 输入有序数组
 */
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */

//  indexOf 太低效了。。。。
var twoSum1 = function(numbers, target) {
  for (let i = 0; i < numbers.length; i++) {
    const find = target - numbers[i];
    let index = numbers.findStart(find, i + 1);
    // console.log('index', index)
    if (index !== -1) {
      return [i + 1, index + 1];
    }
  }
};

Array.prototype.findStart = function(target, start) {
  let index = this.slice(start).indexOf(target);
  return index !== -1 ? index + start : -1;
};

// 暴力循环法
var twoSum2 = function(numbers, target) {
  for (let i = 0; i < numbers.length - 1; i++) {
    for (let j = i + 1; j < numbers.length; j++) {
      // 下标从 0 开始
      if (numbers[i] + numbers[j] === target) return [i + 1, j + 1];
    }
  }
};

// 使用双指针
var twoSum = function(numbers, target) {
  let left = 0,
    right = numbers.length - 1,
    temp;
  while (left < right) {
    temp = numbers[left] + numbers[right];
    if (temp === target) {
      return [left + 1, right + 1];
    } else if (temp > target) {
      right--;
    } else {
      left++;
    }
  }
};

console.log(twoSum([2, 7, 11, 15], 9));
console.log(twoSum([0, 0, 3, 4], 0));
console.log(twoSum([-1, -2, 0, 0, 3, 4], 0));
```

```js
const handler = (num, target) => {
  num = num.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  const length = num.length;
  let jizhun = num[length - 1],
    res;
  for (let i = 0; i < num.length; i++) {
    if (target - num[i] <= jizhun) {
      // 最大也只能是 基准值
      jizhun = target - num[i];
      const index = num.indexOf(jizhun);
      if (index > -1) {
        res = [num[i], num[index]];
        break;
      }
    }
  }
  return res;
};

const a = [3, 2, 4],
  b = 6;
const res = handler(a, b);
console.log(res);
```

#### twoSum [leetcode.1]

```js
/*
 * [1] 两数之和
 * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
 * 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
 * 示例:
 * 给定 nums = [2, 7, 11, 15], target = 9
 * 因为 nums[0] + nums[1] = 2 + 7 = 9
 * 所以返回 [0, 1]
 */

// 76 ms	39.8 MB
// var twoSum = function (nums, target) {
//   const map = new Map();
//   for (let i = 0; i < nums.length; i++) {
//     if (map.has(target - nums[i])) {
//       return [map.get(target - nums[i]), i];
//     }
//     map.set(nums[i], i);
//   }
// };

// 80 ms	39.8 MB
var twoSum = function(nums = [], target) {
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    if (map[target - nums[i]] !== undefined) {
      return [map[target - nums[i]], i];
    }
    map[nums[i]] = i;
  }
};

// 事实证明，{} 与 Map 的存取速度差不多
```

### leetcode 15.三数之和

```js
/*
 * @lc app=leetcode.cn id=15 lang=javascript
 *
 * [15] 三数之和
 */
// 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

// 注意：答案中不可以包含重复的三元组。

// 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

// 满足要求的三元组集合为：
// [
//   [-1, 0, 1],
//   [-1, -1, 2]
// ]
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  // 转化成两数之和
  const result = [];
  for (let i = 0; i < nums.length - 2; i++) {
    const target = -nums[i];
    const res = twoSum(nums, target) || [];

    res.forEach(element => {
      if (element && !element.includes(i)) {
        result.push([nums[i], nums[element[0]], nums[element[1]]]);
      }
    });
  }
  // 返回结果之前先去重，比如 [0,1] 和 [1, 0]
  const cached1 = {};
  const temp = result.filter(res => {
    const key = JSON.stringify(res.sort());
    if (!cached1[key]) {
      cached1[key] = true;
      return true;
    }
  });
  return temp;
};

var twoSum = function(nums, target) {
  if (nums && nums.length < 2) return;
  let result = [];
  for (let i = 0; i < nums.length; i++) {
    const val = target - nums[i];
    const index = nums.indexOf(val);
    if (i !== index && index !== -1) {
      result.push([i, index]);
    }
  }
  // 返回结果之前先去重，比如 [0,1] 和 [1, 0]
  const cached = {};
  const temp = result.filter(res => {
    const key = JSON.stringify(res.sort());
    if (!cached[key]) {
      cached[key] = true;
      return true;
    }
  });
  return temp;
};

// let nums = [-1, 0, 1, 2, -1, -4]
// console.log(threeSum(nums))
// nums = [-1, 0, 1, 2, -1, -4]
// console.log(threeSum(nums))

nums = [0, 0, 0];
console.log(threeSum(nums));
//  [[-1,-1,2],[-1,0,1]]
```

### remove-element

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
  let index = nums.indexOf(val);
  while (index > -1) {
    nums.splice(index, 1);
    index = nums.indexOf(val);
  }
  return nums.length;
};

const nums = [3, 2, 2, 3];
const nums1 = [0, 1, 2, 2, 3, 0, 4, 2];
console.log('result', removeElement(nums, 3));
console.log('result1', removeElement(nums1, 2));
```

### search-insert-position

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  let index = nums.indexOf(target);
  if (index === -1) {
    const newNums = [...nums, target].sort(function(a, b) {
      if (a < b) return -1;
      else if (a > b) return 1;
      else return 0;
    });
    index = newNums.indexOf(target);
  }
  return index;
};
```

### plus-one

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  return (parseInt(digits.join('')) + 1 + '').split('').map(elm => parseInt(elm));
};

const nums = [6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3];
console.log('result', plusOne(nums));
```

### remove-duplicates-from-sorted-array

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const map = {};
  nums.forEach((elm, index) => {
    if (elm === nums[index + 1]) {
      nums.splice(index + 1, 1);
    }
  });
  return nums;
};

const nums = [0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4];
const nums1 = [1, 1, 2];
console.log('result', removeDuplicates(nums));
console.log('result1', removeDuplicates(nums1));
```
