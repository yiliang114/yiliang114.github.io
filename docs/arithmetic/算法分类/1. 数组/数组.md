---
layout: CustomPages
title: 数组
date: 2020-11-29
aside: false
draft: true
---

## 数组

常见问题：

- 两数之和
- 连续最大子数组
- 乘积最大子数组
- 买卖股票的最佳时机 1，2，3
- 买卖股票的最佳时机 1：寻找数组里面的最大上升子序列
- 买卖股票的最佳时机 2：寻找数组里面所有的上升子序列
- 买卖股票的最佳时机 3：寻找数组里面两个不重合的上升子序列，并且使他们的和最大 to-do
- 区间合并(将有交集的区间合并)
- 寻找缺失的数 1. 一个顺序的数组[1,2,3,5,6],缺少了一个数字，如何找到它？ 2. 一个 arr 的数组，只有一个数字出现了一次，其他都出现了两次，如何找到它？
- 数组的近似划分(将一个数组分成两个，但是差最小)
- 数组里面第 k 大的数
- 跳跃游戏 1，2
- 跳跃游戏 1：
- 给出一个非负整数数组，你最初定位在数组的第一个位置,
- 数组中的每个元素代表你在那个位置可以跳跃的最大长度,
- 返回 是否能到达数组的最后一个位置
- 跳跃游戏 2：
- 给出一个非负整数数组，你最初定位在数组的第一个位置,
- 数组中的每个元素代表你在那个位置可以跳跃的最大长度,
- 返回 使用最少的跳跃次数到达数组的最后一个位置
- a+. 二维矩阵
- 顺时针打印二维矩阵
- 给出一个二维矩阵，找到一个路径(从某个左上角到某个角右下)使这条路径的值最大

### 数组去重

```js
function uniq(array) {
  let seen = {};

  return array.reduce((result, current) => {
    if (current in seen) {
      return result;
    }
    seen[current] = true;
    return result.concat(current);
  }, []);
}

function unique(arr) {
  const hashTable = {};
  const data = [];
  for (let i = 0; i < arr.length; i++) {
    const key = arr[i];
    if (!hashTable[key]) {
      hashTable[key] = true;
      data.push(key);
    }
  }
  return data;
}

function unique1(arr) {
  return Array.from(new Set(arr));
}
```

### 数组、字符串的子集位置查询

```js
function indexOfArray(target, tool) {
  for (var i = 0, targetLen = target.length; i < targetLen; i++) {
    for (var j = 0, toolLen = tool.length; j < toolLen; j++) {
      if (target[i + j] !== tool[j]) {
        break; // j++ 是在循环体结束后自增，使用 break 则在自增前就跳出循环了
      }
    }
    if (j === toolLen) {
      return i;
    }
  }
  return -1;
}

console.log(indexOfArray('abcdedfg', 'ed'));
```

### 根据筛选条件从目标数组中返回符合条件的子集

```js
function arrayFilter(target, tool) {
  var result = [];
  for (var i = 0, len = target.length; i < len; i++) {
    var keep = true;
    for (var key in tool) {
      if (typeof target[i][key] === 'undefined' || target[i][key] !== tool[key]) {
        keep = false;
        break;
      }
    }
    if (keep) {
      result.push(target[i]);
    }
  }
  return result;
}

function arrayFilterTest() {
  var target = [
    { name: 'Jack', age: 18, sex: 'f' },
    { name: 'Jack', age: 20 },
    { name: 'Mike', age: 25 },
  ];

  console.log('arrayFilter test: ', arrayFilter(target, { age: 20 }));
  console.log('arrayFilter test: ', arrayFilter(target, { num: 10 }));
  console.log('arrayFilter test: ', arrayFilter(target, {}));
}
```

### 合并两个有序数组

```js
function mergeSortedArray(arrA, arrB) {
  var result = [];
  var i = 0,
    j = 0,
    targetLen = arrA.length,
    toolLen = arrB.length;
  while (i < targetLen && j < toolLen) {
    if (arrA[i] < arrB[j]) {
      result.push(arrA[i++]);
    } else {
      result.push(arrB[j++]);
    }
  }
  while (i < targetLen) {
    result.push(arrA[i++]);
  }
  while (j < toolLen) {
    result.push(arrB[j++]);
  }
  return result;
}
```

### 合并数组

```js
// 给一个数组如：[[“a”,”b”,”c”],[“d”,”e”],…..]得到[ad,ae,bd,be,cd,ce]
function mapConcat(target) {
  var res = target.reduce(function(pre, next) {
    var ret = [];
    pre.forEach(function(preItem) {
      next.forEach(function(nextItem) {
        if (preItem !== nextItem) {
          // 去掉aa这种情况
          ret.push(preItem + nextItem);
        }
      });
    });
    return ret;
  });
  return res;
}

function mapConcatTest() {
  // var target = [['a', 'b', 'c'], ['d', 'e'], ['f', 'g', 'h'], ['j', 'm']];
  var target = [
    ['a', 'b', 'c'],
    ['a', 'b'],
  ];
  console.log('\nmapConcatTest:\n', mapConcat(target));
}
// mapConcatTest();

// 求整数数组的最大子串和，如 [-23, 17, -7, 11, -2, 1, -34] 的最大子串和是21，对应子串是 [17, -7, 11]
function maxSeqSum(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const len = arr.length;
  let maxSum = arr[0];
  let seqSum = arr[0];
  for (let i = 1; i < len; i++) {
    if (seqSum <= 0) {
      seqSum = arr[i];
    } else {
      seqSum += arr[i];
    }
    if (seqSum > maxSum) {
      maxSum = seqSum;
    }
  }
  return maxSum;
}
function maxSeqSumTest() {
  console.log(maxSeqSum([-23, 17, -7, 11, -2, 1, -34]));
  console.log(maxSeqSum([1, -2, 3, 10, -4, 7, 2, -5]));
  console.log(maxSeqSum([-1]));
}
// maxSeqSumTest();
```

### 数组最长无重复子串查找

查找没有重复的最长子串，若使用哈希表判断重复的话，就要重新定位，可以将哈希的 value=数组元素当前序号

```js
function longestSubArray(target) {
  var lastStart, lastLen, maxStart, maxLen;
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;

  for (var i = 1, len = target.length; i < len; i++) {
    var noRepeat = true;
    for (var j = lastStart; j < lastStart + lastLen; j++) {
      if (target[i] === target[j]) {
        noRepeat = false;
        if (maxLen < lastLen) {
          maxLen = lastLen;
          maxStart = lastStart;
        }
        i = lastStart = i - (lastStart + lastLen - j) + 1;
        lastLen = 1;
        break;
      }
    }
    if (noRepeat) {
      lastLen++;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
// 哈希版本，js实现起来简单、在数据量大的情况下会有优势
function longestSubArrayHash(target) {
  var lastStart,
    lastLen,
    maxStart,
    maxLen,
    last = {};
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;
  last[target[lastStart]] = lastStart;

  for (var i = 1, len = target.length; i < len; i++) {
    if (typeof last[target[i]] === 'undefined') {
      lastLen++;
      last[target[i]] = i;
    } else {
      if (maxLen < lastLen) {
        maxLen = lastLen;
        maxStart = lastStart;
      }
      i = lastStart = last[target[i]] + 1;
      last = {};
      last[target[lastStart]] = lastStart;
      lastLen = 1;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
function longestSubArrayTest() {
  var target = [1, 2, 3, 4, 3, 6, 8, 9, 10, 14, 15, 8, 9];
  console.log('\nlongestSubArray test:\n', longestSubArray(target));
  console.log('\nlongestSubArrayHash test:\n', longestSubArrayHash(target));
}
```

### 数组重复次数最多的子串查找

查重，输出重复次数最多的元素及其重复次数。

```js
function countSubArray(target) {
  var sub = {};
  var max = {
    num: 1,
    index: 0,
  };
  for (var i = 0, len = target.length; i < len; i++) {
    if (!sub.hasOwnProperty(target[i])) {
      sub[target[i]] = {
        num: 1,
        index: i,
      };
    } else {
      var current = sub[target[i]];
      current.num++;
      if (max.num < current.num) {
        max.num = current.num;
        max.index = current.index;
      }
    }
  }
  return {
    element: target[max.index],
    index: max.index,
    count: max.num,
  };
}
function countSubArrayTest() {
  var target = [2, 2, 2, 4, 4, 11, 11, 5, 15, 11, 17, 11, 80, 11];
  var target1 = ['qwe', 'as', 'dsfw', 'as', 'kou', 'lpi', 'as', 'jei', 'as'];
  console.log('\ncountSubArrayTest test:\n', countSubArray(target1));
}
```

### 查询字符串第一个不重复字母

查询给定字符串“abcba”，处理得到第一个不重复字母，c

```js
function queryFirstUniqueItem(target) {
  var items = {};
  var last = [];
  for (var i = 0, l = target.length; i < l; i++) {
    var item = target[i];
    if (!items.hasOwnProperty(item)) {
      last.push(i);
      items[item] = i;
    } else {
      var index = last.indexOf(items[item]);
      if (index >= 0) {
        last.splice(index, 1);
      }
    }
  }
  var ret = '';
  if (last.length) {
    ret = target[last[0]];
  }
  return ret;
}
function queryFirstUniqueItemTest() {
  var a = 'abdcbadegceg';
  var ret = queryFirstUniqueItem(a);
  console.log('ret: ', ret);
  console.log('ret: ', !ret);
}
```

### 是否有序

```js
function isSorted(array) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    let next = array[i + 1];
    if (next && current > next) {
      // exit as soon as we know the array isn't sorted
      return false;
    }
  }
  return true;
}

/// tests

import { test } from 'ava';

test(t => t.is(isSorted([]), true));
test(t => t.is(isSorted([-Infinity, -5, 0, 3, 9]), true));
test(t => t.is(isSorted([3, 9, -3, 10]), false));
```

### remove-element

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
  let index = nums.indexOf(val);
  while (index > -1) {
    nums.splice(index, 1);
    index = nums.indexOf(val);
  }
  return nums.length;
};

const nums = [3, 2, 2, 3];
const nums1 = [0, 1, 2, 2, 3, 0, 4, 2];
console.log('result', removeElement(nums, 3));
console.log('result1', removeElement(nums1, 2));
```

### search-insert-position

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  let index = nums.indexOf(target);
  if (index === -1) {
    const newNums = [...nums, target].sort(function(a, b) {
      if (a < b) return -1;
      else if (a > b) return 1;
      else return 0;
    });
    index = newNums.indexOf(target);
  }
  return index;
};
```

### plus-one

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  return (parseInt(digits.join('')) + 1 + '').split('').map(elm => parseInt(elm));
};

const nums = [6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3];
console.log('result', plusOne(nums));
```

### remove-duplicates-from-sorted-array

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const map = {};
  nums.forEach((elm, index) => {
    if (elm === nums[index + 1]) {
      nums.splice(index + 1, 1);
    }
  });
  return nums;
};

const nums = [0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4];
const nums1 = [1, 1, 2];
console.log('result', removeDuplicates(nums));
console.log('result1', removeDuplicates(nums1));
```

### 查找第 K 大的数

```js
function findKMax(a, k) {
  // 查找第 K大的数
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  let len = a.length - key;
  while (len !== k) {
    if (len > k) {
      key = partition(a, key + 1, right);
    } else {
      key = partition(a, left, key - 1);
    }
    len = a.length - key;
  }
  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让key为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把key现在所在的下标返回
}
const arr = [5, 4, 3, 2, 1, 6];
const KMax = findKMax(arr, 1);
console.log(KMax);
```

### 查找第 K 小的数

```js
function findKMin(a, k) {
  // 查找第 K 小的数
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  while (key !== k - 1) {
    if (key > k - 1) {
      key = partition(a, left, key - 1);
    } else {
      key = partition(a, key + 1, right);
    }
  }
  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让 key 为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果 key 小于 a[right]，则 right 递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果 key 大于 a[left]，则 left 递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把 key 现在所在的下标返回
}
const arr = [5, 4, 3, 2, 1, 6];
const KMin = findKMin(arr, 2);
console.log(KMin);
```
