---
layout: CustomPages
title: 链表
date: 2020-11-22
aside: false
draft: true
---

## 链表

### 经典解法

链表是实现很多复杂数据结构的基础，经典解法如下。

1. **利用快慢指针(有时候需要用到三个指针)**

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。

2. **构建一个虚假的链表头**

一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条 if else 语句。比较简洁的写法是创建一个空的链表头，直接往其后面添加元素即可，最后返回这个空的链表头的下一个节点即可。

**建议：**在解决链表的题目时，可以在纸上或者白板上画出节点之间的相互关系，然后画出修改的方法，既可以帮助你分析问题，又可以在面试的时候，帮助面试官清楚地看到你的思路。

### 例题分析

LeetCode 第 25 题：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：

- 你的算法只能使用常数的额外空间。

- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：

给定这个链表：`1->2->3->4->5`

当 k=2 时，应当返回：`2->1->4->3->5`

当 k=3 时，应当返回：`3->2->1->4->5`

解题思路

这道题考察了两个知识点：

1.  对链表翻转算法是否熟悉
2.  对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif)

1.  将 curr 指向的下一节点保存到 next 指针；

2.  curr 指向 prev，一起前进一步；

3.  重复之前步骤，直到 k 个元素翻转完毕；

4.  当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。

**注意**：这道题是“LeetCode 第 24 题，两个一组翻转链表“的扩展，即当 k 等于 2 时，第 25 题就变成了第 24 题。

### 怎么判断一个链表成环？

后项指针的哈希表（把所有的指针放到一个 map 中，如果其中一个指针已经出现在 map 中，那么就可以确定已经成环了。）

### Code

```js
function Chain(key, value) {
  this.next = null;
  this.key = key;
  this.value = value;
  this.length = 1;
}

// 插入元素
Chain.prototype.insertAfter = function(pos, key, value) {
  var currentObj = this;
  var addObj = {
    key: key,
    value: value,
  };

  // 循环
  while (currentObj.key !== pos) {
    currentObj = currentObj.next;
  }

  // 找到元素
  addObj.next = currentObj.next;
  currentObj.next = addObj;
  this.length++;
  return this;
};

// 删除元素
Chain.prototype.delete = function(key) {
  var last = null;
  var currentObj = this;
  // 循环
  while (currentObj.key !== key) {
    last = currentObj;
    currentObj = currentObj.next;
  }
  // 找到元素
  last.next = currentObj.next;
  this.length--;
  return this;
};

// 查找元素
Chain.prototype.find = function(key) {
  var currentObj = this;
  // 循环
  while (currentObj.key !== key) {
    currentObj = currentObj.next;
  }
  // 找到元素
  return currentObj.value;
};

Chain.prototype.forEach = function(fn) {
  var currentObj = this;
  // 循环
  while (currentObj.next !== null) {
    fn({ key: currentObj.key, value: currentObj.value });
    currentObj = currentObj.next;
  }
  fn({ key: currentObj.key, value: currentObj.value });
};

function test() {
  var chain = new Chain('header', 'head value');
  chain.insertAfter('header', 'second', 'next to header');
  chain.insertAfter('second', '3rd', '3rd value');
  chain.insertAfter('3rd', '4th', '4th value');
  chain.insertAfter('4th', '5th', '5th value');
  console.log('add to end', JSON.stringify(chain));

  chain.insertAfter('3rd', 'add4th', 'add 4th value');
  console.log('insert between', JSON.stringify(chain));

  chain.delete('3rd');
  console.log('delete 3rd', JSON.stringify(chain));

  var temp = chain.delete('add4th').find('5th');
  console.log('5th: ', temp);

  console.log('chain.length', chain.length);

  chain.forEach(function(obj) {
    console.log(obj);
  });
}

test();
```

#### LinkedList

```js
export default class LinkedList {
  head: Node; // 头
  tail: Node; // 尾
  integrity = new Set(); // 完整的集合

  constructor() {
    this.head = new Node({});
  }

  isEmpty(): boolean {
    return !!this.head;
  }

  reverse(node: Node = this.head) {
    if (!node || !node.next) return node;
    const reversedNode = this.reverse(node.next);
    node.next.next = node;
    node.next = null;
    return reversedNode;
  }

  delete(node: Node) {
    let curr = this.head;
    let prev = null;
    while (curr) {
      if (curr === node) {
        if (prev) {
          prev.next = curr.next;
          curr = null;
        } else {
          this.head = curr.next;
        }
        break;
      } else {
        prev = curr;
        curr = curr.next;
      }
    }
  }

  /**
   * Can be done with merge sort, can be O(nlogn) complexity
   * Similar to insertion sort
   * @complexity: O(n^2)
   */
  sort() {
    let { head } = this;

    while (head.hasNext()) {
      let innerHead = this.head;

      while (innerHead.hasNext()) {
        if (head.data > innerHead.data && head.data < innerHead.next.data) {
          // inserts
        }
        innerHead = innerHead.next;
      }
      head = head.next;
    }
  }

  /**
   * Find a node by its data
   */
  find(data: any): Node | false {
    let node = this.head;
    while (node.hasNext()) {
      if (node.data === data) {
        return node;
      }
      node = node.next;
    }
    return false;
  }

  insertAfter = this.insert;

  insert(data: any, begin?: Node): boolean {
    const node = new Node(data);
    if (begin && this.integrity.has(node)) return false;
    const headNext = (begin || this.head).next;

    this.integrity.add(node);
    this.head.next = node;
    this.head.next.next = headNext;

    return true;
  }

  toString() {
    const items = [];
    let node = this.head;
    items.push(node);

    while (node.next) {
      items.push(node.next);
      node = node.next;
    }

    return items;
  }
}

class Node {
  data: number | string = 0;

  next: Node | boolean = false;

  constructor(data: any = {}, next: Node | boolean = false) {
    this.data = data;
    this.next = next;
  }

  hasNext(): boolean {
    return this.next !== false;
  }

  /**
   * Remove first link
   */
  remove() {
    if (!this.isEmpty() && this.head.hasNext()) {
      this.head = this.head.next;
    }
  }

  /**
   * Append after node
   */
  append(data: any): boolean {
    const node = new Node(data);
    const { next } = this;

    node.next = next;
    this.next = node;

    return true;
  }
}
```
