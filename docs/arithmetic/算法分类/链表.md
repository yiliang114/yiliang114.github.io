---
layout: CustomPages
title: 链表
date: 2020-11-22
aside: false
draft: true
---

## 链表

链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。

### 经典解法

链表是实现很多复杂数据结构的基础，经典解法如下。

1. **利用快慢指针(有时候需要用到三个指针)**

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。

2. **构建一个虚假的链表头**

一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条 if else 语句。比较简洁的写法是创建一个空的链表头，直接往其后面添加元素即可，最后返回这个空的链表头的下一个节点即可。

### LeetCode 第 25 题

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：

- 你的算法只能使用常数的额外空间。
- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：

给定这个链表：`1->2->3->4->5`

当 k=2 时，应当返回：`2->1->4->3->5`

当 k=3 时，应当返回：`3->2->1->4->5`

解题思路

这道题考察了两个知识点：

1.  对链表翻转算法是否熟悉
2.  对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif)

1.  将 curr 指向的下一节点保存到 next 指针；
2.  curr 指向 prev，一起前进一步；
3.  重复之前步骤，直到 k 个元素翻转完毕；
4.  当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。

**注意**：这道题是“LeetCode 第 24 题，两个一组翻转链表“的扩展，即当 k 等于 2 时，第 25 题就变成了第 24 题。
