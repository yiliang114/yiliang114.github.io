---
layout: CustomPages
title: 动态规划-DP-斐波那契
date: 2020-11-14
aside: false
draft: true
---

# 斐波那契

（动态规划法）公式：

```js
function fib(n) {
  if (n <= 1) return n;
  let i = 1,
    j = 1;
  for (let k = 3; k <= n; k++) {
    const sum = i + j;
    i = j;
    j = sum;
  }
  return j;
}
```

```js
// 时间复杂度 O(n) 空间复杂度 O(1)
function fib(n) {
  if (n < 3) return 1;
  let f = 0,
    s = 1;
  while (--n) {
    // s += f; // f + s
    // f = s - f; // 旧 s 值
    [f, s] = [s, f + s];
  }
  return s;
}
```

递归法

```js
function fib(n) {
  switch (n) {
    case 0:
      return 0;
    case 1:
      return 1;
    default:
      return fib(n - 1) + fib(n - 2);
  }
}
```

加缓存的递归

```js
let fib2 = memoize(n => {
  switch (n) {
    case 0:
      return 0;
    case 1:
      return 1;
    default:
      return fib2(n - 1) + fib2(n - 2);
  }
});

function memoize(fn) {
  let cache = new Map();
  return _ => {
    if (!cache.has(_)) {
      cache.set(_, fn(_));
    }
    return cache.get(_);
  };
}
```

## 真题

### 1. 爬楼梯

[70. Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/description/)

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

定义一个数组 dp 存储上楼梯的方法数(为了方便讨论，数组下标从 1 开始)，dp[i] 表示走到第 i 个楼梯的方法数目。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。

考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

```js
function fib(n) {
  if (n <= 1) return n;
  let i = 1,
    j = 1;
  for (let k = 3; k <= n; k++) {
    const sum = i + j;
    i = j;
    j = sum;
  }
  return j;
}
```

### 2. 强盗抢劫

[198. House Robber (Easy)](https://leetcode.com/problems/house-robber/description/)

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。

由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以

```java
public int rob(int[] nums) {
    int pre2 = 0, pre1 = 0;
    for (int i = 0; i < nums.length; i++) {
        int cur = Math.max(pre2 + nums[i], pre1);
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}
```

### 3. 强盗在环形街区抢劫

[213. House Robber II (Medium)](https://leetcode.com/problems/house-robber-ii/description/)

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    if (n == 1) {
        return nums[0];
    }
    return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
}

private int rob(int[] nums, int first, int last) {
    int pre2 = 0, pre1 = 0;
    for (int i = first; i <= last; i++) {
        int cur = Math.max(pre1, pre2 + nums[i]);
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}
```

### 4. 信件错排

题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。

定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)\*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)\*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

### 5. 母牛生产

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：

### [1137].第-n-个泰波那契数

类似 fib， 只不过 tribonacci 是前 3 项之和。

```js
var tribonacci = function(n) {
  if (cache[n]) return cache[n];
  switch (n) {
    case 0:
      return 0;
    case 1:
    case 2:
      return 1;
    default:
      // 递归形式
      return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
  }
};
```
