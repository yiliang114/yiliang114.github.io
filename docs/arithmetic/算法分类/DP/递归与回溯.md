---
layout: CustomPages
title: 递归和回溯
date: 2020-11-22
aside: false
draft: true
---

# 递归和回溯

- 递归的基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小然后进行推导的过程。
- 回溯则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程。

递归是从问题的结果倒推，直到问题的规模缩小到寻常。 动态规划是从寻常入手， 逐步扩大规模到最优子结构。

## 递归(Recursion)

递归算法是一种调用自身函数的算法(二叉树的许多性质在定义上就满足递归)。

**举例**：(汉诺塔问题)有三个塔 A、B、C，一开始的时候，在塔 A 上放着 n 个盘子，它们自底向上按照从大到小的顺序叠放。现在要求将塔 A 中所有的盘子搬到塔 C 上，让你打印出搬运的步骤。在搬运的过程中，每次只能搬运一个盘子，另外，任何时候，无论在哪个塔上，大盘子不能放在小盘子的上面。

**解法**：

![](http://s0.lgstatic.com/i/image2/M01/91/12/CgoB5l2IjneAd7CsALPFsWgB1rw332.gif)

1. 从最终的结果出发，要把 n 个盘子按照大小顺序叠放在塔 C 上，就需要将塔 A 的底部最大的盘子搬到塔 C；
2. 为了实现步骤 1，需要将除了这个最大盘子之外的其余盘子都放到塔 B 上。

由上可知，将原来的问题规模从 n 个盘子变成了 `n - 1` 个盘子，即将 `n - 1` 个盘子转移到塔 B 上。

如果一个函数，能将 n 个盘子从塔 A，借助塔 B，搬到塔 C。那么，也可以利用该函数将 `n - 1` 个盘子从塔 A，借助塔 C，搬到塔 B。同理，不断地把问题规模变小，当 n 为 1，也就是只有 1 个盘子的时候，直接打印出步骤。

```js
function hanoi(A, B, C, n) {
  if (n > 0) {
    hanoi(A, C, B, n - 1);
    move(A, C);
    hanoi(B, A, C, n - 1);
  }
}
```

通俗来说，把要实现的递归函数看成是已经实现好的， 直接利用解决一些子问题，然后需要考虑的就是如何根据子问题的解以及当前面对的情况得出答案。这种算法也被称为自顶向下(`Top - Down`)的算法。

### 例题分析一

LeetCode 第 91 题，解码的方法。

一条包含字母  `A - Z`  的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
'Z' -> 26
```

给定一个只包含数字的非空字符串，请计算解码方法的总数。

#### 解题思路

1.  就例题中的第二个例子，给定编码后的消息是字符串“226”，如果对其中“22”的解码有 m 种可能，那么，加多一个“6”在最后，相当于在最终解密出来的字符串里多了一个“F”字符而已，总体的解码还是只有 m 种。

2.  对于“6”而言，如果它的前面是”1”或者“2”，那么它就有可能是“16”，“26”，所以还可以再往前看一个字符，发现它是“26”。而前面的解码组合是 k 个，那么在这 k 个解出的编码里，添加一个“Z”，所以总的解码个数就是 m+k。

#### 代码实现

```js
function numDecodings(s) {
  if (s.charAt(0) == '0') return;

  const chars = s.split();
  return decode(chars, chars.length - 1);
}

// 字符串转换成字符数组，利用递归函数  decode，从最后一个字符向前递归
function decode(chars, index) {
  //  处理到了第一个字符,只能有一种解码方法，返回  1
  if (index <= 0) return 1;

  let count = 0;

  const curr = chars[index];
  const prev = chars[index - 1];

  //  当前字符比  “0”  大，则直接利用它之前的字符串所求得的结果
  if (curr > '0') {
    count = decode(chars, index - 1);
  }

  //  由前一个字符和当前字符所构成的数字，值必须要在  1  到  26  之间，否则无法进行解码
  if (prev == '1' || (prev == '2' && curr <= '6')) {
    count += decode(chars, index - 2);
  }

  return count;
}
```

#### 解题模板

**解题步骤**

1.  判断当前情况是否非法，如果非法就立即返回，这一步也被称为完整性检查(Sanity Check)。例如，看看当前处理的情况是否越界，是否出现了不满足条件的情况。通常，这一部分代码都是写在最前面的。
2.  判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况。
3.  将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码的例子中，我们将问题的规模缩小了一个。
4.  利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案。

**代码实现**

```js
function fn(n) {
    //  第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
    }

//  第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
    }

//  第三步：缩小问题规模
    result1 = fn(n1)
    result2 = fn(n2)
    ...

//  第四步:  整合结果
    return combine(result1, result2)
}
```

### 例题分析二

LeetCode 第 247 题：找到所有长度为 n 的中心对称数。

**示例**

输入:  n = 2

输出: `["11","69","88","96"]`

#### 解题思路

![](http://s0.lgstatic.com/i/image2/M01/91/32/CgotOV2IjniAGk33AEvgAuHp84Y570.gif)

- 当 n=0 的时候，应该输出空字符串：“ ”。

- 当 n=1 的时候，也就是长度为 1 的中心对称数有：0，1，8。

- 当 n=2 的时候，长度为 2 的中心对称数有：11， 69，88，96。注意：00 并不是一个合法的结果。

- 当 n=3 的时候，只需要在长度为 1 的合法中心对称数的基础上，不断地在两边添加 11，69，88，96 就可以了。

\[101, 609, 808, 906,     111, 619, 818, 916,     181, 689, 888, 986\]

随着 n 不断地增长，我们只需要在长度为 n\-2 的中心对称数两边添加 11，69，88，96 即可。

#### 代码实现

List<String> helper(int n, int m) {
    //  第一步：判断输入或者状态是否非法？
    if (n < 0 || m < 0 || n > m) {
        throw new IllegalArgumentException("invalid input");
  }

//  第二步：判读递归是否应当结束?
    if (n == 0) return new ArrayList<String>(Arrays.asList(""));
    if (n == 1) return new ArrayList<String>(Arrays.asList("0", "1", "8"));

//  第三步：缩小问题规模
    List<String> list = helper(n \- 2, m);

//  第四步:  整合结果
    List<String> res = new ArrayList<String>();

for (int i = 0; i < list.size(); i++) {
        String s = list.get(i);

if (n != m) res.add("0" + s + "0");

res.add("1" + s + "1");
        res.add("6" + s + "9");
        res.add("8" + s + "8");
        res.add("9" + s + "6");
    }

return res;
}

#### 算法分析

分析非递归算法的时间复杂度非常直接，例如，前一节课里分析过冒泡排序以及插入排序的时间复杂度，分析方法就是数有多少层循环，由于每层循环里面执行的操作都是对比和交换，时间复杂度是 O(1)，所以，最终的时间复杂度就是将每层循环的长度相乘。

分析递归算法推荐两种方法：

- 迭代法

- 公式法

### 迭代法

**举例**：分析汉诺塔递归函数的时间复杂度。

void hano(char A, char B, char C, int n) {
    if (n > 0) {
        hano(A, C, B, n - 1);
        move(A, C);
        hano(B, A, C, n - 1);
    }
}

假设这个递归函数的运行时间是 T(n)。

1\. if 语句(一般取 if 块或 else 块之间最大的时间复杂度)中，比较和判断 n 的大小，CPU 的执行时间为 1 个单位。

2\. 两次调用递归函数，每次都使问题的规模减少 1 个，得到两倍的 T(`n - 1`)。打印输出的语句，CPU 的执行时间也为 1 个单位。因此得出：T(n) = 1 + 2×T(n \- 1) + 1。

此处 if 语句和打印输出语句的执行时间与问题规模 n 无关，因此它们的算法时间复杂度可以记为 O(1)，表达式变为：T(n) = 2×T(n \- 1) + O(1)。

当 n=0 的时候，T(0) = 1，因为当没有盘子的时候，if 语句也要进行一次比较，判断 n 是否大于 0。

3\. 用迭代法将 T(n) 进行展开。

T(n \- 1) = 2×T(n \- 2) + 1，以此类推，不断地代入到 T(n) 的表达式当中，得到如下关系：

T(n) = 2× (2×T(n \- 2) + 1) + 1 = 22×T(n \- 2) + (2 + 1)

T(n) = 2×(2× (2×T(n \- 3) + 1) + 1) + 1 = 23×T(n \- 3) + (4 + 2 + 1)

T(n) = 2×(2×(2×(2×T(n \- 4) + 1) + 1) + 1) + 1 = 24×T(n \- 4) + (8 + 4 + 2 + 1)

…

T(n) = 2k×T(n \- k) + (2k \- 1)

其中，1 + 2 + 4 + 8 + … 是一个等比数列，由求和公式得到 2k \- 1。当 k 等于 n 的时候，T(n) = 2n×T(0) + (2n \- 1)，由于 T(0) 等于 1，所以最终 T(n) = 2×2n \- 1。

对 T(n) 求 O 的值得到：O(n) = O(T(n)) = O(2×2n \- 1) ，忽略掉常量和系数，O(n) = O(2n)。

所以，整个算法的时间复杂度就是 O(2n)。

而很难通过迭代法推导出比较复杂的时间复杂度的时候，可以借用公式法。

### 公式法

公式法可以说是计算递归函数复杂度最方便的工具，当递归函数的时间执行函数满足如下的关系式时，我们可以利用公式法：T(n) = a×T(n/b) + f(n)。

其中，f(n) 是每次递归完毕之后额外的计算执行时间。例如，在归并排序中，每次递归处理完两边的数组后，我们需要执行合并的操作，那么这个操作的执行时间就是 f(n)。

当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(n^logba)。

由于时间复杂度求的是上界(upper bound)，通过对比递归部分的时间复杂度和 f(n) 的大小关系，得出最后的整体时间复杂度。牢记以下三种情况和相应公式：

1.  当递归部分的执行时间 nlog(b)a 大于 f(n) 的时候，最终的时间复杂度就是  O(n^logba)。

2.  当递归部分的执行时间 nlog(b)a 小于 f(n) 的时候，最终的时间复杂度就是 f(n)。

3.  当递归部分的执行时间 nlog(b)a 等于 f(n) 的时候，最终的时间复杂度就是  O(n^logba)logn。

**举例 1**：分析归并排序的时间复杂度。

T(n) = 2T(n/2) + n

a = 2，b = 2，f(n) = n

logba = 1，n1 = n

符合第三种情况，最终的时间复杂度就是 O(nlogn)。

**举例 2**：分析下面函数的时间复杂度。

int recursiveFn(int n) {
    if (n == 0) {
        return 0;
    }
    return recursiveFn(n / 4) + recursiveFn(n / 4);
}

得出时间执行函数：T(n) =  2×T(n/4) + 1，a = 2，b = 4，f(n) = 1。

代入公式得到：n^log42 = n0.5，当 n>1 的时候，n0.5\>1，因此，时间复杂度就是  O(n0.5)。

**举例 3**：已知时间执行函数如下，分析时间复杂度。

T(n) = 3×T(n/2) + n2

a = 3，b = 2，f(n) = n2

最复杂的操作发生在递归完成之后，符合第二种情况。

代入公式得到：n^log23 = n1.48<n2，最后递归的时间复杂度是 O(n2)。

- **[4.1](#recursion--decimal-to-binary) Write a recursive function that returns the binary string of a given decimal number**
  Given `4` as the decimal input, the function should return `100`

  ```js
  decimalToBinary(3); // 11
  decimalToBinary(8); // 1000
  decimalToBinary(1000); // 1111101000

  function decimalToBinary(digit) {
    if (digit >= 1) {
      // If digit is not divisible by 2 then recursively return proceeding
      // binary of the digit minus 1, 1 is added for the leftover 1 digit
      if (digit % 2) {
        return decimalToBinary((digit - 1) / 2) + 1;
      } else {
        // Recursively return proceeding binary digits
        return decimalToBinary(digit / 2) + 0;
      }
    } else {
      // Exit condition
      return '';
    }
  }
  ```

  **View on Codepen:** http://codepen.io/kennymkchan/pen/OWYYKb?editors=0012

* **[4.2](#recursion--binary-search) Write a recursive function that performs a binary search**

  ```js
  function recursiveBinarySearch(array, value, leftPosition, rightPosition) {
    // Value DNE
    if (leftPosition > rightPosition) return -1;

    var middlePivot = Math.floor((leftPosition + rightPosition) / 2);
    if (array[middlePivot] === value) {
      return middlePivot;
    } else if (array[middlePivot] > value) {
      return recursiveBinarySearch(array, value, leftPosition, middlePivot - 1);
    } else {
      return recursiveBinarySearch(array, value, middlePivot + 1, rightPosition);
    }
  }
  ```

  **View on Codepen:** http://codepen.io/kennymkchan/pen/ygWWmK?editors=0012

**[⬆ back to top](#table-of-contents)**

## 回溯 (Backtracking)

回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。

基本思想类同于：

图的深度优先搜索
二叉树的后序遍历

### 算法思想

回溯实际上是一种试探算法，这种算法跟暴力搜索最大的不同在于，在回溯算法里，是一步一步地小心翼翼地进行向前试探，会对每一步探测到的情况进行评估，如果当前的情况已经无法满足要求，那么就没有必要继续进行下去，也就是说，它可以帮助我们避免走很多的弯路。

回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至可以返回多步，然后再去尝试别的路径和办法。这也就意味着，想要采用回溯算法，就必须保证，每次都有多种尝试的可能。

### 解题模板

**解题步骤**

1.  判断当前情况是否非法，如果非法就立即返回；

2.  当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回；

3.  当前情况下，遍历所有可能出现的情况并进行下一步的尝试；

4.  递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试。

**代码模板**

```js
function fn(n) {
//  第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
  }

//  第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
  }

//  遍历所有可能出现的情况
    for (all possible cases) {

//  第三步:  尝试下一步的可能性
        solution.push(case)
        //  递归
        result = fn(m)

//  第四步：回溯到上一步
        solution.pop(case)

    }

}
```

### 例题分析一

LeetCode 第 39 题：给定一个无重复元素的数组  candidates  和一个目标数  target ，找出  candidates  中所有可以使数字和为  target  的组合。candidates  中的数字可以无限制重复被选取。

说明：

- 所有数字(包括  target)都是正整数。

- 解集不能包含重复的组合。

**解题思路**

题目要求的是所有不重复的子集，而且子集里的元素的值的总和等于一个给定的目标。

**思路 1**：暴力法。

罗列出所有的子集组合，然后逐个判断它们的总和是否为给定的目标值。解法非常慢。

**思路 2**：回溯法。

1.  从一个空的集合开始，小心翼翼地往里面添加元素。

2.  每次添加，检查一下当前的总和是否等于给定的目标。

3.  如果总和已经超出了目标，说明没有必要再尝试其他的元素了，返回并尝试其他的元素；

4.  如果总和等于目标，就把当前的组合添加到结果当中，表明我们找到了一种满足要求的组合，同时返回，并试图寻找其他的集合。

### 代码实现

```js
int\[\]\[\] combinationSum(int\[\] candidates, int target) {
    int\[\]\[\] results;
    backtracking(candidates, target, 0, \[\], results \-  换另外一种颜色高亮);
    return results;
}

void backtracking = (int\[\] candidates, int target, int start, int\[\] solution, int\[\]\[\] results) => {
    if (target < 0) {
        return;
  }

if (target === 0) {
        results.push(solution);
        return;
  }

for (int i = start; i < candidates.length; i++) {
        solution.push(candidates\[i\]);
        backtracking(candidates, target \- candidates\[i\], i, solution, results);
        solution.pop();

}

}
```

在主函数里：

1.  定义一个 results 数组用来保存最终的结果；

2.  调用函数 backtracking，并将初始的情况以及 results 传递进去，这里的初始情况就是从第一个元素开始尝试，而且初始的子集为空。

在 backtracking 函数里：

1.  检查当前的元素总和是否已经超出了目标给定的值，每添加进一个新的元素时，就将它从目标总和中减去；

2.  如果总和已经超出了目标给定值，就立即返回，去尝试其他的数值；

3.  如果总和刚好等于目标值，就把当前的子集添加到结果中。

在循环体内：

1.  每次添加了一个新的元素，立即递归调用 backtracking，看是否找到了合适的子集

2.  递归完毕后，要把上次尝试的元素从子集里删除，这是最重要的。

以上，就完成了回溯。

提示：这是一个最经典的回溯的题目，麻雀虽小，但五脏俱全。它完整地体现了回溯算法的各个阶段。

### 例题分析二

LeetCode 第 51 题， 在一个 N×N 的国际象棋棋盘上放置 N 个皇后，每行一个并使她们不能互相攻击。给定一个整数 N，返回 N 皇后不同的的解决方案的数量。

### 解题思路

解决 N 皇后问题的关键就是如何判断当前各个皇后的摆放是否合法。

![](http://s0.lgstatic.com/i/image2/M01/91/12/CgoB5l2IjnmALbFsAC7XEvsRn6M912.gif)

利用一个数组 columns\[\] 来记录每一行里皇后所在的列。例如，第一行的皇后如果放置在第 5 列的位置上，那么 columns\[0\] = 6。从第一行开始放置皇后，每行只放置一个，假设之前的摆放都不会产生冲突，现在将皇后放在第 row 行第 col 列上，检查一下这样的摆放是否合理。

方法就是沿着两个方向检查是否存在冲突就可以了。

### 代码实现

首先，从第一行开始直到第 row 行的前一行为止，看那一行所放置的皇后是否在 col 列上，或者是不是在它的对角线上，代码如下。

boolean check(int row, int col, int\[\] columns) {
    for (int r = 0; r < row; r++) {
        if (columns\[r\] == col || row \- r == Math.abs(columns\[r\] \- col)) {
            return false;
        }
    }
    return true;
}

然后进行回溯的操作，代码如下。

int count;

int totalNQueens(int n) {
    count = 0;
    backtracking(n, 0, new int\[n\]);
    return count;
}

void backtracking(int n, int row, int\[\] columns) {
    //  是否在所有 n 行里都摆放好了皇后？
    if (row == n) {
        count++; //  找到了新的摆放方法
        return;
  }

//  尝试着将皇后放置在当前行中的每一列
    for (int col = 0; col < n; col++) {
        columns\[row\] = col;

//  检查是否合法，如果合法就继续到下一行
        if (check(row, col, columns)) {
            backtracking(n, row + 1, columns);
        }

//  如果不合法，就不要把皇后放在这列中(回溯)
        columns\[row\] = \-1;
    }
}

### 算法分析

回溯其实是用递归实现的，因此我们在分析回溯的时间复杂度时，其实就是在对递归函数进行分析，方法和之前介绍的一样。

**举例**：分析一下 N 皇后的时间复杂度。

假设 backtracking 函数的执行时间是 T(n)。

**解法**：

1.  每次都必须遍历所有的列，一共有 n 列。

2.  在每次遍历中，先要利用 check 函数检查当前的摆放方法会不会产生冲突，检查的时间复杂度由当前所在的行决定，上限是 n，所以总时间复杂度就是  O(n2)。

3.  递归地尝试着每种摆放，当我们放好了第一个皇后，剩下要处理的之后 `n - 1` 个皇后，问题的规模减少了一个，于是执行时间变成了 T(n \- 1)。

最终得到了 T(n) 的表达式：T(n) = n×T(n \- 1) + O(n2)。

利用迭代法将 T(n) 展开得到：

T(n) = n×((n \- 1)×T(n \- 2) +  (n \- 1)2 + n2

…

T(n) = n×(n \- 1)×(n \- 2)× … ×1 + 1 + 22 + 32 + … (n \- 1)2 + n2

前面一部分是阶乘，后面一部分是平方求和，根据公式最后得到：

T(n) = n! + n(n+1)(2n+1)/6

O(T(n)) = n! + O(n3)

由于 n!>n3，因此，它的上界就是 n!，即：O(T(n)) = n!

## 递归

定义： 递归算法是一种直接或者间接调用自身函数或者方法的算法。

算法中使用递归可以很简单地完成一些用循环实现的功能，比如二叉树的左中右序遍历。递归在算法中有非常广泛的使用，
包括现在日趋流行的函数式编程。

> 纯粹的函数式编程中没有循环，只有递归。

接下来我们来讲解以下递归。通俗来说，递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解

### 递归的三个要素

1. 一个问题的解可以分解为几个子问题的解
2. 子问题的求解思路除了规模之外，没有任何区别
3. 有递归终止条件

我这里列举了几道算法题目，这几道算法题目都可以用递归轻松写出来：

- 递归实现 sum

- 二叉树的遍历

- 走楼梯问题

- 汉诺塔问题

## 动态规划

`如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。` 这句话需要一定的时间来消化,
如果不理解，可以过一段时间再来看。

递归的解决问题非常符合人的直觉，代码写起来比较简单。但是我们通过分析(可以尝试画一个递归树)，可以看出递归在缩小问题规模的同时可能会
重复计算。 我通过递归的方式来解决这个问题，同时内部维护了一个缓存
来存储计算过的运算，那么我们可以减少很多运算。 这其实和动态规划有着异曲同工的地方。

我们结合求和问题来讲解一下, 题目是给定一个数组，求出数组中所有项的和，要求使用递归实现。

代码：

```js
function sum(nums) {
  if (nums.length === 0) return 0;
  if (nums.length === 1) return nums[0];

  return nums[0] + sum(nums.slice(1));
}
```

我们用递归树来直观地看一下。

这种做法本身没有问题，但是每次执行一个函数都有一定的开销，拿 JS 引擎执行 JS 来说，
每次函数执行都会进行入栈操作，并进行预处理和执行过程，所以对于内存来说是一个挑战。
很容易造成爆栈。

> 浏览器中的 JS 引擎对于代码执行栈的长度是有限制的，超过会爆栈，抛出异常。

我们再举一个更加明显的例子，问题描述：

一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？

代码：

```js
function climbStairs(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  return climbStairs(n - 1) + climbStairs(n - 2);
}
```

这道题和 fibnacci 数列一摸一样。
可以看出这里面有很多重复计算，我们可以使用一个 hashtable 去缓存中间计算结果，从而省去不必要的计算。
那么动态规划是怎么解决这个问题呢？ 答案就是“查表”。

刚才我们说了`递归是从问题的结果倒推，直到问题的规模缩小到寻常。 动态规划是从寻常入手， 逐步扩大规模到最优子结构。`

从刚才的两个例子，我想大家可能对前半句话有了一定的理解，我们接下来讲解下后半句。

如果爬楼梯的问题，使用动态规划，代码是这样的：

```js
function climbStairs(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;

  let a = 1;
  let b = 2;
  let temp;

  for (let i = 3; i <= n; i++) {
    temp = a + b;
    a = b;
    b = temp;
  }

  return temp;
}
```

> 虚线代表的是查表过程

这道题目是动态规划中最简单的问题了，因为设计到单个因素的变化，如果涉及到多个因素，就比较复杂了，比如著名的背包问题，挖金矿问题等。

对于单个因素的，我们最多只需要一个一维数组即可，对于如背包问题我们需要二维数组等更高纬度。

> 爬楼梯我们并没有使用一维数组，而是借助两个变量来实现的，空间复杂度是 O(1).
> 之所以能这么做，是因为爬楼梯问题的状态转移方程只和前两个有关，因此只需要存储这两个即可。 动态规划问题有时候有很多这种讨巧的方式，但并不是所有的

### 动态规划的两个要素

1. 状态转移方程

2. 临界条件

在上面讲解的爬楼梯问题中

```
f(1) 与 f(2) 就是【边界】
f(n) = f(n-1) + f(n-2) 就是【状态转移公式】

```

### 动态规划为什么要画表格

动态规划问题要画表格，但是有的人不知道为什么要画，就觉得这个是必然的，必要要画表格才是动态规划。

其实动态规划本质上是将大问题转化为小问题，然后大问题的解是和小问题有关联的，换句话说大问题可以由小问题进行计算得到。

这一点是和递归一样的， 但是动态规划是一种类似查表的方法来缩短时间复杂度和空间复杂度。

画表格的目的就是去不断推导，完成状态转移， 表格中的每一个 cell 都是一个`小问题`， 我们填表的过程其实就是在解决问题的过程，
我们先解决规模为寻常的情况，然后根据这个结果逐步推导，通常情况下，表格的右下角是问题的最大的规模，也就是我们想要求解的规模。

比如我们用动态规划解决背包问题， 其实就是在不断根据之前的小问题`A[i - 1][j] A[i -1][w - wj]`来询问：

1. 我是应该选择它
2. 还是不选择它

至于判断的标准很简单，就是价值最大，因此我们要做的就是对于选择和不选择两种情况分别求价值，然后取最大，最后更新 cell 即可。

## 例题

### 递归-分割数组

递归地将数组一分为二，直到只有一个元素

```js
const items = [];
function DivideArray(array) {
  switch (array.length) {
    case 1:
      items.push(array);
      return items;
    default: {
      const middle = Math.ceil(array.length / 2);
      const first = array.splice(middle);
      DivideArray(first);
      DivideArray(array);
      return items;
    }
  }
}
```

### 递归-拍平数组

取一个二维数组(数组中的数组)并“平化”它。换句话说，这意味着将多个数组合并在一起。Array.prototype.concat

```js
function Flatten(array, collector) {
  switch (array.length > 0) {
    case true: {
      const [first, ...rest] = array;
      return Flatten(rest, [...first, ...collector]);
    }
    default:
      return collector;
  }
}

export function FlattenRecursive(items: Array<any>): Array<any> {
  let concatedItems = [];

  for (let i = 0; i < items.length; i++) {
    Array.isArray(items[i])
      ? (concatedItems = concatedItems.concat(FlattenRecursive(items[i])))
      : concatedItems.push(items[i]);
  }

  return concatedItems;
}
```

### 阶梯问题

```js
/**
 * 阶梯问题
 * 假设一个楼梯有 N 阶台阶，人每次最多可以跨 M 阶，求总共的爬楼梯方案数。
 * 例如楼梯总共有3个台阶，人每次最多跨2个台阶，也就是说人每次可以走1个，也可以走2个，但最多不会超过2个，那么楼梯总共有这么几种走法：
 * 111，12，21
 */

var methods = [];
function countSteps(steps, max, method) {
  method = method || '';
  if (steps === 0) {
    methods.push(method);
    return method;
  }
  if (steps < max) {
    countSteps(steps, steps, method);
  } else {
    for (var i = 1; i <= max; i++) {
      countSteps(steps - i, max, method + String(i));
    }
  }
}

countSteps(4, 3);
console.log('methods', methods);

/**
 * 链式函数
 * 编写阶乘函数 fn，使得 fn(2)(3) = 6，fn(2)(3)(4) = 24
 * 这里用到递归、函数柯里化、valueOf几个点，注意()运算符是从左到右执行的
 */
function mul(x) {
  const fn = y => mul(x * y); // 返回一个函数，函数参数里面做乘法运算
  fn.valueOf = () => x; // 改写valueOf，在链式运算最后一步输出结果
  return fn;
}

/**
 * 汉诺塔问题
 * 编写函数输出汉诺塔移动轨迹，move(n, a, b, c)，n为盘子数量，a为源头，b为中转柱子，c为目标柱子
 */
function move(n, a, b, c) {
  if (n === 1) {
    console.log(`${a} --> ${c}`);
  } else {
    move(n - 1, a, c, b);
    move(1, a, b, c);
    move(n - 1, b, a, c);
  }
}

// move(5, 'A', 'B', 'C');
```

## 无题

### 递归

```js
export default str => {
  // 保存所有符合条件的IP地址
  let r = [];
  // 分四步递归处理ip分段
  let search = (cur, sub) => {
    // 边界条件
    if (cur.length === 4 && cur.join('') === str) {
      r.push(cur.join('.'));
    } else {
      // 正常的处理过程
      for (let i = 0, len = Math.min(3, sub.length), tmp; i < len; i++) {
        tmp = sub.substr(0, i + 1);
        if (tmp < 256) {
          search(cur.concat([tmp]), sub.substr(i + 1));
        }
      }
    }
  };
  search([], str);
  return r;
};
```

```js
export default (str, words) => {
  // 保存结果
  let result = [];
  // 记录数组的长度，做边界条件计算
  let num = words.length;
  // 递归函数体
  let range = (r, _arr) => {
    if (r.length === num) {
      result.push(r);
    } else {
      _arr.forEach((item, idx) => {
        let tmp = [].concat(_arr);
        tmp.splice(idx, 1);
        range(r.concat(item), tmp);
      });
    }
  };
  range([], words);
  // [0, 9, -1] filter 之后[0,9]
  return result
    .map(item => {
      return str.indexOf(item.join(''));
    })
    .filter(item => item !== -1)
    .sort();
};
```

### 扑克牌问题

有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；

> 最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；
>
> 问：原来那堆牌的顺序，用函数实现。

```js
function poke(arr) {
  let i = 1;
  let out = [];
  while (arr.length) {
    if (i % 2) {
      out.push(arr.shift());
    } else {
      arr.push(arr.shift());
    }
    i++;
  }
  return out;
}

function reverse(arr) {
  let i = 1;
  let out = [];
  while (arr.length) {
    if (i % 2) {
      out.unshift(arr.pop());
    } else {
      out.unshift(out.pop());
    }
    i++;
  }
  return out;
}

reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
// [1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]
```
