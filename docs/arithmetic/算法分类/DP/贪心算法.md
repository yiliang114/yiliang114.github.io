---
layout: CustomPages
title: 动态规划-DP-贪心算法
date: 2020-11-14
aside: false
draft: true
---

# 贪心算法

贪心算法(Greed algorithm) 是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望导致全局结果是最好或最优的算法。

分治算法(Divide and conquer algorithm) 字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

动态规划算法(Dynamic programming，DP) 通过将原问题分解为相对简单的子问题的方式来求解复杂问题。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。

贪婪算法虽然是一种比较直观的算法，但是比较难的地方在于证明它的正确性。
贪婪算法是一种在每一步选中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。

优点：对于一些问题，非常直观有效。

缺点：

1. 并不是所有问题都能用它去解决；
2. 得到的结果并一定不是正确的，因为这种算法容易过早地做出决定，从而没有办法达到最优解。

### 0-1 背包问题

能不能运用贪婪算法去解决？

有三种策略：

1.  选取价值最大的物品

2.  选择重量最轻的物品

3.  选取价值/重量比最大的物品

**策略 1**：每次尽可能选择价值最大的，行不通。举例说明如下。

物品有：A B C

重量分别是：25, 10, 10

价值分别是：100，80，80

根据策略，首先选取物品 A，接下来就不能再去选其他物品，但是，如果选取 B 和 C，结果会更好。

**策略 2**：每次尽可能选择轻的物品，行不通。举例说明如下。

物品有：A B C

重量分别为：25, 10, 10

价值分别为：100, 5, 5

根据策略，首先选取物品 B 和 C，接下来就不能选 A，但是，如果选 A，价值更大。

**策略 3**：每次尽可能选价值/重量比最大的，行不通。举例说明如下。

物品有：A B C

重量是：25, 10, 10

价值是：25, 10, 10

根据策略，三种物品的价值/重量比都是一样，如果选 A，答案不对，应该选 B 和 C。

由上，贪婪算法总是做出在当前看来是最好的选择。即，它不从整体的角度去考虑，仅仅对局部的最优解感兴趣。因此，只有当那些局部最优策略能产生全局最优策略的时候，才能用贪婪算法。

### 例题分析五

LeetCode 第 253 题，会议室 II，给定一系列会议的起始时间和结束时间，求最少需要多少个会议室就可以让这些会议顺利召开。

#### 解题思路

**思路 1**：暴力法。

- 把所有的会议组合找出来；

- 从最长的组合开始检查，看看各个会议之间有没有冲突；

- 直到发现一组会议没有冲突，那么它就是答案。

很明显，这样的解法是非常没有效率的。

**思路 2**：贪婪算法

- 会议按照起始时间顺序进行；

- 要给新的即将开始的会议找会议室时，先看当前有无空会议室；

- 有则在空会议室开会，无则开设一间新会议室。

#### 代码实现

int minMeetingRooms(Interval\[\] intervals) {
    if (intervals == null || intervals.length == 0)
        return 0;

//  将输入的一系列会议按照会议的起始时间排序。
    Arrays.sort(intervals, new Comparator<Interval>() {
        public int compare(Interval a, Interval b) { return a.start \- b.start; }
    });

//  用一个最小堆来维护目前开辟的所有会议室，最小堆里的会议室按照会议的结束时间排序。
    PriorityQueue<Interval> heap = new PriorityQueue<Interval>(intervals.length, new Comparator<Interval>() {
        public int compare(Interval a, Interval b) { return a.end \- b.end; }
    });

//  让第一个会议在第一个会议室里举行。
    heap.offer(intervals\[0\]);

for (int i = 1; i < intervals.length; i++) {
        //  从第二个会议开始，对于每个会议，我们都从最小堆里取出一个会议室，那么这个会议室里的会议一定是最早结束的。
        Interval interval = heap.poll();

if (intervals\[i\].start >= interval.end) {
        //  若当前要开的会议可以等会议室被腾出才开始，那么就可以重复利用这个会议室。
        interval.end = intervals\[i\].end;
      } else {
        //  否则，开一个新的会议室。
        heap.offer(intervals\[i\]);
    }

//  把旧的会议室也放入到最小堆里。
    heap.offer(interval);
    }
    //  最小堆里的会议室个数就是要求的答案，即最少的会议个数。
    return heap.size();
}

为什么贪婪算法能在这里成立？

每当遇到一个新的会议时，总是贪婪地从所有会议室里找出最先结束会议的那个。

为什么这样可以产生最优的结果？

若选择的会议室中会议未结束，则意味着需要开辟一个新会议室，这已经不是当前的最优解了

**建议**：贪婪算法考点在面试中相对于其他算法而言是比较轻的，大家只需要把常见的一些利用贪婪算法解题的题目多加练习即可。
