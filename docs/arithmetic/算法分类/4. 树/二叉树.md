---
layout: CustomPages
title: 二叉树
date: 2020-12-02
aside: false
draft: true
---

## 二叉树

挺重要的样子

### 平衡二叉树

```js
/*
 * @lc app=leetcode id=110 lang=javascript
 *
 * [110] Balanced Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function maxDepth(root) {
  if (root == null) return 0;
  const l = maxDepth(root.left);
  const r = maxDepth(root.right);
  if (l === false || r === false) return false;
  if (Math.abs(l - r) > 1) return false;
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
  if (root === null) return true;
  return !!maxDepth(root);
};
```

```js
/*
 * @lc app=leetcode id=110 lang=javascript
 *
 * [110] Balanced Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function maxDepth(root) {
  if (root == null) return 0;
  const l = maxDepth(root.left);
  const r = maxDepth(root.right);
  if (l === false || r === false) return false;
  if (Math.abs(l - r) > 1) return false;
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
  if (root === null) return true;
  return !!maxDepth(root);
};
```

### 合并二叉树

#### 递归

- 构造新 tree 的根节点
- 递归构造新 tree 根节点左子树
- 递归构造新 tree 根节点右子树

理解“树是一种递归的数据结构”

Time complexity : O(n)
Space complexity : O(n)

参考代码

```js
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
  // 递归，由于树是一种递归的数据结构，因此递归是符合直觉且比较简单的
  if (t1 === null) return t2;
  if (t2 === null) return t1;
  t1.val += t2.val;
  t1.left = mergeTrees(t1.left, t2.left);
  t1.right = mergeTrees(t1.right, t2.right);
  return t1;
};
```

#### 迭代

层次遍历，利用数据结构是队列。

参考代码

```java
class Solution2 {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2)
    {
      //t2合并到t1上,t1必须存在,如果不存在就结束。
      if(t1 ==NULL)
      {
          return t2;
      }
     vector<TreeNode*> node(2);
     node[0]=t1;
     node[1]=t2;

     queue<vector<TreeNode*>> data;
     data.push(node); //第一次出队列的数据就是root节点.


     while(!data.empty())
     {
         //出队列操作
         vector<TreeNode*> temp=data.front();
         data.pop();

         TreeNode*pt1=temp[0];
         TreeNode*pt2=temp[1];
         if(pt2==NULL)
         {
            continue;//维持pt1结构不变

         }
          //pt1如果null 是不入队列的。
          pt1->val+=pt2->val; // 结构不变，只修改节点数值
          //
         if(pt1->left ==NULL)
         {
            pt1->left =pt2->left; //结构发生生变化，不能如队列。该节点遍历将结束。
         }else
         {
             node[0]=pt1->left;
             node[1]=pt2->left;
             data.push(node); //结构不变，可以入队列操作

         }

        if(pt1->right ==NULL)
         {
            pt1->right =pt2->right; //结构发生生变化，不能如队列。该节点遍历将结束。
         }else
         {
             node[0]=pt1->right;
             node[1]=pt2->right;
             data.push(node);

         }
     }

     return t1;
    }
};
```

#### JS Code

```js
/*
 * @lc app=leetcode.cn id=617 lang=javascript
 *
 * [617] 合并二叉树
 * 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
注意: 合并必须从两个树的根节点开始。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
// 递归思想
var mergeTrees = function(t1, t2) {
  if (t1 === null && t2 === null) return null;
  if (t1 === null) return t2;
  if (t2 === null) return t1;
  const t3 = new TreeNode(t1.val + t2.val);
  t3.left = mergeTrees(t1.left, t2.left);
  t3.right = mergeTrees(t1.right, t2.right);
  return t3;
};
```
