---
layout: CustomPages
title: 合集 400-500
date: 2020.09.04
aside: false
draft: true
---

### [404].Sum-of-Left-Leaves

```js
/**
 * https://leetcode.com/problems/sum-of-left-leaves/description/
 * Difficulty:Easy
 *
 * Find the sum of all left leaves in a given binary tree.
 * Example:
 *     3
 *    / \
 *   9  20
 *      / \
 *    15   7
 * There are two left leaves in the binary tree, with values 9 and 15 respectively. Return [24].
 *
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
  return fn(root, false);
};

function fn(node, isLeft) {
  if (!node) return 0;
  if (!node.left && !node.right) {
    return isLeft ? node.val : 0;
  }

  return fn(node.left, true) + fn(node.right, false);
}
```

### 404

```js
// Sum of Left Leaves
// Find the sum of all left leaves in a given binary tree

//   3
// /   \
// 9    20
//    /   \
//   15   7

// There are two left leaves in the binary tree, with values 9 and 15 respectively. Return [24].

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const sumOfLeftLeavesAux = (root, sum, isLeft) => {
  if (root === null) return 0;
  if (!root.left && !root.right && isLeft) return root.val;
  if (root.left) sum += sumOfLeftLeavesAux(root.left, 0, true);
  if (root.right) sum += sumOfLeftLeavesAux(root.right, 0, false);
  return sum;
};

export default function sumOfLeftLeaves(root) {
  return sumOfLeftLeavesAux(root, 0, false);
}
```

### [412].fizz-buzz

```js
/*
 * @lc app=leetcode.cn id=412 lang=javascript
 *
 * [412] Fizz Buzz
 */
/**
 * @param {number} n
 * @return {string[]}
 */

// Accepted
// ✔ 8 / 8 cases passed(92 ms)
// ✔ Your runtime beats [70].8 % of javascript submissions
// ✔ Your memory usage beats [44].87 % of javascript submissions(37.3 MB)
var fizzBuzz1 = function(n) {
  let result = [],
    i = 1;
  while (i <= n) {
    if (i % 3 === 0 && i % 5 === 0) {
      result.push('FizzBuzz');
    } else if (i % 3 === 0) {
      result.push('Fizz');
    } else if (i % 5 === 0) {
      result.push('Buzz');
    } else {
      result.push(i + '');
    }
    i++;
  }
  return result;
};

// ✔ Accepted
// ✔ 8 / 8 cases passed(84 ms)
// ✔ Your runtime beats [91].18 % of javascript submissions
// ✔ Your memory usage beats [55].13 % of javascript submissions(37.3 MB)
var fizzBuzz = function(n) {
  let result = [0];
  for (let i = 1; i <= n; i++) {
    result[i] = i % 3 === 0 && i % 5 === 0 ? 'FizzBuzz' : i % 3 === 0 ? 'Fizz' : i % 5 === 0 ? 'Buzz' : i + '';
  }
  result.shift();
  return result;
};

console.log(fizzBuzz(1));
console.log(fizzBuzz(2));
console.log(fizzBuzz(3));
console.log(fizzBuzz(10));
console.log(fizzBuzz(15));
```

### [413].Arithmetic-Slices

```js
/**
 * https://leetcode.com/problems/arithmetic-slices/description/
 * Difficulty:Medium
 *
 * A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
 *
 * For example, these are arithmetic sequence:
 * 1, 3, 5, 7, 9
 * 7, 7, 7, 7
 * 3, -1, -5, -9
 *
 * The following sequence is not arithmetic.
 * 1, 1, 2, 5, 7
 *
 * A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.
 *
 * A slice (P, Q) of array A is called arithmetic if the sequence:
 *
 * A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.
 *
 * The function should return the number of arithmetic slices in the array A.
 *
 * Example:
 * A = [1, 2, 3, 4]
 *
 * return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
 *
 */

/**
 * @param {number[]} A
 * @return {number}
 */
var numberOfArithmeticSlices = function(A) {
  if (A.length < 3) return 0;
  var dp = [];
  if (A[2] - A[1] === A[1] - A[0]) {
    dp[2] = 1;
  } else {
    dp[2] = 0;
  }
  var result = dp[2];

  for (var i = 3; i < A.length; i++) {
    if (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {
      dp[i] = dp[i - 1] + 1;
      result += dp[i];
    } else {
      dp[i] = 0;
    }
  }

  return result;
};
```

### [415].Add-Strings 字符串相加

```js
/**
 * https://leetcode.com/problems/add-strings/description/
 * Difficulty:Easy
 *
 * Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
 * Note:
 *
 * The length of both num1 and num2 is < [5100].
 * Both num1 and num2 contains only digits [0].9.
 * Both num1 and num2 does not contain any leading zero.
 * You must not use any built-in BigInteger library or convert the inputs to integer directly.
 */

var addStrings = function(num1, num2) {
  var carry = 0;
  var len1 = num1.length;
  var len2 = num2.length;
  var forCount = Math.max(len1, len2);
  var newNum = '';
  for (var i = 0; i < forCount; i++) {
    var a = parseInt(num1[len1 - 1 - i]) || 0;
    var b = parseInt(num2[len2 - 1 - i]) || 0;
    var c = a + b + carry;
    carry = Math.floor(c / 10);
    var e = c % 10;
    newNum = e + newNum;
  }

  if (carry) {
    newNum = carry + newNum;
  }
  return newNum;
};

console.log(addStrings('12', '123') == '135');
```

```js
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function(num1, num2) {
  let i = num1.length - 1,
    j = num2.length - 1;
  let carry = 0;
  let res = '';
  while (i >= 0 || j >= 0) {
    let x = i >= 0 ? +num1[i] : 0;
    let y = j >= 0 ? +num2[j] : 0;
    let sum = x + y + carry;
    carry = Math.floor(sum / 10);
    let val = sum % 10;
    res = val + res;
    if (i >= 0) i--;
    if (j >= 0) j--;
  }
  if (carry) {
    res = carry + res;
  }
  return res;
};
```

### 415

```js
// [415]. Add Strings

// Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.

// Note:
// The length of both num1 and num2 is < [5100].
// Both num1 and num2 contains only digits [0].9.
// Both num1 and num2 does not contain any leading zero.
// You must not use any built-in BigInteger library or convert the inputs to integer directly.

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
export default function addStrings(num1, num2) {
  let carry = false;
  const str = [];
  for (let i = 0; i < Math.max(num1.length, num2.length) || carry; i++) {
    const a = i < num1.length ? num1[num1.length - 1 - i] : 0;
    const b = i < num2.length ? num2[num2.length - 1 - i] : 0;
    let sum = parseInt(a, 10) + parseInt(b, 10) + (carry === true ? 1 : 0);
    carry = sum > 9;
    sum %= 10;
    str.push(sum);
  }
  return str.reverse().join('');
}
```

### [416].Partition-Equal-Subset-Sum

```js
/**
 * https://leetcode.com/problems/partition-equal-subset-sum/description/
 * Difficulty:Medium
 *
 * Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
 * Note:
 * Each of the array element will not exceed [100].
 * The array size will not exceed [200].
 * Example 1:
 * Input: [1, 5, 11, 5]
 * Output: true
 * Explanation: The array can be partitioned as [1, 5, 5] and [11].
 * Example 2:
 * Input: [1, 2, 3, 5]
 * Output: false
 * Explanation: The array cannot be partitioned into equal sum subsets.
 */

/**
 *
 * 01背包问题
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  var sum = nums.reduce((a, b) => a + b, 0);
  if (sum % 2) return false;
  sum = sum / 2;

  var n = nums.length;
  var dp = [];

  while (dp.push(new Array(sum + 1).fill(0)) < n + 1);

  for (var i = 0; i < n + 1; i++) {
    dp[i][0] = 1;
  }

  for (var i = 1; i < n + 1; i++) {
    for (var j = 1; j < sum + 1; j++) {
      if (dp[i - 1][j]) dp[i][j] = 1;
      if (j >= nums[i - 1] && dp[i - 1][j - nums[i - 1]]) dp[i][j] = 1;
    }
  }

  // console.log(dp);

  return !!dp[n][sum];
};

console.log(canPartition([1, 5]));
console.log(canPartition([1, 5, 11, 5]));
// console.log(canPartition([1, 5, 11, 5, 1, 1]));
// console.log(canPartition([1, 5, 11, 5, 2]));
// console.log(canPartition([1, 5, 11, 5]));
// console.log(canPartition([1, 2, 3, 5]));
```

### [443].压缩字符串

```js
/*
 * @lc app=leetcode.cn id=443 lang=javascript
 *
 * [443] 压缩字符串
 */
/**
 * @param {character[]} chars
 * @return {number}
 */
// TODO: 原地修改
var compress = function(chars) {
  // 0 记录 chars[i] 1 记录次数
  let map = [],
    resp = '';
  for (let i = 0; i < chars.length; i++) {
    if (!map[0]) {
      map[0] = chars[i];
      map[1] = 1;
    } else {
      if (map[0] !== chars[i]) {
        resp += `${map[0]}${map[1] > 1 ? map[1] : ''}`;
        map[0] = chars[i];
        map[1] = 1;
        continue;
      }
      map[1]++;
    }
  }
  resp += `${map[0]}${map[1] > 1 ? map[1] : ''}`;
  return resp.length;
};

console.log(compress(['a', 'a', 'b', 'b', 'c', 'c', 'c']));
console.log(compress(['a']));
console.log(compress(['a', 'a', 'b', 'b', 'c', 'c', 'c']));
console.log(compress(['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b']));
```

### [447].Number-of-Boomerangs

```js
/**
 * https://leetcode.com/problems/number-of-boomerangs/description/
 * Difficulty:Easy
 *
 * Given n points in the plane that are all pairwise distinct,
 * a "boomerang" is a tuple of points (i, j, k) such that the distance
 * between i and j equals the distance between i and k (the order of the tuple matters).
 *
 * Find the number of boomerangs.
 * You may assume that n will be at most 500 and
 * coordinates of points are all in the range [-10000, 10000] (inclusive).
 *
 *
 *
 * Example:
 * Input:
 * [[0,0],[1,0],[2,0]]
 * Output:
 * 2
 * Explanation:
 * The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
 *
 *
 *
 * 解释
 *
 * 给定一个Point的数组, 找到所有的长度为3的Point数组(i, j, k)
 * 使得 i&j, i&k 的距离相同
 * 顺序有关
 *
 */

/**
 * @param {number[][]} points
 * @return {number}
 */
var numberOfBoomerangs = function(points) {
  if (points.length < 3) return 0;
  var ret = 0;
  for (var i = 0; i < points.length; i++) {
    var p1 = points[i];
    var disMap = {};

    for (var j = 0; j < points.length; j++) {
      if (i == j) continue;
      var p2 = points[j];
      var dis = getDis(p1, p2);
      if (disMap[dis] == undefined) disMap[dis] = 1;
      else disMap[dis] += 1;
    }

    for (var key in disMap) {
      var n = disMap[key];
      ret += n * (n - 1);
    }
  }

  return ret;
};

function getDis(p1, p2) {
  var d1 = p2[1] - p1[1];
  var d2 = p2[0] - p1[0];
  return d1 * d1 + d2 * d2;
}

console.log(
  numberOfBoomerangs([
    [0, 0],
    [1, 0],
    [2, 0],
  ]) == 2,
);
console.log(numberOfBoomerangs([[1, 1]]) == 0);
console.log(
  numberOfBoomerangs([
    [1, 1],
    [1, 2],
  ]) == 0,
);
console.log(
  numberOfBoomerangs([
    [0, 0],
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
  ]) == 20,
);
```

### [453].Minimum-Moves-to-Equal-Array-Elements

```js
/**
 * https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/
 * Difficulty:Easy
 *
 * Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by [1].
 * Example:
 * Input:
 * [1,2,3]
 * Output:
 * 3
 * Explanation:
 * Only three moves are needed (remember each move increments two elements):
 * [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
 *
 */

/**
 *
 * reverse thinking!
 *
 * Adding 1 to n - 1 elements is the same as subtracting 1 from one element
 *
 * goal of making the elements in the array equal.
 * So, best way to do this is make all the elements in the array equal to the min element.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var minMoves = function(nums) {
  var min = nums[0];
  for (var i = 1; i < nums.length; i++) {
    min = Math.min(min, nums[i]);
  }

  var ret = 0;
  for (i = 0; i < nums.length; i++) {
    ret += nums[i] - min;
  }
  return ret;
};

console.log(minMoves([1, 999, 1000]));
```

### [454].4Sum-II

```js
/**
 * Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l)
 * there are such that A[i] + B[j] + C[k] + D[l] is zero.

 To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ [500].
 All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - [1].

 Example:

 Input:
 A = [ 1, 2]
 B = [-2,-1]
 C = [-1, 2]
 D = [ 0, 2]

 Output:
 2

 Explanation:
 The two tuples are:
 [1]. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
 [2]. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
 */

/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
var fourSumCount = function(A, B, C, D) {
  var cnt = 0;
  var map = {};
  var n = A.length;

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      var sum = A[i] + B[j];
      if (map[sum] === undefined) map[sum] = 1;
      else map[sum]++;
    }
  }

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      var sum = C[i] + D[j];
      if (map[-sum] !== undefined) cnt += map[-sum];
    }
  }
  return cnt;
};

console.log(fourSumCount([1, 2], [-2, -2], [-1, 2], [0, 2]));
```

### [455].Assign-Cookies

```js
/**
 * https://leetcode.com/problems/assign-cookies/description/
 * Difficulty:Easy
 *
 * Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
 *
 * Note:
 * You may assume the greed factor is always positive.
 * You cannot assign more than one cookie to one child.
 * Example 1:
 * Input: [1,2,3], [1,1]
 * Output: 1
 * Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, [3].
 * And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
 * You need to output [1].
 *
 */

/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
  var ret = 0;
  g.sort((a, b) => a - b);
  s.sort((a, b) => a - b);
  var gIndex = 0;
  var sIndex = 0;

  while (gIndex < g.length && sIndex < s.length) {
    var gi = g[gIndex];
    var si = s[sIndex];
    if (gi <= si) {
      ret += 1;
      gIndex++;
      sIndex++;
    } else if (gi > si) {
      sIndex++;
    } else {
      break;
    }
  }

  return ret;
};

console.log(findContentChildren([1, 2, 3], [1, 1]));
console.log(findContentChildren([1, 2], [1, 2, 3]));
```

### [459].重复的子字符串

```js
/*
 * @lc app=leetcode.cn id=459 lang=javascript
 *
 * [459] 重复的子字符串
 */
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
  // 正则表达式的模式匹配
  return /^(\w+)\1+$/.test(s);
};

console.log(repeatedSubstringPattern('abab'));
console.log(repeatedSubstringPattern('aba'));
console.log(repeatedSubstringPattern('abcabcabcabc'));
```

### [461].Hamming-Distance

```js
/**
 * https://leetcode.com/problems/hamming-distance/description/
 * Difficulty:Easy
 *
 * The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
 * Given two integers x and y, calculate the Hamming distance.
 * Note:
 * 0 ≤ x, y < [231].
 * Example:
 * Input: x = 1, y = 4
 * Output: 2
 * Explanation:
 * 1   (0 0 0 1)
 * 4   (0 1 0 0)
 * ↑   ↑
 * The above arrows point to positions where the corresponding bits are different.
 *
 */

/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
  var z = x ^ y;
  var ret = 0;
  while (z) {
    ret += z % 2;
    z = Math.floor(z / 2);
  }
  return ret;
};

console.log(hammingDistance(1, 4));
```

### [476].Number-Complement

```js
/**
 * https://leetcode.com/problems/number-complement/description/
 * Difficulty:Easy
 *
 * Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
 * Note:
 *
 * The given integer is guaranteed to fit within the range of a [32].bit signed integer.
 * You could assume no leading zero bit in the integer’s binary representation.
 *
 * Example:
 * Input: 5
 * Output: 2
 * Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is [010]. So you need to output [2].
 */

/**
 * @param {number} num
 * @return {number}
 */
var findComplement = function(num) {
  var str = '';

  while (num) {
    str = (num % 2 ? 0 : 1) + str;
    num = Math.floor(num / 2);
  }

  return parseInt(str, 2);
};

console.log(findComplement(5));
console.log(findComplement(2));
```

### [477].Total-Hamming-Distance

```js
/**
 * https://leetcode.com/problems/total-hamming-distance/description/
 * Difficulty:Medium
 *
 * The Hamming distance between two integers is the number of positions at which
 * the corresponding bits are different.
 * Now your job is to find the total Hamming distance between all pairs of the given numbers.
 *
 * Example:
 * Input: 4, 14, 2
 * Output: 6
 * Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
 * showing the four bits relevant in this case). So the answer will be:
 * HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = [6].
 *
 * Note:
 * Elements of the given array are in the range of 0 to 10^9
 * Length of the array will not exceed 10^4.
 *
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var totalHammingDistance = function(nums) {
  var ret = 0;
  var maxLen = 0;
  var bArrs = nums.map(n => {
    var arr = [];
    while (n) {
      arr.push(n % 2);
      n = Math.floor(n / 2);
    }
    if (arr.length > maxLen) maxLen = arr.length;

    return arr;
  });

  while (maxLen) {
    var index = maxLen - 1;

    var ones = 0;
    var zeros = 0;
    for (var i = 0; i < bArrs.length; i++) {
      if (bArrs[i][index]) {
        ones++;
      } else {
        zeros++;
      }
    }
    ret += ones * zeros;
    maxLen--;
  }

  return ret;
};

console.log(6 == totalHammingDistance([4, 14, 2]));
```

### [492].Construct-the-Rectangle

```js
/**
 *
 * https://leetcode.com/problems/construct-the-rectangle/description/
 * Difficulty:Easy
 *
 * For a web developer, it is very important to know how to design a web page's size.
 * So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page,
 * whose length L and width W satisfy the following requirements:
 * [1]. The area of the rectangular web page you designed must equal to the given target area.
 * [2]. The width W should not be larger than the length L, which means L >= W.
 * [3]. The difference between length L and width W should be as small as possible.
 * You need to output the length L and the width W of the web page you designed in sequence.
 *
 * Example:
 * Input: 4
 * Output: [2, 2]
 * Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].
 * But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is [2].
 *
 * Note:
 * The given area won't exceed 10,000,000 and is a positive integer
 * The web page's width and length you designed must be positive integers.
 * */

/**
 * @param {number} area
 * @return {number[]}
 */
var constructRectangle = function(area) {
  var w = Math.floor(Math.sqrt(area));
  while (area % w != 0) w--;
  return [area / w, w];
};

console.log(constructRectangle(4));
console.log(constructRectangle(17));
```

### [416].partition-equal-subset-sum

#### 题目描述

```
Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Note:

Each of the array element will not exceed 100.
The array size will not exceed 200.


Example 1:

Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].


Example 2:

Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.


```

#### 思路

题目要求给定一个数组， 问是否能划分为和相等的两个数组。

这是一个典型的背包问题，我们可以遍历数组，对于每一个，我们都分两种情况考虑，拿或者不拿。

背包问题处理这种离散的可以划分子问题解决的问题很有用。

如果能够识别出这是一道背包问题，那么就相对容易了。

#### 关键点解析

- 背包问题

#### 代码

```js
/*
 * @lc app=leetcode id=416 lang=javascript
 *
 * [416] Partition Equal Subset Sum
 *
 * https://leetcode.com/problems/partition-equal-subset-sum/description/
 *
 * algorithms
 * Medium (39.97%)
 * Total Accepted:    79.7K
 * Total Submissions: 198.5K
 * Testcase Example:  '[1,5,11,5]'
 *
 * Given a non-empty array containing only positive integers, find if the array
 * can be partitioned into two subsets such that the sum of elements in both
 * subsets is equal.
 *
 * Note:
 *
 *
 * Each of the array element will not exceed 100.
 * The array size will not exceed 200.
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: [1, 5, 11, 5]
 *
 * Output: true
 *
 * Explanation: The array can be partitioned as [1, 5, 5] and [11].
 *
 *
 *
 *
 * Example 2:
 *
 *
 * Input: [1, 2, 3, 5]
 *
 * Output: false
 *
 * Explanation: The array cannot be partitioned into equal sum subsets.
 *
 *
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  let sum = 0;
  for (let num of nums) {
    sum += num;
  }

  if (sum & (1 === 1)) return false;

  const half = sum >> 1;

  let dp = Array(half);
  dp[0] = [true, ...Array(nums.length).fill(false)];

  for (let i = 1; i < nums.length + 1; i++) {
    dp[i] = [true, ...Array(half).fill(false)];
    for (let j = 1; j < half + 1; j++) {
      if (j >= nums[i - 1]) {
        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
      }
    }
  }

  return dp[nums.length][half];
};
```

### [437].path-sum-iii

#### 题目描述

```
You are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```

#### 思路

这道题目是要我们求解出任何一个节点出发到子孙节点的路径中和为指定值。
注意这里，不一定是从根节点出发，也不一定在叶子节点结束。

一种简单的思路就是直接递归解决，空间复杂度 O(n) 时间复杂度介于 O(nlogn) 和 O(n^2)，
具体代码：

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
// the number of the paths starting from self
function helper(root, sum) {
  if (root === null) return 0;
  const l = helper(root.left, sum - root.val);
  const r = helper(root.right, sum - root.val);

  return l + r + (root.val === sum ? 1 : 0);
}
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number}
 */
var pathSum = function(root, sum) {
  // 空间复杂度O(n) 时间复杂度介于O(nlogn) 和 O(n^2)
  // tag: dfs tree
  if (root === null) return 0;
  // the number of the paths starting from self
  const self = helper(root, sum);
  // we don't know the answer, so we just pass it down
  const l = pathSum(root.left, sum);
  // we don't know the answer, so we just pass it down
  const r = pathSum(root.right, sum);

  return self + l + r;
};
```

但是还有一种空间复杂度更加优秀的算法，利用 hashmap 来避免重复计算，时间复杂度和空间复杂度都是 O(n)。
这种思路是`subarray-sum-equals-k`的升级版本，如果那道题目你可以 O(n)解决，这道题目难度就不会很大，
只是将数组换成了二叉树。关于具体的思路可以看[这道题目](./560.subarray-sum-equals-k.md)

这里有一个不一样的地方，这里我说明一下，就是为什么要有`hashmap[acc] = hashmap[acc] - 1;`，
原因很简单，就是我们 DFS 的时候，从底部往上回溯的时候，map 的值应该也回溯。如果你对回溯法比较熟悉的话，
应该很容易理解，如果不熟悉可以参考[这道题目](./46.permutations.md)， 这道题目就是通过`tempList.pop()`来完成的。

另外我画了一个图，相信看完你就明白了。

当我们执行到底部的时候：

接着往上回溯：

很容易看出，我们的 hashmap 不应该有第一张图的那个记录了，因此需要减去。

具体实现见下方代码区。

#### 关键点解析

- 通过 hashmap，以时间换空间
- 对于这种连续的元素求和问题，有一个共同的思路，可以参考[这道题目](./560.subarray-sum-equals-k.md)

#### 代码

- 语言支持：JS

```js
/*
 * @lc app=leetcode id=437 lang=javascript
 *
 * [437] Path Sum III
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(root, acc, target, hashmap) {
  // see also : https://leetcode.com/problems/subarray-sum-equals-k/

  if (root === null) return 0;
  let count = 0;
  acc += root.val;
  if (acc === target) count++;
  if (hashmap[acc - target] !== void 0) {
    count += hashmap[acc - target];
  }
  if (hashmap[acc] === void 0) {
    hashmap[acc] = 1;
  } else {
    hashmap[acc] += 1;
  }
  const res = count + helper(root.left, acc, target, hashmap) + helper(root.right, acc, target, hashmap);

  // 这里要注意别忘记了
  hashmap[acc] = hashmap[acc] - 1;

  return res;
}

var pathSum = function(root, sum) {
  // 时间复杂度和空间复杂度都是O(n)
  const hashmap = {};
  return helper(root, 0, sum, hashmap);
};
```

### [445].两数之和 II add-two-numbers-ii

#### 题目描述

```
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

Example:

Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7

```

#### 思路

由于需要从低位开始加，然后进位。 因此可以采用栈来简化操作。
依次将两个链表的值分别入栈 stack1 和 stack2，然后相加入栈 stack，进位操作用一个变量 carried 记录即可。

最后根据 stack 生成最终的链表即可。

#### 关键点解析

- 栈的基本操作
- carried 变量记录进位
- 循环的终止条件设置成`stack.length > 0` 可以简化操作
- 注意特殊情况， 比如 1 + 99 = 100

#### 代码

```js
/*
 * @lc app=leetcode id=445 lang=javascript
 *
 * [445] Add Two Numbers II
 *
 * https://leetcode.com/problems/add-two-numbers-ii/description/
 *
 * algorithms
 * Medium (49.31%)
 * Total Accepted:    83.7K
 * Total Submissions: 169K
 * Testcase Example:  '[7,2,4,3]\n[5,6,4]'
 *
 * You are given two non-empty linked lists representing two non-negative
 * integers. The most significant digit comes first and each of their nodes
 * contain a single digit. Add the two numbers and return it as a linked list.
 *
 * You may assume the two numbers do not contain any leading zero, except the
 * number 0 itself.
 *
 * Follow up:
 * What if you cannot modify the input lists? In other words, reversing the
 * lists is not allowed.
 *
 *
 *
 * Example:
 *
 * Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
 * Output: 7 -> 8 -> 0 -> 7
 *
 *
 */

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  const stack1 = [];
  const stack2 = [];
  const stack = [];

  let cur1 = l1;
  let cur2 = l2;
  let curried = 0;

  while (cur1) {
    stack1.push(cur1.val);
    cur1 = cur1.next;
  }

  while (cur2) {
    stack2.push(cur2.val);
    cur2 = cur2.next;
  }

  let a = null;
  let b = null;

  while (stack1.length > 0 || stack2.length > 0) {
    a = Number(stack1.pop()) || 0;
    b = Number(stack2.pop()) || 0;

    stack.push((a + b + curried) % 10);

    if (a + b + curried >= 10) {
      curried = 1;
    } else {
      curried = 0;
    }
  }

  if (curried === 1) {
    stack.push(1);
  }

  const dummy = {};

  let current = dummy;

  while (stack.length > 0) {
    current.next = {
      val: stack.pop(),
      next: null,
    };

    current = current.next;
  }

  return dummy.next;
};
```

### [454].4-sum-ii

#### 题目描述

```
Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.

To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.

Example:

Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```

#### 思路

如果按照常规思路去完成查找需要四层遍历，时间复杂是 O(n^4), 显然是行不通的。
因此我们有必要想一种更加高效的算法。

我一个思路就是我们将四个数组分成两组，两两结合。
然后我们分别计算`两两结合能够算出的和有哪些，以及其对应的个数`。

如图：

这个时候我们得到了两个`hashTable`， 我们只需要进行简单的数学运算就可以得到结果。

#### 关键点解析

- 空间换时间
- 两两分组，求出两两结合能够得出的可能数，然后合并即可。

#### 代码

```js
/*
 * @lc app=leetcode id=454 lang=javascript
 *
 * [454] 4Sum II
 *
 * https://leetcode.com/problems/4sum-ii/description/
 *
 * algorithms
 * Medium (49.93%)
 * Total Accepted:    63.2K
 * Total Submissions: 125.6K
 * Testcase Example:  '[1,2]\n[-2,-1]\n[-1,2]\n[0,2]'
 *
 * Given four lists A, B, C, D of integer values, compute how many tuples (i,
 * j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.
 *
 * To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤
 * N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result
 * is guaranteed to be at most 2^31 - 1.
 *
 * Example:
 *
 *
 * Input:
 * A = [ 1, 2]
 * B = [-2,-1]
 * C = [-1, 2]
 * D = [ 0, 2]
 *
 * Output:
 * 2
 *
 * Explanation:
 * The two tuples are:
 * 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
 * 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
 *
 *
 *
 *
 */
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
var fourSumCount = function(A, B, C, D) {
  const sumMapper = {};
  let res = 0;
  for (let i = 0; i < A.length; i++) {
    for (let j = 0; j < B.length; j++) {
      sumMapper[A[i] + B[j]] = (sumMapper[A[i] + B[j]] || 0) + 1;
    }
  }

  for (let i = 0; i < C.length; i++) {
    for (let j = 0; j < D.length; j++) {
      res += sumMapper[-(C[i] + D[j])] || 0;
    }
  }

  return res;
};
```

#### 题目描述

```
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.


Example 1:

    2
   / \
  1   3

Input: [2,1,3]
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6

Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.


```

#### 思路

这道题是让你验证一棵树是否为二叉查找树(BST)。 由于中序遍历的性质`如果一个树遍历的结果是有序数组，那么他也是一个二叉查找树(BST)`,
我们只需要中序遍历，然后两两判断是否有逆序的元素对即可，如果有，则不是 BST，否则即为一个 BST。

#### 关键点解析

- 二叉树的基本操作(遍历)
- 中序遍历一个二叉查找树(BST)的结果是一个有序数组
- 如果一个树遍历的结果是有序数组，那么他也是一个二叉查找树(BST)

#### 代码

```js
/*
 * @lc app=leetcode id=98 lang=javascript
 *
 * [98] Validate Binary Search Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  if (root === null) return true;
  if (root.left === null && root.right === null) return true;
  const stack = [root];
  let cur = root;
  let pre = null;

  function insertAllLefts(cur) {
    while (cur && cur.left) {
      const l = cur.left;
      stack.push(l);
      cur = l;
    }
  }
  insertAllLefts(cur);

  while ((cur = stack.pop())) {
    if (pre && cur.val <= pre.val) return false;
    const r = cur.right;

    if (r) {
      stack.push(r);
      insertAllLefts(r);
    }
    pre = cur;
  }

  return true;
};
```

#### 相关题目

[230.kth-smallest-element-in-a-bst](./230.kth-smallest-element-in-a-bst.md)

### [494].target-sum

#### 题目描述

```
You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target S.

Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
Note:
The length of the given array is positive and will not exceed 20.
The sum of elements in the given array will not exceed 1000.
Your output answer is guaranteed to be fitted in a 32-bit integer.

```

#### 思路

题目是给定一个数组，让你在数字前面添加 `+`或者`-`，使其和等于 target.

暴力法的时间复杂度是指数级别的，因此我们不予考虑。我们需要换种思路.

我们将最终的结果分成两组，一组是我们添加了`+`的，一组是我们添加了`-`的。

如上图，问题转化为如何求其中一组，我们不妨求前面标`+`的一组

> 如果求出一组，另一组实际就已知了，即总集和这一组的差集。

通过进一步分析，我们得到了这样的关系：

因此问题转化为，求解`sumCount(nums, target)`,即 nums 数组中能够组成
target 的总数一共有多少种，这是一道我们之前做过的题目，使用动态规划可以解决。

#### 关键点解析

- 对元素进行分组，分组的依据是符号， 是`+` 或者 `-`
- 通过数学公式推导可以简化我们的求解过程，这需要一点`数学知识和数学意识`

#### 代码

```js
/*
 * @lc app=leetcode id=494 lang=javascript
 *
 * [494] Target Sum
 *
 * https://leetcode.com/problems/target-sum/description/
 *
 * algorithms
 * Medium (44.86%)
 * Total Accepted:    89.3K
 * Total Submissions: 198.5K
 * Testcase Example:  '[1,1,1,1,1]\n3'
 *
 *
 * You are given a list of non-negative integers, a1, a2, ..., an, and a
 * target, S. Now you have 2 symbols + and -. For each integer, you should
 * choose one from + and - as its new symbol.
 * ⁠
 *
 * Find out how many ways to assign symbols to make sum of integers equal to
 * target S.
 *
 *
 * Example 1:
 *
 * Input: nums is [1, 1, 1, 1, 1], S is 3.
 * Output: 5
 * Explanation:
 *
 * -1+1+1+1+1 = 3
 * +1-1+1+1+1 = 3
 * +1+1-1+1+1 = 3
 * +1+1+1-1+1 = 3
 * +1+1+1+1-1 = 3
 *
 * There are 5 ways to assign symbols to make the sum of nums be target 3.
 *
 *
 *
 * Note:
 *
 * The length of the given array is positive and will not exceed 20.
 * The sum of elements in the given array will not exceed 1000.
 * Your output answer is guaranteed to be fitted in a 32-bit integer.
 *
 *
 */
// 这个是我们熟悉的问题了
// 我们这里需要求解的是nums里面有多少种可以组成target的方式
var sumCount = function(nums, target) {
  // 这里通过观察，我们没必要使用二维数组去存储这些计算结果
  // 使用一维数组可以有效节省空间
  const dp = Array(target + 1).fill(0);
  dp[0] = 1;
  for (let i = 0; i < nums.length; i++) {
    for (let j = target; j >= nums[i]; j--) {
      dp[j] += dp[j - nums[i]];
    }
  }
  return dp[target];
};
const add = nums => nums.reduce((a, b) => (a += b), 0);
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
  const sum = add(nums);
  if (sum < S) return 0;
  if ((S + sum) % 2 === 1) return 0;
  return sumCount(nums, (S + sum) >> 1);
};
```

#### 扩展

如果这道题目并没有限定所有的元素以及 target 都是正数怎么办？

### [409].最长回文串 longest-palindrome

```js
var longestPalindrome = function(s) {
  // abccccdd
  let res = 0;
  let hasOdd = false;
  const counts = Array('z'.charCodeAt(0) + 1).fill(0);
  for (let i = 0; i < s.length; i++) {
    counts[s.charCodeAt(i)] += 1;
  }

  for (let i = 0; i < counts.length; i++) {
    if (counts[i] % 2 === 0) {
      res += counts[i];
    } else {
      hasOdd = true;
      res += counts[i] - 1;
    }
  }

  return hasOdd ? res + 1 : res;
};
```

### [417]. 太平洋大西洋水流问题

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/pacific-atlantic-water-flow

* tag：`Backtracking` `DFS`

#### 题目描述

给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

提示：

输出坐标的顺序不重要
m 和 n 都小于 150

示例：

```
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
```

#### 参考答案

- 方法 1：直接采用回溯法 超时

直接判断 水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标
采用方法是
回溯法(英语：backtracking)是暴力搜索法中的一种。
在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
在这个题目中，这个题目中正好就是如此。
因为需要等到上下左右全部计算完毕才有确定答案。

m 和 n =150，肯定超时。

- 方法 2：动态规划+回溯法

思路：

总体思路还是回溯，我们对能够流入太平洋的(第一行和第一列)开始进行上下左右探测。

同样我们对能够流入大西洋的(最后一行和最后一列)开始进行上下左右探测。

最后将探测结果进行合并即可。合并的条件就是当前单元既能流入太平洋又能流入大西洋。

![集合](https://user-images.githubusercontent.com/5937331/63209454-7c921a80-c113-11e9-8d74-82d0476b8828.png)
扩展：

如果题目改为能够流入大西洋或者太平洋，我们只需要最后合并的时候，条件改为求或即可

#### 参考代码

- JavaScript Code

```js
function dfs(i, j, height, m, matrix, rows, cols) {
    if (i >= rows || i < 0) return;
    if (j >= cols || j < 0) return;

    if (matrix[i][j] < height) return;

    if (m[i][j] === true) return;

    m[i][j] = true;

    dfs(i + 1, j, matrix[i][j], m, matrix, rows, cols);
    dfs(i - 1, j, matrix[i][j], m, matrix, rows, cols);
    dfs(i, j + 1, matrix[i][j], m, matrix, rows, cols);
    dfs(i, j - 1, matrix[i][j], m, matrix, rows, cols);
}
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var pacificAtlantic = function(matrix) {
    const rows = matrix.length;
    if (rows === 0) return [];
    const cols = matrix[0].length;
    const pacific = Array.from({
        length: rows
    },
    () = >Array(cols).fill(false));
    const atlantic = Array.from({
        length: rows
    },
    () = >Array(cols).fill(false));
    const res = [];

    for (let i = 0; i < rows; i++) {
        dfs(i, 0, 0, pacific, matrix, rows, cols);
        dfs(i, cols - 1, 0, atlantic, matrix, rows, cols);
    }

    for (let i = 0; i < cols; i++) {
        dfs(0, i, 0, pacific, matrix, rows, cols);
        dfs(rows - 1, i, 0, atlantic, matrix, rows, cols);
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (pacific[i][j] === true && atlantic[i][j] === true) res.push([i, j]);
        }
    }

    return res;
};
```

###### 字符串首尾相等的最长子串

#### 信息卡片

- 题目链接：无
- tag：`String` `Hash Table`

#### 题目描述

```

求一个字符串首尾相等的最长子串，例如 abcba，最长就是 abcba

```

#### 参考答案

思路:

头尾两个字母相同的子串，比如 abca，这里头尾相同的就是 a..a 子串，它的长度就是这两个 a 的下标之差+1；

如果是 abcadefa，这里有三个 a，那么这个子串的长度是第一个 a 和最后一个 a 的下标之差+1；

这时候规律就来了，那我只要计算同一个字母第一次出现和最后一次出现的位置就好了嘛，最后再求个最大值；

那这样的话，我们只要一次遍历，用一个 map 把这些位置记下来即可。

但是仔细想想，我存同一个字母的这么多位置，好像最后我也只取这个位置集合的第一个和最后一个啊，那我为什么还要存这么多，存起始位置就好了嘛！
每次遍历到第 2,3,4 个相同字母的时候，我都减去第一个此字母位置的下标再看看这个差值是不是最大的。
所以代码来了：

JavaScript Code:

```js
var LES = function(str) {
  var map = {}; // 用来存储遍历到的字母出现的第一个位置
  var maxLen = 1; // 初始化最大子串长度
  var substrStartIndex = 0; // 最长子串的起始位置
  for (var i = 0; i < str.length; i++) {
    var char = str[i];
    if (map[char] != null) {
      // 如果这个字母之前已经出现过了
      if (i - map[char] + 1 > maxLen) {
        // 那么计算当前这个字母到第一次出现的位置距离，然后比较
        maxLen = i - map[char] + 1;
        substrStartIndex = map[char]; // 如果是最大值，记录下当前最大子串的起始位置
      }
    } else {
      map[char] = i; // 如果这个字母之前没出现过，那么记下它的下标
    }
  }

  return str.slice(substrStartIndex, substrStartIndex + maxLen);
};
```

####### [593]. 有效的正方形

- 题目链接：https://leetcode.com/problems/top-k-frequent-elements/description/
- tag：`Hash Table` `Heap`

##### 题目描述

```
Given a non-empty array of integers, return the k most frequent elements.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Example 2:


Input: nums = [1], k = 1
Output: [1]

Note:

You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is
the array's size.
```

##### 参考答案

模仿 [@raof01](https://github.com/raof01) 的思路写的 JS 代码，

基本思路就是： 证明四个角都是直角， 而证明直角的方式就是边长关系。

四个点一共有六个连接的线段，其中两个是对角线，另外四个是边。

对于直角来说，满足“a _ a + b _ b = c _ c”, 由于是正方形，所以 a = b， 因此 c 就等于
2 _ a \* a , 其中 a 为边长，c 就是对角线的长度。

我们分别计算出距离的平方，如果有四个相同，另外两个相同。 且二者的关系可以满足直角，那么他就有四个直角，他就是一个正方形

```js
/*
 * @lc app=leetcode id=593 lang=javascript
 *
 * [593] Valid Square
 */
function square(p1, p2) {
  const deltaX = p1[0] - p2[0];
  const deltaY = p1[1] - p2[1];

  return deltaX * deltaX + deltaY * deltaY;
}
/**
 * @param {number[]} p1
 * @param {number[]} p2
 * @param {number[]} p3
 * @param {number[]} p4
 * @return {boolean}
 */
var validSquare = function(p1, p2, p3, p4) {
  // 证明四个角都是直角
  // 证明直角的方式就是边长关系
  const squares = [square(p1, p2), square(p1, p3), square(p1, p4), square(p2, p3), square(p2, p4), square(p3, p4)];
  let cnt1 = 0;
  let cnt2 = 0;
  let sum = 0;

  for (let i = 0; i < squares.length; i++) {
    sum += squares[i];
  }

  for (let i = 0; i < squares.length; i++) {
    if (sum === 8 * squares[i]) {
      cnt1++;
    } else if (sum === 4 * squares[i]) {
      cnt2++;
    }
  }

  return cnt1 === 4 && cnt2 === 2;
};
```

##### 其他优秀解答

暂无

### [460].lfu-cache

```js
/*
 * @lc app=leetcode id=460 lang=javascript
 *
 * [460] LFU Cache
 */
/**
 * @param {number} capacity
 */
var LFUCache = function(capacity) {
  this.capacity = capacity;
  this.size = 0;
  this.cache = {};
  this.timestamp = 0;
};

/**
 * @param {number} key
 * @return {number}
 */
LFUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit === void 0) {
    return -1;
  }
  hit.count += 1;
  hit.timestamp = this.timestamp++;

  return hit.value;
};

// 时间复杂度O(n)   n其实就是capacity
LFUCache.prototype.evicted = function() {
  // evicted lfu
  let leastCountKey = null;
  let min = Number.MAX_VALUE;

  for (const k in this.cache) {
    const item = this.cache[k];
    if (item.count < min) {
      leastCountKey = k;
      min = item.count;
    } else if (item.count === min && item.timestamp < this.cache[leastCountKey].timestamp) {
      leastCountKey = k;
      min = item.count;
    }
  }

  delete this.cache[leastCountKey];
  this.size--;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LFUCache.prototype.put = function(key, value) {
  if (this.capacity === 0) return;
  const hit = this.cache[key];

  if (hit === void 0) {
    if (this.capacity === this.size) {
      this.evicted();
    }
    this.size++;
    return (this.cache[key] = {
      value,
      timestamp: this.timestamp++,
      count: 1,
    });
  }

  this.cache[key].value = value;
  this.cache[key].timestamp = this.timestamp++;
  return (this.cache[key].count += 1);
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * var obj = new LFUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [460].lfu-cache

#### 题目描述

```
Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

#### 思路

[LFU(Least frequently used)](https://www.wikiwand.com/en/Least_frequently_used) 但内存容量满的情况下，有新的数据进来，需要更多空间的时候，就需要删除被访问频率最少的元素。

举个例子，比如说 cache 容量是 3，按顺序依次放入 `1，2，1，2，1，3`， cache 已存满 3 个元素 (1，2，3)， 这时如果想放入一个新的元素 4 的时候，就需要腾出一个元素空间。
用 LFU，这里就淘汰 3， 因为 3 的次数只出现依次， 1 和 2 出现的次数都比 3 多。

题中 `get` 和 `put` 都是 `O(1)`的时间复杂度，那么删除和增加都是`O(1)`，可以想到用双链表，和`HashMap`，用一个`HashMap, nodeMap,` 保存当前`key`，和 `node{key, value, frequent}`的映射。
这样`get(key)`的操作就是`O(1)`. 如果要删除一个元素，那么就需要另一个`HashMap，freqMap，`保存元素出现次数`(frequent)`和双链表`(DoublyLinkedlist)` 映射，
这里双链表存的是 frequent 相同的元素。每次`get`或`put`的时候，`frequent+1`，然后把`node`插入到双链表的`head node, head.next=node`
每次删除`freqent`最小的双链表的`tail node, tail.prev`。

用给的例子举例说明：

```
1. put(1, 1),
   - 首先查找nodeMap中有没有key=1对应的value，
       没有就新建node(key, value, freq) -> node1(1, 1, 1), 插入 nodeMap，{[1, node1]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把node1 插入doublylinkedlist head->next = node1.
   如下图，
```

```
2. put(2, 2),
   - 首先查找nodeMap中有没有key=2对应的value，
       没有就新建node(key, value, freq) -> node2(2, 2, 1), 插入 nodeMap，{[1, node1], [2, node2]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把node2 插入doublylinkedlist head->next = node2.
   如下图，
```

```
3. get(1),
   - 首先查找nodeMap中有没有key=1对应的value，nodeMap:{[1, node1], [2, node2]},
       找到node1，把node1 freq+1 -> node1(1,1,2)
   - 更新freqMap，删除freq=1，node1
   - 更新freqMap，插入freq=2，node1
   如下图，
```

```
4. put(3, 3),
   - 判断cache的capacity，已满，需要淘汰使用次数最少的元素，找到最小的freq=1，删除双链表tail node.prev
       如果tailnode.prev != null, 删除。然后从nodeMap中删除对应的key。
   - 首先查找nodeMap中有没有key=3对应的value，
       没有就新建node(key, value, freq) -> node3(3, 3, 1), 插入 nodeMap，{[1, node1], [3, node3]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把node3 插入doublylinkedlist head->next = node3.
   如下图，
```

```
5. get(2)
   - 查找nodeMap，如果没有对应的key的value，返回 -1。

6. get(3)
   - 首先查找nodeMap中有没有key=3对应的value，nodeMap:{[1, node1], [3, node3]},
       找到node3，把node3 freq+1 -> node3(3,3,2)
   - 更新freqMap，删除freq=1，node3
   - 更新freqMap，插入freq=2，node3
   如下图，
```

```
7. put(4, 4),
   - 判断cache的capacity，已满，需要淘汰使用次数最少的元素，找到最小的freq=1，删除双链表tail node.prev
       如果tailnode.prev != null, 删除。然后从nodeMap中删除对应的key。
   - 首先查找nodeMap中有没有key=4对应的value，
       没有就新建node(key, value, freq) -> node4(4, 4, 1), 插入 nodeMap，{[4, node4], [3, node3]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把 node4 插入doublylinkedlist head->next = node4.
   如下图，
```

```
8. get(1)
   - 查找nodeMap，如果没有对应的key的value，返回 -1。

9. get(3)
   - 首先查找nodeMap中有没有key=3对应的value，nodeMap:{[4, node4], [3, node3]},
       找到node3，把node3 freq+1 -> node3(3,3,3)
   - 更新freqMap，删除freq=2，node3
   - 更新freqMap，插入freq=3，node3
   如下图，
```

```
10. get(4)
   - 首先查找nodeMap中有没有key=4对应的value，nodeMap:{[4, node4], [3, node3]},
       找到node4，把node4 freq+1 -> node4(4,4,2)
   - 更新freqMap，删除freq=1，node4
   - 更新freqMap，插入freq=2，node4
   如下图，
```

#### 关键点分析

用两个`Map`分别保存 `nodeMap {key, node}` 和 `freqMap{frequent, DoublyLinkedList}`。
实现`get` 和 `put`操作都是`O(1)`的时间复杂度。

可以用 Java 自带的一些数据结构，比如 HashLinkedHashSet，这样就不需要自己自建 Node，DoublelyLinkedList。
可以很大程度的缩减代码量。

#### 代码(Java code)

```java
public class LC460LFUCache {
  class Node {
    int key, val, freq;
    Node prev, next;

    Node(int key, int val) {
      this.key = key;
      this.val = val;
      freq = 1;
    }
  }

  class DoubleLinkedList {
    private Node head;
    private Node tail;
    private int size;

    DoubleLinkedList() {
      head = new Node(0, 0);
      tail = new Node(0, 0);
      head.next = tail;
      tail.prev = head;
    }

    void add(Node node) {
      head.next.prev = node;
      node.next = head.next;
      node.prev = head;
      head.next = node;
      size++;
    }

    void remove(Node node) {
      node.prev.next = node.next;
      node.next.prev = node.prev;
      size--;
    }

    // always remove last node if last node exists
    Node removeLast() {
      if (size > 0) {
        Node node = tail.prev;
        remove(node);
        return node;
      } else return null;
    }
  }

  // cache capacity
  private int capacity;
  // min frequent
  private int minFreq;
  Map<Integer, Node> nodeMap;
  Map<Integer, DoubleLinkedList> freqMap;
  public LC460LFUCache(int capacity) {
    this.minFreq = 0;
    this.capacity = capacity;
    nodeMap = new HashMap<>();
    freqMap = new HashMap<>();
  }

  public int get(int key) {
    Node node = nodeMap.get(key);
    if (node == null) return -1;
    update(node);
    return node.val;
  }

  public void put(int key, int value) {
    if (capacity == 0) return;
    Node node;
    if (nodeMap.containsKey(key)) {
      node = nodeMap.get(key);
      node.val = value;
      update(node);
    } else {
      node = new Node(key, value);
      nodeMap.put(key, node);
      if (nodeMap.size() == capacity) {
        DoubleLinkedList lastList = freqMap.get(minFreq);
        nodeMap.remove(lastList.removeLast().key);
      }
      minFreq = 1;
      DoubleLinkedList newList = freqMap.getOrDefault(node.freq, new DoubleLinkedList());
      newList.add(node);
      freqMap.put(node.freq, newList);
    }
  }

  private void update(Node node) {
    DoubleLinkedList oldList = freqMap.get(node.freq);
    oldList.remove(node);
    if (node.freq == minFreq && oldList.size == 0) minFreq++;
    node.freq++;
    DoubleLinkedList newList = freqMap.getOrDefault(node.freq, new DoubleLinkedList());
    newList.add(node);
    freqMap.put(node.freq, newList);
  }
 }
```

#### 参考(References)

1. [LFU(Least frequently used) Cache](https://www.wikiwand.com/en/Least_frequently_used)
2. [LeetCode discussion mylzsd](<https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList>)
3. [LeetCode discussion aaaeeeo](<https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList>)

### [472].concatenated-words

#### 题目地址(472. 连接词)

https://leetcode-cn.com/problems/concatenated-words/

#### 题目描述

```
给定一个不含重复单词的列表，编写一个程序，返回给定单词列表中所有的连接词。

连接词的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。

示例:

输入: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

输出: ["catsdogcats","dogcatsdog","ratcatdogcat"]

解释: "catsdogcats"由"cats", "dog" 和 "cats"组成;
     "dogcatsdog"由"dog", "cats"和"dog"组成;
     "ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。
说明:

给定数组的元素总数不超过 10000。
给定数组中元素的长度总和不超过 600000。
所有输入字符串只包含小写字母。
不需要考虑答案输出的顺序。
```

#### 思路

本题我的思路是直接使用前缀树来解决。**标准的前缀树模板**我在之前的题解中提到了，感兴趣的可以到下方的相关题目中查看。

这道题这里我们不需要 search，我们的做法是：

- 先进行一次遍历，将 words 全部插入(insert)到前缀树中。
- 然后再进行一次遍历，查找每一个单词有几个单词表中的单词组成
- 如果大于 2，则将其加入到 res 中
- 最后返回 res 即可

我们构造的前缀树大概是这样的：

![472.concatenated-words.png](http://ww1.sinaimg.cn/large/e9f490c8ly1gbkcox4r06j21eb15fgq8.jpg)

问题的关键在于第二步中的**查找每一个单词有几个单词表中的单词组成**。 其实如果你了解前缀树的话应该不难写出来。 比如查找 catsdogcats：

- 我们先从 c 到 a 到 t，发现 t 是单词结尾，我们数量 + 1
- 然后将剩下的部分“sdogcats”重新执行上述过程。
- s 发现找不到，我们返回 0
- 因此最终结果是 1

很明显这个逻辑是错误的，正确的划分应该是：

- 我们先从 c 到 a 到 t，再到 s，此时数量 + 1
- 然后将剩下的“dogcats”重复上述过程
- dog 找到了，数量 + 1
- 最后将 cats 加入。也找到了，数量再加 1

由于我们并不知道 cat 这里断开，结果更大？还是 cats 这里断开结果更大？因此我们的做法是将其全部递归求出，然后取出最大值即可。如果我们直接这样递归的话，可能会超时，卡在最后一个测试用例上。一个简单的方式是记忆化递归，从而避免重复计算，经测试这种方法能够通过。

#### 代码

代码支持：Python3

Python3 Code:

```python
class Trie:

    def __init__(self):
        self.Trie = {}
        self.visited = {}

    def insert(self, word):
        curr = self.Trie
        for w in word:
            if w not in curr:
                curr[w] = {}
            curr = curr[w]
        curr['#'] = 1

    def cntWords(self, word):
        if not word:
            return 0
        if word in self.visited:
            return self.visited[word]
        curr = self.Trie
        res = float('-inf')

        for i, w in enumerate(word):
            if w not in curr:
                return res
            curr = curr[w]
            if '#' in curr:
                res = max(res, 1 + self.cntWords(word[i + 1:]))
        self.visited[word] = res
        return res


class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        self.trie = Trie()
        res = []

        for word in words:
            self.trie.insert(word)
        for word in words:
            if self.trie.cntWords(word) >= 2:
                res.append(word)
        return res
```

#### 关键点分析

- 前缀树

#### 相关题目

- [208.implement-trie-prefix-tree](https://github.com/azl397985856/leetcode/blob/b8e8fa5f0554926efa9039495b25ed7fc158372a/problems/208.implement-trie-prefix-tree.md)
- [211.add-and-search-word-data-structure-design](https://github.com/azl397985856/leetcode/blob/b0b69f8f11dace3a9040b54532105d42e88e6599/problems/211.add-and-search-word-data-structure-design.md)
- [212.word-search-ii](https://github.com/azl397985856/leetcode/blob/b0b69f8f11dace3a9040b54532105d42e88e6599/problems/212.word-search-ii.md)
- [0472.concatenated-words](./problems/472.concatenated-words.md)

### [493].reverse-pairs

#### 题目地址(493. 翻转对)

https://leetcode-cn.com/problems/reverse-pairs/description/

#### 题目描述

```
给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。

你需要返回给定数组中的重要翻转对的数量。

示例 1:

输入: [1,3,2,3,1]
输出: 2
示例 2:

输入: [2,4,3,5,1]
输出: 3
注意:

给定数组的长度不会超过50000。
输入数组中的所有数字都在32位整数的表示范围内。

```

#### 暴力法

##### 思路

读完这道题你应该就能联想到逆序数才行。求解逆序数最简单的做法是使用双层循环暴力求解。我们仿照求解决逆序数的解法来解这道题(其实唯一的区别就是系数从 1 变成了 2)。

##### 代码

代码支持：Python3

Python3 Code:

```python
class Solution(object):
    def reversePairs(self, nums):
        n = len(nums)
        cnt = 0
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] > 2 * nums[j]:
                    cnt += 1
        return cnt
```

#### 分治法

##### 思路

如果你能够想到逆序数，那么你很可能直到使用类似归并排序的方法可以求解逆序数。实际上逆序数只是归并排序的副产物而已。

我们在正常的归并排序的代码中去计算逆序数即可。由于每次分治的过程，左右两段数组分别是有序的，因此我们可以减少一些运算。 从时间复杂度的角度上讲，我们从$O(N^2)$优化到了 $O(NlogN)$。

具体来说，对两段有序的数组，有序数组内部是不需要计算逆序数的。 我们计算逆序数的逻辑只是计算两个数组之间的逆序数，我们假设两个数组是 A 和 B，并且 A 数组最大的元素不大于 B 数组最小的元素。而要做到这样，我们只需要常规的归并排序即可。

接下来问题转化为求解两个有序数组之间的逆序数，并且两个有序数组之间满足关系`A数组最大的元素不大于B数组最小的元素`。

关于计算逆序数的核心代码(Python3):

```python
l = r = 0
while l < len(left) and r < len(right):
    if left[l] <= 2 * right[r]:
        l += 1
    else:
        self.cnt += len(left) - l
        r += 1
```

##### 代码

代码支持：Python3

Python3 Code:

```python
class Solution(object):
    def reversePairs(self, nums):
        self.cnt = 0

        def mergeSort(lst):
            L = len(lst)
            if L <= 1:
                return lst
            return mergeTwo(mergeSort(lst[:L//2]), mergeSort(lst[L//2:]))

        def mergeTwo(left, right):
            l = r = 0
            while l < len(left) and r < len(right):
                if left[l] <= 2 * right[r]:
                    l += 1
                else:
                    self.cnt += len(left) - l
                    r += 1
            return sorted(left+right)

        mergeSort(nums)
        return self.cnt

```

对于具体的排序过程我们偷懒直接使用了语言内置的方法 sorted，这在很多时候是有用的，即使你是参加面试，这种方式通常也是允许的。省略非核心的考点，可以使得问题更加聚焦，这是一种解决问题的思路，在工作中也很有用。

#### 关键点解析

- 归并排序
- 逆序数
- 分治
- 识别考点，其他非重点可以使用语言内置方法

#### 代码

#### 扩展

这道题还有很多别的解法，感性的可以参考下这个题解 [General principles behind problems similar to "Reverse Pairs"](https://leetcode.com/problems/reverse-pairs/discuss/97268/General-principles-behind-problems-similar-to-%22Reverse-Pairs%22)
