---
layout: CustomPages
title: LeetCode-合集 500-600
date: 2020-09-04
aside: false
draft: true
---

### [500].Keyboard-Row

```js
/**
 * https://leetcode.com/problems/keyboard-row/description/
 * Difficulty:Easy
 *
 * Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.
 *
 * Example 1:
 * Input: ["Hello", "f", "Dad", "Peace"]
 * Output: ["Alaska", "Dad"]
 * Note:
 * You may use one character in the keyboard more than once.
 * You may assume the input string will only contain letters of alphabet.
 */

/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
  var s = 'qwertyuiopasdfghjklzxcvbnm';
  return words.filter(w => {
    if (!w) return true;
    w = w.toLowerCase();
    var t = row(w[0]);
    for (var i = 1; i < w.length; i++) {
      if (t !== row(w[i])) return false;
    }
    return true;
  });

  function row(ch) {
    var i = s.indexOf(ch);
    if (i < 10) return 0;
    if (i < 19) return 1;
    return 2;
  }
};
console.log(findWords(['Hello', 'Alaska', 'Dad', 'Peace']));
```

### [504].Base-7

```js
/**
 * https://leetcode.com/problems/base-7/description/
 * Difficulty:Easy
 *
 * Given an integer, return its base 7 string representation.
 * Example 1:
 * Input: 100
 * Output: "202"
 * Example 2:
 * Input: -7
 * Output: "-10"
 * Note: The input will be in range of [-1e7, 1e7].
 *
 */

/**
 * @param {number} num
 * @return {string}
 */
var convertToBase7 = function(num) {
  if (num === 0) return '0';
  var str = '';
  var sign = num > 0;
  num = Math.abs(num);
  while (num) {
    str = (num % 7) + str;
    num = Math.floor(num / 7);
  }

  return sign ? str : '-' + str;
};

console.log(convertToBase7(0));
console.log(convertToBase7(100));
console.log(convertToBase7(-7));
```

### [506].Relative-Ranks

```js
/**
 * https://leetcode.com/problems/relative-ranks/description/
 * Difficulty:Easy
 *
 * Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".
 *
 * Example 1:
 * Input: [5, 4, 3, 2, 1]
 * Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
 * Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal".
 * For the left two athletes, you just need to output their relative ranks according to their scores.
 * Note:
 * N is a positive integer and won't exceed 10,000.
 * All the scores of athletes are guaranteed to be unique.
 *
 */

/**
 * @param {number[]} nums
 * @return {string[]}
 */
var findRelativeRanks = function(nums) {
  var medals = ['Gold Medal', 'Silver Medal', 'Bronze Medal'];
  var ranks = [];
  Array.prototype.push.apply(ranks, nums);
  ranks.sort(function(a, b) {
    return b - a;
  });

  return nums.map(n => {
    var rank = ranks.indexOf(n);
    return medals[rank] || rank + 1 + '';
  });
};

// ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
console.log(findRelativeRanks([10, 3, 8, 9, 4]));

console.log(findRelativeRanks([5, 4, 1, 2, 3]));
```

### [520].Detect-Capital

```js
/**
 * https://leetcode.com/problems/detect-capital/description/
 * Difficulty:Easy
 *
 * Given a word, you need to judge whether the usage of capitals in it is right or not.
 * We define the usage of capitals in a word to be right when one of the following cases holds:
 * All letters in this word are capitals, like "USA".
 * All letters in this word are not capitals, like "leetcode".
 * Only the first letter in this word is capital if it has more than one letter, like "Google".
 * Otherwise, we define that this word doesn't use capitals in a right way.
 *
 */

/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
  var len = word.length;
  var upperLen = 0;
  var lowerLen = 0;
  var firstCap = false;
  for (var i = 0; i < len; i++) {
    var ch = word[i];
    if (/[A-Z]/.test(ch)) {
      upperLen++;
      if (i == 0) {
        firstCap = true;
      }
    }
    if (/[a-z]/.test(ch)) {
      lowerLen++;
    }
  }
  if (upperLen == len) return true;
  if (lowerLen == len) return true;
  return upperLen == 1 && firstCap && len > 1;
};

/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
  var isFirstChUpper = false;
  var upperCnt = 0;
  var n = word.length;

  for (let i = 0; i < n; i++) {
    let ch = word[i];
    if (ch >= 'A' && ch <= 'Z') {
      upperCnt++;
      if (i === 0) isFirstChUpper = true;
    }
  }

  if (isFirstChUpper) {
    return upperCnt === 1 || upperCnt === n;
  } else {
    return upperCnt === 0;
  }
};

console.log(detectCapitalUse('USA'));
console.log(detectCapitalUse('FlaG'));
console.log(detectCapitalUse('A'));
console.log(detectCapitalUse('Google'));
console.log(detectCapitalUse('leetcode'));
```

### [523].Continuous-Subarray-Sum

```js
/**
 * https://leetcode.com/problems/continuous-subarray-sum/description/
 * Difficulty:Medium
 *
 * Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer
 *
 * Example 1:
 * Input: [23, 2, 4, 6, 7],  k=6
 * Output: True
 * Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.
 *
 * Example 2:
 * Input: [23, 2, 6, 4, 7],  k=6
 * Output: True
 * Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.
 *
 * Note:
 * The length of the array won't exceed 10,000.
 * You may assume the sum of all the numbers is in the range of a signed 32-bit integer.
 */

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function(nums, k) {
  var arr = [];
  var sum = 0;
  if (nums.length < 2) return false;
  for (var i = 0; i < nums.length - 1; i++) {
    if (nums[i] + nums[i + 1] === 0) return true;
  }

  if (k < 0) k = -k;
  if (k === 0) return false;

  for (i = 0; i < nums.length; i++) {
    sum += nums[i];
    sum = sum % k;
    if (i > 0 && sum === 0) return true;
    var index = arr.indexOf(sum);
    if (index !== -1) {
      return true;
    }
    arr.push(sum);
  }
  return false;
};

console.log(checkSubarraySum([23, 2, 4, 6, 7], 6));
console.log(checkSubarraySum([23, 2, 4, 6, 7], 7));
console.log(checkSubarraySum([23, 2, 4, 6, 7], 8));
console.log(checkSubarraySum([0, 0], 0), true);
console.log(checkSubarraySum([0, 1, 0], 0), false);
console.log(checkSubarraySum([1, 1], 2), true);
```

### [524].通过删除字母匹配到字典里最长单词

```js
/*
 * @lc app=leetcode.cn id=524 lang=javascript
 *
 * [524] 通过删除字母匹配到字典里最长单词
 */
/**
 * @param {string} s
 * @param {string[]} d
 * @return {string}
 */
var findLongestWord = function(s, d) {
  const minSubStr = [];
  for (let i = 0; i < d.length; i++) {
    const target = d[i];
    if (isSubStr(s, target)) {
      if (minSubStr.length === 0) {
        minSubStr.push(target);
      } else if (
        target.length > minSubStr[0].length ||
        (target.length === minSubStr[0].length && target < minSubStr[0])
      ) {
        // 只会等于 1 不会大于 1
        minSubStr[0] = target;
      }
    }
  }
  return minSubStr.length ? minSubStr[0] : '';
};

// 判断是否是子串，通过双指针来判断
function isSubStr(s, p) {
  // 分别指向模式串和标准串
  let i = (j = 0);
  while (i < s.length && j < p.length) {
    if (s[i] === p[j]) {
      j++;
    }
    // 如果两个不匹配的话，就意味着删除对应位置的字符串即可
    i++;
  }
  // 匹配完成.
  // 既然是删除 s 中的一些字符串来匹配 p 所以 p 匹配结束了就表示匹配完成了
  // 否则如果是 s 先匹配结束说明永远都匹配不了 p
  return j === p.length;
}

// console.log(findLongestWord('abpcplea', ["ale", "apple", "monkey", "plea"]))
// console.log(findLongestWord('abpcplea', ["a", "b", "c"]))
// console.log(findLongestWord('bab', ["ba", "ab", "a", "b"]))
```

### [538].convert-bst-to-greater-tree

```js
/*
 * @lc app=leetcode id=538 lang=javascript
 *
 * [538] Convert BST to Greater Tree
 *
 * https://leetcode.com/problems/convert-bst-to-greater-tree/description/
 *
 * algorithms
 * Easy (50.04%)
 * Total Accepted:    75.4K
 * Total Submissions: 149K
 * Testcase Example:  '[5,2,13]'
 *
 * Given a Binary Search Tree (BST), convert it to a Greater Tree such that
 * every key of the original BST is changed to the original key plus sum of all
 * keys greater than the original key in BST.
 *
 *
 * Example:
 *
 * Input: The root of a Binary Search Tree like this:
 * ⁠             5
 * ⁠           /   \
 * ⁠          2     13
 *
 * Output: The root of a Greater Tree like this:
 * ⁠            18
 * ⁠           /   \
 * ⁠         20     13
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
  let res = 0;
  function r(root) {
    if (root === null) return null;

    r(root.right);

    root.val += res;

    res = +root.val;

    r(root.left);

    return root;
  }
  r(root);
  return root;
};
```

### [540].single-element-in-a-sorted-array

```js
/*
 * @lc app=leetcode id=540 lang=javascript
 *给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

示例 1:

输入: [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: [3,3,7,7,10,11,11]
输出: 10
注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
 * [540] Single Element in a Sorted Array
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate1 = function(nums) {
  //   if (nums.length === 1) return nums[0]
  //   nums.sort();
  //   for (let i = 0; i < nums.length; i++) {
  //     if (nums[i] === nums[i + 1]) {
  //       i++;
  //     } else {
  //         return nums[i];
  //     }
  //   }

  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === nums[mid + 1]) {
      if (mid % 2 === 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    } else if (nums[mid] === nums[mid - 1]) {
      if (mid % 2 === 0) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    } else {
      return nums[mid];
    }
  }
};

// 错了。。。。
var singleNonDuplicate = function(nums) {
  // 有序，缺少一个值。
  // 给定的排序数组肯定是单数.
  const n = Math.ceil(nums.length / 2);
  const sum = (nums[0] + nums[nums.length - 1]) * n;
  let sum1 = nums.reduce((sum, num) => sum + num, 0);
  console.log('sum', sum);
  console.log('sum1', sum1);
  return sum - sum1;
};

// console.log(singleNonDuplicate([1, 1, 2, 3, 3, 4, 4, 8, 8]))
// console.log(singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]))
console.log(singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]));
```

### [541].反转字符串-ii

```js
/*
 * @lc app=leetcode.cn id=541 lang=javascript
 *
 * [541] 反转字符串 II
 */
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
  let strArr = [];
  // 1. 截断字符串
  while (s) {
    strArr.push(s.slice(0, 2 * k));
    s = s.slice(2 * k);
  }
  return strArr
    .map(str => {
      return reverseArr(str.split(''), 0, k - 1).join('');
    })
    .join('');
};

// 原地反转
const reverseArr = (arr, start = 0, end = arr.length) => {
  let i = start,
    j = end;
  while (i < j) {
    [arr[i], arr[j]] = [arr[j], arr[i]];
    i++;
    j--;
  }
  return arr;
};

//溜啊
var newReverseStr = function(s, k) {
  if (k > s.length)
    return s
      .split('')
      .reverse()
      .join('');

  const split = s.split('');
  // 将需要翻转部分先翻转，后插入
  for (let i = 0; i < s.length; i += 2 * k) {
    const reverse = split.splice(i, k).reverse();
    split.splice(i, 0, ...reverse);
  }
  return split.join('');
};

console.log(reverseStr('abcdefg', 2));
console.log(newReverseStr('abcdefg', 2));
```

### [543].diameter-of-binary-tree

```js
/*
 * @lc app=leetcode id=543 lang=javascript
 *
 * [543] Diameter of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function maxDepth(root, res) {
  if (root === null) return 0;

  const l = maxDepth(root.left, res);
  const r = maxDepth(root.right, res);
  res.val = Math.max(res.val, l + r);
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
  // 如果不计算max， 直接1+ Math.max(maxLeft, maxRight)， 得到的结果实际上是经过root节点的最大值，并不一定是总体最大值
  // 题目也做了说明， ”最大值不一定经过root“
  if (root === null) return 0;
  const res = {
    val: 0,
  };

  maxDepth(root, res);

  return res.val;
};
```

### [543].二叉树的直径

```js
/*
 * @lc app=leetcode.cn id=543 lang=javascript
 *
 * [543] 二叉树的直径
 * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。
 * 注意：两结点之间的路径长度是以它们之间边的数目表示。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
let max = 0;
var diameterOfBinaryTree = function(root) {
  // if (root == null) return 0;
  depth(root);
  return max;
};

var depth = function(root) {
  if (!root) return 0;
  let l = depth(root.left);
  let r = depth(root.right);
  // 累加结果比较
  max = Math.max(max, l + r);
  // 需要返回最大的深度
  return Math.max(l, r) + 1;
};

console.log(diameterOfBinaryTree({ val: null, left: null, right: null }));
console.log(diameterOfBinaryTree({ val: 1, left: null, right: null }));

// ✘ Wrong Answer
// ✘ 46 / 106 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: 3
// ✘ expected_answer: 0
// ✘ stdout:

// ✘ Wrong Answer
// ✘ 46 / 106 cases passed(N / A)
// ✘ testcase: '[1]'
// ✘ answer: 3
// ✘ expected_answer: 0
// ✘ stdout:
```

### [557].Reverse-Words-in-a-String-III

```js
/**
 * https://leetcode.com/problems/reverse-words-in-a-string-iii/description/
 * Difficulty:Easy
 *
 * Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
 * Example 1:
 * Input: "Let's take LeetCode contest"
 * Output: "s'teL ekat edoCteeL tsetnoc"
 * Note: In the string, each word is separated by single space and there will not be any extra space in the string.
 */

/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s
    .split(' ')
    .map(w =>
      w
        .split('')
        .reverse()
        .join(''),
    )
    .join(' ');
};

console.log(reverseWords(`Let's take LeetCode contest`));
```

### [557].反转字符串中的单词-iii

```js
/*
 * @lc app=leetcode.cn id=557 lang=javascript
 *
 * [557] 反转字符串中的单词 III
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  // 需要注意的是，reverse 是数组拥有的函数，并不是字符串
  return s
    .split(' ')
    .map(item => {
      return item
        .split('')
        .reverse()
        .join('');
    })
    .join(' ');
};

var newReverseWords = function(s) {
  // 正则匹配一个单词，从左到右一个单词一个单词进行匹配
  return s
    .match(/[\w']+/g)
    .map(item => {
      return item
        .split('')
        .reverse()
        .join('');
    })
    .join(' ');
};

console.log(reverseWords("Let's take LeetCode contest"));
console.log(newReverseWords("Let's take LeetCode contest"));
```

### [561].Array-Partition-I

```js
/**
 * https://leetcode.com/problems/array-partition-i/description/
 * Difficulty:Easy
 *
 * Given an array of 2n integers, your task is to group these integers into n pairs of integer,
 * say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
 *
 * Example 1:
 * Input: [1,4,3,2]
 * Output: 4
 * Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
 *
 * Note:
 * n is a positive integer, which is in the range of [1, 10000].
 * All the integers in the array will be in the range of [-10000, 10000].
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
  nums.sort((a, b) => {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  });

  // console.log(nums);
  var sum = 0;
  for (var i = 0; i < nums.length / 2; i++) {
    sum += nums[2 * i];
  }

  return sum;
};

console.log(arrayPairSum([1, 4, 3, 2]));
```

### [567].字符串的排列

```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function(s1, s2) {
  if (s1.length > s2.length) {
    return false;
  }
  let s1Map = {};
  for (let i = 0; i < s1.length; i++) {
    if (s1Map[s1[i]]) {
      s1Map[s1[i]]++;
    } else {
      s1Map[s1[i]] = 1;
    }
  }
  for (let i = 0; i <= s2.length - s1.length; i++) {
    let s2Map = {};
    for (let j = 0; j < s1.length; j++) {
      if (s2Map[s2[i + j]]) {
        s2Map[s2[i + j]]++;
      } else {
        s2Map[s2[i + j]] = 1;
      }
    }
    if (mapEqual(s1Map, s2Map)) {
      return true;
    }
  }
  return false;
};
function mapEqual(m1, m2) {
  for (let i in m1) {
    if (m1[i] !== m2[i]) {
      return false;
    }
  }
  return true;
}
```

### [515].Find Largest Value in Each Tree Row

You need to find the largest value in each row of a binary tree.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
const largestValuesAux = (root, depth, map) => {
  // DFS
  if (!root) return;
  if (Number.isInteger(map[depth])) {
    if (map[depth] < root.val) {
      map[depth] = root.val;
    }
  } else {
    map[depth] = root.val;
  }
  if (root.left) largestValuesAux(root.left, depth + 1, map);
  if (root.right) largestValuesAux(root.right, depth + 1, map);
};

/**
 * @param {TreeNode} root
 * @return {number[]}
 */
export default function largestValues(root) {
  const map = [];
  largestValuesAux(root, 0, map);
  return map;
}
```

### [583].

```js
// Given two words word1 and word2, find the minimum number of steps required
// to make word1 and word2 the same, where in each step you can delete one
// character in either string.

// Example:
// Input: "sea", "eat"
// Output: 2
// Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".

// Note:
// The length of given words won't exceed 500.
// Characters in given words can only be lower-case letters.

/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */

/**
 * Longest common subsequence
 */
const LCS = (a, b, n, m, mat) => {
  if (n < 0 || m < 0) return 0;
  if (mat[n][m] !== undefined) return mat[n][m];

  let res;
  if (a[n] === b[m]) {
    res = 1 + LCS(a, b, n - 1, m - 1, mat);
  } else {
    res = Math.max(LCS(a, b, n - 1, m, mat), LCS(a, b, n, m - 1, mat));
  }

  mat[n][m] = res;

  return res;
};

export default function minDistance(word1, word2) {
  // Initialize DP table
  const mat = Array.from(Array(word1.length), () => new Array(word2.length));
  const lcsLength = LCS(word1, word2, word1.length - 1, word2.length - 1, mat);
  return word1.length - lcsLength + word2.length - lcsLength;
}
```

### [516].最长回文子序列 longest-palindromic-subsequence

```
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.

Example 1:
Input:

"bbbab"
Output:
4
One possible longest palindromic subsequence is "bbbb".
Example 2:
Input:

"cbbd"
Output:
2
One possible longest palindromic subsequence is "bb".
```

#### 思路

这是一道最长回文的题目，要我们求出给定字符串的最大回文子序列。解决这类问题的核心思想就是两个字“延伸”，具体来说

- 如果一个字符串是回文串，那么在它左右分别加上一个相同的字符，那么它一定还是一个回文串，因此`回文长度增加2`
- 如果一个字符串不是回文串，或者在回文串左右分别加不同的字符，得到的一定不是回文串,因此回文长度不变，我们取`[i][j-1]`和`[i+1][j]`的较大值

事实上，上面的分析已经建立了大问题和小问题之间的关联，基于此，我们可以建立动态规划模型。

我们可以用 `dp[i][j]` 表示 s 中从 i 到 j(包括 i 和 j)的回文序列长度，状态转移方程只是将上面的描述转化为代码即可：

```js
if (s[i] === s[j]) {
  dp[i][j] = dp[i + 1][j - 1] + 2;
} else {
  dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
}
```

base case 就是一个字符(轴对称点是本身)

#### 代码

```js
var longestPalindromeSubSeq = function(s) {
  const dp = [];
  // 逆循环是因为 i 依赖 i + 1 的值
  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = Array(s.length).fill(0);
    for (let j = i; j < s.length; j++) {
      // base case 就是一个字符
      if (i - j === 0) dp[i][j] = 1;
      else if (s[i] === s[j]) {
        // 如果两头的字符串相等，那么 i-j 的最长回文子序列就 + 2。 在此之前 dp[i + 1] 的值已经全部经过计算
        dp[i][j] = dp[i + 1][j - 1] + 2;
      } else {
        // 如果两头的字符串不相等的话，那么应该看 i 到 j - 1 的最长回文长还是 i + 1 到 j 的最长回文长。 同样，两个比较的值已经经过计算了
        dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
      }
    }
  }

  return dp[0][s.length - 1];
};
```

### [518].coin-change-2

```
You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.



Example 1:

Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
Example 3:

Input: amount = 10, coins = [10]
Output: 1


Note:

You can assume that

0 <= amount <= 5000
1 <= coin <= 5000
the number of coins is less than 500
the answer is guaranteed to fit into signed 32-bit integer

```

#### 思路

这个题目和 coin-change 的思路比较类似。

我们还是按照 coin-change 的思路来， 如果将问题画出来大概是这样：

进一步我们可以对问题进行空间复杂度上的优化(这种写法比较难以理解，但是相对更省空间)

> 这里用动图会更好理解， 有时间的话我会做一个动图出来， 现在大家脑补一下吧

#### 关键点解析

- 动态规划

- 子问题

用 dp[i] 来表示组成 i 块钱，需要最少的硬币数，那么

1. 第 j 个硬币我可以选择不拿 这个时候， 组成数 = dp[i]

2. 第 j 个硬币我可以选择拿 这个时候， 组成数 = dp[i - coins[j]] + dp[i]

- 和背包问题不同， 硬币是可以拿任意个

- 对于每一个 dp[i] 我们都选择遍历一遍 coin， 不断更新 dp[i]

eg:

```js
if (amount === 0) return 1;

const dp = [Array(amount + 1).fill(1)];

for (let i = 1; i < amount + 1; i++) {
  dp[i] = Array(coins.length + 1).fill(0);
  for (let j = 1; j < coins.length + 1; j++) {
    // 从1开始可以简化运算
    if (i - coins[j - 1] >= 0) {
      // 注意这里是coins[j -1]而不是coins[j]
      dp[i][j] = dp[i][j - 1] + dp[i - coins[j - 1]][j]; // 由于可以重复使用硬币所以这里是j不是j-1
    } else {
      dp[i][j] = dp[i][j - 1];
    }
  }
}

return dp[dp.length - 1][coins.length];
```

- 当我们选择一维数组去解的时候，内外循环将会对结果造成影响

eg:

```js
// 这种答案是不对的。
// 原因在于比如amount = 5, coins = [1,2,5]
// 这种算法会将[1,2,2] [2,1,2] [2, 2, 1] 算成不同的

if (amount === 0) return 1;

const dp = [1].concat(Array(amount).fill(0));

for (let i = 1; i < amount + 1; i++) {
  for (let j = 0; j < coins.length; j++) {
    if (i - coins[j] >= 0) {
      dp[i] = dp[i] + dp[i - coins[j]];
    }
  }
}

return dp[dp.length - 1];

// 正确的写法应该是内外循环调换一下, 具体可以看下方代码区
```

#### 代码

```js
/*
 * @lc app=leetcode id=518 lang=javascript
 *
 * [518] Coin Change 2
 *
 * https://leetcode.com/problems/coin-change-2/description/
 *
 * algorithms
 * Medium (41.57%)
 * Total Accepted:    39.7K
 * Total Submissions: 94.6K
 * Testcase Example:  '5\n[1,2,5]'
 *
 * You are given coins of different denominations and a total amount of money.
 * Write a function to compute the number of combinations that make up that
 * amount. You may assume that you have infinite number of each kind of
 * coin.
 *
 *
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: amount = 5, coins = [1, 2, 5]
 * Output: 4
 * Explanation: there are four ways to make up the amount:
 * 5=5
 * 5=2+2+1
 * 5=2+1+1+1
 * 5=1+1+1+1+1
 *
 *
 * Example 2:
 *
 *
 * Input: amount = 3, coins = [2]
 * Output: 0
 * Explanation: the amount of 3 cannot be made up just with coins of 2.
 *
 *
 * Example 3:
 *
 *
 * Input: amount = 10, coins = [10]
 * Output: 1
 *
 *
 *
 *
 * Note:
 *
 * You can assume that
 *
 *
 * 0 <= amount <= 5000
 * 1 <= coin <= 5000
 * the number of coins is less than 500
 * the answer is guaranteed to fit into signed 32-bit integer
 *
 *
 */
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function(amount, coins) {
  if (amount === 0) return 1;

  const dp = [1].concat(Array(amount).fill(0));

  for (let j = 0; j < coins.length; j++) {
    for (let i = 1; i < amount + 1; i++) {
      if (i - coins[j] >= 0) {
        dp[i] = dp[i] + dp[i - coins[j]];
      }
    }
  }

  return dp[dp.length - 1];
};
```

#### 扩展

这是一道很简单描述的题目， 因此很多时候会被用到大公司的电面中。

相似问题:

[322.coin-change](./322.coin-change.md)

### [560].subarray-sum-equals-k

```
Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

Example 1:
Input:nums = [1,1,1], k = 2
Output: 2
Note:
The length of the array is in range [1, 20,000].
The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].

```

#### 思路

符合直觉的做法是暴力求解所有的子数组，然后分别计算和，如果等于 k,count 就+1.这种做法的时间复杂度为 O(n^2).

这里有一种更加巧妙的方法，我们可以借助额外的空间，使用 hashmap 来简化时间复杂度，这种算法的时间复杂度可以达到 O(n).

我们维护一个 hashmap，hashmap 的 key 为累加值 acc，value 为累加值 acc 出现的次数。
我们迭代数组，然后不断更新 acc 和 hashmap，如果 acc 等于 k，那么很明显应该+1. 如果 hashmap[acc - k] 存在，
我们就把它加到结果中去即可。

语言比较难以解释，我画了一个图来演示 nums = [1,2,3,3,0,3,4,2], k = 6 的情况。

如图，当访问到 nums[3]的时候，hashmap 如图所示，这个时候 count 为 2.
其中之一是[1,2,3],这个好理解。还有一个是[3,3].

这个[3,3]正是我们通过 hashmap[acc - k]即 hashmap[9 - 6]得到的。

#### 关键点解析

- 可以利用 hashmap 记录和的累加值来避免重复计算

#### 代码

```js
/*
 * @lc app=leetcode id=560 lang=javascript
 *
 * [560] Subarray Sum Equals K
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function(nums, k) {
  const hashmap = {};
  let acc = 0;
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    acc += nums[i];

    if (acc === k) count++;

    if (hashmap[acc - k] !== void 0) {
      count += hashmap[acc - k];
    }

    if (hashmap[acc] === void 0) {
      hashmap[acc] = 1;
    } else {
      hashmap[acc] += 1;
    }
  }

  return count;
};
```

#### 扩展

这是一道类似的题目，但是会稍微复杂一点, 题目地址: [437.path-sum-iii](./437.path-sum-iii.md)

### [594].longest-harmonious-subsequence

```js
/*
 * @lc app=leetcode id=594 lang=javascript
 *
 * [594] Longest Harmonious Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLHS = function(nums) {
  // Input: [1,3,2,2,5,2,3,7]
  // Output: 5
  // Explanation: The longest harmonious subsequence is [3,2,2,2,3].
  if (nums.length === 0) return 0;
  const counts = {};
  let res = 0;

  for (let i = 0; i < nums.length; i++) {
    if (!counts[nums[i]]) {
      counts[nums[i]] = 1;
    } else {
      counts[nums[i]] += 1;
    }
  }

  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i] + 1]) {
      res = Math.max(res, counts[nums[i]] + counts[nums[i] + 1]);
    }
  }

  return res;
};
```

### [575].distribute-candies

```
Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.
Example 1:
Input: candies = [1,1,2,2,3,3]
Output: 3
Explanation:
There are three different kinds of candies (1, 2 and 3), and two candies for each kind.
Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.
The sister has three different kinds of candies.
Example 2:
Input: candies = [1,1,2,3]
Output: 2
Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].
The sister has two different kinds of candies, the brother has only one kind of candies.
Note:

The length of the given array is in range [2, 10,000], and will be even.
The number in given array is in range [-100,000, 100,000].
```

#### 思路

由于糖果是偶数，并且我们只需要做到两个人糖果数量一样即可。

考虑两种情况:

- 如果糖果种类大于 n / 2(糖果种类数为 n)，妹妹最多可以获得的糖果种类应该是`n / 2`(因为妹妹只有 n / 2 个糖).
- 糖果种类数小于 n / 2, 妹妹能够得到的糖果种类可以是糖果的种类数(糖果种类本身就这么多).

因此我们发现，妹妹能够获得的糖果种类的制约因素其实是糖果种类数。

#### 关键点解析

- 这是一道逻辑题目，因此如果逻辑分析清楚了，代码是自然而然的

#### 代码

```js
/*
 * @lc app=leetcode id=575 lang=javascript
 *
 * [575] Distribute Candies
 */
/**
 * @param {number[]} candies
 * @return {number}
 */
var distributeCandies = function(candies) {
  const count = new Set(candies);
  return Math.min(count.size, candies.length >> 1);
};
```

### [538].convert-bst-to-greater-tree

```js
/*
 * @lc app=leetcode id=538 lang=javascript
 *
 * [538] Convert BST to Greater Tree
 *
 * https://leetcode.com/problems/convert-bst-to-greater-tree/description/
 *
 * algorithms
 * Easy (50.04%)
 * Total Accepted:    75.4K
 * Total Submissions: 149K
 * Testcase Example:  '[5,2,13]'
 *
 * Given a Binary Search Tree (BST), convert it to a Greater Tree such that
 * every key of the original BST is changed to the original key plus sum of all
 * keys greater than the original key in BST.
 *
 *
 * Example:
 *
 * Input: The root of a Binary Search Tree like this:
 * ⁠             5
 * ⁠           /   \
 * ⁠          2     13
 *
 * Output: The root of a Greater Tree like this:
 * ⁠            18
 * ⁠           /   \
 * ⁠         20     13
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
  let res = 0;
  function r(root) {
    if (root === null) return null;

    r(root.right);

    root.val += res;

    res = +root.val;

    r(root.left);

    return root;
  }
  r(root);
  return root;
};
```

### [540].single-element-in-a-sorted-array

```js
/*
 * @lc app=leetcode id=540 lang=javascript
 *
 * [540] Single Element in a Sorted Array
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function(nums) {
  //   if (nums.length === 1) return nums[0]
  //   nums.sort();
  //   for (let i = 0; i < nums.length; i++) {
  //     if (nums[i] === nums[i + 1]) {
  //       i++;
  //     } else {
  //         return nums[i];
  //     }
  //   }

  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === nums[mid + 1]) {
      if (mid % 2 === 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    } else if (nums[mid] === nums[mid - 1]) {
      if (mid % 2 === 0) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    } else {
      return nums[mid];
    }
  }
};
```

### [543].diameter-of-binary-tree

```js
/*
 * @lc app=leetcode id=543 lang=javascript
 *
 * [543] Diameter of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function maxDepth(root, res) {
  if (root === null) return 0;

  const l = maxDepth(root.left, res);
  const r = maxDepth(root.right, res);
  res.val = Math.max(res.val, l + r);
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
  // 如果不计算max， 直接1+ Math.max(maxLeft, maxRight)， 得到的结果实际上是经过root节点的最大值，并不一定是总体最大值
  // 题目也做了说明， ”最大值不一定经过root“
  if (root === null) return 0;
  const res = {
    val: 0,
  };

  maxDepth(root, res);

  return res.val;
};
```

### [594]. Longest Harmonious Subsequence

#### 信息卡片

- 题目链接：https://leetcode.com/problems/longest-harmonious-subsequence/
- tag：`Array`

```
We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.

Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.

Example 1:

  Input: [1,3,2,2,5,2,3,7]
  Output: 5
  Explanation: The longest harmonious subsequence is [3,2,2,2,3].
```

#### 思路

1. 将数组中的值作为一个对象中的属性，出现的次数就是属性值
2. 属性差一的值相加，获取最大的，否则返回 0；

#### 参考答案

```js
/**
 * @param {number[]} nums
 * @return {number}
 * 使用ES6中的Map
 */
var findLHS = function(nums) {
  if (!nums.length) return 0;
  const map = new Map();
  let max = 0;
  for (let i = 0; i < nums.length; i++) {
    let target = nums[i];
    if (map.has(target)) {
      map.set(target, map.get(target) + 1);
    } else {
      map.set(target, 1);
    }
  }
  for (let key of map.keys()) {
    if (map.has(key + 1)) {
      max = Math.max(map.get(key) + map.get(key + 1), max);
    }
  }
  return max;
};
```

##### 其它优秀解法

```js
/**
 * @param {number[]} nums
 * @return {number}
 * for...in遍历
 */
var findLHS = function(nums) {
  if (!nums.length) return 0;
  const counts = {};
  let max = 0;
  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i]]) {
      counts[nums[i]] += 1;
    } else {
      counts[nums[i]] = 1;
    }
  }
  for (let key in counts) {
    // for...in性能低
    if (counts[+key + 1]) {
      max = Math.max(counts[key] + counts[+key + 1], max);
    }
  }
  return max;
};

/**
 * @param {number[]} nums
 * @return {number}
 * 普通遍历
 */
var findLHS = function(nums) {
  if (!nums.length) return 0;
  const counts = {};
  let max = 0;
  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i]]) {
      counts[nums[i]] += 1;
    } else {
      counts[nums[i]] = 1;
    }
  }
  for (let i = 0; i < nums.length; i++) {
    // 有多余的无效遍历
    if (counts[nums[i] + 1]) {
      max = Math.max(max, counts[nums[i]] + counts[nums[i] + 1]);
    }
  }
  return max;
};
```

####### 圆桌一先一后

- 题目链接：暂无
- tag：`逻辑思维`

：

```
考虑一个双人游戏。游戏在一个圆桌上进行。每个游戏者都有足够多的硬币。他们需要在桌子上轮流放置硬币，每次必需且只能放置一枚硬币，要求硬币完全置于桌面内(不能有一部分悬在桌子外面)，并且不能与原来放过的硬币重叠。谁没有地方放置新的硬币，谁就输了。游戏的先行者还是后行者有必胜策略？这种策略是什么？
```

##### 参考答案

思路如下：

首先，谁有必胜机会？
假设硬币跟桌子一样大，必然是先手者胜，所以这题的第一问答案必然是先手必胜

再假设硬币的大小是圆桌的“微分”，一个硬币就一个点的大小，那么桌子上就可以放下 ∞ 个硬币，但是因为圆桌本身是个圆，而圆关于圆心对称，所以一定是奇数个点，多出来的这个点是作为对称中心的圆心，再次印证结论先手必胜。

必胜的策略，先手抢圆心，之后保持和对方放置的硬币关于圆心对称即可

##### 扩展

**扩展一：**

有 1996 个棋子,两人轮流取棋子,每次允许取其中的 2 个,4 个或 8 个,
谁最后取完棋子,就算获胜.那么先取的人为保证获胜,第一次应取几个棋子?

**参考答案：**

1. 1996 这一类的问题其实 1996 和 11992 关系不大，先记为 M，重要的是可选的{a,b,c...}这些选项
2. 将选项集合记为 K={a,b,c..}，在对方报出 A∈K 后，必有 B∈K 使得 A+B = n \* γ(n 是正整数)，本题中 γ 为 6
3. 确定好 γ 以后，剩下要做的事情就是 M 对 γ 取余，本题中 M%γ=332 余 4
4. 4 是{abc...}里的一个选项，所以先手取 4 个棋子必胜

**扩展二：**

在一个 4×5 的棋盘中,甲,乙两人轮流往棋盘的方格中放棋子,甲先放第一枚棋子,乙只能在与这枚棋子的相邻的格内放棋子(相邻是指有公共边的两个格),甲再放时又必须在乙刚放的棋子的相邻的格内放,以后照此规则放,谁无法放棋子的时候谁失败,如果都按最佳方案,谁取胜?

**扩展三：**

上述的题目全部变成变量，然后用代码写出来

####### squares-of-a-sorted-array

- 题目链接：https://leetcode.com/problems/squares-of-a-sorted-array/
- tag：`Array` `Two Pointers`

```
Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.



Example 1:

Input: [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Example 2:

Input: [-7,-3,2,3,11]
Output: [4,9,9,49,121]


Note:

1 <= A.length <= 10000
-10000 <= A[i] <= 10000
A is sorted in non-decreasing order.

```

##### 思路

典型的双指针问题。我们记录头尾指针，
然后每次`移动两个指针指向的值中绝对值较大的那个`就好了。

这个很好理解，因为是从小到大排列，我们可以获取到最小的元素和最大的元素。
平方较大的元素一定是最小的元素或者最大的元素，因此我们两个指针指向首尾就好了。

更新的策略也很简单，由于我们取得的绝对值是从大到小的，因此我们新建一个数组，
然后从后面往前放就好了。

##### 参考答案

```js
/*
 * @lc app=leetcode id=977 lang=javascript
 *
 * [977] Squares of a Sorted Array
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortedSquares = function(A) {
  let start = 0;
  let end = A.length - 1;
  const res = [];
  let cur = 0;

  while (start <= end) {
    if (Math.abs(A[start]) === Math.abs(A[end])) {
      cur++;
      res[A.length - cur] = A[start] * A[start];
      cur++;
      res[A.length - cur] = A[end] * A[end];
      start++;
      end--;
    } else if (Math.abs(A[start]) > Math.abs(A[end])) {
      cur++;
      res[A.length - cur] = A[start] * A[start];
      start++;
    } else {
      cur++;
      res[A.length - cur] = A[end] * A[end];
      end--;
    }
  }

  return res;
};
```

### [524].longest-word-in-dictionary-through-deleting

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/
- tag：`String` `Two Pointers`

```
给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

示例 1:

输入:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

输出:
"apple"
示例 2:

输入:
s = "abpcplea", d = ["a","b","c"]

输出:
"a"
说明:

1. 所有输入的字符串只包含小写字母。
2. 字典的大小不会超过 1000。
3. 所有输入的字符串长度不会超过 1000。

```

#### 参考答案

我们的思路是删除字符串中的某些字符，使得可以组成数组中的字符串，
然后我们找到最长。

`字符串删除某些字符，使之成为另一个字符串`，这本质上是字符串子序列问题。

求解 subSequence 的题目，可以用双指针解决
比如在字符串 a 中查找 b，那么快指针在 a 上，慢指针在 b。 快指针一直更新，慢指针只有两个相等才更新
最后比较慢指针是否走到底了即可

参考 JavaScript 代码：

```js
function isSequence(s, word) {
  if (word.length > s.length) return false;

  let i = 0;
  let j = 0;

  while (i < s.length && j < s.length) {
    if (word[i] === s[j]) i++;
    j++;
  }

  // 说明有s中有word.length个元素和word匹配(且顺序一致)
  // 换句话说就是word是s的子序列
  return i === word.length;
}
/**
 * @param {string} s
 * @param {string[]} d
 * @return {string}
 */
var findLongestWord = function(s, d) {
  let res = '';

  for (let word of d) {
    if (isSequence(s, word)) {
      if (word.length > res.length) res = word;
      else if (word.length === res.length && word.charAt(0) < res.charAt(0)) res = word;
    }
  }

  return res;
};
```

### [547].朋友圈

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/friend-circles

* tag：`并查集` `BFS`

班上有  N  名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B  的朋友，B 是 C  的朋友，那么我们可以认为 A 也是 C  的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个  N \* N  的矩阵  M，表示班级中学生之间的朋友关系。如果 M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

**示例 1:**

```
输入:
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。
```

**示例 2:**

```
输入:
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```

注意：

1. N 在[1,200]的范围内。
2. 对于所有学生，有 M[i][i] = 1。
3. 如果有 M[i][j] = 1，则有 M[j][i] = 1。

#### 参考答案

##### 解法一：并查集

遍历邻接矩阵 M，如果 M[i][j]==1 即二者是朋友，那么合并 i,j 集合，遍历完整个矩阵 M 后则剩余的集合数量就是有多少个朋友圈。其中路径压缩能大大降低算法的时间复杂度：合并时让当前节点归属指向朋友圈的根节点，下次查询时就能快许多。

```
class Solution {
public:
    int findCircleNum(vector<vector<int>>& M) {
        if (M.empty())
            return 0;
        vector<int> pre(M.size());
        for(int i=0; i<M.size(); i++)
            pre[i] = i;//先各自为组，组名也为自己的序号
        int group = M.size();//一开始有多少人就有多少个朋友圈，当每出现一对朋友时就减1，最后就是总的朋友圈数量了。
        for(int i=0; i<M.size(); i++)
        {
            for(int j=0; j<M.size(); j++)
            {
                if (i != j && M[i][j] == 1)
                {
                    int x1 = find(i, pre);//x1为i所属的组
                    int x2 = find(j, pre);//x2为j所属的组
                    if (x1 != x2)
                    {
                        //如果不属于同个朋友圈的话就把i归为j的组
                        pre[x1] = x2;
                        group--;
                    }
                }
            }
        }
        return group;
    }
private:
    int find(int x, vector<int>& pre)
    {
        //“pre[x] = ”这句为路径压缩，直接指向组的根节点，下次查询时就快很多了。
        return pre[x]==x ? x : pre[x] = find(pre[x], pre);
    }
};
```

##### 解法二：BFS

时间复杂度 O(n²)

> 可以将题目转换为是在一个图中求连通子图的问题，给出的 N\*N 的矩阵就是邻接矩阵，建立 N 个节点的 visited 数组，从 not visited 的节点开始深度优先遍历，遍历就是在邻接矩阵中去遍历，如果在第 i 个节点的邻接矩阵那一行中的第 j 个位置处 M[i][j]==1 and not visited[j]，就应该 dfs 到这个第 j 个节点的位置，

```java
public class Solution {
    public void dfs(int[][] M, int[] visited, int i) {
        for (int j = 0; j < M.length; j++) {
            if (M[i][j] == 1 && visited[j] == 0) {
                visited[j] = 1;
                dfs(M, visited, j);
            }
        }
    }
    public int findCircleNum(int[][] M) {
        int[] visited = new int[M.length];
        int count = 0;
        for (int i = 0; i < M.length; i++) {
            if (visited[i] == 0) {
                dfs(M, visited, i);
                count++;
            }
        }
        return count;
    }
}
```

### [594].longest-harmonious-subsequence

```js
/*
 * @lc app=leetcode id=594 lang=javascript
 *
 * [594] Longest Harmonious Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLHS = function(nums) {
  // Input: [1,3,2,2,5,2,3,7]
  // Output: 5
  // Explanation: The longest harmonious subsequence is [3,2,2,2,3].
  if (nums.length === 0) return 0;
  const counts = {};
  let res = 0;

  for (let i = 0; i < nums.length; i++) {
    if (!counts[nums[i]]) {
      counts[nums[i]] = 1;
    } else {
      counts[nums[i]] += 1;
    }
  }

  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i] + 1]) {
      res = Math.max(res, counts[nums[i]] + counts[nums[i] + 1]);
    }
  }

  return res;
};
```

### [501].Find-Mode-in-Binary-Search-Tree

#### Problem on LeetCode

https://leetcode.com/problems/find-mode-in-binary-search-tree/

#### Description

Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.

Assume a BST is defined as follows:

- The left subtree of a node contains only nodes with keys less than or equal to the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

For example:
Given BST `[1,null,2,2]`,

```bash
   1
    \
     2
    /
   2
```

return `[2]`.

Note: If a tree has more than one mode, you can return them in any order.

Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).

#### Ideas

Basically, it needs traversing, counting and recording. `map` can be used to help us to do record and count.
For doing that without using any extra space, the property of BST will be used. For each node, the value of the left child is no greater than its value, while the value of right child is no less than the its value. So, when traversing each node, only the value of previous node is required to be compared with the value of current node for counting.
As the problem shown, an array of intergers will be returned. While the number of modes is unknown, using `ArrayList` to store all outputs is a good choice because `ArrayList` can be converted into array conveniently.

#### Codes

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList<> ();
    TreeNode preNode = null;
    int max = 0, count = 0;

    public int[] findMode(TreeNode root) {
        helper(root);
        int[] res = new int[list.size()];
        for (int i=0; i<res.length; i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    private void helper (TreeNode root) {
        if (root == null) return;
        helper(root.left);

        if (preNode != null && root.val == preNode.val) {
            count++;
        } else {
            count = 1;
        }

        if (count > max) {
            list.clear();
            list.add(root.val);
            max = count;
        } else if (max == count) {
            list.add(root.val);
        }
        preNode = root;
        helper(root.right);
    }
}
```
