---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### 504.Base-7

```js
/**
 * https://leetcode.com/problems/base-7/description/
 * Difficulty:Easy
 *
 * Given an integer, return its base 7 string representation.
 * Example 1:
 * Input: 100
 * Output: "202"
 * Example 2:
 * Input: -7
 * Output: "-10"
 * Note: The input will be in range of [-1e7, 1e7].
 *
 */

/**
 * @param {number} num
 * @return {string}
 */
var convertToBase7 = function(num) {
  if (num === 0) return '0';
  var str = '';
  var sign = num > 0;
  num = Math.abs(num);
  while (num) {
    str = (num % 7) + str;
    num = Math.floor(num / 7);
  }

  return sign ? str : '-' + str;
};

console.log(convertToBase7(0));
console.log(convertToBase7(100));
console.log(convertToBase7(-7));
```

### 506.Relative-Ranks

```js
/**
 * https://leetcode.com/problems/relative-ranks/description/
 * Difficulty:Easy
 *
 * Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".
 *
 * Example 1:
 * Input: [5, 4, 3, 2, 1]
 * Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
 * Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal".
 * For the left two athletes, you just need to output their relative ranks according to their scores.
 * Note:
 * N is a positive integer and won't exceed 10,000.
 * All the scores of athletes are guaranteed to be unique.
 *
 */

/**
 * @param {number[]} nums
 * @return {string[]}
 */
var findRelativeRanks = function(nums) {
  var medals = ['Gold Medal', 'Silver Medal', 'Bronze Medal'];
  var ranks = [];
  Array.prototype.push.apply(ranks, nums);
  ranks.sort(function(a, b) {
    return b - a;
  });

  return nums.map(n => {
    var rank = ranks.indexOf(n);
    return medals[rank] || rank + 1 + '';
  });
};

// ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
console.log(findRelativeRanks([10, 3, 8, 9, 4]));

console.log(findRelativeRanks([5, 4, 1, 2, 3]));
```

### 520.Detect-Capital

```js
/**
 * https://leetcode.com/problems/detect-capital/description/
 * Difficulty:Easy
 *
 * Given a word, you need to judge whether the usage of capitals in it is right or not.
 * We define the usage of capitals in a word to be right when one of the following cases holds:
 * All letters in this word are capitals, like "USA".
 * All letters in this word are not capitals, like "leetcode".
 * Only the first letter in this word is capital if it has more than one letter, like "Google".
 * Otherwise, we define that this word doesn't use capitals in a right way.
 *
 */

/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
  var len = word.length;
  var upperLen = 0;
  var lowerLen = 0;
  var firstCap = false;
  for (var i = 0; i < len; i++) {
    var ch = word[i];
    if (/[A-Z]/.test(ch)) {
      upperLen++;
      if (i == 0) {
        firstCap = true;
      }
    }
    if (/[a-z]/.test(ch)) {
      lowerLen++;
    }
  }
  if (upperLen == len) return true;
  if (lowerLen == len) return true;
  return upperLen == 1 && firstCap && len > 1;
};

/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
  var isFirstChUpper = false;
  var upperCnt = 0;
  var n = word.length;

  for (let i = 0; i < n; i++) {
    let ch = word[i];
    if (ch >= 'A' && ch <= 'Z') {
      upperCnt++;
      if (i === 0) isFirstChUpper = true;
    }
  }

  if (isFirstChUpper) {
    return upperCnt === 1 || upperCnt === n;
  } else {
    return upperCnt === 0;
  }
};

console.log(detectCapitalUse('USA'));
console.log(detectCapitalUse('FlaG'));
console.log(detectCapitalUse('A'));
console.log(detectCapitalUse('Google'));
console.log(detectCapitalUse('leetcode'));
```

### 523.Continuous-Subarray-Sum

```js
/**
 * https://leetcode.com/problems/continuous-subarray-sum/description/
 * Difficulty:Medium
 *
 * Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer
 *
 * Example 1:
 * Input: [23, 2, 4, 6, 7],  k=6
 * Output: True
 * Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.
 *
 * Example 2:
 * Input: [23, 2, 6, 4, 7],  k=6
 * Output: True
 * Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.
 *
 * Note:
 * The length of the array won't exceed 10,000.
 * You may assume the sum of all the numbers is in the range of a signed 32-bit integer.
 */

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function(nums, k) {
  var arr = [];
  var sum = 0;
  if (nums.length < 2) return false;
  for (var i = 0; i < nums.length - 1; i++) {
    if (nums[i] + nums[i + 1] === 0) return true;
  }

  if (k < 0) k = -k;
  if (k === 0) return false;

  for (i = 0; i < nums.length; i++) {
    sum += nums[i];
    sum = sum % k;
    if (i > 0 && sum === 0) return true;
    var index = arr.indexOf(sum);
    if (index !== -1) {
      return true;
    }
    arr.push(sum);
  }
  return false;
};

console.log(checkSubarraySum([23, 2, 4, 6, 7], 6));
console.log(checkSubarraySum([23, 2, 4, 6, 7], 7));
console.log(checkSubarraySum([23, 2, 4, 6, 7], 8));
console.log(checkSubarraySum([0, 0], 0), true);
console.log(checkSubarraySum([0, 1, 0], 0), false);
console.log(checkSubarraySum([1, 1], 2), true);
```

### 524.通过删除字母匹配到字典里最长单词

```js
/*
 * @lc app=leetcode.cn id=524 lang=javascript
 *
 * [524] 通过删除字母匹配到字典里最长单词
 */
/**
 * @param {string} s
 * @param {string[]} d
 * @return {string}
 */
var findLongestWord = function(s, d) {
  const minSubStr = [];
  for (let i = 0; i < d.length; i++) {
    const target = d[i];
    if (isSubStr(s, target)) {
      if (minSubStr.length === 0) {
        minSubStr.push(target);
      } else if (
        target.length > minSubStr[0].length ||
        (target.length === minSubStr[0].length && target < minSubStr[0])
      ) {
        // 只会等于 1 不会大于 1
        minSubStr[0] = target;
      }
    }
  }
  return minSubStr.length ? minSubStr[0] : '';
};

// 判断是否是子串，通过双指针来判断
function isSubStr(s, p) {
  // 分别指向模式串和标准串
  let i = (j = 0);
  while (i < s.length && j < p.length) {
    if (s[i] === p[j]) {
      j++;
    }
    // 如果两个不匹配的话，就意味着删除对应位置的字符串即可
    i++;
  }
  // 匹配完成.
  // 既然是删除 s 中的一些字符串来匹配 p 所以 p 匹配结束了就表示匹配完成了
  // 否则如果是 s 先匹配结束说明永远都匹配不了 p
  return j === p.length;
}

// console.log(findLongestWord('abpcplea', ["ale", "apple", "monkey", "plea"]))
// console.log(findLongestWord('abpcplea', ["a", "b", "c"]))
// console.log(findLongestWord('bab', ["ba", "ab", "a", "b"]))
```

### 538.convert-bst-to-greater-tree

```js
/*
 * @lc app=leetcode id=538 lang=javascript
 *
 * [538] Convert BST to Greater Tree
 *
 * https://leetcode.com/problems/convert-bst-to-greater-tree/description/
 *
 * algorithms
 * Easy (50.04%)
 * Total Accepted:    75.4K
 * Total Submissions: 149K
 * Testcase Example:  '[5,2,13]'
 *
 * Given a Binary Search Tree (BST), convert it to a Greater Tree such that
 * every key of the original BST is changed to the original key plus sum of all
 * keys greater than the original key in BST.
 *
 *
 * Example:
 *
 * Input: The root of a Binary Search Tree like this:
 * ⁠             5
 * ⁠           /   \
 * ⁠          2     13
 *
 * Output: The root of a Greater Tree like this:
 * ⁠            18
 * ⁠           /   \
 * ⁠         20     13
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
  let res = 0;
  function r(root) {
    if (root === null) return null;

    r(root.right);

    root.val += res;

    res = +root.val;

    r(root.left);

    return root;
  }
  r(root);
  return root;
};
```

### 540.single-element-in-a-sorted-array

```js
/*
 * @lc app=leetcode id=540 lang=javascript
 *给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

示例 1:

输入: [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: [3,3,7,7,10,11,11]
输出: 10
注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
 * [540] Single Element in a Sorted Array
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate1 = function(nums) {
  //   if (nums.length === 1) return nums[0]
  //   nums.sort();
  //   for (let i = 0; i < nums.length; i++) {
  //     if (nums[i] === nums[i + 1]) {
  //       i++;
  //     } else {
  //         return nums[i];
  //     }
  //   }

  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === nums[mid + 1]) {
      if (mid % 2 === 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    } else if (nums[mid] === nums[mid - 1]) {
      if (mid % 2 === 0) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    } else {
      return nums[mid];
    }
  }
};

// 错了。。。。
var singleNonDuplicate = function(nums) {
  // 有序，缺少一个值。
  // 给定的排序数组肯定是单数.
  const n = Math.ceil(nums.length / 2);
  const sum = (nums[0] + nums[nums.length - 1]) * n;
  let sum1 = nums.reduce((sum, num) => sum + num, 0);
  console.log('sum', sum);
  console.log('sum1', sum1);
  return sum - sum1;
};

// console.log(singleNonDuplicate([1, 1, 2, 3, 3, 4, 4, 8, 8]))
// console.log(singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]))
console.log(singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]));
```

### 541.反转字符串-ii

```js
/*
 * @lc app=leetcode.cn id=541 lang=javascript
 *
 * [541] 反转字符串 II
 */
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
  let strArr = [];
  // 1. 截断字符串
  while (s) {
    strArr.push(s.slice(0, 2 * k));
    s = s.slice(2 * k);
  }
  return strArr
    .map(str => {
      return reverseArr(str.split(''), 0, k - 1).join('');
    })
    .join('');
};

// 原地反转
const reverseArr = (arr, start = 0, end = arr.length) => {
  let i = start,
    j = end;
  while (i < j) {
    [arr[i], arr[j]] = [arr[j], arr[i]];
    i++;
    j--;
  }
  return arr;
};

//溜啊
var newReverseStr = function(s, k) {
  if (k > s.length)
    return s
      .split('')
      .reverse()
      .join('');

  const split = s.split('');
  // 将需要翻转部分先翻转，后插入
  for (let i = 0; i < s.length; i += 2 * k) {
    const reverse = split.splice(i, k).reverse();
    split.splice(i, 0, ...reverse);
  }
  return split.join('');
};

console.log(reverseStr('abcdefg', 2));
console.log(newReverseStr('abcdefg', 2));
```

### 543.diameter-of-binary-tree

```js
/*
 * @lc app=leetcode id=543 lang=javascript
 *
 * [543] Diameter of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function maxDepth(root, res) {
  if (root === null) return 0;

  const l = maxDepth(root.left, res);
  const r = maxDepth(root.right, res);
  res.val = Math.max(res.val, l + r);
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
  // 如果不计算max， 直接1+ Math.max(maxLeft, maxRight)， 得到的结果实际上是经过root节点的最大值，并不一定是总体最大值
  // 题目也做了说明， ”最大值不一定经过root“
  if (root === null) return 0;
  const res = {
    val: 0,
  };

  maxDepth(root, res);

  return res.val;
};
```

### 543.二叉树的直径

```js
/*
 * @lc app=leetcode.cn id=543 lang=javascript
 *
 * [543] 二叉树的直径
 * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。
 * 注意：两结点之间的路径长度是以它们之间边的数目表示。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
let max = 0;
var diameterOfBinaryTree = function(root) {
  // if (root == null) return 0;
  depth(root);
  return max;
};

var depth = function(root) {
  if (!root) return 0;
  let l = depth(root.left);
  let r = depth(root.right);
  // 累加结果比较
  max = Math.max(max, l + r);
  // 需要返回最大的深度
  return Math.max(l, r) + 1;
};

console.log(diameterOfBinaryTree({ val: null, left: null, right: null }));
console.log(diameterOfBinaryTree({ val: 1, left: null, right: null }));

// ✘ Wrong Answer
// ✘ 46 / 106 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: 3
// ✘ expected_answer: 0
// ✘ stdout:

// ✘ Wrong Answer
// ✘ 46 / 106 cases passed(N / A)
// ✘ testcase: '[1]'
// ✘ answer: 3
// ✘ expected_answer: 0
// ✘ stdout:
```

### 557.Reverse-Words-in-a-String-III

```js
/**
 * https://leetcode.com/problems/reverse-words-in-a-string-iii/description/
 * Difficulty:Easy
 *
 * Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
 * Example 1:
 * Input: "Let's take LeetCode contest"
 * Output: "s'teL ekat edoCteeL tsetnoc"
 * Note: In the string, each word is separated by single space and there will not be any extra space in the string.
 */

/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s
    .split(' ')
    .map(w =>
      w
        .split('')
        .reverse()
        .join(''),
    )
    .join(' ');
};

console.log(reverseWords(`Let's take LeetCode contest`));
```

### 557.反转字符串中的单词-iii

```js
/*
 * @lc app=leetcode.cn id=557 lang=javascript
 *
 * [557] 反转字符串中的单词 III
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  // 需要注意的是，reverse 是数组拥有的函数，并不是字符串
  return s
    .split(' ')
    .map(item => {
      return item
        .split('')
        .reverse()
        .join('');
    })
    .join(' ');
};

var newReverseWords = function(s) {
  // 正则匹配一个单词，从左到右一个单词一个单词进行匹配
  return s
    .match(/[\w']+/g)
    .map(item => {
      return item
        .split('')
        .reverse()
        .join('');
    })
    .join(' ');
};

console.log(reverseWords("Let's take LeetCode contest"));
console.log(newReverseWords("Let's take LeetCode contest"));
```

### 561.Array-Partition-I

```js
/**
 * https://leetcode.com/problems/array-partition-i/description/
 * Difficulty:Easy
 *
 * Given an array of 2n integers, your task is to group these integers into n pairs of integer,
 * say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
 *
 * Example 1:
 * Input: [1,4,3,2]
 * Output: 4
 * Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
 *
 * Note:
 * n is a positive integer, which is in the range of [1, 10000].
 * All the integers in the array will be in the range of [-10000, 10000].
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
  nums.sort((a, b) => {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  });

  // console.log(nums);
  var sum = 0;
  for (var i = 0; i < nums.length / 2; i++) {
    sum += nums[2 * i];
  }

  return sum;
};

console.log(arrayPairSum([1, 4, 3, 2]));
```

### [567].字符串的排列

```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function(s1, s2) {
  if (s1.length > s2.length) {
    return false;
  }
  let s1Map = {};
  for (let i = 0; i < s1.length; i++) {
    if (s1Map[s1[i]]) {
      s1Map[s1[i]]++;
    } else {
      s1Map[s1[i]] = 1;
    }
  }
  for (let i = 0; i <= s2.length - s1.length; i++) {
    let s2Map = {};
    for (let j = 0; j < s1.length; j++) {
      if (s2Map[s2[i + j]]) {
        s2Map[s2[i + j]]++;
      } else {
        s2Map[s2[i + j]] = 1;
      }
    }
    if (mapEqual(s1Map, s2Map)) {
      return true;
    }
  }
  return false;
};
function mapEqual(m1, m2) {
  for (let i in m1) {
    if (m1[i] !== m2[i]) {
      return false;
    }
  }
  return true;
}
```

### [515].Find Largest Value in Each Tree Row

You need to find the largest value in each row of a binary tree.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
const largestValuesAux = (root, depth, map) => {
  // DFS
  if (!root) return;
  if (Number.isInteger(map[depth])) {
    if (map[depth] < root.val) {
      map[depth] = root.val;
    }
  } else {
    map[depth] = root.val;
  }
  if (root.left) largestValuesAux(root.left, depth + 1, map);
  if (root.right) largestValuesAux(root.right, depth + 1, map);
};

/**
 * @param {TreeNode} root
 * @return {number[]}
 */
export default function largestValues(root) {
  const map = [];
  largestValuesAux(root, 0, map);
  return map;
}
```

### [583].

```js
// Given two words word1 and word2, find the minimum number of steps required
// to make word1 and word2 the same, where in each step you can delete one
// character in either string.

// Example:
// Input: "sea", "eat"
// Output: 2
// Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".

// Note:
// The length of given words won't exceed 500.
// Characters in given words can only be lower-case letters.

/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */

/**
 * Longest common subsequence
 */
const LCS = (a, b, n, m, mat) => {
  if (n < 0 || m < 0) return 0;
  if (mat[n][m] !== undefined) return mat[n][m];

  let res;
  if (a[n] === b[m]) {
    res = 1 + LCS(a, b, n - 1, m - 1, mat);
  } else {
    res = Math.max(LCS(a, b, n - 1, m, mat), LCS(a, b, n, m - 1, mat));
  }

  mat[n][m] = res;

  return res;
};

export default function minDistance(word1, word2) {
  // Initialize DP table
  const mat = Array.from(Array(word1.length), () => new Array(word2.length));
  const lcsLength = LCS(word1, word2, word1.length - 1, word2.length - 1, mat);
  return word1.length - lcsLength + word2.length - lcsLength;
}
```
