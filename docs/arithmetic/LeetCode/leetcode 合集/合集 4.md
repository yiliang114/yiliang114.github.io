---
layout: CustomPages
title: LeetCode-合集 0-100
date: 2020-09-04
aside: false
draft: true
---

# 004-Median-of-Two-Sorted-Arrays

```js
/**
 * https://leetcode.com/problems/median-of-two-sorted-arrays/description/
 * Difficulty:Hard
 *
 * There are two sorted arrays nums1 and nums2 of size m and n respectively.
 * Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
 *
 * Example 1:
 * nums1 = [1, 3]
 * nums2 = [2]
 * The median is 2.0
 *
 * Example 2:
 * nums1 = [1, 2]
 * nums2 = [3, 4]
 * The median is (2 + 3)/2 = 2.5
 * *
 */

function kth(arr1, s1, n1, arr2, s2, n2, k) {
  // console.log(arr1, s1, n1, arr2, s2, n2, k);
  // console.log('-----------');
  if (k < 1 || k > n1 + n2) return -1;

  if (n1 > n2) {
    return kth(arr2, s2, n2, arr1, s1, n1, k);
  }

  if (n1 === 0) {
    return arr2[s2 + k - 1];
  }

  if (k === 1) {
    return arr1[s1] < arr2[s2] ? arr1[s1] : arr2[s2];
  }

  var newK = k >> 1;

  if (n1 < newK) {
    newK = n1;
  }

  if (arr1[s1 + newK - 1] < arr2[s2 + newK - 1]) {
    return kth(arr1, s1 + newK, n1 - newK, arr2, s2, n2, k - newK);
  } else {
    return kth(arr1, s1, n1, arr2, s2 + newK, n2 - newK, k - newK);
  }
}

// var arr1 = [2, 3, 6, 7, 9];
// var arr2 = [1, 4, 8, 10];
// console.log([...arr1, ...arr2].sort(function (a, b) {
//     if (a > b) return 1;
//     if (a < b) return -1;
//     return 0;
// }));
//
// console.log('=======');
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 1), 1);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 2), 2);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 3), 3);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 4), 4);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 5), 6);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 6), 7);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 7), 8);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 8), 9);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 9), 10);

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  var n1 = nums1.length;
  var n2 = nums2.length;

  var mid = Math.floor((n1 + n2) / 2);
  if ((n1 + n2) % 2 === 0) {
    return (kth(nums1, 0, n1, nums2, 0, n2, mid) + kth(nums1, 0, n1, nums2, 0, n2, mid + 1)) / 2;
  } else {
    return kth(nums1, 0, n1, nums2, 0, n2, mid + 1);
  }
};

console.log(findMedianSortedArrays([1, 3, 4], [2, 5]));
console.log(findMedianSortedArrays([1, 3, 4], [2, 5, 6]));
```

# 005-Longest-Palindromic-Substring

```js
/**
 * https://leetcode.com/problems/longest-palindromic-substring/description/
 * Difficulty:Medium
 *
 * Given a string s, find the longest palindromic substring in s.
 * You may assume that the maximum length of s is 1000.
 *
 * Example:
 * Input: "babad"
 * Output: "bab"
 * Note: "aba" is also a valid answer.
 *
 * Example:
 * Input: "cbbd"
 * Output: "bb"
 */
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  var a = new Date();
  var n = s.length;
  var res = '';
  var dp = [];
  while (dp.push(new Array(n).fill(-1)) < n);
  // console.log(dp);

  for (var i = n - 1; i >= 0; i--) {
    for (var j = i; j < n; j++) {
      dp[i][j] = s[i] === s[j] && (j - i < 3 || dp[i + 1][j - 1]);
      if (dp[i][j] === undefined) {
        console.log(i, j, s[i], s[j], dp[i + 1][j - 1]);
      }
      if (dp[i][j]) {
        var tmp = s.substring(i, j + 1);
        if (tmp.length > res.length) res = tmp;
      }
    }
  }
  // console.log(dp);
  console.log(new Date() - a);

  return res;
};

// console.log(isPalindrome(s, 1, 3));
// console.log(longestPalindrome('babad'));
// console.log(longestPalindrome(''));
// console.log(longestPalindrome('a'));
// console.log(longestPalindrome('aabbbbbb'));
console.log(
  longestPalindrome(
    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
  ),
);
```

# 006-ZigZag-Conversion

```js
/**
 *
 * https://leetcode.com/problems/zigzag-conversion/description/
 * Difficulty:Medium
 *
 * The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this:
 * (you may want to display this pattern in a fixed font for better legibility)
 *
 * P   A   H   N
 * A P L S I I G
 * Y   I   R
 * And then read line by line: "PAHNAPLSIIGYIR"
 * Write the code that will take a string and make this conversion given a number of rows:
 * string convert(string text, int nRows);
 * convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".
 *
 */

/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  var arr = [];
  for (var i = 0; i < numRows; i++) {
    arr[i] = [];
  }

  var cnt = 0;
  var len = s.length;

  while (cnt < len) {
    for (var i = 0; i < arr.length && cnt < len; i++) {
      arr[i].push(s[cnt++]);
    }
    for (var i = numRows - 2; i >= 1 && cnt < len; i--) {
      arr[i].push(s[cnt++]);
    }
  }
  // console.log(arr);

  return arr.map(arr => arr.join('')).join('');
};

console.log(convert('PAYPALISHIRING', 3));
```

# 009-Palindrome-Number

```js
/**
 * https://leetcode.com/problems/palindrome-number/description/
 * Difficulty:Easy
 *
 * Determine whether an integer is a palindrome. Do this without extra space.
 */

/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
  if (x < 0) return false;
  var t = x;
  x = Math.abs(x);
  var p = 0;
  while (x) {
    p = p * 10 + (x % 10);
    x = Math.floor(x / 10);
  }
  // console.log(x, p);
  return t === p;
};

console.log(isPalindrome(-1) === false);
console.log(isPalindrome(0) === true);
console.log(isPalindrome(123) === false);
console.log(isPalindrome(12321) === true);
console.log(isPalindrome(1221) === true);
console.log(isPalindrome(2222) === true);
```

# 010-Regular-Expression-Matching

# 011-Container-With-Most-Water

```js
/**
 * https://leetcode.com/problems/container-with-most-water/description/
 * Difficulty:Medium
 *
 * Given n non-negative integers a1, a2, ..., an, where each represents a point
 * at coordinate (i, ai).
 * n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).
 * Find two lines, which together with x-axis forms a container,
 * such that the container contains the most water.
 * Note: You may not slant the container and n is at least 2.
 */

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var dp = [0];
  var max = 0;
  for (var i = 1; i < height.length; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      var v = (i - j) * Math.min(height[i], height[j]);
      dp[i] = Math.max(dp[i], v);
    }
    max = Math.max(max, dp[i]);
  }
  // console.log(dp, max);
  return max;
};

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var i = 0;
  var j = height.length - 1;
  var max = 0;
  while (i < j) {
    max = Math.max(max, Math.min(height[i], height[j]) * (j - i));
    if (height[i] < height[j]) i++;
    else j--;
  }
  return max;
};

console.log(maxArea([3, 5, 1, 9]));
```

# 013-Roman-to-Integer

```js
/**
 * https://leetcode.com/problems/roman-to-integer/description/
 * Difficulty:Easy
 *
 * Given a roman numeral, convert it to an integer.
 * Input is guaranteed to be within the range from 1 to 3999.
 */

/**
 * @see https://baike.baidu.com/item/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97
 *
 * 基本字符
 * I V  X  L  C   D   M
 * 1 5 10 50 100 500 1000
 * 相应的阿拉伯数字表示
 *
 * 计数方法
 * 相同的数字连写、所表示的数等于这些数字相加得到的数、如：Ⅲ=3；
 * 小的数字在大的数字的右边、所表示的数等于这些数字相加得到的数、 如：Ⅷ=8、Ⅻ=12；
 * 小的数字(限于 I、X 和 C)在大的数字的左边、所表示的数等于大数减小数得到的数、如：Ⅳ=4、Ⅸ=9；
 * 正常使用时、连写的数字重复不得超过三次；
 *
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
  if (!s) return 0;

  var map = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
  };

  var sum = map[s[s.length - 1]];
  for (var i = s.length - 2; i >= 0; i--) {
    if (map[s[i]] < map[s[i + 1]]) sum -= map[s[i]];
    else sum += map[s[i]];
  }
  return sum;
};

console.log(romanToInt('III'), 3);
console.log(romanToInt('VI'), 6);
console.log(romanToInt('IV'), 4);
```

# 014-Longest-Common-Prefix

# 015-3Sum

```js
/**
 * https://leetcode.com/problems/3sum/
 * Difficulty:Medium
 *
 * Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0?
 * Find all unique triplets in the array which gives the sum of zero.
 * Note: The solution set must not contain duplicate triplets.
 *
 * For example, given array S = [-1, 0, 1, 2, -1, -4],
 * A solution set is:
 * [
 * [-1, 0, 1],
 * [-1, -1, 2]
 * ]

 */
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    if (a > b) return 1;
    if (a === b) return 0;
    if (a < b) return -1;
  });
  // console.log(nums);
  var ret = [];
  for (var i = 0; i < nums.length - 2; i++) {
    var a = nums[i];
    if (i === 0 || (i > 0 && nums[i] !== nums[i - 1])) {
      var j = i + 1;
      var k = nums.length - 1;
      while (j < k) {
        var b = nums[j];
        var c = nums[k];

        var sum = a + b + c;

        // console.log(a, b, c, '=', sum);
        if (sum > 0) k--;
        else if (sum === 0) {
          ret.push([a, b, c]);
          while (j < k && nums[j] === nums[++j]);
          while (j < k && nums[k] === nums[--k]);
          // j++;
          // k--;
        } else j++;
      }
    }
  }
  return ret;
};

console.log(threeSum([-2, 0, 0, 2, 2]));
console.log(threeSum([-1, 0, 1, 2, -1, -4]));
// console.log(threeSum([0, 0, 0, 0]));
// console.log(threeSum([1, -1, -1, 0]));
```

# 016-3Sum-Closest

```js
/**
 * https://leetcode.com/problems/3sum-closest/description/
 * Difficulty:Medium
 *
 * Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target.
 * Return the sum of the three integers. You may assume that each input would have exactly one solution.
 * For example, given array S = {-1 2 1 -4}, and target = 1.
 * The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
 *
 */

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  var ans = nums[0] + nums[1] + nums[2];
  var len = nums.length;

  nums.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));

  for (var i = 0; i < len - 2; i++) {
    var j = i + 1;
    var k = len - 1;

    while (j < k) {
      var sum = nums[i] + nums[j] + nums[k];
      if (sum === target) return sum;
      if (sum > target) k--;
      if (sum < target) j++;
      if (Math.abs(target - sum) < Math.abs(target - ans)) {
        ans = sum;
      }
    }
  }
  return ans;
};

console.log(threeSumClosest([-1, 2, 1, -4], 1));
```

# 018-4Sum

```js
/**
 * https://leetcode.com/problems/4sum/description/
 * Difficulty:Medium
 *
 * Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
 * Note: The solution set must not contain duplicate quadruplets.
 * For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.
 * A solution set is:
 * [
 * [-1,  0, 0, 1],
 * [-2, -1, 1, 2],
 * [-2,  0, 0, 2]
 ]
 */

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
  var len = nums.length;
  if (len < 4) return [];
  nums.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  // console.log(nums);
  var ans = [];
  for (var i = 0; i < len - 3; i++) {
    for (var j = i + 1; j < len - 2; j++) {
      var k = j + 1;
      var l = len - 1;

      while (k < l) {
        var sum = nums[i] + nums[j] + nums[k] + nums[l];
        if (sum === target) {
          ans.push([nums[i], nums[j], nums[k], nums[l]]);
          while (nums[l--] === nums[l] && nums[k++] === nums[k] && k < l);
        } else if (sum < target) while (nums[k++] === nums[k] && k < l);
        else while (nums[l--] === nums[l] && k < l);
      }
      while (nums[j] === nums[j + 1]) j++;
    }
    while (nums[i] === nums[i + 1]) i++;
  }
  return ans;
};

console.log(fourSum([-5, -4, -2, -2, -2, -1, 0, 0, 1], -9));
```

# 019-Remove-Nth-Node-From-End-of-List

```js
/**
 * https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/
 * Difficulty:Medium
 *
 * Given a linked list, remove the nth node from the end of list and return its head.
 *
 * For example,
 *  Given linked list: 1->2->3->4->5, and n = 2.
 *  After removing the second node from the end, the linked list becomes 1->2->3->5.
 *
 * Note:
 *  Given n will always be valid.
 *  Try to do this in one pass.
 *
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  if (!head) return head;
  var len = 0;
  var tail = head;
  while (tail) {
    tail = tail.next;
    len++;
  }
  if (len === n) {
    return head.next;
  }

  len = len - n - 1;
  tail = head;
  while (len) {
    tail = tail.next;
    len--;
  }
  tail.next = tail.next.next;
  return head;
};

var a = new ListNode(1);
var b = new ListNode(2);
var c = new ListNode(3);
var d = new ListNode(4);
// var e = new ListNode(5);
a.next = b;
b.next = c;
c.next = d;
// d.next = e;

console.log(removeNthFromEnd(a, 2));
```

# 020-Valid-Parentheses

```js
/**
 * https://leetcode.com/problems/valid-parentheses/
 * Difficulty:Easy
 *
 * Given a string containing just the characters '(', ')', '{', '}', '[' and ']',
 * determine if the input string is valid.
 * The brackets must close in the correct order,
 * "()" and "()[]{}" are all valid but "(]" and "([)]" are not.
 */

/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  var stack = [];
  for (var i = 0; i < s.length; i++) {
    var c = s[i];
    switch (c) {
      case '(':
        stack.push(')');
        break;
      case '[':
        stack.push(']');
        break;
      case '{':
        stack.push('}');
        break;
      default:
        if (!stack.length || stack.pop() !== c) {
          // console.log(stack);
          return false;
        }
    }
  }

  return stack.length === 0;
};

console.log(isValid('()[]{}'));
console.log(isValid('[()][]{}'));
console.log(isValid('(])'));
```

# 021-Merge-Two-Sorted-Lists

```js
/**
 * https://leetcode.com/problems/merge-two-sorted-lists/description/
 * Difficulty:Easy
 *
 * Merge two sorted linked lists and return it as a new list.
 * The new list should be made by splicing together the nodes of the first two lists.
 *
 * Example:
 * Input: 1->2->4, 1->3->4
 * Output: 1->1->2->3->4->4
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 *
 * non-recursion
 *
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;

  var n = new ListNode(0);
  var t = n;

  while (l1 && l2) {
    if (l1.val <= l2.val) {
      n.next = l1;
      l1 = l1.next;
    } else {
      n.next = l2;
      l2 = l2.next;
    }
    n = n.next;
  }
  if (l1) n.next = l1;
  if (l2) n.next = l2;

  return t.next;
};

/**
 *
 * recursion
 *
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;

  if (l1.val <= l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

# 022-Generate-Parentheses

```js
/**
 * https://leetcode.com/problems/generate-parentheses/description/
 * Difficulty:Medium
 *
 * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
 * For example, given n = 3, a solution set is:
 * [
 *   "((()))",
 *   "(()())",
 *   "(())()",
 *   "()(())",
 *   "()()()"
 * ]
 */

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  var ans = [];
  helper(ans, '', 0, 0, n);
  return ans;
};

function helper(ans, str, left, right, n) {
  if (right === n) ans.push(str);
  if (left < n) {
    helper(ans, str + '(', left + 1, right, n);
  }
  if (right < left) {
    helper(ans, str + ')', left, right + 1, n);
  }
}

console.log(generateParenthesis(3));
```

# 023-Merge-k-Sorted-Lists

```js
/**
 * https://leetcode.com/problems/merge-k-sorted-lists/description/
 * Difficulty:Hard
 *
 * Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
 */

//Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  return lists.reduce((a, b) => merge2lists(a, b), null);
};

function merge2lists(a, b) {
  if (!a && !b) return null;
  if (!a) return b;
  if (!b) return a;
  var h;
  if (a.val < b.val) {
    h = a;
    a = a.next;
  } else {
    h = b;
    b = b.next;
  }
  var t = h;

  while (a && b) {
    if (a.val < b.val) {
      t.next = a;
      t = t.next;
      a = a.next;
    } else {
      t.next = b;
      t = t.next;
      b = b.next;
    }
  }
  if (a) t.next = a;
  if (b) t.next = b;
  return h;
}

var a = {
  val: 1,
  next: {
    val: 4,
    next: {
      val: 7,
      next: null,
    },
  },
};
var b = {
  val: 2,
  next: {
    val: 8,
    next: {
      val: 9,
      next: null,
    },
  },
};

var c = {
  val: 3,
  next: {
    val: 10,
    next: null,
  },
};

// console.log(merge2lists(a, b));
console.log(mergeKLists([a, b, c]));
```

# 024-Swap-Nodes-in-Pairs

```js
/**
 * https://leetcode.com/problems/swap-nodes-in-pairs/description/
 * Difficulty:Medium
 *
 * Given a linked list, swap every two adjacent nodes and return its head.
 *
 * For example,
 * Given 1->2->3->4, you should return the list as 2->1->4->3.
 * Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
 *
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
  var t = new ListNode(0);
  t.next = head;

  var a = t;

  while (true) {
    if (!a) break;
    var b = a.next;
    if (!b) break;
    var c = b.next;
    if (!c) break;

    b.next = c.next;
    c.next = b;
    a.next = c;
    a = b;
  }
  return t.next;
};

console.log(
  swapPairs({
    val: 1,
    next: {
      val: 2,
      next: {
        val: 3,
        next: {
          val: 4,
        },
      },
    },
  }),
);
```

# 025-Reverse-Nodes-in-k-Group

```js
/**
 * https://leetcode.com/problems/reverse-nodes-in-k-group/description/
 * Difficulty:Hard
 *
 * Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
 * k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
 * You may not alter the values in the nodes, only nodes itself may be changed.
 * Only constant memory is allowed.
 * For example,
 * Given this linked list: 1->2->3->4->5
 * For k = 2, you should return: 2->1->4->3->5
 * For k = 3, you should return: 3->2->1->4->5
 *
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
  // if (k === 1)
  //     return head;
  var t = new ListNode(0);
  t.next = head;
  var s = t;

  while (true) {
    var cnt = 0;
    var f = t;
    while (cnt++ < k && f) {
      f = f.next;
    }
    // console.log(p(t), p(f));

    if (!f || cnt !== k + 1) break;
    cnt = 0;
    var a = t.next;

    while (++cnt < k) {
      var b = a.next;
      a.next = b.next;
      b.next = t.next;
      t.next = b;
      // console.log(p(t), p(a), p(b));
    }
    t = a;
  }

  return s.next;
};

function p(n) {
  var t = n;
  var s = '';
  while (t) {
    s = s + t.val + '->';
    t = t.next;
  }
  s += 'null';
  return s;
}
//
console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: {
              val: 4,
            },
          },
        },
      },
      2,
    ),
  ),
);

console.log(p(reverseKGroup({ val: 1 }, 2)));

console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
        },
      },
      2,
    ),
  ),
);

console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: {
              val: 4,
              next: {
                val: 5,
                next: {
                  val: 6,
                  next: {
                    val: 7,
                  },
                },
              },
            },
          },
        },
      },
      3,
    ),
  ),
);
//

console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: {
              val: 4,
              next: null,
            },
          },
        },
      },
      2,
    ),
  ),
);
```

# 026-Remove-Duplicates-from-Sorted-Array

```js
/**
 * https://leetcode.com/problems/remove-duplicates-from-sorted-array/
 * Difficulty:Easy
 *
 * Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
 * Do not allocate extra space for another array, you must do this in place with constant memory.
 *
 * For example,
 * Given input array nums = [1,1,2],
 * Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
 * It doesn't matter what you leave beyond the new length.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  var n = nums.length;
  if (!n) return 0;
  var last = nums[0];
  var cnt = 1;

  for (var i = 1; i < nums.length; i++) {
    if (nums[i] !== last) {
      last = nums[i];
      cnt++;
    } else {
      nums.splice(i, 1);
      i--;
    }
  }
  return cnt;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  for (var i = 0; i < nums.length - 1; i++) if (nums[i] === nums[i + 1]) nums.splice(i--, 1);
  return nums.length;
};

var arr = [1, 2, 2];
console.log(removeDuplicates(arr));
console.log(arr);
```

# 027-Remove-Element

```js
/**
 * https://leetcode.com/problems/remove-element/description/
 * Difficulty:Easy
 *
 * Given an array and a value, remove all instances of that value in-place and return the new length.
 * Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
 * The order of elements can be changed. It doesn't matter what you leave beyond the new length.
 * Example:
 * Given nums = [3,2,2,3], val = 3,
 * Your function should return length = 2, with the first two elements of nums being 2.
 */

/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
  var len = nums.length;
  for (var i = 0; i < len; i++) {
    if (nums[i] === val) {
      nums.splice(i, 1);
      i--;
      len--;
    }
  }
  return len;
};

console.log(removeElement([3, 2, 2, 3], 3));
```

# 030-Substring-with-Concatenation-of-All-Words

```js
/**
 *
 * https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/
 * Difficulty:Hard
 *
 * You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s)
 * in s that is a concatenation of each word in words exactly once and without any intervening characters.
 * For example, given:
 * s: "barfoothefoobarman"
 * words: ["foo", "bar"]
 * You should return the indices: [0,9].
 * (order does not matter).
 *
 */
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  if (!s.length || !words.length) return [];
  var ans = [];
  var toFind = {};

  var m = words.length;
  var n = words[0].length;

  for (var i = 0; i < m; i++) {
    toFind[words[i]] = (toFind[words[i]] || 0) + 1;
  }

  for (i = 0; i <= s.length - m * n; i++) {
    var found = {};

    for (var j = 0; j < m; j++) {
      var k = i + n * j;
      var w = s.substr(k, n);
      if (!toFind[w]) break;
      found[w] = (found[w] || 0) + 1;
      if (found[w] > toFind[w]) break;
    }
    if (j === m) ans.push(i);
  }

  return ans;
};

console.log(findSubstring('barfoothefoobarman', ['foo', 'bar']));
```

# 031-Next-Permutation

```js
/**
 * https://leetcode.com/problems/next-permutation/description/
 * Difficulty:Medium
 *
 * Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
 * If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
 * The replacement must be in-place, do not allocate extra memory.
 * Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
 * 1,2,3 → 1,3,2
 * 3,2,1 → 1,2,3
 * 1,1,5 → 1,5,1
 */
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  if (nums.length < 2) return;
  var peak = nums.length - 1;
  for (var i = peak - 1; nums[i] >= nums[peak]; peak = i--);

  if (peak !== 0) {
    var swapIndex = findSwap(nums, peak, nums.length - 1, peak - 1);
    if (swapIndex !== -1) {
      swap(nums, peak - 1, swapIndex);
    }
  }

  reverse(nums, peak, nums.length - 1);
};

function findSwap(nums, s, e, target) {
  for (var i = e; i >= s; i--) {
    if (nums[i] > nums[target]) return i;
  }
  return -1;
}

function swap(nums, s, e) {
  var t = nums[s];
  nums[s] = nums[e];
  nums[e] = t;
}
function reverse(nums, s, e) {
  // var len = e - s;
  for (var i = 0; i < Math.ceil((e - s) / 2); i++) {
    swap(nums, s + i, e - i);
  }
  // return nums;
}

// console.log(reverse([1, 2, 3, 4, 5], 0, 4));
// console.log(reverse([1, 2, 3, 4, 5], 3, 4));
// console.log(reverse([1, 2, 3, 4, 5], 2, 3));
// console.log(reverse([1, 2, 3, 4, 5], 1, 1));
// console.log(reverse([1, 2, 3, 4, 5], 1, 4));

// var nums = [1, 2, 5, 4, 3];
// console.log(nums);
// nextPermutation(nums);
// console.log(nums);
//
console.log('====');

var nums = [2, 3, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [1, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [3, 2, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);
```

# 032-Longest-Valid-Parentheses

```js
/**
 * https://leetcode.com/problems/longest-valid-parentheses/description/
 * Difficulty:Hard
 *
 * Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.
 * For "(()", the longest valid parentheses substring is "()", which has length = 2.
 * Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.
 */

/**
 * 使用栈解决
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  var stack = [];
  for (var i = 0; i < s.length; i++) {
    if (s[i] === '(') stack.push(i);
    else {
      if (stack.length && s[stack[stack.length - 1]] === '(') stack.length--;
      else stack.push(i);
    }
  }

  if (!stack.length) return s.length;
  var longest = 0;
  var end = s.length;
  var start = 0;
  while (stack.length) {
    start = stack[stack.length - 1];
    stack.length--;
    longest = Math.max(longest, end - start - 1);
    end = start;
  }
  longest = Math.max(longest, end);
  return longest;
};

console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('())'), 2);
console.log(longestValidParentheses('(()'), 2);
console.log(longestValidParentheses('))()())((())))'), 6);
console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('('), 0);
console.log(longestValidParentheses(')()()))()()())'), 6);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('(()'), 2);
```

# 033-Search-in-Rotated-Sorted-Array

```js
/**
 * https://leetcode.com/problems/search-in-rotated-sorted-array/description/
 * Difficulty:Medium
 *
 * Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
 * (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
 * You are given a target value to search. If found in the array return its index, otherwise return -1.
 * You may assume no duplicate exists in the array.
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  var lo = 0;
  var hi = nums.length - 1;
  while (lo < hi) {
    var mid = Math.floor((lo + hi) / 2);
    if (nums[mid] < nums[hi]) hi = mid;
    else lo = mid + 1;
  }
  var i = lo;

  lo = target < nums[0] ? i : 0;
  hi = target <= nums[nums.length - 1] ? nums.length - 1 : i;

  // console.log(nums, lo, hi);
  while (lo <= hi) {
    mid = Math.floor((lo + hi) / 2);
    // console.log(lo, mid, hi)
    if (nums[mid] < target) lo = mid + 1;
    else if (nums[mid] === target) return mid;
    else hi = mid - 1;
  }

  return -1;
};

console.log(search([], 5));
console.log(search([1], 0));
console.log(search([4, 5, 6, 7, 0, 1, 2], 2));
console.log(search([3, 1], 1));
```

# 034-Search-for-a-Range

```js
/**
 *
 * https://leetcode.com/problems/search-for-a-range/description/
 * Difficulty:Medium
 *
 * Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
 * Your algorithm's runtime complexity must be in the order of O(log n).
 * If the target is not found in the array, return [-1, -1].
 * For example,
 * Given [5, 7, 7, 8, 8, 10] and target value 8,
 * return [3, 4].
 *
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  var i = 0;
  var j = nums.length - 1;
  var ret = [-1, -1];
  while (i < j) {
    var mid = Math.floor((i + j) / 2);
    // console.log(i, mid, j);
    if (nums[mid] < target) i = mid + 1;
    else j = mid;
  }
  if (nums[i] !== target) return ret;
  ret[0] = i;
  j = nums.length - 1;
  while (i < j) {
    mid = Math.ceil((i + j) / 2);
    // console.log(i, mid, j);
    if (nums[mid] > target) j = mid - 1;
    else i = mid;
  }
  ret[1] = j;
  return ret;
};

console.log(searchRange([5, 7, 7, 8, 8, 10], 8));
```

# 035-Search-Insert-Position

```js
/**
 * https://leetcode.com/problems/search-insert-position/description/
 * Difficulty:Easy
 *
 * Given a sorted array and a target value, return the index if the target is found.
 * If not, return the index where it would be if it were inserted in order.
 *
 * You may assume no duplicates in the array.
 *
 * Here are few examples.
 * [1,3,5,6], 5 → 2
 * [1,3,5,6], 2 → 1
 * [1,3,5,6], 7 → 4
 * [1,3,5,6], 0 → 0
 */

/**
 * 解题思路
 *
 * 找到不比目标元素大的索引即可
 *
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  for (var i = 0; i < nums.length; i++) {
    if (target <= nums[i]) return i;
  }
  return i;
};

console.log(searchInsert([1, 3, 5, 6], 5) == 2);
console.log(searchInsert([1, 3, 5, 6], 2) == 1);
console.log(searchInsert([1, 3, 5, 6], 7) == 4);
console.log(searchInsert([1, 3, 5, 6], 0) == 0);
console.log(searchInsert([1, 3, 5, 6], 100) == 4);
```

# 036-Valid-Sudoku

```js
/**
 * https://leetcode.com/problems/valid-sudoku/description/
 * Difficulty:Medium
 *
 * Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.
 * The Sudoku board could be partially filled, where empty cells are filled with the character '.'.
 * A partially filled sudoku which is valid.
 * Note:
 * A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
 *
 */
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  for (var i = 0; i < 9; i++) {
    var rowNums = [];
    var colNums = [];
    var cubeNums = [];

    for (var j = 0; j < 9; j++) {
      var ch = board[i][j];
      if (ch !== '.') {
        if (rowNums.indexOf(ch) > -1) return false;
        rowNums.push(ch);
      }

      ch = board[j][i];
      if (ch !== '.') {
        if (colNums.indexOf(ch) > -1) return false;
        colNums.push(ch);
      }

      var row = Math.floor(i / 3) * 3 + Math.floor(j / 3);
      var col = (i % 3) * 3 + (j % 3);
      // console.log(i, j, row, col);
      ch = board[row][col];
      if (ch !== '.') {
        if (cubeNums.indexOf(ch) > -1) return false;
        cubeNums.push(ch);
      }
    }
  }
  return true;
};

// console.log(isValidSudoku([
//     [".", "8", "7", "6", "5", "4", "3", "2", "1"],
//     ["2", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["3", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["4", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["5", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["6", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["7", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["8", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["9", ".", ".", ".", ".", ".", ".", ".", "."]]));
console.log(
  isValidSudoku([
    ['.', '.', '4', '.', '.', '.', '6', '3', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['5', '.', '.', '.', '.', '.', '.', '9', '.'],
    ['.', '.', '.', '5', '6', '.', '.', '.', '.'],
    ['4', '.', '3', '.', '.', '.', '.', '.', '1'],
    ['.', '.', '.', '7', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '5', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
  ]),
);
```

# 037-Sudoku-Solver

```js
/**
 * https://leetcode.com/problems/sudoku-solver/description/
 * Difficulty:Hard
 *
 * Write a program to solve a Sudoku puzzle by filling the empty cells.
 * Empty cells are indicated by the character '.'.
 * You may assume that there will be only one unique solution.
 */

/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
  solve(board);
  console.log(board);
};

function solve(board) {
  for (var i = 0; i < 9; i++) {
    for (var j = 0; j < 9; j++) {
      var ch = board[i][j];
      if (ch === '.') {
        for (var k = 1; k <= 9; k++) {
          if (isValid(i, j, board, '' + k)) {
            board[i][j] = '' + k;
            // console.log(board);
            // console.log('-------------');
            if (solve(board)) {
              // console.log(board);
              // console.log('-------------');
              return true;
            } else {
              board[i][j] = '.';
            }
          }
        }
        return false;
      }
    }
  }
  return true;
}

function isValid(row, col, board, t) {
  for (var i = 0; i < 9; i++) {
    var ch = board[row][i];
    if (ch === t) return false;

    ch = board[i][col];
    if (ch === t) return false;

    ch = board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + (i % 3)];
    // if (row === 0 && col === 8) {
    //     console.log('~ ', Math.floor(row / 3) * 3 + Math.floor(i / 3), Math.floor(row / 3) * 3 + i % 3, ch);
    // }
    if (ch === t) return false;
  }
  return true;
}

console.log(
  solveSudoku([
    ['.', '.', '9', '7', '4', '8', '.', '.', '.'],
    ['7', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '2', '.', '1', '.', '9', '.', '.', '.'],
    ['.', '.', '7', '.', '.', '.', '2', '4', '.'],
    ['.', '6', '4', '.', '1', '.', '5', '9', '.'],
    ['.', '9', '8', '.', '.', '.', '3', '.', '.'],
    ['.', '.', '.', '8', '.', '3', '.', '2', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '6'],
    ['.', '.', '.', '2', '7', '5', '9', '.', '.'],
  ]),
);

console.log([
  ['5', '1', '9', '7', '4', '8', '6', '3', '2'],
  ['7', '8', '3', '6', '5', '2', '4', '1', '9'],
  ['4', '2', '6', '1', '3', '9', '8', '7', '5'],
  ['3', '5', '7', '9', '8', '6', '2', '4', '1'],
  ['2', '6', '4', '3', '1', '7', '5', '9', '8'],
  ['1', '9', '8', '5', '2', '4', '3', '6', '7'],
  ['9', '7', '5', '8', '6', '3', '1', '2', '4'],
  ['8', '3', '2', '4', '9', '1', '7', '5', '6'],
  ['6', '4', '1', '2', '7', '5', '9', '8', '3'],
]);
```

# 038-Count-and-Say

```js
/**
 * https://leetcode.com/problems/count-and-say/description/
 * Difficulty:Easy
 *
 * The count-and-say sequence is the sequence of integers with the first five terms as following:
 * 1.     1
 * 2.     11
 * 3.     21
 * 4.     1211
 * 5.     111221
 *
 * 1 is read off as "one 1" or 11.
 *
 * 11 is read off as "two 1s" or 21.
 *
 * 21 is read off as "one 2, then one 1" or 1211.
 *
 * Given an integer n, generate the nth term of the count-and-say sequence.
 *
 * Note: Each term of the sequence of integers will be represented as a string.
 *
 * Example 1:
 * Input: 1
 * Output: "1"
 *
 * Example 2:
 * Input: 4
 * Output: "1211"
 */

/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
  var ans = '1';
  for (var i = 1; i < n; i++) {
    var tmp = '';
    var cnt = 1;
    for (var j = 1; j < ans.length; j++) {
      if (ans[j] === ans[j - 1]) cnt++;
      else {
        tmp += cnt + ans[j - 1];
        cnt = 1;
      }
    }
    ans = tmp + cnt + ans[j - 1];
  }

  return ans;
};

console.log(countAndSay(1));
console.log(countAndSay(2));
console.log(countAndSay(3));
console.log(countAndSay(4));
console.log(countAndSay(5));
console.log(countAndSay(6));
```

# 039-Combination-Sum

```js
/**
 * https://leetcode.com/problems/combination-sum/description/
 * Difficulty:Medium
 *
 * Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
 * The same repeated number may be chosen from C unlimited number of times.
 * Note:
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 * For example, given candidate set [2, 3, 6, 7] and target 7,
 * A solution set is:
 * [
 *  [7],
 *  [2, 2, 3]
 * ]
 */

/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  var res = [];
  var temp = [];
  helper(res, temp, candidates, target, 0);
  return res;
};

function helper(res, temp, candidates, target, start) {
  if (target === 0) {
    res.push([...temp]);
    return;
  }

  for (var i = start; i < candidates.length; i++) {
    if (candidates[i] <= target) {
      temp.push(candidates[i]);
      helper(res, temp, candidates, target - candidates[i], i);
      temp.length -= 1;
    }
  }
}

console.log(combinationSum([1, 2, 3, 5, 6, 7], 7));
console.log(combinationSum([7, 2, 3, 5, 6, 1], 7));
```

# 040-Combination-Sum-II

```js
/**
 * Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
 * Each number in C may only be used once in the combination.
 * Note:
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 * For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
 * A solution set is:
 * [
 *  [1, 7],
 *  [1, 2, 5],
 *  [2, 6],
 *  [1, 1, 6]
 * ]
 */

/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
  var res = [];
  var temp = [];
  candidates.sort((b, a) => b - a);
  helper(res, temp, candidates, target, 0);
  return res;
};

function helper(res, temp, candidates, target, start) {
  if (target === 0) {
    return res.push([...temp]);
  }

  for (var i = start; i < candidates.length && candidates[i] <= target; i++) {
    if (i === start || candidates[i] !== candidates[i - 1]) {
      temp.push(candidates[i]);
      helper(res, temp, candidates, target - candidates[i], i + 1);
      temp.length -= 1;
    }
  }
}

console.log(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8));
```

# 043-Multiply-Strings

```js
/**
 * https://leetcode.com/problems/multiply-strings/description/
 * Difficulty:Medium
 *
 * Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.
 * Note:
 * The length of both num1 and num2 is < 110.
 * Both num1 and num2 contains only digits 0-9.
 * Both num1 and num2 does not contain any leading zero.
 * You must not use any built-in BigInteger library or convert the inputs to integer directly.
 */

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
  var m = num1.length;
  var n = num2.length;
  var arr = new Array(m + n).fill(0);
  for (var i = m - 1; i >= 0; i--) {
    for (var j = n - 1; j >= 0; j--) {
      var mul = (num1[i] - '0') * (num2[j] - '0');

      var sum = mul + arr[i + j + 1];

      arr[i + j] += Math.floor(sum / 10);
      arr[i + j + 1] = sum % 10;
    }
  }

  var str = arr.reduce((a, b) => {
    if (a === '' && b === 0) return a;
    return a + b;
  }, '');

  return str ? str : '0';
};

console.log(multiply('89', '45'));
console.log(multiply('123', '123'));
console.log(multiply('123', '0'));
```

# 046-Permutations

```js
/**
 * https://leetcode.com/problems/permutations/description/
 * Difficulty:Medium
 *
 * Given a collection of distinct numbers, return all possible permutations.
 * For example,
 * [1,2,3] have the following permutations:
 * [
 *  [1,2,3],
 *  [1,3,2],
 *  [2,1,3],
 *  [2,3,1],
 *  [3,1,2],
 *  [3,2,1]
 * ]
 */

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  if (!nums.length) return [];
  var res = [[]];
  for (var i = 0; i < nums.length; i++) {
    var len = res.length;
    for (var j = 0; j < len; j++) {
      var oldArr = res.shift();
      for (var k = 0; k <= oldArr.length; k++) {
        var newArr = oldArr.slice();
        newArr.splice(k, 0, nums[i]);
        res.push(newArr);
      }
    }
  }
  return res;
};
console.log(permute([1, 2, 3]));
```

# 047-Permutations-II

```js
/**
 * https://leetcode.com/problems/permutations-ii/description/
 * Difficulty:Medium
 *
 * Given a collection of numbers that might contain duplicates, return all possible unique permutations.
 * For example,
 * [1,1,2] have the following unique permutations:
 *  [
 *  [1,1,2],
 *  [1,2,1],
 *  [2,1,1]
 * ]
 */

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
  if (!nums.length) return [];
  nums.sort((a, b) => a - b);
  var res = [[]];
  for (var i = 0; i < nums.length; i++) {
    var len = res.length;
    for (var j = 0; j < len; j++) {
      var oldArr = res.shift();
      if (i > 0 && nums[i] === nums[i - 1]) {
        var k = oldArr.lastIndexOf(nums[i]);
      } else {
        k = 0;
      }
      for (; k <= oldArr.length; k++) {
        if (k === oldArr.length || nums[i] !== oldArr[k]) {
          var newArr = oldArr.slice();
          newArr.splice(k, 0, nums[i]);
          // console.log(oldArr, newArr);
          res.push(newArr);
        }
      }
    }
  }
  return res;
};

console.log(permuteUnique([1, 2, 2, 1]));
```

# 051-N-Queens

```js
/**
 * https://leetcode.com/problems/n-queens/description/
 * Difficulty:Hard
 *
 * The n-queens puzzle is the problem of placing n queens on an n×n chessboard
 * such that no two queens attack each other.
 *
 * Given an integer n, return all distinct solutions to the n-queens puzzle.
 * Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.
 *
 * For example,
 * There exist two distinct solutions to the 4-queens puzzle:
 * [
 *  [".Q..",  // Solution 1
 *   "...Q",
 *   "Q...",
 *   "..Q."],
 *
 *  ["..Q.",  // Solution 2
 *   "Q...",
 *   "...Q",
 *   ".Q.."]
 * ]
 * 2,1 3,2
 */

/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
  var ret = [];
  var board = [];
  for (var i = 0; i < n; i++) {
    board.push(new Array(n).fill('.'));
  }
  helper(board, 0, ret);
  return ret;
};

function helper(board, col, ret) {
  if (col === board.length) {
    ret.push(construct(board));
  } else {
    for (var i = 0; i < board.length; i++) {
      if (check(board, i, col)) {
        board[i][col] = 'Q';
        helper(board, col + 1, ret);
        board[i][col] = '.';
      }
    }
  }
}

function check(board, x, y) {
  for (var i = 0; i < board.length; i++) {
    for (var j = 0; j < y; j++) {
      if (board[i][j] === 'Q' && (i === x || i + j === x + y || i + y === j + x)) return false;
    }
  }
  return true;
}
function construct(board) {
  return board.map(arr => arr.join(''));
}
console.log(solveNQueens(4));
```

# 053-Maximum-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-subarray/description/
 * Difficulty:Easy
 *
 * Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
 *
 * For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
 * the contiguous subarray [4,-1,2,1] has the largest sum = 6.
 */

/**
 *
 * https://discuss.leetcode.com/topic/6413/dp-solution-some-thoughts
 *
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  var dp = [];
  var max = (dp[0] = nums[0]);

  for (var i = 1; i < nums.length; i++) {
    dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
    max = Math.max(dp[i], max);
  }

  return max;
};

/**
 * https://discuss.leetcode.com/topic/5000/accepted-o-n-solution-in-java/11
 * @param nums
 * @returns {*}
 */
var maxSubArray = function(nums) {
  var max = nums[0];
  var sum = nums[0];

  for (var i = 1; i < nums.length; i++) {
    sum = sum > 0 ? sum + nums[i] : nums[i];
    max = Math.max(sum, max);
  }
  return max;
};

console.log(maxSubArray([1, 1, 1]) == 3);
console.log(maxSubArray([-1, -1, -1]) == -1);
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6);
console.log(maxSubArray([-2, -1]) == -1);
console.log(maxSubArray([-1]) == -1);
console.log(maxSubArray([-1, 0]) == 0);
```

# 062-Unique-Paths

```js
/**
 * https://leetcode.com/problems/unique-paths/
 * Difficulty:Medium
 *
 * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
 * The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
 * How many possible unique paths are there?
 * Note: m and n will be at most 100.
 *
 */

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  var arr = [];
  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      if (i === 0 && j === 0) arr[0] = 1;
      else {
        var left = j - 1 < 0 ? 0 : arr[i * n + j - 1];
        var top = i - 1 < 0 ? 0 : arr[(i - 1) * n + j];
        arr[i * n + j] = left + top;
      }
    }
  }
  return arr[arr.length - 1];
};

console.log(uniquePaths(2, 2));
```

# 063-Unique-Paths-II

```js
/**
 * https://leetcode.com/problems/unique-paths-ii/description/
 * Difficulty:Medium
 *
 * Follow up for "Unique Paths":
 * Now consider if some obstacles are added to the grids. How many unique paths would there be?
 * An obstacle and empty space is marked as 1 and 0 respectively in the grid.
 * For example,
 * There is one obstacle in the middle of a 3x3 grid as illustrated below.
 * [
 *  [0,0,0],
 *  [0,1,0],
 *  [0,0,0]
 * ]
 * The total number of unique paths is 2.
 * Note: m and n will be at most 100.
 */

/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
  var m = obstacleGrid.length;
  var n = obstacleGrid[0].length;
  var dp = [];
  while (dp.push(new Array(n + 1).fill(0)) <= m);

  dp[0][1] = 1;
  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      if (!obstacleGrid[i - 1][j - 1]) dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
    }
  }
  return dp[m][n];
};

console.log(uniquePathsWithObstacles([[0, 0]]));
```

# 064-Minimum-Path-Sum

```js
/**
 * https://leetcode.com/problems/minimum-path-sum/description/
 * Difficulty:Medium
 *
 * Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
 * Note: You can only move either down or right at any point in time.
 * Example 1:
 * [
 *  [1,3,1],
 *  [1,5,1],
 *  [4,2,1]
 * ]
 * Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
  var m = grid.length;
  var n = grid[0].length;
  var dp = [];
  while (dp.push(new Array(n + 1).fill(Number.MAX_VALUE)) <= m);
  dp[0][1] = 0;
  dp[1][0] = 0;

  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      dp[i][j] = grid[i - 1][j - 1] + Math.min(dp[i][j - 1], dp[i - 1][j]);
    }
  }

  return dp[m][n];
};

console.log(
  minPathSum([
    [1, 2],
    [1, 1],
  ]),
);
```

# 070-Climbing-Stairs

```js
/**
 * https://leetcode.com/problems/climbing-stairs/description
 * Difficulty:Easy
 *
 * You are climbing a stair case. It takes n steps to reach to the top.
 * Each time you can either climb 1 or 2 steps.
 * In how many distinct ways can you climb to the top?
 *
 * Note: Given n will be a positive integer.
 *
 * 答案:
 *
 * https://leetcode.com/articles/climbing-stairs/
 */

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
  if (n < 2) return 1;
  return climbStairs(n - 1) + climbStairs(n - 2);
};

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs2 = function(n) {
  var ways = [1, 1];
  for (var i = 2; i <= n; i++) {
    ways[i] = ways[i - 1] + ways[i - 2];
  }
  return ways[n];
};

console.log(climbStairs(1));
console.log(climbStairs(2));
console.log(climbStairs(3));
console.log(climbStairs(4));

console.log('==============');

console.log(climbStairs2(1));
console.log(climbStairs2(2));
console.log(climbStairs2(3));
console.log(climbStairs2(4));
```

# 083-Remove-Duplicates-from-Sorted-List

```js
/**
 * https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/
 * Difficulty:Easy
 *
 * Given a sorted linked list, delete all duplicates such that each element appear only once.
 *
 * For example,
 * Given 1->1->2, return 1->2.
 * Given 1->1->2->3->3, return 1->2->3.
 *
 */

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
  var p = head;
  if (!p) return p;
  var all = [p.val];
  var t = p.next;

  while (t) {
    if (all.indexOf(t.val) == -1) {
      all.push(t.val);
      p = t;
      t = p.next;
    } else {
      t = t.next;
      p.next = t;
    }
  }
  return head;
};

/**
 * 改进方案
 *
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates2 = function(head) {
  var p = head;
  while (p && p.next) {
    if (p.val == p.next.val) {
      p.next = p.next.next;
    } else {
      p = p.next;
    }
  }
  return head;
};
```

# 085-Maximal-Rectangle

```js
/**
 * https://leetcode.com/problems/maximal-rectangle/description/
 * Difficulty:Hard
 * Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
 * For example, given the following matrix:
 *
 * 1 0 1 0 0
 * 1 0 1 1 1
 * 1 1 1 1 1
 * 1 0 0 1 0
 *
 * Return 6.
 *
 */

/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
  var m = matrix.length;
  if (!m) return 0;
  var n = matrix[0].length;
  if (!n) return 0;

  var dp = [];
  while (dp.push(new Array(n + 1).fill([0, 0])) <= m);
  var max = 0;
  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      if (matrix[i - 1][j - 1] != 0) {
        dp[i][j] = [1, 1];
        var top = dp[i - 1][j];
        var left = dp[i][j - 1];
        if (top[0] * top[1] === 0) {
          dp[i][j] = [1, left[1] + 1];
        } else if (left[0] * left[1] === 0) {
          dp[i][j] = [top[0] + 1, 1];
        } else {
          var x1 = top[0] + 1;
          var y1 = Math.min(top[1], left[1] + 1);
          var p1 = x1 * y1;

          var x2 = Math.min(left[0], top[0] + 1);
          var y2 = left[1] + 1;
          var p2 = x2 * y2;

          if (p1 >= p2) {
            dp[i][j] = [x1, y1];
          } else {
            dp[i][j] = [x2, y2];
          }
        }

        max = Math.max(max, dp[i][j][0] * dp[i][j][1]);
      }
    }
  }

  // for (var i = 0; i < matrix.length; i++) {
  //     console.log(matrix[i].split(''));
  // }
  // console.log('======================');
  //
  // for (var i = 1; i < dp.length; i++) {
  //     console.log(dp[i].slice(1).join(' | '));
  // }

  return max;
};

// console.log(maximalRectangle([
//     [1, 0, 1, 0, 0],
//     [1, 0, 1, 1, 1],
//     [1, 1, 1, 1, 1],
//     [1, 0, 0, 1, 0],
// ]));

// console.log(maximalRectangle(
//     ["10100", "10111", "11111", "10010"]
// ));

console.log(maximalRectangle(['010', '110', '011', '010']));
```

# 091-Decode-Ways

```js
/**
 * https://leetcode.com/problems/decode-ways/description/
 * Difficulty:Medium
 *
 * A message containing letters from A-Z is being encoded to numbers using the following mapping:
 *
 * 'A' -> 1
 * 'B' -> 2
 * ...
 * 'Z' -> 26
 *
 * Given an encoded message containing digits, determine the total number of ways to decode it.
 * For example,
 * Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).
 * The number of ways decoding "12" is 2.
 *
 */

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  if (!s.length) return 0;
  var dp = [];
  var n = s.length;
  dp[0] = 1;

  for (var i = 1; i <= n; i++) {
    dp[i] = 0;
    var sum1 = parseInt(s[i - 1]);
    var sum2 = parseInt(s[i - 2] + s[i - 1]);

    if (sum1 > 0 && sum1 < 10) {
      dp[i] += dp[i - 1];
    }
    if (sum2 > 9 && sum2 < 27) {
      dp[i] += dp[i - 2];
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(numDecodings('0'));
console.log(numDecodings('12'));
console.log(numDecodings('10'));
console.log(numDecodings('01'));
console.log(numDecodings('100'));
```

# 095-Unique-Binary-Search-Trees-II

```js
/**
 * https://leetcode.com/problems/unique-binary-search-trees-ii/description/
 * Difficulty:Medium
 *
 * Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.
 *
 * For example,
 * Given n = 3, your program should return all 5 unique BST's shown below.
 *
 *  1         3     3      2      1
 *   \       /     /      / \      \
 *    3     2     1      1   3      2
 *   /     /       \                 \
 *  2     1         2                 3
 */

// Definition for a binary tree node.
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
  if (n === 0) return [];
  return _genTrees(1, n);
};

function _genTrees(start, end) {
  if (start > end) return [null];
  // if (start === end) return [new TreeNode(start)];
  var list = [];
  for (var i = start; i <= end; i++) {
    var leftTrees = _genTrees(start, i - 1);
    var rightTrees = _genTrees(i + 1, end);
    // console.log(leftTrees, rightTrees);

    leftTrees.forEach(left => {
      rightTrees.forEach(right => {
        var root = new TreeNode(i);
        root.left = left;
        root.right = right;
        list.push(root);
      });
    });
  }
  return list;
}

console.log(generateTrees(0));
```

# 096-Unique-Binary-Search-Trees

```js
/**
 * https://leetcode.com/problems/unique-binary-search-trees/description/
 * Difficulty:Medium
 *
 * Given n, how many structurally unique BST's (binary search trees) that store values 1...n?
 * For example,
 * Given n = 3, there are a total of 5 unique BST's.
 *
 *   1         3     3      2      1
 *    \       /     /      / \      \
 *    3      2     1      1   3      2
 *   /      /       \                 \
 *  2      1         2                 3
 *
 */

/**
 * G(n): the number of unique BST for a sequence of length n.
 * F(i, n), 1 <= i <= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.
 *
 * G(n) = F(1, n) + F(2, n) + ... + F(n, n).
 * G(0)=1, G(1)=1.
 *
 * F(i, n) = G(i-1) * G(n-i)    1 <= i <= n
 * G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)
 *
 *
 *
 */

/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  var dp = [1, 1];

  for (var i = 2; i <= n; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      dp[i] += dp[j] * dp[i - j - 1];
    }
  }
  return dp[n];
};

console.log(numTrees(1));
console.log(numTrees(2));
console.log(numTrees(3));
```

# 100-Same-Tree

```js
/**
 * https://leetcode.com/problems/same-tree/description/
 * Difficulty:Easy
 *
 * Given two binary trees, write a function to check if they are equal or not.
 * Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
  if (!p && !q) return true;
  if (!p || !q) return false;
  if (p.val !== q.val) return false;

  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

# 13

```js
// 13. Roman to Integer

// Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

// Symbol       Value
// I             1
// V             5
// X             10
// L             50
// C             100
// D             500
// M             1000
// For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

// Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

// I can be placed before V (5) and X (10) to make 4 and 9.
// X can be placed before L (50) and C (100) to make 40 and 90.
// C can be placed before D (500) and M (1000) to make 400 and 900.
// Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

// Example 1:

// Input: "III"
// Output: 3
// Example 2:

// Input: "IV"
// Output: 4
// Example 3:

// Input: "IX"
// Output: 9
// Example 4:

// Input: "LVIII"
// Output: 58
// Explanation: L = 50, V= 5, III = 3.
// Example 5:

// Input: "MCMXCIV"
// Output: 1994
// Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

/**
 * @param {string} s
 * @return {number}
 */
export default function romanToInt(s) {
  let total = 0;
  const map = new Map([
    ['I', 1],
    ['V', 5],
    ['X', 10],
    ['L', 50],
    ['C', 100],
    ['D', 500],
    ['M', 1000],
  ]);
  for (let i = 0; i < s.length; i++) {
    const curr = map.get(s[i]);
    if (i + 1 < s.length) {
      if (map.get(s[i + 1]) > curr) {
        total -= curr;
      } else {
        total += curr;
      }
    } else {
      total += curr;
    }
  }
  return total;
}
```

# 14.最长公共前缀

```js
/*
 * @lc app=leetcode.cn id=14 lang=javascript
 *
 * [14] 最长公共前缀
 */
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  if (strs.length === 1) return strs[0];
  const first = strs[0];
  for (let i = 0; i < first.length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[j][i] !== strs[0][i]) return strs[0].slice(0, i);
    }
  }
  return first;
};

console.log(longestCommonPrefix(['flower', 'flow', 'flight']));
console.log(longestCommonPrefix(['dog', 'racecar', 'car']));
console.log(longestCommonPrefix(['c', 'c']));
```

# 2.addTwoNumbers

```js
/**
 * https://leetcode.com/problems/add-two-numbers/description/
 * Difficulty:Medium
 *
 * 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
 * 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
 * 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
 * 示例：
 * 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
 * 输出：7 -> 0 -> 8
 * 原因：342 + 465 = 807
 *
 */

// Definition for singly-linked list.
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

function List(arr) {
  let head = new ListNode();
  const guard = head;
  if (arr.length === 0) return guard;
  for (let i = 0; i < arr.length; i++) {
    let temp = new ListNode(arr[i]);
    head.next = temp;
    head = temp;
  }
  return guard.next;
}

function ListNodeToString(listNode) {
  let resp = '';
  let cur = listNode;
  while (cur.next) {
    resp += `${cur.val} -> `;
    cur = cur.next;
  }
  resp += `${cur.val}`;
  console.log(resp);
}

// ListNodeToString(List([2, 3, 4]))

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  var c = 0;
  var ret = new ListNode(0);
  var curr = ret;

  while (l1 || l2) {
    var a = l1 ? l1.val : 0;
    var b = l2 ? l2.val : 0;
    var sum = a + b + c;
    // 商作为向前进的值
    c = Math.floor(sum / 10);
    // 当前位数的节点
    curr.next = new ListNode(sum % 10);
    if (l1) {
      l1 = l1.next;
    }
    if (l2) {
      l2 = l2.next;
    }
    curr = curr.next;
  }
  // 最后需要创建的一位
  if (c) {
    curr.next = new ListNode(c);
  }

  return ret.next;
};

const l1 = List([2, 4, 3]);
const l2 = List([5, 6, 4]);
const l3 = addTwoNumbers(l1, l2);
ListNodeToString(l3);
```

# 20

```js
// Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

// An input string is valid if:

// Open brackets must be closed by the same type of brackets.
// Open brackets must be closed in the correct order.
// Note that an empty string is also considered valid.

// Example 1:

// Input: "()"
// Output: true
// Example 2:

// Input: "()[]{}"
// Output: true
// Example 3:

// Input: "(]"
// Output: false
// Example 4:

// Input: "([)]"
// Output: false
// Example 5:

// Input: "{[]}"
// Output: true

/**
 * @param {string} s
 * @return {boolean}
 */
export default function isValid(s) {
  const stack = [];
  const map = new Map([
    [')', '('],
    ['}', '{'],
    [']', '['],
  ]);
  const closing = new Set([')', '}', ']']);
  for (let i = 0; i < s.length; i++) {
    if (stack.length) {
      const top = stack[stack.length - 1];
      // if s[i] is closing, must match
      if (closing.has(s[i])) {
        // if matches top of stack, pop stack
        if (map.get(s[i]) === top) {
          stack.pop();
        } else {
          return false;
        }
      } else {
        stack.push(s[i]);
      }
    } else if (stack.length === 0 && closing.has(s[i])) {
      return false;
    } else {
      stack.push(s[i]);
    }
  }
  return stack.length === 0;
}
```

# 20.有效的括号

```js
/*
 * @lc app=leetcode.cn id=20 lang=javascript
 *
 * [20] 有效的括号
 */
// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

// 有效字符串需满足：

// 左括号必须用相同类型的右括号闭合。
// 左括号必须以正确的顺序闭合。
// 注意空字符串可被认为是有效字符串。

// 示例 1:

// 输入: "()"
// 输出: true
// 示例 2:

// 输入: "()[]{}"
// 输出: true
// 示例 3:

// 输入: "(]"
// 输出: false
// 示例 4:

// 输入: "([)]"
// 输出: false
// 示例 5:

// 输入: "{[]}"
// 输出: true
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  const stack = [];

  for (let l of s) {
    if (l.trim()) {
      stack.push(l);
      const length = stack.length;
      if (length > 1 && ['{}', '[]', '()'].includes(stack[length - 2] + stack[length - 1])) {
        stack.length -= 2;
      }
    }
  }

  return !stack.length;
};

// 最高赞
var isValid1 = function(s) {
  var st = [];
  for (var l of s)
    if ((i = '({[]})'.indexOf(l)) > -1)
      if (st[st.length - 1] + i === 5) st.length--;
      else st.push(i);
  return st.length === 0;
};

['()', '()[]{}', '(]', '([)]', '{[]}'].forEach(elm => {
  console.log(isValid(elm));
});
```

# 21

```js
// 21. Merge Two Sorted Lists

// Merge two sorted linked lists and return it as a new list. The new list should be
// made by splicing together the nodes of the first two lists.

// Example:
// Input: 1->2->4, 1->3->4
// Output: 1->1->2->3->4->4

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
export default function mergeTwoLists(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;
  let head = l1.val < l2.val ? l1 : l2;
  const first = head;
  let other = l1.val < l2.val ? l2 : l1;

  while (head && other) {
    if (!head.next) {
      head.next = other;
      break;
    } else if (head.next.val <= other.val) {
      head = head.next;
    } else {
      const dummy = head.next;
      head.next = other;
      other = dummy;
      head = head.next;
    }
  }

  return first;
}
```

# 21.merge-two-sorted-lists

```js
/*
 * @lc app=leetcode id=21 lang=javascript
 *
 * [21] Merge Two Sorted Lists
 *
 * https://leetcode.com/problems/merge-two-sorted-lists/description/
 *
 * algorithms
 * Easy (46.02%)
 * Total Accepted:    562.7K
 * Total Submissions: 1.2M
 * Testcase Example:  '[1,2,4]\n[1,3,4]'
 *
 * Merge two sorted linked lists and return it as a new list. The new list
 * should be made by splicing together the nodes of the first two lists.
 *
 * Example:
 *
 * Input: 1->2->4, 1->3->4
 * Output: 1->1->2->3->4->4
 *
 *
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
// l1 l2 只是两个引用
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  // 需要 return 的是头节点的引用， current 指针会移动
  const dummy = current;

  // 需要循环到两个链表节点都为空
  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  // dummy 是一个空的头节点，还是需要反馈开头的第一个节点
  return dummy.next;
};

var newMergeTwoLists = function(l1, l2) {
  if (l1 === null) return l2;
  if (l2 === null) return l1;
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

let l1 = List([1, 2, 4]);
ListToString.call(l1);

let l2 = List([1, 3, 4]);
ListToString.call(l2);

const mergeTwoLists1 = (l1, l2) => {
  let current = new ListNode();
  const guard = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return guard.next;
    }
    if (!l2) {
      current.next = l1;
      return guard.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    // 移动节点
    current = current.next;
  }
  return guard.next;
};

let l3 = mergeTwoLists1(l1, l2);
ListToString.call(l3);
```

# 21.合并两个有序链表

```js
/*
 * @lc app=leetcode.cn id=21 lang=javascript
 *
 * [21] 合并两个有序链表
 * 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
 * 输入：1->2->4, 1->3->4
 * 输出：1->1->2->3->4->4
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  const bool = l1.val <= l2.val,
    l3 = new ListNode(bool ? l1.val : l2.val),
    current = l3;
  if (bool) {
    l1 = l1.next;
  } else {
    l2 = l2.next;
  }
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      current.next = l1;
      current = current.next;
      l1 = l1.next;
    } else {
      current.next = l2;
      current = current.next;
      l2 = l1.next;
    }
  }

  if (l1) {
  }

  return current;
};

function List(arr) {
  let current = new ListNode();
  const guard = current;
  for (let i = 0; i < arr.length; i++) {
    current.next = new ListNode(arr[i]);
  }

  return guard.next;
}

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

const l1 = List([1, 1, 2]),
  l2 = List([1, 1, 2, 3, 3]);
ListToString.call(l1);
ListToString.call(l2);
```

# 24

```js
// 24. Swap Nodes in Pairs

// Given a linked list, swap every two adjacent nodes and return its head.

// You may not modify the values in the list's nodes, only nodes itself may be changed.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function swapPairs(head) {
  let curr = head;
  let prev = null;
  let newHead;
  while (curr && curr.next) {
    const tmp = curr;
    const { next } = curr;
    if (!newHead) newHead = next;
    if (prev) prev.next = next;
    curr = curr.next.next;
    next.next = tmp;
    tmp.next = curr;
    prev = tmp;
  }
  return newHead || head;
}
```

# 26.删除排序数组中的重复项

```js
/*
 * @lc app=leetcode.cn id=26 lang=javascript
 *
 * [26] 删除排序数组中的重复项
 */

// 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

// 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

// 示例 1:

// 给定数组 nums = [1, 1, 2],

//   函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。

// 你不需要考虑数组中超出新长度后面的元素。
// 示例 2:

// 给定 nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4],

//   函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

// 你不需要考虑数组中超出新长度后面的元素。
// 说明:

// 为什么返回数值是整数，但输出的答案是数组呢 ?

//   请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

// 你可以想象内部操作如下:

// // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
// int len = removeDuplicates(nums);

// // 在函数里修改输入数组对于调用者是可见的。
// // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const cached = {};
  for (let i = 0; i < nums.length; i++) {
    if (!cached[nums[i]]) {
      cached[nums[i]] = true;
    } else {
      nums.splice(i, 1);
      i--;
    }
  }
  return nums.length;
};

var removeDuplicates1 = function(nums) {
  // 给定的是一个排序数组， 所以甚至于不用 map
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) {
      nums.splice(i, 1);
      i--;
    }
  }
  return nums.length;
};

[[1, 1, 2], [0, 0, 1, 1, 1, 2, 2, 3, 3, 4], [9]].forEach(elm => {
  console.log(removeDuplicates(elm));
});
```

# 28.实现-str-str

```js
/*
 * @lc app=leetcode.cn id=28 lang=javascript
 *
 * [28] 实现 strStr()
 */
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 * 实现一个 indexOf 函数
 */
var strStr = function(haystack, needle) {
  var m = haystack.length,
    n = needle.length;
  if (!n) return 0;
  var lps = kmpProcess(needle);
  for (var i = 0, j = 0; i < m; ) {
    if (haystack[i] == needle[j]) {
      i++, j++;
    }
    if (j == n) return i - j;
    if (i < m && haystack[i] != needle[j]) {
      if (j) j = lps[j - 1];
      else i++;
    }
  }
  return -1;
};

var kmpProcess = function(needle) {
  var n = needle.length;
  var lps = new Array(n).fill(0);
  for (var i = 1, length = 0; i < n; ) {
    if (needle[i] === needle[length]) {
      length++;
      lps[i] = length;
      i++;
    } else if (length) length = lps[length - 1];
    else {
      lps[i] = 0;
      i++;
    }
  }
  return lps;
};
```

# 30.串联所有单词的子串

```js
/*
 * @lc app=leetcode.cn id=30 lang=javascript
 *
 * [30] 串联所有单词的子串
 */
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  const result = [];
  // 1. 算出子串
  const sub = getSubStr(words);
  console.log(sub);
  for (let i = 0; i < sub.length; i++) {
    const index = s.indexOf(sub[i]);
    if (index !== -1) {
      result.push(index);
    }
  }
  return result;

  // 2. 正则计算. 全局匹配
};

function getSubStr(arr) {
  if (arr.length < 2) return arr;
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const sub = getSubStr(arr.slice(1));
    for (let j = 0; j < sub.length; j++) {
      if (i !== j) {
        result.push(`${arr[i]}${sub[j]}`);
      }
    }
  }
  return result;
}

console.log(findSubstring('barfoothefoobarman', ['foo', 'bar']));
// console.log(findSubstring('wordgoodgoodgoodbestword', ["word", "good", "best", "word"]))
```

# 30.串联所有单词的子串 copy

```js
/*
 * @lc app=leetcode.cn id=30 lang=javascript
 *
 * [30] 串联所有单词的子串
 */
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  const reg = new RegExp();
};

const factorial = n => {
  if (n === 1) return 1;
  return n * factorial(n - 1);
};

console.log('factorial', factorial(2));
console.log('factorial', factorial(3));
```

# 34.find-first-and-last-position-of-element-in-sorted-array

```js
/*
 * @lc app=leetcode id=34 lang=javascript
 *
 * [34] Find First and Last Position of Element in Sorted Array
 * 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
 * 你的算法时间复杂度必须是 O(log n) 级别。
 * 如果数组中不存在目标值，返回 [-1, -1]。
 * 示例 1:
 * 输入: nums = [5,7,7,8,8,10], target = 8
 * 输出: [3,4]
 * 示例 2:
 * 输入: nums = [5,7,7,8,8,10], target = 6
 * 输出: [-1,-1]
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 题目要求时间复杂度为O(logn)因此很自然想到二分法
  let start = 0;
  let end = nums.length - 1;
  while (start <= end) {
    // >> 1 除以 2 取整； << 1 乘 2
    const mid = start + ((end - start) >> 1);

    if (nums[mid] === target) {
      let left = 0;
      let right = 0;

      while (nums[mid - left] === target) {
        left++;
      }
      while (nums[mid + right] === target) {
        right++;
      }
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return [-1, -1];
};
```

# 34.在排序数组中查找元素的第一个和最后一个位置

```js
/*
 * @lc app=leetcode.cn id=34 lang=javascript
 *
 * [34] 在排序数组中查找元素的第一个和最后一个位置
 * 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
 * 你的算法时间复杂度必须是 O(log n) 级别。
 * 如果数组中不存在目标值，返回 [-1, -1]。
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 升序， 并且对时间复杂度有要求是 O(logn) 只能是 二分搜索
  let start = 0,
    end = nums.length - 1,
    mid;
  // 需要给 = ，处理 length === 1 的情况
  while (start <= end) {
    mid = start + ((end - start) >> 1);
    let left = (right = 0);
    if (nums[mid] === target) {
      while (nums[mid - left] === target) left++;
      while (nums[mid + right] === target) right++;
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else if (nums[mid] < target) {
      start = mid + 1;
    }
  }

  return [-1, -1];
};

console.log(searchRange([5, 7, 7, 8, 8, 10], 8));
console.log(searchRange([1], 1));
```

# 35

```js
// 35. Search Insert Position

// Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

// You may assume no duplicates in the array.

// Example 1:

// Input: [1,3,5,6], 5
// Output: 2
// Example 2:

// Input: [1,3,5,6], 2
// Output: 1
// Example 3:

// Input: [1,3,5,6], 7
// Output: 4
// Example 4:

// Input: [1,3,5,6], 0
// Output: 0

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
export default function searchInsert(nums, target) {
  if (!nums.length) return -1;
  let lo = 0;
  let hi = nums.length - 1;
  while (lo <= hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] === target) return mid;
    if (lo === hi) return nums[lo] < target ? lo + 1 : lo;
    if (nums[mid] < target) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
}
```

# 38.报数

```js
/*
 * @lc app=leetcode.cn id=38 lang=javascript
 *
 * [38] 报数
 */
/**
 * @param {number} n
 * @return {string}
 */
const result = {};
var countAndSay = function(n) {
  let start = '1',
    tmp = 1,
    res = '';
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < start.length; j++) {
      if (j === start.length - 1 || start[j] !== start[j + 1]) {
        res += `${tmp}${start[j]}`;
        tmp = 1;
      } else {
        tmp++;
      }
    }
    start = res;
    res = '';
  }
  return start;
};

// 1.     1
// 2.     11
// 3.     21
// 4.     1211
// 5.     111221

// f(n) = read(f(n - 1))
// ...
// f(2) = read(f(1))
// f(1) = 1

// f(x) = `${num}num1...`
// console.log(countAndSay(1))
// console.log(countAndSay(2))
// console.log(countAndSay(3))
// console.log(countAndSay(4))
// console.log(countAndSay(5))
// console.log(countAndSay(10))
// console.log(countAndSay(25))
```

# 3Sum Closest

```js
/**
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  var len = nums.length,
    minDiff = Number.MAX_VALUE,
    diff,
    left,
    right,
    i,
    j;

  nums.sort(function(a, b) {
    return a - b;
  });

  for (i = 0; i < len; i++) {
    left = i + 1;
    right = len - 1;

    while (left < right) {
      diff = target - nums[i] - nums[left] - nums[right];

      if (diff === 0) {
        return target;
      } else if (diff > 0) {
        left++;
      } else {
        right--;
      }

      if (Math.abs(diff) < Math.abs(minDiff)) {
        minDiff = diff;
      }
    }
  }

  return target - minDiff;
};
```

# 3Sum

```js
/**
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:
Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
The solution set must not contain duplicate triplets.
    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)

*/
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });

  var len = nums.length,
    i,
    result = [],
    curSol = [];

  for (i = 0; i < len; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }

    curSol.push(nums[i]);
    twoSum(result, curSol.concat(), i + 1, len - 1, -nums[i], nums);
    curSol.pop();
  }

  return result;
};

function twoSum(allSol, curSol, startIndex, endIndex, target, nums) {
  var start = startIndex,
    end = endIndex,
    sum,
    mid;

  while (start < end) {
    sum = nums[start] + nums[end];

    if (sum === target) {
      curSol.push(nums[start]);
      curSol.push(nums[end]);
      allSol.push(curSol.concat());
      curSol.pop();
      curSol.pop();

      start++;
      end--;

      while (nums[start] === nums[start - 1]) {
        start++;
      }

      while (nums[end] === nums[end + 1]) {
        end--;
      }
    } else if (sum < target) {
      start++;
    } else {
      end--;
    }
  }
}
```

# 4.寻找两个有序数组的中位数

```js
/*
 * @lc app=leetcode.cn id=4 lang=javascript
 *
 * [4] 寻找两个有序数组的中位数
 */
// 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

// 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)) 。

// 你可以假设 nums1 和 nums2 不会同时为空。

// 示例 1:

// nums1 = [1, 3]
// nums2 = [2]

// 则中位数是 2.0
// 示例 2:

// nums1 = [1, 2]
// nums2 = [3, 4]

// 则中位数是(2 + 3) / 2 = 2.5
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */

//  TODO: 二分查找
//  24% 16%
var findMedianSortedArrays = function(nums1, nums2) {
  // 合并数组
  let nums = [...nums1, ...nums2];

  // 排序(有时间复杂度要求，那应该是要快排或者归并排序了)
  nums = nums.sort((a, b) => a - b);

  // 计算中位数
  const length = nums.length;
  return length % 2 === 0 ? (nums[length / 2] + nums[length / 2 - 1]) / 2 : nums[parseInt(length / 2)];
};

const swap = (arr, i, j) => {
  [arr[i], arr[j]] = [arr[j], arr[i]];
};

// let nums1 = [1, 3], nums2 = [2]

// console.log(findMedianSortedArrays(nums1, nums2))

// nums1 = [1, 2]
// nums2 = [3, 4]

// console.log(findMedianSortedArrays(nums1, nums2))

// nums1 = [2]
// nums2 = []

// console.log(findMedianSortedArrays(nums1, nums2))

// nums1 = []
// nums2 = [1, 2, 3, 4]

// console.log(findMedianSortedArrays(nums1, nums2))

nums1 = [3];
nums2 = [-2, -1];

console.log(findMedianSortedArrays(nums1, nums2));

var newFindMedianSortedArrays = function(nums1, nums2) {};
```

# 41.缺失的第一个正数

```js
/*
 * @lc app=leetcode.cn id=41 lang=javascript
 *
 * [41] 缺失的第一个正数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
// ✔ Accepted
// ✔ 165 / 165 cases passed(100 ms)
// ✔ Your runtime beats 27.41 % of javascript submissions
// ✔ Your memory usage beats 18.66 % of javascript submissions(35 MB)
var firstMissingPositive = function(nums) {
  nums = nums.filter(num => num > 0).sort((a, b) => a - b);
  if (nums.length) {
    if (nums[0] === 1) {
      for (let i = 1; i < nums.length; i++) {
        if (nums[i] - nums[i - 1] > 1) {
          return nums[i - 1] + 1;
        }
      }
      return nums.pop() + 1;
    } else {
      return 1;
    }
  }

  // 正整数数组为空，直接返回 1
  return 1;
};

// ✔ Accepted
// ✔ 165 / 165 cases passed(88 ms)
// ✔ Your runtime beats 57.46 % of javascript submissions
// ✔ Your memory usage beats 7.65 % of javascript submissions(35.4 MB)
// 选择排序 每一轮都会选出最小值
var firstMissingPositive2 = function(nums) {
  nums = nums.filter(num => num > 0);
  // 数组过滤了之后为空直接返回 1
  if (nums.length === 0) return 1;
  for (let i = 0, minIndex, len = nums.length; i < len; i++) {
    minIndex = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }
    if (i !== minIndex) [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    // 判断最小的数是否是 1
    if (i === 0) {
      if (nums[i] !== 1) return 1;
      // 大于 1 之后，每次都可以比较前面部分，前面部分是有序的， 后面部分还是无序
    } else if (nums[i] - nums[i - 1] > 1) {
      return nums[i - 1] + 1;
    }
  }
  return nums.pop() + 1;
};

console.log(firstMissingPositive([]));
console.log(firstMissingPositive([2]));
console.log(firstMissingPositive([1, 2, 0]));
console.log(firstMissingPositive([3, 4, -1, 1]));
console.log(firstMissingPositive([7, 8, 9, 11, 12]));
console.log(firstMissingPositive([0, 2, 2, 1, 1]));
```

# 4Sum

```js
/**
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:
Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)
The solution set must not contain duplicate quadruplets.
    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

    A solution set is:
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
  nums.sort(function(a, b) {
    return a - b;
  });

  var len = nums.length,
    result = [],
    i;

  kSum(result, [], 4, nums, target, 0, len - 1);

  return result;
};

function kSum(result, curArr, k, nums, target, startIndex, endIndex) {
  var len = nums.length,
    start,
    end,
    sum,
    i;

  if (k >= 3) {
    for (i = startIndex; i <= endIndex; i++) {
      if (i > startIndex && nums[i] === nums[i - 1]) {
        continue;
      }

      curArr.push(nums[i]);
      kSum(result, curArr.concat(), k - 1, nums, target - nums[i], i + 1, endIndex);
      curArr.pop();
    }
  }

  if (k === 1) {
    for (i = startIndex; i <= endIndex; i++) {
      if (nums[i] === target) {
        result.push(nums[i]);
      }
    }
  }

  if (k === 2) {
    start = startIndex;
    end = endIndex;

    while (start < end) {
      sum = nums[start] + nums[end];

      if (sum === target) {
        curArr.push(nums[start]);
        curArr.push(nums[end]);
        result.push(curArr.concat());
        curArr.pop();
        curArr.pop();

        start++;
        end--;

        while (nums[start] === nums[start - 1]) {
          start++;
        }

        while (nums[end] === nums[end + 1]) {
          end--;
        }
      } else if (sum < target) {
        start++;
      } else {
        end--;
      }
    }
  }
}
```

# 50.pow-x-n

```js
/*
 * @lc app=leetcode.cn id=50 lang=javascript
 *
 * [50] Pow(x, n)
 */
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (n === 0) return 1;
  if (n === 1) return x;

  let pow = Math.abs(n);
  const result = pow % 2 === 0 ? myPow(x * x, pow / 2) : myPow(x * x, (pow - 1) / 2) * x;
  return n > 0 ? result : 1 / result;
};

console.log(myPow(8.95371, -1));
```

# 53.最大子序和

```js
/*
 * @lc app=leetcode.cn id=53 lang=javascript
 *
 * [53] 最大子序和
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
// 典型的动态规划 dp[i] = max(dp[i-1] + num[i], dp[i-2])
var maxSubArray = function(nums) {
  if (nums.length < 2) return nums.length === 0 ? 0 : nums[0];
  let max = nums[0];
  for (let i = 1; i < nums.length; i++) {
    // 跟 nums[i] 比较的话， nums[i] 更大表示选取当前值，否则就不选
    // sums[i] = Math.max(sums[i - 1] + nums[i], nums[i])
    // 或者换一种想法就是，判断前一次的结果是否大于 0
    // 大于的话加上当前位置的值，就是最长序列
    // 否则的话，加上前面的和只会更小，也就是只取当前位置为一个新数组
    nums[i] = nums[i] + Math.max(nums[i - 1], 0);
    if (nums[i] > max) {
      max = nums[i];
    }
  }
  return max;
};

console.log(maxSubArray([-2, 1, -3, 4]));
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

# 56.合并区间

```js
/*
 * @lc app=leetcode.cn id=56 lang=javascript
 *
 * [56] 合并区间
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
// 两个区间若能合并，则第一个区间的右端点一定不小于第二个区间的左端点。所以先把区间集合按照左端点从小到大进行排序，接着从第一个区间开始遍历，对每个区间执行如下操作：

// 1. 首先保存该区间的左端点start和右端点end
// 2. 从该区间的下一个区间开始，依次比较此区间的左端点与上一个区间的右端点，若满足合并条件则记录新合并区间的右端点。注意右端点取当前区间与之前区间右端点的较大值
// 3. 若当前区间不再满足合并条件或者遍历到了集合末尾，就构建新合并区间，其中左端点为初始区间的左端点，右端点为当前所有合并区间右端点的最大值，然后将其加入到结果集合中，接着合并下一个区间
var merge = function(intervals) {
  if (intervals.length < 2) return intervals;
  intervals = intervals.sort((a, b) => a[0] - b[0]);
  let left = intervals[0][0],
    right = intervals[0][1];

  for (let i = 1; i < intervals.length; i++) {}
};
```

# 58.最后一个单词的长度

```js
/*
 * @lc app=leetcode.cn id=58 lang=javascript
 *
 * [58] 最后一个单词的长度
 */
// 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。

// 如果不存在最后一个单词，请返回 0 。

// 说明：一个单词是指由字母组成，但不包含任何空格的字符串。

/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
  const resp = s.split(' ').filter(elm => elm.trim());
  return resp.length ? resp.pop().length : 0;
};

['Hello World', '', ' ', 'Hello World ', ' a', 'b   a    '].forEach(elm => {
  console.log(lengthOfLastWord(elm));
});
```

# 6

```js
//
// The string "PAYPALISHIRING" is written in a zigzag pattern on a given number
// of rows like this: (you may want to display this pattern in a fixed font for
// better legibility)
//
// P   A   H   N
// A P L S I I G
// Y   I   R
//
// And then read line by line: "PAHNAPLSIIGYIR"
//
// Write the code that will take a string and make this conversion given a
// number of rows:
export default function ZigZag(string: string, number: number): string {
  const output = [];
  const middle = number - Math.floor(number / 2);
  let rowNumber = 0;
  let index = 0;
  let i = 0;

  while (output.length < string.length) {
    output[i] = string[index];

    if (rowNumber !== Math.floor(number / 2)) {
      if (index + number + 1 > string.length) {
        rowNumber++;
        index = rowNumber;
      } else if (number % 2 === 0) {
        index += number;
      } else {
        index += number + 1;
      }
    } else if (index + middle > string.length) {
      rowNumber++;
      index = rowNumber;
    } else {
      index += middle;
    }
    i++;
  }

  return output.join('');
}
```

# 64.最小路径和

```js
/*
 * @lc app=leetcode.cn id=64 lang=javascript
 *
 * [64] 最小路径和
 */
/**
 * @param {number[][]} grid
 * @return {number}
 */
// 这是最基础的动态规划题目。 不过是二维的。
// dp[i][j]代表从(0, 0)走到(i, j)的最小路径和则
// dp[0][i]来自第一行的累加
// dp[i][0]来自第一列的累加
// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + c[i][j]
// (来自当前位置的走法无非向下或向右，选两者中代价最小的)
var minPathSum = function(grid) {
  const row = grid.length;
  const line = grid[0].length;
  const dp = [];
  dp[0] = [grid[0][0]];
  for (let i = 1; i < row; i++) {
    if (dp[i] === undefined) {
      dp[i] = [];
    }
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }
  for (let j = 1; j < line; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }
  for (let i = 1; i < row; i++) {
    for (let j = 1; j < line; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  // console.log(dp)
  return dp[row - 1][line - 1];
};

console.log(
  minPathSum([
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
  ]),
);

console.log(
  minPathSum([
    [0, 1],
    [1, 0],
  ]),
);
```

# 66.加一

```js
/*
 * @lc app=leetcode.cn id=66 lang=javascript
 *
 * [66] 加一
 */

// 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

// 你可以假设除了整数 0 之外，这个整数不会以零开头。

// 示例 1:

// 输入: [1, 2, 3]
// 输出: [1, 2, 4]
// 解释: 输入数组表示数字 123。
// 示例 2:

// 输入: [4, 3, 2, 1]
// 输出: [4, 3, 2, 2]
// 解释: 输入数组表示数字 4321。

/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  let shouldAddOne = true;
  for (let i = digits.length - 1; i >= 0; i--) {
    if (shouldAddOne) {
      if (digits[i] === 9) {
        digits[i] = 0;
        shouldAddOne = true;
      } else {
        digits[i] += 1;
        shouldAddOne = false;
      }
    }
  }
  if (shouldAddOne) {
    digits.unshift(1);
  }

  return digits;
};

[[1, 2, 3], [4, 3, 2, 1], [9]].forEach(elm => {
  console.log(plusOne(elm));
});
```

# 67.二进制求和 copy 2

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */

function getLastChar(str) {
  if (str) {
    return str[str.length - 1];
  }
  return 0;
}

function advance(str) {
  if (str) {
    return str.slice(0, -1);
  }
}
var addBinary = function(a, b) {
  let result = [],
    carry = 0; // 进位
  while (a || b || carry) {
    let valueA = parseInt(getLastChar(a)),
      valueB = parseInt(getLastChar(b));

    const needCarry = valueA + valueB + carry > 1;

    result.push(needCarry ? valueA + valueB + carry - 2 : valueA + valueB + carry);

    a = advance(a);
    b = advance(b);

    carry = needCarry ? 1 : 0;
  }

  return result.reverse().join('');
};

console.log(addBinary('111', '1'));
console.log(addBinary('1', '1'));
```

# 67.二进制求和 copy

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary1 = function(a, b) {
  let c = 0;
  let aLen = a.length;
  let bLen = b.length;
  let ans = '';
  for (var i = 0; i < Math.max(aLen, bLen); i++) {
    var ai = i < aLen ? parseInt(a[aLen - i - 1]) : 0;
    var bi = i < bLen ? parseInt(b[bLen - i - 1]) : 0;

    var sum = ai + bi + c;
    // console.log(ai, bi, c);
    if (sum < 2) {
      ans = sum + ans;
      c = 0;
    } else {
      ans = sum - 2 + ans;
      c = 1;
    }
  }
  if (c) {
    ans = 1 + ans;
  }

  return ans;
};

console.log(addBinary1('111', '1'));
```

# 67.二进制求和

```js
// Given two binary strings, return their sum (also a binary string).

// The input strings are both non-empty and contains only characters 1 or 0.

// Example 1:

// Input: a = "11", b = "1"
// Output: "100"
// Example 2:

// Input: a = "1010", b = "1011"
// Output: "10101"

// 二进制求和
// 给定两个二进制字符串，返回他们的和(用二进制表示)。

// 输入为非空字符串且只包含数字 1 和 0。

// 示例 1:

// 输入: a = "11", b = "1"
// 输出: "100"
// 示例 2:

// 输入: a = "1010", b = "1011"
// 输出: "10101"

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
export default function addBinary(a, b) {
  let i = a.length - 1;
  let j = b.length - 1;
  const ans = [];
  let carry = 0;
  while (j >= 0 || i >= 0 || carry) {
    let sum = carry;
    if (i >= 0) {
      sum += parseInt(a[i], 10);
      i--;
    }
    if (j >= 0) {
      sum += parseInt(b[j], 10);
      j--;
    }
    carry = sum > 1 ? 1 : 0;
    ans.push(sum % 2);
  }
  return ans.reverse().join('');
}
```

# 69

```js
/**
 * @param {number} x
 * @return {number}
 */
const mySqrt = function(x) {
  if (x === 1) return 1;
  let min = 0;
  let max = parseInt(x / 2);
  let mid = parseInt((max + min) / 2);
  let ans;
  while (!ans) {
    if (mid ** 2 === x) {
      return mid;
    }
    if (mid ** 2 < x) {
      min = mid + 1;
    } else {
      max = mid - 1;
    }
    if (min === max) return min;
    if (min + 1 === max && min ** 2 < x && max ** 2 > x) return min;
    if (mid === parseInt((max + min) / 2)) return mid;
    mid = parseInt((max + min) / 2);
  }
  return ans;
};
```

# 69.x-的平方根

```js
/*
 * @lc app=leetcode.cn id=69 lang=javascript
 *
 * [69] x 的平方根
 */
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
  let left = 1,
    right = x,
    mid;

  while (left <= right) {
    mid = Math.floor((left + right) / 2);

    if (mid * mid > x) {
      right = mid - 1;
    } else if (mid * mid < x) {
      left = mid + 1;
    } else return mid;
  }

  return right;
};

// console.log(mySqrt(4))
// console.log(mySqrt(8))
// console.log(mySqrt(9))
// console.log(mySqrt(10))
// console.log(mySqrt(24))
// console.log(mySqrt(101))
// console.log(mySqrt(101))
```

# 7.整数反转

```js
/*
 * @lc app=leetcode.cn id=7 lang=javascript
 *
 * [7] 整数反转
 */
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  if (x === 0) {
    //超过范围的返回0
    return 0;
  }
  const sign = x > 0;

  let result = 0,
    absValue = Math.abs(x);
  while (absValue !== 0) {
    result = 10 * result + (absValue % 10);
    absValue = parseInt(absValue / 10);
  }
  const MAX = Math.pow(2, 31) - 1;
  const MIN = -1 * Math.pow(2, 31);
  result = x > 0 ? result : -1 * result;
  return result <= MAX && result >= MIN ? result : 0;
};

console.log(reverse(123));
console.log(reverse(-123));
console.log(reverse(120));
console.log(reverse(1534236469));
```

# 70.爬楼梯

```js
/*
 * @lc app=leetcode.cn id=70 lang=javascript
 *
 * [70] 爬楼梯
 */
/**
 * @param {number} n
 * @return {number}
 */
const map = {};
var climbStairs = function(n) {
  if (n <= 2) return n;
  if (!map[n]) {
    map[n] = climbStairs(n - 1) + climbStairs(n - 2);

    return map[n];
  }
  // console.log('map', map)
  return map[n];
};

// console.log(climbStairs(2))
console.log(climbStairs(3));
console.log(climbStairs(4));
console.log(climbStairs(20));
console.log(climbStairs(40));

// f(n) = f(n - 1) + f(n - 2)
// ...
// f(2) = 2
// f(1) = 1
```

# 78.子集

```js
/*
 * @lc app=leetcode.cn id=78 lang=javascript
 *
 * [78] 子集
 */
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  if (nums.length === 0) return [];
  const length = nums.length;
  const result = [];
};

function select(n, nums = []) {
  if (n === 0) return [];

  for (let i = 0; i < nums.length; i++) {}
}
```

# 83.删除排序链表中的重复元素

```js
/*
 * @lc app=leetcode.cn id=83 lang=javascript
 *
 * [83] 删除排序链表中的重复元素
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
  let l1 = head;
  while (l1.next) {
    if (l1.next.val === l1.val) {
      l1.next = l1.next.next;
    } else {
      l1 = l1.next;
    }
  }
  return head;
};

function List(arr) {
  let current = new ListNode();
  const guard = current;
  for (let i = 0; i < arr.length; i++) {
    current.next = new ListNode(arr[i]);
  }
  return guard.next;
}

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

const l1 = List([1, 1, 2]),
  l2 = List([1, 1, 2, 3, 3]);
// ListToString.call(l1)
// ListToString.call(l2)

console.log(ListToString.call(deleteDuplicates(l1)));
console.log(ListToString.call(deleteDuplicates(l2)));
```

# 84.largest-rectangle-in-histogram

```js
/*
 * @lc app=leetcode id=84 lang=javascript
 *
 * [84] Largest Rectangle in Histogram
 */
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  // 木桶原理
  // 暴力求解法 时间复杂度O(n^2) 空间复杂度O(1)
  // if (heights.length === 1) return heights[0];
  // let min = null;
  // let max = 0;
  // for (let i = 0; i < heights.length; i++) {
  //   min = heights[i];
  //   for (let j = i; j < heights.length; j++) {
  //     min = Math.min(min, heights[j]);
  //     max = Math.max((j - i + 1) * min, max);
  //   }
  // }
  // return max;
  // 上面的暴力求解，其实可以做一个小优化，就是通过取局部最大值来减少一部分重复计算，但是时间复杂度还是O(n^2)
  // 关键点： 1. 单调栈(Monotone Stack),线性复杂度,因为所有元素只会进入栈一次，并且出栈后再也不会进栈了 2.如果用暴力求解的话，你要会找出所有组合的方法(大部分题目都是两两组合，如果是任意组合的情况，暴力的话复杂度是2^n，
  // 这种情况，暴力求解通常不不取，需要考虑别的思路)
  // 当前题目就是两两组合 ，时间复杂度是O(n^2)，在可以接受的范围
  // 社区中流行的一种解法: 单调栈,  在这里我们需要使用单调递增栈
  // 时间复杂度O(n) 空间复杂度O(n)
  // const ascStack = [];
  // let max = 0;
  // heights.push(0); // hack, 为了使最后一个柱子也参与运算
  // for (let i = 0; i < heights.length; i++) {
  //   let p = i;
  //   while (
  //     ascStack.length > 0 &&
  //     heights[i] < heights[ascStack[ascStack.length - 1]]
  //   ) {
  //     // 由于是递增栈， height[p]一定是最小的，一定是短板
  //     p = ascStack.pop();
  //     max = Math.max(max, heights[p] * (ascStack.length === 0 ? i : i - p));
  //   }
  //   ascStack.push(i);
  // }
  // return max;
  // 相关题目： 雨水收集
  // 直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高
};
```

# 88.合并两个有序数组

```js
/*
 * @lc app=leetcode.cn id=88 lang=javascript
 *
 * [88] 合并两个有序数组
 */
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge1 = function(nums1, m, nums2, n) {
  const tmp1 = nums1.slice(0, m),
    tmp2 = nums2.slice(0, n);
  const arr = [...tmp1, ...nums2];
  quick(arr);

  for (let i = 0; i < arr.length; i++) {
    nums1[i] = arr[i];
  }
  return arr;
};

function quick(arr, start = 0, end = arr.length - 1) {
  if (arr && arr.length < 2) return arr;
  if (start >= end) return;
  let target = arr[start],
    i = start,
    j = end;

  while (i < j) {
    while (target <= arr[j] && i < j) j--;
    while (target >= arr[i] && i < j) i++;

    if (i < j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i], arr[start]] = [arr[start], arr[i]];
  quick(arr, start, i - 1);
  quick(arr, i + 1, end);
  return arr;
}

// console.log(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3))
// console.log(quick([1, 3, 4, 6, 1, 7, 9, 0, 2, 3]))

// 使用双指针方法
var merge = function(nums1, m, nums2, n) {
  let index1 = m - 1,
    index2 = n - 1,
    mergeIndex = m + n - 1;
  while (index1 >= 0 || index2 >= 0) {
    if (index1 < 0) {
      nums1[mergeIndex--] = nums2[index2--];
    } else if (index2 < 0) {
      nums1[mergeIndex--] = nums1[index1--];
    } else if (nums1[index1] > nums2[index2]) {
      nums1[mergeIndex--] = nums1[index1--];
    } else {
      nums1[mergeIndex--] = nums2[index2--];
    }
  }
  return nums1;
};
// console.log(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3))
```

# 89.格雷编码

```js
/*
 * @lc app=leetcode.cn id=89 lang=javascript
 *
 * [89] 格雷编码
 */
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
  // parseInt 2 进制转 10 进制
  return make(n).map(item => parseInt(item, 2));
};

// 23% 16%
const make = n => {
  if (n === 0) {
    return ['0'];
  } else if (n === 1) {
    return ['0', '1'];
  } else {
    let prev = make(n - 1);
    const max = Math.pow(2, n) - 1;
    let result = [];
    for (let i = 0; i < prev.length; i++) {
      // 取对称
      result[i] = `0${prev[i]}`;
      result[max - i] = `1${prev[i]}`;
    }
    return result;
  }
};

const getValue = str => {
  let result = 0;
  for (let i = str.length - 1, j = 0; i >= 0; i--) {
    if (str[i] == 1) {
      result += Math.pow(2, j);
    }
    j++;
  }
  return result;
};

// 除了第一列取反，其他列都是上下对称
// n = 1
// 0
// ====
// 1

// n = 2
// 0 0
// 0 1
// ====
// 1 1
// 1 0

// n = 3
// 0 0 0
// 0 0 1
// 0 1 1
// 0 1 0
// =====
// 1 1 0
// 1 1 1
// 1 0 1
// 1 0 0

// 最佳解
// TODO: 各种位运算 https://www.cnblogs.com/dongsheng/articles/2665305.html
var newGrayCode = function(n) {
  if (n === 0) return [0];
  const res = grayCode(n - 1);
  // 左移 n - 1
  const mask = 1 << (n - 1);
  for (let i = res.length - 1; i >= 0; i--) {
    // 或操作
    res.push(res[i] | mask);
  }
  return res;
};

// console.log(grayCode(0))
// console.log(grayCode(1))
// console.log(grayCode(2))
```

# 93.restore-ip-addresses

```js
/*
 * @lc app=leetcode id=93 lang=javascript
 *
 * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
 * 示例:
 * 输入: "25525511135"
 * 输出: ["255.255.11.135", "255.255.111.35"]
 * [93] Restore IP Addresses
 */
// TODO: 回溯算法 string | backtracking
function backtrack(list, tempList, s, start) {
  if (tempList.length === 4 && tempList.join('') === s && !list.includes(tempList.join('.'))) {
    list.push(tempList.join('.'));
  }
  if (tempList.length > 4) return;

  for (let i = start; i < s.length; i++) {
    for (let j = 0; j < 3; j++) {
      const r = s.slice(i, i + j + 1);
      if (+r > 255) continue;
      if (r[0] === '0' && r.length > 1) continue;
      tempList.push(r);
      backtrack(list, tempList, s, i + j + 1);
      tempList.pop();
    }
  }
}
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  // Given "25525511135",
  // return ["255.255.11.135", "255.255.111.35"].
  if (s.length > 3 * 4) return [];
  const list = [];
  backtrack(list, [], s, 0);
  return list;
};

console.log(restoreIpAddresses('25525511135'));
```

# 93.复原 ip 地址

```js
/*
 * @lc app=leetcode.cn id=93 lang=javascript
 *
 * [93] 复原IP地址
 */
/**
 * @param {string} s
 * @return {string[]}
 */
// 递归思想
// ip 字段中 255 是最大情况 0 ~ 255
// 3 个点，分为 4 个字段
var restoreIpAddresses = function(s) {
  if (s.length > 12 || str.length < 4) return [];

  const resp = [];
};

function cut(str, n) {
  if (str.length <= n * 4 && str.length >= n) {
    const result = [];
    const resp0 = cut(str.slice(1), n - 1);
    const resp1 = cut(str.slice(2), n - 2);
    let resp2;
    if (str.slice(0, 3) - 0 <= 255) {
      resp2 = cut(str.slice(3), n - 3);
    }
    if (resp0) {
    }
  }

  return [...[str[0]], ...[str.slice(0, 2), cut(str.slice(2), 3)], ...[str.slice(0, 3), cut(str.slice(3), 3)]];
}
```

# 94.二叉树的中序遍历

```js
/*
 * @lc app=leetcode.cn id=94 lang=javascript
 *
 * [94] 二叉树的中序遍历
 * 给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
// 中序： 左 -> 中 -> 右
// 前序： 中 -> 左 -> 右
// 后序： 左 -> 右 -> 中
// 迭代
var inorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根
  while (root || stack.length) {
    if (root) {
      stack.push(root);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};

// 递归
const res = [];
var inorderTraversal1 = function(root) {
  inorderTraversal1(root.left);
  res.push(root);
  inorderTraversal1(root.right);
  return res;
};
```

# Q10

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  let dp = [];
  for (let i = 0; i <= s.length; i++) {
    let child = [];
    for (let j = 0; j <= p.length; j++) {
      child.push(false);
    }
    dp.push(child);
  }
  dp[s.length][p.length] = true;

  for (let i = s.length; i >= 0; i--) {
    for (let j = p.length - 1; j >= 0; j--) {
      let first_match = i < s.length && (p[j] == s[i] || p[j] == '.');
      if (j + 1 < p.length && p[j + 1] == '*') {
        dp[i][j] = dp[i][j + 2] || (first_match && dp[i + 1][j]);
      } else {
        dp[i][j] = first_match && dp[i + 1][j + 1];
      }
    }
  }
  console.log(dp);
  return dp[0][0];
};

console.log(isMatch('aab', 'c*a*b'));

/**
先设定右下角为 false

[
    true, false, true, false, false, false,
    true, false, true, false, false, false,
    true, false, true, false, true, false,
    false, false, false, false, false, true
]
 */
```

# Q11

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  let maxArea = 0;
  let left = 0,
    right = height.length - 1;
  while (left < right) {
    maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return maxArea;
};

const arr = [3, 4, 6, 2, 8, 4, 3, 1, 3, 4, 4];
console.log(maxArea(arr));
```

# Q12

```js
/**
 * @param {number} num (1-3999)
 * @return {string}
 */
var intToRoman = function(num) {
  let ans = '';
  while (num >= 1000) {
    num -= 1000;
    ans += 'M';
  }
  while (num >= 500) {
    num -= 500;
    ans += 'D';
  }
  while (num >= 100) {
    num -= 100;
    ans += 'C';
  }
  while (num >= 50) {
    num -= 50;
    ans += 'L';
  }
  while (num >= 10) {
    num -= 10;
    ans += 'X';
  }
  while (num >= 5) {
    num -= 5;
    ans += 'V';
  }
  while (num >= 1) {
    num -= 1;
    ans += 'I';
  }

  ans = ans.replace('DCCCC', 'CM');
  ans = ans.replace('CCCC', 'CD');
  ans = ans.replace('LXXXX', 'XC');
  ans = ans.replace('XXXX', 'XL');
  ans = ans.replace('VIIII', 'IX');
  ans = ans.replace('IIII', 'IV');
  return ans;
};

console.log(intToRoman(58));
console.log(intToRoman(3));
console.log(intToRoman(4));
console.log(intToRoman(1994));
```

# Q13

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
  let num = 0;
  if (s.includes('IV')) num -= 2;
  if (s.includes('IX')) num -= 2;
  if (s.includes('XL')) num -= 20;
  if (s.includes('XC')) num -= 20;
  if (s.includes('CD')) num -= 200;
  if (s.includes('CM')) num -= 200;

  for (let c of s) {
    switch (c) {
      case 'I':
        num += 1;
        break;
      case 'V':
        num += 5;
        break;
      case 'X':
        num += 10;
        break;
      case 'L':
        num += 50;
        break;
      case 'C':
        num += 100;
        break;
      case 'D':
        num += 500;
        break;
      case 'M':
        num += 1000;
        break;
    }
  }
  return num;
};
```

# Q14

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
  let ans = strs.length > 0 ? strs[0] : '';
  for (let i = 1; i < strs.length; i++) {
    if (!strs[i].startsWith(ans)) {
      for (let j = 0; j < ans.length; j++) {
        if (ans[j] != strs[i][j]) {
          ans = ans.slice(0, j);
        }
      }
    }
  }
  return ans;
};
```

# Q15

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const sum = nums[i] + nums[j];
      const bs = binarySearch(nums, -sum, 0, nums.length - 1);
      if (bs != null && bs != i && bs != j) {
        let mArr = [nums[i], nums[j], nums[bs]].sort(function(a, b) {
          return a - b;
        });
        if (!has(ans, mArr)) {
          ans.push(mArr);
        }
      }
    }
  }
  return ans;
};

function binarySearch(arr, val, lo, hi) {
  if (lo > hi) return null;
  let mid = lo + parseInt((hi - lo) / 2);
  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

function has(arr, target) {
  for (let cur of arr) {
    let isEqual = true;
    for (let i = 0; i < target.length; i++) {
      if (cur[i] != target[i]) {
        isEqual = false;
      }
    }
    if (isEqual) return true;
  }
  return false;
}

// console.log(threeSum([-1, 0, 1, 2, -1, -4]))

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum2 = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) {
      continue;
    }
    let j = i + 1,
      k = nums.length - 1;
    let target = -nums[i];
    while (j < k) {
      if (nums[j] + nums[k] == target) {
        ans.push([nums[i], nums[j], nums[k]]);
        j++;
        k--;
        while (j < k && nums[j] == nums[j - 1]) j++;
        while (j < k && nums[k] == nums[k + 1]) k--;
      } else if (nums[j] + nums[k] > target) {
        k--;
      } else {
        j++;
      }
    }
  }
  return ans;
};

console.log(threeSum2([-2, 0, 0, 2, 2]));
```

# Q16

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let minDiff = nums[nums.length - 1] - nums[0];
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const sum = nums[i] + nums[j] - target;
      const bs = binarySearch(nums, -sum, 0, nums.length - 1);

      if (bs != i && bs != j) {
        if (sum - nums[bs] < minDiff) {
          minDiff = sum - nums[bs];
        }
      }
    }
  }
  return minDiff;
};

function binarySearch(arr, val, lo, hi) {
  if (hi - lo == 1) {
    if (arr[hi] - val > val - arr[lo]) {
      return lo;
    } else {
      return hi;
    }
  }
  let mid = lo + parseInt((hi - lo) / 2);
  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

const nums = [-1, 2, 1, -4];
threeSumClosest(nums, 1);
```

# Q17

```js
// var letterCombinations = function (digits) {
//     var map = {
//         "2": ["a", "b", "c"],
//         "3": ["d", "e", "f"],
//         "4": ["g", "h", "i"],
//         "5": ["j", "k", "l"],
//         "6": ["m", "n", "o"],
//         "7": ["p", "q", "r", "s"],
//         "8": ["t", "u", "v"],
//         "9": ["w", "x", "y", "z"]
//     };
//     // 第一个字符
//     var rtn = map[digits[0]];
//     digits = digits.substr(1);
//     // 遍历字符
//     digits.split("").forEach(function (digit) {
//         var t = [];
//         // 遍历相对符号
//         map[digit].forEach(function (letter) {
//             t = t.concat(rtn.map(function (item) {
//                 // 合并
//                 return item + letter;
//             }));
//         });
//         rtn = t;
//     });
//     return rtn === undefined ? [] : rtn;
// };

/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  var map = {
    '2': ['a', 'b', 'c'],
    '3': ['d', 'e', 'f'],
    '4': ['g', 'h', 'i'],
    '5': ['j', 'k', 'l'],
    '6': ['m', 'n', 'o'],
    '7': ['p', 'q', 'r', 's'],
    '8': ['t', 'u', 'v'],
    '9': ['w', 'x', 'y', 'z'],
  };
  var ans = map[digits[0]];
  digits = digits.substring(1);
  digits.split('').forEach(function(digit) {
    var arr = [];
    map[digit].forEach(function(letter) {
      arr = arr.concat(
        ans.map(function(item) {
          return item + letter;
        }),
      );
    });
    ans = arr;
  });
  return ans ? [] : ans;
};

console.log(letterCombinations('23'));
```

# Q19

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let dummy = new ListNode(0);
  dummy.next = head;
  let first = dummy;
  let second = dummy;
  for (let i = 1; i <= n + 1; i++) {
    first = first.next;
  }
  while (first != null) {
    first = first.next;
    second = second.next;
  }
  second.next = second.next.next;
  return dummy.next;
};

// if (head.next == null) return null
// let fast = head.next, slow = head
// let i = 1
// while (i < n) {
//     if (fast.next) {
//         fast = fast.next
//     }
//     i++
// }
// if (fast.next) {
//     if (fast.next.next) fast.next = fast.next.next
//     else fast.next = null
// }
// return head
```

# Q2

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  let head = new ListNode(0);
  let cur = head;
  let curry = 0;

  while (true) {
    let sum = curry;
    sum += l1 ? l1.val : 0;
    sum += l2 ? l2.val : 0;
    cur.val = sum % 10;
    curry = parseInt(sum / 10);
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
    if (l1 != null || l2 != null) {
      cur.next = new ListNode(0);
      cur = cur.next;
    } else {
      break;
    }
  }
  if (curry != 0) {
    cur.next = new ListNode(0);
    cur = cur.next;
    cur.val = curry;
  }
  return head;
};

var l1 = new ListNode(1);
l1.next = new ListNode(8);

var l2 = new ListNode(0);

console.log(addTwoNumbers(l1, l2));
```

# Q20

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  let stack = [];
  for (let c of s) {
    if (c == '(') stack.push(')');
    else if (c == '[') stack.push(']');
    else if (c == '{') stack.push('}');
    else {
      if (stack.length == 0) return false;
      if (stack.pop() != c) return false;
    }
  }
  return stack.length == 0;
};
```

# Q21

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

# Q22

```js
let result = [];

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  dfs(n, 1, 1, '(');
  return result;
};

function dfs(n, sum, used, s) {
  if (s.length == 2 * n) {
    result.push(s);
    return;
  }
  if (sum == 0) {
    dfs(n, sum + 1, used + 1, s + '(');
  } else if (sum == n || used == n) {
    dfs(n, sum - 1, used, s + ')');
  } else {
    dfs(n, sum + 1, used + 1, s + '(');
    dfs(n, sum - 1, used, s + ')');
  }
}

generateParenthesis(3);
```

# Q23

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  return partion(lists, 0, list.length - 1);
};

function partion(lists, s, e) {
  // 开始 == 结束，说明合并完成。
  if (s == e) return lists[s];
  if (s < e) {
    // 分一半计算
    let q = parseInt((s + e) / 2);
    // 前半部分
    let l1 = partion(lists, s, q);
    // 后半部分
    let l2 = partion(lists, q + 1, e);
    // 合并两个链表
    return merge(l1, l2);
  } else return null;
}

function mergeTwoLists(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

# Q26

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  if (nums.length <= 1) return nums.length;
  let cur = nums[0];
  let index = 1;
  while (index < nums.length) {
    if (cur != nums[index]) {
      cur = nums[index];
      index++;
    } else {
      nums.splice(index, 1);
    }
  }
  return nums.length;
};

console.log(removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]));
```

# Q28

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
  const slen = haystack.length;
  const plen = needle.length;
  if (slen == plen) {
    return haystack == needle ? 0 : -1;
  }
  for (let i = 0; i <= slen - plen; i++) {
    let j;
    for (j = 0; j < plen; j++) {
      if (haystack[i + j] != needle[j]) {
        break;
      }
    }
    if (j == plen) return i;
  }
  return -1;
};

console.log(strStr('mississippi', 'pi'));
```

# Q29

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
  let sign = 1;
  if (dividend < 0) {
    sign = -sign;
    dividend = -dividend;
  }
  if (divisor < 0) {
    sign = -sign;
    divisor = -divisor;
  }

  if (divisor == 0 || dividend < divisor) return 0;

  num = sign * ldivide(dividend, divisor);

  let max = 1;
  for (let i = 0; i < 31; i++) {
    max *= 2;
  }
  if (num > max - 1) return max - 1;
  if (num < -max) return -max;
  return num;
};

function ldivide(dividend, divisor) {
  if (dividend < divisor) return 0;
  let sum = divisor;
  let num = 1;
  while (sum + sum <= dividend) {
    sum += sum;
    num += num;
  }
  return num + ldivide(dividend - sum, divisor);
}

console.log(divide(-1, 1));

1;
```

# Q3

```js
var lengthOfLongestSubstring = function(s) {
  var start = 0; // 非重复字符串开始索引
  var max = 0; // 最长字符串长度
  var visitedCharByPosition = {};

  for (var position = 0; position < s.length; position++) {
    var nextChar = s[position];
    if (nextChar in visitedCharByPosition && visitedCharByPosition[nextChar] >= start) {
      // 有重复，非重复字符串索引从下一个 index 开始
      start = visitedCharByPosition[nextChar] + 1;
      visitedCharByPosition[nextChar] = position;
    } else {
      visitedCharByPosition[nextChar] = position;
      // 非重复，求非重复值
      max = Math.max(max, position + 1 - start);
    }
  }
  return max;
};

console.log(lengthOfLongestSubstring('au'));
```

# Q33

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == target) {
      return i;
    }
  }
  return -1;
};
```

# Q34

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  let targetIndex = binarySearch(nums, target, 0, nums.length - 1);
  if (targetIndex == -1) return [-1, -1];
  let l = targetIndex,
    r = targetIndex;
  while (l > 0 && nums[l - 1] == target) {
    l--;
  }
  while (r < nums.length - 1 && nums[r + 1] == target) {
    r++;
  }
  return [l, r];
};

function binarySearch(arr, val, lo, hi) {
  if (hi < lo) return -1;
  let mid = lo + parseInt((hi - lo) / 2);

  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

let nums = [5, 7, 7, 8, 8, 10],
  target = 9;
searchRange(nums, target);
```

# Q36

```js
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  const M = board.length,
    N = board[0].length;
  for (let i = 0; i < M; i++) {
    let row = new Set();
    let col = new Set();
    let rect = new Set();
    for (let j = 0; j < N; j++) {
      if (board[i][j] != '.' && row.has(board[i][j])) {
        return false;
      } else {
        row.add(board[i][j]);
      }

      if (board[j][i] != '.' && col.has(board[j][i])) {
        return false;
      } else {
        col.add(board[j][i]);
      }

      let RowIndex = 3 * parseInt(i / 3) + parseInt(j / 3);
      let ColIndex = 3 * (i % 3) + (j % 3);
      console.log(RowIndex + '-' + ColIndex);
      const item = board[RowIndex][ColIndex];
      if (item != '.' && rect.has(item)) {
        return false;
      } else {
        rect.add(item);
      }
    }
  }
  return true;
};

let board = [
  ['5', '3', '.', '.', '7', '.', '.', '.', '.'],
  ['6', '.', '.', '1', '9', '5', '.', '.', '.'],
  ['.', '9', '8', '.', '.', '.', '.', '6', '.'],
  ['8', '.', '.', '.', '6', '.', '.', '.', '3'],
  ['4', '.', '.', '8', '.', '3', '.', '.', '1'],
  ['7', '.', '.', '.', '2', '.', '.', '.', '6'],
  ['.', '6', '.', '.', '.', '.', '2', '8', '.'],
  ['.', '.', '.', '4', '1', '9', '.', '.', '5'],
  ['.', '.', '.', '.', '8', '.', '.', '7', '9'],
];

isValidSudoku(board);
```

# Q38

```js
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
  let ans = '1';
  let i = 1;
  while (i < n) {
    ans = say(ans);
    i++;
  }
  return ans;
};

function say(s) {
  let curChar = s[0];
  let curCount = 1;
  let ans = '';
  for (let i = 1; i < s.length; i++) {
    if (s[i] == curChar) {
      curCount++;
    } else {
      ans += curCount + curChar;
      curChar = s[i];
      curCount = 1;
    }
  }
  ans += curCount + curChar;
  return ans;
}

console.log(countAndSay(1));
console.log(countAndSay(2));
console.log(countAndSay(3));
console.log(countAndSay(4));
```

# Q4

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}  012345
 */
var findMedianSortedArrays = function(nums1, nums2) {
  if (nums1.length == 0 || nums2.length == 0) {
    if ((nums1.length + nums2.length) % 2 == 1) {
      const index = parseInt((nums1.length + nums2.length) / 2);
      return nums2.length == 0 ? nums1[index] : nums2[index];
    } else {
      let nums = nums2.length == 0 ? nums1 : nums2;
      const index = nums.length / 2;
      return (nums[index - 1] + nums[index]) / 2;
    }
  }

  if (nums1.length > nums2.length) {
    swap(nums1, nums2);
  }
  const M = nums1.length,
    N = nums2.length;
  let min = 0,
    max = M,
    half = parseInt((M + N + 1) / 2); // 连个数组合并的中间值
  while (min <= max) {
    let i = parseInt((min + max) / 2); // nums1 的索引值
    let j = half - i; // num2 的索引值
    if (i < max && nums2[j - 1] > nums1[i]) {
      min++;
    } else if (i > min && nums1[i - 1] > nums2[j]) {
      max--;
    } else {
      let maxLeft = 0;
      if (i == 0) {
        maxLeft = nums2[j - 1];
      } else if (j == 0) {
        maxLeft = nums1[i - 1];
      } else {
        maxLeft = Math.max(nums1[i - 1], nums2[j - 1]);
      }
      if ((M + N) % 2 == 1) {
        return maxLeft;
      }
      let minRight = 0;
      if (i == M) {
        minRight = nums2[j];
      } else if (j == N) {
        minRight = nums1[i];
      } else {
        minRight = Math.min(nums1[i], nums2[j]);
      }
      return (maxLeft + minRight) / 2;
    }
  }
  return 0;
};

function swap(a, b) {
  let tmp = a;
  a = b;
  b = tmp;
}

const nums1 = [4, 5];
const nums2 = [1, 2, 3];
findMedianSortedArrays(nums1, nums2);

/**
 * 实现思路
 * 先排除空数组的情况
 * 数组从小到大排序
 * 取小数组的中间值
 * 取大数组的索引 = 总中间值-小数组中间值
 * 循环直到符合条件
 * 如果都不符合条件，那么说明中间值在两个数组的左边或者右边
 */
```

# Q41

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let index = 0;
  let val = 0;
  while (index < nums.length) {
    if (nums[index] <= 0) {
      index++;
      continue;
    }
    if (nums[index] == val + 1) {
      val = val + 1;
    }
    if (nums[index] != val) {
      return val + 1;
    }
    index++;
  }
  return nums.length > 0 ? nums[nums.length - 1] + 1 : 1;
};

console.log(firstMissingPositive([3, 4, -1, 1]));
```

# Q42

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  let left = 0,
    right = height.length - 1;
  let count = 0;
  let leftMax = 0,
    rightMax = 0;
  while (left <= right) {
    leftMax = Math.max(leftMax, height[left]);
    rightMax = Math.max(rightMax, height[right]);
    if (leftMax < rightMax) {
      count += leftMax - height[left];
      left++;
    } else {
      count += rightMax - height[right];
      right--;
    }
  }
  return count;
};
```

# Q44

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  // 构造 dp 函数
  let dp = [];
  for (let i = 0; i <= s.length; i++) {
    let child = [];
    for (let j = 0; j <= p.length; j++) {
      child.push(false);
    }
    dp.push(child);
  }
  dp[s.length][p.length] = true;
  // 执行
  for (let i = p.length - 1; i >= 0; i--) {
    if (p[i] != '*') break;
    else dp[s.length][i] = true;
  }

  for (let i = s.length - 1; i >= 0; i--) {
    for (let j = p.length - 1; j >= 0; j--) {
      if (s[i] == p[j] || p[j] == '?') {
        dp[i][j] = dp[i + 1][j + 1];
      } else if (p[j] == '*') {
        console.log(dp[i + 1][j]);
        console.log(dp[i][j + 1]);
        dp[i][j] = dp[i + 1][j] || dp[i][j + 1];
      } else {
        dp[i][j] = false;
      }
    }
  }
  return dp[0][0];
};

isMatch('aa', '*');
```

# Q46

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  result = [];
  nums.sort(function(a, b) {
    return a - b;
  });
  find(nums, []);
  return result;
};

let result = [];

function find(nums, templateList) {
  if (nums.length == 0) {
    result.push(templateList.slice());
  }
  for (let i = 0; i < nums.length; i++) {
    templateList.push(nums[i]);
    let copy = nums.slice();
    copy.splice(i, 1);
    find(copy, templateList);
    templateList.pop();
  }
}

permute([1, 2, 3]);
```

# Q48

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  matrix.reverse();
  for (let i = 0; i < matrix.length; i++) {
    for (let j = i + 1; j < matrix[0].length; j++) {
      let tmp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = tmp;
    }
  }
};

rotate([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);
```

# Q49

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  const a = 'a'.charCodeAt();
  let map = new Map();
  for (let i = 0; i < strs.length; i++) {
    let charArr = createArr();
    for (let j = 0; j < strs[i].length; j++) charArr[strs[i].charCodeAt(j) - a]++;
    let key = charArr.join('');
    if (map.has(key)) {
      map.get(key).push(strs[i]);
    } else {
      map.set(key, [strs[i]]);
    }
  }
  const ans = [];
  for (let value of map.values()) {
    ans.push(value);
  }
  return ans;
};

function createArr() {
  let i = 0;
  let arr = [];
  while (i < 26) {
    arr.push(0);
    i++;
  }
  return arr;
}

groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']);
```

# Q5

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  let maxLength = 0,
    left = 0,
    right = 0;
  for (let i = 0; i < s.length; i++) {
    let singleCharLength = getPalLenByCenterChar(s, i, i);
    let doubleCharLength = getPalLenByCenterChar(s, i, i + 1);
    let max = Math.max(singleCharLength, doubleCharLength);
    if (max > maxLength) {
      maxLength = max;
      left = i - parseInt((max - 1) / 2);
      right = i + parseInt(max / 2);
    }
  }
  return s.slice(left, right + 1);
};

function getPalLenByCenterChar(s, left, right) {
  // 中间值为两个字符，确保两个字符相等
  if (s[left] != s[right]) {
    return right - left; // 不相等返回为1个字符串
  }
  while (left > 0 && right < s.length - 1) {
    // 先加减再判断
    left--;
    right++;
    if (s[left] != s[right]) {
      return right - left - 1;
    }
  }
  return right - left + 1;
}

console.log(longestPalindrome('cbbd'));
```

# Q50

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (n == 0) return 1;
  if (n < 0) {
    n = -n;
    x = 1 / x;
  }
  return n % 2 == 0 ? pow(x * x, parseInt(n / 2)) : x * pow(x * x, parseInt(n / 2));
};
```

# Q53

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let count = nums[0],
    maxCount = nums[0];
  for (let i = 1; i < nums.length; i++) {
    count = Math.max(count + nums[i], nums[i]);
    maxCount = Math.max(maxCount, count);
  }
  return maxCount;
};

console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

# Q54

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  if (matrix.length == 0) return [];
  let ans = [];
  ans.push(matrix[0][0]);
  matrix[0][0] = null;

  let i = 0,
    j = 0;
  const width = matrix[0].length,
    height = matrix.length;
  let status = 'right';
  let count = 0;
  while (count < width * height - 1) {
    if (status == 'right') {
      if (j < width - 1 && matrix[i][j + 1] != null) {
        ans.push(matrix[i][j + 1]);
        matrix[i][j + 1] = null;
        j++;
        count++;
      } else {
        status = 'down';
      }
    } else if (status == 'down') {
      if (i < height - 1 && matrix[i + 1][j] != null) {
        ans.push(matrix[i + 1][j]);
        matrix[i + 1][j] = null;
        i++;
        count++;
      } else {
        status = 'left';
      }
    } else if (status == 'left') {
      if (j > 0 && matrix[i][j - 1] != null) {
        ans.push(matrix[i][j - 1]);
        matrix[i][j - 1] = null;
        j--;
        count++;
      } else {
        status = 'up';
      }
    } else {
      if (i > 0 && matrix[i - 1][j] != null) {
        ans.push(matrix[i - 1][j]);
        matrix[i - 1][j] = null;
        i--;
        count++;
      } else {
        status = 'right';
      }
    }
  }
  return ans;
};

/**
 * TOOD 本方案思路是对的，就是写的非常之不优雅，需要改进。
 */
```

# Q55

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let i = nums.length - 2,
    len = nums.length - 1;
  while (i > 0) {
    if (nums[i] >= len - i) {
      len = i;
    }
    i--;
  }
  return nums[0] >= len;
};

/**
 * 从后往前找更佳
 */
```

# Q56

```js
/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {Interval[]}
 */
var merge = function(intervals) {
  if (intervals.length == 0) return [];
  intervals.sort((a, b) => {
    return a.start - b.start;
  });

  let ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    if (intervals[i].end >= intervals[i + 1].start) {
      intervals[i + 1].start = Math.min(intervals[i].start, intervals[i + 1].start);
      intervals[i + 1].end = Math.max(intervals[i].end, intervals[i + 1].end);
    } else {
      ans.push(intervals[i]);
    }
  }
  ans.push(intervals[intervals.length - 1]);
  return ans;
};
```

# Q6

```js
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  if (numRows == 1) return s;
  let arr = new Array(numRows);
  for (let i = 0; i < numRows; i++) arr[i] = [];
  let index = 0,
    len = s.length,
    mi = 0,
    isDown = true;
  while (index < len) {
    arr[mi].push(s[index]);
    index++;

    if (mi >= numRows - 1) isDown = false;
    else if (mi <= 0) isDown = true;

    if (isDown) mi++;
    else mi--;
  }
  let ans = [];
  for (let item of arr) {
    ans = ans.concat(item);
  }
  return ans.join('');
};

const s = 'AB',
  numRows = 1;

console.log(convert(s, numRows));
```

# Q62

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const pos = new Array(m);
  for (let i = 0; i < m; i++) {
    pos[i] = new Array(n);
  }
  for (let i = 0; i < n; i++) {
    pos[0][i] = 1;
  }
  for (let i = 0; i < m; i++) {
    pos[i][0] = 1;
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      pos[i][j] = pos[i - 1][j] + pos[i][j - 1];
    }
  }
  return pos[m - 1][n - 1];
};

uniquePaths(3, 7);

/**
0  1  1  1  1  1  1
1  2  3  4  5  6  7
1  3  6  10 15 21 28
 */
```

# Q66

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  for (let i = digits.length - 1; i >= 0; i--) {
    if (digits[i] < 9) {
      digits[i]++;
      break;
    } else {
      digits[i] = 0;
    }
  }
  if (digits[0] == 0) {
    digits.unshift(1);
  }
  return digits;
};

console.log([1, 2, 3]);
```

# Q69

```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
  let l = 0,
    r = x;
  while (true) {
    let mid = parseInt(l + (r - l) / 2);
    if (mid * mid > x) {
      r = mid - 1;
    } else if (mid * mid < x) {
      if ((mid + 1) * (mid + 1) > x) {
        return mid;
      }
      l = mid + 1;
    } else {
      return mid;
    }
  }
};
```

# Q7

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  const s = x + '';
  let i = 0;
  let sign = 1;
  if (s[i] == '-') {
    i++;
    sign = -1;
  }
  if (s[i] == '+') {
    i++;
  }
  let num = 0;
  for (let j = s.length - 1; j >= i; j--) {
    num = num * 10 + parseInt(s[j]);
  }
  num *= sign;
  let max = 2;
  for (let n = 0; n < 30; n++) {
    max *= 2;
  }
  if (num > max || num < -max) {
    return 0;
  }
  return num;
};

console.log(reverse(1563847412));
```

# Q70

```js
// let count = 0

// /**
//  * @param {number} n
//  * @return {number}
//  */
// var climbStairs = function (n) {
//     count = 0
//     find(0, n)
//     return count
// };

// function find(step, n) {
//     if (step == n) {
//         count++
//         return
//     }
//     find(step + 1, n)
//     if (step + 2 <= n) {
//         find(step + 2, n)
//     }
// }

var climbStairs = function(n) {
  let dp = new Array(n);
  dp[0] = 1;
  dp[1] = 2;
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n - 1];
};
```

# Q73

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
  const rows = matrix.length,
    cols = matrix[0].length;
  let col0 = 1;
  for (let i = 0; i < rows; i++) {
    if (matrix[i][0] == 0) col0 = 0;
    for (let j = 1; j < cols; j++) {
      if (matrix[i][j] == 0) {
        matrix[0][j] = 0;
        matrix[i][0] = 0;
      }
    }
  }
  for (let i = rows - 1; i >= 0; i--) {
    for (let j = cols - 1; j >= 1; j--) {
      if (matrix[0][j] == 0 || matrix[i][0] == 0) {
        matrix[i][j] = 0;
      }
    }
    if (col0 == 0) {
      matrix[i][0] = 0;
    }
  }
};

console.log(
  setZeroes([
    [0, 1, 2, 0],
    [3, 4, 5, 2],
    [1, 3, 1, 5],
  ]),
);
```

# Q75

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
  sort(nums, 0, nums.length - 1);
};

function sort(arr, lo, hi) {
  if (hi <= lo) return;
  let lt = lo,
    i = lo + 1,
    gt = hi;
  let v = arr[lo];
  while (i <= gt) {
    if (arr[i] < v) swap(arr, lt++, i++);
    else if (arr[i] > v) swap(arr, i, gt--);
    else i++;
  }
  sort(arr, lo, lt - 1);
  sort(arr, gt + 1, hi);
}

function swap(arr, a, b) {
  let x = arr[a];
  arr[a] = arr[b];
  arr[b] = x;
}

/**
 * 三向字符串快速排序
 */
```

# Q76

```js
function minWindow(s, t) {
  var ans = '';

  // 1. process hashmap
  var map = {};
  t.split('').forEach(ch => (map[ch] = (map[ch] || 0) + 1));
  var count = Object.keys(map).length;

  // 2. traverse s to find boundaries
  // both l & r are inclusive
  var l = 0;
  var r = -1;

  while (r < s.length) {
    if (count === 0) {
      // good condition
      // l~r contains t

      // update ans
      if (!ans || r - l + 1 < ans.length) {
        ans = s.slice(l, r + 1);
      }

      // get rid of curr ch and then move l
      if (map[s[l]] !== undefined) {
        map[s[l]]++;
      }
      if (map[s[l]] > 0) {
        count++;
      }
      l++;
    } else {
      // bad condition
      // l~r doesn't contain t

      // move r and add new ch
      r++;
      if (map[s[r]] !== undefined) {
        map[s[r]]--;
      }
      if (map[s[r]] === 0) {
        count--;
      }
    }
  }
  return ans;
}
```

# Q78

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  let list = [];
  nums.sort();
  backtrack(list, new Array(), nums, 0);
  return list;
};

function backtrack(list, tempList, nums, start) {
  list.push(tempList.slice());
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}

subsets([1, 2, 3]);

/**
 *
 * 1
 * 1 2
 * 1 2 3
 * 1 3
 * 2
 * 2 3
 * 3
 */
```

# Q79

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  for (let y = 0; y < board.length; y++) {
    for (let x = 0; x < board[0].length; x++) {
      if (find(board, word, y, x, 0)) return true;
    }
  }
  return false;
};

function find(board, word, y, x, d) {
  if (d == word.length) return true;
  if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false;
  if (board[y][x] != word[d]) return false;
  let tmp = board[y][x];
  board[y][x] = '*';
  let exist =
    find(board, word, y, x + 1, d + 1) ||
    find(board, word, y, x - 1, d + 1) ||
    find(board, word, y + 1, x, d + 1) ||
    find(board, word, y - 1, x, d + 1);
  board[y][x] = tmp;
  return exist;
}

exist(
  [
    ['C', 'A', 'A'],
    ['A', 'A', 'A'],
    ['B', 'C', 'D'],
  ],
  'AAB',
);

//     // board 二维数组，word 查找的单词
//     public boolean exist(char[][] board, String word) {
//     char[] w = word.toCharArray();// 转为字符数组
//     for (int y = 0; y < board.length; y++) {
//         for (int x = 0; x < board[y].length; x++) {
//             // 遍历二维数组去求是否存在
//             if (exist(board, y, x, w, 0)) return true;
//         }
//     }
//     return false;
// }

//     // board 二位数组，第 x 列 第 y 行，查找的单词字符数组，i 是单词字符数组索引值
//     private boolean exist(char[][] board, int y, int x, char[] word, int i) {
//     if (i == word.length) return true; // 完全匹配，返回 true
//     if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false; // x、y超出矩阵边界，返回 false
//     if (board[y][x] != word[i]) return false; // 字符不匹配，返回 false
//     board[y][x] ^= 256; // 按位异或，先将当前字符转为另外的字符，避免获取重复数值
//     boolean exist = exist(board, y, x + 1, word, i + 1)
//         || exist(board, y, x - 1, word, i + 1)
//         || exist(board, y + 1, x, word, i + 1)
//         || exist(board, y - 1, x, word, i + 1);
//     board[y][x] ^= 256; // 恢复当前值
//     return exist;
// }
```

# Q8

```js
/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
  let i = 0;
  // 去除空格
  while (str[i] == ' ') i++;
  // 处理正负值
  let sign = 1;
  if (str[i] == '-' || str[i] == '+') {
    if (str[i] == '-') sign = -1;
    i++;
  }
  // 处理数字
  let num = 0;
  while (i < str.length) {
    if (str.charCodeAt(i) >= 48 && str.charCodeAt(i) <= 57) {
      num = num * 10 + parseInt(str[i]);
      i++;
    } else {
      break;
    }
  }
  num *= sign;
  // 处理 32 位最大最小值
  let max = 2;
  for (let n = 0; n < 30; n++) max *= 2;
  if (num >= max) return max - 1;
  if (num <= -max) return -max + 1;
  return num;
};

console.log(myAtoi('2147483648'));
```

# Q84

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  let maxArea = 0;
  for (let i = 0; i < heights.length; i++) {
    let l = i,
      r = i,
      height = heights[i];
    while (l > 0) {
      if (heights[l - 1] >= height) {
        l--;
      } else {
        break;
      }
    }
    while (r < heights.length - 1) {
      if (heights[r + 1] >= height) {
        r++;
      } else {
        break;
      }
    }
    maxArea = Math.max(maxArea, (r - l + 1) * height);
  }
  return maxArea;
};

largestRectangleArea([2, 1, 5, 6, 2, 3]);
```

# Q88

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
  let i = m - 1,
    j = n - 1,
    k = m + n - 1;
  while (i >= 0 && j >= 0) {
    if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--];
    else nums1[k--] = nums2[j--];
  }
  while (j >= 0) nums1[k--] = nums2[j--];
};
```

# Q9

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
  let str = x + '';
  let left = 0,
    right = str.length - 1;
  while (left < right) {
    if (str[left] != str[right]) return false;
    left++;
    right--;
  }
  return true;
};
```

# Q91

```js
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  let n = s.length;
  if (n == 0) return 0;
  let memo = new Array(n + 1);
  memo[n] = 1;
  memo[n - 1] = s[n - 1] != '0' ? 1 : 0;

  for (let i = n - 2; i >= 0; i--) {
    if (s[i] == '0') {
      memo[i] = 0;
    } else {
      memo[i] = parseInt(s.slice(i, i + 2)) <= 26 ? memo[i + 1] + memo[i + 2] : memo[i + 1];
    }
  }
  return memo[0];
};

console.log(numDecodings('12'));

// public class Solution {
//     public int numDecodings(String s) {
//         int n = s.length();
//         if (n == 0) return 0;
//         // 使用 memo 数组记录某个数字可以转码的总数
//         int[] memo = new int[n + 1];
//         memo[n] = 1;
//         memo[n - 1] = s.charAt(n - 1) != '0' ? 1 : 0; // 最后一个值为0，总数为0

//         for (int i = n - 2; i >= 0; i--)
//         if (s.charAt(i) == '0') continue; // 当前字符为0
//         // 当前总数为：如果两位数小于等于26，前一个字符的总数加上前两个字符的总数。否则返回前一个字符的总数
//         else memo[i] = (Integer.parseInt(s.substring(i, i + 2)) <= 26) ? memo[i + 1] + memo[i + 2] : memo[i + 1];
//         // 返回最终概率
//         return memo[0];
//     }
// }
```

# Q94

```js
let ans = [];

var inorderTraversal = function(root) {
  ans = [];
  helper(root);
  return ans;
};

function helper(node) {
  if (node == null) return;
  if (node.left) helper(node.left);
  ans.push(node.val);
  if (node.right) helper(node.right);
}
```

# Q98

```js
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let isValid = true;

var isValidBST = function(root) {
  if (root == null) return true;
  helper(root);
  return isValid;
};

function helper(node) {
  if (node == null) return;
  if (node.left != null) {
    if (node.left.val > node.val) {
      isValid = false;
      return;
    }
    helper(node.left);
  }
  if (node.right != null) {
    if (node.right.val < node.val) {
      isValid = false;
      return;
    }
    helper(node.right);
  }
}

const tree = new TreeNode(0);
console.log(isValidBST(tree));

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  return validate(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
};

const validate = (node, min, max) => {
  if (!node) {
    return true;
  }

  if (node.val < min || node.val > max) {
    return false;
  }

  return validate(node.left, min, node.val - 1) && validate(node.right, node.val + 1, max);
};
```
