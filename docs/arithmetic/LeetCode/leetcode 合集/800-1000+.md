---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### [832]. Flipping an Image

```js
// Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.

// To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].

// To invert an image means that each 0 is replaced by 1, and each 1 is replaced by [0]. For example, inverting [0, 1, 1] results in [1, 0, 0].

/**
 * @param {number[][]} A
 * @return {number[][]}
 */
export default function flipAndInvertImage(A) {
  // Take the transpose of the matrix
  for (let i = 0; i < A.length; i++) {
    // Flip each row
    for (let j = 0; j < Math.floor(A[i].length / 2); j++) {
      const a = A[i][j];
      const b = A[i][A[i].length - 1 - j];
      A[i][j] = b === 0 ? 1 : 0;
      A[i][A[i].length - 1 - j] = a === 0 ? 1 : 0;
    }
    if (A[i].length % 2 !== 0) {
      A[i][Math.floor(A[i].length / 2)] = A[i][Math.floor(A[i].length / 2)] === 0 ? 1 : 0;
    }
  }
  return A;
}
```

### [876].

```js
// This solution uses the 'runner method' mentioned in CTCI

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function middleNode(head) {
  if (!head) return null;
  let next = head;
  let nextNext = head;

  while (next.next && nextNext && nextNext.next && nextNext.next.next) {
    next = next.next;
    nextNext = nextNext.next.next;
  }

  if (nextNext.next) {
    return next.next;
  }

  return next;
}
```

### [905].按奇偶排序数组

```js
/*
 * @lc app=leetcode.cn id=905 lang=javascript
 *
 * [905] 按奇偶排序数组
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParity = function(nums) {
  // 好像不关排序的事情。。。。
  const result = [];
  let length = nums.length,
    start = 0,
    end = length - 1;
  for (let i = 0; i < length; i++) {
    if (nums[i] % 2 === 0) {
      result[start] = nums[i];
      start++;
    } else {
      result[end] = nums[i];
      end--;
    }
  }
  return result;
};

console.log(sortArrayByParity([4, 2, 5, 7]));
console.log(sortArrayByParity([3, 1, 2, 4]));
```

### [912].排序数组

```js
/*
 * @lc app=leetcode.cn id=912 lang=javascript
 *
 * [912] 排序数组
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
  if (nums.length < 2) return nums;
  return quickSort(nums);
};

const quickSort = (arr, start = 0, end = arr.length - 1) => {
  if (start >= end) return;
  let i = start,
    j = end,
    target = arr[start];

  while (i < j) {
    while (i < j && arr[j] >= target) j--;
    while (i < j && arr[i] <= target) i++;

    if (i < j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[start], arr[j]] = [arr[j], arr[start]];
  quickSort(arr, start, i - 1);
  quickSort(arr, i + 1, end);

  return arr;
};

console.log(sortArray([5, 2, 3, 1]));
console.log(sortArray([5, 1, 1, 2, 0, 0]));
```

### [914].卡牌分组

```js
/*
 * @lc app=leetcode.cn id=914 lang=javascript
 *
 * [914] 卡牌分组
 */
/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
  // 统计数字个数
  const numMap = {};
  for (let i = 0; i < deck.length; i++) {
    if (!numMap[deck[i]]) {
      numMap[deck[i]] = 1;
    } else {
      numMap[deck[i]]++;
    }
  }
  const valuesArr = Object.values(numMap).sort((a, b) => (a > b ? 1 : -1));
  // console.log('valuesArr', valuesArr)
  // 也就是说最大公约数得大于 1
  return !valuesArr.find(value => gcd(value, valuesArr[0]) === 1 || value < 2);
};

// 欧里几德算法，辗转相除法。
function gcd(a, b) {
  if (b == 0) {
    return a;
  }
  var r = parseInt(a % b);
  return gcd(b, r);
}

console.log(hasGroupsSizeX([1, 2, 3, 4, 4, 3, 2, 1]));
console.log(hasGroupsSizeX([1, 1, 1, 2, 2, 2, 3, 3]));
console.log(hasGroupsSizeX([1]));
console.log(hasGroupsSizeX([1, 1]));
console.log(hasGroupsSizeX([1, 1, 2, 2, 2, 2]));
console.log(hasGroupsSizeX([1, 1, 1, 1, 2, 2, 2, 2, 2, 2]));
```

### [917].仅仅反转字母

```js
/*
 * @lc app=leetcode.cn id=917 lang=javascript
 *
 * [917] 仅仅反转字母
 *
 * 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。



示例 1：

输入："ab-cd"
输出："dc-ba"
示例 2：

输入："a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
示例 3：

输入："Test1ng-Leet=code-Q!"
输出："Qedo1ct-eeLg=ntse-T!"


提示：

S.length <= 100
33 <= S[i].ASCIIcode <= 122
S 中不包含 \ or "
 */
/**
 * @param {string} S
 * @return {string}
 */
var reverseOnlyLetters = function(S) {
  S = S.split('');
  let left = 0,
    right = S.length - 1,
    temp;
  const reg = /[a-zA-Z]/;
  while (left < right) {
    while (!reg.test(S[left])) left++;
    while (!reg.test(S[right])) right--;
    if (left < right) {
      [S[left], S[right]] = [S[right], S[left]];
      left++;
      right--;
    }
  }
  return S.join('');
};

// console.log(reverseOnlyLetters('ab-cd'))
// console.log(reverseOnlyLetters('ab'))
console.log(reverseOnlyLetters('a-bC-dEf-ghIj'));
// console.log(reverseOnlyLetters('Test1ng-Leet=code-Q!'))
// console.log(reverseOnlyLetters(''))
```

### [922].按奇偶排序数组-ii

```js
/*
 * @lc app=leetcode.cn id=922 lang=javascript
 *
 * [922] 按奇偶排序数组 II
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParityII = function(nums) {
  // 好像不关排序的事情。。。。
  const result = [];
  let even = 0,
    odd = 1;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 === 0) {
      result[even] = nums[i];
      even += 2;
    } else {
      result[odd] = nums[i];
      odd += 2;
    }
  }
  return result;
};

console.log(sortArrayByParityII([4, 2, 5, 7]));
```

### [958].check-completeness-of-a-binary-tree

```js
/*
 * @lc app=leetcode id=958 lang=javascript
 *
 * [958] Check Completeness of a Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isCompleteTree = function(root) {
  if (root === null) return root;
  let cur = root;
  const queue = [];

  while (cur !== null) {
    queue.push(cur.left);
    queue.push(cur.right);
    cur = queue.shift();
  }

  return queue.filter(Boolean).length === 0;
};
```

### [977].有序数组的平方

```js
/*
 * @lc app=leetcode.cn id=977 lang=javascript
 *
 * [977] 有序数组的平方
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */

// 使用双指针，一个用来移动负数， 一个用来移动正数
var sortedSquares = function(A) {
  let i = 0;
  while (i < A.length && A[i] < 0) {
    i++;
  }
  let j = i--,
    resp = [];
  while (i >= 0 && j < A.length) {
    if (Math.abs(A[i]) < Math.abs(A[j])) {
      resp.push(A[i] * A[i]);
      i--;
    } else {
      resp.push(A[j] * A[j]);
      j++;
    }
  }
  while (i >= 0) {
    resp.push(A[i] * A[i]);
    i--;
  }
  while (j < A.length) {
    resp.push(A[j] * A[j]);
    j++;
  }
  return resp;
};

// console.log(sortedSquares([-4, -1, 0, 3, 10]))
// console.log(sortedSquares([-1
```

### [912].

```js
// [912]. Sort an Array

// Given an array of integers nums, sort the array in ascending order.

// Example 1:

// Input: [5,2,3,1]
// Output: [1,2,3,5]
// Example 2:

// Input: [5,1,1,2,0,0]
// Output: [0,0,1,1,2,5]

// Note:

// 1 <= A.length <= 10000
// -50000 <= A[i] <= 50000

const merge = (left, right) => {
  const merged = [];
  let leftI = 0;
  let rightI = 0;

  while (merged.length < left.length + right.length) {
    if (leftI === left.length) {
      merged.push(right[rightI]);
      rightI++;
    } else if (rightI === right.length) {
      merged.push(left[leftI]);
      leftI++;
    } else if (left[leftI] < right[rightI]) {
      merged.push(left[leftI]);
      leftI++;
    } else {
      merged.push(right[rightI]);
      rightI++;
    }
  }

  return merged;
};

const mergeSort = arr => {
  // console.log(arr)
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
};

/**
 * @param {number[]} nums
 * @return {number[]}
 */
export default function sortArray(nums) {
  return mergeSort(nums);
}
```

### [961].重复了 N 次的元素

```js
var repeatedNTimes = function(A) {
  let mySet = new Set();
  for (let i = 0; i <= A.length / 2 + 1; i++) {
    if (mySet.has(A[i])) {
      return A[i];
    }
    mySet.add(A[i]);
  }
};
```

### [987].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

const verticalTraversalAux = (root, map, mat) => {
  if (!root) return;
  const queue = [];
  queue.push([root, 0]);
  while (queue.length) {
    const [node, x] = queue.shift();
    if (map.has(x)) {
      const a = map.get(x);
      a.push(node.val);
    } else {
      map.set(x, [node.val]);
    }
    if (node.left) queue.push([node.left, x - 1]);
    if (node.right) queue.push([node.right, x + 1]);
  }
};

/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
const verticalTraversal = function(root) {
  const map = new Map();
  const mat = new Array().fill(new Array());
  verticalTraversalAux(root, map, mat);
  const keys = Array.from(map.keys()).sort((a, b) => a - b);
  const res = [];
  for (const key of keys) {
    res.push(map.get(key));
  }
  return res;
};
```

### [875].koko-eating-bananas

```
Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.

Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.

Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.

Return the minimum integer K such that she can eat all the bananas within H hours.



Example 1:

Input: piles = [3,6,7,11], H = 8
Output: 4
Example 2:

Input: piles = [30,11,23,4,20], H = 5
Output: 30
Example 3:

Input: piles = [30,11,23,4,20], H = 6
Output: 23


Note:

1 <= piles.length <= 10^4
piles.length <= H <= 10^9
1 <= piles[i] <= 10^9

```

#### 思路

符合直觉的做法是，选择最大的堆的香蕉数，然后试一下能不能行，如果不行则直接返回上次计算的结果，
如果行，我们减少 1 个香蕉，试试行不行，依次类推。计算出刚好不行的即可。这种解法的时间复杂度是 O(n)。

这道题如果能看出来是二分法解决，那么其实很简单。为什么它是二分问题呢？
我这里画了个图，我相信你看了就明白了。

#### 关键点解析

- 二分查找

#### 代码

```js
/*
 * @lc app=leetcode id=875 lang=javascript
 *
 * [875] Koko Eating Bananas
 *
 * https://leetcode.com/problems/koko-eating-bananas/description/
 *
 * algorithms
 * Medium (44.51%)
 * Total Accepted:    11.3K
 * Total Submissions: 24.8K
 * Testcase Example:  '[3,6,7,11]\n8'
 *
 * Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has
 * piles[i] bananas.  The guards have gone and will come back in H hours.
 *
 * Koko can decide her bananas-per-hour eating speed of K.  Each hour, she
 * chooses some pile of bananas, and eats K bananas from that pile.  If the
 * pile has less than K bananas, she eats all of them instead, and won't eat
 * any more bananas during this hour.
 *
 * Koko likes to eat slowly, but still wants to finish eating all the bananas
 * before the guards come back.
 *
 * Return the minimum integer K such that she can eat all the bananas within H
 * hours.
 *
 *
 *
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: piles = [3,6,7,11], H = 8
 * Output: 4
 *
 *
 *
 * Example 2:
 *
 *
 * Input: piles = [30,11,23,4,20], H = 5
 * Output: 30
 *
 *
 *
 * Example 3:
 *
 *
 * Input: piles = [30,11,23,4,20], H = 6
 * Output: 23
 *
 *
 *
 *
 * Note:
 *
 *
 * 1 <= piles.length <= 10^4
 * piles.length <= H <= 10^9
 * 1 <= piles[i] <= 10^9
 *
 *
 *
 *
 *
 */

function canEatAllBananas(piles, H, mid) {
  let h = 0;
  for (let pile of piles) {
    h += Math.ceil(pile / mid);
  }

  return h <= H;
}
/**
 * @param {number[]} piles
 * @param {number} H
 * @return {number}
 */
var minEatingSpeed = function(piles, H) {
  let lo = 1,
    hi = Math.max(...piles);

  while (lo <= hi) {
    let mid = lo + ((hi - lo) >> 1);
    if (canEatAllBananas(piles, H, mid)) {
      hi = mid - 1;
    } else {
      lo = mid + 1;
    }
  }

  return lo; //  不能选择hi
};
```

### [877].stone-game

```
Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].

The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.

Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.



Example 1:

Input: [5,3,4,5]
Output: true
Explanation:
Alex starts first, and can only take the first 5 or the last 5.
Say he takes the first 5, so that the row becomes [3, 4, 5].
If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alex, so we return true.


Note:

2 <= piles.length <= 500
piles.length is even.
1 <= piles[i] <= 500
sum(piles) is odd.

```

#### 思路

由于 piles 是偶数的，并且 piles 的总和是奇数的。

因此 Alex`可以做到`要不拿的全部是奇数，要么全部是偶数。

举个例子： 比如 Alex 第一次先拿第一个

这里有两种情况：

1. Lee 如果拿了第二块(偶数)，那么 Alex 继续拿第三块，以此类推。。。

2. Lee 如果拿了最后一块(偶数)，那么 Alex 继续拿倒数第二块，以此类推。。。

因此 Alex`可以`做到只拿奇数或者偶数，只是他可以控制的，因此他要做的就是数一下，奇数加起来多还是偶数加起来多就好了。
奇数多就全部选奇数，偶数就全部选偶数。 Lee 是没有这种自由权的。

#### 关键点解析

- 可以用 DP(动态规划)

- 可以从数学的角度去分析

> ......(😅)

#### 代码

```js
/*
 * @lc app=leetcode id=877 lang=javascript
 *
 * [877] Stone Game
 *
 * https://leetcode.com/problems/stone-game/description/
 *
 * algorithms
 * Medium (60.46%)
 * Total Accepted:    21.4K
 * Total Submissions: 35.3K
 * Testcase Example:  '[5,3,4,5]'
 *
 * Alex and Lee play a game with piles of stones.  There are an even number of
 * piles arranged in a row, and each pile has a positive integer number of
 * stones piles[i].
 *
 * The objective of the game is to end with the most stones.  The total number
 * of stones is odd, so there are no ties.
 *
 * Alex and Lee take turns, with Alex starting first.  Each turn, a player
 * takes the entire pile of stones from either the beginning or the end of the
 * row.  This continues until there are no more piles left, at which point the
 * person with the most stones wins.
 *
 * Assuming Alex and Lee play optimally, return True if and only if Alex wins
 * the game.
 *
 *
 *
 * Example 1:
 *
 *
 * Input: [5,3,4,5]
 * Output: true
 * Explanation:
 * Alex starts first, and can only take the first 5 or the last 5.
 * Say he takes the first 5, so that the row becomes [3, 4, 5].
 * If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10
 * points.
 * If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win
 * with 9 points.
 * This demonstrated that taking the first 5 was a winning move for Alex, so we
 * return true.
 *
 *
 *
 *
 * Note:
 *
 *
 * 2 <= piles.length <= 500
 * piles.length is even.
 * 1 <= piles[i] <= 500
 * sum(piles) is odd.
 *
 *
 *
 */
/**
 * @param {number[]} piles
 * @return {boolean}
 */
var stoneGame = function(piles) {
  return true;
};
```

#### 扩展

腾讯面试题：一共 100 只弓箭 你和你的对手共用。你们每次只能射出一支箭或者两支箭，射击交替进行，设计一个算法，保证自己获胜。

答案： 先手，剩下的是 3 的倍数就行(100-1=99)，然后按照 3 的倍数射箭必赢。
比如你先拿了 1，剩下 99 个。 对手拿了 1，你就拿 2。这样持续 33 次就赢了。如果对手拿了 2 个，你就拿 1 个，这样持续 33 次你也是赢的。

> 这是一种典型的博弈问题， 你和对手交替进行，对手的行动影响你接下来的策略。 这算是一种最简单的博弈问题了

### [887].super-egg-drop

```
You are given K eggs, and you have access to a building with N floors from 1 to N.

Each egg is identical in function, and if an egg breaks, you cannot drop it again.

You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.

Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).

Your goal is to know with certainty what the value of F is.

What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?



Example 1:

Input: K = 1, N = 2
Output: 2
Explanation:
Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
If it didn't break, then we know with certainty F = 2.
Hence, we needed 2 moves in the worst case to know what F is with certainty.
Example 2:

Input: K = 2, N = 6
Output: 3
Example 3:

Input: K = 3, N = 14
Output: 4


Note:

1 <= K <= 100
1 <= N <= 10000


```

#### 思路

这是一道典型的动态规划题目，但是又和一般的动态规划不一样。

拿题目给的例子为例，两个鸡蛋，六层楼，我们最少扔几次？

一个符合直觉的做法是，建立 dp[i][j], 代表 i 个鸡蛋，j 层楼最少扔几次，然后我们取 dp[K][n]即可。

代码大概这样的：

```js
const dp = Array(K + 1);
dp[0] = Array(N + 1).fill(0);
for (let i = 1; i < K + 1; i++) {
  dp[i] = [0];
  for (let j = 1; j < N + 1; j++) {
    // 只有一个鸡蛋
    if (i === 1) {
      dp[i][j] = j;
      continue;
    }
    // 只有一层楼
    if (j === 1) {
      dp[i][j] = 1;
      continue;
    }

    // 每一层我们都模拟一遍
    const all = [];
    for (let k = 1; k < j + 1; k++) {
      const brokenCount = dp[i - 1][k - 1]; // 如果碎了
      const notBrokenCount = dp[i][j - k]; // 如果没碎
      all.push(Math.max(brokenCount, notBrokenCount)); // 最坏的可能
    }
    dp[i][j] = Math.min(...all) + 1; // 最坏的集合中我们取最好的情况
  }
}

return dp[K][N];
```

果不其然，当我提交的时候，超时了。 这个的时复杂度是很高的，可以看到，我们内层暴力的求解所有可能，然后
取最好的，这个过程非常耗时，大概是 O(N^2 \* K).

然后我看了一位 leetcode[网友](https://leetcode.com/lee215/)的回答,
他的想法是`dp[M][K]means that, given K eggs and M moves，what is the maximum number of floor that we can check.`

我们按照他的思路重新建模：

可以看到右下角的部分根本就不需要计算，从而节省很多时间

#### 关键点解析

- dp 建模思路要发生变化, 即
  `dp[M][K]means that, given K eggs and M moves，what is the maximum number of floor that we can check.`

#### 代码

```js
/*
 * @lc app=leetcode id=887 lang=javascript
 *
 * [887] Super Egg Drop
 *
 * https://leetcode.com/problems/super-egg-drop/description/
 *
 * algorithms
 * Hard (24.64%)
 * Total Accepted:    6.2K
 * Total Submissions: 24.9K
 * Testcase Example:  '1\n2'
 *
 * You are given K eggs, and you have access to a building with N floors from 1
 * to N.
 *
 * Each egg is identical in function, and if an egg breaks, you cannot drop it
 * again.
 *
 * You know that there exists a floor F with 0 <= F <= N such that any egg
 * dropped at a floor higher than F will break, and any egg dropped at or below
 * floor F will not break.
 *
 * Each move, you may take an egg (if you have an unbroken one) and drop it
 * from any floor X (with 1 <= X <= N).
 *
 * Your goal is to know with certainty what the value of F is.
 *
 * What is the minimum number of moves that you need to know with certainty
 * what F is, regardless of the initial value of F?
 *
 *
 *
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: K = 1, N = 2
 * Output: 2
 * Explanation:
 * Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
 * Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty
 * that F = 1.
 * If it didn't break, then we know with certainty F = 2.
 * Hence, we needed 2 moves in the worst case to know what F is with
 * certainty.
 *
 *
 *
 * Example 2:
 *
 *
 * Input: K = 2, N = 6
 * Output: 3
 *
 *
 *
 * Example 3:
 *
 *
 * Input: K = 3, N = 14
 * Output: 4
 *
 *
 *
 *
 * Note:
 *
 *
 * 1 <= K <= 100
 * 1 <= N <= 10000
 *
 *
 *
 *
 *
 */
/**
 * @param {number} K
 * @param {number} N
 * @return {number}
 */
var superEggDrop = function(K, N) {
  // 不选择dp[K][M]的原因是dp[M][K]可以简化操作
  const dp = Array(N + 1)
    .fill(0)
    .map(_ => Array(K + 1).fill(0));

  let m = 0;
  while (dp[m][K] < N) {
    m++;
    for (let k = 1; k <= K; ++k) dp[m][k] = dp[m - 1][k - 1] + 1 + dp[m - 1][k];
  }
  console.log(dp);
  return m;
};
```

### [900].rle-iterator

```
Write an iterator that iterates through a run-length encoded sequence.

The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.

The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead.

For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".



Example 1:

Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
Output: [null,8,8,5,-1]
Explanation:
RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).
This maps to the sequence [8,8,8,5,5].
RLEIterator.next is then called 4 times:

.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].

.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].

.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].

.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,
but the second term did not exist.  Since the last term exhausted does not exist, we return -1.

Note:

0 <= A.length <= 1000
A.length is an even integer.
0 <= A[i] <= 10^9
There are at most 1000 calls to RLEIterator.next(int n) per test case.
Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.

```

#### 思路

这是一个游程编码的典型题目。

该算法分为两个部分，一个是初始化，一个是调用`next(n)`.

我们需要做的就是初始化的时候，记住这个 A。 然后每次调用`next(n)`的时候只需要

判断 n 是否大于 A[i](i从0开始)

- 如果大于 A[i], 那就说明不够，我们移除数组前两项，更新 n，重复 1

- 如果小于 A[i], 则说明够了，更新 A[i]

这样做，我们每次都要更新 A，还有一种做法就是不更新 A，而是`伪更新`，即用一个变量记录，当前访问到的数组位置。

> 很多时候我们需要原始的，那么就必须这种放了，我的解法就是这种方法。

#### 关键点解析

#### 代码

```js
/*
 * @lc app=leetcode id=900 lang=javascript
 *
 * [900] RLE Iterator
 *
 * https://leetcode.com/problems/rle-iterator/description/
 *
 * algorithms
 * Medium (49.03%)
 * Total Accepted:    11.6K
 * Total Submissions: 23.5K
 * Testcase Example:  '["RLEIterator","next","next","next","next"]\n[[[3,8,0,9,2,5]],[2],[1],[1],[2]]'
 *
 * Write an iterator that iterates through a run-length encoded sequence.
 *
 * The iterator is initialized by RLEIterator(int[] A), where A is a run-length
 * encoding of some sequence.  More specifically, for all even i, A[i] tells us
 * the number of times that the non-negative integer value A[i+1] is repeated
 * in the sequence.
 *
 * The iterator supports one function: next(int n), which exhausts the next n
 * elements (n >= 1) and returns the last element exhausted in this way.  If
 * there is no element left to exhaust, next returns -1 instead.
 *
 * For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding
 * of the sequence [8,8,8,5,5].  This is because the sequence can be read as
 * "three eights, zero nines, two fives".
 *
 *
 *
 * Example 1:
 *
 *
 * Input: ["RLEIterator","next","next","next","next"],
 * [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
 * Output: [null,8,8,5,-1]
 * Explanation:
 * RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).
 * This maps to the sequence [8,8,8,5,5].
 * RLEIterator.next is then called 4 times:
 *
 * .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining
 * sequence is now [8, 5, 5].
 *
 * .next(1) exhausts 1 term of the sequence, returning 8.  The remaining
 * sequence is now [5, 5].
 *
 * .next(1) exhausts 1 term of the sequence, returning 5.  The remaining
 * sequence is now [5].
 *
 * .next(2) exhausts 2 terms, returning -1.  This is because the first term
 * exhausted was 5,
 * but the second term did not exist.  Since the last term exhausted does not
 * exist, we return -1.
 *
 *
 *
 * Note:
 *
 *
 * 0 <= A.length <= 1000
 * A.length is an even integer.
 * 0 <= A[i] <= 10^9
 * There are at most 1000 calls to RLEIterator.next(int n) per test case.
 * Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.
 *
 *
 */
/**
 * @param {number[]} A
 */
var RLEIterator = function(A) {
  this.A = A;
  this.current = 0;
};

/**
 * @param {number} n
 * @return {number}
 */
RLEIterator.prototype.next = function(n) {
  const A = this.A;
  while (this.current < A.length && A[this.current] < n) {
    n = n - A[this.current];
    this.current += 2;
  }

  if (this.current >= A.length) {
    return -1;
  }

  A[this.current] = A[this.current] - n; // 更新Count
  return A[this.current + 1]; // 返回element
};

/**
 * Your RLEIterator object will be instantiated and called as such:
 * var obj = new RLEIterator(A)
 * var param_1 = obj.next(n)
 */
```

### [950].reveal-cards-in-increasing-order

```js
/*
 * @lc app=leetcode id=950 lang=javascript
 *
 * [950] Reveal Cards In Increasing Order
 */
/**
 * @param {number[]} deck
 * @return {number[]}
 */
var deckRevealedIncreasing = function(deck) {
  const hand = [];
  const table = deck.sort((a, b) => a - b);

  let handTurn = true;
  while (table.length > 0) {
    if (handTurn) {
      hand.unshift(table.pop());
    } else {
      hand.unshift(hand.pop());
    }
    handTurn = !handTurn;
  }
  return hand;
};
```

### [1031].maximum-sum-of-two-non-overlapping-subarrays

```
Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M.  (For clarification, the L-length subarray could occur before or after the M-length subarray.)

Formally, return the largest V for which V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:

0 <= i < i + L - 1 < j < j + M - 1 < A.length, or
0 <= j < j + M - 1 < i < i + L - 1 < A.length.


Example 1:

Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.
Example 2:

Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
Output: 29
Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.
Example 3:

Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3
Output: 31
Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.


Note:

L >= 1
M >= 1
L + M <= A.length <= 1000
0 <= A[i] <= 1000
```

#### 思路(动态规划)

题目中要求在前 N(数组长度)个数中找出长度分别为 L 和 M 的非重叠子数组之和的最大值, 因此, 我们可以定义数组 A 中前 i 个数可构成的非重叠子数组 L 和 M 的最大值为 SUMM[i], 并找到 SUMM[i]和 SUMM[i-1]的关系, 那么最终解就是 SUMM[N]. 以下为图解:

#### 关键点解析

1. 注意图中描述的都是 A[i-1], 而不是 A[i], 因为 base case 为空数组, 而不是 A[0];
2. 求解图中 ASUM 数组的时候, 注意定义的是 ASUM[i] = sum(A[0:i]), 因此当 i 等于 0 时, A[0:0]为空数组, 即: ASUM[0]为 0, 而 ASUM[1]才等于 A[0];
3. 求解图中 MAXL 数组时, 注意 i < L 时, 没有意义, 因为长度不够, 所以从 i = L 时才开始求解;
4. 求解图中 MAXM 数组时, 也一样, 要从 i = M 时才开始求解;
5. 求解图中 SUMM 数组时, 因为我们需要一个 L 子数组和一个 M 子数组, 因此长度要大于等于 L+M 才有意义, 所以要从 i = L + M 时开始求解.

#### 代码

- 语言支持: Python

Python Code:

```python
class Solution:
    def maxSumTwoNoOverlap(self, a: List[int], l: int, m: int) -> int:
        """

        define asum[i] as the sum of subarray, a[0:i]
        define maxl[i] as the maximum sum of l-length subarray in a[0:i]
        define maxm[i] as the maximum sum of m-length subarray in a[0:i]
        define msum[i] as the maximum sum of non-overlap l-length subarray and m-length subarray

        case 1: a[i] is both not in l-length subarray and m-length subarray, then msum[i] = msum[i - 1]
        case 2: a[i] is in l-length subarray, then msum[i] = asum[i] - asum[i-l] + maxm[i-l]
        case 3: a[i] is in m-length subarray, then msum[i] = asum[i] - asum[i-m] + maxl[i-m]

        so, msum[i] = max(msum[i - 1], asum[i] - asum[i-l] + maxl[i-l], asum[i] - asum[i-m] + maxm[i-m])
        """

        alen, tlen = len(a), l + m
        asum = [0] * (alen + 1)
        maxl = [0] * (alen + 1)
        maxm = [0] * (alen + 1)
        msum = [0] * (alen + 1)

        for i in range(tlen):
            if i == 1:
                asum[i] = a[i - 1]
            elif i > 1:
                asum[i] = asum[i - 1] + a[i - 1]
            if i >= l:
                maxl[i] = max(maxl[i - 1], asum[i] - asum[i - l])
            if i >= m:
                maxm[i] = max(maxm[i - 1], asum[i] - asum[i - m])

        for i in range(tlen, alen + 1):
            asum[i] = asum[i - 1] + a[i - 1]
            suml = asum[i] - asum[i - l]
            summ = asum[i] - asum[i - m]
            maxl[i] = max(maxl[i - 1], suml)
            maxm[i] = max(maxm[i - 1], summ)
            msum[i] = max(msum[i - 1], suml + maxm[i - l], summ + maxl[i - m])

        return msum[-1]
```

#### 扩展

1. 代码中, 求解了 4 个动态规划数组来求解最终值, 有没有可能只用两个数组来求解该题, 可以的话, 需要保留的又是哪两个数组?
2. 代码中, 求解的 4 动态规划数组的顺序能否改变, 哪些能改, 哪些不能改?

### [958].check-completeness-of-a-binary-tree

```js
/*
 * @lc app=leetcode id=958 lang=javascript
 *
 * [958] Check Completeness of a Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isCompleteTree = function(root) {
  if (root === null) return root;
  let cur = root;
  const queue = [];

  while (cur !== null) {
    queue.push(cur.left);
    queue.push(cur.right);
    cur = queue.shift();
  }

  return queue.filter(Boolean).length === 0;
};
```

### [1123].最深叶节点的最近公共祖先

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/

* tag：`DFS` `Tree`

给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。

回想一下：

- 叶节点是二叉树中没有子节点的节点
- 树的根节点的深度为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1
- 如果我们假定 A 是一组节点 S 的最近公共祖先，`<font color="#c7254e" face="Menlo, Monaco, Consolas, Courier New, monospace">S</font>`中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。

**示例 1：**

```
输入：root = [1,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = [1,2,3,4]
输出：[4]
```

**示例 3：**

```
输入：root = [1,2,3,4,5]
输出：[2,4,5]
```

提示：

- 给你的树中将有 1 到 1000 个节点。
- 树中每个节点的值都在 1 到 1000 之间。

#### 参考答案

深度优先搜索

> 先来解释一下题目意思，给你一个树根，返回最深叶节点的最近公共祖先，存在以下俩种情况：

- 最深叶节点只有一个，那么这个叶节点本身就是它的最近公共祖先
- 最深叶节点不止一个，那就不断深搜找到最大深度，然后回溯，出递归栈时最后一个左右子树等高的节点就是该树的最深节点的最近祖先
  > 所以代码思路分俩条路:只有一个最深叶节点找到并更新返回值;存在多个最深叶节点，找到最后一个子节点等高的节点更新返回值。后者的存在可以被证明，所以后者可以更改前者的结果。

```
class Solution {
private:
    TreeNode *ans;
    int max_deep;
    int DFS(TreeNode *root, int nums){
        //叶子节点
        if(root->left == NULL && root->right == NULL){
            //更新最大深度，记录最大深度的叶节点
            if(nums>max_deep){
                ans = root;
                max_deep = nums;
            }
            return nums;
        }
        int num_l=0, num_r=0;
        //递归左右子树
        if(root->left) num_l = DFS(root->left, nums+1);
        if(root->right) num_r = DFS(root->right, nums+1);
        //存储多个最深叶节点，递归出最近公共祖先
        if(num_l == num_r && num_l>=max_deep){
            ans = root;
            max_deep = num_l;
        }
        //返回最大深度
        return max(num_l, num_r);
    }
public:
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        //初始化根、最大深度
        ans = root;
        max_deep = INT_MIN;
        int deep_n = DFS(root, 1);
        return ans;
    }
};
```

### [1011].capacity-to-ship-packages-within-d-days

#### 题目地址(1011. 在 D 天内送达包裹的能力)

https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days

传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i  个包裹的重量为  weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。

示例 1：

输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。
示例 2：

输入：weights = [3,2,2,4,1,4], D = 3
输出：6
解释：
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4
示例 3：

输入：weights = [1,2,3,1,1], D = 4
输出：3
解释：
第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1

提示：

1 <= D <= weights.length <= 50000
1 <= weights[i] <= 500

#### 思路

这道题和[猴子吃香蕉](https://github.com/azl397985856/leetcode/blob/master/problems/875.koko-eating-bananas.md) 简直一摸一样，没有看过的建议看一下那道题。

像这种题如何你能发现本质的考点，那么 AC 是瞬间的事情。 这道题本质上就是从 1，2，3，4，。。。total(其中 toal 是总的货物重量)的有限离散数据中查找给定的数。这里我们不是直接查找 target，而是查找恰好能够在 D 天运完的载货量。

- 容量是 1 可以运完么？
- 容量是 2 可以运完么？
- 容量是 3 可以运完么？
- 。。。
- 容量是 total 可以运完么？(当然可以，因为 D 大于等于 1)

上面不断询问的过程如果回答是 yes 我们直接 return 即可。如果回答是 no，我们继续往下询问。

这是一个典型的二分问题，只不过我们的判断条件略有不同，大概是：

```python
def canShip(opacity):
    ### 指定船的容量是否可以在D天运完
lo = 0
hi = total
while lo < hi:
    mid = (lo + hi) // 2
    if canShip(mid):
        hi = mid
    else:
        lo = mid + 1

return lo

```

#### 关键点解析

- 能够识别出是给定的有限序列查找一个数字(二分查找)，要求你对二分查找以及变体十分熟悉

#### 代码

```python
class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        lo = 0
        hi = 0

        def canShip(opacity):
            days = 1
            remain = opacity
            for weight in weights:
                if weight > opacity:
                    return False
                remain -= weight
                if remain < 0:
                    days += 1
                    remain = opacity - weight
            return days <= D

        for weight in weights:
            hi += weight
        while lo < hi:
            mid = (lo + hi) // 2
            if canShip(mid):
                hi = mid
            else:
                lo = mid + 1

        return lo
```

#### 扩展

#### 参考

### [1014].best-sightseeing-pair

#### 题目地址(1014. 最佳观光组合)

https://leetcode-cn.com/problems/best-sightseeing-pair/description/

给定正整数数组  A，A[i]  表示第 i 个观光景点的评分，并且两个景点  i 和  j  之间的距离为  j - i。

一对景点(i < j)组成的观光组合的得分为(A[i] + A[j] + i - j)：景点的评分之和减去它们两者之间的距离。

返回一对观光景点能取得的最高分。

示例：

输入：[8,1,5,2,6]
输出：11
解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11

提示：

2 <= A.length <= 50000
1 <= A[i] <= 1000

#### 思路

最简单的思路就是两两组合，找出最大的，妥妥超时，我们来看下代码：

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        res = 0
        for i in range(n - 1):
            for j in range(i + 1, n):
                res = max(res, A[i] + A[j] + i - j)
        return res
```

我们思考如何优化。 其实我们可以遍历一遍数组，对于数组的每一项`A[j] - j` 我们都去前面找`最大`的 A[i] + i (这样才能保证结果最大)。

我们考虑使用动态规划来解决, 我们使用 dp[i] 来表示 数组 A 前 i 项的`A[i] + i`的最大值。

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        dp = [float('-inf')] * (n + 1)
        res = 0
        for i in range(n):
            dp[i + 1] = max(dp[i], A[i] + i)
            res = max(res, dp[i] + A[i] - i)
        return res
```

如上其实我们发现，dp[i + 1] 只和 dp[i] 有关，这是一个空间优化的信号。我们其实可以使用一个变量来记录，而不必要使用一个数组，代码见下方。

#### 关键点解析

- 空间换时间
- dp 空间优化

#### 代码

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        pre = A[0] + 0
        res = 0
        for i in range(1, n):
            res = max(res, pre + A[i] - i)
            pre = max(pre, A[i] + i)
        return res
```

#### 小技巧

Python 的代码如果不使用 max，而是使用 if else 效率目测会更高，大家可以试一下。

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        pre = A[0] + 0
        res = 0
        for i in range(1, n):
            ### res = max(res, pre + A[i] - i)
            ### pre = max(pre, A[i] + i)
            res = res if res > pre + A[i] - i else pre + A[i] - i
            pre = pre if pre > A[i] + i else A[i] + i
        return res
```

### [1015].smallest-integer-divisible-by-k

```
给定正整数 K，你需要找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。

返回 N 的长度。如果不存在这样的 N，就返回 -1。



示例 1：

输入：1
输出：1
解释：最小的答案是 N = 1，其长度为 1。
示例 2：

输入：2
输出：-1
解释：不存在可被 2 整除的正整数 N 。
示例 3：

输入：3
输出：3
解释：最小的答案是 N = 111，其长度为 3。


提示：

1 <= K <= 10^5

```

#### 思路

这道题是说给定一个 K 值，能否找到一个形如 1，11，111，1111 。。。 这样的数字 n 使得 n % K == 0。

首先容易想到的是如果 K 是 2，4，5， 6，8 结尾的话，一定是不行的。直观的解法是从 1，11，111，1111 。。。 这样一直除下去，直到碰到可以整除的，我们返回即可。 但是如果这个数字根本就无法整除怎么办？没错，我们会无限循环下去。我们应该在什么时刻跳出循环，返回 - 1 (表示不能整除)呢？

我们拿题目给出的不能整除的 2 来说。

- 1 // 2 等于 1
- 11 // 2 等于 1
- 111 // 2 等于 1
- ...

我们再来一个不能整除的例子 6:

- 1 // 6 等于 1
- 11 // 6 等于 5
- 111 // 6 等于 3
- 1111 // 6 等于 1
- 11111 // 6 等于 5
- ...

通过观察我们发现不断整除的过程，会陷入无限循环，对于 2 来说，其循环节就是 1。对于 6 来说，其循环节来说就是 153。而且由于我们的分母是 6，也就是说余数的可能性一共只有六种情况 0,1,2,3,4,5。

上面是感性的认识， 接下来我们从数学上予以证明。上面的算法用公式来表示就是`mod = (10 \* mod + 1) % K`。假如出现了相同的数，我们可以肯定之后会无限循环。比如 153 之后出现了 1，我们可以肯定之后一定是 35。。。 因为我们的 mod 只是和前一个 mod 有关，上面的公式是一个`纯函数`。

#### 关键点解析

- 数学(无限循环与循环节)

#### 代码

```python
#
### @lc app=leetcode.cn id=1015 lang=python3
#
### [1015] 可被 K 整除的最小整数
### ### @lc code=start


class Solution:
    def smallestRepunitDivByK(self, K: int) -> int:
        if K % 10 in [2, 4, 5, 6, 8]:
            return - 1
        seen = set()
        mod = 0
        for i in range(1, K + 1):
            mod = (mod * 10 + 1) % K
            if mod in seen:
                return -1
            if mod == 0:
                return ix
            seen.add(mod)

        ### @lc code=end


```

### [1019].next-greater-node-in-linked-list

```
给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。

每个节点都可能有下一个更大值(next larger value)：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。

返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。

注意：在下面的示例中，诸如 [2,1,5] 这样的输入(不是输出)是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。



示例 1：

输入：[2,1,5]
输出：[5,5,0]
示例 2：

输入：[2,7,4,3,5]
输出：[7,0,5,5,0]
示例 3：

输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]


提示：

对于链表中的每个节点，1 <= node.val <= 10^9
给定列表的长度在 [0, 10000] 范围内
```

#### 思路

看完题目就应该想到单调栈才行，LeetCode 上关于单调栈的题目还不少，难度都不小。但是一旦你掌握了这个算法，那么这些题目对你来说都不是问题了。

如果你不用单调栈，那么可以暴力$O(N^2)$的时间复杂度解决，只需要双层循环即可。但是这种做法应该是过不了关的。使用单调栈可以将时间复杂度降低到线性，当然需要额外的$O(N)$的空间复杂度。

顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。为了描述方便，以下举例及代码以维护一个整数的单调递减栈为例。将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。

例如，栈中自顶向下的元素为 1，2，4，5 ，插入元素 3 时为了保证单调性需要依次弹出元素 :

- 最开始栈是这样的： [5,4,2,1]
- 为了维护递减特性，1,2 需要被移除。此时栈是这样的： [5,4]
- 我们将 3 push 到栈顶即可
- 此时栈是这样的： [5,4,3]

用代码描述如下：

Python Code:

```python
def monoStack(list):
    st = []
    for v in list:
        while len(st) > 0 and v > st[-1]:
            st.pop()
        st.append(v)
    return st
monoStack([5, 4, 2, 1, 3]) ### output: [5, 4, 3]
```

#### 关键点

- 单调栈(单调递减栈)
- 单调栈的代码模板

#### 代码

Python Code:

```python
### Definition for singly-linked list.
### class ListNode:
###     def __init__(self, x):
###         self.val = x
###         self.next = None

class Solution:
     def nextLargerNodes(self, head):
        res, st = [], []
        while head:
            while len(st) > 0 and head.val > st[-1][1]:
                res[st.pop()[0]] = head.val
            st.append((len(res), head.val))
            res.append(0)
            head = head.next
        return res
```

#### 扩展

甚至可以做到 O(1)的空间复杂度，请参考[C### O(n) time O(1) space](<https://leetcode.com/problems/next-greater-node-in-linked-list/discuss/267090/C-O(n)-time-O(1)-space>)

### [1020].number-of-enclaves

```
给出一个二维数组 A，每个单元格为 0(代表海)或 1(代表陆地)。

移动是指在陆地上从一个地方走到另一个地方(朝四个方向之一)或离开网格的边界。

返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。



示例 1：

输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：
有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
示例 2：

输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：
所有 1 都在边界上或可以到达边界。


提示：

1 <= A.length <= 500
1 <= A[i].length <= 500
0 <= A[i][j] <= 1
所有行的大小都相同

```

#### 解法一 (暴力法)

##### 思路

这是一个典型的可以使用 DFS 进行解决的一类题目， LeetCode 相关的题目有很多。

对于这种题目不管是思路还是代码都有很大的相似性，我们来看下。

暴力法的思路很简单，我们遍历整个矩阵：

- 如果遍历到 0，我们不予理会
- 如果遍历到 1. 我们将其加到 temp
- 我们不断拓展边界(上下左右)
- 如果 dfs 过程中碰到了边界，说明我们可以逃脱，我们将累加的 temp 清空
- 如果 dfs 过程之后没有碰到边界，说明我们无法逃脱。我们将 temp 加到 cnt
- 最终返回 cnt 即可

##### 关键点解析

- visited 记录访问过的节点，防止重复计算

##### 代码

Python Code:

```python
class Solution:
    temp = 0
    meetEdge = False

    def numEnclaves(self, A: List[List[int]]) -> int:
        cnt = 0
        m = len(A)
        n = len(A[0])
        visited = set()

        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited:
                return
            visited.add((i, j))
            if A[i][j] == 1:
                self.temp += 1
            else:
                return
            if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                self.meetEdge = True
            dfs(i + 1, j)
            dfs(i - 1, j)
            dfs(i, j + 1)
            dfs(i, j - 1)
        for i in range(m):
            for j in range(n):
                dfs(i, j)
                if not self.meetEdge:
                    cnt += self.temp
                self.meetEdge = False
                self.temp = 0
        return cnt

```

#### 解法二 (消除法)

##### 思路

上面的解法时间复杂度和空间复杂度都很差，我们考虑进行优化， 这里我们使用消除法。

- 从矩阵边界开始 dfs
- 如果碰到 1 就将其变成 0
- 如果碰到 0 则什么都不做
- 最后我们遍历整个矩阵，数一下 1 的个数即可。

##### 关键点解析

- dfs 消除法

##### 代码

Python Code:

```python
#
### @lc app=leetcode.cn id=1020 lang=python3
#
### [1020] 飞地的数量
### ### @lc code=start


class Solution:

    def numEnclaves(self, A: List[List[int]]) -> int:
        cnt = 0
        m = len(A)
        n = len(A[0])

        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or A[i][j] == 0:
                return
            A[i][j] = 0

            dfs(i + 1, j)
            dfs(i - 1, j)
            dfs(i, j + 1)
            dfs(i, j - 1)
        for i in range(m):
            dfs(i, 0)
            dfs(i, n - 1)
        for j in range(1, n - 1):
            dfs(0, j)
            dfs(m - 1, j)
        for i in range(m):
            for j in range(n):
                if A[i][j] == 1:
                    cnt += 1
        return cnt

        ### @lc code=end

```

### [1023].camelcase-matching

```
如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。(我们可以在任何位置插入每个字符，也可以插入 0 个字符。)

给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。



示例 1：

输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
输出：[true,false,true,true,false]
示例：
"FooBar" 可以这样生成："F" + "oo" + "B" + "ar"。
"FootBall" 可以这样生成："F" + "oot" + "B" + "all".
"FrameBuffer" 可以这样生成："F" + "rame" + "B" + "uffer".
示例 2：

输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
输出：[true,false,true,false,false]
解释：
"FooBar" 可以这样生成："Fo" + "o" + "Ba" + "r".
"FootBall" 可以这样生成："Fo" + "ot" + "Ba" + "ll".
示例 3：

输出：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
输入：[false,true,false,false,false]
解释：
"FooBarTest" 可以这样生成："Fo" + "o" + "Ba" + "r" + "T" + "est".


提示：

1 <= queries.length <= 100
1 <= queries[i].length <= 100
1 <= pattern.length <= 100
所有字符串都仅由大写和小写英文字母组成。

```

#### 思路

这道题是一道典型的双指针题目。不过这里的双指针并不是指向同一个数组或者字符串，而是指向多个，这道题是指向两个，分别是 query 和 pattern，这种题目非常常见，能够识别和掌握这种题目的解题模板非常重要。对 queries 的每一项我们的逻辑是一样的，这里就以其中一项为例进行讲解。

以 query 为 FooBar，pattern 为 FB 为例。

首先我们来简化一下问题，假如我们没有`可以在任何位置插入每个字符，也可以插入 0 个字符。`这个规则。我们的问题会比较简单，这个时候我们的算法是什么样的呢？一起来看下：

1. 首先我们建立两个指针 i 和 j 分别指向 query 和 pattern 的首字母。
2. 当 i 和 j 指向的字母相同的时候，我们同时向后移动两个指针一个单位。
3. 当 i 和 j 指向的字母不同的时候，我们直接返回 False

假如我们要找到的不是子串，而是子序列怎么办？我们不妨假设判断 pattern 是否是 query 的子序列。 其实 LeetCode 实际上也有这样的题目，我们来看下：

1. 首先我们建立两个指针 i 和 j 分别指向 query 和 pattern 的首字母。
2. 当 i 和 j 指向的字母相同的时候，我们同时向后移动两个指针一个单位。
3. 当 i 和 j 指向的字母不同的时候，我们移动 i 指针。
4. 当 i 超出 query 范围的时候，我们只需要判断 pattern 是否达到了终点即可。当然我们也可以提前退出。

我们直接参考下 LeetCode [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)。

代码：

> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列

Python Code:

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = 0
        j = 0
        while j < len(t):
            if i < len(s) and s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1
            if i >= len (s):
                return True
        return i == len(s)
```

然后我们加上`可以在任何位置插入每个字符，也可以插入 0 个字符。`这个规则。来看下有什么不同：

1. 首先我们建立两个指针 i 和 j 分别指向 query 和 pattern 的首字母。
2. 当 i 和 j 指向的字母相同的时候，我们同时向后移动两个指针一个单位。
3. 当 i 和 j 指向的字母不同的时候，我们继续判断 i 指向的元素是否是小写。
4. 如果是小写我们只把 i 向后移动一个单位。
5. 如果不是小写我们直接返回 False

#### 关键点解析

- 双指针
- 字符串匹配
- 子序列
- 子串

#### 代码

Python Code:

```python
class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        res = []
        for query in queries:
            i = 0
            j = 0
            while i < len(query):
                if j < len(pattern) and query[i] == pattern[j]:
                    i += 1
                    j += 1
                elif query[i].islower():
                    i += 1
                else:
                    break
            if i == len(query) and j == len(pattern):
                res.append(True)
            else:
                res.append(False)
        return res
```

#### 扩展

这是一个符合直觉的解法，但是却不是一个很优秀的解法，那么你有想到什么优秀的解法么？

### [1104].path-in-zigzag-labelled-binary-tree

在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。

如下图所示，在奇数行(即，第一行、第三行、第五行……)中，按从左到右的顺序进行标记；

而偶数行(即，第二行、第四行、第六行……)中，按从右到左的顺序进行标记。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaihhb1ysbj310p0gu3zx.jpg)

给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。

示例 1：

输入：label = 14
输出：[1,3,4,14]
示例 2：

输入：label = 26
输出：[1,2,6,10,26]

提示：

1 <= label <= 10^6

#### 思路

假如这道题不是之字形，那么就会非常简单。 我们可以根据子节点的 label 轻松地求出父节点的 label，公示是 label // 2(其中 label 为子节点的 label)。

如果是这样的话，这道题应该是 easy 难度，代码也不难写出。我们继续考虑之字形。我们不妨先观察一下，找下规律。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaihn0ktanj30lu093gme.jpg)

以上图最后一行为例，对于 15 节点，之字变换之前对应的应该是 8 节点。14 节点对应的是 9 节点。。。

全部列举出来是这样的：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaihota82cj30mk0b6wfp.jpg)

我们发现之字变换前后的 label 相加是一个定值。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaihpnlpicj309b08dmxl.jpg)

因此我们只需要求解出每一层的这个定值，然后减去当前值就好了。(注意我们不需要区分偶数行和奇数行)
问题的关键转化为求解这个定值，这个定值其实很好求，因为每一层的最大值和最小值我们很容易求，而最大值和最小值的和正是我们要求的这个数字。

最大值和最小值这么求呢？由满二叉树的性质，我们知道每一层的最小值就是`2 ** (level - 1)`，而最大值是`2 ** level - 1`。 因此我们只要知道 level 即可，level 非常容易求出，具体可以看下面代码。

#### 关键点

- 满二叉树的性质：

1. 最小值是`2 ** (level - 1)`，最大值是`2 ** level - 1`，其中 level 是树的深度。
2. 假如父节点的索引为 i，那么左子节点就是 2\*i， 右边子节点就是 2\*i + 1。
3. 假如子节点的索引是 i，那么父节点的索引就是 i // 2。

- 先思考一般情况(不是之字形)， 然后通过观察找出规律

#### 代码

```python
class Solution:
    def pathInZigZagTree(self, label: int) -> List[int]:
        level = 0
        res = []
        ### for each level, ranged from 2 ** (level - 1) to 2 ** level - 1
        while 2 ** level - 1 < label:
            level += 1

        while level > 0:
            res.insert(0, label)
            label = 2 ** (level - 1) + 2 ** level - 1 - label
            label //= 2
            level -= 1
        return res
```

### [1131].maximum-of-absolute-value-expression

#### 题目地址(1131. 绝对值表达式的最大值)

https://leetcode-cn.com/problems/maximum-of-absolute-value-expression/description/

给你两个长度相等的整数数组，返回下面表达式的最大值：

|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|

其中下标 i，j 满足 0 <= i, j < arr1.length。

示例 1：

输入：arr1 = [1,2,3,4], arr2 = [-1,4,5,6]
输出：13
示例 2：

输入：arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]
输出：20

提示：

2 <= arr1.length == arr2.length <= 40000
-10^6 <= arr1[i], arr2[i] <= 10^6

#### 解法一(数学分析)

##### 思路

如图我们要求的是这样一个表达式的最大值。arr1 和 arr2 为两个不同的数组，且二者长度相同。i 和 j 是两个合法的索引。

> 红色竖线表示的是绝对值的符号

![](https://tva1.sinaimg.cn/large/006tNbRwly1gamo3dx1bej30q003y74f.jpg)

我们对其进行分类讨论，有如下八种情况：

> |arr1[i] -arr1[j]| 两种情况
> |arr2[i] -arr2[j]| 两种情况
> |i - j| 两种情况
> 因此一共是 2 \* 2 \* 2 = 8 种

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gamosnsknej30tg0viq6w.jpg)

由于 i 和 j 之前没有大小关系，也就说二者可以相互替代。因此：

- 1 等价于 8
- 2 等价于 7
- 3 等价于 6
- 4 等价于 5

也就是说我们只需要计算 1，2，3，4 的最大值就可以了。(当然你可以选择其他组合，只要完备就行)

为了方便，我们将 i 和 j 都提取到一起：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gamp5sizefj30qs0g6gmx.jpg)

容易看出等式的最大值就是前面的最大值，和后面最小值的差值。如图：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gamp9c3g9lj30r20kcabx.jpg)

再仔细观察，会发现前面部分和后面部分是一样的，原因还是上面所说的 i 和 j 可以互换。因此我们要做的就是：

- 遍历一遍数组，然后计算四个表达式， arr1[i] + arr2[i] + i，arr1[i] - arr2[i] + i，arr2[i] - arr1[i] + i 和 -1 \* arr2[i] - arr1[i] + i 的 最大值和最小值。
- 然后分别取出四个表达式最大值和最小值的差值(就是这个表达式的最大值)
- 四个表达式最大值再取出最大值

##### 关键点

- 数学分析

##### 代码

```python
class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        A = []
        B = []
        C = []
        D = []
        for i in range(len(arr1)):
            a, b, c, d = arr1[i] + arr2[i] + i, arr1[i] - arr2[i] + \
                i, arr2[i] - arr1[i] + i, -1 * arr2[i] - arr1[i] + i
            A.append(a)
            B.append(b)
            C.append(c)
            D.append(d)
        return max(max(A) - min(A), max(B) - min(B), max(C) - min(C), max(D) - min(D))
```

#### 解法二(曼哈顿距离)

##### 思路

![](https://tva1.sinaimg.cn/large/006tNbRwly1gampnn032tj308l0a8mxl.jpg)

(图来自： https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%93%88%E9%A0%93%E8%B7%9D%E9%9B%A2)

一维曼哈顿距离可以理解为一条线上两点之间的距离: |x1 - x2|，其值为 max(x1 - x2, x2 - x1)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gampr362oaj30l004mdfv.jpg)

在平面上，坐标(x1, y1)的点 P1 与坐标(x2, y2)的点 P2 的曼哈顿距离为：|x1-x2| + |y1 - y2|,其值为 max(x1 - x2 + y1 - y2, x2 - x1 + y1 - y2, x1 - x2 + y2 - y1, x2 -x1 + y2 - y1)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gampwhua9fj30rq0lmdgl.jpg)

然后这道题目是更复杂的三维曼哈顿距离，其中(i, arr[i], arr[j])可以看作三位空间中的一个点，问题转化为曼哈顿距离最远的两个点的距离。
延续上面的思路，|x1-x2| + |y1 - y2| + |z1 - z2|,其值为 :

max(

x1 - x2 + y1 - y2 + z1 - z2,

x1 - x2 + y1 - y2 + z2 - z1,

x2 - x1 + y1 - y2 + z1 - z2,

x2 - x1 + y1 - y2 + z2 - z1,

x1 - x2 + y2 - y1 + z1 - z2,

x1 - x2 + y2 - y1 + z2- z1,

x2 -x1 + y2 - y1 + z1 - z2，

x2 -x1 + y2 - y1 + z2 - z1

)

我们可以将 1 和 2 放在一起方便计算：

max(

x1 + y1 + z1 - (x2 + y2 + z2)，

x1 + y1 - z1 - (x2 + y2 - z2)

...

)

我们甚至可以扩展到 n 维，具体代码见下方。

##### 关键点

- 曼哈顿距离
- 曼哈顿距离代码模板

> 解题模板可以帮助你快速并且更少错误的解题，更多解题模板请期待我的[新书](https://lucifer.ren/blog/2019/12/11/draft/)(未完成)

##### 代码

```python
class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        ### 曼哈顿距离模板代码
        sign = [1, -1]
        n = len(arr1)
        dists = []
        ### 三维模板
        for a in sign:
            for b in sign:
                for c in sign:
                    maxDist = float('-inf')
                    minDist = float('inf')
                    ### 分别计算所有点的曼哈顿距离
                    for i in range(n):
                        dist = arr1[i] * a + arr2[i] * b + i * c
                        maxDist = max(maxDist, dist)
                        minDist = min(minDist, dist)
                    ### 将所有的点的曼哈顿距离放到dists中
                    dists.append(maxDist - minDist)
        return max(dists)
```

#### 总结

可以看出其实两种解法都是一样的，只是思考角度不一样。

### [1168].optimize-water-distribution-in-a-village-cn

```
There are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.

For each house i, we can either build a well inside it directly with cost wells[i], or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes, where each pipes[i] = [house1, house2, cost] represents the cost to connect house1 and house2 together using a pipe. Connections are bidirectional.

Find the minimum total cost to supply water to all houses.

Example 1:

Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]
Output: 3
Explanation:
The image shows the costs of connecting houses using pipes.
The best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.

Constraints:

1 <= n <= 10000
wells.length == n
0 <= wells[i] <= 10^5
1 <= pipes.length <= 10000
1 <= pipes[i][0], pipes[i][1] <= n
0 <= pipes[i][2] <= 10^5
pipes[i][0] != pipes[i][1]
```

example 1 pic:

#### 思路

题意，在每个城市打井需要一定的花费，也可以用其他城市的井水，城市之间建立连接管道需要一定的花费，怎么样安排可以花费最少的前灌溉所有城市。

这是一道连通所有点的最短路径/最小生成树问题，把城市看成图中的点，管道连接城市看成是连接两个点之间的边。这里打井的花费是直接在点上，而且并不是所有
点之间都有边连接，为了方便，我们可以假想一个点`(root)0`，这里自身点的花费可以与 `0` 连接，花费可以是 `0-i` 之间的花费。这样我们就可以构建一个连通图包含所有的点和边。
那在一个连通图中求最短路径/最小生成树的问题.

参考延伸阅读中，维基百科针对这类题给出的几种解法。

解题步骤：

1. 创建 `POJO EdgeCost(node1, node2, cost) - 节点1 和 节点2 连接边的花费`。
2. 假想一个`root` 点 `0`，构建图
3. 连通所有节点和 `0`，`[0,i] - i 是节点 [1,n]`，`0-1` 是节点 `0` 和 `1` 的边，边的值是节点 `i` 上打井的花费 `wells[i]`;
4. 把打井花费和城市连接点转换成图的节点和边。
5. 对图的边的值排序(从小到大)
6. 遍历图的边，判断两个节点有没有连通 (`Union-Find`)，
   - 已连通就跳过，继续访问下一条边
   - 没有连通，记录花费，连通节点
7. 若所有节点已连通，求得的最小路径即为最小花费，返回
8. 对于每次`union`, 节点数 `n-1`, 如果 `n==0` 说明所有节点都已连通，可以提前退出，不需要继续访问剩余的边。

> 这里用加权 Union-Find 判断两个节点是否连通，和连通未连通的节点。

举例：`n = 5, wells=[1,2,2,3,2], pipes=[[1,2,1],[2,3,1],[4,5,7]]`

如图：

从图中可以看到，最后所有的节点都是连通的。

###### 复杂度分析

- _时间复杂度:_ `O(ElogE) - E 是图的边的个数`
- _空间复杂度:_ `O(E)`

> 一个图最多有 `n(n-1)/2 - n 是图中节点个数` 条边 (完全连通图)

#### 关键点分析

1. 构建图，得出所有边
2. 对所有边排序
3. 遍历所有的边(从小到大)
4. 对于每条边，检查是否已经连通，若没有连通，加上边上的值，连通两个节点。若已连通，跳过。

#### 代码

```java
  class OptimizeWaterDistribution {
    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {
      List<EdgeCost> costs = new ArrayList<>();
      for (int i = 1; i <= n; i++) {
        costs.add(new EdgeCost(0, i, wells[i - 1]));
      }
      for (int[] p : pipes) {
        costs.add(new EdgeCost(p[0], p[1], p[2]));
      }
      Collections.sort(costs);
      int minCosts = 0;
      UnionFind uf = new UnionFind(n);
      for (EdgeCost edge : costs) {
        int rootX = uf.find(edge.node1);
        int rootY = uf.find(edge.node2);
        if (rootX == rootY) continue;
        minCosts += edge.cost;
        uf.union(edge.node1, edge.node2);
        // for each union, we connnect one node
        n--;
        // if all nodes already connected, terminate early
        if (n == 0) {
          return minCosts;
        }
      }
      return minCosts;
    }

    class EdgeCost implements Comparable<EdgeCost> {
      int node1;
      int node2;
      int cost;
      public EdgeCost(int node1, int node2, int cost) {
        this.node1 = node1;
        this.node2 = node2;
        this.cost = cost;
      }

      @Override
      public int compareTo(EdgeCost o) {
        return this.cost - o.cost;
      }
    }

    class UnionFind {
      int[] parent;
      int[] rank;
      public UnionFind(int n) {
        parent = new int[n + 1];
        for (int i = 0; i <= n; i++) {
          parent[i] = i;
        }
        rank = new int[n + 1];
      }
      public int find(int x) {
        return x == parent[x] ? x : find(parent[x]);
      }
      public void union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return;
        if (rank[px] >= rank[py]) {
          parent[py] = px;
          rank[px] += rank[py];
        } else {
          parent[px] = py;
          rank[py] += rank[px];
        }
      }
    }
  }
```

### [1186].maximum-subarray-sum-with-one-deletion

```

给你一个整数数组，返回它的某个 非空 子数组(连续元素)在执行一次可选的删除操作后，所能得到的最大元素总和。

换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素(只能删一次哦)，(删除后)子数组中至少应当有一个元素，然后该子数组(剩下)的元素总和是所有子数组之中最大的。

注意，删除一个元素后，子数组 不能为空。

请看示例：

示例 1：

输入：arr = [1,-2,0,3]
输出：4
解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
示例 2：

输入：arr = [1,-2,-2,3]
输出：3
解释：我们直接选出 [3]，这就是最大和。
示例 3：

输入：arr = [-1,-1,-1,-1]
输出：-1
解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。


提示：

1 <= arr.length <= 10^5
-10^4 <= arr[i] <= 10^4

```

#### 思路

##### 暴力法

符合知觉的做法是求出所有的情况，然后取出最大的。 我们只需要两层循环接口，外循环用于确定我们丢弃的元素，内循环用于计算 subArraySum。

```python
  class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        res = arr[0]
        def maxSubSum(arr, skip):
            res = maxSub = float("-inf")

            for i in range(len(arr)):
                if i == skip:
                    continue
                maxSub = max(arr[i], maxSub + arr[i])
                res = max(res, maxSub)
            return res
		### 这里循环到了len(arr)项，表示的是一个都不删除的情况
        for i in range(len(arr) + 1):
            res = max(res, maxSubSum(arr, i))
        return res
```

##### 空间换时间

上面的做法在 LC 上会 TLE， 因此我们需要换一种思路，既然超时了，我们是否可以从空间换时间的角度思考呢？我们可以分别从头尾遍历，建立两个 subArraySub 的数组 l 和 r。 其实这个不难想到，很多题目都用到了这个技巧。

具体做法：

- 一层遍历， 建立 l 数组，l[i]表示从左边开始的以 arr[i]结尾的 subArraySum 的最大值
- 一层遍历， 建立 r 数组，r[i]表示从右边开始的以 arr[i]结尾的 subArraySum 的最大值
- 一层遍历， 计算 l[i - 1] + r[i + 1] 的最大值
  > l[i - 1] + r[i + 1]的含义就是删除 arr[i]的子数组最大值
- 上面的这个步骤得到了删除一个的子数组最大值， 不删除的只需要在上面循环顺便计算一下即可

```python
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        l = [arr[0]] * n
        r = [arr[n - 1]] * n
        if n == 1:
            return arr[0]
        res = arr[0]
        for i in range(1, n):
            l[i] = max(l[i - 1] + arr[i], arr[i])
            res = max(res, l[i])
        for i in range(n - 2, -1, -1):
            r[i] = max(r[i + 1] + arr[i], arr[i])
            res = max(res, r[i])
        for i in range(1, n - 1):
            res = max(res, l[i - 1] + r[i + 1])

        return res

```

##### 动态规划

上面的算法虽然时间上有所改善，但是正如标题所说，空间复杂度是 O(n),有没有办法改进呢？答案是使用动态规划。

具体过程：

- 定义 max0，表示以 arr[i]结尾且一个都不漏的最大子数组和
- 定义 max1，表示以 arr[i]或者 arr[i - 1]结尾，可以漏一个的最大子数组和
- 遍历数组，更新 max1 和 max0(注意先更新 max1，因为 max1 用到了上一个 max0)
- 其中`max1 = max(max1 + arr[i], max0)`, 即删除 arr[i - 1]或者删除 arr[i]
- 其中`max0 = max(max0 + arr[i], arr[i])`， 一个都不删除

```python
#
### @lc app=leetcode.cn id=1186 lang=python3
#
### [1186] 删除一次得到子数组最大和
### ### @lc code=start


class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        ### DP
        max0 = arr[0]
        max1 = arr[0]
        res = arr[0]
        n = len(arr)
        if n == 1:
            return max0

        for i in range(1, n):
            ### 先更新max1，再更新max0，因为max1用到了上一个max0
            max1 = max(max1 + arr[i], max0)
            max0 = max(max0 + arr[i], arr[i])
            res = max(res, max0, max1)
        return res


### @lc code=end


```

#### 关键点解析

- 空间换时间
- 头尾双数组
- 动态规划

### [1218].longest-arithmetic-subsequence-of-given-difference

```

给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。



示例 1：

输入：arr = [1,2,3,4], difference = 1
输出：4
解释：最长的等差子序列是 [1,2,3,4]。
示例 2：

输入：arr = [1,3,5,7], difference = 1
输出：1
解释：最长的等差子序列是任意单个元素。
示例 3：

输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2
输出：4
解释：最长的等差子序列是 [7,5,3,1]。


提示：

1 <= arr.length <= 10^5
-10^4 <= arr[i], difference <= 10^4

```

#### 思路

最直观的思路是双层循环，我们暴力的枚举出以每一个元素为开始元素，以最后元素结尾的的所有情况。很明显这是所有的情况，这就是暴力法的精髓， 很明显这种解法会 TLE(超时)，不过我们先来看一下代码，顺着这个思维继续思考。

##### 暴力法

```python
  def longestSubsequence(self, arr: List[int], difference: int) -> int:
        n = len(arr)
        res = 1
        for i in range(n):
            count = 1
            for j in range(i + 1, n):
                if arr[i] + difference * count == arr[j]:
                    count += 1

                if count > res:
                    res = count

        return res
```

##### 动态规划

上面的时间复杂度是 O(n^2)， 有没有办法降低到 O(n)呢？很容易想到的是空间换时间的解决方案。

我的想法是将`以每一个元素结尾的最长等差子序列的长度`统统存起来，即`dp[num] = maxLen` 这样我们遍历到一个新的元素的时候，就去之前的存储中去找`dp[num - difference]`, 如果找到了，就更新当前的`dp[num] = dp[num - difference] + 1`, 否则就是不进行操作(还是默认值 1)。

这种空间换时间的做法的时间和空间复杂度都是 O(n)。

#### 关键点解析

- 将`以每一个元素结尾的最长等差子序列的长度`统统存起来

#### 代码

```python
#
### @lc app=leetcode.cn id=1218 lang=python3
#
### [1218] 最长定差子序列
### ### @lc code=start


class Solution:

    ### 动态规划
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        n = len(arr)
        res = 1
        dp = {}
        for num in arr:
            dp[num] = 1
            if num - difference in dp:
                dp[num] = dp[num - difference] + 1

        return max(dp.values())

### @lc code=end
```

### [1227].airplane-seat-assignment-probability

#### 题目地址(1227. 飞机座位分配概率)

https://leetcode-cn.com/problems/airplane-seat-assignment-probability/description/

```

有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。

剩下的乘客将会：

如果他们自己的座位还空着，就坐到自己的座位上，

当他们自己的座位被占用时，随机选择其他座位
第 n 位乘客坐在自己的座位上的概率是多少？



示例 1：

输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。
示例 2：

输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。


提示：

1 <= n <= 10^5


```

#### 暴力递归

这是一道 LeetCode 为数不多的概率题，我们来看下。

##### 思路

我们定义原问题为 f(n)。对于第一个人来说，他有 n 中选择，就是分别选择 n 个座位中的一个。由于选择每个位置的概率是相同的，那么选择每个位置的概率应该都是 1 / n。

我们分三种情况来讨论：

- 如果第一个人选择了第一个人的位置(也就是选择了自己的位置)，那么剩下的人按照票上的座位做就好了，这种情况第 n 个人一定能做到自己的位置
- 如果第一个人选择了第 n 个人的位置，那么第 n 个人肯定坐不到自己的位置。
- 如果第一个人选择了第 i (1 < i < n)个人的位置，那么第 i 个人就相当于变成了“票丢的人”，此时问题转化为 f(n - i + 1)。

此时的问题转化关系如图：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb12n0omuuj31bc0ju405.jpg)
(红色表示票丢的人)

整个过程分析：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb12nhestaj318u0bg76f.jpg)

##### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5
        res = 1 / n
        for i in range(2, n):
            res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n
        return res
```

上述代码会栈溢出。

#### 暴力递归 + hashtable

##### 思路

我们考虑使用记忆化递归来减少重复计算，虽然这种做法可以减少运行时间，但是对减少递归深度没有帮助。还是会栈溢出。

##### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    seen = {}

    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5
        if n in self.seen:
            return self.seen[n]
        res = 1 / n
        for i in range(2, n):
            res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n
        self.seen[n] = res
        return res
```

#### 动态规划

##### 思路

上面做法会栈溢出。其实我们根本不需要运行就应该能判断出栈溢出，题目已经给了数据规模是 1 <= n <= 10 \*\* 5。 这个量级不管什么语言，除非使用尾递归，不然一般都会栈溢出，具体栈深度大家可以查阅相关资料。

既然是栈溢出，那么我们考虑使用迭代来完成。 很容易想到使用动态规划来完成。其实递归都写出来，写一个朴素版的动态规划也难不到哪去，毕竟动态规划就是记录子问题，并建立子问题之间映射而已，这和递归并无本质区别。

##### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5

        dp = [1, .5] * n

        for i in range(2, n):
            dp[i] = 1 / n
            for j in range(2, i):
                dp[i] += dp[i - j + 1] * 1 / n
        return dp[-1]
```

这种思路的代码超时了，并且仅仅执行了 35/100 testcase 就超时了。

#### 数学分析

##### 思路

我们还需要进一步优化时间复杂度，我们需要思考是否可以在线形的时间内完成。

我们继续前面的思路进行分析, 不难得出，我们不妨称其为等式 1：

```
f(n)
= 1/n + 0 + 1/n * (f(n-1) + f(n-2) + ... + f(2))
= 1/n * (f(n-1) + f(n-2) + ... + f(2) + 1)
= 1/n * (f(n-1) + f(n-2) + ... + f(2) + f(1))
```

似乎更复杂了？没关系，我们继续往下看，我们看下 f(n - 1)，我们不妨称其为等式 2。

```
f(n-1) = 1/(n-1) * (f(n-2) + f(n-3) + ... + f(1))
```

我们将等式 1 和等式 2 两边分别同时乘以 n 和 n - 1

```
n * f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(1)
(n-1) * f(n-1) = f(n-2) + f(n-3) + ... + f(1)
```

我们将两者相减：

```
n * f(n) - (n-1)*f(n-1) = f(n-1)
```

我们继续将 (n-1)\*f(n-1) 移到等式右边，得到：

```
n * f(n) = n * f(n-1)
```

也就是说:

```
f(n) = f(n - 1)
```

当然前提是 n 大于 2。

既然如此，我们就可以减少一层循环， 我们用这个思路来优化一下上面的 dp 解法。这种解法终于可以 AC 了。

##### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5

        dp = [1, .5] * n

        for i in range(2, n):
            dp[i] = 1/n+(n-2)/n * dp[n-1]
        return dp[-1]
```

#### 优化数学分析

##### 思路

上面我们通过数学分析，得出了当 n 大于 2 时：

```
f(n) = f(n - 1)
```

那么是不是意味着我们随便求出一个 n 就好了？ 比如我们求出 n = 2 的时候的值，是不是就知道 n 为任意数的值了。 我们不难想出 n = 2 时候，概率是 0.5，因此只要 n 大于 1 就是 0.5 概率，否则就是 1 概率。

##### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else .5

```

#### 关键点

- 概率分析
- 数学推导
- 动态规划
- 递归 + mapper
- 栈限制大小
- 尾递归

### [1260].shift-2d-grid

#### 题目地址(1260. 二维网格迁移)

https://leetcode-cn.com/problems/shift-2d-grid/description/

```

给你一个 n 行 m 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。

每次「迁移」操作将会引发下述活动：

位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。
位于 grid[i][m - 1] 的元素将会移动到 grid[i + 1][0]。
位于 grid[n - 1][m - 1] 的元素将会移动到 grid[0][0]。
请你返回 k 次迁移操作后最终得到的 二维网格。



示例 1：



输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[9,1,2],[3,4,5],[6,7,8]]
示例 2：



输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
示例 3：

输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
输出：[[1,2,3],[4,5,6],[7,8,9]]


提示：

1 <= grid.length <= 50
1 <= grid[i].length <= 50
-1000 <= grid[i][j] <= 1000
0 <= k <= 100


```

#### 暴力法

我们直接翻译题目，没有任何 hack 的做法。

##### 代码

```python
from copy import deepcopy

class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        n = len(grid)
        m = len(grid[0])
        for _ in range(k):
            old = deepcopy(grid)
            for i in range(n):
                for j in range(m):
                    if j == m - 1:
                            grid[(i + 1) % n][0] = old[i][j]
                    elif i == n - 1 and j == m - 1:
                        grid[0][0] = old[i][j]
                    else:
                        grid[i][j + 1] = old[i][j]
        return grid
```

由于是 easy，上述做法勉强可以过，我们考虑优化。

#### 数学分析

##### 思路

我们仔细观察矩阵会发现，其实这样的矩阵迁移是有规律的。 如图：
![image](https://user-images.githubusercontent.com/12479470/72203575-4f6e4c00-34a8-11ea-8765-03fc856d4ea6.png)

因此这个问题就转化为我们一直的一维矩阵转移问题，LeetCode 也有原题[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)，同时我也写了一篇文章[文科生都能看懂的循环移位算法](https://lucifer.ren/blog/2019/12/11/rotate-list/)专门讨论这个，最终我们使用的是三次旋转法，相关数学证明也有写，很详细，这里不再赘述。

LeetCode 真的是喜欢换汤不换药呀 😂

##### 代码

Python 代码：

```python
#
### @lc app=leetcode.cn id=1260 lang=python3
#
### [1260] 二维网格迁移
### ### @lc code=start


class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        n = len(grid)
        m = len(grid[0])
        ### 二维到一维
        arr = [grid[i][j] for i in range(n) for j in range(m)]
        ### 取模，缩小k的范围，避免无意义的运算
        k %= m * n
        res = []
        ### 首尾交换法

        def reverse(l, r):
            while l < r:
                t = arr[l]
                arr[l] = arr[r]
                arr[r] = t
                l += 1
                r -= 1
        ### 三次旋转
        reverse(0, m * n - k - 1)
        reverse(m * n - k, m * n - 1)
        reverse(0, m * n - 1)
        ### 一维到二维
        row = []
        for i in range(m * n):
            if i > 0 and i % m == 0:
                res.append(row)
                row = []
            row.append(arr[i])
        res.append(row)

        return res

### @lc code=end

```

### [1261].find-elements-in-a-contaminated-binary-tree (1261. 在受污染的二叉树中查找元素)

https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/submissions/

```
给出一个满足下述规则的二叉树：

root.val == 0
如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1
如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2
现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。

请你先还原二叉树，然后实现 FindElements 类：

FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。
bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。


示例 1：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasy4qroxoj308w03b3yi.jpg)

输入：
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
输出：
[null,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1]);
findElements.find(1); // return False
findElements.find(2); // return True
示例 2：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasy5mlo3mj30b405iwep.jpg)

输入：
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
输出：
[null,true,true,false]
解释：
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
示例 3：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasy5sr25yj308i07maa8.jpg)

输入：
["FindElements","find","find","find","find"]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
输出：
[null,true,false,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True


提示：

TreeNode.val == -1
二叉树的高度不超过 20
节点的总数在 [1, 10^4] 之间
调用 find() 的总次数在 [1, 10^4] 之间
0 <= target <= 10^6

```

#### 暴力法

##### 思路

最简单想法就是递归建立树，然后 find 的时候递归查找即可，代码也很简单。

##### 代码

Pythpn Code:

```python
### Definition for a binary tree node.
### class TreeNode:
###     def __init__(self, x):
###         self.val = x
###         self.left = None
###         self.right = None

class FindElements:
    node = None
    def __init__(self, root: TreeNode):
        def recover(node):
            if not node:
                return node;
            if node.left:
                node.left.val =  2 * node.val + 1
            if node.right:
                 node.right.val = 2 * node.val + 2
            recover(node.left)
            recover(node.right)
            return node
        root.val = 0
        self.node = recover(root)


    def find(self, target: int) -> bool:
        def findInTree(node, target):
            if not node:
                return False
            if node.val == target:
                return True
            return findInTree(node.left, target) or findInTree(node.right, target)
        return findInTree(self.node, target)




### Your FindElements object will be instantiated and called as such:
### obj = FindElements(root)
### param_1 = obj.find(target)
```

上述代码会超时，我们来考虑优化。

#### 空间换时间

##### 思路

上述代码会超时，我们考虑使用空间换时间。 建立树的时候，我们将所有值存到一个集合中去。当需要 find 的时候，我们直接查找 set 即可，时间复杂度 O(1)。

##### 代码

```python
### Definition for a binary tree node.
### class TreeNode:
###     def __init__(self, x):
###         self.val = x
###         self.left = None
###         self.right = None

class FindElements:
    def __init__(self, root: TreeNode):
        ### set 不能放在init外侧。 因为测试用例之间不会销毁FindElements的变量
        self.seen = set()
        def recover(node):
            if not node:
                return node;
            if node.left:
                node.left.val =  2 * node.val + 1
                self.seen.add(node.left.val)
            if node.right:
                 node.right.val = 2 * node.val + 2
                 self.seen.add(node.right.val)
            recover(node.left)
            recover(node.right)
            return node
        root.val = 0
        self.seen.add(0)
        self.node = recover(root)


    def find(self, target: int) -> bool:
        return target in self.seen




### Your FindElements object will be instantiated and called as such:
### obj = FindElements(root)
### param_1 = obj.find(target)
```

这种解法可以 AC，但是在数据量非常大的时候，可能 MLE，我们继续考虑优化。

#### 二进制法

##### 思路

这是一种非常巧妙的做法。

如果我们把树中的数全部加 1 会怎么样？

![](https://tva1.sinaimg.cn/large/006tNbRwly1gasypfuvuvj30rs0kudjr.jpg)
(图参考 https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/discuss/431229/Python-Special-Way-for-find()-without-HashSet-O(1)-Space-O(logn)-Time)

仔细观察发现，每一行的左右子树分别有不同的前缀：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasz0x09koj312y0sgnnt.jpg)

Ok，那么算法就来了。为了便于理解，我们来举个具体的例子，比如 target 是 9，我们首先将其加 1，二进制表示就是 1010。不考虑第一位，就是 010，我们只要：

- 0 向左 👈
- 1 向右 👉
- - 0 向左 👈

就可以找到 9 了。

> 0 表示向左 ， 1 表示向右

##### 代码

```python
### Definition for a binary tree node.
### class TreeNode:
###     def __init__(self, x):
###         self.val = x
###         self.left = None
###         self.right = None

class FindElements:
    node = None
    def __init__(self, root: TreeNode):
        def recover(node):
            if not node:
                return node;
            if node.left:
                node.left.val =  2 * node.val + 1
            if node.right:
                 node.right.val = 2 * node.val + 2
            recover(node.left)
            recover(node.right)
            return node
        root.val = 0
        self.node = recover(root)


    def find(self, target: int) -> bool:
        node = self.node
        for bit in bin(target+1)[3:]:
            node = node and (node.left, node.right)[int(bit)]
        return bool(node)




### Your FindElements object will be instantiated and called as such:
### obj = FindElements(root)
### param_1 = obj.find(target)
```

#### 关键点解析

- 空间换时间
- 二进制思维
- 将 target + 1

### [1262].greatest-sum-divisible-by-three (1262. 可被三整除的最大和)

https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/description/

```
给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。



示例 1：

输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18(可被 3 整除的最大和)。
示例 2：

输入：nums = [4]
输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。
示例 3：

输入：nums = [1,2,3,4,4]
输出：12
解释：选出数字 1, 3, 4 以及 4，它们的和是 12(可被 3 整除的最大和)。


提示：

1 <= nums.length <= 4 * 10^4
1 <= nums[i] <= 10^4

```

#### 暴力法

##### 思路

一种方式是找出所有的能够被 3 整除的子集，然后挑选出和最大的。由于我们选出了所有的子集，那么时间复杂度就是 $O(2^N)$ ， 毫无疑问会超时。这里我们使用回溯法找子集，如果不清楚回溯法，可以参考我之前的题解，很多题目都用到了，比如[78.subsets](https://github.com/azl397985856/leetcode/blob/master/problems/78.subsets.md)。

更多回溯题目，可以访问上方链接查看(可以使用一套模板搞定)：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatuu0yfh8j30f60c4ab3.jpg)

##### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        self.res = 0
        def backtrack(temp, start):
            total = sum(temp)
            if total % 3 == 0:
                self.res = max(self.res, total)
            for i in range(start, len(nums)):
                temp.append(nums[i])
                backtrack(temp, i + 1)
                temp.pop(-1)


        backtrack([], 0)

        return self.res
```

#### 减法 + 排序

减法的核心思想是，我们求出总和。如果总和不满足题意，我们尝试减去最小的数，使之满足题意。

##### 思路

这种算法的思想，具体来说就是：

- 我们将所有的数字加起来，我们不妨设为 total
- total 除以 3，得到一个余数 mod， mod 可能值有 0，1，2.
- 同时我们建立两个数组，一个是余数为 1 的数组 one，一个是余数为 2 的数组 two
- 如果 mod 为 0，我们直接返回即可。
- 如果 mod 为 1，我们可以减去 one 数组中最小的一个(如果有的话)，或者减去两个 two 数组中最小的(如果有的话)，究竟减去谁取决谁更小。
- 如果 mod 为 2，我们可以减去 two 数组中最小的一个(如果有的话)，或者减去两个 one 数组中最小的(如果有的话)，究竟减去谁取决谁更小。

由于我们需要取 one 和 two 中最小的一个或者两个，因此对数组 one 和 two 进行排序是可行的，如果基于排序的话，时间复杂度大致为 $O(NlogN)$，这种算法可以通过。

以题目中的例 1 为例：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatvdy1zb1j30u00x2wgx.jpg)

以题目中的例 2 为例：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gatvem1xm4j30u00xvq59.jpg)

##### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        one = []
        two = []
        total = 0

        for num in nums:
            total += num
            if num % 3 == 1:
                one.append(num)
            if num % 3 == 2:
                two.append(num)
        one.sort()
        two.sort()
        if total % 3 == 0:
            return total
        elif total % 3 == 1 and one:
            if len(two) >= 2 and one[0] > two[0] + two[1]:
                return total - two[0] - two[1]
            return total - one[0]
        elif total % 3 == 2 and two:
            if len(one) >= 2 and two[0] > one[0] + one[1]:
                return total - one[0] - one[1]
            return total - two[0]
        return 0
```

#### 减法 + 非排序

##### 思路

上面的解法使用到了排序。 我们其实观察发现，我们只是用到了 one 和 two 的最小的两个数。因此我们完全可以在线形的时间和常数的空间完成这个算法。我们只需要分别记录 one 和 two 的最小值和次小值即可，在这里，我使用了两个长度为 2 的数组来表示，第一项是最小值，第二项是次小值。

##### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        one = [float('inf')] * 2
        two = [float('inf')] * 2
        total = 0

        for num in nums:
            total += num
            if num % 3 == 1:
                if num < one[0]:
                    t = one[0]
                    one[0] = num
                    one[1] = t
                elif num < one[1]:
                    one[1] = num
            if num % 3 == 2:
                if num < two[0]:
                    t = two[0]
                    two[0] = num
                    two[1] = t
                elif num < two[1]:
                    two[1] = num
        if total % 3 == 0:
            return total
        elif total % 3 == 1 and one:
            if len(two) >= 2 and one[0] > two[0] + two[1]:
                return total - two[0] - two[1]
            return total - one[0]
        elif total % 3 == 2 and two:
            if len(one) >= 2 and two[0] > one[0] + one[1]:
                return total - one[0] - one[1]
            return total - two[0]
        return 0
```

#### 有限状态机

##### 思路

我在[数据结构与算法在前端领域的应用 - 第二篇](https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/) 中讲到了有限状态机。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatub3vftxj30eq0bfta0.jpg)

状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。

状态机使用非常广泛，比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。

拿本题中来说，我们从左到右扫描数组的过程，将会不断改变状态机的状态。

我们使用 state 数组来表示本题的状态：

- state[0] 表示 mod 为 0 的 最大和
- state[1] 表示 mod 为 1 的 最大和
- state[2] 表示 mod 为 1 的 最大和

我们的状态转移方程就会很容易。说到状态转移方程，你可能会想到动态规划。没错！这种思路可以直接翻译成动态规划，算法完全一样。如果你看过我上面提到的文章，那么状态转移方程对你来说就会很容易。如果你不清楚，那么请往下看：

- 我们从左往右不断读取数字，我们不妨设这个数字为 num。
- 如果 num % 3 为 0。 那么我们的 state[0], state[1], state[2] 可以直接加上 num(题目限定了 num 为非负)， 因为任何数字加上 3 的倍数之后，mod 3 的值是不变的。
- 如果 num % 3 为 1。 我们知道 state[2] + num 会变成一个能被三整除的数，但是这个数字不一定比当前的 state[0]大。 代码表示就是`max(state[2] + num, state[0])`。同理 state[1] 和 state[2] 的转移逻辑类似。
- 同理 num % 3 为 2 也是类似的逻辑。
- 最后我们返回 state[0]即可。

##### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        state = [0, float('-inf'), float('-inf')]

        for num in nums:
            if num % 3 == 0:
                state = [state[0] + num, state[1] + num, state[2] + num]
            if num % 3 == 1:
                a = max(state[2] + num, state[0])
                b = max(state[0] + num, state[1])
                c = max(state[1] + num, state[2])
                state = [a, b, c]
            if num % 3 == 2:
                a = max(state[1] + num, state[0])
                b = max(state[2] + num, state[1])
                c = max(state[0] + num, state[2])
                state = [a, b, c]
        return state[0]
```

当然这个代码还可以简化：

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        state = [0, float('-inf'), float('-inf')]

        for num in nums:
            temp = [0] * 3
            for i in range(3):
                temp[(i + num) % 3] = max(state[(i + num) % 3], state[i] + num)
            state = temp

        return state[0]
```

#### 关键点解析

- 贪婪法
- 状态机
- 数学分析

#### 扩展

实际上，我们可以采取加法(贪婪策略)，感兴趣的可以试一下。

### [1297].maximum-number-of-occurrences-of-a-substring(1297. 子串的最大出现次数)

https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring

```
给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：

子串中不同字母的数目必须小于等于 maxLetters 。
子串的长度必须大于等于 minSize 且小于等于 maxSize 。


示例 1：

输入：s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
输出：2
解释：子串 "aab" 在原字符串中出现了 2 次。
它满足所有的要求：2 个不同的字母，长度为 3 (在 minSize 和 maxSize 范围内)。
示例 2：

输入：s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
输出：2
解释：子串 "aaa" 在原字符串中出现了 2 次，且它们有重叠部分。
示例 3：

输入：s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
输出：3
示例 4：

输入：s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
输出：0


提示：

1 <= s.length <= 10^5
1 <= maxLetters <= 26
1 <= minSize <= maxSize <= min(26, s.length)
s 只包含小写英文字母。
```

#### 暴力法

题目给的数据量不是很大，为 1 <= maxLetters <= 26，我们试一下暴力法。

##### 思路

暴力法如下：

- 先找出所有满足长度大于等于 minSize 且小于等于 maxSize 的所有子串。(平方的复杂度)
- 对于 maxLetter 满足题意的子串，我们统计其出现次数。时间复杂度为 O(k),其中 k 为子串长度
- 返回最大的出现次数

##### 代码

Pythpn Code:

```python
class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        n = len(s)
        letters = set()
        cnts = dict()
        res = 0
        for i in range(n - minSize + 1):
            length = minSize
            while i + length <= n and length <= maxSize:
                t = s[i:i + length]
                for c in t:
                    if len(letters) > maxLetters:
                        break
                    letters.add(c)
                if len(letters) <= maxLetters:
                    cnts[t] = cnts.get(t, 0) + 1
                    res = max(res, cnts[t])
                letters.clear()
                length += 1
        return res
```

上述代码会超时。我们来利用剪枝来优化。

#### 剪枝

##### 思路

还是暴力法的思路，不过我们在此基础上进行一些优化。首先我们需要仔细阅读题目，如果你足够细心或者足够有经验，可能会发现其实题目中 maxSize 没有任何用处，属于干扰信息。

也就是说我们没有必要统计`长度大于等于 minSize 且小于等于 maxSize 的所有子串`，而是统计长度为 minSize 的所有字串即可。原因是，如果一个大于 minSize 长度的字串若是满足条件，那么该子串其中必定有至少一个长度为 minSize 的字串满足条件。因此一个大于 minSize 长度的字串出现了 n 次，那么该子串其中必定有一个长度为 minSize 的子串出现了 n 次。

##### 代码

代码支持 Java：

```java
 public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {
    Map<String, Integer> counter = new HashMap<>();
    int res = 0;
    for (int i = 0; i < s.length() - minSize + 1; i++) {
        String substr = s.substring(i, i + minSize);
        if (checkNum(substr, maxLetters)) {
            int newVal = counter.getOrDefault(substr, 0) + 1;
            counter.put(substr, newVal);
            res = Math.max(res, newVal);
        }
    }
    return res;
}
public boolean checkNum(String substr, int maxLetters) {
    Set<Character> set = new HashSet<>();
    for (int i = 0; i < substr.length(); i++)
        set.add(substr.charAt(i));
    return set.size() <= maxLetters;
}

```

#### 关键点解析

- 滑动窗口
- 识别题目干扰信息
- 看题目限制条件，对于本题有用的信息是`1 <= maxLetters <= 26`

#### 扩展

我们也可以使用滑动窗口来解决，感兴趣的可以试试看。

### [1310].xor-queries-of-a-subarray(1310. 子数组异或查询)

https://leetcode-cn.com/problems/xor-queries-of-a-subarray

```
有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。

对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值(即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri])作为本次查询的结果。

并返回一个包含给定查询 queries 所有结果的数组。



示例 1：

输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
输出：[2,7,14,8]
解释：
数组中元素的二进制表示形式是：
1 = 0001
3 = 0011
4 = 0100
8 = 1000
查询的 XOR 值为：
[0,1] = 1 xor 3 = 2
[1,2] = 3 xor 4 = 7
[0,3] = 1 xor 3 xor 4 xor 8 = 14
[3,3] = 8
示例 2：

输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
输出：[8,0,4,4]


提示：

1 <= arr.length <= 3 * 10^4
1 <= arr[i] <= 10^9
1 <= queries.length <= 3 * 10^4
queries[i].length == 2
0 <= queries[i][0] <= queries[i][1] < arr.length
```

#### 暴力法

##### 思路

最直观的思路是双层循环即可，果不其然超时了。

##### 代码

```python

class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
 		res = []
        for (L, R) in queries:
            i = L
            xor = 0
            while i <= R:
                xor ^= arr[i]
                i += 1
            res.append(xor)
        return res
```

#### 前缀表达式

##### 思路

比较常见的是前缀和，这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。

对 [1,2,3,4,5,6] 来说，其前缀和可以是 pre=[1,3,6,10,15,21]。我们可以使用公式 pre[𝑖]=pre[𝑖−1]+nums[𝑖]得到每一位前缀和的值，从而通过前缀和进行相应的计算和解题。其实前缀和的概念很简单，但困难的是如何在题目中使用前缀和以及如何使用前缀和的关系来进行解题。

这道题是前缀对前缀异或，我们利用了异或的性质 `x ^ y ^ x = y`。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqll5r048j30fm0bfglz.jpg)

##### 代码

```java
  public int[] xorQueries(int[] arr, int[][] queries) {

        int[] preXor = new int[arr.length];
        preXor[0] = 0;

        for (int i = 1; i < arr.length; i++)
            preXor[i] = preXor[i - 1] ^ arr[i - 1];

        int[] res = new int[queries.length];

        for (int i = 0; i < queries.length; i++) {

            int left = queries[i][0], right = queries[i][1];
            res[i] = arr[right] ^ preXor[right] ^ preXor[left];
        }

        return res;
    }

```

#### 关键点解析

- 异或的性质 x ^ y ^ x = y
- 前缀表达式

### [1332].remove-palindromic-subsequences(1332. 删除回文子序列)

https://leetcode-cn.com/problems/remove-palindromic-subsequences/

```
给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。

返回删除给定字符串中所有字符(字符串为空)的最小删除次数。

「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。

「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。



示例 1：

输入：s = "ababa"
输出：1
解释：字符串本身就是回文序列，只需要删除一次。
示例 2：

输入：s = "abb"
输出：2
解释："abb" -> "bb" -> "".
先删除回文子序列 "a"，然后再删除 "bb"。
示例 3：

输入：s = "baabb"
输出：2
解释："baabb" -> "b" -> "".
先删除回文子序列 "baab"，然后再删除 "b"。
示例 4：

输入：s = ""
输出：0


提示：

0 <= s.length <= 1000
s 仅包含字母 'a'  和 'b'
在真实的面试中遇到过这道题？
```

#### 思路

由于只有 a 和 b 两个字符。其实最多的消除次数就是 2。因为我们无论如何都可以先消除全部的 1 再消除全部的 2(先消除 2 也一样)，这样只需要两次即可完成。 我们再看一下题目给的一次消除的情况，题目给的例子是“ababa”，我们发现其实它本身就是一个回文串，所以才可以一次全部消除。那么思路就有了：

- 如果 s 是回文，则我们需要一次消除
- 否则需要两次
- 一定要注意特殊情况， 对于空字符串，我们需要 0 次

#### 代码

代码支持：Python3

Python3 Code:

```python

class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if s == '':
            return 0
        def isPalindrome(s):
            l = 0
            r = len(s) - 1
            while l < r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True
        return 1 if isPalindrome(s) else 2
```

如果你觉得判断回文不是本题重点，也可以简单实现：

Python3 Code:

```python
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if s == '':
            return 0
        return 1 if s == s[::-1] else 2

```

#### 关键点解析

- 注意审题目，一定要利用题目条件“只含有 a 和 b 两个字符”否则容易做的很麻烦

### [1334].find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance(1334. 阈值距离内邻居最少的城市)

https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/

```
有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。

返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。

注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。



示例 1：

```

![image.png](http://ww1.sinaimg.cn/large/e9f490c8ly1gbh9v5ygtsj20qo0k0aap.jpg)

```



输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
输出：3
解释：城市分布图如上。
每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：
城市 0 -> [城市 1, 城市 2]
城市 1 -> [城市 0, 城市 2, 城市 3]
城市 2 -> [城市 0, 城市 1, 城市 3]
城市 3 -> [城市 1, 城市 2]
城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。
示例 2：

```

![image.png](http://ww1.sinaimg.cn/large/e9f490c8ly1gbh9vg1w43j20qo0k0js8.jpg)

```

输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
输出：0
解释：城市分布图如上。
每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：
城市 0 -> [城市 1]
城市 1 -> [城市 0, 城市 4]
城市 2 -> [城市 3, 城市 4]
城市 3 -> [城市 2, 城市 4]
城市 4 -> [城市 1, 城市 2, 城市 3]
城市 0 在阈值距离 4 以内只有 1 个邻居城市。


提示：

2 <= n <= 100
1 <= edges.length <= n * (n - 1) / 2
edges[i].length == 3
0 <= fromi < toi < n
1 <= weighti, distanceThreshold <= 10^4
所有 (fromi, toi) 都是不同的。


```

#### 思路

这道题的本质就是：

1. 在一个无向图中寻找每两个城镇的最小距离，我们使用 Floyd-Warshall 算法(英语：Floyd-Warshall algorithm)，中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法。
2. 筛选最小距离不大于  distanceThreshold 的城镇。
3. 统计每个城镇，其满足条件的城镇有多少个
4. 我们找出最少的即可

Floyd-Warshall 算法的时间复杂度和空间复杂度都是$O(N^3)$, 而空间复杂度可以优化到$O(N^2)$。Floyd-Warshall 的基本思想是对于每两个点之间的最小距离，要么经过中间节点 k，要么不经过，我们取两者的最小值，这是一种动态规划思想

#### 代码

代码支持：Python3

Python3 Code:

```python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        ### 构建dist矩阵
        dist = [[float('inf')] * n for _ in  range(n)]
        for i, j, w in edges:
            dist[i][j] = w
            dist[j][i] = w
        for i in range(n):
            dist[i][i] = 0
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

        ### 过滤
        res = 0
        minCnt = float('inf')
        for i in range(n):
            cnt = 0
            for d in dist[i]:
                if d <= distanceThreshold:
                    cnt += 1
            if cnt <= minCnt:
                minCnt = cnt
                res = i
        return res


```

#### 关键点解析

- Floyd-Warshall 算法
- 你可以将本文给的 Floyd-Warshall 算法当成一种解题模板使用

### [874].walking-robot-simulation

#### 题目地址(874. 模拟行走机器人)

https://leetcode-cn.com/problems/walking-robot-simulation/submissions/

```
机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：

-2：向左转 90 度
-1：向右转 90 度
1 <= x <= 9：向前移动 x 个单位长度
在网格上有一些格子被视为障碍物。

第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])

如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。

返回从原点到机器人的最大欧式距离的平方。



示例 1：

输入: commands = [4,-1,3], obstacles = []
输出: 25
解释: 机器人将会到达 (3, 4)
示例 2：

输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出: 65
解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处


提示：

0 <= commands.length <= 10000
0 <= obstacles.length <= 10000
-30000 <= obstacle[i][0] <= 30000
-30000 <= obstacle[i][1] <= 30000
答案保证小于 2 ^ 31


```

#### 思路

这道题之所以是简单难度，是因为其没有什么技巧。你只需要看懂题目描述，然后把题目描述转化为代码即可。

唯一需要注意的是查找障碍物的时候如果你采用的是`线形查找`会很慢，很可能会超时。

> 我实际测试了一下，确实会超时

- 一种方式是使用排序，然后二分查找，如果采用基于比较的排序算法，那么这种算法的瓶颈在于排序本身，也就是$O(NlogN)$。
- 另一种方式是使用集合，将 obstacles 放入集合，然后需要的时候进行查询，查询的时候的时间复杂度为$O(1)$。

这里我们采用第二种方式。

接下来我们来“翻译”一下题目。

- 由于机器人只能往前走。因此机器人往东西南北哪个方向走取决于它的`朝向`。
- 我们使用枚举来表示当前机器人的`朝向`。
- 题目只有两种方式改变`朝向`，一种是左转(-2)，另一种是右转(-1)。
- 题目要求的是机器人在`运动过程中距离原点的最大值`，而不是最终位置距离原点的距离。

为了代码书写简单，我建立了一个直角坐标系。用`机器人的朝向和 x 轴正方向的夹角度数`来作为枚举值，并且这个度数是 `0 <= deg < 360`。我们不难知道，其实这个取值就是`0`, `90`,`180`,`270` 四个值。那么当 0 度的时候，我们只需要不断地 x+1，90 度的时候我们不断地 y + 1 等等。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbdnsywx97j31020r8gmt.jpg)

#### 关键点解析

- 理解题意，这道题容易理解错题意，求解为`最终位置距离原点的距离`
- 建立坐标系
- 使用集合简化线形查找的时间复杂度。

#### 代码

代码支持： Python3

Python3 Code:

```python
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        pos = [0, 0]
        deg = 90
        ans = 0
        obstaclesSet = set(map(tuple, obstacles))

        for command in commands:
            if command == -1:
                deg = (deg + 270) % 360
            elif command == -2:
                deg = (deg + 90) % 360
            else:
                if deg == 0:
                    i = 0
                    while i < command and not (pos[0] + 1, pos[1]) in obstaclesSet:
                        pos[0] += 1
                        i += 1
                if deg == 90:
                    i = 0
                    while i < command and not (pos[0], pos[1] + 1) in obstaclesSet:
                        pos[1] += 1
                        i += 1
                if deg == 180:
                    i = 0
                    while i < command and not (pos[0] - 1, pos[1]) in obstaclesSet:
                        pos[0] -= 1
                        i += 1
                if deg == 270:
                    i = 0
                    while i < command and not (pos[0], pos[1] - 1) in obstaclesSet:
                        pos[1] -= 1
                        i += 1
                ans = max(ans, pos[0] ** 2 + pos[1] ** 2)
        return ans
```
