---
layout: CustomPages
title: LeetCode-合集 4
date: 2020-09-04
aside: false
draft: true
---

### [2].两数相加 addTwoNumbers

- 链表

给出两个非空的`链表`用来表示两个非负的整数。其中，它们各自的位数是按照**逆序**的方式存储的，并且它们的每个节点只能存储一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

#### 思路

设立一个表示进位的变量 carried，建立一个新链表，
把输入的两个链表从头往后同时处理，每两个相加，将结果加上 carried 后的值作为一个新节点到新链表后面。

#### 关键点解析

1. 链表这种数据结构的特点和使用
2. 用一个 carried 变量来实现进位的功能，每次相加之后计算 carried，并用于下一位的计算

#### 代码

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  var carried = 0; // 用于进位
  const head = new ListNode();
  const noop = {
    val: 0,
    next: null,
  };
  let currentL1 = l1;
  let currentL2 = l2;
  let currentNode = head; // 返回的链表的当前node
  let newNode; // 声明在外面节省内存
  let previousNode; // 记录前一个节点，便于删除最后一个节点

  while (currentL1 || currentL2) {
    newNode = new ListNode(0);

    currentNode.val = ((currentL1 || noop).val + (currentL2 || noop).val + carried) % 10;

    currentNode.next = newNode;
    previousNode = currentNode;
    currentNode = newNode;

    if ((currentL1 || noop).val + (currentL2 || noop).val + carried >= 10) {
      carried = 1;
    } else {
      carried = 0;
    }

    currentL1 = (currentL1 || noop).next;
    currentL2 = (currentL2 || noop).next;
  }

  if (carried) {
    // 还有位没进呢
    previousNode.next = new ListNode(carried);
  } else {
    previousNode.next = null;
  }

  return head;
};
```

```js
export default function addTwoNumbers(l1, l2) {
  let carry = false;
  let ans;
  let prev;
  while (l1 || l2 || carry) {
    const val1 = (l1 && l1.val) || 0;
    const val2 = (l2 && l2.val) || 0;
    let sum = val1 + val2;
    if (carry) sum++;
    carry = sum > 9;
    const mod = sum % 10;
    if (ans) {
      prev.next = new ListNode(mod);
      prev = prev.next;
    } else {
      ans = new ListNode(mod);
      prev = ans;
    }
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }
  return ans;
}
```

```js
var addTwoNumbers = function(l1, l2) {
  let HEAD = new ListNode(0);
  let cur = HEAD;
  let p = l1,
    q = l2;
  let carry = 0;
  while (q !== null || p !== null) {
    let x = q === null ? 0 : q.val;
    let y = p === null ? 0 : p.val;
    let sum = carry + x + y;
    carry = Math.floor(sum / 10);
    let val = sum % 10;
    cur.next = new ListNode(val);
    cur = cur.next;
    if (q !== null) {
      q = q.next;
    }
    if (p !== null) {
      p = p.next;
    }
  }
  if (carry) {
    cur.next = new ListNode(carry);
  }
  return HEAD.next;
};
```

```js
function List(arr) {
  let head = new ListNode();
  const guard = head;
  if (arr.length === 0) return guard;
  for (let i = 0; i < arr.length; i++) {
    let temp = new ListNode(arr[i]);
    head.next = temp;
    head = temp;
  }
  return guard.next;
}

function ListNodeToString(listNode) {
  let resp = '';
  let cur = listNode;
  while (cur.next) {
    resp += `${cur.val} -> `;
    cur = cur.next;
  }
  resp += `${cur.val}`;
  console.log(resp);
}

// ListNodeToString(List([2, 3, 4]))

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  var c = 0;
  var ret = new ListNode(0);
  var curr = ret;

  while (l1 || l2) {
    var a = l1 ? l1.val : 0;
    var b = l2 ? l2.val : 0;
    var sum = a + b + c;
    // 商作为向前进的值
    c = Math.floor(sum / 10);
    // 当前位数的节点
    curr.next = new ListNode(sum % 10);
    if (l1) {
      l1 = l1.next;
    }
    if (l2) {
      l2 = l2.next;
    }
    curr = curr.next;
  }
  // 最后需要创建的一位
  if (c) {
    curr.next = new ListNode(c);
  }

  return ret.next;
};

const l1 = List([2, 4, 3]);
const l2 = List([5, 6, 4]);
const l3 = addTwoNumbers(l1, l2);
ListNodeToString(l3);
```

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  let head = new ListNode(0);
  let cur = head;
  let curry = 0;

  while (true) {
    let sum = curry;
    sum += l1 ? l1.val : 0;
    sum += l2 ? l2.val : 0;
    cur.val = sum % 10;
    curry = parseInt(sum / 10);
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
    if (l1 != null || l2 != null) {
      cur.next = new ListNode(0);
      cur = cur.next;
    } else {
      break;
    }
  }
  if (curry != 0) {
    cur.next = new ListNode(0);
    cur = cur.next;
    cur.val = curry;
  }
  return head;
};

var l1 = new ListNode(1);
l1.next = new ListNode(8);

var l2 = new ListNode(0);

console.log(addTwoNumbers(l1, l2));
```

### [3].无重复字符的最长子串

Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.Given "bbbbb", the answer is "b", with the length of 1. Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

#### 思路

用一个 hashmap 来建立字符和其出现位置之间的映射。

维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。

(1)如果当前遍历到的字符从未出现过，那么直接扩大右边界；

(2)如果当前遍历到的字符出现过，则缩小窗口(左边索引向右移动)，然后继续观察当前遍历到的字符；

(3)重复(1)(2)，直到左边索引无法再移动；

(4)维护一个结果 res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。

#### 关键点

1. 用一个 mapper 记录出现过并且没有被删除的字符
2. 用一个滑动窗口记录当前 index 开始的最大的不重复的字符序列
3. 用 res 去记录目前位置最大的长度，每次滑动窗口更新就去决定是否需要更新 res

```js
var lengthOfLongestSubstring = function(s) {
  const mapper = {}; // 记录已经出现过的charactor
  let res = 0;
  let slidingWindow = [];

  for (let c of s) {
    if (mapper[c]) {
      // 已经出现过了
      // 则删除
      const delIndex = slidingWindow.findIndex(_c => _c === c);

      for (let i = 0; i < delIndex; i++) {
        mapper[slidingWindow[i]] = false;
      }

      slidingWindow = slidingWindow.slice(delIndex + 1).concat(c);
    } else {
      // 新字符
      if (slidingWindow.push(c) > res) {
        res = slidingWindow.length;
      }
    }
    mapper[c] = true;
  }
  return res;
};
```

```js
var lengthOfLongestSubstring = function(s) {
  var start = 0; // 非重复字符串开始索引
  var max = 0; // 最长字符串长度
  var visitedCharByPosition = {};

  for (var position = 0; position < s.length; position++) {
    var nextChar = s[position];
    if (nextChar in visitedCharByPosition && visitedCharByPosition[nextChar] >= start) {
      // 有重复，非重复字符串索引从下一个 index 开始
      start = visitedCharByPosition[nextChar] + 1;
      visitedCharByPosition[nextChar] = position;
    } else {
      visitedCharByPosition[nextChar] = position;
      // 非重复，求非重复值
      max = Math.max(max, position + 1 - start);
    }
  }
  return max;
};

console.log(lengthOfLongestSubstring('au'));
```

```js
var lengthOfLongestSubstring = function(s) {
  let res = '';
  let l = 0;
  for (let i = 0; i < s.length; i++) {
    if (res.includes(s[i])) {
      res = res.slice(res.indexOf(s[i]) + 1);
    }
    res += s[i];
    l = Math.max(res.length, l);
  }
  return l;
};
```

```js
var lengthOfLongestSubstring = function(s) {
  var len = s.length,
    max = 0,
    chars = new Set(),
    leftBound = 0,
    ch,
    i;

  for (i = 0; i < len; i++) {
    ch = s.charAt(i);

    if (chars.has(ch)) {
      // find the repeating character
      while (leftBound < i && s.charAt(leftBound) !== ch) {
        chars.delete(s.charAt(leftBound));
        leftBound++;
      }

      leftBound++;
    } else {
      chars.add(ch);
      max = Math.max(max, i - leftBound + 1);
    }
  }

  return max;
};
```

### [4].寻找两个有序数组的中位数 median-of-two-sorted-arrays

```js
/*
 * @lc app=leetcode.cn id=4 lang=javascript
 *
 * [4] 寻找两个有序数组的中位数
 */
// 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

// 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)) 。

// 你可以假设 nums1 和 nums2 不会同时为空。

// 示例 1:

// nums1 = [1, 3]
// nums2 = [2]

// 则中位数是 [2].0
// 示例 2:

// nums1 = [1, 2]
// nums2 = [3, 4]

// 则中位数是(2 + 3) / 2 = [2].5
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */

//  TODO: 二分查找
//  24% 16%
var findMedianSortedArrays = function(nums1, nums2) {
  // 合并数组
  let nums = [...nums1, ...nums2];

  // 排序(有时间复杂度要求，那应该是要快排或者归并排序了)
  nums = nums.sort((a, b) => a - b);

  // 计算中位数
  const length = nums.length;
  return length % 2 === 0 ? (nums[length / 2] + nums[length / 2 - 1]) / 2 : nums[parseInt(length / 2)];
};

const swap = (arr, i, j) => {
  [arr[i], arr[j]] = [arr[j], arr[i]];
};

// let nums1 = [1, 3], nums2 = [2]

// console.log(findMedianSortedArrays(nums1, nums2))

// nums1 = [1, 2]
// nums2 = [3, 4]

// console.log(findMedianSortedArrays(nums1, nums2))

// nums1 = [2]
// nums2 = []

// console.log(findMedianSortedArrays(nums1, nums2))

// nums1 = []
// nums2 = [1, 2, 3, 4]

// console.log(findMedianSortedArrays(nums1, nums2))

nums1 = [3];
nums2 = [-2, -1];

console.log(findMedianSortedArrays(nums1, nums2));

var newFindMedianSortedArrays = function(nums1, nums2) {};
```

```js
/**
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:
Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)
The solution set must not contain duplicate quadruplets.
    For example, given array S = {1 0 -1 0 -2 2}, and target = [0].

    A solution set is:
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
  nums.sort(function(a, b) {
    return a - b;
  });

  var len = nums.length,
    result = [],
    i;

  kSum(result, [], 4, nums, target, 0, len - 1);

  return result;
};

function kSum(result, curArr, k, nums, target, startIndex, endIndex) {
  var len = nums.length,
    start,
    end,
    sum,
    i;

  if (k >= 3) {
    for (i = startIndex; i <= endIndex; i++) {
      if (i > startIndex && nums[i] === nums[i - 1]) {
        continue;
      }

      curArr.push(nums[i]);
      kSum(result, curArr.concat(), k - 1, nums, target - nums[i], i + 1, endIndex);
      curArr.pop();
    }
  }

  if (k === 1) {
    for (i = startIndex; i <= endIndex; i++) {
      if (nums[i] === target) {
        result.push(nums[i]);
      }
    }
  }

  if (k === 2) {
    start = startIndex;
    end = endIndex;

    while (start < end) {
      sum = nums[start] + nums[end];

      if (sum === target) {
        curArr.push(nums[start]);
        curArr.push(nums[end]);
        result.push(curArr.concat());
        curArr.pop();
        curArr.pop();

        start++;
        end--;

        while (nums[start] === nums[start - 1]) {
          start++;
        }

        while (nums[end] === nums[end + 1]) {
          end--;
        }
      } else if (sum < target) {
        start++;
      } else {
        end--;
      }
    }
  }
}
```

```js
/*
 * @lc app=leetcode id=4 lang=javascript
 *
 * [4] Median of Two Sorted Arrays
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
function findKth(nums1, nums2, k) {
  if (nums1.length === 0) return nums2[k - 1];
  if (nums2.length === 0) return nums1[k - 1];
  if (k == 1) return Math.min(nums1[0], nums2[0]);
  let i = Math.min(k >> 1, nums1.length);
  let j = Math.min(k >> 1, nums2.length);
  if (nums1[i - 1] > nums2[j - 1]) {
    return findKth(nums1, nums2.slice(j), k - j);
  }

  return findKth(nums1.slice(i), nums2, k - i);
}
var findMedianSortedArrays = function(nums1, nums2) {
  // 1
  // 2 3 4 5
  const m = nums1.length,
    n = nums2.length;
  return (findKth(nums1, nums2, (m + n + 1) >> 1) + findKth(nums1, nums2, (m + n + 2) >> 1)) / 2.0;
};
```

```js
/**
 * https://leetcode.com/problems/median-of-two-sorted-arrays/description/
 * Difficulty:Hard
 *
 * There are two sorted arrays nums1 and nums2 of size m and n respectively.
 * Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
 *
 * Example 1:
 * nums1 = [1, 3]
 * nums2 = [2]
 * The median is [2].0
 *
 * Example 2:
 * nums1 = [1, 2]
 * nums2 = [3, 4]
 * The median is (2 + 3)/2 = [2].5
 * *
 */

function kth(arr1, s1, n1, arr2, s2, n2, k) {
  // console.log(arr1, s1, n1, arr2, s2, n2, k);
  // console.log('-----------');
  if (k < 1 || k > n1 + n2) return -1;

  if (n1 > n2) {
    return kth(arr2, s2, n2, arr1, s1, n1, k);
  }

  if (n1 === 0) {
    return arr2[s2 + k - 1];
  }

  if (k === 1) {
    return arr1[s1] < arr2[s2] ? arr1[s1] : arr2[s2];
  }

  var newK = k >> 1;

  if (n1 < newK) {
    newK = n1;
  }

  if (arr1[s1 + newK - 1] < arr2[s2 + newK - 1]) {
    return kth(arr1, s1 + newK, n1 - newK, arr2, s2, n2, k - newK);
  } else {
    return kth(arr1, s1, n1, arr2, s2 + newK, n2 - newK, k - newK);
  }
}

// var arr1 = [2, 3, 6, 7, 9];
// var arr2 = [1, 4, 8, 10];
// console.log([...arr1, ...arr2].sort(function (a, b) {
//     if (a > b) return 1;
//     if (a < b) return -1;
//     return 0;
// }));
//
// console.log('=======');
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 1), 1);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 2), 2);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 3), 3);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 4), 4);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 5), 6);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 6), 7);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 7), 8);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 8), 9);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 9), 10);

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  var n1 = nums1.length;
  var n2 = nums2.length;

  var mid = Math.floor((n1 + n2) / 2);
  if ((n1 + n2) % 2 === 0) {
    return (kth(nums1, 0, n1, nums2, 0, n2, mid) + kth(nums1, 0, n1, nums2, 0, n2, mid + 1)) / 2;
  } else {
    return kth(nums1, 0, n1, nums2, 0, n2, mid + 1);
  }
};

console.log(findMedianSortedArrays([1, 3, 4], [2, 5]));
console.log(findMedianSortedArrays([1, 3, 4], [2, 5, 6]));
```

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}  12345
 */
var findMedianSortedArrays = function(nums1, nums2) {
  if (nums1.length == 0 || nums2.length == 0) {
    if ((nums1.length + nums2.length) % 2 == 1) {
      const index = parseInt((nums1.length + nums2.length) / 2);
      return nums2.length == 0 ? nums1[index] : nums2[index];
    } else {
      let nums = nums2.length == 0 ? nums1 : nums2;
      const index = nums.length / 2;
      return (nums[index - 1] + nums[index]) / 2;
    }
  }

  if (nums1.length > nums2.length) {
    swap(nums1, nums2);
  }
  const M = nums1.length,
    N = nums2.length;
  let min = 0,
    max = M,
    half = parseInt((M + N + 1) / 2); // 连个数组合并的中间值
  while (min <= max) {
    let i = parseInt((min + max) / 2); // nums1 的索引值
    let j = half - i; // num2 的索引值
    if (i < max && nums2[j - 1] > nums1[i]) {
      min++;
    } else if (i > min && nums1[i - 1] > nums2[j]) {
      max--;
    } else {
      let maxLeft = 0;
      if (i == 0) {
        maxLeft = nums2[j - 1];
      } else if (j == 0) {
        maxLeft = nums1[i - 1];
      } else {
        maxLeft = Math.max(nums1[i - 1], nums2[j - 1]);
      }
      if ((M + N) % 2 == 1) {
        return maxLeft;
      }
      let minRight = 0;
      if (i == M) {
        minRight = nums2[j];
      } else if (j == N) {
        minRight = nums1[i];
      } else {
        minRight = Math.min(nums1[i], nums2[j]);
      }
      return (maxLeft + minRight) / 2;
    }
  }
  return 0;
};

function swap(a, b) {
  let tmp = a;
  a = b;
  b = tmp;
}

const nums1 = [4, 5];
const nums2 = [1, 2, 3];
findMedianSortedArrays(nums1, nums2);

/**
 * 实现思路
 * 先排除空数组的情况
 * 数组从小到大排序
 * 取小数组的中间值
 * 取大数组的索引 = 总中间值-小数组中间值
 * 循环直到符合条件
 * 如果都不符合条件，那么说明中间值在两个数组的左边或者右边
 */
```

### [5].最长回文 longest-palindromic-substring

#### 思路

这是一道最长回文的题目，要我们求出给定字符串的最大回文子串。

解决这类问题的核心思想就是两个字“延伸”，具体来说

- 如果一个字符串是回文串，那么在它左右分别加上一个相同的字符，那么它一定还是一个回文串
- 如果一个字符串不是回文串，或者在回文串左右分别加不同的字符，得到的一定不是回文串

事实上，上面的分析已经建立了大问题和小问题之间的关联，
基于此，我们可以建立动态规划模型。

我们可以用 dp[i][j] 表示 s 中从 i 到 j(包括 i 和 j)是否可以形成回文，
状态转移方程只是将上面的描述转化为代码即可：

```js
if (s[i] === s[j] && dp[i + 1][j - 1]) {
  dp[i][j] = true;
}
```

base case 就是一个字符(轴对称点是本身)，或者两个字符(轴对称点是介于两者之间的虚拟点)。

#### 关键点

- ”延伸“(extend)

#### 代码

```js
/*
 * @lc app=leetcode id=5 lang=javascript
 *
 * [5] Longest Palindromic Substring
 */
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  // babad
  // tag : dp
  if (!s || s.length === 0) return '';
  let res = s[0];

  const dp = [];

  // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]
  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = [];
    for (let j = i; j < s.length; j++) {
      if (j - i === 0) dp[i][j] = true;
      // specail case 1
      else if (j - i === 1 && s[i] === s[j]) dp[i][j] = true;
      // specail case 2
      else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        // state transition
        dp[i][j] = true;
      }

      if (dp[i][j] && j - i + 1 > res.length) {
        // update res
        res = s.slice(i, j + 1);
      }
    }
  }

  return res;
};
```



给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"

```js
var longestPalindrome = function(str) {
  const n = str.length;
  if (n < 2) return str;
  let s = 0,
    e = 0;
  // 表示子串是否是回文串
  let dp = [0];
  for (let j = 0; j < n; ++j) {
    for (let i = 0; i < j; ++i) {
      if (!(dp[i] = dp[i + 1] || str[i] != str[j]) && e - s <= j - i) (s = i), (e = j);
    }
  }
  return str.substr(s, e - s + 1);
};
```

```js
var longestPalindrome = function(s) {
  var len = s.length,
    isPal = [],
    max = 1,
    start = 0,
    end = 0,
    i,
    j;

  for (i = 0; i < len; i++) {
    isPal.push(new Array(len));
    isPal[i][i] = true;
  }

  for (i = len - 1; i >= 0; i--) {
    for (j = i + 1; j < len; j++) {
      if (s.charAt(i) === s.charAt(j) && (j === i + 1 || isPal[i + 1][j - 1])) {
        isPal[i][j] = true;

        if (j - i + 1 > max) {
          start = i;
          end = j;
          max = j - i + 1;
        }
      }
    }
  }

  return s.substring(start, end + 1);
};
```

用 `dp[i][j]` 表示子串 i 到 j 是否是回文，使用动态规划求解：

```cpp
string longestPalindrome(string s) {
	int m = s.size();
	if (m == 0) {
		return "";
	}
	vector<vector<int>> dp(m, vector<int>(m, 0));
	int start = 0;
	int length = 1;

	for (int i = 0; i < m; i++) {
        // 单个字符属于回文，例如 abcd
		dp[i][i] = 1;

        // 连续两个字符相同属于回文，例如 abb
		if (i < m - 1) {
			if (s[i] == s[i + 1]) {
				dp[i][i + 1] = 1;
                start = i;
				length = 2;
			}
		}
	}

	for (int len = 2; len <= m; len++) {
		for (int i = 0; i < m - len; i++) {
			int j = i + len;
            // 扩展长度
			if (dp[i + 1][j - 1] == 1 && s[i] == s[j]) {
				dp[i][j] = 1;

				if (j - i + 1 > length) {
                    start = i;
					length = j - i + 1;
				}
			}
		}
	}

	return s.substr(start, length);
}
```

```js
var longestPalindrome = function(s) {
  var a = new Date();
  var n = s.length;
  var res = '';
  var dp = [];
  while (dp.push(new Array(n).fill(-1)) < n);
  // console.log(dp);

  for (var i = n - 1; i >= 0; i--) {
    for (var j = i; j < n; j++) {
      dp[i][j] = s[i] === s[j] && (j - i < 3 || dp[i + 1][j - 1]);
      if (dp[i][j] === undefined) {
        console.log(i, j, s[i], s[j], dp[i + 1][j - 1]);
      }
      if (dp[i][j]) {
        var tmp = s.substring(i, j + 1);
        if (tmp.length > res.length) res = tmp;
      }
    }
  }
  // console.log(dp);
  console.log(new Date() - a);

  return res;
};

// console.log(isPalindrome(s, 1, 3));
// console.log(longestPalindrome('babad'));
// console.log(longestPalindrome(''));
// console.log(longestPalindrome('a'));
// console.log(longestPalindrome('aabbbbbb'));
console.log(
  longestPalindrome(
    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
  ),
);
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  let maxLength = 0,
    left = 0,
    right = 0;
  for (let i = 0; i < s.length; i++) {
    let singleCharLength = getPalLenByCenterChar(s, i, i);
    let doubleCharLength = getPalLenByCenterChar(s, i, i + 1);
    let max = Math.max(singleCharLength, doubleCharLength);
    if (max > maxLength) {
      maxLength = max;
      left = i - parseInt((max - 1) / 2);
      right = i + parseInt(max / 2);
    }
  }
  return s.slice(left, right + 1);
};

function getPalLenByCenterChar(s, left, right) {
  // 中间值为两个字符，确保两个字符相等
  if (s[left] != s[right]) {
    return right - left; // 不相等返回为1个字符串
  }
  while (left > 0 && right < s.length - 1) {
    // 先加减再判断
    left--;
    right++;
    if (s[left] != s[right]) {
      return right - left - 1;
    }
  }
  return right - left + 1;
}

console.log(longestPalindrome('cbbd'));
```

### [6].

```js
//
// The string "PAYPALISHIRING" is written in a zigzag pattern on a given number
// of rows like this: (you may want to display this pattern in a fixed font for
// better legibility)
//
// P   A   H   N
// A P L S I I G
// Y   I   R
//
// And then read line by line: "PAHNAPLSIIGYIR"
//
// Write the code that will take a string and make this conversion given a
// number of rows:
export default function ZigZag(string: string, number: number): string {
  const output = [];
  const middle = number - Math.floor(number / 2);
  let rowNumber = 0;
  let index = 0;
  let i = 0;

  while (output.length < string.length) {
    output[i] = string[index];

    if (rowNumber !== Math.floor(number / 2)) {
      if (index + number + 1 > string.length) {
        rowNumber++;
        index = rowNumber;
      } else if (number % 2 === 0) {
        index += number;
      } else {
        index += number + 1;
      }
    } else if (index + middle > string.length) {
      rowNumber++;
      index = rowNumber;
    } else {
      index += middle;
    }
    i++;
  }

  return output.join('');
}
```

### [7].整数反转

```js
/*
 * @lc app=leetcode.cn id=7 lang=javascript
 *
 * [7] 整数反转
 */
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  if (x === 0) {
    //超过范围的返回0
    return 0;
  }
  const sign = x > 0;

  let result = 0,
    absValue = Math.abs(x);
  while (absValue !== 0) {
    result = 10 * result + (absValue % 10);
    absValue = parseInt(absValue / 10);
  }
  const MAX = Math.pow(2, 31) - 1;
  const MIN = -1 * Math.pow(2, 31);
  result = x > 0 ? result : -1 * result;
  return result <= MAX && result >= MIN ? result : 0;
};

console.log(reverse(123));
console.log(reverse(-123));
console.log(reverse(120));
console.log(reverse(1534236469));
```

### [10].

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  let dp = [];
  for (let i = 0; i <= s.length; i++) {
    let child = [];
    for (let j = 0; j <= p.length; j++) {
      child.push(false);
    }
    dp.push(child);
  }
  dp[s.length][p.length] = true;

  for (let i = s.length; i >= 0; i--) {
    for (let j = p.length - 1; j >= 0; j--) {
      let first_match = i < s.length && (p[j] == s[i] || p[j] == '.');
      if (j + 1 < p.length && p[j + 1] == '*') {
        dp[i][j] = dp[i][j + 2] || (first_match && dp[i + 1][j]);
      } else {
        dp[i][j] = first_match && dp[i + 1][j + 1];
      }
    }
  }
  console.log(dp);
  return dp[0][0];
};

console.log(isMatch('aab', 'c*a*b'));

/**
先设定右下角为 false

[
    true, false, true, false, false, false,
    true, false, true, false, false, false,
    true, false, true, false, true, false,
    false, false, false, false, false, true
]
 */
```

### [11].container-with-most-water

#### 题目地址

https://leetcode.com/problems/container-with-most-water/description/

#### 题目描述

```
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.
```

```

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.



Example:

Input: [1,8,6,2,5,4,8,3,7]
Output: 49
```

#### 思路

符合直觉的解法是，我们可以对两两进行求解，计算可以承载的水量。 然后不断更新最大值，最后返回最大值即可。
这种解法，需要两层循环，时间复杂度是 O(n^2)

eg:

```js
// 这个解法比较暴力，效率比较低
// 时间复杂度是O(n^2)
let max = 0;
for (let i = 0; i < height.length; i++) {
  for (let j = i + 1; j < height.length; j++) {
    const currentArea = Math.abs(i - j) * Math.min(height[i], height[j]);
    if (currentArea > max) {
      max = currentArea;
    }
  }
}
return max;
```

> 这种符合直觉的解法有点像冒泡排序， 大家可以稍微类比一下

那么有没有更加优的解法呢？我们来换个角度来思考这个问题，上述的解法是通过两两组合，这无疑是完备的，
那我门是否可以先计算长度为 n 的面积，然后计算长度为 n-1 的面积，... 计算长度为 1 的面积。 这样去不断更新最大值呢？
很显然这种解法也是完备的，但是似乎时间复杂度还是 O(n ^ 2), 不要着急。

考虑一下，如果我们计算 n-1 长度的面积的时候,是直接直接排除一半的结果的。

如图：

比如我们计算 n 面积的时候，假如左侧的线段高度比右侧的高度低，那么我们通过左移右指针来将长度缩短为 n-1 的做法是没有意义的，
因为`新的形成的面积变成了(n-1) * heightOfLeft 这个面积一定比刚才的长度为n的面积nn * heightOfLeft 小`

也就是说最大面积`一定是当前的面积或者通过移动短的线段得到`。

#### 关键点解析

- 双指针优化时间复杂度

#### 代码

- 语言支持：JS，C++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=11 lang=javascript
 *
 * [11] Container With Most Water
 *
 * https://leetcode.com/problems/container-with-most-water/description/
 *
 * algorithms
 * Medium (42.86%)
 * Total Accepted:    344.3K
 * Total Submissions: 790.1K
 * Testcase Example:  '[1,8,6,2,5,4,8,3,7]'
 *
 * Given n non-negative integers a1, a2, ..., an , where each represents a
 * point at coordinate (i, ai). n vertical lines are drawn such that the two
 * endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together
 * with x-axis forms a container, such that the container contains the most
 * water.
 *
 * Note: You may not slant the container and n is at least 2.
 *
 *
 *
 *
 *
 * The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In
 * this case, the max area of water (blue section) the container can contain is
 * 49.
 *
 *
 *
 * Example:
 *
 *
 * Input: [1,8,6,2,5,4,8,3,7]
 * Output: 49
 *
 */
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  if (!height || height.length <= 1) return 0;

  // 双指针来进行优化
  // 时间复杂度是O(n)
  let leftPos = 0;
  let rightPos = height.length - 1;
  let max = 0;
  while (leftPos < rightPos) {
    const currentArea = Math.abs(leftPos - rightPos) * Math.min(height[leftPos], height[rightPos]);
    if (currentArea > max) {
      max = currentArea;
    }
    // 更新小的
    if (height[leftPos] < height[rightPos]) {
      leftPos++;
    } else {
      // 如果相等就随便了
      rightPos--;
    }
  }

  return max;
};
```

### [6].ZigZag-Conversion

```js
/**
 *
 * https://leetcode.com/problems/zigzag-conversion/description/
 * Difficulty:Medium
 *
 * The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this:
 * (you may want to display this pattern in a fixed font for better legibility)
 *
 * P   A   H   N
 * A P L S I I G
 * Y   I   R
 * And then read line by line: "PAHNAPLSIIGYIR"
 * Write the code that will take a string and make this conversion given a number of rows:
 * string convert(string text, int nRows);
 * convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".
 *
 */

/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  var arr = [];
  for (var i = 0; i < numRows; i++) {
    arr[i] = [];
  }

  var cnt = 0;
  var len = s.length;

  while (cnt < len) {
    for (var i = 0; i < arr.length && cnt < len; i++) {
      arr[i].push(s[cnt++]);
    }
    for (var i = numRows - 2; i >= 1 && cnt < len; i--) {
      arr[i].push(s[cnt++]);
    }
  }
  // console.log(arr);

  return arr.map(arr => arr.join('')).join('');
};

console.log(convert('PAYPALISHIRING', 3));
```

### [9]. 回文数 Palindrome-Number

```js
var isPalindrome = function(x) {
  if (x < 0) return false;
  var t = x;
  // 绝对值
  x = Math.abs(x);
  var p = 0;
  while (x) {
    p = p * 10 + (x % 10);
    x = Math.floor(x / 10);
  }
  // console.log(x, p);
  return t === p;
};

console.log(isPalindrome(-1) === false);
console.log(isPalindrome(0) === true);
console.log(isPalindrome(123) === false);
console.log(isPalindrome(12321) === true);
console.log(isPalindrome(1221) === true);
console.log(isPalindrome(2222) === true);
```

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
  let str = x + '';
  let left = 0,
    right = str.length - 1;
  while (left < right) {
    if (str[left] != str[right]) return false;
    left++;
    right--;
  }
  return true;
};
```

转成字符串方式

1. 负数都是非回文数，10 的整数倍不是回文。
2. 将数字转为字符串，再逆序排列字符串。两者比较，相等就是回文数。

直接操作整数方式

1. 复制 x 到 temp;
2. 取 temp 末尾数字，方式为 temp 与 10 的求余；组成新数 reverse;
3. 每取完一位,temp 缩小 10 倍并且去掉小数。
4. reverse 要`先扩大十倍`再加上取下来的数
5. 当 temp === 0 时，表示已经取完；reverse 与 x 比较

```js
/**
 * @param {number} x
 * @return {boolean}
 * 转成字符串
 */
var isPalindrome = function(x) {
  if (x < 0) return false;
  if (x === 0) return true;
  if (x % 10 === 0) return false;
  let reverse = '';
  let str = String(x);
  for (let i = str.length - 1; i >= 0; i--) {
    reverse += str[i];
  }
  return str === reverse;
};

/**
 * @param {number} x
 * @return {boolean}
 * 不转成字符串
 */
var isPalindrome = function(x) {
  if (x < 0) return false;
  if (x === 0) return true;
  if (x % 10 === 0) return false;
  let temp = x;
  let reverse = 0;
  while (temp > 0) {
    let num = temp % 10;
    temp = (temp - num) / 10; // 或 temp = (temp / 10) >> 0,去除小数位
    reverse = reverse * 10 + num;
  }
  return x === reverse;
};
```

要求不能使用额外空间，也就不能将整数转换为字符串进行判断。

将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。

```java
public boolean isPalindrome(int x) {
    if (x == 0) {
        return true;
    }
    if (x < 0 || x % 10 == 0) {
        return false;
    }
    int right = 0;
    while (x > right) {
        right = right * 10 + x % 10;
        x /= 10;
    }
    return x == right || x == right / 10;
}
```

### [10].Regular-Expression-Matching

### [11].

```js
// Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

// Note: You may not slant the container and n is at least 2.

/**
 * @param {number[]} height
 * @return {number}
 */
export default function maxArea(height) {
  let width = height.length - 1;
  let lo = 0;
  let hi = height.length - 1;
  let max = 0;
  while (lo < hi) {
    const loVal = height[lo];
    const hiVal = height[hi];
    max = Math.max(max, width * Math.min(hiVal, loVal));
    if (loVal < hiVal) {
      lo++;
    } else {
      hi--;
    }
    width--;
  }
  return max;
}
```

### [14].最长公共前缀

```js
var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  if (strs.length === 1) return strs[0];
  const first = strs[0];
  for (let i = 0; i < first.length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[j][i] !== strs[0][i]) return strs[0].slice(0, i);
    }
  }
  return first;
};

console.log(longestCommonPrefix(['flower', 'flow', 'flight']));
console.log(longestCommonPrefix(['dog', 'racecar', 'car']));
console.log(longestCommonPrefix(['c', 'c']));
```

```js
var longestCommonPrefix = function(strs) {
  if (!strs.length || !strs[0].length) return '';
  let res = '';
  for (let i = 0; i < strs[0].length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[0][i] !== strs[j][i]) {
        return res;
      }
    }
    res += strs[0][i];
  }
  return res;
};
```

### [15].3-sum

#### 题目地址

https://leetcode.com/problems/3sum/description/

#### 题目描述

```
Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]

```

#### 思路

我们采用`分治`的思想. 想要找出三个数相加等于 0，我们可以数组依次遍历，
每一项 a[i]我们都认为它是最终能够用组成 0 中的一个数字，那么我们的目标就是找到
剩下的元素(除 a[i])`两个`相加等于-a[i].

通过上面的思路，我们的问题转化为了`给定一个数组，找出其中两个相加等于给定值`，
这个问题是比较简单的， 我们只需要对数组进行排序，然后双指针解决即可。 加上我们需要外层遍历依次数组，因此总的时间复杂度应该是 O(N^2)。

思路如图所示：

> 在这里之所以要排序解决是因为， 我们算法的瓶颈在这里不在于排序，而在于 O(N^2)，如果我们瓶颈是排序，就可以考虑别的方式了

> 如果找某一个特定元素，一个指针就够了。如果是找两个元素满足一定关系(比如求和等于特定值)，需要双指针，
> 当然前提是数组有序。

#### 关键点解析

- 排序之后，用双指针
- 分治

#### 代码

```js
/*
 * @lc app=leetcode id=15 lang=javascript
 *
 * [15] 3Sum
 *
 * https://leetcode.com/problems/3sum/description/
 *
 * algorithms
 * Medium (23.51%)
 * Total Accepted:    531.5K
 * Total Submissions: 2.2M
 * Testcase Example:  '[-1,0,1,2,-1,-4]'
 *
 * Given an array nums of n integers, are there elements a, b, c in nums such
 * that a + b + c = 0? Find all unique triplets in the array which gives the
 * sum of zero.
 *
 * Note:
 *
 * The solution set must not contain duplicate triplets.
 *
 * Example:
 *
 *
 * Given array nums = [-1, 0, 1, 2, -1, -4],
 *
 * A solution set is:
 * [
 * ⁠ [-1, 0, 1],
 * ⁠ [-1, -1, 2]
 * ]
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  if (nums.length < 3) return [];
  const list = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    // skip duplicated result without set
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let left = i;
    let right = nums.length - 1;

    // for each index i
    // we want to find the triplet [i, left, right] which sum to 0
    while (left < right) {
      // skip i === left or i === right, in that case, the index i will be used twice
      if (left === i) {
        left++;
      } else if (right === i) {
        right--;
      } else if (nums[left] + nums[right] + nums[i] === 0) {
        list.push([nums[left], nums[right], nums[i]]);
        // skip duplicated result without set
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        left++;
        // skip duplicated result without set
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        right--;
        continue;
      } else if (nums[left] + nums[right] + nums[i] > 0) {
        right--;
      } else {
        left++;
      }
    }
  }
  return list;
};
```

### [19].removeNthNodeFromEndofList

#### 题目地址

https://leetcode.com/problems/remove-nth-node-from-end-of-list/description

#### 题目描述

Given a linked list, remove the n-th node from the end of list and return its head.

Example:

Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?

#### 思路

双指针，指针 A 先移动 n 次， 指针 B 再开始移动。当 A 到达 null 的时候， 指针 b 的位置正好是倒数 n

我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。

设置虚拟节点 dummyHead 指向 head

设定双指针 p 和 q，初始都指向虚拟节点 dummyHead

移动 q，直到 p 与 q 之间相隔的元素个数为 n

同时移动 p 与 q，直到 q 指向的为 NULL

将 p 的下一个节点指向下下个节点

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

1. 链表这种数据结构的特点和使用

2. 使用双指针

3. 使用一个 dummyHead 简化操作

#### 代码

```js
/*
 * @lc app=leetcode id=19 lang=javascript
 *
 * [19] Remove Nth Node From End of List
 *
 * https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/
 *
 * algorithms
 * Medium (34.03%)
 * Total Accepted:    360.1K
 * Total Submissions: 1.1M
 * Testcase Example:  '[1,2,3,4,5]\n2'
 *
 * Given a linked list, remove the n-th node from the end of list and return
 * its head.
 *
 * Example:
 *
 *
 * Given linked list: 1->2->3->4->5, and n = 2.
 *
 * After removing the second node from the end, the linked list becomes
 * 1->2->3->5.
 *
 *
 * Note:
 *
 * Given n will always be valid.
 *
 * Follow up:
 *
 * Could you do this in one pass?
 *
 */

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let i = -1;
  const noop = {
    next: null,
  };

  const dummyHead = new ListNode(); // 增加一个dummyHead 简化操作
  dummyHead.next = head;

  let currentP1 = dummyHead;
  let currentP2 = dummyHead;

  while (currentP1) {
    if (i === n) {
      currentP2 = currentP2.next;
    }

    if (i !== n) {
      i++;
    }

    currentP1 = currentP1.next;
  }

  currentP2.next = ((currentP2 || noop).next || noop).next;

  return dummyHead.next;
};
```

### [10].

```js
// [102]. Binary Tree Level Order Traversal

// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

// For example:
// Given binary tree [3,9,20,null,null,15,7],

//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its level order traversal as:

// [
//   [3],
//   [9,20],
//   [15,7]
// ]

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
export default function levelOrder(root) {
  if (!root) return [];
  const queue = [];
  queue.push(root);
  const ans = [];
  const depths = new Map();
  depths.set(root, 0);
  let prev;
  let arr = [];
  while (queue.length) {
    const item = queue.shift();
    const depth = depths.get(item);
    if (!prev || (prev && depths.get(prev) !== depths.get(item))) {
      arr = [];
      ans.push(arr);
    }
    arr.push(item.val);
    if (item.left) {
      depths.set(item.left, depth + 1);
      queue.push(item.left);
    }
    if (item.right) {
      depths.set(item.right, depth + 1);
      queue.push(item.right);
    }
    prev = item;
  }
  return ans;
}
```

### [11].

```js
// [117]. Populating Next Right Pointers in Each Node II

// Given a binary tree

// struct Node {
//   int val;
//   Node *left;
//   Node *right;
//   Node *next;
// }
// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

// Initially, all next pointers are set to NULL.

/**
 * // Definition for a Node.
 * function Node(val,left,right,next) {
 *    this.val = val;
 *    this.left = left;
 *    this.right = right;
 *    this.next = next;
 * };
 */
/**
 * @param {Node} root
 * @return {Node}
 */
export default function connect(root) {
  // BFS
  if (!root) return root;
  const depth = new Map();
  // For each level of tree, point
  const queue = [];
  queue.push(root);
  depth.set(root, 0);
  let prev;
  while (queue.length) {
    const item = queue.shift();
    const d = depth.get(item);
    if (prev && d === depth.get(prev)) {
      prev.next = item;
    } else if (prev) prev.next = null;
    prev = item;
    if (item.left) {
      queue.push(item.left);
      depth.set(item.left, d + 1);
    }
    if (item.right) {
      queue.push(item.right);
      depth.set(item.right, d + 1);
    }
  }
  return root;
}
```

### [14].

```js
// [142]. Linked List Cycle II

// Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

// To represent a cycle in the given linked list, we use an integer pos which represents the position ([0].indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

// Note: Do not modify the linked list.

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function detectCycle(head) {
  let i = 0;
  const map = new Map();
  if (!head) return null;
  let curr = head;
  while (curr && curr.next) {
    map.set(curr, i);
    curr = curr.next;
    if (map.has(curr)) return curr;
    i++;
  }
  return null;
}
```

### [19].

```js
// [199]. Binary Tree Right Side View

// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

// Example:

// Input: [1,2,3,null,5,null,4]
// Output: [1, 3, 4]
// Explanation:

//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

const getDepth = (node, depth, map) => {
  if (!node) return;
  map.set(node, depth);
  if (node.left) getDepth(node.left, depth + 1, map);
  if (node.right) getDepth(node.right, depth + 1, map);
};

export default function rightSideView(root) {
  // BFS from right to left
  const queue = [];
  const map = new Map();
  getDepth(root, 0, map);
  const ans = [];
  if (!root) return [];
  const set = new Set();

  queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    if (map.has(item)) {
      if (item.right) queue.push(item.right);
      if (item.left) queue.push(item.left);
      if (!set.has(map.get(item))) {
        ans.push(item.val);
        set.add(map.get(item));
      }
    }
  }
  return ans;
}
```

### [20].validParentheses

#### 题目地址

https://leetcode.com/problems/valid-parentheses/description

#### 题目描述

```
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true
```

#### 思路

关于这道题的思路，邓俊辉讲的非常好，没有看过的同学可以看一下, [视频地址](http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/courseware/ad1a23c053df4501a3facd66ef6ccfa9/8d6f450e7f7a445098ae1d507fda80f6/)。

使用栈,遍历输入字符串

如果当前字符为左半边括号时，则将其压入栈中

如果遇到右半边括号时，分类讨论：

1)如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环

2)若此时栈为空，则直接返回 false

3)若不为对应的左半边括号，反之返回 false

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

> 值得注意的是，如果题目要求只有一种括号，那么我们其实可以使用更简洁，更省内存的方式 - 计数器来进行求解，而
> 不必要使用栈。

> 事实上，这类问题还可以进一步扩展，我们可以去解析类似 HTML 等标记语法， 比如 <p></p> <body></body>

#### 关键点解析

1. 栈的基本特点和操作
2. 如果你用的是 JS 没有现成的栈，可以用数组来模拟
   入： push 出: pop

> 入： push 出 shift 就是队列

#### 代码

```js
/*
 * @lc app=leetcode id=20 lang=javascript
 *
 * [20] Valid Parentheses
 *
 * https://leetcode.com/problems/valid-parentheses/description/
 *
 * algorithms
 * Easy (35.97%)
 * Total Accepted:    530.2K
 * Total Submissions: 1.5M
 * Testcase Example:  '"()"'
 *
 * Given a string containing just the characters '(', ')', '{', '}', '[' and
 * ']', determine if the input string is valid.
 *
 * An input string is valid if:
 *
 *
 * Open brackets must be closed by the same type of brackets.
 * Open brackets must be closed in the correct order.
 *
 *
 * Note that an empty string is also considered valid.
 *
 * Example 1:
 *
 *
 * Input: "()"
 * Output: true
 *
 *
 * Example 2:
 *
 *
 * Input: "()[]{}"
 * Output: true
 *
 *
 * Example 3:
 *
 *
 * Input: "(]"
 * Output: false
 *
 *
 * Example 4:
 *
 *
 * Input: "([)]"
 * Output: false
 *
 *
 * Example 5:
 *
 *
 * Input: "{[]}"
 * Output: true
 *
 *
 */
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  let valid = true;
  const stack = [];
  const mapper = {
    '{': '}',
    '[': ']',
    '(': ')',
  };

  for (let i in s) {
    const v = s[i];
    if (['(', '[', '{'].indexOf(v) > -1) {
      stack.push(v);
    } else {
      const peak = stack.pop();
      if (v !== mapper[peak]) {
        return false;
      }
    }
  }

  if (stack.length > 0) return false;

  return valid;
};
```

#### 扩展

如果让你检查 XML 标签是否闭合如何检查， 更进一步如果要你实现一个简单的 XML 的解析器，应该怎么实现？

### [23].merge-k-sorted-lists

#### 题目地址

https://leetcode.com/problems/merge-k-sorted-lists/description

#### 题目描述

```
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6

```

#### 思路

这道题目是合并 k 个已排序的链表，号称 leetcode 目前`最难`的链表题。 和之前我们解决的[88.merge-sorted-array](./88.merge-sorted-array.md)很像。
他们有两点区别：

1. 这道题的数据结构是链表，那道是数组。这个其实不复杂，毕竟都是线性的数据结构。

2. 这道题需要合并 k 个元素，那道则只需要合并两个。这个是两题的关键差别，也是这道题难度为`hard`的原因。

因此我们可以看出，这道题目是`88.merge-sorted-array`的进阶版本。其实思路也有点像，我们来具体分析下第二条。
如果你熟悉合并排序的话，你会发现它就是`合并排序的一部分`。

具体我们可以来看一个动画

(动画来自 https://zhuanlan.zhihu.com/p/61796021)

#### 关键点解析

- 分治
- 合并排序(merge sort)

#### 代码

```js
/*
 * @lc app=leetcode id=23 lang=javascript
 *
 * [23] Merge k Sorted Lists
 *
 * https://leetcode.com/problems/merge-k-sorted-lists/description/
 *
 * algorithms
 * Hard (33.14%)
 * Total Accepted:    373.7K
 * Total Submissions: 1.1M
 * Testcase Example:  '[[1,4,5],[1,3,4],[2,6]]'
 *
 * Merge k sorted linked lists and return it as one sorted list. Analyze and
 * describe its complexity.
 *
 * Example:
 *
 *
 * Input:
 * [
 * 1->4->5,
 * 1->3->4,
 * 2->6
 * ]
 * Output: 1->1->2->3->4->4->5->6
 *
 *
 */
function mergeTwoLists(l1, l2) {
  const dummyHead = {};
  let current = dummyHead;
  // l1: 1 -> 3 -> 5
  // l2: 2 -> 4 -> 6
  while (l1 !== null && l2 !== null) {
    if (l1.val < l2.val) {
      current.next = l1; // 把小的添加到结果链表
      current = current.next; // 移动结果链表的指针
      l1 = l1.next; // 移动小的那个链表的指针
    } else {
      current.next = l2;
      current = current.next;
      l2 = l2.next;
    }
  }

  if (l1 === null) {
    current.next = l2;
  } else {
    current.next = l1;
  }
  return dummyHead.next;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  // 图参考： https://zhuanlan.zhihu.com/p/61796021
  if (lists.length === 0) return null;
  if (lists.length === 1) return lists[0];
  if (lists.length === 2) {
    return mergeTwoLists(lists[0], lists[1]);
  }

  const mid = lists.length >> 1;
  const l1 = [];
  for (let i = 0; i < mid; i++) {
    l1[i] = lists[i];
  }

  const l2 = [];
  for (let i = mid, j = 0; i < lists.length; i++, j++) {
    l2[j] = lists[i];
  }

  return mergeTwoLists(mergeKLists(l1), mergeKLists(l2));
};
```

#### 相关题目

-[88.merge-sorted-array](./88.merge-sorted-array.md)

### [24].swapNodesInPairs

#### 题目地址

https://leetcode.com/problems/swap-nodes-in-pairs/description/

#### 题目描述

Given a linked list, swap every two adjacent nodes and return its head.

You may not modify the values in the list's nodes, only nodes itself may be changed.

Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.

#### 思路

设置一个 dummy 节点简化操作,dummy next 指向 head。

1. 初始化 first 为第一个节点
2. 初始化 second 为第二个节点
3. 初始化 current 为 dummy
4. first.next = second.next
5. second.next = first
6. current.next = second
7. current 移动两格
8. 重复

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

1. 链表这种数据结构的特点和使用

2. dummyHead 简化操作

#### 代码

```js
/*
 * @lc app=leetcode id=24 lang=javascript
 *
 * [24] Swap Nodes in Pairs
 *
 * https://leetcode.com/problems/swap-nodes-in-pairs/description/
 *
 * algorithms
 * Medium (43.33%)
 * Total Accepted:    287.2K
 * Total Submissions: 661.3K
 * Testcase Example:  '[1,2,3,4]'
 *
 * Given a linked list, swap every two adjacent nodes and return its head.
 *
 * You may not modify the values in the list's nodes, only nodes itself may be
 * changed.
 *
 *
 *
 * Example:
 *
 *
 * Given 1->2->3->4, you should return the list as 2->1->4->3.
 *
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
  const dummy = new ListNode(0);
  dummy.next = head;
  let current = dummy;
  while (current.next != null && current.next.next != null) {
    // 初始化双指针
    const first = current.next;
    const second = current.next.next;

    // 更新双指针和current指针
    first.next = second.next;
    second.next = first;
    current.next = second;

    // 更新指针
    current = current.next.next;
  }
  return dummy.next;
};
```

### [26].remove-duplicates-from-sorted-array

#### 题目地址

https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/

#### 题目描述

Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

```
// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

#### 思路

使用快慢指针来记录遍历的坐标。

- 开始时这两个指针都指向第一个数字

- 如果两个指针指的数字相同，则快指针向前走一步

- 如果不同，则两个指针都向前走一步

- 当快指针走完整个数组后，慢指针当前的坐标加 1 就是数组中不同数字的个数

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

- 双指针

这道题如果不要求，O(n)的时间复杂度， O(1)的空间复杂度的话，会很简单。
但是这道题是要求的，这种题的思路一般都是采用双指针

- 如果是数据是无序的，就不可以用这种方式了，从这里也可以看出排序在算法中的基础性和重要性。

#### 代码

```js
/*
 * @lc app=leetcode id=26 lang=javascript
 *
 * [26] Remove Duplicates from Sorted Array
 *
 * https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/
 *
 * algorithms
 * Easy (39.76%)
 * Total Accepted:    539.7K
 * Total Submissions: 1.4M
 * Testcase Example:  '[1,1,2]'
 *
 * Given a sorted array nums, remove the duplicates in-place such that each
 * element appear only once and return the new length.
 *
 * Do not allocate extra space for another array, you must do this by modifying
 * the input array in-place with O(1) extra memory.
 *
 * Example 1:
 *
 *
 * Given nums = [1,1,2],
 *
 * Your function should return length = 2, with the first two elements of nums
 * being 1 and 2 respectively.
 *
 * It doesn't matter what you leave beyond the returned length.
 *
 * Example 2:
 *
 *
 * Given nums = [0,0,1,1,1,2,2,3,3,4],
 *
 * Your function should return length = 5, with the first five elements of nums
 * being modified to 0, 1, 2, 3, and 4 respectively.
 *
 * It doesn't matter what values are set beyond the returned length.
 *
 *
 * Clarification:
 *
 * Confused why the returned value is an integer but your answer is an array?
 *
 * Note that the input array is passed in by reference, which means
 * modification to the input array will be known to the caller as well.
 *
 * Internally you can think of this:
 *
 *
 * // nums is passed in by reference. (i.e., without making a copy)
 * int len = removeDuplicates(nums);
 *
 * // any modification to nums in your function would be known by the caller.
 * // using the length returned by your function, it prints the first len
 * elements.
 * for (int i = 0; i < len; i++) {
 * print(nums[i]);
 * }
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const size = nums.length;
  let slowP = 0;
  for (let fastP = 0; fastP < size; fastP++) {
    if (nums[fastP] !== nums[slowP]) {
      slowP++;
      nums[slowP] = nums[fastP];
    }
  }
  return slowP + 1;
};
```

### [29].divide-two-integers

#### 题目地址

https://leetcode.com/problems/divide-two-integers/description/

#### 题目描述

```
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.

```

#### 思路

符合直觉的做法是，减数一次一次减去被减数，不断更新差，直到差小于 0，我们减了多少次，结果就是多少。

核心代码：

```js
let acc = divisor;
let count = 0;

while (dividend - acc >= 0) {
  acc += divisor;
  count++;
}

return count;
```

这种做法简单直观，但是性能却比较差. 下面来介绍一种性能更好的方法。

通过上面这样的分析，我们直到可以使用二分法来解决，性能有很大的提升。

#### 关键点解析

- 二分查找

- 正负数的判断中，这样判断更简单。

```js
const isNegative = dividend > 0 !== divisor > 0;
```

#### 代码

```js
/*
 * @lc app=leetcode id=29 lang=javascript
 *
 * [29] Divide Two Integers
 */
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
  if (divisor === 1) return dividend;

  // 这种方法很巧妙，即符号相同则为正，不同则为负
  const isNegative = dividend > 0 !== divisor > 0;

  const MAX_INTERGER = Math.pow(2, 31);

  const res = helper(Math.abs(dividend), Math.abs(divisor));

  // overflow
  if (res > MAX_INTERGER - 1 || res < -1 * MAX_INTERGER) {
    return MAX_INTERGER - 1;
  }

  return isNegative ? -1 * res : res;
};

function helper(dividend, divisor) {
  // 二分法
  if (dividend <= 0) return 0;
  if (dividend < divisor) return 0;
  if (divisor === 1) return dividend;

  let acc = 2 * divisor;
  let count = 1;

  while (dividend - acc > 0) {
    acc += acc;
    count += count;
  }
  // 直接使用位移运算，比如acc >> 1会有问题
  const last = dividend - Math.floor(acc / 2);

  return count + helper(last, divisor);
}
```

#### 相关题目

- [875.koko-eating-bananas](./875.koko-eating-bananas.md)

### [31].next-permutation

#### 题目地址

https://leetcode.com/problems/next-permutation/description/

#### 题目描述

```
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```

#### 思路

符合直觉的方法是我们按顺序求出所有的排列，如果当前排列等于 nums，那么我直接取下一个
但是这种做法不符合 constant space 要求(题目要求直接修改原数组),时间复杂度也太高，为 O(n!),肯定不是合适的解。

这种题目比较抽象，写几个例子通常会帮助理解问题的规律。我找了几个例子，其中蓝色背景表示的是当前数字找下一个更大排列的时候`需要改变的元素`.

我们不难发现，蓝色的数字都是从后往前第一个不递增的元素，并且我们的下一个更大的排列
只需要改变蓝色的以及之后部分即可，前面的不需要变。

那么怎么改变蓝色的以及后面部分呢？为了使增量最小，
由于前面我们观察发现，其实剩下的元素从左到右是递减的，而我们想要变成递增的，我们只需要不断交换首尾元素即可。

另外我们也可以以回溯的角度来思考这个问题，让我们先回溯一次：

这个时候可以选择的元素只有 2，我们无法组成更大的排列，我们继续回溯，直到如图：

我们发现我们可以交换 4 或者 2 实现变大的效果，但是要保证变大的幅度最小(下一个更大)，
我们需要选择最小的，由于之前我们发现后面是从左到右递减的，显然就是交换最右面大于 1 的。

之后就是不断交换使之幅度最小：

#### 关键点解析

- 写几个例子通常会帮助理解问题的规律
- 在有序数组中首尾指针不断交换位置即可实现 reverse
- 找到从右边起`第一个大于nums[i]的`，并将其和 nums[i]进行交换

#### 代码

```js
/*
 * @lc app=leetcode id=31 lang=javascript
 *
 * [31] Next Permutation
 */

function reverseRange(A, i, j) {
  while (i < j) {
    const temp = A[i];
    A[i] = A[j];
    A[j] = temp;
    i++;
    j--;
  }
}
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  // 时间复杂度O(n) 空间复杂度O(1)
  if (nums == null || nums.length <= 1) return;

  let i = nums.length - 2;
  // 从后往前找到第一个降序的,相当于找到了我们的回溯点
  while (i > -1 && nums[i + 1] <= nums[i]) i--;

  // 如果找了就swap
  if (i > -1) {
    let j = nums.length - 1;
    // 找到从右边起第一个大于nums[i]的，并将其和nums[i]进行交换
    // 因为如果交换的数字比nums[i]还要小肯定不符合题意
    while (nums[j] <= nums[i]) j--;
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }

  // 最后我们只需要将剩下的元素从左到右，依次填入当前最小的元素就可以保证是大于当前排列的最小值了
  // [i + 1, A.length -1]的元素进行反转

  reverseRange(nums, i + 1, nums.length - 1);
};
```

#### 相关题目

- [46.next-permutation](./46.next-permutation.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [60.permutation-sequence](./60.permutation-sequence.md)(TODO)

### [32].longest-valid-parentheses

#### 题目地址

https://leetcode.com/problems/longest-valid-parentheses/

#### 题目描述

```
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

#### 思路(动态规划)

所有的动态规划问题, 首先需要解决的就是如何寻找合适的子问题.
该题需要我们找到最长的有效括号对, 我们首先想到的就是定义**dp[i]为前 i 个字符串的最长有效括号对长度**, 但是随后我们会发现, 这样的定义, 我们无法找到 dp[i]和 dp[i-1]的任何关系.
所以, 我们需要重新找一个新的定义: 定义**dp[i]为以第 i 个字符结尾的最长有效括号对长度**. 然后, 我们通过下面这个例子找一下 dp[i]和 dp[i-1]之间的关系.

从上面的例子我们可以观察出一下几点结论(**描述中 i 为图中的 dp 数组的下标, 对应 s 的下标应为 i-1, 第 i 个字符的 i 从 1 开始**).

1. base case: 空字符串的最长有效括号对长度肯定为 0, 即: dp[0] = 0;
2. s 的第**1**个字符结尾的最长有效括号对长度为 0, s 的第**2**个字符结尾的最长有效括号对长度也为 0, 这个时候我们可以得出结论: 最长有效括号对不可能以'('结尾, 即: dp[1] = d[2] = 0;
3. 当 i 等于 3 时, 我们可以看出 dp[2]=0, dp[3]=2, 因为第 2 个字符(**s[1]**)和第 3 个字符(**s[2]**)是配对的;
   当 i 等于 4 时, 我们可以看出 dp[3]=2, dp[4]=4, 因为我们配对的是第 1 个字符(**s[0]**)和第 4 个字符(**s[3]**);
   因此, 我们可以得出结论: 如果第**i**个字符和第<strong>i-1-dp[i-1]</strong>个字符是配对的, 则 dp[i] = dp[i-1] + 2, 其中: i-1-dp[i-1] >= 1, 因为第 0 个字符没有任何意义;
4. 根据第 3 条规则来计算的话, 我们发现 dp[5]=0, dp[6]=2, 但是显然, dp[6]应该为 6 才对, 但是我们发现可以将"(())"和"()"进行拼接, 即: dp[i] += dp[i-dp[i]], 即: dp[6] = 2 + dp[6-2] = 2 + dp[4] = 6

根据以上规则, 我们求解 dp 数组的结果为: [0, 0, 0, 2, 4, 0, 6, 0], 其中最长有效括号对的长度为 6. 以下为图解:

#### 关键点解析

1. 第 3 点特征, 需要检查的字符是 s[i-1]和 s[i-2-dp[i-1]], 根据定义可知: i-1 >= dp[i-1], 但是 i-2 不一定大于 dp[i-1], 因此, 需要检查越界;
2. 第 4 点特征最容易遗漏, 还有就是不需要检查越界, 因为根据定义可知: i >= dp[i], 所以 dp[i-dp[i]]的边界情况是 dp[0];

#### 扩展

1. 如果判断的不仅仅只有'('和')', 还有'[', ']', '{'和'}', 该怎么办?
2. 如果输出的不是长度, 而是任意一个最长有效括号对的字符串, 该怎么办?

### [33].search-in-rotated-sorted-array

#### 题目地址

https://leetcode.com/problems/search-in-rotated-sorted-array/

#### 题目描述

```
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

```

#### 思路

这是一个我在网上看到的前端头条技术终面的一个算法题。

题目要求时间复杂度为 logn，因此基本就是二分法了。 这道题目不是直接的有序数组，不然就是 easy 了。

首先要知道，我们随便选择一个点，将数组分为前后两部分，其中一部分一定是有序的。

具体步骤：

- 我们可以先找出 mid，然后根据 mid 来判断，mid 是在有序的部分还是无序的部分

假如 mid 小于 start，则 mid 一定在右边有序部分。
假如 mid 大于等于 start， 则 mid 一定在左边有序部分。

> 注意等号的考虑

- 然后我们继续判断 target 在哪一部分， 我们就可以舍弃另一部分了

我们只需要比较 target 和有序部分的边界关系就行了。 比如 mid 在右侧有序部分，即[mid, end]
那么我们只需要判断 target >= mid && target <= end 就能知道 target 在右侧有序部分，我们就
可以舍弃左边部分了(start = mid + 1)， 反之亦然。

我们以([6,7,8,1,2,3,4,5], 4)为例讲解一下：

#### 关键点解析

- 二分法
- 找出有序区间，然后根据 target 是否在有序区间舍弃一半元素

#### 代码

- 语言支持: Javascript

```js
/*
 * @lc app=leetcode id=33 lang=javascript
 *
 * [33] Search in Rotated Sorted Array
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  // 时间复杂度：O(logn)
  // 空间复杂度：O(1)
  // [6,7,8,1,2,3,4,5]
  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === target) return mid;

    // [start, mid]有序

    // ️⚠️注意这里的等号
    if (nums[mid] >= nums[start]) {
      //target 在 [start, mid] 之间

      // 其实target不可能等于nums[mid]， 但是为了对称，我还是加上了等号
      if (target >= nums[start] && target <= nums[mid]) {
        end = mid - 1;
      } else {
        //target 不在 [start, mid] 之间
        start = mid + 1;
      }
    } else {
      // [mid, end]有序

      // target 在 [mid, end] 之间
      if (target >= nums[mid] && target <= nums[end]) {
        start = mid + 1;
      } else {
        // target 不在 [mid, end] 之间
        end = mid - 1;
      }
    }
  }

  return -1;
};
```

#### 扩展

### [42].trapping-rain-water

#### 题目地址

https://leetcode.com/problems/trapping-rain-water/description/

#### 题目描述

```
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.


The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!


```

```
Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

```

#### 思路

这是一道雨水收集的问题， 难度为`hard`. 如图所示，让我们求下过雨之后最多可以积攒多少的水。

如果采用暴力求解的话，思路应该是 height 数组依次求和，然后相加。

伪代码:

```js
for (let i = 0; i < height.length; i++) {
  area += (h[i] - height[i]) * 1; // h为下雨之后的水位
}
```

如上图那么 h 为 [1, 1, 2, 2, ,2 ,2, ,3, 2, 2, 2, 1]

问题转化为求 h，那么 h[i]又等于`左右两侧柱子的最大值中的较小值`，即
`h[i] = Math.min(左边柱子最大值, 右边柱子最大值)`

问题的关键在于求解`左边柱子最大值`和`右边柱子最大值`,
我们其实可以用两个数组来表示`leftMax`, `rightMax`，
以 leftMax 为例，leftMax[i]代表 i 的左侧柱子的最大值，因此我们维护两个数组即可。

#### 关键点解析

- 建模 `h[i] = Math.min(左边柱子最大值, 右边柱子最大值)`(h 为下雨之后的水位)

#### 代码

```js
/*
 * @lc app=leetcode id=42 lang=javascript
 *
 * [42] Trapping Rain Water
 *
 * https://leetcode.com/problems/trapping-rain-water/description/
 *
 * algorithms
 * Hard (42.06%)
 * Total Accepted:    278.1K
 * Total Submissions: 651.6K
 * Testcase Example:  '[0,1,0,2,1,0,1,3,2,1,2,1]'
 *
 * Given n non-negative integers representing an elevation map where the width
 * of each bar is 1, compute how much water it is able to trap after raining.
 *
 *
 * The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].
 * In this case, 6 units of rain water (blue section) are being trapped. Thanks
 * Marcos for contributing this image!
 *
 * Example:
 *
 *
 * Input: [0,1,0,2,1,0,1,3,2,1,2,1]
 * Output: 6
 *
 */
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  let max = 0;
  let volumn = 0;
  const leftMax = [];
  const rightMax = [];

  for (let i = 0; i < height.length; i++) {
    leftMax[i] = max = Math.max(height[i], max);
  }

  max = 0;

  for (let i = height.length - 1; i >= 0; i--) {
    rightMax[i] = max = Math.max(height[i], max);
  }

  for (let i = 0; i < height.length; i++) {
    volumn = volumn + Math.min(leftMax[i], rightMax[i]) - height[i];
  }

  return volumn;
};
```

### [33].

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const binSearch = (nums, target, n, m) => {
  if (n === m || m < n) {
    return nums[n] === target ? n : -1;
  }
  const mid = Math.floor((n + m) / 2);
  if (target === nums[mid]) return mid;
  // console.log(n, m, mid)
  if (target > nums[mid]) {
    return binSearch(nums, target, mid + 1, m);
  }
  return binSearch(nums, target, n, mid - 1);
};

export default function search(nums, target) {
  if (nums.length === 0) return -1;
  if (nums.length === 1) return nums[0] === target ? 0 : -1;

  let low = 0;
  let high = nums.length - 1;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (nums[mid] > nums[high]) low += 1;
    else high = mid;
  }

  const minIndex = low;
  const maxIndex = low - 1;

  if (nums[0] < nums[nums.length - 1]) {
    return binSearch(nums, target, 0, nums.length - 1);
  }

  if (target > nums[0]) {
    return binSearch(nums, target, 1, maxIndex);
  }
  if (target < nums[0]) {
    return binSearch(nums, target, minIndex, nums.length - 1);
  }
  return 0;
}
```

### [34].

```js
// 34. Find First and Last Position of Element in Sorted Array

// Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

// Your algorithm's runtime complexity must be in the order of O(log n).

// If the target is not found in the array, return [-1, -1].

// Input: nums = [5,7,7,8,8,10], target = 8
// Output: [3,4]

// Input: nums = [5,7,7,8,8,10], target = 6
// Output: [-1,-1]

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

const binSearch = (nums, lo, hi, target, left) => {
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (left) {
      if (nums[lo] === target) return lo;
      if (hi - lo === 1) return hi;
      if (nums[mid] < target) lo = mid;
      else hi = mid;
    } else {
      if (nums[hi] === target) return hi;
      if (hi - lo === 1) return lo;
      if (nums[mid] > target) hi = mid;
      else lo = mid;
    }
  }
};

export default function searchRange(nums, target) {
  if (nums.length === 0) return [-1, -1];
  // bin search for target.
  let lo = 0;
  let hi = nums.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] < target) lo = mid + 1;
    else hi = mid;
  }
  if (nums[lo] !== target) return [-1, -1];

  // if left and right not equal to target, we are done
  if (nums[lo - 1] !== target && nums[lo + 1] !== target) return [lo, lo];

  if (nums.length === 2) return [0, 1];

  // if left of target not equal to target, find left
  const left = nums[hi - 1] === target ? binSearch(nums, 0, lo, target, true) : hi;

  // if right of target not equal to target, find right
  const right = nums[lo + 1] === target ? binSearch(nums, hi, nums.length - 1, target, false) : lo;

  return [left, right];
}
```

### [36].

```js
// 36. Valid Sudoku

// Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

// Each row must contain the digits 1-9 without repetition.
// Each column must contain the digits 1-9 without repetition.
// Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.

/**
 * @param {character[][]} board
 * @return {boolean}
 */

const isNum = n => n !== '.';
const validateRow = (board, row) => {
  const set = new Set();
  for (let i = 0; i < board.length; i++) {
    if (isNum(board[row][i]) && set.has(board[row][i])) return false;
    set.add(board[row][i]);
  }
  return true;
};
const validateCol = (board, col) => {
  const set = new Set();
  for (let i = 0; i < board.length; i++) {
    if (isNum(board[i][col]) && set.has(board[i][col])) return false;
    set.add(board[i][col]);
  }
  return true;
};
const validateSquare = (board, i, j) => {
  const imin = i * 3;
  const imax = imin + 2;
  const jmin = j * 3;
  const jmax = jmin + 2;
  const set = new Set();
  for (let i = imin; i <= imax; i++) {
    for (let j = jmin; j <= jmax; j++) {
      if (isNum(board[i][j]) && set.has(board[i][j])) return false;
      set.add(board[i][j]);
    }
  }
  return true;
};

export default function isValidSudoku(board) {
  for (let i = 0; i < board.length; i++) {
    if (!validateRow(board, i)) return false;
  }
  for (let i = 0; i < board.length; i++) {
    if (!validateCol(board, i)) return false;
  }
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (!validateSquare(board, i, j)) return false;
    }
  }
  return true;
}
```

### [043].Multiply-Strings 字符串相乘

```js
/**
 * https://leetcode.com/problems/multiply-strings/description/
 * Difficulty:Medium
 *
 * Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.
 * Note:
 * The length of both num1 and num2 is < [110].
 * Both num1 and num2 contains only digits 0-[9].
 * Both num1 and num2 does not contain any leading zero.
 * You must not use any built-in BigInteger library or convert the inputs to integer directly.
 */

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
  var m = num1.length;
  var n = num2.length;
  var arr = new Array(m + n).fill(0);
  for (var i = m - 1; i >= 0; i--) {
    for (var j = n - 1; j >= 0; j--) {
      var mul = (num1[i] - '0') * (num2[j] - '0');

      var sum = mul + arr[i + j + 1];

      arr[i + j] += Math.floor(sum / 10);
      arr[i + j + 1] = sum % 10;
    }
  }

  var str = arr.reduce((a, b) => {
    if (a === '' && b === 0) return a;
    return a + b;
  }, '');

  return str ? str : '0';
};

console.log(multiply('89', '45'));
console.log(multiply('123', '123'));
console.log(multiply('123', '0'));
```

```js
var multiply = function(num1, num2) {
  if (num1 == '0' || num2 == '0') return '0';
  let l1 = num1.length,
    l2 = num2.length;
  let res = new Array(l1 + l2 - 1).fill(0);
  console.log(res);
  for (let i = 0; i < l2; i++) {
    for (let j = 0; j < l1; j++) {
      res[i + j] += +num2[i] * +num1[j];
    }
  }
  console.log(res);
  let len = res.length;
  let str = '',
    num = 0;
  while (len--) {
    num += res[len];
    str = (num % 10) + str;
    num = (num / 10) | 0;
  }
  console.log(num);
  return num > 0 ? num + str : str;
};

var multiply2 = function(num1, num2) {
  if (num1 == '0' || num2 == '0') return '0';
  let l1 = num1.length,
    l2 = num2.length;
  let res = new Array(l1 + l2).fill(0);
  for (let i = l2 - 1; i >= 0; i--) {
    for (let j = l1 - 1; j >= 0; j--) {
      let sum = res[i + j + 1] + +num2[i] * +num1[j];
      res[i + j + 1] = sum % 10;
      res[i + j] += (sum / 10) | 0;
    }
  }
  if (res[0] === 0) {
    res.shift();
  }
  return res.join('');
};
console.log(multiply2('123', '45'));
```

```js
var multiply = function(num1, num2) {
  const len1 = num1.length;
  const len2 = num2.length;
  let result = new Array(len1 + len2).fill(0);

  for (let i = len1 - 1; i >= 0; i--) {
    for (let j = len2 - 1; j >= 0; j--) {
      let value = parseInt(num1.charAt(i)) * parseInt(num2.charAt(j));
      result[i + j + 1] += value;

      if (result[i + j + 1] >= 10) {
        result[i + j] += parseInt(result[i + j + 1] / 10);
        result[i + j + 1] = result[i + j + 1] % 10;
      }
    }
  }

  let string = '';

  for (let i = 0; i < result.length; i++) {
    if (string === '' && result[i] === 0) {
      continue;
    }

    string += result[i];
  }

  return string === '' ? '0' : string;
};

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
  var len1 = num1.length,
    len2 = num2.length,
    result = [],
    carry,
    val,
    arr1,
    arr2,
    i,
    j;

  for (i = 0; i < len1 + len2; i++) {
    result.push(0);
  }

  arr1 = num1.split('').reverse();
  arr2 = num2.split('').reverse();

  for (i = 0; i < len1; i++) {
    val = arr1[i] - '0';
    carry = 0;

    for (j = 0; j < len2; j++) {
      carry += val * (arr2[j] - '0') + result[i + j];
      result[i + j] = carry % 10;
      carry = parseInt(carry / 10);
    }

    if (carry !== 0) {
      result[len2 + i] = carry;
    }
  }

  result = result.reverse();

  i = 0;

  while (i < len1 + len2 - 1 && result[i] === 0) {
    i++;
  }

  return result.slice(i).join('');
};
```

### [56].

```js
// 56. Merge Intervals

// Given a collection of intervals, merge all overlapping intervals.

// Example 1:

// Input: [[1,3],[2,6],[8,10],[15,18]]
// Output: [[1,6],[8,10],[15,18]]
// Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
// Example 2:

// Input: [[1,4],[4,5]]
// Output: [[1,5]]
// Explanation: Intervals [1,4] and [4,5] are considered overlapping.

/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
export default function merge(intervals) {
  if (intervals.length === 0) return [];
  if (intervals.length === 1) return intervals;
  intervals = intervals.sort((a, b) => {
    if (a[0] !== b[0]) return a[0] - b[0];
    return a[1] - b[1];
  });
  let start = intervals[0][0];
  let end = intervals[0][1];
  const ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    const left = intervals[i];
    const right = intervals[i + 1];
    if (right[0] <= end && right[1] >= end) {
      end = right[1]; // then overlap
    } else if (right[0] > end) {
      ans.push([start, end]);
      start = right[0];
      end = right[1];
    }
    if (i === intervals.length - 2) ans.push([start, end]);
  }
  return ans;
}
```

### [61].

```js
// 61. Rotate List

// Given a linked list, rotate the list to the right by k places, where k is non-negative.

// Example 1:

// Input: 1->2->3->4->5->NULL, k = 2
// Output: 4->5->1->2->3->NULL
// Explanation:
// rotate 1 steps to the right: 5->1->2->3->4->NULL
// rotate 2 steps to the right: 4->5->1->2->3->NULL
// Example 2:

// Input: 0->1->2->NULL, k = 4
// Output: 2->0->1->NULL
// Explanation:
// rotate 1 steps to the right: 2->0->1->NULL
// rotate 2 steps to the right: 1->2->0->NULL
// rotate 3 steps to the right: 0->1->2->NULL
// rotate 4 steps to the right: 2->0->1->NULL

/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
export default function rotateRight(head, k) {
  let len = 0;
  let curr = head;
  let tail = curr;
  while (curr !== null) {
    tail = curr;
    curr = curr.next;
    len++;
  }
  k %= len;
  if (len <= 1 || k === 0) return head;
  curr = head;
  for (let i = 0; i < len - k - 1; i++) {
    curr = curr.next;
  }
  const nextHead = curr.next;
  tail.next = head;
  head = nextHead;
  curr.next = null;
  return head;
}
```

### [64].

```js
// Given a m x n grid filled with non-negative numbers, find a path from top left to bottom
// right which minimizes the sum of all numbers along its path.

// Note: You can only move either down or right at any point in time.

// Input:
// [
//   [1,3,1],
//   [1,5,1],
//   [4,2,1]
// ]
// Output: 7
// Explanation: Because the path 1→3→1→1→1 minimizes the sum.

// Observations:
// This is a DP problem. The shortest path of location i, j is the Min of down or right

/**
 * @param {number[][]} grid
 * @return {number}
 */

const traverse = (grid, i, j, dpTable) => {
  if (i === grid.length - 1 && j === grid[0].length - 1) return grid[i][j];
  if (i < 0 || j < 0 || i === grid.length || j === grid[0].length) return Infinity;
  if (dpTable[i][j]) return dpTable[i][j];
  const min = Math.min(traverse(grid, i + 1, j, dpTable), traverse(grid, i, j + 1, dpTable));
  const res = grid[i][j] + min;
  dpTable[i][j] = res;
  return res;
};

export default function minPathSum(grid) {
  const dpTable = new Array(grid.length);
  for (let i = 0; i < grid.length; i++) {
    dpTable[i] = [];
  }
  return traverse(grid, 0, 0, dpTable);
}
```

### [74].

```js
const binSearch = (nums, target) => {
  let lo = 0;
  let hi = nums.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] === target) return true;
    if (nums[mid] < target) lo = mid + 1;
    else hi = mid;
  }
  return nums[lo] === target;
};

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
export default function searchMatrix(matrix, target) {
  if (matrix.length === 0) return false;
  let lo = 0;
  let hi = matrix.length - 1;
  while (lo < hi) {
    // Search the middle row
    const mid = Math.floor((lo + hi) / 2);
    // If ###  is in range of the row then bin search row
    if (matrix[mid].length === 0) return false;
    if (matrix[mid][0] <= target && target <= matrix[mid][matrix[mid].length - 1]) {
      return binSearch(matrix[mid], target);
    }
    if (matrix[mid][0] > target) {
      // if less than range, search rows between middle row and first row
      hi = mid - 1;
    } else {
      // search rows between middle row and last row
      lo = mid + 1;
    }
    if (hi < lo) return false;
    if (lo === hi) return binSearch(matrix[lo], target);
  }
  if (lo === hi) return binSearch(matrix[lo], target);
  return false;
}
```

### [75].

```js
// 75. Sort Colors

// Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

// Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

// Note: You are not suppose to use the library's sort function for this problem.

// Input: [2,0,2,1,1,0]
// Output: [0,0,1,1,2,2]

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
export default function sortColors(nums) {
  const counts = new Array(3);
  for (const item of nums) {
    counts[item] = counts[item] === undefined ? 1 : counts[item] + 1;
  }
  let index = 0;
  for (let i = 0; i < counts.length; i++) {
    for (let j = 0; j < counts[i]; j++) {
      nums[index] = i;
      index++;
    }
  }
  return nums;
}
```

### [78].

```js
// 78. Subsets

// Given a set of distinct integers, nums, return all possible subsets (the power set).

// Note: The solution set must not contain duplicate subsets.

// Example:

// Input: nums = [1,2,3]
// Output:
// [
//   [3],
//   [1],
//   [2],
//   [1,2,3],
//   [1,3],
//   [2,3],
//   [1,2],
//   []
// ]
const subsetsAux = (nums, prev, start, res) => {
  if (start === nums.length || start === prev.length) {
    res.push(prev);
    return res;
  }
  const remove = [];
  for (let i = 0; i < prev.length; i++) {
    if (start === i) {
      continue;
    }
    remove.push(prev[i]);
  }
  subsetsAux(nums, [...prev], start + 1, res);
  subsetsAux(nums, [...remove], start, res);
  return res;
};

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
export default function subsets(nums) {
  const res = [];
  return subsetsAux(nums, [...nums], 0, res);
}
```

### [98].

```js
// Given a binary tree, determine if it is a valid binary search tree (BST).

// Assume a BST is defined as follows:

// The left subtree of a node contains only nodes with keys less than the node's key.
// The right subtree of a node contains only nodes with keys greater than the node's key.
// Both the left and right subtrees must also be binary search trees.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

const binSearch = (tree, val) => {
  if (tree === null) return false;
  if (tree.val === val) return true;
  return val > tree.val ? binSearch(tree.right, val) : binSearch(tree.left, val);
};

const traverseAndValidate = (root, tree) => {
  if (tree === null || root === null) return true;
  if (!binSearch(root, tree.val)) return false;
  return traverseAndValidate(root, tree.left) && traverseAndValidate(root, tree.right);
};

export default function isValidBST(root) {
  const values = [];
  // BFS
  const queue = [];
  if (root) queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    values.push(item.val);
    if (item.left) queue.push(item.left);
    if (item.right) queue.push(item.right);
  }
  // Validate if BST has duplicates (BST does not allow duplicates)
  const set = new Set(values);
  if (set.size !== values.length) return false;
  return traverseAndValidate(root, root);
}
```

### [11].Container-With-Most-Water

```js
/**
 * https://leetcode.com/problems/container-with-most-water/description/
 * Difficulty:Medium
 *
 * Given n non-negative integers a1, a2, ..., an, where each represents a point
 * at coordinate (i, ai).
 * n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).
 * Find two lines, which together with x-axis forms a container,
 * such that the container contains the most water.
 * Note: You may not slant the container and n is at least [2].
 */

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var dp = [0];
  var max = 0;
  for (var i = 1; i < height.length; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      var v = (i - j) * Math.min(height[i], height[j]);
      dp[i] = Math.max(dp[i], v);
    }
    max = Math.max(max, dp[i]);
  }
  // console.log(dp, max);
  return max;
};

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var i = 0;
  var j = height.length - 1;
  var max = 0;
  while (i < j) {
    max = Math.max(max, Math.min(height[i], height[j]) * (j - i));
    if (height[i] < height[j]) i++;
    else j--;
  }
  return max;
};

console.log(maxArea([3, 5, 1, 9]));
```

### [13].Roman-to-Integer

```js
/**
 * https://leetcode.com/problems/roman-to-integer/description/
 * Difficulty:Easy
 *
 * Given a roman numeral, convert it to an integer.
 * Input is guaranteed to be within the range from 1 to [3999].
 */

/**
 * @see https://baike.baidu.com/item/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97
 *
 * 基本字符
 * I V  X  L  C   D   M
 * 1 5 10 50 100 500 100
 * 相应的阿拉伯数字表示
 *
 * 计数方法
 * 相同的数字连写、所表示的数等于这些数字相加得到的数、如：Ⅲ=3；
 * 小的数字在大的数字的右边、所表示的数等于这些数字相加得到的数、 如：Ⅷ=8、Ⅻ=12；
 * 小的数字(限于 I、X 和 C)在大的数字的左边、所表示的数等于大数减小数得到的数、如：Ⅳ=4、Ⅸ=9；
 * 正常使用时、连写的数字重复不得超过三次；
 *
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
  if (!s) return 0;

  var map = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 100,
  };

  var sum = map[s[s.length - 1]];
  for (var i = s.length - 2; i >= 0; i--) {
    if (map[s[i]] < map[s[i + 1]]) sum -= map[s[i]];
    else sum += map[s[i]];
  }
  return sum;
};

console.log(romanToInt('III'), 3);
console.log(romanToInt('VI'), 6);
console.log(romanToInt('IV'), 4);
```

### [14].Longest-Common-Prefix

### [15].3Sum

```js
/**
 * https://leetcode.com/problems/3sum/
 * Difficulty:Medium
 *
 * Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0?
 * Find all unique triplets in the array which gives the sum of zero.
 * Note: The solution set must not contain duplicate triplets.
 *
 * For example, given array S = [-1, 0, 1, 2, -1, -4],
 * A solution set is:
 * [
 * [-1, 0, 1],
 * [-1, -1, 2]
 * ]

 */
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    if (a > b) return 1;
    if (a === b) return 0;
    if (a < b) return -1;
  });
  // console.log(nums);
  var ret = [];
  for (var i = 0; i < nums.length - 2; i++) {
    var a = nums[i];
    if (i === 0 || (i > 0 && nums[i] !== nums[i - 1])) {
      var j = i + 1;
      var k = nums.length - 1;
      while (j < k) {
        var b = nums[j];
        var c = nums[k];

        var sum = a + b + c;

        // console.log(a, b, c, '=', sum);
        if (sum > 0) k--;
        else if (sum === 0) {
          ret.push([a, b, c]);
          while (j < k && nums[j] === nums[++j]);
          while (j < k && nums[k] === nums[--k]);
          // j++;
          // k--;
        } else j++;
      }
    }
  }
  return ret;
};

console.log(threeSum([-2, 0, 0, 2, 2]));
console.log(threeSum([-1, 0, 1, 2, -1, -4]));
// console.log(threeSum([0, 0, 0, 0]));
// console.log(threeSum([1, -1, -1, 0]));
```

### [16].3Sum-Closest

```js
/**
 * https://leetcode.com/problems/3sum-closest/description/
 * Difficulty:Medium
 *
 * Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target.
 * Return the sum of the three integers. You may assume that each input would have exactly one solution.
 * For example, given array S = {-1 2 1 -4}, and target = [1].
 * The sum that is closest to the target is [2]. (-1 + 2 + 1 = 2).
 *
 */

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  var ans = nums[0] + nums[1] + nums[2];
  var len = nums.length;

  nums.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));

  for (var i = 0; i < len - 2; i++) {
    var j = i + 1;
    var k = len - 1;

    while (j < k) {
      var sum = nums[i] + nums[j] + nums[k];
      if (sum === target) return sum;
      if (sum > target) k--;
      if (sum < target) j++;
      if (Math.abs(target - sum) < Math.abs(target - ans)) {
        ans = sum;
      }
    }
  }
  return ans;
};

console.log(threeSumClosest([-1, 2, 1, -4], 1));
```

```js
/**
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

    For example, given array S = {-1 2 1 -4}, and target = [1].

    The sum that is closest to the target is [2]. (-1 + 2 + 1 = 2).

*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  var len = nums.length,
    minDiff = Number.MAX_VALUE,
    diff,
    left,
    right,
    i,
    j;

  nums.sort(function(a, b) {
    return a - b;
  });

  for (i = 0; i < len; i++) {
    left = i + 1;
    right = len - 1;

    while (left < right) {
      diff = target - nums[i] - nums[left] - nums[right];

      if (diff === 0) {
        return target;
      } else if (diff > 0) {
        left++;
      } else {
        right--;
      }

      if (Math.abs(diff) < Math.abs(minDiff)) {
        minDiff = diff;
      }
    }
  }

  return target - minDiff;
};
```

```js
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });

  var len = nums.length,
    i,
    result = [],
    curSol = [];

  for (i = 0; i < len; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }

    curSol.push(nums[i]);
    twoSum(result, curSol.concat(), i + 1, len - 1, -nums[i], nums);
    curSol.pop();
  }

  return result;
};

function twoSum(allSol, curSol, startIndex, endIndex, target, nums) {
  var start = startIndex,
    end = endIndex,
    sum,
    mid;

  while (start < end) {
    sum = nums[start] + nums[end];

    if (sum === target) {
      curSol.push(nums[start]);
      curSol.push(nums[end]);
      allSol.push(curSol.concat());
      curSol.pop();
      curSol.pop();

      start++;
      end--;

      while (nums[start] === nums[start - 1]) {
        start++;
      }

      while (nums[end] === nums[end + 1]) {
        end--;
      }
    } else if (sum < target) {
      start++;
    } else {
      end--;
    }
  }
}
```

### [18].4Sum

Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note: The solution set must not contain duplicate quadruplets.
For example, given array S = [1, 0, -1, 0, -2, 2], and target = [0].
A solution set is:
[-1, 0, 0, 1],
[-2, -1, 1, 2],
[-2, 0, 0, 2]

```js
var fourSum = function(nums, target) {
  var len = nums.length;
  if (len < 4) return [];
  nums.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  // console.log(nums);
  var ans = [];
  for (var i = 0; i < len - 3; i++) {
    for (var j = i + 1; j < len - 2; j++) {
      var k = j + 1;
      var l = len - 1;

      while (k < l) {
        var sum = nums[i] + nums[j] + nums[k] + nums[l];
        if (sum === target) {
          ans.push([nums[i], nums[j], nums[k], nums[l]]);
          while (nums[l--] === nums[l] && nums[k++] === nums[k] && k < l);
        } else if (sum < target) while (nums[k++] === nums[k] && k < l);
        else while (nums[l--] === nums[l] && k < l);
      }
      while (nums[j] === nums[j + 1]) j++;
    }
    while (nums[i] === nums[i + 1]) i++;
  }
  return ans;
};

console.log(fourSum([-5, -4, -2, -2, -2, -1, 0, 0, 1], -9));
```

### [19].Remove-Nth-Node-From-End-of-List

```js
/**
 * https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/
 * Difficulty:Medium
 *
 * Given a linked list, remove the nth node from the end of list and return its head.
 *
 * For example,
 *  Given linked list: 1->2->3->4->5, and n = [2].
 *  After removing the second node from the end, the linked list becomes 1->2->3->[5].
 *
 * Note:
 *  Given n will always be valid.
 *  Try to do this in one pass.
 *
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  if (!head) return head;
  var len = 0;
  var tail = head;
  while (tail) {
    tail = tail.next;
    len++;
  }
  if (len === n) {
    return head.next;
  }

  len = len - n - 1;
  tail = head;
  while (len) {
    tail = tail.next;
    len--;
  }
  tail.next = tail.next.next;
  return head;
};

var a = new ListNode(1);
var b = new ListNode(2);
var c = new ListNode(3);
var d = new ListNode(4);
// var e = new ListNode(5);
a.next = b;
b.next = c;
c.next = d;
// d.next = e;

console.log(removeNthFromEnd(a, 2));
```

### [20].Valid-Parentheses

```js
/**
 * https://leetcode.com/problems/valid-parentheses/
 * Difficulty:Easy
 *
 * Given a string containing just the characters '(', ')', '{', '}', '[' and ']',
 * determine if the input string is valid.
 * The brackets must close in the correct order,
 * "()" and "()[]{}" are all valid but "(]" and "([)]" are not.
 */

/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  var stack = [];
  for (var i = 0; i < s.length; i++) {
    var c = s[i];
    switch (c) {
      case '(':
        stack.push(')');
        break;
      case '[':
        stack.push(']');
        break;
      case '{':
        stack.push('}');
        break;
      default:
        if (!stack.length || stack.pop() !== c) {
          // console.log(stack);
          return false;
        }
    }
  }

  return stack.length === 0;
};

console.log(isValid('()[]{}'));
console.log(isValid('[()][]{}'));
console.log(isValid('(])'));
```

### [21].Merge-Two-Sorted-Lists

```js
/**
 * https://leetcode.com/problems/merge-two-sorted-lists/description/
 * Difficulty:Easy
 *
 * Merge two sorted linked lists and return it as a new list.
 * The new list should be made by splicing together the nodes of the first two lists.
 *
 * Example:
 * Input: 1->2->4, 1->3->4
 * Output: 1->1->2->3->4->4
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 *
 * non-recursion
 *
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;

  var n = new ListNode(0);
  var t = n;

  while (l1 && l2) {
    if (l1.val <= l2.val) {
      n.next = l1;
      l1 = l1.next;
    } else {
      n.next = l2;
      l2 = l2.next;
    }
    n = n.next;
  }
  if (l1) n.next = l1;
  if (l2) n.next = l2;

  return t.next;
};

/**
 *
 * recursion
 *
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;

  if (l1.val <= l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

### [22].Generate-Parentheses

```js
/**
 * https://leetcode.com/problems/generate-parentheses/description/
 * Difficulty:Medium
 *
 * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
 * For example, given n = 3, a solution set is:
 * [
 *   "((()))",
 *   "(()())",
 *   "(())()",
 *   "()(())",
 *   "()()()"
 * ]
 */

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  var ans = [];
  helper(ans, '', 0, 0, n);
  return ans;
};

function helper(ans, str, left, right, n) {
  if (right === n) ans.push(str);
  if (left < n) {
    helper(ans, str + '(', left + 1, right, n);
  }
  if (right < left) {
    helper(ans, str + ')', left, right + 1, n);
  }
}

console.log(generateParenthesis(3));
```

### [23].Merge-k-Sorted-Lists

```js
/**
 * https://leetcode.com/problems/merge-k-sorted-lists/description/
 * Difficulty:Hard
 *
 * Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
 */

//Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  return lists.reduce((a, b) => merge2lists(a, b), null);
};

function merge2lists(a, b) {
  if (!a && !b) return null;
  if (!a) return b;
  if (!b) return a;
  var h;
  if (a.val < b.val) {
    h = a;
    a = a.next;
  } else {
    h = b;
    b = b.next;
  }
  var t = h;

  while (a && b) {
    if (a.val < b.val) {
      t.next = a;
      t = t.next;
      a = a.next;
    } else {
      t.next = b;
      t = t.next;
      b = b.next;
    }
  }
  if (a) t.next = a;
  if (b) t.next = b;
  return h;
}

var a = {
  val: 1,
  next: {
    val: 4,
    next: {
      val: 7,
      next: null,
    },
  },
};
var b = {
  val: 2,
  next: {
    val: 8,
    next: {
      val: 9,
      next: null,
    },
  },
};

var c = {
  val: 3,
  next: {
    val: 10,
    next: null,
  },
};

// console.log(merge2lists(a, b));
console.log(mergeKLists([a, b, c]));
```

### [24].Swap-Nodes-in-Pairs

```js
/**
 * https://leetcode.com/problems/swap-nodes-in-pairs/description/
 * Difficulty:Medium
 *
 * Given a linked list, swap every two adjacent nodes and return its head.
 *
 * For example,
 * Given 1->2->3->4, you should return the list as 2->1->4->[3].
 * Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
 *
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
  var t = new ListNode(0);
  t.next = head;

  var a = t;

  while (true) {
    if (!a) break;
    var b = a.next;
    if (!b) break;
    var c = b.next;
    if (!c) break;

    b.next = c.next;
    c.next = b;
    a.next = c;
    a = b;
  }
  return t.next;
};

console.log(
  swapPairs({
    val: 1,
    next: {
      val: 2,
      next: {
        val: 3,
        next: {
          val: 4,
        },
      },
    },
  }),
);
```

### [25].Reverse-Nodes-in-k-Group

```js
/**
 * https://leetcode.com/problems/reverse-nodes-in-k-group/description/
 * Difficulty:Hard
 *
 * Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
 * k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
 * You may not alter the values in the nodes, only nodes itself may be changed.
 * Only constant memory is allowed.
 * For example,
 * Given this linked list: 1->2->3->4->5
 * For k = 2, you should return: 2->1->4->3->5
 * For k = 3, you should return: 3->2->1->4->5
 *
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
  // if (k === 1)
  //     return head;
  var t = new ListNode(0);
  t.next = head;
  var s = t;

  while (true) {
    var cnt = 0;
    var f = t;
    while (cnt++ < k && f) {
      f = f.next;
    }
    // console.log(p(t), p(f));

    if (!f || cnt !== k + 1) break;
    cnt = 0;
    var a = t.next;

    while (++cnt < k) {
      var b = a.next;
      a.next = b.next;
      b.next = t.next;
      t.next = b;
      // console.log(p(t), p(a), p(b));
    }
    t = a;
  }

  return s.next;
};

function p(n) {
  var t = n;
  var s = '';
  while (t) {
    s = s + t.val + '->';
    t = t.next;
  }
  s += 'null';
  return s;
}
//
console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: {
              val: 4,
            },
          },
        },
      },
      2,
    ),
  ),
);

console.log(p(reverseKGroup({ val: 1 }, 2)));

console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
        },
      },
      2,
    ),
  ),
);

console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: {
              val: 4,
              next: {
                val: 5,
                next: {
                  val: 6,
                  next: {
                    val: 7,
                  },
                },
              },
            },
          },
        },
      },
      3,
    ),
  ),
);
//

console.log(
  p(
    reverseKGroup(
      {
        val: 1,
        next: {
          val: 2,
          next: {
            val: 3,
            next: {
              val: 4,
              next: null,
            },
          },
        },
      },
      2,
    ),
  ),
);
```

### [26].Remove-Duplicates-from-Sorted-Array

```js
/**
 * https://leetcode.com/problems/remove-duplicates-from-sorted-array/
 * Difficulty:Easy
 *
 * Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
 * Do not allocate extra space for another array, you must do this in place with constant memory.
 *
 * For example,
 * Given input array nums = [1,1,2],
 * Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
 * It doesn't matter what you leave beyond the new length.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  var n = nums.length;
  if (!n) return 0;
  var last = nums[0];
  var cnt = 1;

  for (var i = 1; i < nums.length; i++) {
    if (nums[i] !== last) {
      last = nums[i];
      cnt++;
    } else {
      nums.splice(i, 1);
      i--;
    }
  }
  return cnt;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  for (var i = 0; i < nums.length - 1; i++) if (nums[i] === nums[i + 1]) nums.splice(i--, 1);
  return nums.length;
};

var arr = [1, 2, 2];
console.log(removeDuplicates(arr));
console.log(arr);
```

### [27].Remove-Element

```js
/**
 * https://leetcode.com/problems/remove-element/description/
 * Difficulty:Easy
 *
 * Given an array and a value, remove all instances of that value in-place and return the new length.
 * Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
 * The order of elements can be changed. It doesn't matter what you leave beyond the new length.
 * Example:
 * Given nums = [3,2,2,3], val = 3,
 * Your function should return length = 2, with the first two elements of nums being [2].
 */

/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
  var len = nums.length;
  for (var i = 0; i < len; i++) {
    if (nums[i] === val) {
      nums.splice(i, 1);
      i--;
      len--;
    }
  }
  return len;
};

console.log(removeElement([3, 2, 2, 3], 3));
```

### [30].Substring-with-Concatenation-of-All-Words

```js
/**
 *
 * https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/
 * Difficulty:Hard
 *
 * You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s)
 * in s that is a concatenation of each word in words exactly once and without any intervening characters.
 * For example, given:
 * s: "barfoothefoobarman"
 * words: ["foo", "bar"]
 * You should return the indices: [0,9].
 * (order does not matter).
 *
 */
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  if (!s.length || !words.length) return [];
  var ans = [];
  var toFind = {};

  var m = words.length;
  var n = words[0].length;

  for (var i = 0; i < m; i++) {
    toFind[words[i]] = (toFind[words[i]] || 0) + 1;
  }

  for (i = 0; i <= s.length - m * n; i++) {
    var found = {};

    for (var j = 0; j < m; j++) {
      var k = i + n * j;
      var w = s.substr(k, n);
      if (!toFind[w]) break;
      found[w] = (found[w] || 0) + 1;
      if (found[w] > toFind[w]) break;
    }
    if (j === m) ans.push(i);
  }

  return ans;
};

console.log(findSubstring('barfoothefoobarman', ['foo', 'bar']));
```

### [31].Next-Permutation

```js
/**
 * https://leetcode.com/problems/next-permutation/description/
 * Difficulty:Medium
 *
 * Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
 * If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
 * The replacement must be in-place, do not allocate extra memory.
 * Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
 * 1,2,3 → 1,3,2
 * 3,2,1 → 1,2,3
 * 1,1,5 → 1,5,1
 */
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  if (nums.length < 2) return;
  var peak = nums.length - 1;
  for (var i = peak - 1; nums[i] >= nums[peak]; peak = i--);

  if (peak !== 0) {
    var swapIndex = findSwap(nums, peak, nums.length - 1, peak - 1);
    if (swapIndex !== -1) {
      swap(nums, peak - 1, swapIndex);
    }
  }

  reverse(nums, peak, nums.length - 1);
};

function findSwap(nums, s, e, target) {
  for (var i = e; i >= s; i--) {
    if (nums[i] > nums[target]) return i;
  }
  return -1;
}

function swap(nums, s, e) {
  var t = nums[s];
  nums[s] = nums[e];
  nums[e] = t;
}
function reverse(nums, s, e) {
  // var len = e - s;
  for (var i = 0; i < Math.ceil((e - s) / 2); i++) {
    swap(nums, s + i, e - i);
  }
  // return nums;
}

// console.log(reverse([1, 2, 3, 4, 5], 0, 4));
// console.log(reverse([1, 2, 3, 4, 5], 3, 4));
// console.log(reverse([1, 2, 3, 4, 5], 2, 3));
// console.log(reverse([1, 2, 3, 4, 5], 1, 1));
// console.log(reverse([1, 2, 3, 4, 5], 1, 4));

// var nums = [1, 2, 5, 4, 3];
// console.log(nums);
// nextPermutation(nums);
// console.log(nums);
//
console.log('====');

var nums = [2, 3, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [1, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [3, 2, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);
```

### [32].Longest-Valid-Parentheses

```js
/**
 * https://leetcode.com/problems/longest-valid-parentheses/description/
 * Difficulty:Hard
 *
 * Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.
 * For "(()", the longest valid parentheses substring is "()", which has length = [2].
 * Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = [4].
 */

/**
 * 使用栈解决
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  var stack = [];
  for (var i = 0; i < s.length; i++) {
    if (s[i] === '(') stack.push(i);
    else {
      if (stack.length && s[stack[stack.length - 1]] === '(') stack.length--;
      else stack.push(i);
    }
  }

  if (!stack.length) return s.length;
  var longest = 0;
  var end = s.length;
  var start = 0;
  while (stack.length) {
    start = stack[stack.length - 1];
    stack.length--;
    longest = Math.max(longest, end - start - 1);
    end = start;
  }
  longest = Math.max(longest, end);
  return longest;
};

console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('())'), 2);
console.log(longestValidParentheses('(()'), 2);
console.log(longestValidParentheses('))()())((())))'), 6);
console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('('), 0);
console.log(longestValidParentheses(')()()))()()())'), 6);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('(()'), 2);
```

### [33].Search-in-Rotated-Sorted-Array

```js
/**
 * https://leetcode.com/problems/search-in-rotated-sorted-array/description/
 * Difficulty:Medium
 *
 * Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
 * (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
 * You are given a target value to search. If found in the array return its index, otherwise return -[1].
 * You may assume no duplicate exists in the array.
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  var lo = 0;
  var hi = nums.length - 1;
  while (lo < hi) {
    var mid = Math.floor((lo + hi) / 2);
    if (nums[mid] < nums[hi]) hi = mid;
    else lo = mid + 1;
  }
  var i = lo;

  lo = target < nums[0] ? i : 0;
  hi = target <= nums[nums.length - 1] ? nums.length - 1 : i;

  // console.log(nums, lo, hi);
  while (lo <= hi) {
    mid = Math.floor((lo + hi) / 2);
    // console.log(lo, mid, hi)
    if (nums[mid] < target) lo = mid + 1;
    else if (nums[mid] === target) return mid;
    else hi = mid - 1;
  }

  return -1;
};

console.log(search([], 5));
console.log(search([1], 0));
console.log(search([4, 5, 6, 7, 0, 1, 2], 2));
console.log(search([3, 1], 1));
```

### [34].Search-for-a-Range

```js
/**
 *
 * https://leetcode.com/problems/search-for-a-range/description/
 * Difficulty:Medium
 *
 * Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
 * Your algorithm's runtime complexity must be in the order of O(log n).
 * If the target is not found in the array, return [-1, -1].
 * For example,
 * Given [5, 7, 7, 8, 8, 10] and target value 8,
 * return [3, 4].
 *
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  var i = 0;
  var j = nums.length - 1;
  var ret = [-1, -1];
  while (i < j) {
    var mid = Math.floor((i + j) / 2);
    // console.log(i, mid, j);
    if (nums[mid] < target) i = mid + 1;
    else j = mid;
  }
  if (nums[i] !== target) return ret;
  ret[0] = i;
  j = nums.length - 1;
  while (i < j) {
    mid = Math.ceil((i + j) / 2);
    // console.log(i, mid, j);
    if (nums[mid] > target) j = mid - 1;
    else i = mid;
  }
  ret[1] = j;
  return ret;
};

console.log(searchRange([5, 7, 7, 8, 8, 10], 8));
```

### [35].Search-Insert-Position

```js
/**
 * https://leetcode.com/problems/search-insert-position/description/
 * Difficulty:Easy
 *
 * Given a sorted array and a target value, return the index if the target is found.
 * If not, return the index where it would be if it were inserted in order.
 *
 * You may assume no duplicates in the array.
 *
 * Here are few examples.
 * [1,3,5,6], 5 → 2
 * [1,3,5,6], 2 → 1
 * [1,3,5,6], 7 → 4
 * [1,3,5,6], 0 → 0
 */

/**
 * 解题思路
 *
 * 找到不比目标元素大的索引即可
 *
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  for (var i = 0; i < nums.length; i++) {
    if (target <= nums[i]) return i;
  }
  return i;
};

console.log(searchInsert([1, 3, 5, 6], 5) == 2);
console.log(searchInsert([1, 3, 5, 6], 2) == 1);
console.log(searchInsert([1, 3, 5, 6], 7) == 4);
console.log(searchInsert([1, 3, 5, 6], 0) == 0);
console.log(searchInsert([1, 3, 5, 6], 100) == 4);
```

### [36].Valid-Sudoku

```js
/**
 * https://leetcode.com/problems/valid-sudoku/description/
 * Difficulty:Medium
 *
 * Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.
 * The Sudoku board could be partially filled, where empty cells are filled with the character '.'.
 * A partially filled sudoku which is valid.
 * Note:
 * A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
 *
 */
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  for (var i = 0; i < 9; i++) {
    var rowNums = [];
    var colNums = [];
    var cubeNums = [];

    for (var j = 0; j < 9; j++) {
      var ch = board[i][j];
      if (ch !== '.') {
        if (rowNums.indexOf(ch) > -1) return false;
        rowNums.push(ch);
      }

      ch = board[j][i];
      if (ch !== '.') {
        if (colNums.indexOf(ch) > -1) return false;
        colNums.push(ch);
      }

      var row = Math.floor(i / 3) * 3 + Math.floor(j / 3);
      var col = (i % 3) * 3 + (j % 3);
      // console.log(i, j, row, col);
      ch = board[row][col];
      if (ch !== '.') {
        if (cubeNums.indexOf(ch) > -1) return false;
        cubeNums.push(ch);
      }
    }
  }
  return true;
};

// console.log(isValidSudoku([
//     [".", "8", "7", "6", "5", "4", "3", "2", "1"],
//     ["2", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["3", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["4", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["5", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["6", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["7", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["8", ".", ".", ".", ".", ".", ".", ".", "."],
//     ["9", ".", ".", ".", ".", ".", ".", ".", "."]]));
console.log(
  isValidSudoku([
    ['.', '.', '4', '.', '.', '.', '6', '3', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['5', '.', '.', '.', '.', '.', '.', '9', '.'],
    ['.', '.', '.', '5', '6', '.', '.', '.', '.'],
    ['4', '.', '3', '.', '.', '.', '.', '.', '1'],
    ['.', '.', '.', '7', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '5', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.'],
  ]),
);
```

### [37].Sudoku-Solver

```js
/**
 * https://leetcode.com/problems/sudoku-solver/description/
 * Difficulty:Hard
 *
 * Write a program to solve a Sudoku puzzle by filling the empty cells.
 * Empty cells are indicated by the character '.'.
 * You may assume that there will be only one unique solution.
 */

/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
  solve(board);
  console.log(board);
};

function solve(board) {
  for (var i = 0; i < 9; i++) {
    for (var j = 0; j < 9; j++) {
      var ch = board[i][j];
      if (ch === '.') {
        for (var k = 1; k <= 9; k++) {
          if (isValid(i, j, board, '' + k)) {
            board[i][j] = '' + k;
            // console.log(board);
            // console.log('-------------');
            if (solve(board)) {
              // console.log(board);
              // console.log('-------------');
              return true;
            } else {
              board[i][j] = '.';
            }
          }
        }
        return false;
      }
    }
  }
  return true;
}

function isValid(row, col, board, t) {
  for (var i = 0; i < 9; i++) {
    var ch = board[row][i];
    if (ch === t) return false;

    ch = board[i][col];
    if (ch === t) return false;

    ch = board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + (i % 3)];
    // if (row === 0 && col === 8) {
    //     console.log('~ ', Math.floor(row / 3) * 3 + Math.floor(i / 3), Math.floor(row / 3) * 3 + i % 3, ch);
    // }
    if (ch === t) return false;
  }
  return true;
}

console.log(
  solveSudoku([
    ['.', '.', '9', '7', '4', '8', '.', '.', '.'],
    ['7', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '2', '.', '1', '.', '9', '.', '.', '.'],
    ['.', '.', '7', '.', '.', '.', '2', '4', '.'],
    ['.', '6', '4', '.', '1', '.', '5', '9', '.'],
    ['.', '9', '8', '.', '.', '.', '3', '.', '.'],
    ['.', '.', '.', '8', '.', '3', '.', '2', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '6'],
    ['.', '.', '.', '2', '7', '5', '9', '.', '.'],
  ]),
);

console.log([
  ['5', '1', '9', '7', '4', '8', '6', '3', '2'],
  ['7', '8', '3', '6', '5', '2', '4', '1', '9'],
  ['4', '2', '6', '1', '3', '9', '8', '7', '5'],
  ['3', '5', '7', '9', '8', '6', '2', '4', '1'],
  ['2', '6', '4', '3', '1', '7', '5', '9', '8'],
  ['1', '9', '8', '5', '2', '4', '3', '6', '7'],
  ['9', '7', '5', '8', '6', '3', '1', '2', '4'],
  ['8', '3', '2', '4', '9', '1', '7', '5', '6'],
  ['6', '4', '1', '2', '7', '5', '9', '8', '3'],
]);
```

### [38].Count-and-Say

```js
/**
 * https://leetcode.com/problems/count-and-say/description/
 * Difficulty:Easy
 *
 * The count-and-say sequence is the sequence of integers with the first five terms as following:
 * [1].     1
 * [2].     11
 * [3].     21
 * [4].     1211
 * [5].     111221
 *
 * 1 is read off as "one 1" or [11].
 *
 * 11 is read off as "two 1s" or [21].
 *
 * 21 is read off as "one 2, then one 1" or [1211].
 *
 * Given an integer n, generate the nth term of the count-and-say sequence.
 *
 * Note: Each term of the sequence of integers will be represented as a string.
 *
 * Example 1:
 * Input: 1
 * Output: "1"
 *
 * Example 2:
 * Input: 4
 * Output: "1211"
 */

/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
  var ans = '1';
  for (var i = 1; i < n; i++) {
    var tmp = '';
    var cnt = 1;
    for (var j = 1; j < ans.length; j++) {
      if (ans[j] === ans[j - 1]) cnt++;
      else {
        tmp += cnt + ans[j - 1];
        cnt = 1;
      }
    }
    ans = tmp + cnt + ans[j - 1];
  }

  return ans;
};

console.log(countAndSay(1));
console.log(countAndSay(2));
console.log(countAndSay(3));
console.log(countAndSay(4));
console.log(countAndSay(5));
console.log(countAndSay(6));
```

### [39].Combination-Sum

```js
/**
 * https://leetcode.com/problems/combination-sum/description/
 * Difficulty:Medium
 *
 * Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
 * The same repeated number may be chosen from C unlimited number of times.
 * Note:
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 * For example, given candidate set [2, 3, 6, 7] and target 7,
 * A solution set is:
 * [
 *  [7],
 *  [2, 2, 3]
 * ]
 */

/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  var res = [];
  var temp = [];
  helper(res, temp, candidates, target, 0);
  return res;
};

function helper(res, temp, candidates, target, start) {
  if (target === 0) {
    res.push([...temp]);
    return;
  }

  for (var i = start; i < candidates.length; i++) {
    if (candidates[i] <= target) {
      temp.push(candidates[i]);
      helper(res, temp, candidates, target - candidates[i], i);
      temp.length -= 1;
    }
  }
}

console.log(combinationSum([1, 2, 3, 5, 6, 7], 7));
console.log(combinationSum([7, 2, 3, 5, 6, 1], 7));
```

### [40].Combination-Sum-II

```js
/**
 * Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
 * Each number in C may only be used once in the combination.
 * Note:
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 * For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
 * A solution set is:
 * [
 *  [1, 7],
 *  [1, 2, 5],
 *  [2, 6],
 *  [1, 1, 6]
 * ]
 */

/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
  var res = [];
  var temp = [];
  candidates.sort((b, a) => b - a);
  helper(res, temp, candidates, target, 0);
  return res;
};

function helper(res, temp, candidates, target, start) {
  if (target === 0) {
    return res.push([...temp]);
  }

  for (var i = start; i < candidates.length && candidates[i] <= target; i++) {
    if (i === start || candidates[i] !== candidates[i - 1]) {
      temp.push(candidates[i]);
      helper(res, temp, candidates, target - candidates[i], i + 1);
      temp.length -= 1;
    }
  }
}

console.log(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8));
```

### [46].Permutations

```js
/**
 * https://leetcode.com/problems/permutations/description/
 * Difficulty:Medium
 *
 * Given a collection of distinct numbers, return all possible permutations.
 * For example,
 * [1,2,3] have the following permutations:
 * [
 *  [1,2,3],
 *  [1,3,2],
 *  [2,1,3],
 *  [2,3,1],
 *  [3,1,2],
 *  [3,2,1]
 * ]
 */

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  if (!nums.length) return [];
  var res = [[]];
  for (var i = 0; i < nums.length; i++) {
    var len = res.length;
    for (var j = 0; j < len; j++) {
      var oldArr = res.shift();
      for (var k = 0; k <= oldArr.length; k++) {
        var newArr = oldArr.slice();
        newArr.splice(k, 0, nums[i]);
        res.push(newArr);
      }
    }
  }
  return res;
};
console.log(permute([1, 2, 3]));
```

### [47].Permutations-II

```js
/**
 * https://leetcode.com/problems/permutations-ii/description/
 * Difficulty:Medium
 *
 * Given a collection of numbers that might contain duplicates, return all possible unique permutations.
 * For example,
 * [1,1,2] have the following unique permutations:
 *  [
 *  [1,1,2],
 *  [1,2,1],
 *  [2,1,1]
 * ]
 */

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
  if (!nums.length) return [];
  nums.sort((a, b) => a - b);
  var res = [[]];
  for (var i = 0; i < nums.length; i++) {
    var len = res.length;
    for (var j = 0; j < len; j++) {
      var oldArr = res.shift();
      if (i > 0 && nums[i] === nums[i - 1]) {
        var k = oldArr.lastIndexOf(nums[i]);
      } else {
        k = 0;
      }
      for (; k <= oldArr.length; k++) {
        if (k === oldArr.length || nums[i] !== oldArr[k]) {
          var newArr = oldArr.slice();
          newArr.splice(k, 0, nums[i]);
          // console.log(oldArr, newArr);
          res.push(newArr);
        }
      }
    }
  }
  return res;
};

console.log(permuteUnique([1, 2, 2, 1]));
```

### [51].N-Queens

```js
/**
 * https://leetcode.com/problems/n-queens/description/
 * Difficulty:Hard
 *
 * The n-queens puzzle is the problem of placing n queens on an n×n chessboard
 * such that no two queens attack each other.
 *
 * Given an integer n, return all distinct solutions to the n-queens puzzle.
 * Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.
 *
 * For example,
 * There exist two distinct solutions to the 4-queens puzzle:
 * [
 *  [".Q..",  // Solution 1
 *   "...Q",
 *   "Q...",
 *   "..Q."],
 *
 *  ["..Q.",  // Solution 2
 *   "Q...",
 *   "...Q",
 *   ".Q.."]
 * ]
 * 2,1 3,2
 */

/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
  var ret = [];
  var board = [];
  for (var i = 0; i < n; i++) {
    board.push(new Array(n).fill('.'));
  }
  helper(board, 0, ret);
  return ret;
};

function helper(board, col, ret) {
  if (col === board.length) {
    ret.push(construct(board));
  } else {
    for (var i = 0; i < board.length; i++) {
      if (check(board, i, col)) {
        board[i][col] = 'Q';
        helper(board, col + 1, ret);
        board[i][col] = '.';
      }
    }
  }
}

function check(board, x, y) {
  for (var i = 0; i < board.length; i++) {
    for (var j = 0; j < y; j++) {
      if (board[i][j] === 'Q' && (i === x || i + j === x + y || i + y === j + x)) return false;
    }
  }
  return true;
}
function construct(board) {
  return board.map(arr => arr.join(''));
}
console.log(solveNQueens(4));
```

### [53].Maximum-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-subarray/description/
 * Difficulty:Easy
 *
 * Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
 *
 * For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
 * the contiguous subarray [4,-1,2,1] has the largest sum = [6].
 */

/**
 *
 * https://discuss.leetcode.com/topic/6413/dp-solution-some-thoughts
 *
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  var dp = [];
  var max = (dp[0] = nums[0]);

  for (var i = 1; i < nums.length; i++) {
    dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
    max = Math.max(dp[i], max);
  }

  return max;
};

/**
 * https://discuss.leetcode.com/topic/500/accepted-o-n-solution-in-java/11
 * @param nums
 * @returns {*}
 */
var maxSubArray = function(nums) {
  var max = nums[0];
  var sum = nums[0];

  for (var i = 1; i < nums.length; i++) {
    sum = sum > 0 ? sum + nums[i] : nums[i];
    max = Math.max(sum, max);
  }
  return max;
};

console.log(maxSubArray([1, 1, 1]) == 3);
console.log(maxSubArray([-1, -1, -1]) == -1);
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6);
console.log(maxSubArray([-2, -1]) == -1);
console.log(maxSubArray([-1]) == -1);
console.log(maxSubArray([-1, 0]) == 0);
```

### [62].Unique-Paths

```js
/**
 * https://leetcode.com/problems/unique-paths/
 * Difficulty:Medium
 *
 * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
 * The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
 * How many possible unique paths are there?
 * Note: m and n will be at most [100].
 *
 */

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  var arr = [];
  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      if (i === 0 && j === 0) arr[0] = 1;
      else {
        var left = j - 1 < 0 ? 0 : arr[i * n + j - 1];
        var top = i - 1 < 0 ? 0 : arr[(i - 1) * n + j];
        arr[i * n + j] = left + top;
      }
    }
  }
  return arr[arr.length - 1];
};

console.log(uniquePaths(2, 2));
```

### [63].Unique-Paths-II

```js
/**
 * https://leetcode.com/problems/unique-paths-ii/description/
 * Difficulty:Medium
 *
 * Follow up for "Unique Paths":
 * Now consider if some obstacles are added to the grids. How many unique paths would there be?
 * An obstacle and empty space is marked as 1 and 0 respectively in the grid.
 * For example,
 * There is one obstacle in the middle of a 3x3 grid as illustrated below.
 * [
 *  [0,0,0],
 *  [0,1,0],
 *  [0,0,0]
 * ]
 * The total number of unique paths is [2].
 * Note: m and n will be at most [100].
 */

/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
  var m = obstacleGrid.length;
  var n = obstacleGrid[0].length;
  var dp = [];
  while (dp.push(new Array(n + 1).fill(0)) <= m);

  dp[0][1] = 1;
  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      if (!obstacleGrid[i - 1][j - 1]) dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
    }
  }
  return dp[m][n];
};

console.log(uniquePathsWithObstacles([[0, 0]]));
```

### [64].Minimum-Path-Sum

```js
/**
 * https://leetcode.com/problems/minimum-path-sum/description/
 * Difficulty:Medium
 *
 * Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
 * Note: You can only move either down or right at any point in time.
 * Example 1:
 * [
 *  [1,3,1],
 *  [1,5,1],
 *  [4,2,1]
 * ]
 * Given the above grid map, return [7]. Because the path 1→3→1→1→1 minimizes the sum.
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
  var m = grid.length;
  var n = grid[0].length;
  var dp = [];
  while (dp.push(new Array(n + 1).fill(Number.MAX_VALUE)) <= m);
  dp[0][1] = 0;
  dp[1][0] = 0;

  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      dp[i][j] = grid[i - 1][j - 1] + Math.min(dp[i][j - 1], dp[i - 1][j]);
    }
  }

  return dp[m][n];
};

console.log(
  minPathSum([
    [1, 2],
    [1, 1],
  ]),
);
```

### [70].Climbing-Stairs

```js
/**
 * https://leetcode.com/problems/climbing-stairs/description
 * Difficulty:Easy
 *
 * You are climbing a stair case. It takes n steps to reach to the top.
 * Each time you can either climb 1 or 2 steps.
 * In how many distinct ways can you climb to the top?
 *
 * Note: Given n will be a positive integer.
 *
 * 答案:
 *
 * https://leetcode.com/articles/climbing-stairs/
 */

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
  if (n < 2) return 1;
  return climbStairs(n - 1) + climbStairs(n - 2);
};

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs2 = function(n) {
  var ways = [1, 1];
  for (var i = 2; i <= n; i++) {
    ways[i] = ways[i - 1] + ways[i - 2];
  }
  return ways[n];
};

console.log(climbStairs(1));
console.log(climbStairs(2));
console.log(climbStairs(3));
console.log(climbStairs(4));

console.log('==============');

console.log(climbStairs2(1));
console.log(climbStairs2(2));
console.log(climbStairs2(3));
console.log(climbStairs2(4));
```

### [83].Remove-Duplicates-from-Sorted-List

```js
/**
 * https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/
 * Difficulty:Easy
 *
 * Given a sorted linked list, delete all duplicates such that each element appear only once.
 *
 * For example,
 * Given 1->1->2, return 1->[2].
 * Given 1->1->2->3->3, return 1->2->[3].
 *
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
  var p = head;
  if (!p) return p;
  var all = [p.val];
  var t = p.next;

  while (t) {
    if (all.indexOf(t.val) == -1) {
      all.push(t.val);
      p = t;
      t = p.next;
    } else {
      t = t.next;
      p.next = t;
    }
  }
  return head;
};

/**
 * 改进方案
 *
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates2 = function(head) {
  var p = head;
  while (p && p.next) {
    if (p.val == p.next.val) {
      p.next = p.next.next;
    } else {
      p = p.next;
    }
  }
  return head;
};
```

### [85].Maximal-Rectangle

```js
/**
 * https://leetcode.com/problems/maximal-rectangle/description/
 * Difficulty:Hard
 * Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
 * For example, given the following matrix:
 *
 * 1 0 1 0 0
 * 1 0 1 1 1
 * 1 1 1 1 1
 * 1 0 0 1 0
 *
 * Return [6].
 *
 */

/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
  var m = matrix.length;
  if (!m) return 0;
  var n = matrix[0].length;
  if (!n) return 0;

  var dp = [];
  while (dp.push(new Array(n + 1).fill([0, 0])) <= m);
  var max = 0;
  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      if (matrix[i - 1][j - 1] != 0) {
        dp[i][j] = [1, 1];
        var top = dp[i - 1][j];
        var left = dp[i][j - 1];
        if (top[0] * top[1] === 0) {
          dp[i][j] = [1, left[1] + 1];
        } else if (left[0] * left[1] === 0) {
          dp[i][j] = [top[0] + 1, 1];
        } else {
          var x1 = top[0] + 1;
          var y1 = Math.min(top[1], left[1] + 1);
          var p1 = x1 * y1;

          var x2 = Math.min(left[0], top[0] + 1);
          var y2 = left[1] + 1;
          var p2 = x2 * y2;

          if (p1 >= p2) {
            dp[i][j] = [x1, y1];
          } else {
            dp[i][j] = [x2, y2];
          }
        }

        max = Math.max(max, dp[i][j][0] * dp[i][j][1]);
      }
    }
  }

  // for (var i = 0; i < matrix.length; i++) {
  //     console.log(matrix[i].split(''));
  // }
  // console.log('======================');
  //
  // for (var i = 1; i < dp.length; i++) {
  //     console.log(dp[i].slice(1).join(' | '));
  // }

  return max;
};

// console.log(maximalRectangle([
//     [1, 0, 1, 0, 0],
//     [1, 0, 1, 1, 1],
//     [1, 1, 1, 1, 1],
//     [1, 0, 0, 1, 0],
// ]));

// console.log(maximalRectangle(
//     ["1100", "1111", "11111", "1010"]
// ));

console.log(maximalRectangle(['10', '110', '11', '10']));
```

### [91].Decode-Ways

```js
/**
 * https://leetcode.com/problems/decode-ways/description/
 * Difficulty:Medium
 *
 * A message containing letters from A-Z is being encoded to numbers using the following mapping:
 *
 * 'A' -> 1
 * 'B' -> 2
 * ...
 * 'Z' -> 26
 *
 * Given an encoded message containing digits, determine the total number of ways to decode it.
 * For example,
 * Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).
 * The number of ways decoding "12" is [2].
 *
 */

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  if (!s.length) return 0;
  var dp = [];
  var n = s.length;
  dp[0] = 1;

  for (var i = 1; i <= n; i++) {
    dp[i] = 0;
    var sum1 = parseInt(s[i - 1]);
    var sum2 = parseInt(s[i - 2] + s[i - 1]);

    if (sum1 > 0 && sum1 < 10) {
      dp[i] += dp[i - 1];
    }
    if (sum2 > 9 && sum2 < 27) {
      dp[i] += dp[i - 2];
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(numDecodings('0'));
console.log(numDecodings('12'));
console.log(numDecodings('10'));
console.log(numDecodings('01'));
console.log(numDecodings('100'));
```

### [95].Unique-Binary-Search-Trees-II

```js
/**
 * https://leetcode.com/problems/unique-binary-search-trees-ii/description/
 * Difficulty:Medium
 *
 * Given an integer n, generate all structurally unique BST's (binary search trees) that store values [1]...n.
 *
 * For example,
 * Given n = 3, your program should return all 5 unique BST's shown below.
 *
 *  1         3     3      2      1
 *   \       /     /      / \      \
 *    3     2     1      1   3      2
 *   /     /       \                 \
 *  2     1         2                 3
 */

// Definition for a binary tree node.
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
  if (n === 0) return [];
  return _genTrees(1, n);
};

function _genTrees(start, end) {
  if (start > end) return [null];
  // if (start === end) return [new TreeNode(start)];
  var list = [];
  for (var i = start; i <= end; i++) {
    var leftTrees = _genTrees(start, i - 1);
    var rightTrees = _genTrees(i + 1, end);
    // console.log(leftTrees, rightTrees);

    leftTrees.forEach(left => {
      rightTrees.forEach(right => {
        var root = new TreeNode(i);
        root.left = left;
        root.right = right;
        list.push(root);
      });
    });
  }
  return list;
}

console.log(generateTrees(0));
```

### [96].Unique-Binary-Search-Trees

```js
/**
 * https://leetcode.com/problems/unique-binary-search-trees/description/
 * Difficulty:Medium
 *
 * Given n, how many structurally unique BST's (binary search trees) that store values [1]...n?
 * For example,
 * Given n = 3, there are a total of 5 unique BST's.
 *
 *   1         3     3      2      1
 *    \       /     /      / \      \
 *    3      2     1      1   3      2
 *   /      /       \                 \
 *  2      1         2                 3
 *
 */

/**
 * G(n): the number of unique BST for a sequence of length n.
 * F(i, n), 1 <= i <= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.
 *
 * G(n) = F(1, n) + F(2, n) + ... + F(n, n).
 * G(0)=1, G(1)=[1].
 *
 * F(i, n) = G(i-1) * G(n-i)    1 <= i <= n
 * G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)
 *
 *
 *
 */

/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  var dp = [1, 1];

  for (var i = 2; i <= n; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      dp[i] += dp[j] * dp[i - j - 1];
    }
  }
  return dp[n];
};

console.log(numTrees(1));
console.log(numTrees(2));
console.log(numTrees(3));
```

### [100].Same-Tree

```js
/**
 * https://leetcode.com/problems/same-tree/description/
 * Difficulty:Easy
 *
 * Given two binary trees, write a function to check if they are equal or not.
 * Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
  if (!p && !q) return true;
  if (!p || !q) return false;
  if (p.val !== q.val) return false;

  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

### [11].

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  let maxArea = 0;
  let left = 0,
    right = height.length - 1;
  while (left < right) {
    maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return maxArea;
};

const arr = [3, 4, 6, 2, 8, 4, 3, 1, 3, 4, 4];
console.log(maxArea(arr));
```

### [12].

```js
/**
 * @param {number} num (1-3999)
 * @return {string}
 */
var intToRoman = function(num) {
  let ans = '';
  while (num >= 100) {
    num -= 100;
    ans += 'M';
  }
  while (num >= 500) {
    num -= 500;
    ans += 'D';
  }
  while (num >= 100) {
    num -= 100;
    ans += 'C';
  }
  while (num >= 50) {
    num -= 50;
    ans += 'L';
  }
  while (num >= 10) {
    num -= 10;
    ans += 'X';
  }
  while (num >= 5) {
    num -= 5;
    ans += 'V';
  }
  while (num >= 1) {
    num -= 1;
    ans += 'I';
  }

  ans = ans.replace('DCCCC', 'CM');
  ans = ans.replace('CCCC', 'CD');
  ans = ans.replace('LXXXX', 'XC');
  ans = ans.replace('XXXX', 'XL');
  ans = ans.replace('VIIII', 'IX');
  ans = ans.replace('IIII', 'IV');
  return ans;
};

console.log(intToRoman(58));
console.log(intToRoman(3));
console.log(intToRoman(4));
console.log(intToRoman(1994));
```

### [13].

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
  let num = 0;
  if (s.includes('IV')) num -= 2;
  if (s.includes('IX')) num -= 2;
  if (s.includes('XL')) num -= 20;
  if (s.includes('XC')) num -= 20;
  if (s.includes('CD')) num -= 200;
  if (s.includes('CM')) num -= 200;

  for (let c of s) {
    switch (c) {
      case 'I':
        num += 1;
        break;
      case 'V':
        num += 5;
        break;
      case 'X':
        num += 10;
        break;
      case 'L':
        num += 50;
        break;
      case 'C':
        num += 100;
        break;
      case 'D':
        num += 500;
        break;
      case 'M':
        num += 100;
        break;
    }
  }
  return num;
};
```

### [14].

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
  let ans = strs.length > 0 ? strs[0] : '';
  for (let i = 1; i < strs.length; i++) {
    if (!strs[i].startsWith(ans)) {
      for (let j = 0; j < ans.length; j++) {
        if (ans[j] != strs[i][j]) {
          ans = ans.slice(0, j);
        }
      }
    }
  }
  return ans;
};
```

### [15].

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const sum = nums[i] + nums[j];
      const bs = binarySearch(nums, -sum, 0, nums.length - 1);
      if (bs != null && bs != i && bs != j) {
        let mArr = [nums[i], nums[j], nums[bs]].sort(function(a, b) {
          return a - b;
        });
        if (!has(ans, mArr)) {
          ans.push(mArr);
        }
      }
    }
  }
  return ans;
};

function binarySearch(arr, val, lo, hi) {
  if (lo > hi) return null;
  let mid = lo + parseInt((hi - lo) / 2);
  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

function has(arr, target) {
  for (let cur of arr) {
    let isEqual = true;
    for (let i = 0; i < target.length; i++) {
      if (cur[i] != target[i]) {
        isEqual = false;
      }
    }
    if (isEqual) return true;
  }
  return false;
}

// console.log(threeSum([-1, 0, 1, 2, -1, -4]))

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum2 = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) {
      continue;
    }
    let j = i + 1,
      k = nums.length - 1;
    let target = -nums[i];
    while (j < k) {
      if (nums[j] + nums[k] == target) {
        ans.push([nums[i], nums[j], nums[k]]);
        j++;
        k--;
        while (j < k && nums[j] == nums[j - 1]) j++;
        while (j < k && nums[k] == nums[k + 1]) k--;
      } else if (nums[j] + nums[k] > target) {
        k--;
      } else {
        j++;
      }
    }
  }
  return ans;
};

console.log(threeSum2([-2, 0, 0, 2, 2]));
```

### [16].

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let minDiff = nums[nums.length - 1] - nums[0];
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const sum = nums[i] + nums[j] - target;
      const bs = binarySearch(nums, -sum, 0, nums.length - 1);

      if (bs != i && bs != j) {
        if (sum - nums[bs] < minDiff) {
          minDiff = sum - nums[bs];
        }
      }
    }
  }
  return minDiff;
};

function binarySearch(arr, val, lo, hi) {
  if (hi - lo == 1) {
    if (arr[hi] - val > val - arr[lo]) {
      return lo;
    } else {
      return hi;
    }
  }
  let mid = lo + parseInt((hi - lo) / 2);
  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

const nums = [-1, 2, 1, -4];
threeSumClosest(nums, 1);
```

### [17].

```js
// var letterCombinations = function (digits) {
//     var map = {
//         "2": ["a", "b", "c"],
//         "3": ["d", "e", "f"],
//         "4": ["g", "h", "i"],
//         "5": ["j", "k", "l"],
//         "6": ["m", "n", "o"],
//         "7": ["p", "q", "r", "s"],
//         "8": ["t", "u", "v"],
//         "9": ["w", "x", "y", "z"]
//     };
//     // 第一个字符
//     var rtn = map[digits[0]];
//     digits = digits.substr(1);
//     // 遍历字符
//     digits.split("").forEach(function (digit) {
//         var t = [];
//         // 遍历相对符号
//         map[digit].forEach(function (letter) {
//             t = t.concat(rtn.map(function (item) {
//                 // 合并
//                 return item + letter;
//             }));
//         });
//         rtn = t;
//     });
//     return rtn === undefined ? [] : rtn;
// };

/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  var map = {
    '2': ['a', 'b', 'c'],
    '3': ['d', 'e', 'f'],
    '4': ['g', 'h', 'i'],
    '5': ['j', 'k', 'l'],
    '6': ['m', 'n', 'o'],
    '7': ['p', 'q', 'r', 's'],
    '8': ['t', 'u', 'v'],
    '9': ['w', 'x', 'y', 'z'],
  };
  var ans = map[digits[0]];
  digits = digits.substring(1);
  digits.split('').forEach(function(digit) {
    var arr = [];
    map[digit].forEach(function(letter) {
      arr = arr.concat(
        ans.map(function(item) {
          return item + letter;
        }),
      );
    });
    ans = arr;
  });
  return ans ? [] : ans;
};

console.log(letterCombinations('23'));
```

### [19].

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let dummy = new ListNode(0);
  dummy.next = head;
  let first = dummy;
  let second = dummy;
  for (let i = 1; i <= n + 1; i++) {
    first = first.next;
  }
  while (first != null) {
    first = first.next;
    second = second.next;
  }
  second.next = second.next.next;
  return dummy.next;
};

// if (head.next == null) return null
// let fast = head.next, slow = head
// let i = 1
// while (i < n) {
//     if (fast.next) {
//         fast = fast.next
//     }
//     i++
// }
// if (fast.next) {
//     if (fast.next.next) fast.next = fast.next.next
//     else fast.next = null
// }
// return head
```

### [13].

```js
// [13]. Roman to Integer

// Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

// Symbol       Value
// I             1
// V             5
// X             10
// L             50
// C             100
// D             500
// M             100
// For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

// Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

// I can be placed before V (5) and X (10) to make 4 and [9].
// X can be placed before L (50) and C (100) to make 40 and [90].
// C can be placed before D (500) and M (100) to make 400 and [900].
// Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to [3999].

// Example 1:

// Input: "III"
// Output: 3
// Example 2:

// Input: "IV"
// Output: 4
// Example 3:

// Input: "IX"
// Output: 9
// Example 4:

// Input: "LVIII"
// Output: 58
// Explanation: L = 50, V= 5, III = [3].
// Example 5:

// Input: "MCMXCIV"
// Output: 1994
// Explanation: M = 100, CM = 900, XC = 90 and IV = [4].

/**
 * @param {string} s
 * @return {number}
 */
export default function romanToInt(s) {
  let total = 0;
  const map = new Map([
    ['I', 1],
    ['V', 5],
    ['X', 10],
    ['L', 50],
    ['C', 100],
    ['D', 500],
    ['M', 100],
  ]);
  for (let i = 0; i < s.length; i++) {
    const curr = map.get(s[i]);
    if (i + 1 < s.length) {
      if (map.get(s[i + 1]) > curr) {
        total -= curr;
      } else {
        total += curr;
      }
    } else {
      total += curr;
    }
  }
  return total;
}
```

### [20].有效的括号

```js
// Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

// An input string is valid if:

// Open brackets must be closed by the same type of brackets.
// Open brackets must be closed in the correct order.
// Note that an empty string is also considered valid.

// Example 1:

// Input: "()"
// Output: true
// Example 2:

// Input: "()[]{}"
// Output: true
// Example 3:

// Input: "(]"
// Output: false
// Example 4:

// Input: "([)]"
// Output: false
// Example 5:

// Input: "{[]}"
// Output: true

/**
 * @param {string} s
 * @return {boolean}
 */
export default function isValid(s) {
  const stack = [];
  const map = new Map([
    [')', '('],
    ['}', '{'],
    [']', '['],
  ]);
  const closing = new Set([')', '}', ']']);
  for (let i = 0; i < s.length; i++) {
    if (stack.length) {
      const top = stack[stack.length - 1];
      // if s[i] is closing, must match
      if (closing.has(s[i])) {
        // if matches top of stack, pop stack
        if (map.get(s[i]) === top) {
          stack.pop();
        } else {
          return false;
        }
      } else {
        stack.push(s[i]);
      }
    } else if (stack.length === 0 && closing.has(s[i])) {
      return false;
    } else {
      stack.push(s[i]);
    }
  }
  return stack.length === 0;
}
```

```js
/*
 * @lc app=leetcode.cn id=20 lang=javascript
 *
 * [20] 有效的括号
 */
// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

// 有效字符串需满足：

// 左括号必须用相同类型的右括号闭合。
// 左括号必须以正确的顺序闭合。
// 注意空字符串可被认为是有效字符串。

// 示例 1:

// 输入: "()"
// 输出: true
// 示例 2:

// 输入: "()[]{}"
// 输出: true
// 示例 3:

// 输入: "(]"
// 输出: false
// 示例 4:

// 输入: "([)]"
// 输出: false
// 示例 5:

// 输入: "{[]}"
// 输出: true
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  const stack = [];

  for (let l of s) {
    if (l.trim()) {
      stack.push(l);
      const length = stack.length;
      if (length > 1 && ['{}', '[]', '()'].includes(stack[length - 2] + stack[length - 1])) {
        stack.length -= 2;
      }
    }
  }

  return !stack.length;
};

// 最高赞
var isValid1 = function(s) {
  var st = [];
  for (var l of s)
    if ((i = '({[]})'.indexOf(l)) > -1)
      if (st[st.length - 1] + i === 5) st.length--;
      else st.push(i);
  return st.length === 0;
};

['()', '()[]{}', '(]', '([)]', '{[]}'].forEach(elm => {
  console.log(isValid(elm));
});
```

### [21].merge-two-sorted-lists 合并两个有序链表

```js
// [21]. Merge Two Sorted Lists

// Merge two sorted linked lists and return it as a new list. The new list should be
// made by splicing together the nodes of the first two lists.

// Example:
// Input: 1->2->4, 1->3->4
// Output: 1->1->2->3->4->4

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
export default function mergeTwoLists(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;
  let head = l1.val < l2.val ? l1 : l2;
  const first = head;
  let other = l1.val < l2.val ? l2 : l1;

  while (head && other) {
    if (!head.next) {
      head.next = other;
      break;
    } else if (head.next.val <= other.val) {
      head = head.next;
    } else {
      const dummy = head.next;
      head.next = other;
      other = dummy;
      head = head.next;
    }
  }

  return first;
}
```

```js
/*
 * @lc app=leetcode id=21 lang=javascript
 *
 * [21] Merge Two Sorted Lists
 *
 * https://leetcode.com/problems/merge-two-sorted-lists/description/
 *
 * algorithms
 * Easy ([46].02%)
 * Total Accepted:    [562].7K
 * Total Submissions: [1].2M
 * Testcase Example:  '[1,2,4]\n[1,3,4]'
 *
 * Merge two sorted linked lists and return it as a new list. The new list
 * should be made by splicing together the nodes of the first two lists.
 *
 * Example:
 *
 * Input: 1->2->4, 1->3->4
 * Output: 1->1->2->3->4->4
 *
 *
 */

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
// l1 l2 只是两个引用
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  // 需要 return 的是头节点的引用， current 指针会移动
  const dummy = current;

  // 需要循环到两个链表节点都为空
  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  // dummy 是一个空的头节点，还是需要反馈开头的第一个节点
  return dummy.next;
};

var newMergeTwoLists = function(l1, l2) {
  if (l1 === null) return l2;
  if (l2 === null) return l1;
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

let l1 = List([1, 2, 4]);
ListToString.call(l1);

let l2 = List([1, 3, 4]);
ListToString.call(l2);

const mergeTwoLists1 = (l1, l2) => {
  let current = new ListNode();
  const guard = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return guard.next;
    }
    if (!l2) {
      current.next = l1;
      return guard.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    // 移动节点
    current = current.next;
  }
  return guard.next;
};

let l3 = mergeTwoLists1(l1, l2);
ListToString.call(l3);
```

```js
/*
 * @lc app=leetcode.cn id=21 lang=javascript
 *
 * [21] 合并两个有序链表
 * 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
 * 输入：1->2->4, 1->3->4
 * 输出：1->1->2->3->4->4
 */

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  const bool = l1.val <= l2.val,
    l3 = new ListNode(bool ? l1.val : l2.val),
    current = l3;
  if (bool) {
    l1 = l1.next;
  } else {
    l2 = l2.next;
  }
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      current.next = l1;
      current = current.next;
      l1 = l1.next;
    } else {
      current.next = l2;
      current = current.next;
      l2 = l1.next;
    }
  }

  if (l1) {
  }

  return current;
};

function List(arr) {
  let current = new ListNode();
  const guard = current;
  for (let i = 0; i < arr.length; i++) {
    current.next = new ListNode(arr[i]);
  }

  return guard.next;
}

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

const l1 = List([1, 1, 2]),
  l2 = List([1, 1, 2, 3, 3]);
ListToString.call(l1);
ListToString.call(l2);
```

### [24].

```js
// [24]. Swap Nodes in Pairs

// Given a linked list, swap every two adjacent nodes and return its head.

// You may not modify the values in the list's nodes, only nodes itself may be changed.

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function swapPairs(head) {
  let curr = head;
  let prev = null;
  let newHead;
  while (curr && curr.next) {
    const tmp = curr;
    const { next } = curr;
    if (!newHead) newHead = next;
    if (prev) prev.next = next;
    curr = curr.next.next;
    next.next = tmp;
    tmp.next = curr;
    prev = tmp;
  }
  return newHead || head;
}
```

### [26].删除排序数组中的重复项

```js
/*
 * @lc app=leetcode.cn id=26 lang=javascript
 *
 * [26] 删除排序数组中的重复项
 */

// 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

// 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

// 示例 1:

// 给定数组 nums = [1, 1, 2],

//   函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。

// 你不需要考虑数组中超出新长度后面的元素。
// 示例 2:

// 给定 nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4],

//   函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

// 你不需要考虑数组中超出新长度后面的元素。
// 说明:

// 为什么返回数值是整数，但输出的答案是数组呢 ?

//   请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

// 你可以想象内部操作如下:

// // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
// int len = removeDuplicates(nums);

// // 在函数里修改输入数组对于调用者是可见的。
// // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const cached = {};
  for (let i = 0; i < nums.length; i++) {
    if (!cached[nums[i]]) {
      cached[nums[i]] = true;
    } else {
      nums.splice(i, 1);
      i--;
    }
  }
  return nums.length;
};

var removeDuplicates1 = function(nums) {
  // 给定的是一个排序数组， 所以甚至于不用 map
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) {
      nums.splice(i, 1);
      i--;
    }
  }
  return nums.length;
};

[[1, 1, 2], [0, 0, 1, 1, 1, 2, 2, 3, 3, 4], [9]].forEach(elm => {
  console.log(removeDuplicates(elm));
});
```

### [28].实现-str-str

```js
/*
 * @lc app=leetcode.cn id=28 lang=javascript
 *
 * [28] 实现 strStr()
 */
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 * 实现一个 indexOf 函数
 */
var strStr = function(haystack, needle) {
  var m = haystack.length,
    n = needle.length;
  if (!n) return 0;
  var lps = kmpProcess(needle);
  for (var i = 0, j = 0; i < m; ) {
    if (haystack[i] == needle[j]) {
      i++, j++;
    }
    if (j == n) return i - j;
    if (i < m && haystack[i] != needle[j]) {
      if (j) j = lps[j - 1];
      else i++;
    }
  }
  return -1;
};

var kmpProcess = function(needle) {
  var n = needle.length;
  var lps = new Array(n).fill(0);
  for (var i = 1, length = 0; i < n; ) {
    if (needle[i] === needle[length]) {
      length++;
      lps[i] = length;
      i++;
    } else if (length) length = lps[length - 1];
    else {
      lps[i] = 0;
      i++;
    }
  }
  return lps;
};
```

### [30].串联所有单词的子串

```js
/*
 * @lc app=leetcode.cn id=30 lang=javascript
 *
 * [30] 串联所有单词的子串
 */
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  const result = [];
  // [1]. 算出子串
  const sub = getSubStr(words);
  console.log(sub);
  for (let i = 0; i < sub.length; i++) {
    const index = s.indexOf(sub[i]);
    if (index !== -1) {
      result.push(index);
    }
  }
  return result;

  // [2]. 正则计算. 全局匹配
};

function getSubStr(arr) {
  if (arr.length < 2) return arr;
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const sub = getSubStr(arr.slice(1));
    for (let j = 0; j < sub.length; j++) {
      if (i !== j) {
        result.push(`${arr[i]}${sub[j]}`);
      }
    }
  }
  return result;
}

console.log(findSubstring('barfoothefoobarman', ['foo', 'bar']));
// console.log(findSubstring('wordgoodgoodgoodbestword', ["word", "good", "best", "word"]))
```

### [30].串联所有单词的子串 copy

```js
/*
 * @lc app=leetcode.cn id=30 lang=javascript
 *
 * [30] 串联所有单词的子串
 */
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  const reg = new RegExp();
};

const factorial = n => {
  if (n === 1) return 1;
  return n * factorial(n - 1);
};

console.log('factorial', factorial(2));
console.log('factorial', factorial(3));
```

### [34].find-first-and-last-position-of-element-in-sorted-array 在排序数组中查找元素的第一个和最后一个位置

```js
/*
 * @lc app=leetcode id=34 lang=javascript
 *
 * [34] Find First and Last Position of Element in Sorted Array
 * 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
 * 你的算法时间复杂度必须是 O(log n) 级别。
 * 如果数组中不存在目标值，返回 [-1, -1]。
 * 示例 1:
 * 输入: nums = [5,7,7,8,8,10], target = 8
 * 输出: [3,4]
 * 示例 2:
 * 输入: nums = [5,7,7,8,8,10], target = 6
 * 输出: [-1,-1]
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 题目要求时间复杂度为O(logn)因此很自然想到二分法
  let start = 0;
  let end = nums.length - 1;
  while (start <= end) {
    // >> 1 除以 2 取整； << 1 乘 2
    const mid = start + ((end - start) >> 1);

    if (nums[mid] === target) {
      let left = 0;
      let right = 0;

      while (nums[mid - left] === target) {
        left++;
      }
      while (nums[mid + right] === target) {
        right++;
      }
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return [-1, -1];
};
```

```js
/*
 * @lc app=leetcode.cn id=34 lang=javascript
 *
 * [34] 在排序数组中查找元素的第一个和最后一个位置
 * 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
 * 你的算法时间复杂度必须是 O(log n) 级别。
 * 如果数组中不存在目标值，返回 [-1, -1]。
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 升序， 并且对时间复杂度有要求是 O(logn) 只能是 二分搜索
  let start = 0,
    end = nums.length - 1,
    mid;
  // 需要给 = ，处理 length === 1 的情况
  while (start <= end) {
    mid = start + ((end - start) >> 1);
    let left = (right = 0);
    if (nums[mid] === target) {
      while (nums[mid - left] === target) left++;
      while (nums[mid + right] === target) right++;
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else if (nums[mid] < target) {
      start = mid + 1;
    }
  }

  return [-1, -1];
};

console.log(searchRange([5, 7, 7, 8, 8, 10], 8));
console.log(searchRange([1], 1));
```

### [35].

```js
// [35]. Search Insert Position

// Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

// You may assume no duplicates in the array.

// Example 1:

// Input: [1,3,5,6], 5
// Output: 2
// Example 2:

// Input: [1,3,5,6], 2
// Output: 1
// Example 3:

// Input: [1,3,5,6], 7
// Output: 4
// Example 4:

// Input: [1,3,5,6], 0
// Output: 0

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
export default function searchInsert(nums, target) {
  if (!nums.length) return -1;
  let lo = 0;
  let hi = nums.length - 1;
  while (lo <= hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] === target) return mid;
    if (lo === hi) return nums[lo] < target ? lo + 1 : lo;
    if (nums[mid] < target) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
}
```

### [38].报数

```js
/*
 * @lc app=leetcode.cn id=38 lang=javascript
 *
 * [38] 报数
 */
/**
 * @param {number} n
 * @return {string}
 */
const result = {};
var countAndSay = function(n) {
  let start = '1',
    tmp = 1,
    res = '';
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < start.length; j++) {
      if (j === start.length - 1 || start[j] !== start[j + 1]) {
        res += `${tmp}${start[j]}`;
        tmp = 1;
      } else {
        tmp++;
      }
    }
    start = res;
    res = '';
  }
  return start;
};

// [1].     1
// [2].     11
// [3].     21
// [4].     1211
// [5].     111221

// f(n) = read(f(n - 1))
// ...
// f(2) = read(f(1))
// f(1) = 1

// f(x) = `${num}num1...`
// console.log(countAndSay(1))
// console.log(countAndSay(2))
// console.log(countAndSay(3))
// console.log(countAndSay(4))
// console.log(countAndSay(5))
// console.log(countAndSay(10))
// console.log(countAndSay(25))
```

### [41].缺失的第一个正数

```js
/*
 * @lc app=leetcode.cn id=41 lang=javascript
 *
 * [41] 缺失的第一个正数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
// ✔ Accepted
// ✔ 165 / 165 cases passed(100 ms)
// ✔ Your runtime beats [27].41 % of javascript submissions
// ✔ Your memory usage beats [18].66 % of javascript submissions(35 MB)
var firstMissingPositive = function(nums) {
  nums = nums.filter(num => num > 0).sort((a, b) => a - b);
  if (nums.length) {
    if (nums[0] === 1) {
      for (let i = 1; i < nums.length; i++) {
        if (nums[i] - nums[i - 1] > 1) {
          return nums[i - 1] + 1;
        }
      }
      return nums.pop() + 1;
    } else {
      return 1;
    }
  }

  // 正整数数组为空，直接返回 1
  return 1;
};

// ✔ Accepted
// ✔ 165 / 165 cases passed(88 ms)
// ✔ Your runtime beats [57].46 % of javascript submissions
// ✔ Your memory usage beats [7].65 % of javascript submissions([35].4 MB)
// 选择排序 每一轮都会选出最小值
var firstMissingPositive2 = function(nums) {
  nums = nums.filter(num => num > 0);
  // 数组过滤了之后为空直接返回 1
  if (nums.length === 0) return 1;
  for (let i = 0, minIndex, len = nums.length; i < len; i++) {
    minIndex = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }
    if (i !== minIndex) [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    // 判断最小的数是否是 1
    if (i === 0) {
      if (nums[i] !== 1) return 1;
      // 大于 1 之后，每次都可以比较前面部分，前面部分是有序的， 后面部分还是无序
    } else if (nums[i] - nums[i - 1] > 1) {
      return nums[i - 1] + 1;
    }
  }
  return nums.pop() + 1;
};

console.log(firstMissingPositive([]));
console.log(firstMissingPositive([2]));
console.log(firstMissingPositive([1, 2, 0]));
console.log(firstMissingPositive([3, 4, -1, 1]));
console.log(firstMissingPositive([7, 8, 9, 11, 12]));
console.log(firstMissingPositive([0, 2, 2, 1, 1]));
```

### [50].pow-x-n

```js
/*
 * @lc app=leetcode.cn id=50 lang=javascript
 *
 * [50] Pow(x, n)
 */
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (n === 0) return 1;
  if (n === 1) return x;

  let pow = Math.abs(n);
  const result = pow % 2 === 0 ? myPow(x * x, pow / 2) : myPow(x * x, (pow - 1) / 2) * x;
  return n > 0 ? result : 1 / result;
};

console.log(myPow([8].95371, -1));
```

### [53].最大子序和

```js
/*
 * @lc app=leetcode.cn id=53 lang=javascript
 *
 * [53] 最大子序和
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
// 典型的动态规划 dp[i] = max(dp[i-1] + num[i], dp[i-2])
var maxSubArray = function(nums) {
  if (nums.length < 2) return nums.length === 0 ? 0 : nums[0];
  let max = nums[0];
  for (let i = 1; i < nums.length; i++) {
    // 跟 nums[i] 比较的话， nums[i] 更大表示选取当前值，否则就不选
    // sums[i] = Math.max(sums[i - 1] + nums[i], nums[i])
    // 或者换一种想法就是，判断前一次的结果是否大于 0
    // 大于的话加上当前位置的值，就是最长序列
    // 否则的话，加上前面的和只会更小，也就是只取当前位置为一个新数组
    nums[i] = nums[i] + Math.max(nums[i - 1], 0);
    if (nums[i] > max) {
      max = nums[i];
    }
  }
  return max;
};

console.log(maxSubArray([-2, 1, -3, 4]));
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

### [56].合并区间

```js
/*
 * @lc app=leetcode.cn id=56 lang=javascript
 *
 * [56] 合并区间
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
// 两个区间若能合并，则第一个区间的右端点一定不小于第二个区间的左端点。所以先把区间集合按照左端点从小到大进行排序，接着从第一个区间开始遍历，对每个区间执行如下操作：

// [1]. 首先保存该区间的左端点start和右端点end
// [2]. 从该区间的下一个区间开始，依次比较此区间的左端点与上一个区间的右端点，若满足合并条件则记录新合并区间的右端点。注意右端点取当前区间与之前区间右端点的较大值
// [3]. 若当前区间不再满足合并条件或者遍历到了集合末尾，就构建新合并区间，其中左端点为初始区间的左端点，右端点为当前所有合并区间右端点的最大值，然后将其加入到结果集合中，接着合并下一个区间
var merge = function(intervals) {
  if (intervals.length < 2) return intervals;
  intervals = intervals.sort((a, b) => a[0] - b[0]);
  let left = intervals[0][0],
    right = intervals[0][1];

  for (let i = 1; i < intervals.length; i++) {}
};
```

### [58].最后一个单词的长度

```js
/*
 * @lc app=leetcode.cn id=58 lang=javascript
 *
 * [58] 最后一个单词的长度
 */
// 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。

// 如果不存在最后一个单词，请返回 0 。

// 说明：一个单词是指由字母组成，但不包含任何空格的字符串。

/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
  const resp = s.split(' ').filter(elm => elm.trim());
  return resp.length ? resp.pop().length : 0;
};

['Hello World', '', ' ', 'Hello World ', ' a', 'b   a    '].forEach(elm => {
  console.log(lengthOfLastWord(elm));
});
```

### [64].最小路径和

```js
/*
 * @lc app=leetcode.cn id=64 lang=javascript
 *
 * [64] 最小路径和
 */
/**
 * @param {number[][]} grid
 * @return {number}
 */
// 这是最基础的动态规划题目。 不过是二维的。
// dp[i][j]代表从(0, 0)走到(i, j)的最小路径和则
// dp[0][i]来自第一行的累加
// dp[i][0]来自第一列的累加
// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + c[i][j]
// (来自当前位置的走法无非向下或向右，选两者中代价最小的)
var minPathSum = function(grid) {
  const row = grid.length;
  const line = grid[0].length;
  const dp = [];
  dp[0] = [grid[0][0]];
  for (let i = 1; i < row; i++) {
    if (dp[i] === undefined) {
      dp[i] = [];
    }
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }
  for (let j = 1; j < line; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }
  for (let i = 1; i < row; i++) {
    for (let j = 1; j < line; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  // console.log(dp)
  return dp[row - 1][line - 1];
};

console.log(
  minPathSum([
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
  ]),
);

console.log(
  minPathSum([
    [0, 1],
    [1, 0],
  ]),
);
```

### [66].加一

```js
/*
 * @lc app=leetcode.cn id=66 lang=javascript
 *
 * [66] 加一
 */

// 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

// 你可以假设除了整数 0 之外，这个整数不会以零开头。

// 示例 1:

// 输入: [1, 2, 3]
// 输出: [1, 2, 4]
// 解释: 输入数组表示数字 123。
// 示例 2:

// 输入: [4, 3, 2, 1]
// 输出: [4, 3, 2, 2]
// 解释: 输入数组表示数字 4321。

/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  let shouldAddOne = true;
  for (let i = digits.length - 1; i >= 0; i--) {
    if (shouldAddOne) {
      if (digits[i] === 9) {
        digits[i] = 0;
        shouldAddOne = true;
      } else {
        digits[i] += 1;
        shouldAddOne = false;
      }
    }
  }
  if (shouldAddOne) {
    digits.unshift(1);
  }

  return digits;
};

[[1, 2, 3], [4, 3, 2, 1], [9]].forEach(elm => {
  console.log(plusOne(elm));
});
```

### [67].二进制求和 copy 2

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */

function getLastChar(str) {
  if (str) {
    return str[str.length - 1];
  }
  return 0;
}

function advance(str) {
  if (str) {
    return str.slice(0, -1);
  }
}
var addBinary = function(a, b) {
  let result = [],
    carry = 0; // 进位
  while (a || b || carry) {
    let valueA = parseInt(getLastChar(a)),
      valueB = parseInt(getLastChar(b));

    const needCarry = valueA + valueB + carry > 1;

    result.push(needCarry ? valueA + valueB + carry - 2 : valueA + valueB + carry);

    a = advance(a);
    b = advance(b);

    carry = needCarry ? 1 : 0;
  }

  return result.reverse().join('');
};

console.log(addBinary('111', '1'));
console.log(addBinary('1', '1'));
```

### [67].二进制求和 copy

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary1 = function(a, b) {
  let c = 0;
  let aLen = a.length;
  let bLen = b.length;
  let ans = '';
  for (var i = 0; i < Math.max(aLen, bLen); i++) {
    var ai = i < aLen ? parseInt(a[aLen - i - 1]) : 0;
    var bi = i < bLen ? parseInt(b[bLen - i - 1]) : 0;

    var sum = ai + bi + c;
    // console.log(ai, bi, c);
    if (sum < 2) {
      ans = sum + ans;
      c = 0;
    } else {
      ans = sum - 2 + ans;
      c = 1;
    }
  }
  if (c) {
    ans = 1 + ans;
  }

  return ans;
};

console.log(addBinary1('111', '1'));
```

### [67].二进制求和

```js
// Given two binary strings, return their sum (also a binary string).

// The input strings are both non-empty and contains only characters 1 or [0].

// Example 1:

// Input: a = "11", b = "1"
// Output: "100"
// Example 2:

// Input: a = "110", b = "111"
// Output: "1101"

// 二进制求和
// 给定两个二进制字符串，返回他们的和(用二进制表示)。

// 输入为非空字符串且只包含数字 1 和 0。

// 示例 1:

// 输入: a = "11", b = "1"
// 输出: "100"
// 示例 2:

// 输入: a = "110", b = "111"
// 输出: "1101"

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
export default function addBinary(a, b) {
  let i = a.length - 1;
  let j = b.length - 1;
  const ans = [];
  let carry = 0;
  while (j >= 0 || i >= 0 || carry) {
    let sum = carry;
    if (i >= 0) {
      sum += parseInt(a[i], 10);
      i--;
    }
    if (j >= 0) {
      sum += parseInt(b[j], 10);
      j--;
    }
    carry = sum > 1 ? 1 : 0;
    ans.push(sum % 2);
  }
  return ans.reverse().join('');
}
```

### [69].

```js
/**
 * @param {number} x
 * @return {number}
 */
const mySqrt = function(x) {
  if (x === 1) return 1;
  let min = 0;
  let max = parseInt(x / 2);
  let mid = parseInt((max + min) / 2);
  let ans;
  while (!ans) {
    if (mid ** 2 === x) {
      return mid;
    }
    if (mid ** 2 < x) {
      min = mid + 1;
    } else {
      max = mid - 1;
    }
    if (min === max) return min;
    if (min + 1 === max && min ** 2 < x && max ** 2 > x) return min;
    if (mid === parseInt((max + min) / 2)) return mid;
    mid = parseInt((max + min) / 2);
  }
  return ans;
};
```

### [69].x-的平方根

```js
/*
 * @lc app=leetcode.cn id=69 lang=javascript
 *
 * [69] x 的平方根
 */
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
  let left = 1,
    right = x,
    mid;

  while (left <= right) {
    mid = Math.floor((left + right) / 2);

    if (mid * mid > x) {
      right = mid - 1;
    } else if (mid * mid < x) {
      left = mid + 1;
    } else return mid;
  }

  return right;
};

// console.log(mySqrt(4))
// console.log(mySqrt(8))
// console.log(mySqrt(9))
// console.log(mySqrt(10))
// console.log(mySqrt(24))
// console.log(mySqrt(101))
// console.log(mySqrt(101))
```

### [70].爬楼梯

```js
/*
 * @lc app=leetcode.cn id=70 lang=javascript
 *
 * [70] 爬楼梯
 */
/**
 * @param {number} n
 * @return {number}
 */
const map = {};
var climbStairs = function(n) {
  if (n <= 2) return n;
  if (!map[n]) {
    map[n] = climbStairs(n - 1) + climbStairs(n - 2);

    return map[n];
  }
  // console.log('map', map)
  return map[n];
};

// console.log(climbStairs(2))
console.log(climbStairs(3));
console.log(climbStairs(4));
console.log(climbStairs(20));
console.log(climbStairs(40));

// f(n) = f(n - 1) + f(n - 2)
// ...
// f(2) = 2
// f(1) = 1
```

### [78].子集

```js
/*
 * @lc app=leetcode.cn id=78 lang=javascript
 *
 * [78] 子集
 */
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  if (nums.length === 0) return [];
  const length = nums.length;
  const result = [];
};

function select(n, nums = []) {
  if (n === 0) return [];

  for (let i = 0; i < nums.length; i++) {}
}
```

### [83].删除排序链表中的重复元素

```js
/*
 * @lc app=leetcode.cn id=83 lang=javascript
 *
 * [83] 删除排序链表中的重复元素
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
  let l1 = head;
  while (l1.next) {
    if (l1.next.val === l1.val) {
      l1.next = l1.next.next;
    } else {
      l1 = l1.next;
    }
  }
  return head;
};

function List(arr) {
  let current = new ListNode();
  const guard = current;
  for (let i = 0; i < arr.length; i++) {
    current.next = new ListNode(arr[i]);
  }
  return guard.next;
}

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

const l1 = List([1, 1, 2]),
  l2 = List([1, 1, 2, 3, 3]);
// ListToString.call(l1)
// ListToString.call(l2)

console.log(ListToString.call(deleteDuplicates(l1)));
console.log(ListToString.call(deleteDuplicates(l2)));
```

### [84].largest-rectangle-in-histogram

```js
/*
 * @lc app=leetcode id=84 lang=javascript
 *
 * [84] Largest Rectangle in Histogram
 */
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  // 木桶原理
  // 暴力求解法 时间复杂度O(n^2) 空间复杂度O(1)
  // if (heights.length === 1) return heights[0];
  // let min = null;
  // let max = 0;
  // for (let i = 0; i < heights.length; i++) {
  //   min = heights[i];
  //   for (let j = i; j < heights.length; j++) {
  //     min = Math.min(min, heights[j]);
  //     max = Math.max((j - i + 1) * min, max);
  //   }
  // }
  // return max;
  // 上面的暴力求解，其实可以做一个小优化，就是通过取局部最大值来减少一部分重复计算，但是时间复杂度还是O(n^2)
  // 关键点： [1]. 单调栈(Monotone Stack),线性复杂度,因为所有元素只会进入栈一次，并且出栈后再也不会进栈了 [2].如果用暴力求解的话，你要会找出所有组合的方法(大部分题目都是两两组合，如果是任意组合的情况，暴力的话复杂度是2^n，
  // 这种情况，暴力求解通常不不取，需要考虑别的思路)
  // 当前题目就是两两组合 ，时间复杂度是O(n^2)，在可以接受的范围
  // 社区中流行的一种解法: 单调栈,  在这里我们需要使用单调递增栈
  // 时间复杂度O(n) 空间复杂度O(n)
  // const ascStack = [];
  // let max = 0;
  // heights.push(0); // hack, 为了使最后一个柱子也参与运算
  // for (let i = 0; i < heights.length; i++) {
  //   let p = i;
  //   while (
  //     ascStack.length > 0 &&
  //     heights[i] < heights[ascStack[ascStack.length - 1]]
  //   ) {
  //     // 由于是递增栈， height[p]一定是最小的，一定是短板
  //     p = ascStack.pop();
  //     max = Math.max(max, heights[p] * (ascStack.length === 0 ? i : i - p));
  //   }
  //   ascStack.push(i);
  // }
  // return max;
  // 相关题目： 雨水收集
  // 直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高
};
```

### [88].合并两个有序数组

```js
/*
 * @lc app=leetcode.cn id=88 lang=javascript
 *
 * [88] 合并两个有序数组
 */
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge1 = function(nums1, m, nums2, n) {
  const tmp1 = nums1.slice(0, m),
    tmp2 = nums2.slice(0, n);
  const arr = [...tmp1, ...nums2];
  quick(arr);

  for (let i = 0; i < arr.length; i++) {
    nums1[i] = arr[i];
  }
  return arr;
};

function quick(arr, start = 0, end = arr.length - 1) {
  if (arr && arr.length < 2) return arr;
  if (start >= end) return;
  let target = arr[start],
    i = start,
    j = end;

  while (i < j) {
    while (target <= arr[j] && i < j) j--;
    while (target >= arr[i] && i < j) i++;

    if (i < j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i], arr[start]] = [arr[start], arr[i]];
  quick(arr, start, i - 1);
  quick(arr, i + 1, end);
  return arr;
}

// console.log(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3))
// console.log(quick([1, 3, 4, 6, 1, 7, 9, 0, 2, 3]))

// 使用双指针方法
var merge = function(nums1, m, nums2, n) {
  let index1 = m - 1,
    index2 = n - 1,
    mergeIndex = m + n - 1;
  while (index1 >= 0 || index2 >= 0) {
    if (index1 < 0) {
      nums1[mergeIndex--] = nums2[index2--];
    } else if (index2 < 0) {
      nums1[mergeIndex--] = nums1[index1--];
    } else if (nums1[index1] > nums2[index2]) {
      nums1[mergeIndex--] = nums1[index1--];
    } else {
      nums1[mergeIndex--] = nums2[index2--];
    }
  }
  return nums1;
};
// console.log(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3))
```

### [89].格雷编码

```js
/*
 * @lc app=leetcode.cn id=89 lang=javascript
 *
 * [89] 格雷编码
 */
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
  // parseInt 2 进制转 10 进制
  return make(n).map(item => parseInt(item, 2));
};

// 23% 16%
const make = n => {
  if (n === 0) {
    return ['0'];
  } else if (n === 1) {
    return ['0', '1'];
  } else {
    let prev = make(n - 1);
    const max = Math.pow(2, n) - 1;
    let result = [];
    for (let i = 0; i < prev.length; i++) {
      // 取对称
      result[i] = `0${prev[i]}`;
      result[max - i] = `1${prev[i]}`;
    }
    return result;
  }
};

const getValue = str => {
  let result = 0;
  for (let i = str.length - 1, j = 0; i >= 0; i--) {
    if (str[i] == 1) {
      result += Math.pow(2, j);
    }
    j++;
  }
  return result;
};

// 除了第一列取反，其他列都是上下对称
// n = 1
// 0
// ====
// 1

// n = 2
// 0 0
// 0 1
// ====
// 1 1
// 1 0

// n = 3
// 0 0 0
// 0 0 1
// 0 1 1
// 0 1 0
// =====
// 1 1 0
// 1 1 1
// 1 0 1
// 1 0 0

// 最佳解
// TODO: 各种位运算 https://www.cnblogs.com/dongsheng/articles/[2665305].html
var newGrayCode = function(n) {
  if (n === 0) return [0];
  const res = grayCode(n - 1);
  // 左移 n - 1
  const mask = 1 << (n - 1);
  for (let i = res.length - 1; i >= 0; i--) {
    // 或操作
    res.push(res[i] | mask);
  }
  return res;
};

// console.log(grayCode(0))
// console.log(grayCode(1))
// console.log(grayCode(2))
```

### [93].restore-ip-addresses

```js
/*
 * @lc app=leetcode id=93 lang=javascript
 *
 * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
 * 示例:
 * 输入: "25525511135"
 * 输出: ["[255].[255].[11].135", "[255].[255].[111].35"]
 * [93] Restore IP Addresses
 */
// TODO: 回溯算法 string | backtracking
function backtrack(list, tempList, s, start) {
  if (tempList.length === 4 && tempList.join('') === s && !list.includes(tempList.join('.'))) {
    list.push(tempList.join('.'));
  }
  if (tempList.length > 4) return;

  for (let i = start; i < s.length; i++) {
    for (let j = 0; j < 3; j++) {
      const r = s.slice(i, i + j + 1);
      if (+r > 255) continue;
      if (r[0] === '0' && r.length > 1) continue;
      tempList.push(r);
      backtrack(list, tempList, s, i + j + 1);
      tempList.pop();
    }
  }
}
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  // Given "25525511135",
  // return ["[255].[255].[11].135", "[255].[255].[111].35"].
  if (s.length > 3 * 4) return [];
  const list = [];
  backtrack(list, [], s, 0);
  return list;
};

console.log(restoreIpAddresses('25525511135'));
```

### [93].复原 ip 地址

```js
/*
 * @lc app=leetcode.cn id=93 lang=javascript
 *
 * [93] 复原IP地址
 */
/**
 * @param {string} s
 * @return {string[]}
 */
// 递归思想
// ip 字段中 255 是最大情况 0 ~ 255
// 3 个点，分为 4 个字段
var restoreIpAddresses = function(s) {
  if (s.length > 12 || str.length < 4) return [];

  const resp = [];
};

function cut(str, n) {
  if (str.length <= n * 4 && str.length >= n) {
    const result = [];
    const resp0 = cut(str.slice(1), n - 1);
    const resp1 = cut(str.slice(2), n - 2);
    let resp2;
    if (str.slice(0, 3) - 0 <= 255) {
      resp2 = cut(str.slice(3), n - 3);
    }
    if (resp0) {
    }
  }

  return [...[str[0]], ...[str.slice(0, 2), cut(str.slice(2), 3)], ...[str.slice(0, 3), cut(str.slice(3), 3)]];
}
```

### [94].二叉树的中序遍历

```js
/*
 * @lc app=leetcode.cn id=94 lang=javascript
 *
 * [94] 二叉树的中序遍历
 * 给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
// 中序： 左 -> 中 -> 右
// 前序： 中 -> 左 -> 右
// 后序： 左 -> 右 -> 中
// 迭代
var inorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根
  while (root || stack.length) {
    if (root) {
      stack.push(root);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};

// 递归
const res = [];
var inorderTraversal1 = function(root) {
  inorderTraversal1(root.left);
  res.push(root);
  inorderTraversal1(root.right);
  return res;
};
```

### [6].

```js
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  if (numRows == 1) return s;
  let arr = new Array(numRows);
  for (let i = 0; i < numRows; i++) arr[i] = [];
  let index = 0,
    len = s.length,
    mi = 0,
    isDown = true;
  while (index < len) {
    arr[mi].push(s[index]);
    index++;

    if (mi >= numRows - 1) isDown = false;
    else if (mi <= 0) isDown = true;

    if (isDown) mi++;
    else mi--;
  }
  let ans = [];
  for (let item of arr) {
    ans = ans.concat(item);
  }
  return ans.join('');
};

const s = 'AB',
  numRows = 1;

console.log(convert(s, numRows));
```

### [7].

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  const s = x + '';
  let i = 0;
  let sign = 1;
  if (s[i] == '-') {
    i++;
    sign = -1;
  }
  if (s[i] == '+') {
    i++;
  }
  let num = 0;
  for (let j = s.length - 1; j >= i; j--) {
    num = num * 10 + parseInt(s[j]);
  }
  num *= sign;
  let max = 2;
  for (let n = 0; n < 30; n++) {
    max *= 2;
  }
  if (num > max || num < -max) {
    return 0;
  }
  return num;
};

console.log(reverse(1563847412));
```

### [8].

```js
/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
  let i = 0;
  // 去除空格
  while (str[i] == ' ') i++;
  // 处理正负值
  let sign = 1;
  if (str[i] == '-' || str[i] == '+') {
    if (str[i] == '-') sign = -1;
    i++;
  }
  // 处理数字
  let num = 0;
  while (i < str.length) {
    if (str.charCodeAt(i) >= 48 && str.charCodeAt(i) <= 57) {
      num = num * 10 + parseInt(str[i]);
      i++;
    } else {
      break;
    }
  }
  num *= sign;
  // 处理 32 位最大最小值
  let max = 2;
  for (let n = 0; n < 30; n++) max *= 2;
  if (num >= max) return max - 1;
  if (num <= -max) return -max + 1;
  return num;
};

console.log(myAtoi('2147483648'));
```

### [20].

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  let stack = [];
  for (let c of s) {
    if (c == '(') stack.push(')');
    else if (c == '[') stack.push(']');
    else if (c == '{') stack.push('}');
    else {
      if (stack.length == 0) return false;
      if (stack.pop() != c) return false;
    }
  }
  return stack.length == 0;
};
```

### [21].

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

### [22].

```js
let result = [];

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  dfs(n, 1, 1, '(');
  return result;
};

function dfs(n, sum, used, s) {
  if (s.length == 2 * n) {
    result.push(s);
    return;
  }
  if (sum == 0) {
    dfs(n, sum + 1, used + 1, s + '(');
  } else if (sum == n || used == n) {
    dfs(n, sum - 1, used, s + ')');
  } else {
    dfs(n, sum + 1, used + 1, s + '(');
    dfs(n, sum - 1, used, s + ')');
  }
}

generateParenthesis(3);
```

### [23].

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  return partion(lists, 0, list.length - 1);
};

function partion(lists, s, e) {
  // 开始 == 结束，说明合并完成。
  if (s == e) return lists[s];
  if (s < e) {
    // 分一半计算
    let q = parseInt((s + e) / 2);
    // 前半部分
    let l1 = partion(lists, s, q);
    // 后半部分
    let l2 = partion(lists, q + 1, e);
    // 合并两个链表
    return merge(l1, l2);
  } else return null;
}

function mergeTwoLists(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

### [26].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  if (nums.length <= 1) return nums.length;
  let cur = nums[0];
  let index = 1;
  while (index < nums.length) {
    if (cur != nums[index]) {
      cur = nums[index];
      index++;
    } else {
      nums.splice(index, 1);
    }
  }
  return nums.length;
};

console.log(removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]));
```

### [28].

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
  const slen = haystack.length;
  const plen = needle.length;
  if (slen == plen) {
    return haystack == needle ? 0 : -1;
  }
  for (let i = 0; i <= slen - plen; i++) {
    let j;
    for (j = 0; j < plen; j++) {
      if (haystack[i + j] != needle[j]) {
        break;
      }
    }
    if (j == plen) return i;
  }
  return -1;
};

console.log(strStr('mississippi', 'pi'));
```

### [29].

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
  let sign = 1;
  if (dividend < 0) {
    sign = -sign;
    dividend = -dividend;
  }
  if (divisor < 0) {
    sign = -sign;
    divisor = -divisor;
  }

  if (divisor == 0 || dividend < divisor) return 0;

  num = sign * ldivide(dividend, divisor);

  let max = 1;
  for (let i = 0; i < 31; i++) {
    max *= 2;
  }
  if (num > max - 1) return max - 1;
  if (num < -max) return -max;
  return num;
};

function ldivide(dividend, divisor) {
  if (dividend < divisor) return 0;
  let sum = divisor;
  let num = 1;
  while (sum + sum <= dividend) {
    sum += sum;
    num += num;
  }
  return num + ldivide(dividend - sum, divisor);
}

console.log(divide(-1, 1));

1;
```

### [33].

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == target) {
      return i;
    }
  }
  return -1;
};
```

### [34].

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  let targetIndex = binarySearch(nums, target, 0, nums.length - 1);
  if (targetIndex == -1) return [-1, -1];
  let l = targetIndex,
    r = targetIndex;
  while (l > 0 && nums[l - 1] == target) {
    l--;
  }
  while (r < nums.length - 1 && nums[r + 1] == target) {
    r++;
  }
  return [l, r];
};

function binarySearch(arr, val, lo, hi) {
  if (hi < lo) return -1;
  let mid = lo + parseInt((hi - lo) / 2);

  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

let nums = [5, 7, 7, 8, 8, 10],
  target = 9;
searchRange(nums, target);
```

### [36].

```js
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  const M = board.length,
    N = board[0].length;
  for (let i = 0; i < M; i++) {
    let row = new Set();
    let col = new Set();
    let rect = new Set();
    for (let j = 0; j < N; j++) {
      if (board[i][j] != '.' && row.has(board[i][j])) {
        return false;
      } else {
        row.add(board[i][j]);
      }

      if (board[j][i] != '.' && col.has(board[j][i])) {
        return false;
      } else {
        col.add(board[j][i]);
      }

      let RowIndex = 3 * parseInt(i / 3) + parseInt(j / 3);
      let ColIndex = 3 * (i % 3) + (j % 3);
      console.log(RowIndex + '-' + ColIndex);
      const item = board[RowIndex][ColIndex];
      if (item != '.' && rect.has(item)) {
        return false;
      } else {
        rect.add(item);
      }
    }
  }
  return true;
};

let board = [
  ['5', '3', '.', '.', '7', '.', '.', '.', '.'],
  ['6', '.', '.', '1', '9', '5', '.', '.', '.'],
  ['.', '9', '8', '.', '.', '.', '.', '6', '.'],
  ['8', '.', '.', '.', '6', '.', '.', '.', '3'],
  ['4', '.', '.', '8', '.', '3', '.', '.', '1'],
  ['7', '.', '.', '.', '2', '.', '.', '.', '6'],
  ['.', '6', '.', '.', '.', '.', '2', '8', '.'],
  ['.', '.', '.', '4', '1', '9', '.', '.', '5'],
  ['.', '.', '.', '.', '8', '.', '.', '7', '9'],
];

isValidSudoku(board);
```

### [38].

```js
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
  let ans = '1';
  let i = 1;
  while (i < n) {
    ans = say(ans);
    i++;
  }
  return ans;
};

function say(s) {
  let curChar = s[0];
  let curCount = 1;
  let ans = '';
  for (let i = 1; i < s.length; i++) {
    if (s[i] == curChar) {
      curCount++;
    } else {
      ans += curCount + curChar;
      curChar = s[i];
      curCount = 1;
    }
  }
  ans += curCount + curChar;
  return ans;
}

console.log(countAndSay(1));
console.log(countAndSay(2));
console.log(countAndSay(3));
console.log(countAndSay(4));
```

### [41].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let index = 0;
  let val = 0;
  while (index < nums.length) {
    if (nums[index] <= 0) {
      index++;
      continue;
    }
    if (nums[index] == val + 1) {
      val = val + 1;
    }
    if (nums[index] != val) {
      return val + 1;
    }
    index++;
  }
  return nums.length > 0 ? nums[nums.length - 1] + 1 : 1;
};

console.log(firstMissingPositive([3, 4, -1, 1]));
```

### [42].

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  let left = 0,
    right = height.length - 1;
  let count = 0;
  let leftMax = 0,
    rightMax = 0;
  while (left <= right) {
    leftMax = Math.max(leftMax, height[left]);
    rightMax = Math.max(rightMax, height[right]);
    if (leftMax < rightMax) {
      count += leftMax - height[left];
      left++;
    } else {
      count += rightMax - height[right];
      right--;
    }
  }
  return count;
};
```

### [44].

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  // 构造 dp 函数
  let dp = [];
  for (let i = 0; i <= s.length; i++) {
    let child = [];
    for (let j = 0; j <= p.length; j++) {
      child.push(false);
    }
    dp.push(child);
  }
  dp[s.length][p.length] = true;
  // 执行
  for (let i = p.length - 1; i >= 0; i--) {
    if (p[i] != '*') break;
    else dp[s.length][i] = true;
  }

  for (let i = s.length - 1; i >= 0; i--) {
    for (let j = p.length - 1; j >= 0; j--) {
      if (s[i] == p[j] || p[j] == '?') {
        dp[i][j] = dp[i + 1][j + 1];
      } else if (p[j] == '*') {
        console.log(dp[i + 1][j]);
        console.log(dp[i][j + 1]);
        dp[i][j] = dp[i + 1][j] || dp[i][j + 1];
      } else {
        dp[i][j] = false;
      }
    }
  }
  return dp[0][0];
};

isMatch('aa', '*');
```

### [46].

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  result = [];
  nums.sort(function(a, b) {
    return a - b;
  });
  find(nums, []);
  return result;
};

let result = [];

function find(nums, templateList) {
  if (nums.length == 0) {
    result.push(templateList.slice());
  }
  for (let i = 0; i < nums.length; i++) {
    templateList.push(nums[i]);
    let copy = nums.slice();
    copy.splice(i, 1);
    find(copy, templateList);
    templateList.pop();
  }
}

permute([1, 2, 3]);
```

### [48].

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  matrix.reverse();
  for (let i = 0; i < matrix.length; i++) {
    for (let j = i + 1; j < matrix[0].length; j++) {
      let tmp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = tmp;
    }
  }
};

rotate([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);
```

### [49].

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  const a = 'a'.charCodeAt();
  let map = new Map();
  for (let i = 0; i < strs.length; i++) {
    let charArr = createArr();
    for (let j = 0; j < strs[i].length; j++) charArr[strs[i].charCodeAt(j) - a]++;
    let key = charArr.join('');
    if (map.has(key)) {
      map.get(key).push(strs[i]);
    } else {
      map.set(key, [strs[i]]);
    }
  }
  const ans = [];
  for (let value of map.values()) {
    ans.push(value);
  }
  return ans;
};

function createArr() {
  let i = 0;
  let arr = [];
  while (i < 26) {
    arr.push(0);
    i++;
  }
  return arr;
}

groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']);
```

### [50].

```js
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (n == 0) return 1;
  if (n < 0) {
    n = -n;
    x = 1 / x;
  }
  return n % 2 == 0 ? pow(x * x, parseInt(n / 2)) : x * pow(x * x, parseInt(n / 2));
};
```

### [53].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let count = nums[0],
    maxCount = nums[0];
  for (let i = 1; i < nums.length; i++) {
    count = Math.max(count + nums[i], nums[i]);
    maxCount = Math.max(maxCount, count);
  }
  return maxCount;
};

console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

### [54].

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  if (matrix.length == 0) return [];
  let ans = [];
  ans.push(matrix[0][0]);
  matrix[0][0] = null;

  let i = 0,
    j = 0;
  const width = matrix[0].length,
    height = matrix.length;
  let status = 'right';
  let count = 0;
  while (count < width * height - 1) {
    if (status == 'right') {
      if (j < width - 1 && matrix[i][j + 1] != null) {
        ans.push(matrix[i][j + 1]);
        matrix[i][j + 1] = null;
        j++;
        count++;
      } else {
        status = 'down';
      }
    } else if (status == 'down') {
      if (i < height - 1 && matrix[i + 1][j] != null) {
        ans.push(matrix[i + 1][j]);
        matrix[i + 1][j] = null;
        i++;
        count++;
      } else {
        status = 'left';
      }
    } else if (status == 'left') {
      if (j > 0 && matrix[i][j - 1] != null) {
        ans.push(matrix[i][j - 1]);
        matrix[i][j - 1] = null;
        j--;
        count++;
      } else {
        status = 'up';
      }
    } else {
      if (i > 0 && matrix[i - 1][j] != null) {
        ans.push(matrix[i - 1][j]);
        matrix[i - 1][j] = null;
        i--;
        count++;
      } else {
        status = 'right';
      }
    }
  }
  return ans;
};

/**
 * TOOD 本方案思路是对的，就是写的非常之不优雅，需要改进。
 */
```

### [55].

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let i = nums.length - 2,
    len = nums.length - 1;
  while (i > 0) {
    if (nums[i] >= len - i) {
      len = i;
    }
    i--;
  }
  return nums[0] >= len;
};

/**
 * 从后往前找更佳
 */
```

### [56].

```js
/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {Interval[]}
 */
var merge = function(intervals) {
  if (intervals.length == 0) return [];
  intervals.sort((a, b) => {
    return a.start - b.start;
  });

  let ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    if (intervals[i].end >= intervals[i + 1].start) {
      intervals[i + 1].start = Math.min(intervals[i].start, intervals[i + 1].start);
      intervals[i + 1].end = Math.max(intervals[i].end, intervals[i + 1].end);
    } else {
      ans.push(intervals[i]);
    }
  }
  ans.push(intervals[intervals.length - 1]);
  return ans;
};
```

### [62].

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const pos = new Array(m);
  for (let i = 0; i < m; i++) {
    pos[i] = new Array(n);
  }
  for (let i = 0; i < n; i++) {
    pos[0][i] = 1;
  }
  for (let i = 0; i < m; i++) {
    pos[i][0] = 1;
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      pos[i][j] = pos[i - 1][j] + pos[i][j - 1];
    }
  }
  return pos[m - 1][n - 1];
};

uniquePaths(3, 7);

/**
0  1  1  1  1  1  1
1  2  3  4  5  6  7
1  3  6  10 15 21 28
 */
```

### [66].

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  for (let i = digits.length - 1; i >= 0; i--) {
    if (digits[i] < 9) {
      digits[i]++;
      break;
    } else {
      digits[i] = 0;
    }
  }
  if (digits[0] == 0) {
    digits.unshift(1);
  }
  return digits;
};

console.log([1, 2, 3]);
```

### [69].

```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
  let l = 0,
    r = x;
  while (true) {
    let mid = parseInt(l + (r - l) / 2);
    if (mid * mid > x) {
      r = mid - 1;
    } else if (mid * mid < x) {
      if ((mid + 1) * (mid + 1) > x) {
        return mid;
      }
      l = mid + 1;
    } else {
      return mid;
    }
  }
};
```

### [70].

```js
// let count = 0

// /**
//  * @param {number} n
//  * @return {number}
//  */
// var climbStairs = function (n) {
//     count = 0
//     find(0, n)
//     return count
// };

// function find(step, n) {
//     if (step == n) {
//         count++
//         return
//     }
//     find(step + 1, n)
//     if (step + 2 <= n) {
//         find(step + 2, n)
//     }
// }

var climbStairs = function(n) {
  let dp = new Array(n);
  dp[0] = 1;
  dp[1] = 2;
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n - 1];
};
```

### [73].

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
  const rows = matrix.length,
    cols = matrix[0].length;
  let col0 = 1;
  for (let i = 0; i < rows; i++) {
    if (matrix[i][0] == 0) col0 = 0;
    for (let j = 1; j < cols; j++) {
      if (matrix[i][j] == 0) {
        matrix[0][j] = 0;
        matrix[i][0] = 0;
      }
    }
  }
  for (let i = rows - 1; i >= 0; i--) {
    for (let j = cols - 1; j >= 1; j--) {
      if (matrix[0][j] == 0 || matrix[i][0] == 0) {
        matrix[i][j] = 0;
      }
    }
    if (col0 == 0) {
      matrix[i][0] = 0;
    }
  }
};

console.log(
  setZeroes([
    [0, 1, 2, 0],
    [3, 4, 5, 2],
    [1, 3, 1, 5],
  ]),
);
```

### [75].

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
  sort(nums, 0, nums.length - 1);
};

function sort(arr, lo, hi) {
  if (hi <= lo) return;
  let lt = lo,
    i = lo + 1,
    gt = hi;
  let v = arr[lo];
  while (i <= gt) {
    if (arr[i] < v) swap(arr, lt++, i++);
    else if (arr[i] > v) swap(arr, i, gt--);
    else i++;
  }
  sort(arr, lo, lt - 1);
  sort(arr, gt + 1, hi);
}

function swap(arr, a, b) {
  let x = arr[a];
  arr[a] = arr[b];
  arr[b] = x;
}

/**
 * 三向字符串快速排序
 */
```

### [76].

```js
function minWindow(s, t) {
  var ans = '';

  // [1]. process hashmap
  var map = {};
  t.split('').forEach(ch => (map[ch] = (map[ch] || 0) + 1));
  var count = Object.keys(map).length;

  // [2]. traverse s to find boundaries
  // both l & r are inclusive
  var l = 0;
  var r = -1;

  while (r < s.length) {
    if (count === 0) {
      // good condition
      // l~r contains t

      // update ans
      if (!ans || r - l + 1 < ans.length) {
        ans = s.slice(l, r + 1);
      }

      // get rid of curr ch and then move l
      if (map[s[l]] !== undefined) {
        map[s[l]]++;
      }
      if (map[s[l]] > 0) {
        count++;
      }
      l++;
    } else {
      // bad condition
      // l~r doesn't contain t

      // move r and add new ch
      r++;
      if (map[s[r]] !== undefined) {
        map[s[r]]--;
      }
      if (map[s[r]] === 0) {
        count--;
      }
    }
  }
  return ans;
}
```

### [78].

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  let list = [];
  nums.sort();
  backtrack(list, new Array(), nums, 0);
  return list;
};

function backtrack(list, tempList, nums, start) {
  list.push(tempList.slice());
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}

subsets([1, 2, 3]);

/**
 *
 * 1
 * 1 2
 * 1 2 3
 * 1 3
 * 2
 * 2 3
 * 3
 */
```

### [79].

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  for (let y = 0; y < board.length; y++) {
    for (let x = 0; x < board[0].length; x++) {
      if (find(board, word, y, x, 0)) return true;
    }
  }
  return false;
};

function find(board, word, y, x, d) {
  if (d == word.length) return true;
  if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false;
  if (board[y][x] != word[d]) return false;
  let tmp = board[y][x];
  board[y][x] = '*';
  let exist =
    find(board, word, y, x + 1, d + 1) ||
    find(board, word, y, x - 1, d + 1) ||
    find(board, word, y + 1, x, d + 1) ||
    find(board, word, y - 1, x, d + 1);
  board[y][x] = tmp;
  return exist;
}

exist(
  [
    ['C', 'A', 'A'],
    ['A', 'A', 'A'],
    ['B', 'C', 'D'],
  ],
  'AAB',
);

//     // board 二维数组，word 查找的单词
//     public boolean exist(char[][] board, String word) {
//     char[] w = word.toCharArray();// 转为字符数组
//     for (int y = 0; y < board.length; y++) {
//         for (int x = 0; x < board[y].length; x++) {
//             // 遍历二维数组去求是否存在
//             if (exist(board, y, x, w, 0)) return true;
//         }
//     }
//     return false;
// }

//     // board 二位数组，第 x 列 第 y 行，查找的单词字符数组，i 是单词字符数组索引值
//     private boolean exist(char[][] board, int y, int x, char[] word, int i) {
//     if (i == word.length) return true; // 完全匹配，返回 true
//     if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false; // x、y超出矩阵边界，返回 false
//     if (board[y][x] != word[i]) return false; // 字符不匹配，返回 false
//     board[y][x] ^= 256; // 按位异或，先将当前字符转为另外的字符，避免获取重复数值
//     boolean exist = exist(board, y, x + 1, word, i + 1)
//         || exist(board, y, x - 1, word, i + 1)
//         || exist(board, y + 1, x, word, i + 1)
//         || exist(board, y - 1, x, word, i + 1);
//     board[y][x] ^= 256; // 恢复当前值
//     return exist;
// }
```

### [84].

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  let maxArea = 0;
  for (let i = 0; i < heights.length; i++) {
    let l = i,
      r = i,
      height = heights[i];
    while (l > 0) {
      if (heights[l - 1] >= height) {
        l--;
      } else {
        break;
      }
    }
    while (r < heights.length - 1) {
      if (heights[r + 1] >= height) {
        r++;
      } else {
        break;
      }
    }
    maxArea = Math.max(maxArea, (r - l + 1) * height);
  }
  return maxArea;
};

largestRectangleArea([2, 1, 5, 6, 2, 3]);
```

### [88].

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
  let i = m - 1,
    j = n - 1,
    k = m + n - 1;
  while (i >= 0 && j >= 0) {
    if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--];
    else nums1[k--] = nums2[j--];
  }
  while (j >= 0) nums1[k--] = nums2[j--];
};
```

### [91].

```js
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  let n = s.length;
  if (n == 0) return 0;
  let memo = new Array(n + 1);
  memo[n] = 1;
  memo[n - 1] = s[n - 1] != '0' ? 1 : 0;

  for (let i = n - 2; i >= 0; i--) {
    if (s[i] == '0') {
      memo[i] = 0;
    } else {
      memo[i] = parseInt(s.slice(i, i + 2)) <= 26 ? memo[i + 1] + memo[i + 2] : memo[i + 1];
    }
  }
  return memo[0];
};

console.log(numDecodings('12'));

// public class Solution {
//     public int numDecodings(String s) {
//         int n = s.length();
//         if (n == 0) return 0;
//         // 使用 memo 数组记录某个数字可以转码的总数
//         int[] memo = new int[n + 1];
//         memo[n] = 1;
//         memo[n - 1] = s.charAt(n - 1) != '0' ? 1 : 0; // 最后一个值为0，总数为0

//         for (int i = n - 2; i >= 0; i--)
//         if (s.charAt(i) == '0') continue; // 当前字符为0
//         // 当前总数为：如果两位数小于等于26，前一个字符的总数加上前两个字符的总数。否则返回前一个字符的总数
//         else memo[i] = (Integer.parseInt(s.substring(i, i + 2)) <= 26) ? memo[i + 1] + memo[i + 2] : memo[i + 1];
//         // 返回最终概率
//         return memo[0];
//     }
// }
```

### [94].

```js
let ans = [];

var inorderTraversal = function(root) {
  ans = [];
  helper(root);
  return ans;
};

function helper(node) {
  if (node == null) return;
  if (node.left) helper(node.left);
  ans.push(node.val);
  if (node.right) helper(node.right);
}
```

### [98].

```js
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let isValid = true;

var isValidBST = function(root) {
  if (root == null) return true;
  helper(root);
  return isValid;
};

function helper(node) {
  if (node == null) return;
  if (node.left != null) {
    if (node.left.val > node.val) {
      isValid = false;
      return;
    }
    helper(node.left);
  }
  if (node.right != null) {
    if (node.right.val < node.val) {
      isValid = false;
      return;
    }
    helper(node.right);
  }
}

const tree = new TreeNode(0);
console.log(isValidBST(tree));

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  return validate(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
};

const validate = (node, min, max) => {
  if (!node) {
    return true;
  }

  if (node.val < min || node.val > max) {
    return false;
  }

  return validate(node.left, min, node.val - 1) && validate(node.right, node.val + 1, max);
};
```

### [39].combination-sum

#### 题目地址

https://leetcode.com/problems/combination-sum/description/

#### 题目描述

```
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]

```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=39 lang=javascript
 *
 * [39] Combination Sum
 *
 * https://leetcode.com/problems/combination-sum/description/
 *
 * algorithms
 * Medium (46.89%)
 * Total Accepted:    326.7K
 * Total Submissions: 684.2K
 * Testcase Example:  '[2,3,6,7]\n7'
 *
 * Given a set of candidate numbers (candidates) (without duplicates) and a
 * target number (target), find all unique combinations in candidates where the
 * candidate numbers sums to target.
 *
 * The same repeated number may be chosen from candidates unlimited number of
 * times.
 *
 * Note:
 *
 *
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 *
 *
 * Example 1:
 *
 *
 * Input: candidates = [2,3,6,7], target = 7,
 * A solution set is:
 * [
 * ⁠ [7],
 * ⁠ [2,2,3]
 * ]
 *
 *
 * Example 2:
 *
 *
 * Input: candidates = [2,3,5], target = 8,
 * A solution set is:
 * [
 * [2,2,2,2],
 * [2,3,3],
 * [3,5]
 * ]
 *
 */

function backtrack(list, tempList, nums, remain, start) {
  if (remain < 0) return;
  else if (remain === 0) return list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, remain - nums[i], i); // 数字可以重复使用， i + 1代表不可以重复利用
    tempList.pop();
  }
}
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  const list = [];
  backtrack(
    list,
    [],
    candidates.sort((a, b) => a - b),
    target,
    0,
  );
  return list;
};
```

#### 相关题目

- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [46].permutations

#### 题目地址

https://leetcode.com/problems/permutations/description/

#### 题目描述

```
Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=46 lang=javascript
 *
 * [46] Permutations
 *
 * https://leetcode.com/problems/permutations/description/
 *
 * algorithms
 * Medium (53.60%)
 * Total Accepted:    344.6K
 * Total Submissions: 642.9K
 * Testcase Example:  '[1,2,3]'
 *
 * Given a collection of distinct integers, return all possible permutations.
 *
 * Example:
 *
 *
 * Input: [1,2,3]
 * Output:
 * [
 * ⁠ [1,2,3],
 * ⁠ [1,3,2],
 * ⁠ [2,1,3],
 * ⁠ [2,3,1],
 * ⁠ [3,1,2],
 * ⁠ [3,2,1]
 * ]
 *
 *
 */
function backtrack(list, tempList, nums) {
  if (tempList.length === nums.length) return list.push([...tempList]);
  for (let i = 0; i < nums.length; i++) {
    if (tempList.includes(nums[i])) continue;
    tempList.push(nums[i]);
    backtrack(list, tempList, nums);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const list = [];
  backtrack(list, [], nums);
  return list;
};
```

#### 相关题目

- [31.next-permutation](./31.next-permutation.md)
- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [60.permutation-sequence](./60.permutation-sequence.md)(TODO)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [40].combination-sum-ii

#### 题目地址

https://leetcode.com/problems/combination-sum-ii/description/

#### 题目描述

```
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]

```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=40 lang=javascript
 *
 * [40] Combination Sum II
 *
 * https://leetcode.com/problems/combination-sum-ii/description/
 *
 * algorithms
 * Medium (40.31%)
 * Total Accepted:    212.8K
 * Total Submissions: 519K
 * Testcase Example:  '[10,1,2,7,6,1,5]\n8'
 *
 * Given a collection of candidate numbers (candidates) and a target number
 * (target), find all unique combinations in candidates where the candidate
 * numbers sums to target.
 *
 * Each number in candidates may only be used once in the combination.
 *
 * Note:
 *
 *
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 *
 *
 * Example 1:
 *
 *
 * Input: candidates = [10,1,2,7,6,1,5], target = 8,
 * A solution set is:
 * [
 * ⁠ [1, 7],
 * ⁠ [1, 2, 5],
 * ⁠ [2, 6],
 * ⁠ [1, 1, 6]
 * ]
 *
 *
 * Example 2:
 *
 *
 * Input: candidates = [2,5,2,1,2], target = 5,
 * A solution set is:
 * [
 * [1,2,2],
 * [5]
 * ]
 *
 *
 */
function backtrack(list, tempList, nums, remain, start) {
  if (remain < 0) return;
  else if (remain === 0) return list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    // 和39.combination-sum 的其中一个区别就是这道题candidates可能有重复
    // 代码表示就是下面这一行
    if (i > start && nums[i] == nums[i - 1]) continue; // skip duplicates
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, remain - nums[i], i + 1); // i + 1代表不可以重复利用， i 代表数字可以重复使用
    tempList.pop();
  }
}
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
  const list = [];
  backtrack(
    list,
    [],
    candidates.sort((a, b) => a - b),
    target,
    0,
  );
  return list;
};
```

#### 相关题目

- [39.combination-sum](./39.combination-sum.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [47].permutations-ii

#### 题目地址

https://leetcode.com/problems/permutations-ii/description/

#### 题目描述

```
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=47 lang=javascript
 *
 * [47] Permutations II
 *
 * https://leetcode.com/problems/permutations-ii/description/
 *
 * algorithms
 * Medium (39.29%)
 * Total Accepted:    234.1K
 * Total Submissions: 586.2K
 * Testcase Example:  '[1,1,2]'
 *
 * Given a collection of numbers that might contain duplicates, return all
 * possible unique permutations.
 *
 * Example:
 *
 *
 * Input: [1,1,2]
 * Output:
 * [
 * ⁠ [1,1,2],
 * ⁠ [1,2,1],
 * ⁠ [2,1,1]
 * ]
 *
 *
 */
function backtrack(list, nums, tempList, visited) {
  if (tempList.length === nums.length) return list.push([...tempList]);
  for (let i = 0; i < nums.length; i++) {
    // 和46.permutations的区别是这道题的nums是可以重复的
    // 我们需要过滤这种情况
    if (visited[i]) continue; // 不能用tempList.includes(nums[i])了，因为有重复
    // visited[i - 1] 这个判断容易忽略
    if (i > 0 && nums[i] === nums[i - 1] && visited[i - 1]) continue;

    visited[i] = true;
    tempList.push(nums[i]);
    backtrack(list, nums, tempList, visited);
    visited[i] = false;
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
  const list = [];
  backtrack(
    list,
    nums.sort((a, b) => a - b),
    [],
    [],
  );
  return list;
};
```

#### 相关题目

- [31.next-permutation](./31.next-permutation.md)
- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [60.permutation-sequence](./60.permutation-sequence.md)(TODO)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [48].rotate-image

#### 题目地址

https://leetcode.com/problems/rotate-image/description/

#### 题目描述

```
You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

```

#### 思路

这道题目让我们 in-place，也就说空间复杂度要求 O(1)，如果没有这个限制的话，很简单。

通过观察发现，我们只需要将第 i 行变成第 n - i - 1 列， 因此我们只需要保存一个原有矩阵，然后按照这个规律一个个更新即可。

代码：

```js
var rotate = function(matrix) {
  // 时间复杂度O(n^2) 空间复杂度O(n)
  const oMatrix = JSON.parse(JSON.stringify(matrix)); // clone
  const n = oMatrix.length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      matrix[j][n - i - 1] = oMatrix[i][j];
    }
  }
};
```

如果要求空间复杂度是 O(1)的话，我们可以用一个 temp 记录即可，这个时候就不能逐个遍历了。
比如遍历到 1 的时候，我们把 1 存到 temp，然后更新 1 的值为 7。 1 被换到了 3 的位置，我们再将 3 存到 temp，依次类推。
但是这种解法写起来比较麻烦，这里我就不写了。

事实上有一个更加巧妙的做法，我们可以巧妙地利用对称轴旋转达到我们的目的，如图，我们先进行一次以对角线为轴的翻转，然后
再进行一次以水平轴心线为轴的翻转即可。

这种做法的时间复杂度是 O(n^2) ，空间复杂度是 O(1)

#### 关键点解析

- 矩阵旋转操作

#### 代码

```js
/*
 * @lc app=leetcode id=48 lang=javascript
 *
 * [48] Rotate Image
 */
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  // 时间复杂度O(n^2) 空间复杂度O(1)

  // 做法： 先沿着对角线翻转，然后沿着水平线翻转
  const n = matrix.length;
  function swap(arr, [i, j], [m, n]) {
    const temp = arr[i][j];
    arr[i][j] = arr[m][n];
    arr[m][n] = temp;
  }
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i; j++) {
      swap(matrix, [i, j], [n - j - 1, n - i - 1]);
    }
  }

  for (let i = 0; i < n / 2; i++) {
    for (let j = 0; j < n; j++) {
      swap(matrix, [i, j], [n - i - 1, j]);
    }
  }
};
```

### [49].group-anagrams

#### 题目地址

https://leetcode.com/problems/group-anagrams/description/

#### 题目描述

```
Given an array of strings, group anagrams together.

Example:

Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
```

#### 思路

一个简单的解法就是遍历数组，然后对每一项都进行排序，然后将其添加到 hashTable 中，最后输出 hashTable 中保存的值即可。

这种做法空间复杂度 O(n)， 假设排序算法用的快排，那么时间复杂度为 O(n \* klogk), n 为数组长度，k 为字符串的平均长度

代码：

```js
var groupAnagrams = function(strs) {
  const hashTable = {};

  function sort(str) {
    return str
      .split('')
      .sort()
      .join('');
  }

  // 这个方法需要排序，因此不是很优，但是很直观，容易想到
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    const key = sort(str);
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

下面我们介绍另外一种方法，我们建立一个 26 长度的 counts 数组(如果区分大小写，我们可以建立 52 个，如果支持其他字符依次类推)。
然后我们给每一个字符一个固定的数组下标，然后我们只需要更新每个字符出现的次数。 最后形成的 counts 数组如果一致，则说明他们可以通过
交换顺序得到。这种算法空间复杂度 O(n), 时间复杂度 O(n \* k), n 为数组长度，k 为字符串的平均长度.

#### 关键点解析

- 桶排序

#### 代码

```js
/*
 * @lc app=leetcode id=49 lang=javascript
 *
 * [49] Group Anagrams
 */
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  // 类似桶排序

  let counts = [];
  const hashTable = {};
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    counts = Array(26).fill(0);
    for (let j = 0; j < str.length; j++) {
      counts[str[j].charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }
    const key = counts.join('');
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

### [55].jump-game

#### 题目地址

https://leetcode.com/problems/jump-game/description/

#### 题目描述

```
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.

```

#### 思路

这道题目是一道典型的`回溯`类型题目。
思路就是用一个变量记录当前能够到达的最大的索引，我们逐个遍历数组中的元素去更新这个索引。
变量完成判断这个索引是否大于数组下表即可。

#### 关键点解析

- 建模 (记录和更新当前位置能够到达的最大的索引即可)

#### 代码

```js
/*
 * @lc app=leetcode id=55 lang=javascript
 *
 * [55] Jump Game
 *
 * https://leetcode.com/problems/jump-game/description/
 *
 * algorithms
 * Medium (31.38%)
 * Total Accepted:    252.4K
 * Total Submissions: 797.2K
 * Testcase Example:  '[2,3,1,1,4]'
 *
 * Given an array of non-negative integers, you are initially positioned at the
 * first index of the array.
 *
 * Each element in the array represents your maximum jump length at that
 * position.
 *
 * Determine if you are able to reach the last index.
 *
 * Example 1:
 *
 *
 * Input: [2,3,1,1,4]
 * Output: true
 * Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last
 * index.
 *
 *
 * Example 2:
 *
 *
 * Input: [3,2,1,0,4]
 * Output: false
 * Explanation: You will always arrive at index 3 no matter what. Its
 * maximum
 * jump length is 0, which makes it impossible to reach the last index.
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let max = 0; // 能够走到的数组下标

  for (let i = 0; i < nums.length; i++) {
    if (max < i) return false; // 当前这一步都走不到，后面更走不到了
    max = Math.max(nums[i] + i, max);
  }

  return max >= nums.length - 1;
};
```

### [56].merge-intervals

#### 题目地址

https://leetcode.com/problems/merge-intervals/description/

#### 题目描述

```
Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

```

#### 思路

- 先对数组进行排序，排序的依据就是每一项的第一个元素的大小。
- 然后我们对数组进行遍历，遍历的时候两两运算(具体运算逻辑见下)
- 判断是否相交，如果不相交，则跳过
- 如果相交，则合并两项

#### 关键点解析

- 对数组进行排序简化操作
- 如果不排序，需要借助一些 hack,这里不介绍了

#### 代码

```js
/*
 * @lc app=leetcode id=56 lang=javascript
 *
 * [56] Merge Intervals
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */

function intersected(a, b) {
  if (a[0] > b[1] || a[1] < b[0]) return false;
  return true;
}

function mergeTwo(a, b) {
  return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];
}
var merge = function(intervals) {
  // 这种算法需要先排序
  intervals.sort((a, b) => a[0] - b[0]);
  for (let i = 0; i < intervals.length - 1; i++) {
    const cur = intervals[i];
    const next = intervals[i + 1];

    if (intersected(cur, next)) {
      intervals[i] = undefined;
      intervals[i + 1] = mergeTwo(cur, next);
    }
  }
  return intervals.filter(q => q);
};
```

### [62].unique-paths

#### 题目地址

https://leetcode.com/problems/unique-paths/description/

#### 题目描述

```

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
```

```
Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
```

#### 思路

这是一道典型的适合使用动态规划解决的题目，它和爬楼梯等都属于动态规划中最简单的题目，
因此也经常会被用于面试之中。

读完题目你就能想到动态规划的话，建立模型并解决恐怕不是难事。其实我们很容易看出，由于机器人只能右移动和下移动，
因此第[i, j]个格子的总数应该等于[i - 1, j] + [i, j -1]， 因为第[i,j]个格子一定是从左边或者上面移动过来的。

代码大概是：

```js
const dp = [];
for (let i = 0; i < m + 1; i++) {
  dp[i] = [];
  dp[i][0] = 0;
}
for (let i = 0; i < n + 1; i++) {
  dp[0][i] = 0;
}
for (let i = 1; i < m + 1; i++) {
  for (let j = 1; j < n + 1; j++) {
    dp[i][j] = j === 1 ? 1 : dp[i - 1][j] + dp[i][j - 1]; // 转移方程
  }
}

return dp[m][n];
```

由于 dp[i][j] 只依赖于左边的元素和上面的元素，因此空间复杂度可以进一步优化， 优化到 O(n).

具体代码请查看代码区。

#### 关键点

- 空间复杂度可以进一步优化到 O(n), 这会是一个考点
- 基本动态规划问题

#### 代码

```js
/*
 * @lc app=leetcode id=62 lang=javascript
 *
 * [62] Unique Paths
 *
 * https://leetcode.com/problems/unique-paths/description/
 *
 * algorithms
 * Medium (46.53%)
 * Total Accepted:    277K
 * Total Submissions: 587.7K
 * Testcase Example:  '3\n2'
 *
 * A robot is located at the top-left corner of a m x n grid (marked 'Start' in
 * the diagram below).
 *
 * The robot can only move either down or right at any point in time. The robot
 * is trying to reach the bottom-right corner of the grid (marked 'Finish' in
 * the diagram below).
 *
 * How many possible unique paths are there?
 *
 *
 * Above is a 7 x 3 grid. How many possible unique paths are there?
 *
 * Note: m and n will be at most 100.
 *
 * Example 1:
 *
 *
 * Input: m = 3, n = 2
 * Output: 3
 * Explanation:
 * From the top-left corner, there are a total of 3 ways to reach the
 * bottom-right corner:
 * 1. Right -> Right -> Down
 * 2. Right -> Down -> Right
 * 3. Down -> Right -> Right
 *
 *
 * Example 2:
 *
 *
 * Input: m = 7, n = 3
 * Output: 28
 *
 *   START
 */
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const dp = Array(n).fill(1);

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[j] = dp[j] + dp[j - 1];
    }
  }

  return dp[n - 1];
};
```

### [73].set-matrix-zeroes

#### 题目地址

https://leetcode.com/problems/set-matrix-zeroes/description/

#### 题目描述

```
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:

Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
Example 2:

Input:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
Follow up:

- A straight forward solution using O(mn) space is probably a bad idea.
- A simple improvement uses O(m + n) space, but still not the best solution.
- Could you devise a constant space solution?

```

#### 思路

符合直觉的想法是，使用一个 m + n 的数组来表示每一行每一列是否”全部是 0“，
先遍历一遍去构建这样的 m + n 数组，然后根据这个 m + n 数组去修改 matrix 即可。

这样的时间复杂度 O(m \* n), 空间复杂度 O(m + n).

代码如下：

```js
var setZeroes = function(matrix) {
  if (matrix.length === 0) return matrix;
  const m = matrix.length;
  const n = matrix[0].length;
  const zeroes = Array(m + n).fill(false);

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      const item = matrix[i][j];

      if (item === 0) {
        zeroes[i] = true;
        zeroes[m + j] = true;
      }
    }
  }

  for (let i = 0; i < m; i++) {
    if (zeroes[i]) {
      matrix[i] = Array(n).fill(0);
    }
  }

  for (let i = 0; i < n; i++) {
    if (zeroes[m + i]) {
      for (let j = 0; j < m; j++) {
        matrix[j][i] = 0;
      }
    }
  }

  return matrix;
};
```

但是这道题目还有一个 follow up， 要求使用 O(1)的时间复杂度。因此上述的方法就不行了。
但是我们要怎么去存取这些信息(哪一行哪一列应该全部为 0)呢？

一种思路是使用第一行第一列的数据来代替上述的 zeros 数组。 这样我们就不必借助额外的存储空间，空间复杂度自然就是 O(1)了。

由于我们不能先操作第一行和第一列， 因此我们需要记录下”第一行和第一列是否全是 0“这样的一个数据，最后根据这个信息去
修改第一行和第一列。

具体步骤如下：

- 记录下”第一行和第一列是否全是 0“这样的一个数据
- 遍历除了第一行和第一列之外的所有的数据，如果是 0，那就更新第一行第一列中对应的元素为 0
  > 你可以把第一行第一列看成我们上面那种解法使用的 m + n 数组。
- 根据第一行第一列的数据，更新 matrix
- 最后根据我们最开始记录的”第一行和第一列是否全是 0“去更新第一行和第一列即可

#### 关键点

- 使用第一行和第一列来替代我们 m + n 数组
- 先记录下”第一行和第一列是否全是 0“这样的一个数据，否则会因为后续对第一行第一列的更新造成数据丢失
- 最后更新第一行第一列

#### 代码

```js
/*
 * @lc app=leetcode id=73 lang=javascript
 *
 * [73] Set Matrix Zeroes
 */
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
  if (matrix.length === 0) return matrix;
  const m = matrix.length;
  const n = matrix[0].length;

  // 时间复杂度 O(m * n), 空间复杂度 O(1)
  let firstRow = false; // 第一行是否应该全部为0
  let firstCol = false; // 第一列是否应该全部为0

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      const item = matrix[i][j];
      if (item === 0) {
        if (i === 0) {
          firstRow = true;
        }
        if (j === 0) {
          firstCol = true;
        }
        matrix[0][j] = 0;
        matrix[i][0] = 0;
      }
    }
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      const item = matrix[i][j];
      if (matrix[0][j] == 0 || matrix[i][0] == 0) {
        matrix[i][j] = 0;
      }
    }
  }

  // 最后处理第一行和第一列

  if (firstRow) {
    for (let i = 0; i < n; i++) {
      matrix[0][i] = 0;
    }
  }

  if (firstCol) {
    for (let i = 0; i < m; i++) {
      matrix[i][0] = 0;
    }
  }

  return matrix;
};
```

#### 扩展

为什么选择第一行第一列，选择其他行和列可以么？为什么？

### [75].sort-colors

#### 题目地址

https://leetcode.com/problems/sort-colors/description/

#### 题目描述

Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:

Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Follow up:

A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
Could you come up with a one-pass algorithm using only constant space?

#### 思路

其实就是排序，而且没有要求稳定性，就是用啥排序算法都行。
题目并没有给出数据规模，因此我默认数据量不大，直接选择了冒泡排序

#### 关键点解析

冒泡排序的时间复杂度是 N 平方，无法优化，但是可以进一步优化常数项，
比如循环的起止条件。 由于每一次遍历都会将最后一位“就位”，因此内层循环的截止条件就可以是
`nums.length - i`， 而不是 `nums.length`, 可以省一半的时间。

#### 代码

```js
/*
 * @lc app=leetcode id=75 lang=javascript
 *
 * [75] Sort Colors
 *
 * https://leetcode.com/problems/sort-colors/description/
 *
 * algorithms
 * Medium (41.41%)
 * Total Accepted:    297K
 * Total Submissions: 716.1K
 * Testcase Example:  '[2,0,2,1,1,0]'
 *
 * Given an array with n objects colored red, white or blue, sort them in-place
 * so that objects of the same color are adjacent, with the colors in the order
 * red, white and blue.
 *
 * Here, we will use the integers 0, 1, and 2 to represent the color red,
 * white, and blue respectively.
 *
 * Note: You are not suppose to use the library's sort function for this
 * problem.
 *
 * Example:
 *
 *
 * Input: [2,0,2,1,1,0]
 * Output: [0,0,1,1,2,2]
 *
 * Follow up:
 *
 *
 * A rather straight forward solution is a two-pass algorithm using counting
 * sort.
 * First, iterate the array counting number of 0's, 1's, and 2's, then
 * overwrite array with total number of 0's, then 1's and followed by 2's.
 * Could you come up with a one-pass algorithm using only constant space?
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
  function swap(nums, i, j) {
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = 0; j < nums.length - i; j++) {
      if (nums[j] < nums[j - 1]) {
        swap(nums, j - 1, j);
      }
    }
  }
};
```

### [78].subsets

#### 题目地址

https://leetcode.com/problems/subsets/description/

#### 题目描述

```
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]


```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

- 语言支持：JS，C++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=78 lang=javascript
 *
 * [78] Subsets
 *
 * https://leetcode.com/problems/subsets/description/
 *
 * algorithms
 * Medium (51.19%)
 * Total Accepted:    351.6K
 * Total Submissions: 674.8K
 * Testcase Example:  '[1,2,3]'
 *
 * Given a set of distinct integers, nums, return all possible subsets (the
 * power set).
 *
 * Note: The solution set must not contain duplicate subsets.
 *
 * Example:
 *
 *
 * Input: nums = [1,2,3]
 * Output:
 * [
 * ⁠ [3],
 * [1],
 * [2],
 * [1,2,3],
 * [1,3],
 * [2,3],
 * [1,2],
 * []
 * ]
 *
 */
function backtrack(list, tempList, nums, start) {
  list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  const list = [];
  backtrack(list, [], nums, 0);
  return list;
};
```

#### 相关题目

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [86].partition-list

#### 题目地址

https://leetcode.com/problems/partition-list/description/

#### 题目描述

Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example:

Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5

#### 思路

- 设定两个虚拟节点，dummyHead1 用来保存小于该值的链表，dummyHead2 来保存大于等于该值的链表

- 遍历整个原始链表，将小于该值的放于 dummyHead1 中，其余的放置在 dummyHead2 中

遍历结束后，将 dummyHead2 插入到 dummyHead1 后面

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

- 链表的基本操作(遍历)
- 虚拟节点 dummy 简化操作
- 遍历完成之后记得`currentL1.next = null;`否则会内存溢出

> 如果单纯的遍历是不需要上面操作的，但是我们的遍历会导致 currentL1.next 和 currentL2.next
> 中有且仅有一个不是 null， 如果不这么操作的话会导致两个链表成环，造成溢出。

#### 代码

```js
/*
 * @lc app=leetcode id=86 lang=javascript
 *
 * [86] Partition List
 *
 * https://leetcode.com/problems/partition-list/description/
 *
 * algorithms
 * Medium (36.41%)
 * Total Accepted:    155.1K
 * Total Submissions: 425.1K
 * Testcase Example:  '[1,4,3,2,5,2]\n3'
 *
 * Given a linked list and a value x, partition it such that all nodes less
 * than x come before nodes greater than or equal to x.
 *
 * You should preserve the original relative order of the nodes in each of the
 * two partitions.
 *
 * Example:
 *
 *
 * Input: head = 1->4->3->2->5->2, x = 3
 * Output: 1->2->2->4->3->5
 *
 *
 */

/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function(head, x) {
  const dummyHead1 = {
    next: null,
  };
  const dummyHead2 = {
    next: null,
  };

  let current = {
    next: head,
  };
  let currentL1 = dummyHead1;
  let currentL2 = dummyHead2;
  while (current.next) {
    current = current.next;
    if (current.val < x) {
      currentL1.next = current;
      currentL1 = current;
    } else {
      currentL2.next = current;
      currentL2 = current;
    }
  }

  currentL2.next = null;

  currentL1.next = dummyHead2.next;

  return dummyHead1.next;
};
```

### [88].merge-sorted-array

#### 题目地址

https://leetcode.com/problems/merge-sorted-array/description/

#### 题目描述

```
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:

The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.
Example:

Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
```

#### 思路

符合直觉的做法是`将nums2插到num1的末尾, 然后排序`

具体代码：

```js
// 这种解法连m都用不到
// 这显然不是出题人的意思
if (n === 0) return;
let current2 = 0;
for (let i = nums1.length - 1; i >= nums1.length - n; i--) {
  nums1[i] = nums2[current2++];
}
nums1.sort((a, b) => a - b); // 当然你可以自己写排序，这里懒得写了，因为已经偏离了题目本身
```

这道题目其实和基本排序算法中的`merge sort`非常像，但是 merge sort 很多时候，合并的时候我们通常是
新建一个数组，这样就很简单。 但是这道题目要求的是`原地修改`.

这就和 merge sort 的 merge 过程有点不同，我们先来回顾一下 merge sort 的 merge 过程。

merge 的过程`可以`是先比较两个数组的头元素，然后将较小的推到最终的数组中，并将其从原数组中出队列。
循环直到两个数组都为空。

具体代码如下：

```js
// 将nums1 和 nums2 合并
function merge(nums1, nums2) {
  let ret = [];
  while (nums1.length || nums2.length) {
    // 为了方便大家理解，这里代码有点赘余
    if (nums1.length === 0) {
      ret.push(nums2.shift());
      continue;
    }

    if (nums2.length === 0) {
      ret.push(nums1.shift());
      continue;
    }
    const a = nums1[0];
    const b = nums2[0];
    if (a > b) {
      ret.push(nums2.shift());
    } else {
      ret.push(nums1.shift());
    }
  }
  return ret;
}
```

这里要求原地修改，其实我们能只要从后往前比较，并从后往前插入即可。

我们需要三个指针：

1. current 用于记录当前填补到那个位置了

2. m 用于记录 nums1 数组处理到哪个元素了

3. n 用于记录 nums2 数组处理到哪个元素了

如图所示：

- 灰色代表 num2 数组已经处理过的元素
- 红色代表当前正在进行比较的元素
- 绿色代表已经就位的元素

#### 关键点解析

- 从后往前比较，并从后往前插入

#### 代码

```js
/*
 * @lc app=leetcode id=88 lang=javascript
 *
 * [88] Merge Sorted Array
 *
 * https://leetcode.com/problems/merge-sorted-array/description/
 *
 * algorithms
 * Easy (34.95%)
 * Total Accepted:    347.5K
 * Total Submissions: 984.7K
 * Testcase Example:  '[1,2,3,0,0,0]\n3\n[2,5,6]\n3'
 *
 * Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as
 * one sorted array.
 *
 * Note:
 *
 *
 * The number of elements initialized in nums1 and nums2 are m and n
 * respectively.
 * You may assume that nums1 has enough space (size that is greater or equal to
 * m + n) to hold additional elements from nums2.
 *
 *
 * Example:
 *
 *
 * Input:
 * nums1 = [1,2,3,0,0,0], m = 3
 * nums2 = [2,5,6],       n = 3
 *
 * Output: [1,2,2,3,5,6]
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
  // 设置一个指针，指针初始化指向nums1的末尾
  // 然后不断左移指针更新元素
  let current = nums1.length - 1;

  while (current >= 0) {
    // 没必要继续了
    if (n === 0) return;

    // 为了方便大家理解，这里代码有点赘余
    if (m < 0) {
      nums1[current--] = nums2[--n];
      continue;
    }

    if (n < 0) {
      nums1[current--] = nums1[--m];
      continue;
    }
    // 取大的填充 nums1的末尾
    // 然后更新 m 或者 n
    if (nums1[m - 1] > nums2[n - 1]) {
      nums1[current--] = nums1[--m];
    } else {
      nums1[current--] = nums2[--n];
    }
  }
};
```

### [90].subsets-ii

#### 题目地址

https://leetcode.com/problems/subsets-ii/description/

#### 题目描述

```
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=90 lang=javascript
 *
 * [90] Subsets II
 *
 * https://leetcode.com/problems/subsets-ii/description/
 *
 * algorithms
 * Medium (41.53%)
 * Total Accepted:    197.1K
 * Total Submissions: 469.1K
 * Testcase Example:  '[1,2,2]'
 *
 * Given a collection of integers that might contain duplicates, nums, return
 * all possible subsets (the power set).
 *
 * Note: The solution set must not contain duplicate subsets.
 *
 * Example:
 *
 *
 * Input: [1,2,2]
 * Output:
 * [
 * ⁠ [2],
 * ⁠ [1],
 * ⁠ [1,2,2],
 * ⁠ [2,2],
 * ⁠ [1,2],
 * ⁠ []
 * ]
 *
 *
 */
function backtrack(list, tempList, nums, start) {
  list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    // 和78.subsets的区别在于这道题nums可以有重复
    // 因此需要过滤这种情况
    if (i > start && nums[i] === nums[i - 1]) continue;
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
  const list = [];
  backtrack(
    list,
    [],
    nums.sort((a, b) => a - b),
    0,
    [],
  );
  return list;
};
```

#### 相关题目

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [91].decode-ways

#### 题目地址

https://leetcode.com/problems/decode-ways/description/

#### 题目描述

```
A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
Example 2:

Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```

#### 思路

这道题目和爬楼梯问题有异曲同工之妙。

这也是一道典型的动态规划题目。我们来思考：

- 对于一个数字来说[1,9]这九个数字能够被识别为一种编码方式
- 对于两个数字来说[10, 26]这几个数字能被识别为一种编码方式

我们考虑用 dp[i]来切分子问题， 那么 dp[i]表示的意思是当前字符串的以索引 i 结尾的子问题。
这样的话，我们最后只需要取 dp[s.length] 就可以解决问题了。

关于递归公式，让我们`先局部后整体`。对于局部，我们遍历到一个元素的时候，
我们有两种方式来组成编码方式，第一种是这个元素本身(需要自身是[1,9]),
第二种是它和前一个元素组成[10, 26]。 用伪代码来表示的话就是：
`dp[i] = 以自身去编码(一位) + 以前面的元素和自身去编码(两位)` .这显然是完备的，
这样我们通过层层推导就可以得到结果。

#### 关键点解析

- 爬楼梯问题(我把这种题目统称为爬楼梯问题)

#### 代码

```js
/*
 * @lc app=leetcode id=91 lang=javascript
 *
 * [91] Decode Ways
 *
 * https://leetcode.com/problems/decode-ways/description/
 *
 * algorithms
 * Medium (21.93%)
 * Total Accepted:    254.4K
 * Total Submissions: 1.1M
 * Testcase Example:  '"12"'
 *
 * A message containing letters from A-Z is being encoded to numbers using the
 * following mapping:
 *
 *
 * 'A' -> 1
 * 'B' -> 2
 * ...
 * 'Z' -> 26
 *
 *
 * Given a non-empty string containing only digits, determine the total number
 * of ways to decode it.
 *
 * Example 1:
 *
 *
 * Input: "12"
 * Output: 2
 * Explanation: It could be decoded as "AB" (1 2) or "L" (12).
 *
 *
 * Example 2:
 *
 *
 * Input: "226"
 * Output: 3
 * Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2
 * 6).
 *
 */
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  if (s == null || s.length == 0) {
    return 0;
  }
  const dp = Array(s.length + 1).fill(0);
  dp[0] = 1;
  dp[1] = s[0] !== '0' ? 1 : 0;
  for (let i = 2; i < s.length + 1; i++) {
    const one = +s.slice(i - 1, i);
    const two = +s.slice(i - 2, i);

    if (two >= 10 && two <= 26) {
      dp[i] = dp[i - 2];
    }

    if (one >= 1 && one <= 9) {
      dp[i] += dp[i - 1];
    }
  }

  return dp[dp.length - 1];
};
```

#### 扩展

如果编码的范围不再是 1-26，而是三位的话怎么办？

### [92].reverse-linked-list-ii

#### 题目地址

https://leetcode.com/problems/reverse-linked-list-ii/description/

#### 题目描述

Reverse a linked list from position m to n. Do it in one-pass.

Note: 1 ≤ m ≤ n ≤ length of list.

Example:

Input: 1->2->3->4->5->NULL, m = 2, n = 4
Output: 1->4->3->2->5->NULL

#### 思路

考虑取出需要反转的这一小段链表，反转完后再插入到原先的链表中。

以本题为例：

变换的是 2,3,4 这三个点，那么我们可以先取出 2，用 front 指针指向 2，然后当取出 3 的时候，我们把 3 加到 2 的前面，把 front 指针前移到 3，依次类推，到 4 后停止，这样我们得到一个新链表 4->3->2, front 指针指向 4。

对于原链表来说，有两个点的位置很重要，需要用指针记录下来，分别是 1 和 5，把新链表插入的时候需要这两个点的位置。

用 pre 指针记录 1 的位置

当 4 结点被取走后，5 的位置需要记下来

这样我们就可以把倒置后的那一小段链表加入到原链表中

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

- 链表的基本操作(交换)
- 虚拟节点 dummy 简化操作
- 考虑特殊情况 m 是 1 或者 n 是链表长度的情况
- 用四个变量记录特殊节点， 然后操作这四个节点使之按照一定方式连接即可。

```js
let midStartNode = null;
let preMidStartNode = null;
let midEndNode = null;
let postMidEndNode = null;
```

- 注意更新 current 和 pre 的位置， 否则有可能出现溢出

#### 代码

```js
/*
 * @lc app=leetcode id=92 lang=javascript
 *
 * [92] Reverse Linked List II
 *
 * https://leetcode.com/problems/reverse-linked-list-ii/description/
 *
 * algorithms
 * Medium (34.13%)
 * Total Accepted:    182.3K
 * Total Submissions: 532.8K
 * Testcase Example:  '[1,2,3,4,5]\n2\n4'
 *
 * Reverse a linked list from position m to n. Do it in one-pass.
 *
 * Note: 1 ≤ m ≤ n ≤ length of list.
 *
 * Example:
 *
 *
 * Input: 1->2->3->4->5->NULL, m = 2, n = 4
 * Output: 1->4->3->2->5->NULL
 *
 *
 */

/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */
var reverseBetween = function(head, m, n) {
  // 虚拟节点，简化操作
  const dummyHead = {
    next: head,
  };

  let current = dummyHead.next; // 当前遍历的节点
  let pre = current; // 因为要反转，因此我们需要记住前一个节点
  let index = 0; // 链表索引，用来判断是否是特殊位置(头尾位置)

  // 上面提到的四个特殊节点
  let midStartNode = null;
  let preMidStartNode = null;
  let midEndNode = null;
  let postMidEndNode = null;

  while (current) {
    const next = current.next;
    index++;

    // 对 (m - n) 范围内的节点进行反转
    if (index > m && index <= n) {
      current.next = pre;
    }

    // 下面四个if都是边界, 用于更新四个特殊节点的值
    if (index === m - 1) {
      preMidStartNode = current;
    }
    if (index === m) {
      midStartNode = current;
    }

    if (index === n + 1) {
      postMidEndNode = current;
    }

    if (index === n) {
      midEndNode = current;
    }

    pre = current;

    current = next;
  }

  // 两个链表合并起来
  (preMidStartNode || dummyHead).next = midEndNode; // 特殊情况需要考虑
  midStartNode.next = postMidEndNode;

  return dummyHead.next;
};
```

### [94].binary-tree-inorder-traversal

#### 题目地址

https://leetcode.com/problems/binary-tree-inorder-traversal/description/

#### 题目描述

```
Given a binary tree, return the inorder traversal of its nodes' values. (中序遍历)

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?
```

#### 思路

递归的方式相对简单，非递归的方式借助栈这种数据结构实现起来会相对轻松。

如果采用非递归，可以用栈(Stack)的思路来处理问题。

中序遍历的顺序为左-根-右，具体算法为：

- 从根节点开始，先将根节点压入栈

- 然后再将其所有左子结点压入栈，取出栈顶节点，保存节点值

- 再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中， 重复上步骤

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

- 二叉树的基本操作(遍历)
  > 不同的遍历算法差异还是蛮大的
- 如果非递归的话利用栈来简化操作

- 如果数据规模不大的话，建议使用递归

- 递归的问题需要注意两点，一个是终止条件，一个如何缩小规模

1. 终止条件，自然是当前这个元素是 null(链表也是一样)

2. 由于二叉树本身就是一个递归结构， 每次处理一个子树其实就是缩小了规模，
   难点在于如何合并结果，这里的合并结果其实就是`left.concat(mid).concat(right)`,
   mid 是一个具体的节点，left 和 right`递归求出即可`

#### 代码

```js
/*
 * @lc app=leetcode id=94 lang=javascript
 *
 * [94] Binary Tree Inorder Traversal
 *
 * https://leetcode.com/problems/binary-tree-inorder-traversal/description/
 *
 * algorithms
 * Medium (55.22%)
 * Total Accepted:    422.4K
 * Total Submissions: 762.1K
 * Testcase Example:  '[1,null,2,3]'
 *
 * Given a binary tree, return the inorder traversal of its nodes' values.
 *
 * Example:
 *
 *
 * Input: [1,null,2,3]
 * ⁠  1
 * ⁠   \
 * ⁠    2
 * ⁠   /
 * ⁠  3
 *
 * Output: [1,3,2]
 *
 * Follow up: Recursive solution is trivial, could you do it iteratively?
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
  // 1. Recursive solution
  // if (!root) return [];
  // const left = root.left ? inorderTraversal(root.left) : [];
  // const right = root.right ? inorderTraversal(root.right) : [];
  // return left.concat([root.val]).concat(right);

  // 2. iterative solutuon
  if (!root) return [];
  const stack = [root];
  const ret = [];
  let left = root.left;

  let item = null; // stack 中弹出的当前项

  while (left) {
    stack.push(left);
    left = left.left;
  }

  while ((item = stack.pop())) {
    ret.push(item.val);
    let t = item.right;

    while (t) {
      stack.push(t);
      t = t.left;
    }
  }

  return ret;
};
```

### [98].validate-binary-search-tree

### [30].

```js
// [300]. Longest Increasing Subsequence

// Given an unsorted array of integers, find the length of longest increasing subsequence.

// Example:

// Input: [10,9,2,5,3,7,101,18]
// Output: 4
// Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is [4].
// Note:

// There may be more than one LIS combination, it is only necessary for you to return the length.
// Your algorithm should run in O(n2) complexity.

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function lengthOfLIS(nums) {
  const dp = new Array(nums.length).fill(1);

  // current num
  for (let i = 1; i < nums.length; i++) {
    // nums before current num
    let max = 0;
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        max = Math.max(dp[j], max);
      }
    }
    dp[i] = max + dp[i];
  }

  let max = 0;
  for (let i = 0; i < dp.length; i++) {
    if (dp[i] > max) max = dp[i];
  }

  return max;
}
```

### [31].

```js
// For an undirected graph with tree characteristics, we can choose any node
// as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.

// Format
// The graph contains n nodes which are labeled from 0 to n - [1]. You will be given the
// number n and a list of undirected edges (each edge is a pair of labels).

// You can assume that no duplicate edges will appear in edges. Since all edges are
// undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

// Observations:
// The height of a graph is maximal when the tree is rooted at a leaf. Another observation
// is that the nodes in the centermost of the graph have the lowest height when chosen to
// be the root. The procedure is then to delete leaves until there are are either only one
// or two nodes left.

/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
export default function findMinHeightTrees(n, edges) {
  if (n === 2) return edges[0];
  const adj = new Array(n);
  for (let i = 0; i < n; i++) {
    adj[i] = new Set();
  }
  for (const edge of edges) {
    const [a, b] = edge;
    adj[a].add(b);
    adj[b].add(a);
  }
  const ans = new Set();
  for (let i = 0; i < n; i++) {
    ans.add(i);
  }
  // Find leaves and add them to queue
  const queue = [];
  const a = [];
  for (let i = 0; i < n; i++) {
    if (adj[i].size === 1) {
      a.push(i);
    }
  }
  queue.push(a);

  // While set has more than two nodes, remove them
  while (queue.length) {
    const nodes = queue.shift();
    const b = [];
    for (const node of nodes) {
      ans.delete(node);
      // delete the edges from the current node to other nodes
      for (const child of adj[node]) {
        adj[child].delete(node);
        adj[node].delete(child);
        if (adj[child].size === 1) {
          b.push(child);
        }
      }
    }
    if (ans.size < 3) break;
    if (b.length) queue.push(b);
  }

  return Array.from(ans);
}
```

### [38].

```js
// Design a data structure that supports all following operations in average O(1) time.

// insert(val): Inserts an item val to the set if not already present.
// remove(val): Removes an item val from the set if present.
// getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
// Example:

// // Init an empty set.
// RandomizedSet randomSet = new RandomizedSet();

// // Inserts 1 to the set. Returns true as 1 was inserted successfully.
// randomSet.insert(1);

// // Returns false as 2 does not exist in the set.
// randomSet.remove(2);

// // Inserts 2 to the set, returns true. Set now contains [1,2].
// randomSet.insert(2);

// // getRandom should return either 1 or 2 randomly.
// randomSet.getRandom();

// // Removes 1 from the set, returns true. Set now contains [2].
// randomSet.remove(1);

// // 2 was already in the set, so return false.
// randomSet.insert(2);

// // Since 2 is the only number in the set, getRandom always return [2].
// randomSet.getRandom();

// Observations:
// use an array for order
// keep track of array indicies mapping to set key
//
// remove:
//   swap with last element, then delete
//   then delete from mappings
// insert:
//   add to end of array
//   then add to mappings
// getRandom:
//   get random array element from array and return

/**
 * Initialize your data structure here.
 */
export default class RandomizedSet {
  constructor() {
    this.set = new Set();
    this.mappings = new Map();
    this.randomArray = [];
    this.last = -1;
  }

  /**
   * Inserts a value to the set. Returns true if the set did not already contain the specified element.
   * @param {number} val
   * @return {boolean}
   */
  insert(val) {
    if (this.set.has(val)) return false;
    this.set.add(val);
    this.last++;
    this.randomArray[this.last] = val;
    this.mappings.set(val, this.last);
    return true;
  }

  /**
   * Removes a value from the set. Returns true if the set contained the specified element.
   * @param {number} val
   * @return {boolean}
   */
  remove(val) {
    if (!this.set.has(val)) return false;
    this.set.delete(val);
    const itemIndex = this.mappings.get(val);
    const last = this.randomArray[this.last];
    this.randomArray[this.last] = undefined;
    this.randomArray[itemIndex] = last;
    this.mappings.set(last, itemIndex);
    this.mappings.delete(val);
    this.last--;
    return true;
  }

  /**
   * Get a random element from the set.
   * @return {number}
   */
  getRandom() {
    const index = Math.floor(Math.random() * (this.last + 1));
    return this.randomArray[index];
  }
}
```

### [39].

```js
/**
 * Given an encoded string, return it's decoded string.
 * The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets
 * is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
 * You may assume that the input string is always valid; No extra white spaces, square
 * brackets are well-formed, etc.
 * Furthermore, you may assume that the original data does not contain any digits and
 * that digits are only for those repeat numbers, k. For example, there won't be input
 * like 3a or 2[4].
 *
 * Examples:
 * s = "3[a]2[bc]", return "aaabcbc".
 * s = "3[a2[c]]", return "accaccacc".
 * s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
 *
 * Approach:
 * We see that brackets can be nested, so from this, we can deduce that the algorithm can probably
 * be solved recursively
 *
 * We need to expand the mostly deeply nested, or innermost, strings first. Maybe we can add them
 * to a stack. The top-most elements would be the innermost strings:
 *
 * Example: "3[a2[c]]"
 *
 *   "3[a2[c]]"
 *    "a2[c]"
 *     "2[c]"
 *      "c"
 *     "cc"
 *     "acc"
 *   "accaccacc"
 *
 * @flow
 */
function joinNTimes(string: string, n: number): string {
  return new Array(n + 1).join(string);
}

export default function DecodeString(string: string, continuingString: string = ''): string {
  const chars = Array.from(string);

  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];

    if (!Number.isNaN(parseInt(char))) {
      // console.log(continuingString);
      continuingString += joinNTimes(DecodeString(chars.slice(i + 2, chars.length - 1)), parseInt(char));
    }

    if (char === ']') {
      return continuingString;
    }

    if (char !== '[' && char !== ']') {
      continuingString += char;
    }
  }

  return continuingString;
}

console.log(DecodeString('3[a]2[bc]'));
// console.log(DecodeString('3[a2[c]]'));
```

### [45].

```js
// You are given an array of positive and negative integers. If a number n at
// an index is positive, then move forward n steps. Conversely, if it's
// negative (-n), move backward n steps. Assume the first element of the array
// is forward next to the last element, and the last element is backward next
// to the first element. Determine if there is a loop in this array. A loop
// starts and ends at a particular index with more than 1 element along the
// loop. The loop must be "forward" or "backward'.
//
// Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> [0].
//
// Example 2: Given the array [-1, 2], there is no loop.
//
// Note: The given array is guaranteed to contain no element "0".
//
// Can you do it in O(n) time complexity and O(1) space complexity?
//

import { expect } from 'chai';

function CircularArrayLoop(nums: number[]): boolean {
  const _nums = new Set();
  let ended = false;
  let index = 0;

  while (!ended) {
    if (!_nums.has(index)) {
      _nums.add(index);
    } else {
      ended = false;
    }

    index += nums[index];
  }

  return false;
}

test('CircularArrayLoop()', () => {
  expect(CircularArrayLoop([2, -1, 1, 2, 2])).instanceOf(Array);
});
```

### [21].merge-two-sorted-lists

```js
/*
 * @lc app=leetcode id=21 lang=javascript
 *
 * [21] Merge Two Sorted Lists
 *
 * https://leetcode.com/problems/merge-two-sorted-lists/description/
 *
 * algorithms
 * Easy (46.02%)
 * Total Accepted:    562.7K
 * Total Submissions: 1.2M
 * Testcase Example:  '[1,2,4]\n[1,3,4]'
 *
 * Merge two sorted linked lists and return it as a new list. The new list
 * should be made by splicing together the nodes of the first two lists.
 *
 * Example:
 *
 * Input: 1->2->4, 1->3->4
 * Output: 1->1->2->3->4->4
 *
 *
 */

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;

  //   if (l1 === null) return l2;
  //   if (l2 === null) return l1;
  //   if (l1.val < l2.val) {
  //     l1.next = mergeTwoLists(l1.next, l2);
  //     return l1;
  //   } else {
  //     l2.next = mergeTwoLists(l1, l2.next);
  //     return l2;
  //   }
};
```

### [34].find-first-and-last-position-of-element-in-sorted-array

```js
/*
 * @lc app=leetcode id=34 lang=javascript
 *
 * [34] Find First and Last Position of Element in Sorted Array
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 题目要求时间复杂度为O(logn)因此很自然想到二分法
  let start = 0;
  let end = nums.length - 1;
  while (start <= end) {
    const mid = start + ((end - start) >> 1);

    if (nums[mid] === target) {
      let left = 0;
      let right = 0;

      while (nums[mid - left] === target) {
        left++;
      }
      while (nums[mid + right] === target) {
        right++;
      }
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return [-1, -1];
};
```

### [93].restore-ip-addresses

```js
/*
 * @lc app=leetcode id=93 lang=javascript
 *
 * [93] Restore IP Addresses
 */
function backtrack(list, tempList, s, start) {
  if (tempList.length === 4 && tempList.join('') === s && !list.includes(tempList.join('.'))) {
    list.push(tempList.join('.'));
  }
  if (tempList.length > 4) return;

  for (let i = start; i < s.length; i++) {
    for (let j = 0; j < 3; j++) {
      const r = s.slice(i, i + j + 1);
      if (+r > 255) continue;
      if (r[0] === '0' && r.length > 1) continue;
      tempList.push(r);
      backtrack(list, tempList, s, i + j + 1);
      tempList.pop();
    }
  }
}
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  // Given "25525511135",
  // return ["255.255.11.135", "255.255.111.35"].
  if (s.length > 3 * 4) return [];
  const list = [];
  backtrack(list, [], s, 0);
  return list;
};
```

### [54].Spiral Matrix

#### 信息卡片

- 题目链接：https://leetcode.com/problems/spiral-matrix/
- tag：`Array` `Matrix`

#### 题目描述

```
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

  Input:
    [
      [ 1, 2, 3 ],
      [ 4, 5, 6 ],
      [ 7, 8, 9 ]
    ]
  Output: [1,2,3,6,9,8,7,4,5]
Example 2:

  Input:
    [
      [1, 2, 3, 4],
      [5, 6, 7, 8],
      [9,10,11,12]
    ]
  Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

#### 参考答案

1. 剥洋葱，row->col->row->col 为一次；
2. row->col、col->row 的切换都伴随读取的初始位置的变化；
3. 结束条件是 row 头>row 尾或者 col 顶>col 底

时间复杂度 O(m\*n), 空间复杂度 O(1)

参考 JavaScript 代码：

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  if (matrix.length === 0) return [];
  let rowT = 0; // 行顶
  let rowB = matrix.length - 1; // 行底
  let colL = 0; // 列左
  let colR = matrix[0].length - 1; // 列右
  let result = [];
  // 顺序是行、列、行、列；每次切换，读取的初始位置都会变化1(+/- 1)
  while (colL <= colR && rowT <= rowB) {
    for (let a = colL; a <= colR; a++) {
      result.push(matrix[rowT][a]);
    }
    rowT++;
    for (let b = rowT; b <= rowB; b++) {
      result.push(matrix[b][colR]);
    }
    colR--;
    for (let c = colR; c >= colL && rowB >= rowT; c--) {
      result.push(matrix[rowB][c]);
    }
    rowB--;
    for (let d = rowB; d >= rowT && colR >= colL; d--) {
      result.push(matrix[d][colL]);
    }
    colL++;
  }
  return result;
};
```

代码只有一个 for 循环的方式，操作方向
例如

> 1 2 3 4 5
> 6 7 8 9 10
> 11 12 13 14 15
>
> 对上面矩阵遍历时的操作
>
> 向右 5 次(算上从左侧第一次进入)
> 向下 2 次
> 向左 4 次
> 向上 1 次
> 向右 3 次
> 向下 0 次 -- 结束

方向有四个，right、down、left、up
四个方向又分两类，水平(right,left)和垂直(down，up)
而在两类方向上的移动最值是 水平 n, 垂直 m;
在遍历过程中，根据`方向切换`来减小 n/m 从而缩小两类方向的移动最值直到结束
四个方向可以用二维数组来表示[ [0, 1], [1, 0], [0, -1], [-1, 0] ]
两类方向各自的初始最大值是[n, m-1]
当 n == 0 || m == 0 表示元素已经全部遍历完

这种写法省去了代码中的 for 循环，但是 while 循环次数却增多了；复杂度没有变化
时间复杂度 O(m\*n), 空间复杂度 O(1)

参考 JavaScript 代码：

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 * 一个for循环,但while变多了
 */
var spiralOrder = function(matrix) {
  if (matrix.length === 0) return [];
  let m = matrix.length;
  let n = matrix[0].length;
  let result = [];
  const dirs = [
    [0, 1],
    [1, 0],
    [0, -1],
    [-1, 0],
  ]; // 控制方向的数组
  // 元素坐标row,col;
  let row = 0;
  let col = -1;
  let steps = [n, m - 1];
  let dir = 0; // 初始方向
  while (steps[dir % 2]) {
    for (let i = 0; i < steps[dir % 2]; i++) {
      // 方向的改变的效果，row/col能增能减
      row += dirs[dir][0];
      col += dirs[dir][1];
      result.push(matrix[row][col]);
    }
    steps[dir % 2]--; // 移动极值缩小
    dir = (dir + 1) % 4; // 方向改变
  }
  return result;
};
```

#### 参考

- @stellari [A concise C++ implementation based on Directions](https://leetcode.com/problems/spiral-matrix/discuss/20573/A-concise-C%2B%2B-implementation-based-on-Directions)

####### 走地球问题

- 题目链接：暂无
- tag：`几何`

##### 题目描述：

```
地球上有多少个点，使得从该点出发向南走一英里，向东走一英里，再向北走一英里之后恰好回到了起点?
```

##### 参考答案

无数个点

思路如下：
首先可以确定的是北极点(从北极点出发，任何角度都是向南)

将地球看成一个标准球体，那么纬线就是无数个长度不等的圆，必然存在纬线满足周长等于`2πkR=1(英里) 其中k为正整数`,即半径为`R=1/2πk`的圆
那么沿着这条纬线(记为 E 纬线)上任意一点向东走一英里，始终会回到原点，只是走的圈数不同而已。
根据题目倒推，在这条纬线以北一英里存在一条纬线(记为 N 纬线)，从 N 纬线的任意一点向南一英里到达 E 纬线 W 点，沿着 E 纬线向东一英里，必会回到 W 点，再向北走一英里恰好可以回到起点。北极点可能包含在这个集合中，也可能不在。
如下图示供参考：

所以答案是无数个点

####### 小飞电梯调度问题

- 题目链接：暂无
- tag：`Math` `Dynamic Programming`

##### 题目描述：

```
微软亚洲研究所所在的希格玛大厦一共有6部电梯。在高峰时间，每层都有人上下，电梯在每层都停。实习生小飞常常会被每层都停的电梯弄得很不耐烦，于是他提出了这样一个办法：
由于楼层并不太高看没在繁忙的上下班时间，每层电梯从一层往上走时，我们只允许电梯停在其中的某一层。所有的乘客都从一楼上电梯，到达某层楼后，电梯停下来，所有乘客再从这里爬楼梯到自己的目的层。
在一楼的时候，每个乘客选择自己的目的层，电梯则自动计算出应停的楼层。
问：电梯停在哪一层楼，能够保证这次乘坐电梯的所有乘客爬楼梯的层数之和最少。

扩展：

1.如何在O(n)的时间复杂度完成？
2.往上爬楼梯，总是比往下走要累的。假设往上爬一个楼层，要耗费k单位的能量，而往下走只需要耗费1单位的能量，那么如果题目条件改为让所有人消耗的能量最少，这个问题怎么解决呢？
这个问题可以用类似上面的分析方法来解答看，因此笔者不再累述，留给读者自行解决。
3.在一个高楼里面，电梯只在某一个楼层停，这个政策还是不太人性化。如果电梯会在k个楼层停呢？读者可以发挥自己的想象力，看看如何寻找最优方案。
```

##### 参考答案

题意是
每层都停 => 只停一层，其余让人爬楼梯；所有人爬梯之和最小
选择目的层(i)，在 i 层下的人数是 T[i]，根据大家选择的目的层计算在哪一层(X)停最优
sum(1 ～ N){T[i]\*|i-x|}的最小值

从简单易想到的方式开始；
从 1 楼开始直到顶层，算出在每层人需要爬梯的总和数组 result
找出 Min(result)下标
时间复杂度是 O(N^2)

```js
/**
 * 两个测试数据
 * nPerson = [0, 1, 3, 4, 2, 3]
 * nPerson = [0, 1, 0, 2, 2, 6]
 */
function original(nPerson) {
  // nPerson首元素设0，使楼层与下标对应
  // nPerson[i] 在i层下的人， N 总楼层
  let result = [0]; // 存各层结果
  let target = 1; // 最小值下标
  for (let x = 1; x < nPerson.length; x++) {
    // 目标楼层x
    result[x] = 0;
    for (let i = 1; i < nPerson.length; i++) {
      // 人在哪层停留
      result[x] += nPerson[i] * Math.abs(x - i);
    }
    if (result[target] > result[x]) {
      target = x;
    }
  }
  return target;
}
```

进一步考虑(动态规划)
假设在 i 层停，共需要爬 Y 阶；在 i 层有 N2 人，在 i 层以下共 N1 人，i 层以上共 N3 人
如果在 i-1 层停，相比 i 层变化 Y+N2+N3-N1 = Y - (N1-N2-N3) => N1 > (N2 + N3)时会减少爬阶数
如果在 i+1 层停，相比 i 层变化 Y-N3+N2+N1 = Y - (N3-N2-N1) => N3 > (N2 + N1)时会减少爬阶数
所以在 N1 > N2+N3 时应该在 i-1 层停，N3 > N2+N1 时应该在 i+1 层停; 否则在 i 层停

初始状态电梯停在第一层，向上进行状态的变迁，开始时 N2 + N1 - N3 < 0
sum 越来越小，直到某一层 N2 + N1 >= N3，就没有必要在往上走了。这时已求出最合适的楼层了

```js
function betterOne(nPerson) {
  // 首元素设空, 下标就与楼层对应了，nPerson的长度-1就是楼层数
  let N1 = 0;
  let N2 = nPerson[1];
  let N3 = 0;
  let target = 1;
  // 第一层时，算出人需要走的楼梯数Y和在一楼以上的人数N3
  for (let i = 2; i < nPerson.length; i++) {
    N3 += nPerson[i];
  }
  // 再来优化
  for (let i = 2; i < nPerson.length; i++) {
    if (N1 + N2 < N3) {
      // 在i+1层停较优
      target = i;
      N1 += N2;
      N3 -= nPerson[i];
      N2 = nPerson[i];
    } else {
      break;
    }
  }
  return target;
}
```

扩展问题 2 的解
向上爬比向下走更耗费体力，假设上楼是下楼耗费能量的 k 倍；k 大于 1
比较消耗能量的大小决定楼层，只需在动态规划方式上增加权重即可

```js
function betterOnewithWeight(nPerson, k) {
  // 首元素设空, 下标就与楼层对应了，nPerson的长度-1就是楼层数
  let N1 = 0;
  let N2 = nPerson[1];
  let N3 = 0;
  let target = 1;
  // 第一层时，算出人需要走的楼梯数Y和在一楼以上的人数N3
  for (let i = 2; i < nPerson.length; i++) {
    N3 += nPerson[i];
  }
  // 再来优化
  for (let i = 2; i < nPerson.length; i++) {
    if (N1 + N2 < N3 * k) {
      // 在i+1层停比较好
      target = i;
      N1 += N2;
      N3 -= nPerson[i];
      N2 = nPerson[i];
    } else {
      break;
    }
  }
  return target;
}
```

##### 其他优秀解答

中位数方法

假设两个人在 2 楼和 9 楼下。那么在 2-9 楼之间任意层停，两人走楼梯的层数和是不变的
换一组(第二小、第二大)人也是这么处理
将每个人要去的楼层从低到高逐一排列，找到中位数，此中位数就是最优楼层

时间复杂度 O(N)

```js
/**
 * 中位数方法
 */
function median(nPerson) {
  const newArr = []; // 存楼层
  for (let i = 0; i < nPerson.length; i++) {
    while (nPerson[i] > 0) {
      newArr.push(i);
      nPerson[i]--;
    }
  }
  let len = newArr.length;
  // 返回楼层中位数
  return len % 2 == 1 ? newArr[(len + 1) / 2] : newArr[len / 2];
}
```

### [64].最小路径和

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/minimum-path-sum/

* tag：`动态规划` `Array`

#### 题目描述

给定一个包含非负整数的  m x n  网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
**说明**：每次只能向下或者向右移动一步。
**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

#### 参考答案

动态规划求解，时间复杂度 O(n\*m)

> 我们新建一个额外的 dp 数组，与原矩阵大小相同。在这个矩阵中,dp(i,j)表示从坐标(i,j)到右下角的最小路径权值。我们初始化右下角的 dp 值为对应的原矩阵值，然后去填整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：`dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))`

```
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        //剪枝
        int n = grid.size();
        if(n==0)
            return 0;
        int m = grid[0].size();
        if(m==0)
            return 0;
        //初始化第一列
        for(int i=1;i<m;i++)
        {
            grid[0][i] += grid[0][i-1];
        }
        //初始化第一排
        for(int i=1;i<n;i++)
        {
            grid[i][0] += grid[i-1][0];
        }

        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                //计算出到当前位置的最小值
                grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);
            }
        }
        return grid[n-1][m-1];
    }
};
```

### [54].spiral-matrix

```js
/*
 * @lc app=leetcode id=54 lang=javascript
 *
 * [54] Spiral Matrix
 */
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  // https://leetcode.com/problems/spiral-matrix/discuss/20570/Clean-Java-readable-human-friendly-code
  // brilliant!
  const res = [];
  if (matrix.length == 0) return res;

  let top = 0;
  let bottom = matrix.length - 1;
  let left = 0;
  let right = matrix[0].length - 1;

  while (true) {
    for (let i = left; i <= right; i++) res.push(matrix[top][i]);
    top++;
    if (top > bottom) break;

    for (let i = top; i <= bottom; i++) res.push(matrix[i][right]);
    right--;
    if (left > right) break;

    for (let i = right; i >= left; i--) res.push(matrix[bottom][i]);
    bottom--;
    if (top > bottom) break;

    for (let i = bottom; i >= top; i--) res.push(matrix[i][left]);
    left++;
    if (left > right) break;
  }

  return res;
};
```

### [50].pow-x-n

#### 题目描述

```
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:

输入: 2.00000, 10
输出: 1024.00000
示例 2:

输入: 2.10000, 3
输出: 9.26100
示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
说明:

-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

```

#### 解法零 - 遍历法

##### 思路

这道题是让我们实现数学函数`幂`，因此直接调用系统内置函数是不被允许的。

符合直觉的做法是`将x乘以n次`，这种做法的时间复杂度是$O(N)$。

经实际测试，这种做法果然超时了。测试用例通过 291/304，在 `0.00001\n2147483647`这个测试用例挂掉了。如果是面试，这个解法可以作为一种兜底解法。

#### 解法一 - 普通递归(超时法)

##### 思路

首先我们要知道：

- 如果想要求 x ^ 4，那么我们可以求 (x^2)^2
- 如果是奇数，会有一点不同。 比如 x ^ 5 就等价于 x \* (x^2)^2。

> 当然 x ^ 5 可以等价于 (x ^ 2) ^ 2.5, 但是这不相当于直接调用了幂函数了么。对于整数，我们可以很方便的模拟，但是小数就不方便了。

我们的思路就是：

- 将 n 地板除 2，我们不妨设结果为 a
- 那么 myPow(x, n) 就等价于 `myPow(x, a) * myPow(x, n - a)`

很可惜这种算法也会超时，原因在于重复计算会比较多，你可以试一下缓存一下计算看能不能通过。

> 如果你搞不清楚有哪些重复计算，建议画图理解一下。

#### 解法二 - 优化递归

##### 思路

上面的解法每次直接 myPow 都会调用两次自己。我们不从缓存计算角度，而是从减少这种调用的角度来优化。

我们考虑 myPow 只调用一次自身可以么？ 没错，是可以的。

我们的思路就是：

- 如果 n 是偶数，我们将 n 折半，底数变为 x^2
- 如果 n 是奇数， 我们将 n 减去 1 ，底数不变，得到的结果再乘上底数 x

这样终于可以 AC。

#### 解法三 - 位运算

##### 思路

我们来从位(bit)的角度来看一下这道题。如果你经常看我的题解和文章的话，可能知道我之前写过几次相关的“从位的角度思考分治法”，比如 LeetCode [458.可怜的小猪](https://leetcode-cn.com/problems/poor-pigs/description/)。

以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gbdseolzbmj30t802mjrk.jpg)

![](https://tva1.sinaimg.cn/large/006tNbRwly1gbdssrrsh6j30xp0u040e.jpg)

因此我们的算法就是：

- 不断的求解 x 的 2^0 次方，x 的 2^1 次方，x 的 2^2 次方等等。
- 将 n 转化为二进制表示
- 将 n 的二进制表示中`1的位置`pick 出来。比如 n 的第 i 位为 1，那么就将 x^i pick 出来。
- 将 pick 出来的结果相乘

![](https://tva1.sinaimg.cn/large/006tNbRwly1gbdtiky90rj30vq0hcab4.jpg)

这里有两个问题：

第一个问题是`似乎我们需要存储 x^i 以便后续相乘的时候用到`。实际上，我们并不需要这么做。我们可以采取一次遍历的方式来完成，具体看代码。

第二个问题是，如果我们从低位到高位计算的时候，我们如何判断最高位置是否为 1？我们需要一个 bitmask 来完成，这种算法我们甚至需要借助一个额外的变量。 然而我们可以 hack 一下，直接从高位到低位进行计算，这个时候我们只需要判断最后一位是否为 1 就可以了，这个就简单了，我们直接和 1 进行一次`与运算`即可。

#### 关键点解析

- 超时分析
- hashtable
- 数学分析
- 位运算
- 二进制转十进制

#### 相关题目

- [458.可怜的小猪](https://leetcode-cn.com/problems/poor-pigs/description/)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbdrfn9n2wj30wn0u0dp2.jpg)

### [53].maximum-sum-subarray-cn

#### 题目描述

```
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
```

#### 思路

这道题求解连续最大子序列和，以下从时间复杂度角度分析不同的解题思路。

###### 解法一 - 暴力解 (暴力出奇迹， 噢耶！)

一般情况下，先从暴力解分析，然后再进行一步步的优化。

**原始暴力解：**(超时)

求子序列和，那么我们要知道子序列的首尾位置，然后计算首尾之间的序列和。用 2 个 for 循环可以枚举所有子序列的首尾位置。
然后用一个 for 循环求解序列和。这里时间复杂度太高，`O(n^3)`.

###### 复杂度分析

- _时间复杂度：_ `O(n^3) - n 是数组长度`
- _空间复杂度：_ `O(1)`

###### 解法二 - 前缀和 + 暴力解

**优化暴力解：** (震惊，居然 AC 了)

在暴力解的基础上，用前缀和我们可以优化到暴力解`O(n^2)`, 这里以空间换时间。
这里可以使用原数组表示`prefixSum`, 省空间。

求序列和可以用前缀和(`prefixSum`) 来优化，给定子序列的首尾位置`(l, r),`
那么序列和 `subarraySum=prefixSum[r] - prefixSum[l - 1];`
用一个全局变量`maxSum`, 比较每次求解的子序列和，`maxSum = max(maxSum, subarraySum)`.

###### 复杂度分析

- _时间复杂度：_ `O(n^2) - n 是数组长度`
- _空间复杂度：_ `O(n) - prefixSum 数组空间为n`

> 如果用更改原数组表示前缀和数组，空间复杂度降为`O(1)`

但是时间复杂度还是太高，还能不能更优化。答案是可以，前缀和还可以优化到`O(n)`.

###### 解法三 - 优化前缀和 - from [**@lucifer**](https://github.com/azl397985856)

我们定义函数`S(i)` ，它的功能是计算以 `0(包括 0)`开始加到 `i(包括 i)`的值。

那么 `S(j) - S(i - 1)` 就等于 从 `i` 开始(包括 i)加到 `j`(包括 j)的值。

我们进一步分析，实际上我们只需要遍历一次计算出所有的 `S(i)`, 其中 `i = 0,1,2....,n-1。`
然后我们再减去之前的`S(k)`,其中 `k = 0，1，i - 1`，中的最小值即可。 因此我们需要
用一个变量来维护这个最小值，还需要一个变量维护最大值。

###### 复杂度分析

- _时间复杂度：_ `O(n) - n 是数组长度`
- _空间复杂度：_ `O(1)`

###### 解法四 - [分治法](https://www.wikiwand.com/zh-hans/%E5%88%86%E6%B2%BB%E6%B3%95)

我们把数组`nums`以中间位置(`m`)分为左(`left`)右(`right`)两部分. 那么有，
`left = nums[0]...nums[m - 1]` 和 `right = nums[m + 1]...nums[n-1]`

最大子序列和的位置有以下三种情况：

1. 考虑中间元素`nums[m]`, 跨越左右两部分，这里从中间元素开始，往左求出后缀最大，往右求出前缀最大, 保持连续性。
2. 不考虑中间元素，最大子序列和出现在左半部分，递归求解左边部分最大子序列和
3. 不考虑中间元素，最大子序列和出现在右半部分，递归求解右边部分最大子序列和

分别求出三种情况下最大子序列和，三者中最大值即为最大子序列和。

举例说明，如下图：

###### 复杂度分析

- _时间复杂度：_ `O(nlogn) - n 是数组长度`
- _空间复杂度：_ `O(logn)` - 因为调用栈的深度最多是 logn。

###### 解法五 - [动态规划](https://www.wikiwand.com/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

动态规划的难点在于找到状态转移方程，

`dp[i] - 表示到当前位置 i 的最大子序列和`

状态转移方程为：
`dp[i] = max(dp[i - 1] + nums[i], nums[i])`

初始化：`dp[0] = nums[0]`

从状态转移方程中，我们只关注前一个状态的值，所以不需要开一个数组记录位置所有子序列和，只需要两个变量，

`currMaxSum - 累计最大和到当前位置i`

`maxSum - 全局最大子序列和`:

- `currMaxSum = max(currMaxSum + nums[i], nums[i])`
- `maxSum = max(currMaxSum, maxSum)`

如图：

###### 复杂度分析

- _时间复杂度:_ `O(n) - n 是数组长度`
- _空间复杂度:_ `O(1)`

#### 关键点分析

1. 暴力解，列举所有组合子序列首尾位置的组合，求解最大的子序列和, 优化可以预先处理，得到前缀和
2. 分治法，每次从中间位置把数组分为左右中三部分， 分别求出左右中(这里中是包括中间元素的子序列)最大和。对左右分别深度递归，三者中最大值即为当前最大子序列和。
3. 动态规划，找到状态转移方程，求到当前位置最大和。

#### 代码

###### 解法二 - 前缀和 + 暴力

```js
function LSS(list) {
  const len = list.length;
  let max = -Number.MAX_VALUE;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum = 0;
    for (let j = i; j < len; j++) {
      sum += list[j];
      if (sum > max) {
        max = sum;
      }
    }
  }

  return max;
}
```

###### 解法三 - 优化前缀和

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  let min = 0;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum += list[i];
    if (sum - min > max) max = sum - min;
    if (sum < min) {
      min = sum;
    }
  }

  return max;
}
```

###### 解法四 - 分治法

```js
function helper(list, m, n) {
  if (m === n) return list[m];
  let sum = 0;
  let lmax = -Number.MAX_VALUE;
  let rmax = -Number.MAX_VALUE;
  const mid = ((n - m) >> 1) + m;
  const l = helper(list, m, mid);
  const r = helper(list, mid + 1, n);
  for (let i = mid; i >= m; i--) {
    sum += list[i];
    if (sum > lmax) lmax = sum;
  }

  sum = 0;

  for (let i = mid + 1; i <= n; i++) {
    sum += list[i];
    if (sum > rmax) rmax = sum;
  }

  return Math.max(l, r, lmax + rmax);
}

function LSS(list) {
  return helper(list, 0, list.length - 1);
}
```

###### 解法五 - 动态规划

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  for (let i = 1; i < len; i++) {
    list[i] = Math.max(0, list[i - 1]) + list[i];
    if (list[i] > max) max = list[i];
  }

  return max;
}
```

#### 扩展

- 如果数组是二维数组，求最大子数组的和？
- 如果要求最大子序列的乘积？

#### 相似题

- [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)
- [Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)

### [60].permutation-sequence

#### 标签

- 数学
- 回溯
- 找规律
- factorial

#### 题目描述

```
给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1, n!]。
示例 1:

输入: n = 3, k = 3
输出: "213"
示例 2:

输入: n = 4, k = 9
输出: "2314"
```

#### 思路

LeetCode 上关于排列的题目截止目前(2020-01-06)主要有三种类型：

- 生成全排列
- 生成下一个排列
- 生成第 k 个排列(我们的题目就是这种)

我们不可能求出所有的排列，然后找到第 k 个之后返回。因为排列的组合是 N！，要比 2^n 还要高很多，非常有可能超时。我们必须使用一些巧妙的方法。

我们以题目中的 n= 3 k = 3 为例：

- "123"
- "132"
- "213"
- "231"
- "312"
- "321"

可以看出 1xx，2xx 和 3xx 都有两个，如果你知道阶乘的话，实际上是 2！个。 我们想要找的是第 3 个。那么我们可以直接跳到 2 开头，我们排除了以 1 开头的排列，问题缩小了，我们将 2 加入到结果集，我们不断重复上述的逻辑，知道结果集的元素为 n 即可。

#### 关键点解析

- 找规律
- 排列组合

### [79].word-search

#### 题目描述

```
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

#### 思路

在 2D 表中搜索是否有满足给定单词的字符组合，要求所有字符都是相邻的(方向不限). 题中也没有要求字符的起始和结束位置。

在起始位置不确定的情况下，扫描二维数组，找到字符跟给定单词的第一个字符相同的，四个方向(上，下，左，右)分别 DFS 搜索，
如果任意方向满足条件，则返回结果。不满足，回溯，重新搜索。

举例说明：如图二维数组，单词："SEE"

```
1. 扫描二维数组，找到board[1,0] = word[0]，匹配单词首字母。
2. 做DFS(上，下，左，右 四个方向)

如下图：
```

起始位置(1，0)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1，0)为已经访问过，board[1][0] = '*'
2. 上(0，0)字符为 'A' 不匹配,
3. 下(2，0)字符为 'A'，不匹配,
4. 左(-1，0)超越边界，不匹配,
5. 右(1，1)字符 'F'，不匹配

如下图：
```

由于从起始位置 DFS 都不满足条件，所以

```
1. 回溯，标记起始位置(1，0)为未访问。board[1][0] = 'S'.
2. 然后继续扫描二维数组，找到下一个起始位置(1，3)

如下图：
```

起始位置(1，3)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1, 3)为已经访问过，board[1][3] = '*'
2. 上(0，3)字符为 'E', 匹配, 继续DFS搜索(参考位置为(0，3)位置DFS搜索步骤描述)
3. 下(2，3)字符为 'E'，匹配, #2匹配，先进行#2 DFS搜索，由于#2 DFS搜索没有找到与单词匹配，继续DFS搜索(参考位置为(2，3)DFS搜索步骤描述)
4. 左(1，2)字符为 'C'，不匹配,
5. 右(1，4)超越边界，不匹配

如下图：
```

位置(0，3)满足条件，继续 DFS，判断相邻的字符是否匹配单词下一个字符 `E`

```
1. 标记当前字符(0，3)为已经访问过，board[0][3] = '*'
2. 上 (-1，3)超越边界，不匹配
3. 下(1，3)已经访问过，
4. 左(0，2)字符为 'C'，不匹配
5. 右(1，4)超越边界，不匹配

如下图
```

从位置(0，3)DFS 不满足条件，继续位置(2，3)DFS 搜索

```
1. 回溯，标记起始位置(0，3)为未访问。board[0][3] = 'E'.
2. 回到满足条件的位置(2，3)，继续DFS搜索，判断相邻的字符是否匹配单词下一个字符 'E'
3. 上 (1，3)已访问过
4. 下(3，3)超越边界，不匹配
5. 左(2，2)字符为 'E'，匹配
6. 右(2，4)超越边界，不匹配

如下图：
```

单词匹配完成，满足条件，返回 `True`.

###### 复杂度分析

- _时间复杂度：_ `O(m*n) - m 是二维数组行数， n 是二维数组列数`
- _空间复杂度：_ `O(1) - 这里在原数组中标记当前访问过，没有用到额外空间`

> **注意**：如果用 Set 或者是 boolean[][]来标记字符位置是否已经访问过，需要额外的空间 `O(m*n)`.

#### 关键点分析

- 遍历二维数组的每一个点，找到起始点相同的字符，做 DFS
- DFS 过程中，要记录已经访问过的节点，防止重复遍历，这里(Java Code 中)用 `*` 表示当前已经访问过，也可以用 Set 或者是 boolean[][]数组记录访问过的节点位置。
- 是否匹配当前单词中的字符，不符合回溯，这里记得把当前 `*` 重新设为当前字符。如果用 Set 或者是 boolean[][]数组，记得把当前位置重设为没有访问过。

#### 代码

```js
/*
 * @lc app=leetcode id=79 lang=javascript
 *
 * [79] Word Search
 */
function DFS(board, row, col, rows, cols, word, cur) {
  // 边界检查
  if (row >= rows || row < 0) return false;
  if (col >= cols || col < 0) return false;

  const item = board[row][col];

  if (item !== word[cur]) return false;

  if (cur + 1 === word.length) return true;

  // 如果你用hashmap记录访问的字母， 那么你需要每次backtrack的时候手动清除hashmap，并且需要额外的空间
  // 这里我们使用一个little trick

  board[row][col] = null;

  // 上下左右
  const res =
    DFS(board, row + 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row - 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row, col - 1, rows, cols, word, cur + 1) ||
    DFS(board, row, col + 1, rows, cols, word, cur + 1);

  board[row][col] = item;

  return res;
}
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  if (word.length === 0) return true;
  if (board.length === 0) return false;

  const rows = board.length;
  const cols = board[0].length;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const hit = DFS(board, i, j, rows, cols, word, 0);
      if (hit) return true;
    }
  }
  return false;
};
```

### [80].remove-duplicates-from-sorted-array-ii

#### 题目描述

```
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。
说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

```

#### 思路

”删除排序“类题目截止到现在(2020-1-15)一共有四道题：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gax0eadc5ej30x60ce76i.jpg)

这道题是[26.remove-duplicates-from-sorted-array](./26.remove-duplicates-from-sorted-array.md) 的进阶版本，唯一的不同是不再是全部元素唯一，而是全部元素不超过 2 次。实际上这种问题可以更抽象一步，即“删除排序数组中的重复项，使得相同数字最多出现 k 次”
。 那么这道题 k 就是 2， 26.remove-duplicates-from-sorted-array 的 k 就是 1。

上一题我们使用了快慢指针来实现，这道题也是一样，只不过逻辑稍有不同。 其实快慢指针本质是读写指针，在这里我们的快指针实际上就是读指针，而慢指针恰好相当于写指针。”快慢指针的说法“便于描述和记忆，“读写指针”的说法更便于理解本质。本文中，以下内容均描述为快慢指针。

- 初始化快慢指针 slow ， fast ，全部指向索引为 0 的元素。
- fast 每次移动一格
- 慢指针选择性移动，即只有写入数据之后才移动。是否写入数据取决于 slow - 2 对应的数字和 fast 对应的数字是否一致。
- 如果一致，我们不应该写。 否则我们就得到了三个相同的数字，不符合题意
- 如果不一致，我们需要将 fast 指针的数据写入到 slow 指针。
- 重复这个过程，直到 fast 走到头，说明我们已无数字可写。

图解(红色的两个数字，表示我们需要比较的两个数字)：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0oyt4yhj30n10hpdgc.jpg)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0p3ri3ij30ga0880ss.jpg)

#### 关键点分析

- 快慢指针
- 读写指针
- 删除排序问题

#### 相关题目

正如上面所说，相关题目一共有三道(排除自己)。其中一道我们仓库已经讲到了。剩下两道原理类似，但是实际代码和细节有很大不同，原因就在于数组可以随机访问，而链表不行。 感兴趣的可以做一下剩下的两道链表题。

- 82. 删除排序链表中的重复元素 II

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0txa7gbj31lq0tg0zm.jpg)

- 83. 删除排序链表中的重复元素

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0uzm0euj318c0se44t.jpg)
