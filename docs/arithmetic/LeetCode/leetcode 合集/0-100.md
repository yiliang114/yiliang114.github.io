---
layout: CustomPages
title: LeetCode-合集 4
date: 2020-09-04
aside: false
draft: true
---

### [2].两数相加 Add Two Numbers

```js
export default function addTwoNumbers(l1, l2) {
  let carry = false;
  let ans;
  let prev;
  while (l1 || l2 || carry) {
    const val1 = (l1 && l1.val) || 0;
    const val2 = (l2 && l2.val) || 0;
    let sum = val1 + val2;
    if (carry) sum++;
    carry = sum > 9;
    const mod = sum % 10;
    if (ans) {
      prev.next = new ListNode(mod);
      prev = prev.next;
    } else {
      ans = new ListNode(mod);
      prev = ans;
    }
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }
  return ans;
}
```

```js
var addTwoNumbers = function(l1, l2) {
  let HEAD = new ListNode(0);
  let cur = HEAD;
  let p = l1,
    q = l2;
  let carry = 0;
  while (q !== null || p !== null) {
    let x = q === null ? 0 : q.val;
    let y = p === null ? 0 : p.val;
    let sum = carry + x + y;
    carry = Math.floor(sum / 10);
    let val = sum % 10;
    cur.next = new ListNode(val);
    cur = cur.next;
    if (q !== null) {
      q = q.next;
    }
    if (p !== null) {
      p = p.next;
    }
  }
  if (carry) {
    cur.next = new ListNode(carry);
  }
  return HEAD.next;
};
```

### [11].

```js
// Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

// Note: You may not slant the container and n is at least 2.

/**
 * @param {number[]} height
 * @return {number}
 */
export default function maxArea(height) {
  let width = height.length - 1;
  let lo = 0;
  let hi = height.length - 1;
  let max = 0;
  while (lo < hi) {
    const loVal = height[lo];
    const hiVal = height[hi];
    max = Math.max(max, width * Math.min(hiVal, loVal));
    if (loVal < hiVal) {
      lo++;
    } else {
      hi--;
    }
    width--;
  }
  return max;
}
```

### [33].

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const binSearch = (nums, target, n, m) => {
  if (n === m || m < n) {
    return nums[n] === target ? n : -1;
  }
  const mid = Math.floor((n + m) / 2);
  if (target === nums[mid]) return mid;
  // console.log(n, m, mid)
  if (target > nums[mid]) {
    return binSearch(nums, target, mid + 1, m);
  }
  return binSearch(nums, target, n, mid - 1);
};

export default function search(nums, target) {
  if (nums.length === 0) return -1;
  if (nums.length === 1) return nums[0] === target ? 0 : -1;

  let low = 0;
  let high = nums.length - 1;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (nums[mid] > nums[high]) low += 1;
    else high = mid;
  }

  const minIndex = low;
  const maxIndex = low - 1;

  if (nums[0] < nums[nums.length - 1]) {
    return binSearch(nums, target, 0, nums.length - 1);
  }

  if (target > nums[0]) {
    return binSearch(nums, target, 1, maxIndex);
  }
  if (target < nums[0]) {
    return binSearch(nums, target, minIndex, nums.length - 1);
  }
  return 0;
}
```

### [34].

```js
// 34. Find First and Last Position of Element in Sorted Array

// Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

// Your algorithm's runtime complexity must be in the order of O(log n).

// If the target is not found in the array, return [-1, -1].

// Input: nums = [5,7,7,8,8,10], target = 8
// Output: [3,4]

// Input: nums = [5,7,7,8,8,10], target = 6
// Output: [-1,-1]

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

const binSearch = (nums, lo, hi, target, left) => {
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (left) {
      if (nums[lo] === target) return lo;
      if (hi - lo === 1) return hi;
      if (nums[mid] < target) lo = mid;
      else hi = mid;
    } else {
      if (nums[hi] === target) return hi;
      if (hi - lo === 1) return lo;
      if (nums[mid] > target) hi = mid;
      else lo = mid;
    }
  }
};

export default function searchRange(nums, target) {
  if (nums.length === 0) return [-1, -1];
  // bin search for target.
  let lo = 0;
  let hi = nums.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] < target) lo = mid + 1;
    else hi = mid;
  }
  if (nums[lo] !== target) return [-1, -1];

  // if left and right not equal to target, we are done
  if (nums[lo - 1] !== target && nums[lo + 1] !== target) return [lo, lo];

  if (nums.length === 2) return [0, 1];

  // if left of target not equal to target, find left
  const left = nums[hi - 1] === target ? binSearch(nums, 0, lo, target, true) : hi;

  // if right of target not equal to target, find right
  const right = nums[lo + 1] === target ? binSearch(nums, hi, nums.length - 1, target, false) : lo;

  return [left, right];
}
```

### [36].

```js
// 36. Valid Sudoku

// Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

// Each row must contain the digits 1-9 without repetition.
// Each column must contain the digits 1-9 without repetition.
// Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.

/**
 * @param {character[][]} board
 * @return {boolean}
 */

const isNum = n => n !== '.';
const validateRow = (board, row) => {
  const set = new Set();
  for (let i = 0; i < board.length; i++) {
    if (isNum(board[row][i]) && set.has(board[row][i])) return false;
    set.add(board[row][i]);
  }
  return true;
};
const validateCol = (board, col) => {
  const set = new Set();
  for (let i = 0; i < board.length; i++) {
    if (isNum(board[i][col]) && set.has(board[i][col])) return false;
    set.add(board[i][col]);
  }
  return true;
};
const validateSquare = (board, i, j) => {
  const imin = i * 3;
  const imax = imin + 2;
  const jmin = j * 3;
  const jmax = jmin + 2;
  const set = new Set();
  for (let i = imin; i <= imax; i++) {
    for (let j = jmin; j <= jmax; j++) {
      if (isNum(board[i][j]) && set.has(board[i][j])) return false;
      set.add(board[i][j]);
    }
  }
  return true;
};

export default function isValidSudoku(board) {
  for (let i = 0; i < board.length; i++) {
    if (!validateRow(board, i)) return false;
  }
  for (let i = 0; i < board.length; i++) {
    if (!validateCol(board, i)) return false;
  }
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (!validateSquare(board, i, j)) return false;
    }
  }
  return true;
}
```

### [56].

```js
// 56. Merge Intervals

// Given a collection of intervals, merge all overlapping intervals.

// Example 1:

// Input: [[1,3],[2,6],[8,10],[15,18]]
// Output: [[1,6],[8,10],[15,18]]
// Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
// Example 2:

// Input: [[1,4],[4,5]]
// Output: [[1,5]]
// Explanation: Intervals [1,4] and [4,5] are considered overlapping.

/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
export default function merge(intervals) {
  if (intervals.length === 0) return [];
  if (intervals.length === 1) return intervals;
  intervals = intervals.sort((a, b) => {
    if (a[0] !== b[0]) return a[0] - b[0];
    return a[1] - b[1];
  });
  let start = intervals[0][0];
  let end = intervals[0][1];
  const ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    const left = intervals[i];
    const right = intervals[i + 1];
    if (right[0] <= end && right[1] >= end) {
      end = right[1]; // then overlap
    } else if (right[0] > end) {
      ans.push([start, end]);
      start = right[0];
      end = right[1];
    }
    if (i === intervals.length - 2) ans.push([start, end]);
  }
  return ans;
}
```

### [61].

```js
// 61. Rotate List

// Given a linked list, rotate the list to the right by k places, where k is non-negative.

// Example 1:

// Input: 1->2->3->4->5->NULL, k = 2
// Output: 4->5->1->2->3->NULL
// Explanation:
// rotate 1 steps to the right: 5->1->2->3->4->NULL
// rotate 2 steps to the right: 4->5->1->2->3->NULL
// Example 2:

// Input: 0->1->2->NULL, k = 4
// Output: 2->0->1->NULL
// Explanation:
// rotate 1 steps to the right: 2->0->1->NULL
// rotate 2 steps to the right: 1->2->0->NULL
// rotate 3 steps to the right: 0->1->2->NULL
// rotate 4 steps to the right: 2->0->1->NULL

/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
export default function rotateRight(head, k) {
  let len = 0;
  let curr = head;
  let tail = curr;
  while (curr !== null) {
    tail = curr;
    curr = curr.next;
    len++;
  }
  k %= len;
  if (len <= 1 || k === 0) return head;
  curr = head;
  for (let i = 0; i < len - k - 1; i++) {
    curr = curr.next;
  }
  const nextHead = curr.next;
  tail.next = head;
  head = nextHead;
  curr.next = null;
  return head;
}
```

### [64].

```js
// Given a m x n grid filled with non-negative numbers, find a path from top left to bottom
// right which minimizes the sum of all numbers along its path.

// Note: You can only move either down or right at any point in time.

// Input:
// [
//   [1,3,1],
//   [1,5,1],
//   [4,2,1]
// ]
// Output: 7
// Explanation: Because the path 1→3→1→1→1 minimizes the sum.

// Observations:
// This is a DP problem. The shortest path of location i, j is the Min of down or right

/**
 * @param {number[][]} grid
 * @return {number}
 */

const traverse = (grid, i, j, dpTable) => {
  if (i === grid.length - 1 && j === grid[0].length - 1) return grid[i][j];
  if (i < 0 || j < 0 || i === grid.length || j === grid[0].length) return Infinity;
  if (dpTable[i][j]) return dpTable[i][j];
  const min = Math.min(traverse(grid, i + 1, j, dpTable), traverse(grid, i, j + 1, dpTable));
  const res = grid[i][j] + min;
  dpTable[i][j] = res;
  return res;
};

export default function minPathSum(grid) {
  const dpTable = new Array(grid.length);
  for (let i = 0; i < grid.length; i++) {
    dpTable[i] = [];
  }
  return traverse(grid, 0, 0, dpTable);
}
```

### [74].

```js
const binSearch = (nums, target) => {
  let lo = 0;
  let hi = nums.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] === target) return true;
    if (nums[mid] < target) lo = mid + 1;
    else hi = mid;
  }
  return nums[lo] === target;
};

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
export default function searchMatrix(matrix, target) {
  if (matrix.length === 0) return false;
  let lo = 0;
  let hi = matrix.length - 1;
  while (lo < hi) {
    // Search the middle row
    const mid = Math.floor((lo + hi) / 2);
    // If ###  is in range of the row then bin search row
    if (matrix[mid].length === 0) return false;
    if (matrix[mid][0] <= target && target <= matrix[mid][matrix[mid].length - 1]) {
      return binSearch(matrix[mid], target);
    }
    if (matrix[mid][0] > target) {
      // if less than range, search rows between middle row and first row
      hi = mid - 1;
    } else {
      // search rows between middle row and last row
      lo = mid + 1;
    }
    if (hi < lo) return false;
    if (lo === hi) return binSearch(matrix[lo], target);
  }
  if (lo === hi) return binSearch(matrix[lo], target);
  return false;
}
```

### [75].

```js
// 75. Sort Colors

// Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

// Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

// Note: You are not suppose to use the library's sort function for this problem.

// Input: [2,0,2,1,1,0]
// Output: [0,0,1,1,2,2]

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
export default function sortColors(nums) {
  const counts = new Array(3);
  for (const item of nums) {
    counts[item] = counts[item] === undefined ? 1 : counts[item] + 1;
  }
  let index = 0;
  for (let i = 0; i < counts.length; i++) {
    for (let j = 0; j < counts[i]; j++) {
      nums[index] = i;
      index++;
    }
  }
  return nums;
}
```

### [78].

```js
// 78. Subsets

// Given a set of distinct integers, nums, return all possible subsets (the power set).

// Note: The solution set must not contain duplicate subsets.

// Example:

// Input: nums = [1,2,3]
// Output:
// [
//   [3],
//   [1],
//   [2],
//   [1,2,3],
//   [1,3],
//   [2,3],
//   [1,2],
//   []
// ]
const subsetsAux = (nums, prev, start, res) => {
  if (start === nums.length || start === prev.length) {
    res.push(prev);
    return res;
  }
  const remove = [];
  for (let i = 0; i < prev.length; i++) {
    if (start === i) {
      continue;
    }
    remove.push(prev[i]);
  }
  subsetsAux(nums, [...prev], start + 1, res);
  subsetsAux(nums, [...remove], start, res);
  return res;
};

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
export default function subsets(nums) {
  const res = [];
  return subsetsAux(nums, [...nums], 0, res);
}
```

### [98].

```js
// Given a binary tree, determine if it is a valid binary search tree (BST).

// Assume a BST is defined as follows:

// The left subtree of a node contains only nodes with keys less than the node's key.
// The right subtree of a node contains only nodes with keys greater than the node's key.
// Both the left and right subtrees must also be binary search trees.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

const binSearch = (tree, val) => {
  if (tree === null) return false;
  if (tree.val === val) return true;
  return val > tree.val ? binSearch(tree.right, val) : binSearch(tree.left, val);
};

const traverseAndValidate = (root, tree) => {
  if (tree === null || root === null) return true;
  if (!binSearch(root, tree.val)) return false;
  return traverseAndValidate(root, tree.left) && traverseAndValidate(root, tree.right);
};

export default function isValidBST(root) {
  const values = [];
  // BFS
  const queue = [];
  if (root) queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    values.push(item.val);
    if (item.left) queue.push(item.left);
    if (item.right) queue.push(item.right);
  }
  // Validate if BST has duplicates (BST does not allow duplicates)
  const set = new Set(values);
  if (set.size !== values.length) return false;
  return traverseAndValidate(root, root);
}
```
