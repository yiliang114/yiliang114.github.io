---
layout: CustomPages
title: LeetCode-合集 5
date: 2020-09-04
aside: false
draft: true
---

# SF/js-algorithms/LeetCode/Medium/64.js

```js
// Given a m x n grid filled with non-negative numbers, find a path from top left to bottom
// right which minimizes the sum of all numbers along its path.

// Note: You can only move either down or right at any point in time.

// Input:
// [
//   [1,3,1],
//   [1,5,1],
//   [4,2,1]
// ]
// Output: 7
// Explanation: Because the path 1→3→1→1→1 minimizes the sum.

// Observations:
// This is a DP problem. The shortest path of location i, j is the Min of down or right

/**
 * @param {number[][]} grid
 * @return {number}
 */

const traverse = (grid, i, j, dpTable) => {
  if (i === grid.length - 1 && j === grid[0].length - 1) return grid[i][j];
  if (i < 0 || j < 0 || i === grid.length || j === grid[0].length) return Infinity;
  if (dpTable[i][j]) return dpTable[i][j];
  const min = Math.min(traverse(grid, i + 1, j, dpTable), traverse(grid, i, j + 1, dpTable));
  const res = grid[i][j] + min;
  dpTable[i][j] = res;
  return res;
};

export default function minPathSum(grid) {
  const dpTable = new Array(grid.length);
  for (let i = 0; i < grid.length; i++) {
    dpTable[i] = [];
  }
  return traverse(grid, 0, 0, dpTable);
}
```

# SF/js-algorithms/LeetCode/Medium/74.js

```js
const binSearch = (nums, target) => {
  let lo = 0;
  let hi = nums.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] === target) return true;
    if (nums[mid] < target) lo = mid + 1;
    else hi = mid;
  }
  return nums[lo] === target;
};

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
export default function searchMatrix(matrix, target) {
  if (matrix.length === 0) return false;
  let lo = 0;
  let hi = matrix.length - 1;
  while (lo < hi) {
    // Search the middle row
    const mid = Math.floor((lo + hi) / 2);
    // If # is in range of the row then bin search row
    if (matrix[mid].length === 0) return false;
    if (matrix[mid][0] <= target && target <= matrix[mid][matrix[mid].length - 1]) {
      return binSearch(matrix[mid], target);
    }
    if (matrix[mid][0] > target) {
      // if less than range, search rows between middle row and first row
      hi = mid - 1;
    } else {
      // search rows between middle row and last row
      lo = mid + 1;
    }
    if (hi < lo) return false;
    if (lo === hi) return binSearch(matrix[lo], target);
  }
  if (lo === hi) return binSearch(matrix[lo], target);
  return false;
}
```

# SF/js-algorithms/LeetCode/Medium/75.js

```js
// 75. Sort Colors

// Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

// Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

// Note: You are not suppose to use the library's sort function for this problem.

// Input: [2,0,2,1,1,0]
// Output: [0,0,1,1,2,2]

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
export default function sortColors(nums) {
  const counts = new Array(3);
  for (const item of nums) {
    counts[item] = counts[item] === undefined ? 1 : counts[item] + 1;
  }
  let index = 0;
  for (let i = 0; i < counts.length; i++) {
    for (let j = 0; j < counts[i]; j++) {
      nums[index] = i;
      index++;
    }
  }
  return nums;
}
```

# SF/js-algorithms/LeetCode/Medium/78.js

```js
// 78. Subsets

// Given a set of distinct integers, nums, return all possible subsets (the power set).

// Note: The solution set must not contain duplicate subsets.

// Example:

// Input: nums = [1,2,3]
// Output:
// [
//   [3],
//   [1],
//   [2],
//   [1,2,3],
//   [1,3],
//   [2,3],
//   [1,2],
//   []
// ]
const subsetsAux = (nums, prev, start, res) => {
  if (start === nums.length || start === prev.length) {
    res.push(prev);
    return res;
  }
  const remove = [];
  for (let i = 0; i < prev.length; i++) {
    if (start === i) {
      continue;
    }
    remove.push(prev[i]);
  }
  subsetsAux(nums, [...prev], start + 1, res);
  subsetsAux(nums, [...remove], start, res);
  return res;
};

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
export default function subsets(nums) {
  const res = [];
  return subsetsAux(nums, [...nums], 0, res);
}
```

# SF/js-algorithms/LeetCode/Medium/912.js

```js
// 912. Sort an Array

// Given an array of integers nums, sort the array in ascending order.

// Example 1:

// Input: [5,2,3,1]
// Output: [1,2,3,5]
// Example 2:

// Input: [5,1,1,2,0,0]
// Output: [0,0,1,1,2,5]

// Note:

// 1 <= A.length <= 10000
// -50000 <= A[i] <= 50000

const merge = (left, right) => {
  const merged = [];
  let leftI = 0;
  let rightI = 0;

  while (merged.length < left.length + right.length) {
    if (leftI === left.length) {
      merged.push(right[rightI]);
      rightI++;
    } else if (rightI === right.length) {
      merged.push(left[leftI]);
      leftI++;
    } else if (left[leftI] < right[rightI]) {
      merged.push(left[leftI]);
      leftI++;
    } else {
      merged.push(right[rightI]);
      rightI++;
    }
  }

  return merged;
};

const mergeSort = arr => {
  // console.log(arr)
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
};

/**
 * @param {number[]} nums
 * @return {number[]}
 */
export default function sortArray(nums) {
  return mergeSort(nums);
}
```

# SF/js-algorithms/LeetCode/Medium/98.js

```js
// Given a binary tree, determine if it is a valid binary search tree (BST).

// Assume a BST is defined as follows:

// The left subtree of a node contains only nodes with keys less than the node's key.
// The right subtree of a node contains only nodes with keys greater than the node's key.
// Both the left and right subtrees must also be binary search trees.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

const binSearch = (tree, val) => {
  if (tree === null) return false;
  if (tree.val === val) return true;
  return val > tree.val ? binSearch(tree.right, val) : binSearch(tree.left, val);
};

const traverseAndValidate = (root, tree) => {
  if (tree === null || root === null) return true;
  if (!binSearch(root, tree.val)) return false;
  return traverseAndValidate(root, tree.left) && traverseAndValidate(root, tree.right);
};

export default function isValidBST(root) {
  const values = [];
  // BFS
  const queue = [];
  if (root) queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    values.push(item.val);
    if (item.left) queue.push(item.left);
    if (item.right) queue.push(item.right);
  }
  // Validate if BST has duplicates (BST does not allow duplicates)
  const set = new Set(values);
  if (set.size !== values.length) return false;
  return traverseAndValidate(root, root);
}
```

# SF/js-algorithms/LeetCode/Medium/987.js

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

const verticalTraversalAux = (root, map, mat) => {
  if (!root) return;
  const queue = [];
  queue.push([root, 0]);
  while (queue.length) {
    const [node, x] = queue.shift();
    if (map.has(x)) {
      const a = map.get(x);
      a.push(node.val);
    } else {
      map.set(x, [node.val]);
    }
    if (node.left) queue.push([node.left, x - 1]);
    if (node.right) queue.push([node.right, x + 1]);
  }
};

/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
const verticalTraversal = function(root) {
  const map = new Map();
  const mat = new Array().fill(new Array());
  verticalTraversalAux(root, map, mat);
  const keys = Array.from(map.keys()).sort((a, b) => a - b);
  const res = [];
  for (const key of keys) {
    res.push(map.get(key));
  }
  return res;
};
```

# SF/js-algorithms/LeetCode/globals.js

```js
/* eslint import/prefer-default-export: off */

export function ListNode(val) {
  this.val = val;
  this.next = null;
}
```

# SF/js-algorithms/LeetCode/Hard/212.js

```js
const findWordsAux = (board, trie, i, j, char, visited, ans) => {
  if (i < 0 || j < 0 || i >= board.length || j >= board[0].length) return;
  if (visited[i][j] === 1) return;
  if (!trie.has(board[i][j])) return;
  char += board[i][j];
  const child = trie.get(board[i][j]);
  if (child.has('END')) {
    ans.push(char);
  }
  visited[i][j] = 1;
  findWordsAux(board, child, i, j - 1, char, visited, ans);
  findWordsAux(board, child, i, j + 1, char, visited, ans);
  findWordsAux(board, child, i - 1, j, char, visited, ans);
  findWordsAux(board, child, i + 1, j, char, visited, ans);
  visited[i][j] = 0;
};

const createTrie = words => {
  const trie = new Map();
  for (const word of words) {
    let tmp = trie;
    for (const char of Array.from(word)) {
      if (!tmp.has(char)) {
        tmp.set(char, new Map());
      }
      tmp = tmp.get(char);
    }
    tmp.set('END', null);
  }
  return trie;
};

/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
export default function findWords(board, words) {
  // build a trie
  const trie = createTrie(words);
  const ans = [];
  const visited = [];
  for (let i = 0; i < board.length; i++) {
    visited[i] = [];
    for (let j = 0; j < board[i].length; j++) {
      visited[i][j] = 0;
    }
  }
  // Iterate over each position and call recursively
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[i].length; j++) {
      findWordsAux(board, trie, i, j, '', visited, ans);
    }
  }
  return Array.from(new Set(ans));
}
```

# SF/js-algorithms/LeetCode/Medium/102.js

```js
// 102. Binary Tree Level Order Traversal

// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

// For example:
// Given binary tree [3,9,20,null,null,15,7],

//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its level order traversal as:

// [
//   [3],
//   [9,20],
//   [15,7]
// ]

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
export default function levelOrder(root) {
  if (!root) return [];
  const queue = [];
  queue.push(root);
  const ans = [];
  const depths = new Map();
  depths.set(root, 0);
  let prev;
  let arr = [];
  while (queue.length) {
    const item = queue.shift();
    const depth = depths.get(item);
    if (!prev || (prev && depths.get(prev) !== depths.get(item))) {
      arr = [];
      ans.push(arr);
    }
    arr.push(item.val);
    if (item.left) {
      depths.set(item.left, depth + 1);
      queue.push(item.left);
    }
    if (item.right) {
      depths.set(item.right, depth + 1);
      queue.push(item.right);
    }
    prev = item;
  }
  return ans;
}
```

# SF/js-algorithms/LeetCode/Medium/11.js

```js
// Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

// Note: You may not slant the container and n is at least 2.

/**
 * @param {number[]} height
 * @return {number}
 */
export default function maxArea(height) {
  let width = height.length - 1;
  let lo = 0;
  let hi = height.length - 1;
  let max = 0;
  while (lo < hi) {
    const loVal = height[lo];
    const hiVal = height[hi];
    max = Math.max(max, width * Math.min(hiVal, loVal));
    if (loVal < hiVal) {
      lo++;
    } else {
      hi--;
    }
    width--;
  }
  return max;
}
```

# SF/js-algorithms/LeetCode/Medium/117.js

```js
// 117. Populating Next Right Pointers in Each Node II

// Given a binary tree

// struct Node {
//   int val;
//   Node *left;
//   Node *right;
//   Node *next;
// }
// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

// Initially, all next pointers are set to NULL.

/**
 * // Definition for a Node.
 * function Node(val,left,right,next) {
 *    this.val = val;
 *    this.left = left;
 *    this.right = right;
 *    this.next = next;
 * };
 */
/**
 * @param {Node} root
 * @return {Node}
 */
export default function connect(root) {
  // BFS
  if (!root) return root;
  const depth = new Map();
  // For each level of tree, point
  const queue = [];
  queue.push(root);
  depth.set(root, 0);
  let prev;
  while (queue.length) {
    const item = queue.shift();
    const d = depth.get(item);
    if (prev && d === depth.get(prev)) {
      prev.next = item;
    } else if (prev) prev.next = null;
    prev = item;
    if (item.left) {
      queue.push(item.left);
      depth.set(item.left, d + 1);
    }
    if (item.right) {
      queue.push(item.right);
      depth.set(item.right, d + 1);
    }
  }
  return root;
}
```

# SF/js-algorithms/LeetCode/Medium/142.js

```js
// 142. Linked List Cycle II

// Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

// To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

// Note: Do not modify the linked list.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function detectCycle(head) {
  let i = 0;
  const map = new Map();
  if (!head) return null;
  let curr = head;
  while (curr && curr.next) {
    map.set(curr, i);
    curr = curr.next;
    if (map.has(curr)) return curr;
    i++;
  }
  return null;
}
```

# SF/js-algorithms/LeetCode/Medium/199.js

```js
// 199. Binary Tree Right Side View

// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

// Example:

// Input: [1,2,3,null,5,null,4]
// Output: [1, 3, 4]
// Explanation:

//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

const getDepth = (node, depth, map) => {
  if (!node) return;
  map.set(node, depth);
  if (node.left) getDepth(node.left, depth + 1, map);
  if (node.right) getDepth(node.right, depth + 1, map);
};

export default function rightSideView(root) {
  // BFS from right to left
  const queue = [];
  const map = new Map();
  getDepth(root, 0, map);
  const ans = [];
  if (!root) return [];
  const set = new Set();

  queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    if (map.has(item)) {
      if (item.right) queue.push(item.right);
      if (item.left) queue.push(item.left);
      if (!set.has(map.get(item))) {
        ans.push(item.val);
        set.add(map.get(item));
      }
    }
  }
  return ans;
}
```

# SF/js-algorithms/LeetCode/Medium/2.js

```js
// 2. Add Two Numbers

// You are given two non-empty linked lists representing two non-negative integers. The digits
// are stored in reverse order and each of their nodes contain a single digit. Add the two
// numbers and return it as a linked list.

// You may assume the two numbers do not contain any leading zero, except the number 0 itself.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
import { ListNode } from '../globals';

export default function addTwoNumbers(l1, l2) {
  let carry = false;
  let ans;
  let prev;
  while (l1 || l2 || carry) {
    const val1 = (l1 && l1.val) || 0;
    const val2 = (l2 && l2.val) || 0;
    let sum = val1 + val2;
    if (carry) sum++;
    carry = sum > 9;
    const mod = sum % 10;
    if (ans) {
      prev.next = new ListNode(mod);
      prev = prev.next;
    } else {
      ans = new ListNode(mod);
      prev = ans;
    }
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }
  return ans;
}
```

# SF/js-algorithms/LeetCode/Medium/207.js

```js
// https://leetcode.com/problems/course-schedule/

// There are a total of n courses you have to take, labeled from 0 to n-1.

// Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

// Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */

const topsort = (numCourses, prereqs) => {
  const sortedOrder = [];
  // construct outdegree
  if (!prereqs.length) return true;

  const indegrees = new Array(numCourses);
  const graph = new Array(numCourses);
  for (let i = 0; i < numCourses; i++) {
    graph[i] = [];
    indegrees[i] = 0;
  }
  for (const pair of prereqs) {
    const [a, b] = pair;
    // add outdegrees
    graph[b].push(a);
    indegrees[a]++;
  }
  // Find vertices with indeg 0
  const queue = [];
  for (let i = 0; i < indegrees.length; i++) {
    if (indegrees[i] === 0) {
      queue.push(i);
    }
  }
  if (queue.length === 0) return false;
  while (queue.length) {
    const v = queue.shift();
    sortedOrder.push(v);
    for (const outgoing of graph[v]) {
      indegrees[outgoing]--;
      if (indegrees[outgoing] === 0) {
        queue.push(outgoing);
      }
    }
  }
  return sortedOrder.length === numCourses;
};

export default function canFinish(numCourses, prerequisites) {
  return topsort(numCourses, prerequisites);
}
```

# SF/js-algorithms/LeetCode/Medium/209.js

```js
// 209. Minimum Size Subarray Sum

// Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

// Example:

// Input: s = 7, nums = [2,3,1,2,4,3]
// Output: 2
// Explanation: the subarray [4,3] has the minimal length under the problem constraint.
// Follow up:
// If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).

/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
export default function minSubArrayLen(s, nums) {
  let result = Number.MAX_SAFE_INTEGER;
  let left = 0;
  let sum = 0;
  for (let i = 0; i < nums.length; i++) {
    if (result === 1) return 1;
    sum += nums[i];
    while (sum >= s) {
      result = Math.min(i - left + 1, result);
      sum -= nums[left];
      left++;
    }
  }
  return result === Number.MAX_SAFE_INTEGER ? 0 : result;
}
```

# SF/js-algorithms/LeetCode/Medium/229.js

```js
// 229. Majority Element II

// Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

// Note: The algorithm should run in linear time and in O(1) space.

// Example 1:

// Input: [3,2,3]
// Output: [3]
// Example 2:

// Input: [1,1,1,3,3,2,2,2]
// Output: [1,2]

/**
 * @param {number[]} nums
 * @return {number[]}
 */
export default function majorityElement(nums) {
  if (!nums.length) return [];
  let count1 = 0;
  let count2 = 0;
  let maj1 = null;
  let maj2 = null;
  // Find the two numbers that occur the most
  for (const num of nums) {
    if (num === maj1) {
      count1++;
    } else if (num === maj2) {
      count2++;
    } else if (count1 === 0) {
      maj1 = num;
      count1 = 1;
    } else if (count2 === 0) {
      maj2 = num;
      count2 = 1;
    } else {
      count1--;
      count2--;
    }
  }
  // Filter any of the two numbers that do not occur more than len / 3 times
  return [maj1, maj2].filter(e => {
    let i = 0;
    for (const num of nums) {
      if (num === e) {
        i++;
      }
    }
    return i > nums.length / 3;
  });
}
```

# SF/js-algorithms/LeetCode/Medium/230.js

```js
// 230. Kth Smallest Element in a BST

// Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

// Note:
// You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

// Example 1:

// Input: root = [3,1,4,null,2], k = 1
//    3
//   / \
//  1   4
//   \
//    2
// Output: 1
// Example 2:

// Input: root = [5,3,6,2,4,null,null,1], k = 3
//        5
//       / \
//      3   6
//     / \
//    2   4
//   /
//  1
// Output: 3
// Follow up:
// What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

const kthSmallestAux = (root, ans) => {
  if (!root) return;
  if (root.left) kthSmallestAux(root.left, ans);
  ans.push(root.val);
  if (root.right) kthSmallestAux(root.right, ans);
};

/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
export default function kthSmallest(root, k) {
  if (!root) return -1;
  const ans = [];
  kthSmallestAux(root, ans);
  return ans[k - 1];
}
```

# SF/js-algorithms/LeetCode/Medium/236.js

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */

const trav = (root, node, path, paths) => {
  if (root === null) return;
  path.push(root);
  if (root.val === node.val) {
    paths.push(path);
    return;
  }
  if (root.left) trav(root.left, node, [...path], paths);
  if (root.right) trav(root.right, node, [...path], paths);
};

export default function lowestCommonAncestor(root, p, q) {
  let set = new Set();
  {
    const paths = [];
    trav(root, p, [], paths);
    if (!paths.length) return -1;
    const [path] = paths;
    if (path) set = new Set(path);
  }
  const paths = [];
  trav(root, q, [], paths);
  if (!paths.length) return -1;
  const [path] = paths;
  for (const item of path) {
    if (set.has(item)) return item;
  }
}
```

# SF/js-algorithms/LeetCode/Medium/300.js

```js
// 300. Longest Increasing Subsequence

// Given an unsorted array of integers, find the length of longest increasing subsequence.

// Example:

// Input: [10,9,2,5,3,7,101,18]
// Output: 4
// Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
// Note:

// There may be more than one LIS combination, it is only necessary for you to return the length.
// Your algorithm should run in O(n2) complexity.

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function lengthOfLIS(nums) {
  const dp = new Array(nums.length).fill(1);

  // current num
  for (let i = 1; i < nums.length; i++) {
    // nums before current num
    let max = 0;
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        max = Math.max(dp[j], max);
      }
    }
    dp[i] = max + dp[i];
  }

  let max = 0;
  for (let i = 0; i < dp.length; i++) {
    if (dp[i] > max) max = dp[i];
  }

  return max;
}
```

# SF/js-algorithms/LeetCode/Medium/310.js

```js
// For an undirected graph with tree characteristics, we can choose any node
// as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.

// Format
// The graph contains n nodes which are labeled from 0 to n - 1. You will be given the
// number n and a list of undirected edges (each edge is a pair of labels).

// You can assume that no duplicate edges will appear in edges. Since all edges are
// undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

// Observations:
// The height of a graph is maximal when the tree is rooted at a leaf. Another observation
// is that the nodes in the centermost of the graph have the lowest height when chosen to
// be the root. The procedure is then to delete leaves until there are are either only one
// or two nodes left.

/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
export default function findMinHeightTrees(n, edges) {
  if (n === 2) return edges[0];
  const adj = new Array(n);
  for (let i = 0; i < n; i++) {
    adj[i] = new Set();
  }
  for (const edge of edges) {
    const [a, b] = edge;
    adj[a].add(b);
    adj[b].add(a);
  }
  const ans = new Set();
  for (let i = 0; i < n; i++) {
    ans.add(i);
  }
  // Find leaves and add them to queue
  const queue = [];
  const a = [];
  for (let i = 0; i < n; i++) {
    if (adj[i].size === 1) {
      a.push(i);
    }
  }
  queue.push(a);

  // While set has more than two nodes, remove them
  while (queue.length) {
    const nodes = queue.shift();
    const b = [];
    for (const node of nodes) {
      ans.delete(node);
      // delete the edges from the current node to other nodes
      for (const child of adj[node]) {
        adj[child].delete(node);
        adj[node].delete(child);
        if (adj[child].size === 1) {
          b.push(child);
        }
      }
    }
    if (ans.size < 3) break;
    if (b.length) queue.push(b);
  }

  return Array.from(ans);
}
```

# SF/js-algorithms/LeetCode/Medium/33.js

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const binSearch = (nums, target, n, m) => {
  if (n === m || m < n) {
    return nums[n] === target ? n : -1;
  }
  const mid = Math.floor((n + m) / 2);
  if (target === nums[mid]) return mid;
  // console.log(n, m, mid)
  if (target > nums[mid]) {
    return binSearch(nums, target, mid + 1, m);
  }
  return binSearch(nums, target, n, mid - 1);
};

export default function search(nums, target) {
  if (nums.length === 0) return -1;
  if (nums.length === 1) return nums[0] === target ? 0 : -1;

  let low = 0;
  let high = nums.length - 1;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (nums[mid] > nums[high]) low += 1;
    else high = mid;
  }

  const minIndex = low;
  const maxIndex = low - 1;

  if (nums[0] < nums[nums.length - 1]) {
    return binSearch(nums, target, 0, nums.length - 1);
  }

  if (target > nums[0]) {
    return binSearch(nums, target, 1, maxIndex);
  }
  if (target < nums[0]) {
    return binSearch(nums, target, minIndex, nums.length - 1);
  }
  return 0;
}
```

# SF/js-algorithms/LeetCode/Medium/34.js

```js
// 34. Find First and Last Position of Element in Sorted Array

// Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

// Your algorithm's runtime complexity must be in the order of O(log n).

// If the target is not found in the array, return [-1, -1].

// Input: nums = [5,7,7,8,8,10], target = 8
// Output: [3,4]

// Input: nums = [5,7,7,8,8,10], target = 6
// Output: [-1,-1]

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

const binSearch = (nums, lo, hi, target, left) => {
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (left) {
      if (nums[lo] === target) return lo;
      if (hi - lo === 1) return hi;
      if (nums[mid] < target) lo = mid;
      else hi = mid;
    } else {
      if (nums[hi] === target) return hi;
      if (hi - lo === 1) return lo;
      if (nums[mid] > target) hi = mid;
      else lo = mid;
    }
  }
};

export default function searchRange(nums, target) {
  if (nums.length === 0) return [-1, -1];
  // bin search for target.
  let lo = 0;
  let hi = nums.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] < target) lo = mid + 1;
    else hi = mid;
  }
  if (nums[lo] !== target) return [-1, -1];

  // if left and right not equal to target, we are done
  if (nums[lo - 1] !== target && nums[lo + 1] !== target) return [lo, lo];

  if (nums.length === 2) return [0, 1];

  // if left of target not equal to target, find left
  const left = nums[hi - 1] === target ? binSearch(nums, 0, lo, target, true) : hi;

  // if right of target not equal to target, find right
  const right = nums[lo + 1] === target ? binSearch(nums, hi, nums.length - 1, target, false) : lo;

  return [left, right];
}
```

# SF/js-algorithms/LeetCode/Medium/36.js

```js
// 36. Valid Sudoku

// Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

// Each row must contain the digits 1-9 without repetition.
// Each column must contain the digits 1-9 without repetition.
// Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.

/**
 * @param {character[][]} board
 * @return {boolean}
 */

const isNum = n => n !== '.';
const validateRow = (board, row) => {
  const set = new Set();
  for (let i = 0; i < board.length; i++) {
    if (isNum(board[row][i]) && set.has(board[row][i])) return false;
    set.add(board[row][i]);
  }
  return true;
};
const validateCol = (board, col) => {
  const set = new Set();
  for (let i = 0; i < board.length; i++) {
    if (isNum(board[i][col]) && set.has(board[i][col])) return false;
    set.add(board[i][col]);
  }
  return true;
};
const validateSquare = (board, i, j) => {
  const imin = i * 3;
  const imax = imin + 2;
  const jmin = j * 3;
  const jmax = jmin + 2;
  const set = new Set();
  for (let i = imin; i <= imax; i++) {
    for (let j = jmin; j <= jmax; j++) {
      if (isNum(board[i][j]) && set.has(board[i][j])) return false;
      set.add(board[i][j]);
    }
  }
  return true;
};

export default function isValidSudoku(board) {
  for (let i = 0; i < board.length; i++) {
    if (!validateRow(board, i)) return false;
  }
  for (let i = 0; i < board.length; i++) {
    if (!validateCol(board, i)) return false;
  }
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (!validateSquare(board, i, j)) return false;
    }
  }
  return true;
}
```

# SF/js-algorithms/LeetCode/Medium/380.js

```js
// Design a data structure that supports all following operations in average O(1) time.

// insert(val): Inserts an item val to the set if not already present.
// remove(val): Removes an item val from the set if present.
// getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
// Example:

// // Init an empty set.
// RandomizedSet randomSet = new RandomizedSet();

// // Inserts 1 to the set. Returns true as 1 was inserted successfully.
// randomSet.insert(1);

// // Returns false as 2 does not exist in the set.
// randomSet.remove(2);

// // Inserts 2 to the set, returns true. Set now contains [1,2].
// randomSet.insert(2);

// // getRandom should return either 1 or 2 randomly.
// randomSet.getRandom();

// // Removes 1 from the set, returns true. Set now contains [2].
// randomSet.remove(1);

// // 2 was already in the set, so return false.
// randomSet.insert(2);

// // Since 2 is the only number in the set, getRandom always return 2.
// randomSet.getRandom();

// Observations:
// use an array for order
// keep track of array indicies mapping to set key
//
// remove:
//   swap with last element, then delete
//   then delete from mappings
// insert:
//   add to end of array
//   then add to mappings
// getRandom:
//   get random array element from array and return

/**
 * Initialize your data structure here.
 */
export default class RandomizedSet {
  constructor() {
    this.set = new Set();
    this.mappings = new Map();
    this.randomArray = [];
    this.last = -1;
  }

  /**
   * Inserts a value to the set. Returns true if the set did not already contain the specified element.
   * @param {number} val
   * @return {boolean}
   */
  insert(val) {
    if (this.set.has(val)) return false;
    this.set.add(val);
    this.last++;
    this.randomArray[this.last] = val;
    this.mappings.set(val, this.last);
    return true;
  }

  /**
   * Removes a value from the set. Returns true if the set contained the specified element.
   * @param {number} val
   * @return {boolean}
   */
  remove(val) {
    if (!this.set.has(val)) return false;
    this.set.delete(val);
    const itemIndex = this.mappings.get(val);
    const last = this.randomArray[this.last];
    this.randomArray[this.last] = undefined;
    this.randomArray[itemIndex] = last;
    this.mappings.set(last, itemIndex);
    this.mappings.delete(val);
    this.last--;
    return true;
  }

  /**
   * Get a random element from the set.
   * @return {number}
   */
  getRandom() {
    const index = Math.floor(Math.random() * (this.last + 1));
    return this.randomArray[index];
  }
}
```

# SF/js-algorithms/LeetCode/Medium/394.js

```js
/**
 * Given an encoded string, return it's decoded string.
 * The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets
 * is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
 * You may assume that the input string is always valid; No extra white spaces, square
 * brackets are well-formed, etc.
 * Furthermore, you may assume that the original data does not contain any digits and
 * that digits are only for those repeat numbers, k. For example, there won't be input
 * like 3a or 2[4].
 *
 * Examples:
 * s = "3[a]2[bc]", return "aaabcbc".
 * s = "3[a2[c]]", return "accaccacc".
 * s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
 *
 * Approach:
 * We see that brackets can be nested, so from this, we can deduce that the algorithm can probably
 * be solved recursively
 *
 * We need to expand the mostly deeply nested, or innermost, strings first. Maybe we can add them
 * to a stack. The top-most elements would be the innermost strings:
 *
 * Example: "3[a2[c]]"
 *
 *   "3[a2[c]]"
 *    "a2[c]"
 *     "2[c]"
 *      "c"
 *     "cc"
 *     "acc"
 *   "accaccacc"
 *
 * @flow
 */
function joinNTimes(string: string, n: number): string {
  return new Array(n + 1).join(string);
}

export default function DecodeString(string: string, continuingString: string = ''): string {
  const chars = Array.from(string);

  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];

    if (!Number.isNaN(parseInt(char))) {
      // console.log(continuingString);
      continuingString += joinNTimes(DecodeString(chars.slice(i + 2, chars.length - 1)), parseInt(char));
    }

    if (char === ']') {
      return continuingString;
    }

    if (char !== '[' && char !== ']') {
      continuingString += char;
    }
  }

  return continuingString;
}

console.log(DecodeString('3[a]2[bc]'));
// console.log(DecodeString('3[a2[c]]'));
```

# SF/js-algorithms/LeetCode/Medium/457.js

```js
// You are given an array of positive and negative integers. If a number n at
// an index is positive, then move forward n steps. Conversely, if it's
// negative (-n), move backward n steps. Assume the first element of the array
// is forward next to the last element, and the last element is backward next
// to the first element. Determine if there is a loop in this array. A loop
// starts and ends at a particular index with more than 1 element along the
// loop. The loop must be "forward" or "backward'.
//
// Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -> 2 -> 3 -> 0.
//
// Example 2: Given the array [-1, 2], there is no loop.
//
// Note: The given array is guaranteed to contain no element "0".
//
// Can you do it in O(n) time complexity and O(1) space complexity?
//

import { expect } from 'chai';

function CircularArrayLoop(nums: number[]): boolean {
  const _nums = new Set();
  let ended = false;
  let index = 0;

  while (!ended) {
    if (!_nums.has(index)) {
      _nums.add(index);
    } else {
      ended = false;
    }

    index += nums[index];
  }

  return false;
}

test('CircularArrayLoop()', () => {
  expect(CircularArrayLoop([2, -1, 1, 2, 2])).instanceOf(Array);
});
```

# SF/js-algorithms/LeetCode/Medium/515.js

```js
// 515. Find Largest Value in Each Tree Row

// You need to find the largest value in each row of a binary tree.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
const largestValuesAux = (root, depth, map) => {
  // DFS
  if (!root) return;
  if (Number.isInteger(map[depth])) {
    if (map[depth] < root.val) {
      map[depth] = root.val;
    }
  } else {
    map[depth] = root.val;
  }
  if (root.left) largestValuesAux(root.left, depth + 1, map);
  if (root.right) largestValuesAux(root.right, depth + 1, map);
};

/**
 * @param {TreeNode} root
 * @return {number[]}
 */
export default function largestValues(root) {
  const map = [];
  largestValuesAux(root, 0, map);
  return map;
}
```

# SF/js-algorithms/LeetCode/Medium/56.js

```js
// 56. Merge Intervals

// Given a collection of intervals, merge all overlapping intervals.

// Example 1:

// Input: [[1,3],[2,6],[8,10],[15,18]]
// Output: [[1,6],[8,10],[15,18]]
// Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
// Example 2:

// Input: [[1,4],[4,5]]
// Output: [[1,5]]
// Explanation: Intervals [1,4] and [4,5] are considered overlapping.

/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
export default function merge(intervals) {
  if (intervals.length === 0) return [];
  if (intervals.length === 1) return intervals;
  intervals = intervals.sort((a, b) => {
    if (a[0] !== b[0]) return a[0] - b[0];
    return a[1] - b[1];
  });
  let start = intervals[0][0];
  let end = intervals[0][1];
  const ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    const left = intervals[i];
    const right = intervals[i + 1];
    if (right[0] <= end && right[1] >= end) {
      end = right[1]; // then overlap
    } else if (right[0] > end) {
      ans.push([start, end]);
      start = right[0];
      end = right[1];
    }
    if (i === intervals.length - 2) ans.push([start, end]);
  }
  return ans;
}
```

# SF/js-algorithms/LeetCode/Medium/583.js

```js
// Given two words word1 and word2, find the minimum number of steps required
// to make word1 and word2 the same, where in each step you can delete one
// character in either string.

// Example:
// Input: "sea", "eat"
// Output: 2
// Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".

// Note:
// The length of given words won't exceed 500.
// Characters in given words can only be lower-case letters.

/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */

/**
 * Longest common subsequence
 */
const LCS = (a, b, n, m, mat) => {
  if (n < 0 || m < 0) return 0;
  if (mat[n][m] !== undefined) return mat[n][m];

  let res;
  if (a[n] === b[m]) {
    res = 1 + LCS(a, b, n - 1, m - 1, mat);
  } else {
    res = Math.max(LCS(a, b, n - 1, m, mat), LCS(a, b, n, m - 1, mat));
  }

  mat[n][m] = res;

  return res;
};

export default function minDistance(word1, word2) {
  // Initialize DP table
  const mat = Array.from(Array(word1.length), () => new Array(word2.length));
  const lcsLength = LCS(word1, word2, word1.length - 1, word2.length - 1, mat);
  return word1.length - lcsLength + word2.length - lcsLength;
}
```

# SF/js-algorithms/LeetCode/Medium/61.js

```js
// 61. Rotate List

// Given a linked list, rotate the list to the right by k places, where k is non-negative.

// Example 1:

// Input: 1->2->3->4->5->NULL, k = 2
// Output: 4->5->1->2->3->NULL
// Explanation:
// rotate 1 steps to the right: 5->1->2->3->4->NULL
// rotate 2 steps to the right: 4->5->1->2->3->NULL
// Example 2:

// Input: 0->1->2->NULL, k = 4
// Output: 2->0->1->NULL
// Explanation:
// rotate 1 steps to the right: 2->0->1->NULL
// rotate 2 steps to the right: 1->2->0->NULL
// rotate 3 steps to the right: 0->1->2->NULL
// rotate 4 steps to the right: 2->0->1->NULL

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
export default function rotateRight(head, k) {
  let len = 0;
  let curr = head;
  let tail = curr;
  while (curr !== null) {
    tail = curr;
    curr = curr.next;
    len++;
  }
  k %= len;
  if (len <= 1 || k === 0) return head;
  curr = head;
  for (let i = 0; i < len - k - 1; i++) {
    curr = curr.next;
  }
  const nextHead = curr.next;
  tail.next = head;
  head = nextHead;
  curr.next = null;
  return head;
}
```

## 例题分析

LeetCode 第 212 题：给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。

![](http://s0.lgstatic.com/i/image2/M01/90/B0/CgoB5l2ILXyAYLwPAAAO6ajgsHk324.png)

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

说明：你可以假设所有输入都由小写字母 `a-z` 组成。

### 解题思路

这是一道出现较为频繁的难题，题目给出了一个二维的字符矩阵，然后还给出了一个字典，现在要求在这个字符矩阵中找到出现在字典里的单词。

由于字符矩阵的每个点都能作为一个字符串的开头，所以必须得尝试从矩阵中的所有字符出发，上下左右一步步地走，然后去和字典进行匹配，如果发现那些经过的字符能组成字典里的单词，就把它记录下来。

可以借用深度优先的算法来实现(关于深度优先算法，将在第 06 节课深入探讨)，如果你对它不熟悉，可以把它想象成走迷宫。

![](http://s0.lgstatic.com/i/image2/M01/90/CD/CgoB5l2IShaAfIDFAAElACD4d7I232.png)

**字典匹配的解法 1**：每次都循环遍历字典，看看是否存在字典里面，如果把输入的字典变为哈希集合的话，似乎只需要 O(1) 的时间就能完成匹配。

但是，这样并不能进行前缀的对比，即，必须每次都要进行一次全面的深度优先搜索，或者搜索的长度为字典里最长的字符串长度，这样还是不够高效。

**字典匹配的解法 2**：对比字符串的前缀，借助前缀树来重新构建字典。

假如在矩阵里遇到了一个字符”V”，而字典里根本就没有以“V”开头的字符串，则不需要将深度优先搜索进行下去，可以大大地提高搜索效率。

构建好了前缀树之后，每次从矩阵里的某个字符出发进行搜索的时候，同步地对前缀树进行对比，如果发现字符一直能被找到，就继续进行下去，一步一步地匹配，直到在前缀树里发现一个完整的字符串，把它输出即可。

#### 线段树(Segment Tree)

**举例**：假设有一个数组 array\[0 … n\-1\]， 里面有 n 个元素，现在要经常对这个数组做两件事。

1.  更新数组元素的数值

2.  求数组任意一段区间里元素的总和(或者平均值)

**解法 1**：遍历一遍数组。

- 时间复杂度 O(n)。

**解法 2**：线段树。

- 线段树，就是一种按照二叉树的形式存储数据的结构，每个节点保存的都是数组里某一段的总和。

- 适用于数据很多，而且需要频繁更新并求和的操作。

- 时间复杂度 O(logn)。

#### 实现

**举例**：数组是 \[1, 3, 5, 7, 9, 11\]，那么它的线段树如下。

       ![](http://s0.lgstatic.com/i/image2/M01/90/D0/CgotOV2ILX2AB5E_AABPrKDb2WM573.png)

根节点保存的是从下标 0 到下标 5 的所有元素的总和，即 36。左右两个子节点分别保存左右两半元素的总和。按照这样的逻辑不断地切分下去，最终的叶子节点保存的就是每个元素的数值。

**解法**：

1\. 更新数组里某个元素的数值

从线段树的根节点出发，更新节点的数值，它保存的是数组元素的总和。修改的元素有可能会落在线段树里一些区间里，至少叶子节点是肯定需要更新的，所以，要做的是从根节点往下，判断元素的下标是否在左边还是右边，然后更新分支里的节点大小。因此，复杂度就是遍历树的高度，即 O(logn)。

2\. 对数组某个区间段里的元素进行求和

方法和更新操作类似，首先从根节点出发，判断所求的区间是否落在节点所代表的区间中。如果所要求的区间完全包含了节点所代表的区间，那么就得加上该节点的数值，意味着该节点所记录的区间总和只是所要求解总和的一部分。接下来，不断地往下寻找其他的子区间，最终得出所要求的总和。

**建议**：线段树的实现书写起来有些繁琐，需要不断地练习。

#### 例题分析

###### LeetCode 第 315 题：给定一个整数数组 nums，按要求返回一个新数组 counts，使得数组 counts 有该性质——counts\[i\] 的值是 nums\[i\] 右侧小于 nums\[i\] 的元素的数量。

**示例**

输入：\[5, 2, 6, 1\]

输出：\[2, 1, 1, 0\]

**解释**

5 的右侧有 2 个更小的元素(2 和 1)

2 的右侧仅有 1 个更小的元素(1)

6 的右侧有 1 个更小的元素(1)

1 的右侧有 0 个更小的元素

### 解题思路

给定一个数组 nums，里面都是一些整数，现在要求打印输出一个新的数组 counts，counts 数组的每个元素 counts\[i\] 表示 nums 中第 i 个元素右边有多少个数小于 nums\[i\]。

例如，输入数组是 \[5, 2, 6, 1\]，应该输出的结果是 \[2, 1, 1, 0\]。

因为，对于 5，右边有两个数比它小，分别是 2 和 1，所以输出的结果中，第一个元素是 2；对于 2，右边只有 1 比它小，所以第二个元素是 1，类推。

如果使用线段树解法，需要理清线段树的每个节点应该需要包含什么样的信息。

线段树每个节点记录的区间是数组下标所形成的区间，然而对于这道题，因为要统计的是比某个数还要小的数的总和，如果把分段的区间设计成按照数值的大小来划分，并记录下在这个区间中的数的总和，就能快速地知道比当前数还要小的数有多少个。

![](http://s0.lgstatic.com/i/image2/M01/90/ED/CgotOV2IStmAJxNFAHcB4XzkqCg286.gif)

1\. 首先，让从线段树的根节点开始，根节点记录的是数组里最小值到最大值之间的所有元素的总和，然后分割根节点成左区间和右区间，不断地分割下去。

2\. 初始化，每个节点记录的在此区间内的元素数量是 0，接下来从数组的最后一位开始往前遍历，每次遍历，判断这个数落在哪个区间，那么那个区间的数量加一。

3\. 遇到 1，把它加入到线段树里，此时线段树里各个节点所统计的数量会发生变化。

4\. 当前所遇到的最小值就是 1。

5. 把 6 加入到线段树里。

6\. 求比 6 小的数有多少个，即查询线段树，从 1 到 5 之间有多少个数。

7\. 从根节点开始查询。由于所要查询的区间是 1 到 5，无法包含根节点的区间 1 到 6，所以继续往下查询。

8\. 左边，区间 1 到 3 被完全包含在 1 到 5 之间，把该节点所统计好的数返回。

9\. 右边，区间 1 到 5 跟区间 4 到 6 有交叉，继续往下看，区间 4 到 5 完全被包含在 1 到 5 之间，所以可以马上返回，并把统计的数量相加。

10\. 最后得出，在当前位置，在 6 的右边比 6 小的数只有一个。

通过这样的方法，每次把当前的数用线段树进行个数统计，然后再计算出比它小的数即可。算法复杂度是 O(nlogm)。

#### 树状数组(Fenwick Tree / Binary Indexed Tree)

#### 实现

**举例**：假设有一个数组 array\[0 … n\-1\]， 里面有 n 个元素，现在要经常对这个数组做两件事。

1.  更新数组元素的数值

2.  求数组前 k 个元素的总和(或者平均值)

**解法 1**：线段树。

- 线段树能在 O(logn) 的时间里更新和求解前 k 个元素的总和。

**解法 2**：树状数组。

- 该问题只要求求解前 k 个元素的总和，并不要求任意一个区间。

- 树状数组可以在 O(logn) 的时间里完成上述的操作。

- 相对于线段树的实现，树状数组显得更简单。

#### 特点

树状数组的数据结构有以下几个重要的基本特征。

1.  它是利用数组来表示多叉树的结构，在这一点上和优先队列有些类似，只不过，优先队列是用数组来表示完全二叉树，而树状数组是多叉树。

2.  树状数组的第一个元素是空节点。

3.  如果节点 tree\[y\] 是 tree\[x\] 的父节点，那么需要满足条件：y = x \- (x & (\-x))。

**建议**：由于树状数组所解决的问题跟线段树有些类似，所以不花篇幅进行问题的讨论。LeetCode 上有很多经典的题目可以用树状数组来解决，比如 LeetCode 第 308 题，求一个动态变化的二维矩阵里，任意子矩阵里的数的总和。

#### 总结

这节课讲解了一些高级的数据结构。

1\. 优先队列

经常出现在考题里的，它的实现过程比较繁琐，但是很多编程语言里都有它的实现，所以在解决面试中的问题时，实行“拿来主义”即可。

鼓励你自己练习实现一个优先队列，在实现它的过程中更好地去了解它的结构和特点。

2\. 图

被广泛运用的数据结构，很多涉及大数据的问题都得运用到图论的知识。

比如在社交网络里，每个人可以用图的顶点表示，人与人直接的关系可以用图的边表示；再比如，在地图上，要求解从起始点到目的地，如何行驶会更快捷，需要运用图论里的最短路径算法。

3\. 前缀树

出现在许多面试的难题当中。

因为很多时候你得自己实现一棵前缀树，所以你要能熟练地书写它的实现以及运用它。

4\. 线段树和树状数组

应用场合比较明确。

例如，问题变为在一幅图片当中修改像素的颜色，然后求解任意矩形区间的灰度平均值，那么可以考虑采用二维的线段树了。

**建议**：LeetCode 平台上，针对上面的这些高级数据结构都有丰富的题目，希望你能用功学习。

下节课的主题是“面试中常用的算法”。
