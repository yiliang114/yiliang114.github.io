---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

# SF/leetcode/js-leetcode/code/array/lesson2.js

```js
export default arr => {
  // 对这副牌进行排序，升序、降序都可以
  arr.sort((a, b) => a - b);
  let min = Number.MAX_SAFE_INTEGER;
  let dst = [];
  let result = true;
  for (let i = 0, len = arr.length, tmp = []; i < len; i++) {
    tmp.push(arr[i]);
    for (let j = i + 1; j < len - 1; j++) {
      if (arr[i] === arr[j]) {
        tmp.push(arr[j]);
      } else {
        if (min > tmp.length) {
          min = tmp.length;
        }
        dst.push([].concat(tmp));
        tmp.length = 0;
        i = j;
        break;
      }
    }
  }
  dst.every(item => {
    if (item.length % min !== 0) {
      result = false;
      return false;
    }
  });
  return result;
};
```

# SF/leetcode/js-leetcode/code/array/lesson3.js

```js
export default (arr, n) => {
  // 计数器
  let max = 0;
  for (let i = 0, len = arr.length - 1; i < len; i++) {
    if (arr[i] === 0) {
      if (i === 0 && arr[1] === 0) {
        max++;
        i++;
      } else if (arr[i - 1] === 0 && arr[i + 1] === 0) {
        max++;
        i++;
      }
    }
  }
  return max >= n;
};
```

# SF/leetcode/js-leetcode/code/array/lesson4.js

```js
export default n => {
  // 递归函数，用来算输入为n的格雷编码序列
  let make = n => {
    if (n === 1) {
      return ['0', '1'];
    } else {
      let prev = make(n - 1);
      let result = [];
      let max = Math.pow(2, n) - 1;
      for (let i = 0, len = prev.length; i < len; i++) {
        result[i] = `0${prev[i]}`;
        result[max - i] = `1${prev[i]}`;
      }
      return result;
    }
  };
  return make(n);
};
```

# SF/leetcode/js-leetcode/code/recur/lesson1.js

```js
export default str => {
  // 保存所有符合条件的IP地址
  let r = [];
  // 分四步递归处理ip分段
  let search = (cur, sub) => {
    // 边界条件
    if (cur.length === 4 && cur.join('') === str) {
      r.push(cur.join('.'));
    } else {
      // 正常的处理过程
      for (let i = 0, len = Math.min(3, sub.length), tmp; i < len; i++) {
        tmp = sub.substr(0, i + 1);
        if (tmp < 256) {
          search(cur.concat([tmp]), sub.substr(i + 1));
        }
      }
    }
  };
  search([], str);
  return r;
};
```

# SF/leetcode/js-leetcode/code/recur/lesson2.js

```js
export default (str, words) => {
  // 保存结果
  let result = [];
  // 记录数组的长度，做边界条件计算
  let num = words.length;
  // 递归函数体
  let range = (r, _arr) => {
    if (r.length === num) {
      result.push(r);
    } else {
      _arr.forEach((item, idx) => {
        let tmp = [].concat(_arr);
        tmp.splice(idx, 1);
        range(r.concat(item), tmp);
      });
    }
  };
  range([], words);
  // [0, 9, -1] filter 之后[0,9]
  return result
    .map(item => {
      return str.indexOf(item.join(''));
    })
    .filter(item => item !== -1)
    .sort();
};
```

# SF/leetcode/js-leetcode/code/regexp/lesson2.js

```js
export default (str, mode) => {
  // 对模式变量进行正则筛选
  let modeArr = mode.match(/([a-z.]\*)|([a-z]+(?=([a-z.]\*)|$))/g);
  let cur = 0;
  let strLen = str.length;
  for (let i = 0, len = modeArr.length, m; i < len; i++) {
    // 对于模式分为三类，.*|a*|cdef
    m = modeArr[i].split('');
    // 如果第二位是*表示是有模式的
    if (m[1] === '*') {
      if (m[0] === '.') {
        cur = strLen;
        break;
      } else {
        while (str[cur] === m[0]) {
          cur++;
        }
      }
    } else {
      for (let j = 0, jl = m.length; j < jl; j++) {
        if (m[j] !== str[cur]) {
          return false;
        } else {
          cur++;
        }
      }
    }
  }
  return cur === strLen;
};
```

# SF/leetcode/js-leetcode/code/string/lesson1.js

```js
// export default (str) => {
//   // 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
//   let arr = str.split(' ')
//   // 对数组进行遍历，然后每个元素进行反转
//   let result = arr.map(item => {
//     return item.split('').reverse().join('')
//   })
//   return result.join(' ')
// }

// export default (str) => {
//   // 1. 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
//   // 2. 对数组进行遍历，然后每个元素进行反转
//   return str.split(' ').map(item => {
//     return item.split('').reverse().join('')
//   }).join(' ')
// }

// export default (str) => {
//   // 1. 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
//   // 2. 对数组进行遍历，然后每个元素进行反转
//   return str.split(/\s/g).map(item => {
//     return item.split('').reverse().join('')
//   }).join(' ')
// }

export default str => {
  // 1. 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
  // 2. 对数组进行遍历，然后每个元素进行反转
  return str
    .match(/[\w']+/g)
    .map(item => {
      return item
        .split('')
        .reverse()
        .join('');
    })
    .join(' ');
};
```

# SF/leetcode/js-leetcode/code/string/lesson2.js

```js
export default str => {
  // 建立数据结构，堆栈，保存数据
  let r = [];
  // 给定任意子输入都返回第一个符合条件的子串
  let match = str => {
    let j = str.match(/^(0+|1+)/)[0];
    let o = (j[0] ^ 1).toString().repeat(j.length);
    let reg = new RegExp(`^(${j}${o})`);
    if (reg.test(str)) {
      return RegExp.$1;
    } else {
      return '';
    }
  };
  // 通过for循环控制程序运行的流程
  for (let i = 0, len = str.length - 1; i < len; i++) {
    let sub = match(str.slice(i));
    if (sub) {
      r.push(sub);
    }
  }
  return r;
};
```

# SF/leetcode/js-leetcode/done/duplicateZeros.js

```js
/**
 * @param {number[]} arr
 * @return {void} Do not return anything, modify arr in-place instead.
 */
var duplicateZeros = function(arr) {
  const indexArr = [],
    length = arr.length;
  arr.map((elm, index) => {
    if (elm === 0) {
      indexArr.push(index);
    }
  });
  indexArr.forEach((elm, index) => {
    arr.splice(elm + index, 0, 0);
  });
  arr.splice(length, arr.length - length);
};

duplicateZeros([1, 0, 2, 3, 0, 4, 5, 0]);
```

# SF/leetcode/js-leetcode/done/remove-element.js

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
  let index = nums.indexOf(val);
  while (index > -1) {
    nums.splice(index, 1);
    index = nums.indexOf(val);
  }
  return nums.length;
};

const nums = [3, 2, 2, 3];
const nums1 = [0, 1, 2, 2, 3, 0, 4, 2];
console.log('result', removeElement(nums, 3));
console.log('result1', removeElement(nums1, 2));
```

# SF/leetcode/js-leetcode/done/search-insert-position.js

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  let index = nums.indexOf(target);
  if (index === -1) {
    const newNums = [...nums, target].sort(function(a, b) {
      if (a < b) return -1;
      else if (a > b) return 1;
      else return 0;
    });
    index = newNums.indexOf(target);
  }
  return index;
};
```

# SF/leetcode/js-leetcode/plus-one.js

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  return (parseInt(digits.join('')) + 1 + '').split('').map(elm => parseInt(elm));
};

const nums = [6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3];
console.log('result', plusOne(nums));
```

# SF/leetcode/js-leetcode/remove-duplicates-from-sorted-array.js

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const map = {};
  nums.forEach((elm, index) => {
    if (elm === nums[index + 1]) {
      nums.splice(index + 1, 1);
    }
  });
  return nums;
};

const nums = [0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4];
const nums1 = [1, 1, 2];
console.log('result', removeDuplicates(nums));
console.log('result1', removeDuplicates(nums1));
```

# SF/leetcode/js-leetcode/reverse-integer.js

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  const isMinus = x < 0;
  x = isMinus ? -x : x;
  let temp = x + '',
    temp2 = Array.prototype.reverse.call(temp);
  return isMinus ? '-' + parseInt(temp2) : parseInt(temp2);
};

reverse(10);
reverse(0);
reverse(-1230);
```

# SF/leetcode/js-leetcode/two-num.js

```js
const handler = (num, target) => {
  num = num.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  const length = num.length;
  let jizhun = num[length - 1],
    res;
  for (let i = 0; i < num.length; i++) {
    if (target - num[i] <= jizhun) {
      // 最大也只能是 基准值
      jizhun = target - num[i];
      const index = num.indexOf(jizhun);
      if (index > -1) {
        res = [num[i], num[index]];
        break;
      }
    }
  }
  return res;
};

const a = [3, 2, 4],
  b = 6;
const res = handler(a, b);
console.log(res);
```
