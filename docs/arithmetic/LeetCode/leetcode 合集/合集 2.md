---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

# SF/leetcode/js-leetcode/done/duplicateZeros.js

```js
/**
 * @param {number[]} arr
 * @return {void} Do not return anything, modify arr in-place instead.
 */
var duplicateZeros = function(arr) {
  const indexArr = [],
    length = arr.length;
  arr.map((elm, index) => {
    if (elm === 0) {
      indexArr.push(index);
    }
  });
  indexArr.forEach((elm, index) => {
    arr.splice(elm + index, 0, 0);
  });
  arr.splice(length, arr.length - length);
};

duplicateZeros([1, 0, 2, 3, 0, 4, 5, 0]);
```

# SF/leetcode/js-leetcode/done/remove-element.js

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
  let index = nums.indexOf(val);
  while (index > -1) {
    nums.splice(index, 1);
    index = nums.indexOf(val);
  }
  return nums.length;
};

const nums = [3, 2, 2, 3];
const nums1 = [0, 1, 2, 2, 3, 0, 4, 2];
console.log('result', removeElement(nums, 3));
console.log('result1', removeElement(nums1, 2));
```

# SF/leetcode/js-leetcode/done/search-insert-position.js

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  let index = nums.indexOf(target);
  if (index === -1) {
    const newNums = [...nums, target].sort(function(a, b) {
      if (a < b) return -1;
      else if (a > b) return 1;
      else return 0;
    });
    index = newNums.indexOf(target);
  }
  return index;
};
```

# SF/leetcode/js-leetcode/plus-one.js

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  return (parseInt(digits.join('')) + 1 + '').split('').map(elm => parseInt(elm));
};

const nums = [6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3];
console.log('result', plusOne(nums));
```

# SF/leetcode/js-leetcode/remove-duplicates-from-sorted-array.js

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const map = {};
  nums.forEach((elm, index) => {
    if (elm === nums[index + 1]) {
      nums.splice(index + 1, 1);
    }
  });
  return nums;
};

const nums = [0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4];
const nums1 = [1, 1, 2];
console.log('result', removeDuplicates(nums));
console.log('result1', removeDuplicates(nums1));
```

# SF/leetcode/js-leetcode/reverse-integer.js

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  const isMinus = x < 0;
  x = isMinus ? -x : x;
  let temp = x + '',
    temp2 = Array.prototype.reverse.call(temp);
  return isMinus ? '-' + parseInt(temp2) : parseInt(temp2);
};

reverse(10);
reverse(0);
reverse(-1230);
```

# SF/leetcode/js-leetcode/two-num.js

```js
const handler = (num, target) => {
  num = num.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  const length = num.length;
  let jizhun = num[length - 1],
    res;
  for (let i = 0; i < num.length; i++) {
    if (target - num[i] <= jizhun) {
      // 最大也只能是 基准值
      jizhun = target - num[i];
      const index = num.indexOf(jizhun);
      if (index > -1) {
        res = [num[i], num[index]];
        break;
      }
    }
  }
  return res;
};

const a = [3, 2, 4],
  b = 6;
const res = handler(a, b);
console.log(res);
```
