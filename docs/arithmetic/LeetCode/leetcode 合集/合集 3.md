---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### 104.二叉树的最大深度

```js
/*
 * @lc app=leetcode.cn id=104 lang=javascript
 *
 * [104] 二叉树的最大深度
 *
 * 给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，
返回它的最大深度 3 。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root === null) return 0;
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

function Tree(arr) {
  const head = new TreeNode(null);
  if (arr.length === 0) return head;
  let cur = head;

  return cur;
}
```

```js
function TreeNode(val: any) {
  this.val = val;
  this.left = this.right = null;
}

export default function MaxDepth(root: TreeNode, count: number = 0): number {
  if (!root) return 0;

  const first = MaxDepth(root.left, count);
  const sec = MaxDepth(root.right, count);

  return Math.max(first, sec) + 1;
}

const t = new TreeNode(1);
const t2 = new TreeNode(2);
const t3 = new TreeNode(3);

//           t1
//         /   \
//       t2     null
//      / \
//   null  t3

t.left = t2.right = t3;

// expect(MaxDepth(t)).to.equal(2);
```

### 110.平衡二叉树

```js
//
// Given a binary tree, determine if it is height-balanced.
//
// For this problem, a height-balanced binary tree is defined as a binary tree
// in which the depth of the two subtrees of every node never differ by more
// than 1.
//
// Time Complexity: O(n)
// Space Complexity: O(n+1)

export function TreeNode(val: any) {
  this.val = val;
  this.right = null;
  this.left = this.right;
}

const isBalancedAux = node => {
  if (!node) return 0;
  const left = isBalancedAux(node.left);
  const right = isBalancedAux(node.right);
  if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1;
  return Math.max(left, right) + 1;
};

/**
 * @param {TreeNode} root
 * @return {boolean}
 */
export default function isBalanced(root) {
  if (!root) return true;
  return isBalancedAux(root) !== -1;
}
```

```js
/*
 * @lc app=leetcode.cn id=110 lang=javascript
 *
 * [110] 平衡二叉树
 * 本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。


 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let result = true; // 默认是平衡二叉树，只要找出左右子树高度大于 1 的就不是
var isBalanced = function(root) {
  if (root === null) return true;
  depthMax(root);
  return result;
};

var depthMax = function(root) {
  if (root) {
    let l = depthMax(root.left),
      r = depthMax(root.right);
    if (Math.abs(l - r) > 1) result = false;
    // +1 表示当前层的深度， 需要累加
    return Math.max(l, r) + 1;
  }
  return 0;
};

// function TreeNode(val) {
//   this.val = val;
//   this.left = this.right = null;
// }

// function Tree(arr) {
//   const t = new TreeNode(null)
//   if (arr.length === 0) return t
//   let index = 0, cur = t
//   cur.val = arr[index++]
//   while (index < arr.length) {
//     cur.left = new TreeNode(index++)
//     cur.right = new TreeNode(index++)
//     cur = cur.left
//   }
//   return t
// }

// const t = new TreeNode(null)
// console.log(isBalanced(t))

// TODO:
// ✘ Wrong Answer
// ✘ 195 / 227 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: false
// ✘ expected_answer: true
// ✘ stdout:

// ✘ Wrong Answer
// ✘ 196 / 227 cases passed(N / A)
// ✘ testcase: '[1]'
// ✘ answer: false
// ✘ expected_answer: true
// ✘ stdout:
```

### 111-Minimum-Depth-of-Binary-Tree

```js
/**
 * https://leetcode.com/problems/minimum-depth-of-binary-tree/description/
 * Difficulty:Easy
 *
 * Given a binary tree, find its minimum depth.
 * The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
 *
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
  if (!root) return 0;

  var left = minDepth(root.left);
  var right = minDepth(root.right);

  return left == 0 || right == 0 ? left + right + 1 : Math.min(left, right) + 1;
};
```

```js
const minDepthAux = (root, depth) => {
  if (!root) return Infinity;
  if (!root.left && !root.right) {
    return depth + 1;
  }
  const left = minDepthAux(root.left, depth + 1);
  const right = minDepthAux(root.right, depth + 1);
  return Math.min(left, right);
};

/**
 * @param {TreeNode} root
 * @return {number}
 */
export default function minDepth(root) {
  if (!root) return 0;
  return minDepthAux(root, 0);
}
```

### 112.path-sum 路径总和

```js
/*
 * @lc app=leetcode.cn id=112 lang=javascript
 *
 * [112] 路径总和
 * 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
  if (root === null) return false;
  if (root.left === null && root.right === null && root.val === sum) return true;
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.right);
};

// Input data:
// [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]
// 22

// Actual
// ✔ runtime: 112 ms
// ✘ answer: false
// ✔ stdout: ''

// Expected
// ✔ runtime: 40 ms
// ✔ answer: true
// ✔ stdout: ''
```

```js
var hasPathSum = function(root, sum) {
  // check
  if (root === null) return false;
  //  if it's leaf:
  if (root.left === null && root.right === null) {
    return root.val === sum;
  }
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
```

### 121-Best-Time-to-Buy-and-Sell-Stock

```js
/**
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
 * Difficulty:Easy
 *
 * Say you have an array for which the ith element is the price of a given stock on day i.
 * If you were only permitted to complete at most one transaction
 * (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
 *
 * Example 1:
 * Input: [7, 1, 5, 3, 6, 4]
 * Output: 5
 * max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
 *
 * Example 2:
 * Input: [7, 6, 4, 3, 1]
 * Output: 0
 * In this case, no transaction is done, i.e. max profit = 0.
 */

/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  if (!prices.length) return 0;
  var min = prices[0];
  var max = 0;
  for (var i = 1; i < prices.length; i++) {
    var tmp = prices[i];
    if (tmp < min) min = tmp;
    else if (tmp - min > max) max = tmp - min;
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
```

### 121.买卖股票的最佳时机

```js
/*
 * @lc app=leetcode.cn id=121 lang=javascript
 *
 * [121] 买卖股票的最佳时机
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  // 直接认为 prices length 大于 2
  let max = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    for (let j = i + 1; j < prices.length; j++) {
      const target = prices[j] - prices[i];
      if (target > max) {
        max = target;
      }
    }
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
console.log(maxProfit([1, 4, 2]));
```

### 137.single-number-ii

```js
/*
 * @lc app=leetcode id=137 lang=javascript
 *
 * [137] Single Number II
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99
 */
/**
 * @param {number[]} nums
 * @return {number}
 * O(n) 时间复杂度
 */
var singleNumber = function(nums) {
  // [1,1,1,2]
  let res = 0;
  // 前提是nums中数字都不大于2^31
  for (let i = 0; i < 32; i++) {
    let cnt = 0;
    let bit = 1 << i;
    for (let j = 0; j < nums.length; j++) {
      if (nums[j] & bit) cnt++;
    }
    if (cnt % 3 != 0) res = res | bit;
  }
  return res;
};
```

### 138-Copy-List-with-Random-Pointer

```js
/**
 * https://leetcode.com/problems/copy-list-with-random-pointer/description/
 * Difficulty:Medium
 *
 * A linked list is given such that each node contains an additional random pointer
 * which could point to any node in the list or null.
 *
 * Return a deep copy of the list.
 *
 */

// Definition for singly-linked list with a random pointer.
function RandomListNode(label) {
  this.label = label;
  this.next = this.random = null;
}

/**
 * @param {RandomListNode} head
 * @return {RandomListNode}
 */
var copyRandomList = function(head) {
  print(head);

  var p = head;
  // A->B->C
  // A->A'->B->B'->C->C'
  while (p) {
    var copy = new RandomListNode(p.label + "'");
    copy.next = p.next;
    p.next = copy;
    p = copy.next;
  }

  print(head);

  // 构造 A' B' C'.random
  p = head;
  while (p) {
    p.next.random = p.random ? p.random.next : null;
    p = p.next.next;
  }

  print(head);
  // 构造 copy
  var pp = new RandomListNode(0);
  var copy = pp;
  p = head;
  while (p) {
    pp.next = p.next;
    pp = pp.next;

    p.next = pp.next;
    p = p.next;
  }

  print(head);
  print(copy.next);

  return copy.next;
};

var a = new RandomListNode('A');
var b = new RandomListNode('B');
var c = new RandomListNode('C');

a.next = b;
b.next = c;
a.random = c;
b.random = c;
c.random = a;

function print(h) {
  var ls = [];
  var rs = [];
  while (h) {
    ls.push(h.label);
    rs.push(h.random ? h.random.label : 'nil');
    h = h.next;
  }
  console.log(ls.join('->'));
  console.log(rs.join(' '));
  console.log('-------------');
}

console.log(copyRandomList(a));
```

### 139-Word-Break

```js
/**
 * https://leetcode.com/problems/word-break/description/
 * Difficulty:Medium
 *
 * Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.
 *
 * For example, given
 * s = "leetcode",
 * dict = ["leet", "code"].
 * Return true because "leetcode" can be segmented as "leet code".
 */

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var n = s.length;

  var dp = [true];
  for (var i = 1; i < n + 1; i++) {
    for (var j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) > -1) {
        dp[i] = true;
        break;
      } else {
        dp[i] = false;
      }
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(wordBreak('leetcode', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'e']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'leetco']));
```

### 141.linked-list-cycle

```js
/*
 * @lc app=leetcode id=141 lang=javascript
 *
 * [141] Linked List Cycle
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */

//  快慢指针。 如果有环，快指针一定能追上慢指针
var hasCycle1 = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // 快指针一次移动两个
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};

// 哈希表 Set add has 来查询
// 牺牲了空间换时间
var hasCycle = function(head) {
  const set = new Set();
  let curr = head;
  set.add(curr);
  while (curr) {
    if (set.has(curr.next)) {
      return true;
    }
    set.add(curr.next);
    curr = curr.next;
  }
  return false;
};
```

### 145.二叉树的后序遍历

```js
/*
 * @lc app=leetcode.cn id=145 lang=javascript
 *
 * [145] 二叉树的后序遍历
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根
  while (root || stack.length) {
    if (root) {
      stack.push(root);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};

// 递归
// const res = []
// var postorderTraversal = function (root) {
//   if (root === null) return root
//   postorderTraversal(root.left)
//   postorderTraversal(root.right)
//   res.push(root.val)
//   return res
// };
```

### 151-Reverse-Words-in-a-String

```js
/**
 * https://leetcode.com/problems/reverse-words-in-a-string/description/
 * Difficulty:Medium
 *
 * Given an input string, reverse the string word by word.
 *
 * For example,
 * Given s = "the sky is blue",
 * return "blue is sky the".
 */

/**
 * @param {string} str
 * @returns {string}
 */
var reverseWords = function(str) {
  return str
    .split(' ')
    .filter(w => w)
    .reverse()
    .join(' ');
};
```

### 152-Maximum-Product-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-product-subarray/description/
 * Difficulty:Medium
 *
 * Find the contiguous subarray within an array (containing at least one number)
 * which has the largest product.
 *
 * For example, given the array [2,3,-2,4],
 * the contiguous subarray [2,3] has the largest product = 6.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  var a = nums[0];
  var imin = a;
  var imax = a;
  var max = a;

  for (var i = 1; i < nums.length; i++) {
    var t = nums[i];
    if (t < 0) {
      var tmp = imin;
      imin = imax;
      imax = tmp;
    }
    imax = Math.max(t, t * imax);
    imin = Math.min(t, t * imin);
    max = Math.max(max, imax);
  }

  return max;
};

console.log(maxProduct([-1]));
console.log(maxProduct([1]));
console.log(maxProduct([1, 2, 3, -4]));
console.log(maxProduct([2, 3, -2, 4]));
```

### 153.寻找旋转排序数组中的最小值

```js
/*
 * @lc app=leetcode.cn id=153 lang=javascript
 *
 * [153] 寻找旋转排序数组中的最小值
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  let l = 0,
    h = nums.length - 1;
  while (l < h) {
    let mid = l + Math.floor((h - l) / 2);
    if (nums[mid] <= nums[h]) {
      h = mid;
    } else {
      l = mid + 1;
    }
  }
  return nums[l];
};

// console.log(findMin([3, 4, 5, 1, 2]))
// console.log(findMin([4, 5, 6, 7, 0, 1, 2]))
```

### 155.最小栈

```js
/*
 * @lc app=leetcode.cn id=155 lang=javascript
 *
 * [155] 最小栈
 */
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.value = [];
  this.minIndex = -1;
  return this;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.value.push(x);
  if (this.minIndex === -1 || this.value[this.minIndex] > x) {
    // 栈顶
    this.minIndex = this.value.length - 1;
  }
  return this.value.length;
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const popValue = this.value.pop();
  this.minIndex = 0;
  for (let i = 0; i < this.value.length; i++) {
    if (this.value[i] < this.value[this.minIndex]) {
      this.minIndex = i;
    }
  }
  return popValue;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const length = this.value.length;
  return this.value[length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.value[this.minIndex];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

const minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
console.log(minStack.getMin());
console.log(minStack.pop());
console.log(minStack.top());
console.log(minStack.getMin());
```

### 160.intersection-of-two-linked-lists

```js
/*
 * @lc app=leetcode id=160 lang=javascript
 *
 * [160] Intersection of Two Linked Lists
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // 网上精妙的解法没看懂
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

### 162-Find-Peak-Element

```js
/**
 * https://leetcode.com/problems/find-peak-element/description/
 * Difficulty:Medium
 *
 * A peak element is an element that is greater than its neighbors.
 * Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
 * The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
 * You may imagine that num[-1] = num[n] = -∞.
 * For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.
 */

/**
 *
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  for (var i = 1; i < nums.length; i++) {
    if (nums[i - 1] > nums[i]) return i - 1;
  }
  return nums.length - 1;
};

// ================================================

/**
 * 二分查找
 *
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  if (nums.length <= 1) return 0;
  var l = 0;
  var h = nums.length - 1;
  while (l < h) {
    var mid = Math.floor((l + h) / 2);
    if (nums[mid] > nums[mid + 1]) h = mid;
    else l = mid + 1;
  }
  return l;
};

// ================================================

console.log(findPeakElement([3, 2, 1]), 0);
console.log(findPeakElement([1, 2, 3, 1]), 2);
console.log(findPeakElement([1, 3, 2]), 1);
```

### 164.最大间距

```js
/*
 * @lc app=leetcode.cn id=164 lang=javascript
 *
 * [164] 最大间距
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap1 = function(nums) {
  const map = {};
  // 用空间牺牲来换时间，一次遍历即可
  for (let i = 0; i < nums.length; i++) {
    map[nums[i]] = true;
  }
  // key number 类型默认会排序输出
  const keys = Object.keys(map);
  let max = 0;
  for (let i = 0; i < keys.length - 1; i++) {
    let tmp = keys[i + 1] - keys[i];
    if (max < tmp) {
      max = tmp;
    }
  }
  return max;
};

var maximumGap = function(nums) {
  let maxGap = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    // 每次应该默认基准值为最小，在剩余部分中尝试找出一个更小的数
    let minIndex = i;
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }
    // 每次循环， a[i] 位都将是未选择出的数据中的最小值
    if (minIndex !== i) {
      [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    }
    // console.log('nums: ', nums)
    if (i > 0) {
      const tmp = nums[i] - nums[i - 1];
      maxGap = tmp > maxGap ? tmp : maxGap;
      // console.log('maxGap  ==== ', maxGap)
    }
  }
  // 倒数第二个与倒数第一个值差
  const tmp = nums[nums.length - 1] - nums[nums.length - 2];
  maxGap = tmp > maxGap ? tmp : maxGap;
  return maxGap;
};

console.log(maximumGap([3, 6, 9, 1]));
console.log(maximumGap([10]));
console.log(maximumGap([1, 10000000]));

// console.log(maximumGap1([3, 6, 9, 1]))
// console.log(maximumGap1([10]))
```

### 167-Two-Sum-II-Input-array-is-sorted

```js
/**
 * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
 * Difficulty:Easy
 *
 * Given an array of integers that is already sorted in ascending order,
 * find two numbers such that they add up to a specific target number.
 * The function twoSum should return indices of the two numbers such that they add up to the target,
 * where index1 must be less than index2.
 *
 * Please note that your returned answers (both index1 and index2) are not zero-based.
 * You may assume that each input would have exactly one solution and you may not use the same element twice.
 *
 * Input: numbers=[2, 7, 11, 15], target=9
 * Output: index1=1, index2=2
 *
 */

/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
  for (var i = 0; i < numbers.length - 1; i++) {
    for (var j = i + 1; j < numbers.length; j++) {
      if (numbers[i] + numbers[j] === target) return [i + 1, j + 1];
    }
  }
};

// ==========================================

/**
 * 双指针
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  var lo = 0;
  var hi = nums.length - 1;

  while (nums[lo] + nums[hi] !== target) {
    if (nums[lo] + nums[hi] > target) hi--;
    else lo++;
  }
  return [lo + 1, hi + 1];
};

console.log(twoSum([2, 7, 11, 15], 9));
```

### 169

```js
// 169. Majority Element

// Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

// You may assume that the array is non-empty and the majority element always exist in the array.

// Example 1:

// Input: [3,2,3]
// Output: 3
// Example 2:

// Input: [2,2,1,1,1,2,2]
// Output: 2

// Time: O(n)
// Sace: O(1)

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function majorityElement(nums) {
  if (!nums.length) return 0;
  let majorityIndex = 0;
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    // If current num === majority number, count++
    if (nums[i] === nums[majorityIndex]) {
      count++;
    } else {
      count--;
    }
    // If count === 0, set to current num
    if (count === 0) {
      majorityIndex = i;
      count = 1;
    }
  }

  return nums[majorityIndex];
}
```

### 169.求众数

```js
/*
 * @lc app=leetcode.cn id=169 lang=javascript
 *
 * [169] 求众数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (nums.length === 1) return nums[0];
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > parseInt(nums.length / 2)) {
        return key;
      }
    }
    // console.log('i', i)
  }
};

// console.log(majorityElement([1]))
// console.log(majorityElement([3, 2, 3]))
// console.log(majorityElement([2, 2, 1, 1, 1, 2, 2]))
```

### 171-Excel-Sheet-Column-Number

```js
/**
 * https://leetcode.com/problems/excel-sheet-column-number/description/
 * Difficulty:Easy
 *
 * Given a column title as appear in an Excel sheet, return its corresponding column number.
 * For example:
 * A -> 1
 * B -> 2
 * C -> 3
 * ...
 * Z -> 26
 * AA -> 27
 * AB -> 28
 */

/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
  var num = 0;
  var aCode = 'A'.charCodeAt(0);
  for (var i = 0; i < s.length; i++) {
    var n = 1 + s.charCodeAt(i) - aCode;
    num = num * 26 + n;
  }
  return num;
};

console.log(titleToNumber('AA'));
```

### 189

```js
// 189. Rotate Array

// Given an array, rotate the array to the right by k steps, where k is non-negative.

// Example 1:

// Input: [1,2,3,4,5,6,7] and k = 3
// Output: [5,6,7,1,2,3,4]
// Explanation:
// rotate 1 steps to the right: [7,1,2,3,4,5,6]
// rotate 2 steps to the right: [6,7,1,2,3,4,5]
// rotate 3 steps to the right: [5,6,7,1,2,3,4]
// Example 2:

// Input: [-1,-100,3,99] and k = 2
// Output: [3,99,-1,-100]
// Explanation:
// rotate 1 steps to the right: [99,-1,-100,3]
// rotate 2 steps to the right: [3,99,-1,-100]
// Note:

// Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
// Could you do it in-place with O(1) extra space?

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */

const reverse = (arr, i, j) => {
  while (i < j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    i++;
    j--;
  }
  return arr;
};

export default function rotate(nums, k) {
  k %= nums.length;
  reverse(nums, 0, nums.length - 1);
  reverse(nums, 0, k - 1);
  return reverse(nums, k, nums.length - 1);
}
```

### 189.rotate-array

```js
/*
 * @lc app=leetcode id=189 lang=javascript
 *
 * [189] Rotate Array
 *
 * https://leetcode.com/problems/rotate-array/description/
 *
 * algorithms
 * Easy (29.07%)
 * Total Accepted:    287.3K
 * Total Submissions: 966.9K
 * Testcase Example:  '[1,2,3,4,5,6,7]\n3'
 *
 * Given an array, rotate the array to the right by k steps, where k is
 * non-negative.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,4,5,6,7] and k = 3
 * Output: [5,6,7,1,2,3,4]
 * Explanation:
 * rotate 1 steps to the right: [7,1,2,3,4,5,6]
 * rotate 2 steps to the right: [6,7,1,2,3,4,5]
 * rotate 3 steps to the right: [5,6,7,1,2,3,4]
 *
 *
 * Example 2:
 *
 *
 * Input: [-1,-100,3,99] and k = 2
 * Output: [3,99,-1,-100]
 * Explanation:
 * rotate 1 steps to the right: [99,-1,-100,3]
 * rotate 2 steps to the right: [3,99,-1,-100]
 *
 *
 * Note:
 *
 *
 * Try to come up as many solutions as you can, there are at least 3 different
 * ways to solve this problem.
 * Could you do it in-place with O(1) extra space?
 *
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  // 就像扩容一样操作
  k = k % nums.length;
  const n = nums.length;

  for (let i = nums.length - 1; i >= 0; i--) {
    nums[i + k] = nums[i];
  }

  for (let i = 0; i < k; i++) {
    nums[i] = nums[n + i];
  }
  nums.length = n;
};
```

### 189.旋转数组

```js
/*
 * @lc app=leetcode.cn id=189 lang=javascript
 *
 * [189] 旋转数组
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  if (nums.length === 0) return [];
  k %= nums.length;

  let last = nums[0];
  for (let i = 0; i < nums.length; i += 4) {
    if (i < k) {
      last = nums[i];
      nums[i] = nums[nums.length - k + i];
    } else {
      last = nums[i];
      nums[i] = nums[i - 3];
    }
  }
  nums[0] = start;

  return nums;
};

console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));
console.log(rotate([-1, -100, 3, 99], 2));
```

### 190-Reverse-Bits

```js
/**
 * https://leetcode.com/problems/reverse-bits/#/description
 * Difficulty:Easy
 *
 * Reverse bits of a given 32 bits unsigned integer.
 *
 * For example, given input 43261596 (represented in binary as 00000010100101000001111010011100),
 *
 * return 964176192 (represented in binary as 00111001011110000010100101000000).
 *
 * 00000010100101000001111010011100
 * 00111001011110000010100101000000
 */

/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
  // reverse binary str
  var str = '';
  var i = 32;
  while (i--) {
    str += n % 2;
    n = Math.floor(n / 2);
  }

  return parseInt(str, 2);
};

console.log(reverseBits(43261596) == 964176192);
```

### 191-Number-of-1-Bits

```js
/**
 *
 * https://leetcode.com/problems/number-of-1-bits/description
 * Difficulty:Easy
 *
 * Write a function that takes an unsigned integer and returns the number of ’1' bits it has
 * (also known as the Hamming weight).
 *
 * For example, the 32-bit integer ’11' has binary representation
 * 00000000000000000000000000001011, so the function should return 3.
 */

/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  var weight = 0;

  while (n > 0) {
    weight += n % 2;
    n = Math.floor(n / 2);
  }
  return weight;
};

console.log(hammingWeight(11) == 3);
console.log(hammingWeight(0) == 0);
console.log(hammingWeight(1) == 1);
```

### 191.位-1-的个数

```js
/*
 * @lc app=leetcode.cn id=191 lang=javascript
 *
 * [191] 位1的个数
 */
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight1 = function(n) {
  let count = 0;
  while (n) {
    // 直接判断二进制最低为的数是不是1
    count += n & 1;
    // 每一步都右移一位
    n >>= 1;
  }
  return count;
};

// TODO: JS 超出值范围
console.log(hammingWeight(00000000000000000000000000001011));
console.log(hammingWeight(00000000000000000000000010000000));
console.log(hammingWeight('11111111111111111111111111111101'));
```

### 198-House-Robber

```js
/**
 * https://leetcode.com/problems/house-robber/description/
 * Difficulty:Easy
 *
 * You are a professional robber planning to rob houses along a street.
 * Each house has a certain amount of money stashed,
 * the only constraint stopping you from robbing each of them is that adjacent houses have security system connected
 * and it will automatically contact the police if two adjacent houses were broken into on the same night.

 Given a list of non-negative integers representing the amount of money of each house,
 determine the maximum amount of money you can rob tonight without alerting the police.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  if (!nums.length) return 0;
  var dp = [0, nums[0]];
  var max = nums[0];
  for (var i = 1; i < nums.length; i++) {
    dp[i + 1] = Math.max(dp[i], dp[i - 1] + nums[i]);
    max = Math.max(dp[i + 1], max);
  }
  return max;
};

console.log(rob([5, 2, 3, 5, 8]));
```

### 198

```js
// 198. House Robber

// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint
// stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police
// if two adjacent houses were broken into on the same night.

// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob
// tonight without alerting the police.

// Explaination:
// https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems

const robAux = (nums, i, map) => {
  if (i >= nums.length) return 0;
  if (map.has(i)) return map.get(i);
  const a = robAux(nums, i + 1, map);
  const b = robAux(nums, i + 2, map);
  const curr = Math.max(a, b + nums[i]);
  map.set(i, curr);
  return curr;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function rob(nums) {
  const map = new Map();
  return robAux(nums, 0, map);
}
```

### 202-Happy-Number

```js
/**
 * https://leetcode.com/problems/happy-number/description/
 * Difficulty:Easy
 *
 * Write an algorithm to determine if a number is "happy".
 * A happy number is a number defined by the following process: Starting with any positive integer,
 * replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),
 * or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.
 *
 * Example: 19 is a happy number
 *
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */

/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  var results = [n];

  while (true) {
    n = squareSumOfDigits(n);
    // console.log(n);
    if (n === 1) return true;
    if (results.indexOf(n) > -1) return false;
    results.push(n);
  }
};

function squareSumOfDigits(n) {
  var sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

console.log(isHappy(1));
console.log(isHappy(19));
```

### 202.happy-number

```js
/*
 * @lc app=leetcode id=202 lang=javascript
 *
 * [202] Happy Number
 *
 * https://leetcode.com/problems/happy-number/description/
 *
 * algorithms
 * Easy (44.36%)
 * Total Accepted:    227.2K
 * Total Submissions: 505.7K
 * Testcase Example:  '19'
 *
 * Write an algorithm to determine if a number is "happy".
 *
 * A happy number is a number defined by the following process: Starting with
 * any positive integer, replace the number by the sum of the squares of its
 * digits, and repeat the process until the number equals 1 (where it will
 * stay), or it loops endlessly in a cycle which does not include 1. Those
 * numbers for which this process ends in 1 are happy numbers.
 *
 * Example:
 *
 *
 * Input: 19
 * Output: true
 * Explanation:
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */
function squareSum(n) {
  let sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

function isHappyWithMapper(n, visited) {
  if (n === 1) return true;
  if (visited[n]) return false;
  visited[n] = true;

  return isHappyWithMapper(squareSum(n), visited);
}
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  const visited = {};

  return isHappyWithMapper(n, visited);
};
```

### 203

```js
// Remove all elements from a linked list of integers that have value val.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
export default function removeElements(head, val) {
  if (head === null) return null;
  let prev = null;
  let curr = head;
  let next = null;
  let hasHead = false;
  while (curr) {
    next = curr.next;
    if (curr.val === val) {
      // delete
      curr = null;
      // join links
      if (prev) prev.next = next;
    } else {
      prev = curr;
      if (!hasHead) {
        head = curr;
        hasHead = true;
      }
    }
    curr = next;
  }
  if (!prev) head = null;
  return head;
}
```

### 204-Count-Primes

```js
/**
 * https://leetcode.com/problems/count-primes/description/
 * Difficulty:Easy
 *
 * Description:
 * Count the number of prime numbers less than a non-negative number, n.
 */

/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  if (n < 3) return 0;
  var cnt = 0;
  var p = new Array(n + 1).fill(1);
  p[1] = 0;
  for (var i = 2; i < n; i++) {
    if (p[i]) {
      cnt++;
      for (var j = i * 2; j <= n; j += i) {
        p[j] = 0;
      }
    }
  }
  // console.log(p);
  return cnt;
};

console.log(countPrimes(3));
console.log(countPrimes(4));
console.log(countPrimes(21));
console.log(countPrimes(27));
console.log(countPrimes(31));
```

### 204.count-primes

```js
/*
 * @lc app=leetcode id=204 lang=javascript
 *
 * [204] Count Primes
 *
 * https://leetcode.com/problems/count-primes/description/
 *
 * algorithms
 * Easy (28.33%)
 * Total Accepted:    229.8K
 * Total Submissions: 798.7K
 * Testcase Example:  '10'
 *
 * Count the number of prime numbers less than a non-negative number, n.
 *
 * Example:
 *
 *
 * Input: 10
 * Output: 4
 * Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
 *
 *
 */
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  // tag: 数论
  // if (n <= 2) return 0;
  // let compositionCount = 0;
  // for(let i = 3; i < n; i++) {
  //     for(let j = i - 1; j > 1 ; j--) {
  //         if (i % j === 0) {
  //             compositionCount++;
  //             break; // 找到一个就可以证明它不是质数了
  //         }
  //     }
  // }
  // return n - compositionCount - 2; // 需要减去1和n这两个数字

  // 上面的方法会超时，因此我们需要进行优化
  // 数学角度来看，如果一个数字可以分解为两个数字相乘(这两个数字不包括0和它本身)，那么它就是合数
  const compositions = []; // compositions[i] 表示i是否是合数
  let count = 0;
  for (let i = 2; i < n; i++) {
    if (!compositions[i]) count++;
    for (let j = 2; i * j < n; j++) {
      compositions[i * j] = true;
    }
  }

  return count;
};
```

### 206.反转链表

```js
/*
 * @lc app=leetcode.cn id=206 lang=javascript
 *
 * [206] 反转链表
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  const l1 = new ListNode(null);
  if (!head) return l1;

  // 收集到数组
  const result = [];
  while (head !== null) {
    result.push(head.val);
    head = head.next;
  }
  // result.push(head.val)

  // 重新创建一个链表
  let cur = l1;

  for (let i = result.length - 1; i >= 0; i--) {
    cur.next = new ListNode(result[i]);
    cur = cur.next;
  }

  return l1.next;
};

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let head = new ListNode(null);
  const guard = head;
  if (arr.length === 0) return guard;
  for (let i = 0; i < arr.length; i++) {
    let temp = new ListNode(arr[i]);
    head.next = temp;
    head = temp;
  }
  return guard.next;
}

function ListNodeToString(listNode) {
  let resp = '';
  let cur = listNode;
  while (cur.next) {
    resp += `${cur.val} -> `;
    cur = cur.next;
  }
  if (cur.val) resp += `${cur.val}`;
  console.log(resp);
}

const l1 = List([1, 2, 3]);
// ListNodeToString(l1)
const l2 = reverseList(l1);
ListNodeToString(l2);

const l3 = List([]);
ListNodeToString(l3);
const l4 = reverseList(l3);
ListNodeToString(l4);

// Wrong Answer
// ✘ 26 / 27 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: [0]
// ✘ expected_answer: []
// ✘ stdout:
```

### 215.数组中的第 k 个最大元素

```js
/*
 * @lc app=leetcode.cn id=215 lang=javascript
 *
 * [215] 数组中的第K个最大元素
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
// 最简单方法。。。
var findKthLargest = function(nums, k) {
  // nums = Array.from(new Set(nums)).sort()
  // 注意如果单纯是 nums.sort() 函数执行的话，会进行字典升序
  nums = nums.sort((a, b) => a - b);
  console.log(nums);
  return nums[nums.length - k];
};

console.log(findKthLargest([3, 2, 1, 5, 6, 4], 2));
console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4));
console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6, 7, 7, 8, 2, 3, 1, 1, 1, 10, 11, 5, 6, 2, 4, 7, 8, 5, 6], 2));
```

### 217-Contains-Duplicate

```js
/**
 * https://leetcode.com/problems/contains-duplicate/description/
 * Difficulty:Easy
 *
 * Given an array of integers, find if the array contains any duplicates.
 * Your function should return true if any value appears at least twice in the array,
 * and it should return false if every element is distinct.
 */

/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  var map = {};
  for (var i = 0; i < nums.length; i++) {
    var n = nums[i];
    if (map[n]) return true;
    map[n] = 1;
  }
  return false;
};
console.log(containsDuplicate([3, 4]));
```

### 217.contains-duplicate

```js
/*
 * @lc app=leetcode id=217 lang=javascript
 *
 * [217] Contains Duplicate
 *
 * https://leetcode.com/problems/contains-duplicate/description/
 *
 * algorithms
 * Easy (50.92%)
 * Total Accepted:    324K
 * Total Submissions: 628.5K
 * Testcase Example:  '[1,2,3,1]'
 *
 * Given an array of integers, find if the array contains any duplicates.
 *
 * Your function should return true if any value appears at least twice in the
 * array, and it should return false if every element is distinct.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,1]
 * Output: true
 *
 * Example 2:
 *
 *
 * Input: [1,2,3,4]
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: [1,1,1,3,3,4,3,2,4,2]
 * Output: true
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  // 1. 暴力两层循环两两比较， 时间复杂度O(n^2) 空间复杂度O(1)

  // 2. 先排序，之后比较前后元素是否一致即可，一层循环即可，如果排序使用的比较排序的话时间复杂度O(nlogn) 空间复杂度O(1)

  // 3. 用hashmap ，时间复杂度O(n) 空间复杂度O(n)
  const visited = {};
  for (let i = 0; i < nums.length; i++) {
    if (visited[nums[i]]) return true;
    visited[nums[i]] = true;
  }
  return false;
};
```

### 226.Invert-Binary-Tree

```js
/**
 * https://leetcode.com/problems/invert-binary-tree/description/
 * Difficulty:Easy
 *
 * Invert a binary tree.
 *      4
 *    /   \
 *   2     7
 *  / \   / \
 * 1   3 6   9
 *
 * to
 *
 *       4
 *     /   \
 *   7     2
 *  / \   / \
 * 9   6 3   1
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
  if (!root) return root;
  if (!root.left && !root.right) return root;
  var left = invertTree(root.right);
  var right = invertTree(root.left);
  root.left = left;
  root.right = right;
  return root;
};

function invertTree1(root) {
  if (!root) return root;
  const { left, right } = root;
  root.left = right;
  root.right = left;
  invertTree1(root.left);
  invertTree1(root.right);
  return root;
}

// console.log(invertTree({
//   val: 4,
//   left: {
//     val: 2,
//     left: {
//       val: 1,
//       left: null,
//       right: null,
//     },
//     right: null
//   },
//   right: null
// }));
```

### 227-Basic-Calculator-II

```js
/**
 * https://leetcode.com/problems/basic-calculator-ii/description/
 * Difficulty:Medium
 *
 * Implement a basic calculator to evaluate a simple expression string.
 * The expression string contains only non-negative integers, +, -, *, / operators and
 * empty spaces . The integer division should truncate toward zero.
 * You may assume that the given expression is always valid.
 *
 * Some examples:
 *
 * "3+2*2" = 7
 * " 3/2 " = 1
 * " 3+5 / 2 " = 5
 *
 * Note: Do not use the eval built-in library function.
 */

/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  var operand = [];
  var operator = [];
  var lastIsNum = false;

  var arr = [];
  for (var i = 0; i < s.length; i++) {
    var ch = s[i];
    if (ch === ' ') continue;

    if (['+', '-', '*', '/'].indexOf(ch) > -1) {
      arr.push(ch);
      lastIsNum = false;
    } else {
      ch = parseInt(ch);
      if (lastIsNum && arr.length) {
        var last = arr.pop();
        arr.push(last * 10 + ch);
      } else {
        arr.push(ch);
      }
      lastIsNum = true;
    }
  }

  // console.log(arr);
  for (var i = 0; i < arr.length; i++) {
    var ch = arr[i];

    if (['+', '-', '*', '/'].indexOf(ch) > -1) {
      operator.push(ch);
      continue;
    }
    if (operator.length) {
      var op = operator.pop();
      if (op === '*' || op === '/') {
        var last = operand.pop();
        if (op === '*') {
          operand.push(last * ch);
        } else {
          operand.push(Math.floor(last / ch));
        }
      } else {
        operator.push(op);
        operand.push(ch);
      }
    } else {
      operand.push(ch);
    }
  }
  // console.log(operand);
  // console.log(operator);

  var i = 1;
  var j = 0;
  var res = operand[0];
  while (i < operand.length && j < operator.length) {
    var a = operand[i++];
    var op = operator[j++];
    // console.log(a, op, b);
    if (op === '+') {
      res = res + a;
    } else {
      res = res - a;
    }
  }

  return res;
};

console.log(calculate('1/1'));
console.log(calculate('1-1+1'));
console.log(calculate('1+1-1'));
console.log(calculate('42'));
console.log(calculate('12*12'));
console.log(calculate('3+2*2'));
console.log(calculate(' 3/2 '));
console.log(calculate(' 3+5 / 2 '));
```

### 227.basic-calculator-ii

```js
/*
 * @lc app=leetcode id=227 lang=javascript
 *
 * [227] Basic Calculator II
 */
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  // "3+2*2"
};
```

### 229.求众数-ii

```js
/*
 * @lc app=leetcode.cn id=229 lang=javascript
 *
 * [229] 求众数 II
 * 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例 1:

输入: [3,2,3]
输出: [3]
示例 2:

输入: [1,1,1,3,3,2,2,2]
输出: [1,2]
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  if (nums.length === 0) return [];
  const result = [],
    targetNum = parseInt(nums.length / 3),
    map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > targetNum) {
        result.push(map[key]);
      }
    }
  }
  return result;
};

// console.log(majorityElement())
```

### 232

```js
/**
 * Initialize your data structure here.
 */
export default class StackQueue {
  constructor() {
    this.tmpStack = [];
    this.stack = [];
  }

  /**
   * Push element x to the back of queue.
   * @param {number} x
   * @return {void}
   */
  push(x) {
    this.stack.push(x);
  }

  /**
   * Removes the element from in front of queue and returns that element.
   * @return {number}
   */
  pop() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      const item = this.stack.pop();
      return item;
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const item = this.stack.pop();
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Get the front element.
   * @return {number}
   */
  peek() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      return this.stack[0];
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const [item] = this.stack;
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Returns whether the queue is empty.
   * @return {boolean}
   */
  empty() {
    return this.stack.length === 0;
  }
}

/**
 * Initialize your data structure here.
 */
class StackQueueFast {
  constructor() {
    this.tmpStack = [];
    this.stack = [];
  }

  /**
   * Push element x to the back of queue.
   * @param {number} x
   * @return {void}
   */
  push(x) {
    this.stack.push(x);
  }

  /**
   * Removes the element from in front of queue and returns that element.
   * @return {number}
   */
  pop() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      const item = this.stack.pop();
      return item;
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const item = this.stack.pop();
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Get the front element.
   * @return {number}
   */
  peek() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      return this.stack[0];
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const [item] = this.stack;
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Returns whether the queue is empty.
   * @return {boolean}
   */
  empty() {
    return this.stack.length === 0;
  }
}
```

### 232.用栈实现队列

```js
/*
 * @lc app=leetcode.cn id=232 lang=javascript
 *
 * [232] 用栈实现队列
 * 使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
示例:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
说明:

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque(双端队列)来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 (例如，一个空的队列不会调用 pop 或者 peek 操作)。
 */
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
  this.stack = [];
  this.length = 0;
};

/**
 * Push element x to the back of queue.
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
  this.stack.push(x);
  this.length++;
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
  if (this.length) {
    this.length--;
    return this.stack.shift();
  }
  return undefined;
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
  if (this.length) return this.stack[0];
  return undefined;
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
  return this.length === 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */

// const queue = new MyQueue();

// queue.push(1);
// queue.push(2);
// console.log(queue.peek()) // 返回 1
// console.log(queue.pop())  // 返回 1
// console.log(queue.empty()) // 返回 false

// ✘ Wrong Answer
// ✘ 12 / 17 cases passed(N / A)
// ✘ testcase: '["MyQueue","push","pop","empty"]\n[[],[1],[],[]]'
// ✘ answer: [null, null, 1, false]
// ✘ expected_answer: [null, null, 1, true]
// ✘ stdout:
```

### 235

```js
// 235. Lowest Common Ancestor of a Binary Search Tree

// Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

// According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

// Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

// Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
// Output: 6
// Explanation: The LCA of nodes 2 and 8 is 6.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */

const dfs = (root, p, q, path, paths) => {
  if (!root) return;
  path.push(root);
  if (root.val === p.val || root.val === q.val) paths.push([...path]);
  if (root.left) dfs(root.left, p, q, [...path], paths);
  if (root.right) dfs(root.right, p, q, [...path], paths);
};

export default function lowestCommonAncestor(root, p, q) {
  const paths = [];
  dfs(root, p, q, [], paths);
  let [a, b] = paths;
  b = new Set(b);
  a = a.reverse();
  for (let i = 0; i < a.length; i++) {
    if (b.has(a[i])) return a[i];
  }
  return -1;
}
```

### 257

```js
// See https://leetcode.com/problems/binary-tree-paths/

const getPaths = (root, paths, parent) => {
  if (root === null) return;
  // Clone
  parent = [...parent];
  // Push node value
  parent.push(root.val);
  if (root.left) getPaths(root.left, paths, parent);
  if (root.right) getPaths(root.right, paths, parent);
  if (!root.left && !root.right) paths.push(parent.join('->'));
};

const binaryTreePaths = function(root) {
  const paths = [];
  const parent = [];
  getPaths(root, paths, parent);
  return paths;
};
```

### 258-Add-Digits

```js
/**
 * https://leetcode.com/problems/add-digits/description/
 * Difficulty:Easy
 *
 * Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
 * For example:
 * Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
 * Follow up:
 * Could you do it without any loop/recursion in O(1) runtime?
 *
 */

/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {
  if (num < 10) return num;
  return addDigits(sum(num));
};

function sum(num) {
  return ('' + num).split('').reduce((a, b) => a + parseInt(b), 0);
}

console.log(addDigits(38));
```

### 263-Ugly-Number

```js
/**
 *
 * https://leetcode.com/problems/ugly-number/#/description
 * Difficulty:Easy
 *
 * Write a program to check whether a given number is an ugly number.
 *
 * Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
 *
 * For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
 *
 * Note that 1 is typically treated as an ugly number.
 */

/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
  if (num <= 0) return false;
  if (num == 1) return true;

  while (num > 1) {
    var old = num;
    if (!(num % 2)) num = num / 2;
    if (!(num % 3)) num = num / 3;
    if (!(num % 5)) num = num / 5;
    if (old === num) return false;
  }
  return true;
};

console.log(isUgly(6) === true);
console.log(isUgly(8) === true);
console.log(isUgly(14) === false);
```

### 287.find-the-duplicate-number

```js
/*
 * @lc app=leetcode id=287 lang=javascript
 *
 * [287] Find the Duplicate Number
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // Input: [1,3,4,2,2]
  // Output: 2
  // TODO: 冒泡、选择、插入是否都可以？ 不需要全部都排序完成之后就可以知道前后的值是否相等啦！
  nums.sort();

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) return nums[i];
  }
};
```

### 287.寻找重复数

```js
/*
 * @lc app=leetcode.cn id=287 lang=javascript
 *
 * [287] 寻找重复数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // 1 - n 下标
  const arr = [];
  for (let i = 0; i < nums.length; i++) {
    if (arr[nums[i]] === undefined) {
      arr[nums[i]] = true;
    } else {
      return nums[i];
    }
  }
};

console.log(findDuplicate([1, 3, 4, 2, 2]));
console.log(findDuplicate([3, 1, 3, 4, 2]));
```

### 292

```js
// You are playing the following Nim Game with your friend: There is a heap of
// stones on the table, each time one of you take turns to remove 1 to 3 stones.
//
// The one who removes the last stone will be the winner. You will take the
// first turn to remove the stones.
//
// Both of you are very clever and have optimal strategies for the game. Write
// a function to determine whether you can win the game given the number of
// stones in the heap.
//
// For example, if there are 4 stones in the heap, then you will never win the
// game: no matter 1, 2, or 3 stones you remove, the last stone will always be
// removed by your friend.
//

export default function CanWinNim(n: number): boolean {
  return (n / 4) % 1 !== 0;
}
```

### 300-Longest-Increasing-Subsequence

```js
/**
 * https://leetcode.com/problems/longest-increasing-subsequence/description/
 * Difficulty:Medium
 * Given an unsorted array of integers, find the length of longest increasing subsequence.
 * For example,
 * Given [10, 9, 2, 5, 3, 7, 101, 18],
 * The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.
 * Your algorithm should run in O(n2) complexity.
 * Follow up: Could you improve it to O(n log n) time complexity?
 *
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  var dp = [];
  for (var i = 0; i < nums.length; i++) {
    dp[i] = 1;

    var max = 0;
    for (var j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        if (dp[j] > max) {
          max = dp[j];
        }
      }
    }
    dp[i] = max + 1;
  }

  return Math.max(...dp);
};

console.log(lengthOfLIS([23, 2, 4, 5, 6]));
```

### 300.longest-increasing-subsequence

```js
/*
 * @lc app=leetcode id=300 lang=javascript
 *
 * [300] Longest Increasing Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  // 时间复杂度O(n^2)
  // if (nums.length === 0) return 0;
  //   const dp = Array(nums.length).fill(1);
  //   let max = 1;
  //   for (let i = 0; i < nums.length; i++) {
  //     for (let j = 0; j < i; j++) {
  //       if (nums[i] > nums[j]) {
  //         dp[i] = Math.max(dp[j] + 1, dp[i]);
  //       }
  //       max = Math.max(max, dp[i]);
  //     }
  //   }
  //   return max;
  // [ 10, 9, 2, 5, 3, 7, 101, 18 ]
  // [ 2, 3, 5, 7, 9, 10, 18, 101 ]
  // 参考： https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation
  // const tails = [];
  // for (let i = 0; i < nums.length; i++) {
  //   let left = 0;
  //   let right = tails.length;
  //   while (left < right) {
  //     const mid = left + (right - left) / 2; // 防止溢出
  //     if (tails[mid] < nums[i]) left = mid + 1;
  //     else right = mid;
  //   }
  //   // 说明nums[i] 比如tails中所有数字都大，我们直接push
  //   if (right === tails.length) tails.push(nums[i]);
  //   else tails[right] = nums[i]; // 否则我们修改tails[right]
  // }
  // return tails.length;
};
```

### 303.区域和检索-数组不可变

```js
/*
 * @lc app=leetcode.cn id=303 lang=javascript
 *
 * [303] 区域和检索 - 数组不可变
 */
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  if (nums.length === 0) return;
  this.sums = [nums[0]];
  for (let i = 1; i < nums.length; i++) {
    this.sums[i] = this.sums[i - 1] + nums[i];
  }
  this.nums = nums;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  if (i === j) {
    return this.nums[i];
  } else if (i < j) {
    if (i === 0) return this.sums[j];
    return this.sums[j] - this.sums[i - 1];
  }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(i,j)
 */

// var obj = new NumArray([-2, 0, 3, -5, 2, -1])
// // var param_1 = obj.sumRange(0, 2)

// console.log(obj.sums)
// console.log(obj.sumRange(1, 1))
// console.log(obj.sumRange(0, 2))
// console.log(obj.sumRange(2, 5))
// console.log(obj.sumRange(0, 5))
```

### 307.range-sum-query-mutable

```js
/*
 * @lc app=leetcode id=307 lang=javascript
 *
 * [307] Range Sum Query - Mutable
 */
/**
 * @param {number[]} nums
 */
// var NumArray = function(nums) {
//   this.nums = nums;
// };

// /**
//  * @param {number} i
//  * @param {number} val
//  * @return {void}
//  */
// NumArray.prototype.update = function(i, val) {
//   this.nums[i] = val;
// };

// /**
//  * @param {number} i
//  * @param {number} j
//  * @return {number}
//  */
// NumArray.prototype.sumRange = function(i, j) {
//   let res = 0;
//   for (let k = i; k < j + 1; k++) {
//     res += this.nums[k];
//   }

//   return res;
// };

/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  this.nums = nums;

  // Init array representation of segment tree.
  this.segmentTree = [];

  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;
  this.buildTreeRecursively(l, r, cur);
};

NumArray.prototype.buildTreeRecursively = function(l, r, cur) {
  // If low input index and high input index are equal that would mean
  // the we have finished splitting and we are already came to the leaf
  // of the segment tree. We need to copy this leaf value from input
  // array to segment tree.
  if (l === r) {
    return (this.segmentTree[cur] = this.nums[r]);
  }

  // Split input array on two halves and process them recursively.
  const m = Math.floor((l + r) / 2);
  // Process left half of the input array.
  this.buildTreeRecursively(l, m, this.getLeftChildIndex(cur));
  // Process right half of the input array.
  this.buildTreeRecursively(m + 1, r, this.getRightChildIndex(cur));

  // Once every tree leaf is not empty we're able to build tree bottom up using
  // provided operation function.
  this.segmentTree[cur] = this.operation(
    this.segmentTree[this.getLeftChildIndex(cur)],
    this.segmentTree[this.getRightChildIndex(cur)],
  );
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
  this.nums[i] = val;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;

  return this.rangeQueryRecursive(i, j, l, r, cur);
};

NumArray.prototype.rangeQueryRecursive = function(i, j, l, r, cur) {
  if (i <= l && j >= r) {
    // Total overlap.
    return this.segmentTree[cur];
  }

  if (i > r || j < l) {
    // No overlap.
    return this.operationFallback;
  }

  // Partial overlap.
  const m = Math.floor((l + r) / 2);

  const leftOperationResult = this.rangeQueryRecursive(i, j, l, m, this.getLeftChildIndex(cur));

  const rightOperationResult = this.rangeQueryRecursive(i, j, m + 1, r, this.getRightChildIndex(cur));

  return this.sumRange(leftOperationResult, rightOperationResult);
};

NumArray.prototype.getLeftChildIndex = function(parentIndex) {
  return 2 * parentIndex + 1;
};

NumArray.prototype.getRightChildIndex = function(parentIndex) {
  return 2 * parentIndex + 2;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(i,val)
 * var param_2 = obj.sumRange(i,j)
 */
```

### 315.count-of-smaller-numbers-after-self

```js
/*
 * @lc app=leetcode id=315 lang=javascript
 *
 * [315] Count of Smaller Numbers After Self
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
  // Input: [5,2,6,1]
  // Output: [2,1,1,0]
  // 暴力法：
  //   const res = Array(nums.length).fill(0);
  //   for (let i = 0; i < nums.length - 1; i++) {
  //     for (let j = i; j < nums.length; j++) {
  //       if (nums[i] > nums[j]) {
  //         res[i] += 1;
  //       }
  //     }
  //   }

  //   return res;
  //  归并排序
  const res = Array(nums.length).fill(0);

  function merge(arr, l, m, r, res) {
    let i, j, k;
    const n1 = m - l + 1;
    const n2 = r - m;

    /* create temp arrays */
    const L = Array(n1);
    const R = Array(n2);

    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) L[i] = arr[l + i];
    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
    while (i < n1 && j < n2) {
      if (L[i] <= R[j]) {
        arr[k] = L[i];
        i++;
      } else {
        arr[k] = R[j];
        res[k] += 1;
        j++;
      }
      k++;
    }

    /* Copy the remaining elements of L[], if there
       are any */
    while (i < n1) {
      arr[k] = L[i];
      i++;
      k++;
    }

    /* Copy the remaining elements of R[], if there
       are any */
    while (j < n2) {
      arr[k] = R[j];
      j++;
      k++;
    }
  }
  function mergeSort(arr, l, r, res) {
    if (l < r) {
      const m = l + ((r - l) >> 1);

      mergeSort(arr, l, m, res);
      mergeSort(arr, m + 1, r, res);

      merge(arr, l, m, r, res);
    }
    return res;
  }

  return mergeSort(nums, 0, nums.length - 1, res);
};
```

### 326.power-of-three

```js
/*
 * @lc app=leetcode id=326 lang=javascript
 *
 * [326] Power of Three
 *
 * https://leetcode.com/problems/power-of-three/description/
 *
 * algorithms
 * Easy (41.43%)
 * Total Accepted:    178.8K
 * Total Submissions: 430.4K
 * Testcase Example:  '27'
 *
 * Given an integer, write a function to determine if it is a power of three.
 *
 * Example 1:
 *
 *
 * Input: 27
 * Output: true
 *
 *
 * Example 2:
 *
 *
 * Input: 0
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: 9
 * Output: true
 *
 * Example 4:
 *
 *
 * Input: 45
 * Output: false
 *
 * Follow up:
 * Could you do it without using any loop / recursion?
 */
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  // tag: 数论
  // let i = 0;
  // while(Math.pow(3, i) < n) {
  //     i++;
  // }
  // return Math.pow(3, i) === n;

  // 巧用整除
  return n > 0 && Math.pow(3, 19) % n === 0;
};
// 扩展： 这个方法可以扩展到任意质数，合数则不行
```

### 337.house-robber-iii

```js
/*
 * @lc app=leetcode id=337 lang=javascript
 *
 * [337] House Robber III
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(root) {
  if (root === null) return [0, 0];
  // 0: rob 1: notRob
  const l = helper(root.left);
  const r = helper(root.right);

  const robed = root.val + l[1] + r[1];
  const notRobed = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);

  return [robed, notRobed];
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
  //   if (root === null) return 0;
  //   const notRobed = rob(root.left) + rob(root.right);
  //   const robed =
  //     root.val +
  //     rob(root.left && root.left.left) +
  //     rob(root.left && root.left.right) +
  //     rob(root.right && root.right.left) +
  //     rob(root.right && root.right.right);

  //   return Math.max(notRobed, robed);

  // dp
  const [robed, notRobed] = helper(root);
  return Math.max(robed, notRobed);
};
```

### 338.counting-bits

```js
/*
 * @lc app=leetcode id=338 lang=javascript
 *
 * [338] Counting Bits
 *
 * https://leetcode.com/problems/counting-bits/description/
 *
 * algorithms
 * Medium (64.04%)
 * Total Accepted:    163.1K
 * Total Submissions: 253K
 * Testcase Example:  '2'
 *
 * Given a non negative integer number num. For every numbers i in the range 0
 * ≤ i ≤ num calculate the number of 1's in their binary representation and
 * return them as an array.
 *
 * Example 1:
 *
 *
 * Input: 2
 * Output: [0,1,1]
 *
 * Example 2:
 *
 *
 * Input: 5
 * Output: [0,1,1,2,1,2]
 *
 *
 * Follow up:
 *
 *
 * It is very easy to come up with a solution with run time
 * O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a
 * single pass?
 * Space complexity should be O(n).
 * Can you do it like a boss? Do it without using any builtin function like
 * __builtin_popcount in c++ or in any other language.
 *
 */
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  // tag: bit dp
  // Time complexity: O(n)
  // Space complexity: O(n)
  const res = [];
  res[0] = 0;

  // 10000100110101
  for (let i = 1; i <= num; i++) {
    if ((i & 1) === 0) {
      // 偶数
      // 偶数最后一位是0，因此右移一位对结果没有影响
      res[i] = res[i >> 1];
    } else {
      // 奇数
      // 奇数最后一位是1，i - 1 的 位数 + 1 就是结果
      res[i] = res[i - 1] + 1;
    }
  }

  return res;
};
```

### 344

```js
// Write a function that reverses a string. The input string is given as an array of characters char[].

// Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

// You may assume all the characters consist of printable ascii characters.

const reverseStringAux = (s, n, m) => {
  if (m === n || s.length === 0 || n > m) return s;
  // swap first and last, in place
  const a = s[n];
  const b = s[m];
  s[n] = b;
  s[m] = a;
  reverseStringAux(s, n + 1, m - 1);
  return s;
};

/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
export default function reverseString(s) {
  return reverseStringAux(s, 0, s.length - 1);
}
```

### 344.reverse-string

```js
/*
 * @lc app=leetcode id=344 lang=javascript
 *
 * [344] Reverse String
 *
 * https://leetcode.com/problems/reverse-string/description/
 *
 * algorithms
 * Easy (62.81%)
 * Total Accepted:    409.9K
 * Total Submissions: 649.5K
 * Testcase Example:  '["h","e","l","l","o"]'
 *
 * Write a function that reverses a string. The input string is given as an
 * array of characters char[].
 *
 * Do not allocate extra space for another array, you must do this by modifying
 * the input array in-place with O(1) extra memory.
 *
 * You may assume all the characters consist of printable ascii
 * characters.
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: ["h","e","l","l","o"]
 * Output: ["o","l","l","e","h"]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: ["H","a","n","n","a","h"]
 * Output: ["h","a","n","n","a","H"]
 *
 *
 *
 *
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  for (let i = 0; i < s.length >> 1; i++) {
    const temp = s[i];
    s[i] = s[s.length - i - 1];
    s[s.length - i - 1] = temp;
  }
};
```

### 344.反转字符串

```js
/*
 * @lc app=leetcode.cn id=344 lang=javascript
 *
 * [344] 反转字符串
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  if (s.length < 2) return s;
  let i = 0,
    j = s.length - 1;
  while (i < j) {
    // es6 结构
    [s[i], s[j]] = [s[j], s[i]];
    i++;
    j--;
  }
  return s;
};

// 原地交换顺序解决
console.log(reverseString(['h', 'e', 'l', 'l', 'o']));
console.log(reverseString(['H', 'a', 'n', 'n', 'a', 'h']));
```

### 345.reverse-vowels-of-a-string

```js
/*
 * @lc app=leetcode id=345 lang=javascript
 *
 * [345] Reverse Vowels of a String
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
  const res = s.split('');

  let start = 0;
  let end = s.length - 1;
  while (start < end) {
    const startVowel = vowels.includes(s[start]);
    const endVowel = vowels.includes(s[end]);
    if (startVowel && endVowel) {
      const temp = res[start];
      res[start] = res[end];
      res[end] = temp;
      start++;
      end--;
    } else if (startVowel) {
      end--;
    } else if (endVowel) {
      start++;
    } else {
      start++;
      end--;
    }
  }

  return res.join('');
};
```

### 345.反转字符串中的元音字母

```js
/*
 * @lc app=leetcode.cn id=345 lang=javascript
 *
 * [345] 反转字符串中的元音字母
 *
 * 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: "hello"
输出: "holle"
示例 2:

输入: "leetcode"
输出: "leotcede"
说明:
元音字母不包含字母"y"。
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const map = {
    a: true,
    e: true,
    i: true,
    o: true,
    u: true,
    A: true,
    E: true,
    I: true,
    O: true,
    U: true,
  };
  s = s.split('');
  let left = 0,
    right = s.length - 1;
  while (left < right) {
    while (!map[s[left]] && left < right) left++;
    while (!map[s[right]] && left < right) right--;
    if (left < right) {
      [s[left], s[right]] = [s[right], s[left]];
      left++;
      right--;
    }
  }
  return s.join('');
};

// console.log(reverseVowels('hello'))
// console.log(reverseVowels('leetcode'))
console.log(reverseVowels('.,'));
```

### 349-Intersection-of-Two-Arrays

```js
/**
 * https://leetcode.com/problems/intersection-of-two-arrays/description/
 * Difficulty:Easy
 *
 * Given two arrays, write a function to compute their intersection.
 * Example:
 * Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].
 * Note:
 * Each element in the result must be unique.
 * The result can be in any order.
 */

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  var ret = [];
  var map1 = nums1.reduce((map, n) => {
    if (!map[n]) map[n] = 1;
    return map;
  }, {});

  var map2 = nums2.reduce((map, n) => {
    if (map1[n] && !map[n]) {
      ret.push(n);
      map[n] = 1;
    }
    return map;
  }, {});

  return ret;
};
console.log(intersection([1, 2, 2, 1], [2, 2]));
```

### 349

```js
// 349. Intersection of Two Arrays
// Given two arrays, write a function to compute their intersection.

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
export default function intersection(nums1, nums2) {
  const a = new Set(nums1);
  const b = new Set(nums2);
  const inters = [];
  for (const x of a) {
    if (b.has(x)) inters.push(x);
  }
  return inters;
}
```

### 349.两个数组的交集

```js
/*
 * @lc app=leetcode.cn id=349 lang=javascript
 *
 * [349] 两个数组的交集
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  // nums1 = [...new Set(nums1)]
  // nums2 = [...new Set(nums2)]
  if (nums1.length < nums2.length) {
    let temp = nums1;
    nums1 = nums2;
    nums2 = temp;
  }
  const map = {},
    resp = [];
  for (let i = 0; i < nums1.length; i++) {
    if (!map[nums1[i]]) {
      map[nums1[i]] = true;
    }
  }
  for (let i = 0; i < nums2.length; i++) {
    if (map[nums2[i]]) {
      resp.push(nums2[i]);
    }
  }
  return [...new Set(resp)];
};
// console.log(intersection([4, 9, 5], [9, 4, 9, 8, 4]))
// console.log(intersection([1, 2, 2, 1], [2, 2]))
```

### 350.intersection-of-two-arrays-ii

```js
/*
 * @lc app=leetcode id=350 lang=javascript
 *
 * [350] Intersection of Two Arrays II
 *
 * https://leetcode.com/problems/intersection-of-two-arrays-ii/description/
 *
 * algorithms
 * Easy (46.84%)
 * Total Accepted:    185.1K
 * Total Submissions: 393.7K
 * Testcase Example:  '[1,2,2,1]\n[2,2]'
 *
 * Given two arrays, write a function to compute their intersection.
 *
 * Example 1:
 *
 *
 * Input: nums1 = [1,2,2,1], nums2 = [2,2]
 * Output: [2,2]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
 * Output: [4,9]
 *
 *
 * Note:
 *
 *
 * Each element in the result should appear as many times as it shows in both
 * arrays.
 * The result can be in any order.
 *
 *
 * Follow up:
 *
 *
 * What if the given array is already sorted? How would you optimize your
 * algorithm?
 * What if nums1's size is small compared to nums2's size? Which algorithm is
 * better?
 * What if elements of nums2 are stored on disk, and the memory is limited such
 * that you cannot load all elements into the memory at once?
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
  const res = [];

  for (let i = 0; i < nums1.length; i++) {
    if (nums2.includes(nums1[i])) {
      // 这里我们对两个数组排序，然后二分查找， 时间复杂度nlogn
      nums2[nums2.indexOf(nums1[i])] = null;
      res.push(nums1[i]);
    }
  }

  return res;
};
```

### 367.有效的完全平方数

```js
/*
 * @lc app=leetcode.cn id=367 lang=javascript
 *
 * [367] 有效的完全平方数
 */
/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
  if (num < 2) return true;
  let mid = 0,
    left = 1,
    end = num,
    product = 0;
  while (left <= end) {
    mid = left + ((end - left) >> 1);
    // console.log('mid', mid)
    product = mid * mid;
    if (product === num) return true;
    if (product > num) {
      end = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return false;
};

console.log(isPerfectSquare(16));
console.log(isPerfectSquare(14));
console.log(isPerfectSquare(2));
console.log(isPerfectSquare(4));
console.log(isPerfectSquare(104976));
```

### 371

```js
// Sum of Two Integers
//
// Calculate the sum of two integers a and b, but you are not allowed to use
// the operator + and -
//
// ex. Given a = 1 and b = 2, return 3.
//

type num = number;

export default function SumTimelineMethod(first: num, second: num): num {
  const _first = new Array(Math.abs(first));
  const _second = new Array(Math.abs(second));
  const negatives = [];
  const positives = [];

  while (_first.length !== 0) {
    // first is positive
    if (_first.length > 0 && first > 0 && negatives.length === 0) {
      positives.push('-');
    } else if (first > 0 && negatives.length > 0) {
      negatives.splice(0, 1);
      // first is negative
    } else if (first < 0 && positives.length === 0) {
      negatives.push('-');
    } else if (first < 0 && positives.length > 0) {
      positives.splice(0, 1);
    }
    _first.splice(0, 1);
  }

  while (_second.length !== 0) {
    if (_second.length > 0 && second > 0 && negatives.length === 0) {
      positives.push('-');
    } else if (second > 0 && negatives.length > 0) {
      negatives.splice(0, 1);
      // second is negative
    } else if (second < 0 && positives.length === 0) {
      negatives.push('-');
    } else if (second < 0 && positives.length > 0) {
      positives.splice(0, 1);
    }
    _second.splice(0, 1);
  }

  return positives.length === 0 ? (negatives.length === 0 ? 0 : negatives.length * -1) : positives.length;
}
```

### 375.猜数字大小-ii

```js
/*
 * @lc app=leetcode.cn id=375 lang=javascript
 *
 * [375] 猜数字大小 II
 */
/**
 * @param {number} n
 * @return {number}
 */
var getMoneyAmount = function(n) {
  let resp = 0,
    mid = 0,
    start = 1,
    end = n;

  // 最少多少，也就是每次都需要选择右边的区间
  while (end - start > 1) {
    mid = parseInt((start + end) / 2);
    // console.log('start: ', start)
    // console.log('end: ', end)
    // console.log('mid: ', mid)
    resp += mid;
    start = mid + 1;
  }

  if (end - start === 1) {
    resp += start;
  }

  return resp;
};

console.log(getMoneyAmount(10));
console.log(getMoneyAmount(2)); // 1
console.log(getMoneyAmount(3)); // 2
console.log(getMoneyAmount(4)); // 3 + 1
console.log(getMoneyAmount(5)); // 3 + 4
console.log(getMoneyAmount(6)); // 3 + 5
```

### 383-Ransom-Note

```js
/**
 *
 Each letter in the magazine string can only be used once in your ransom note.

 Note:
 You may assume that both strings contain only lowercase letters.

 canConstruct("a", "b") -> false
 canConstruct("aa", "ab") -> false
 canConstruct("aa", "aab") -> true

 */

/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
  var canUseMap = magazine.split('').reduce((map, ch) => {
    if (!map[ch]) {
      map[ch] = 1;
    } else {
      map[ch] += 1;
    }
    return map;
  }, {});

  var wantUseMap = ransomNote.split('').reduce((map, ch) => {
    if (!map[ch]) {
      map[ch] = 1;
    } else {
      map[ch] += 1;
    }
    return map;
  }, {});

  for (var k in wantUseMap) {
    if (wantUseMap[k] > (canUseMap[k] || 0)) return false;
  }
  return true;
};
```

### 387-First-Unique-Character-in-a-String

```js
/**
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 * Difficulty:Easy
 *
 * Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.
 *
 * Examples:
 * s = "leetcode"
 * return 0.
 * s = "loveleetcode",
 * return 2.
 * Note: You may assume the string contain only lowercase letters.
 *
 */

/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (var i = 0; i < s.length; i++) {
    var ch = s[i];
    if (s.lastIndexOf(ch) === s.indexOf(ch)) return i;
  }
  return -1;
};

console.log(firstUniqChar('leetcode'));
console.log(firstUniqChar('loveleetcode'));
```

### 387.first-unique-character-in-a-string

```js
/*
 * @lc app=leetcode id=387 lang=javascript
 *
 * [387] First Unique Character in a String
 *
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 *
 * algorithms
 * Easy (49.29%)
 * Total Accepted:    255.6K
 * Total Submissions: 513.8K
 * Testcase Example:  '"leetcode"'
 *
 *
 * Given a string, find the first non-repeating character in it and return it's
 * index. If it doesn't exist, return -1.
 *
 * Examples:
 *
 * s = "leetcode"
 * return 0.
 *
 * s = "loveleetcode",
 * return 2.
 *
 *
 *
 *
 * Note: You may assume the string contain only lowercase letters.
 *
 */
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
};
```

### 392-Is-Subsequence

```js
/**
 * https://leetcode.com/problems/is-subsequence/description/
 * Difficulty:Medium
 *
 * Given a string s and a string t, check if s is subsequence of t.
 * You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).
 * A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).
 *
 * Example 1:
 * s = "abc", t = "ahbgdc"
 * Return true.
 *
 * Example 2:
 * s = "axc", t = "ahbgdc"
 * Return false.
 *
 * Follow up:
 * If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?
 */

/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
  var i = 0;
  var j = 0;
  var m = s.length;
  var n = t.length;
  while (j < n && i < m) {
    if (s[i] === t[j]) {
      i++;
    }
    j++;
  }

  return i === m;
};

console.log(isSubsequence('abc', 'asssbsssc'));
console.log(isSubsequence('abc', 'asssbsss'));
console.log(isSubsequence('', 'asssbsss'));
```

### 392.判断子序列

```js
/*
 * @lc app=leetcode.cn id=392 lang=javascript
 *
 * [392] 判断子序列
 */
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
// 如果s是t的子序列，也就是说s中的所有字符都会按照顺序出现在t中，
// 因此，使用双指针的方式实现:
var isSubsequence = function(s, t) {
  let i = 0,
    j = 0;
  while (s[i] && t[j]) {
    // 如果字符匹配，则两个都加一位，否则的话，母字符串 + 1
    if (s[i] === t[j]) {
      i++;
    }
    j++;
  }
  return i === s.length;
};

console.log(isSubsequence('abc', 'ahbgdc'));
console.log(isSubsequence('axc', 'ahbgdc'));
```

### 404-Sum-of-Left-Leaves

```js
/**
 * https://leetcode.com/problems/sum-of-left-leaves/description/
 * Difficulty:Easy
 *
 * Find the sum of all left leaves in a given binary tree.
 * Example:
 *     3
 *    / \
 *   9  20
 *      / \
 *    15   7
 * There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
 *
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
  return fn(root, false);
};

function fn(node, isLeft) {
  if (!node) return 0;
  if (!node.left && !node.right) {
    return isLeft ? node.val : 0;
  }

  return fn(node.left, true) + fn(node.right, false);
}
```

### 404

```js
// Sum of Left Leaves
// Find the sum of all left leaves in a given binary tree

//   3
// /   \
// 9    20
//    /   \
//   15   7

// There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const sumOfLeftLeavesAux = (root, sum, isLeft) => {
  if (root === null) return 0;
  if (!root.left && !root.right && isLeft) return root.val;
  if (root.left) sum += sumOfLeftLeavesAux(root.left, 0, true);
  if (root.right) sum += sumOfLeftLeavesAux(root.right, 0, false);
  return sum;
};

export default function sumOfLeftLeaves(root) {
  return sumOfLeftLeavesAux(root, 0, false);
}
```

### 412.fizz-buzz

```js
/*
 * @lc app=leetcode.cn id=412 lang=javascript
 *
 * [412] Fizz Buzz
 */
/**
 * @param {number} n
 * @return {string[]}
 */

// Accepted
// ✔ 8 / 8 cases passed(92 ms)
// ✔ Your runtime beats 70.8 % of javascript submissions
// ✔ Your memory usage beats 44.87 % of javascript submissions(37.3 MB)
var fizzBuzz1 = function(n) {
  let result = [],
    i = 1;
  while (i <= n) {
    if (i % 3 === 0 && i % 5 === 0) {
      result.push('FizzBuzz');
    } else if (i % 3 === 0) {
      result.push('Fizz');
    } else if (i % 5 === 0) {
      result.push('Buzz');
    } else {
      result.push(i + '');
    }
    i++;
  }
  return result;
};

// ✔ Accepted
// ✔ 8 / 8 cases passed(84 ms)
// ✔ Your runtime beats 91.18 % of javascript submissions
// ✔ Your memory usage beats 55.13 % of javascript submissions(37.3 MB)
var fizzBuzz = function(n) {
  let result = [0];
  for (let i = 1; i <= n; i++) {
    result[i] = i % 3 === 0 && i % 5 === 0 ? 'FizzBuzz' : i % 3 === 0 ? 'Fizz' : i % 5 === 0 ? 'Buzz' : i + '';
  }
  result.shift();
  return result;
};

console.log(fizzBuzz(1));
console.log(fizzBuzz(2));
console.log(fizzBuzz(3));
console.log(fizzBuzz(10));
console.log(fizzBuzz(15));
```

### 413-Arithmetic-Slices

```js
/**
 * https://leetcode.com/problems/arithmetic-slices/description/
 * Difficulty:Medium
 *
 * A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
 *
 * For example, these are arithmetic sequence:
 * 1, 3, 5, 7, 9
 * 7, 7, 7, 7
 * 3, -1, -5, -9
 *
 * The following sequence is not arithmetic.
 * 1, 1, 2, 5, 7
 *
 * A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.
 *
 * A slice (P, Q) of array A is called arithmetic if the sequence:
 *
 * A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.
 *
 * The function should return the number of arithmetic slices in the array A.
 *
 * Example:
 * A = [1, 2, 3, 4]
 *
 * return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
 *
 */

/**
 * @param {number[]} A
 * @return {number}
 */
var numberOfArithmeticSlices = function(A) {
  if (A.length < 3) return 0;
  var dp = [];
  if (A[2] - A[1] === A[1] - A[0]) {
    dp[2] = 1;
  } else {
    dp[2] = 0;
  }
  var result = dp[2];

  for (var i = 3; i < A.length; i++) {
    if (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {
      dp[i] = dp[i - 1] + 1;
      result += dp[i];
    } else {
      dp[i] = 0;
    }
  }

  return result;
};
```

### 415-Add-Strings

```js
/**
 * https://leetcode.com/problems/add-strings/description/
 * Difficulty:Easy
 *
 * Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
 * Note:
 *
 * The length of both num1 and num2 is < 5100.
 * Both num1 and num2 contains only digits 0-9.
 * Both num1 and num2 does not contain any leading zero.
 * You must not use any built-in BigInteger library or convert the inputs to integer directly.
 */

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function(num1, num2) {
  var carry = 0;
  var len1 = num1.length;
  var len2 = num2.length;
  var forCount = Math.max(len1, len2);
  var newNum = '';
  for (var i = 0; i < forCount; i++) {
    var a = parseInt(num1[len1 - 1 - i]) || 0;
    var b = parseInt(num2[len2 - 1 - i]) || 0;
    var c = a + b + carry;
    carry = Math.floor(c / 10);
    var e = c % 10;
    newNum = e + newNum;
  }

  if (carry) {
    newNum = carry + newNum;
  }
  return newNum;
};

console.log(addStrings('12', '123') == '135');
```

### 415

```js
// 415. Add Strings

// Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.

// Note:
// The length of both num1 and num2 is < 5100.
// Both num1 and num2 contains only digits 0-9.
// Both num1 and num2 does not contain any leading zero.
// You must not use any built-in BigInteger library or convert the inputs to integer directly.

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
export default function addStrings(num1, num2) {
  let carry = false;
  const str = [];
  for (let i = 0; i < Math.max(num1.length, num2.length) || carry; i++) {
    const a = i < num1.length ? num1[num1.length - 1 - i] : 0;
    const b = i < num2.length ? num2[num2.length - 1 - i] : 0;
    let sum = parseInt(a, 10) + parseInt(b, 10) + (carry === true ? 1 : 0);
    carry = sum > 9;
    sum %= 10;
    str.push(sum);
  }
  return str.reverse().join('');
}
```

### 416-Partition-Equal-Subset-Sum

```js
/**
 * https://leetcode.com/problems/partition-equal-subset-sum/description/
 * Difficulty:Medium
 *
 * Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
 * Note:
 * Each of the array element will not exceed 100.
 * The array size will not exceed 200.
 * Example 1:
 * Input: [1, 5, 11, 5]
 * Output: true
 * Explanation: The array can be partitioned as [1, 5, 5] and [11].
 * Example 2:
 * Input: [1, 2, 3, 5]
 * Output: false
 * Explanation: The array cannot be partitioned into equal sum subsets.
 */

/**
 *
 * 01背包问题
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  var sum = nums.reduce((a, b) => a + b, 0);
  if (sum % 2) return false;
  sum = sum / 2;

  var n = nums.length;
  var dp = [];

  while (dp.push(new Array(sum + 1).fill(0)) < n + 1);

  for (var i = 0; i < n + 1; i++) {
    dp[i][0] = 1;
  }

  for (var i = 1; i < n + 1; i++) {
    for (var j = 1; j < sum + 1; j++) {
      if (dp[i - 1][j]) dp[i][j] = 1;
      if (j >= nums[i - 1] && dp[i - 1][j - nums[i - 1]]) dp[i][j] = 1;
    }
  }

  // console.log(dp);

  return !!dp[n][sum];
};

console.log(canPartition([1, 5]));
console.log(canPartition([1, 5, 11, 5]));
// console.log(canPartition([1, 5, 11, 5, 1, 1]));
// console.log(canPartition([1, 5, 11, 5, 2]));
// console.log(canPartition([1, 5, 11, 5]));
// console.log(canPartition([1, 2, 3, 5]));
```

### 443.压缩字符串

```js
/*
 * @lc app=leetcode.cn id=443 lang=javascript
 *
 * [443] 压缩字符串
 */
/**
 * @param {character[]} chars
 * @return {number}
 */
// TODO: 原地修改
var compress = function(chars) {
  // 0 记录 chars[i] 1 记录次数
  let map = [],
    resp = '';
  for (let i = 0; i < chars.length; i++) {
    if (!map[0]) {
      map[0] = chars[i];
      map[1] = 1;
    } else {
      if (map[0] !== chars[i]) {
        resp += `${map[0]}${map[1] > 1 ? map[1] : ''}`;
        map[0] = chars[i];
        map[1] = 1;
        continue;
      }
      map[1]++;
    }
  }
  resp += `${map[0]}${map[1] > 1 ? map[1] : ''}`;
  return resp.length;
};

console.log(compress(['a', 'a', 'b', 'b', 'c', 'c', 'c']));
console.log(compress(['a']));
console.log(compress(['a', 'a', 'b', 'b', 'c', 'c', 'c']));
console.log(compress(['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b']));
```

### 447-Number-of-Boomerangs

```js
/**
 * https://leetcode.com/problems/number-of-boomerangs/description/
 * Difficulty:Easy
 *
 * Given n points in the plane that are all pairwise distinct,
 * a "boomerang" is a tuple of points (i, j, k) such that the distance
 * between i and j equals the distance between i and k (the order of the tuple matters).
 *
 * Find the number of boomerangs.
 * You may assume that n will be at most 500 and
 * coordinates of points are all in the range [-10000, 10000] (inclusive).
 *
 *
 *
 * Example:
 * Input:
 * [[0,0],[1,0],[2,0]]
 * Output:
 * 2
 * Explanation:
 * The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
 *
 *
 *
 * 解释
 *
 * 给定一个Point的数组, 找到所有的长度为3的Point数组(i, j, k)
 * 使得 i&j, i&k 的距离相同
 * 顺序有关
 *
 */

/**
 * @param {number[][]} points
 * @return {number}
 */
var numberOfBoomerangs = function(points) {
  if (points.length < 3) return 0;
  var ret = 0;
  for (var i = 0; i < points.length; i++) {
    var p1 = points[i];
    var disMap = {};

    for (var j = 0; j < points.length; j++) {
      if (i == j) continue;
      var p2 = points[j];
      var dis = getDis(p1, p2);
      if (disMap[dis] == undefined) disMap[dis] = 1;
      else disMap[dis] += 1;
    }

    for (var key in disMap) {
      var n = disMap[key];
      ret += n * (n - 1);
    }
  }

  return ret;
};

function getDis(p1, p2) {
  var d1 = p2[1] - p1[1];
  var d2 = p2[0] - p1[0];
  return d1 * d1 + d2 * d2;
}

console.log(
  numberOfBoomerangs([
    [0, 0],
    [1, 0],
    [2, 0],
  ]) == 2,
);
console.log(numberOfBoomerangs([[1, 1]]) == 0);
console.log(
  numberOfBoomerangs([
    [1, 1],
    [1, 2],
  ]) == 0,
);
console.log(
  numberOfBoomerangs([
    [0, 0],
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
  ]) == 20,
);
```

### 453-Minimum-Moves-to-Equal-Array-Elements

```js
/**
 * https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/
 * Difficulty:Easy
 *
 * Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.
 * Example:
 * Input:
 * [1,2,3]
 * Output:
 * 3
 * Explanation:
 * Only three moves are needed (remember each move increments two elements):
 * [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
 *
 */

/**
 *
 * reverse thinking!
 *
 * Adding 1 to n - 1 elements is the same as subtracting 1 from one element
 *
 * goal of making the elements in the array equal.
 * So, best way to do this is make all the elements in the array equal to the min element.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var minMoves = function(nums) {
  var min = nums[0];
  for (var i = 1; i < nums.length; i++) {
    min = Math.min(min, nums[i]);
  }

  var ret = 0;
  for (i = 0; i < nums.length; i++) {
    ret += nums[i] - min;
  }
  return ret;
};

console.log(minMoves([1, 999, 1000]));
```

### 454-4Sum-II

```js
/**
 * Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l)
 * there are such that A[i] + B[j] + C[k] + D[l] is zero.

 To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500.
 All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.

 Example:

 Input:
 A = [ 1, 2]
 B = [-2,-1]
 C = [-1, 2]
 D = [ 0, 2]

 Output:
 2

 Explanation:
 The two tuples are:
 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
 */

/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
var fourSumCount = function(A, B, C, D) {
  var cnt = 0;
  var map = {};
  var n = A.length;

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      var sum = A[i] + B[j];
      if (map[sum] === undefined) map[sum] = 1;
      else map[sum]++;
    }
  }

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      var sum = C[i] + D[j];
      if (map[-sum] !== undefined) cnt += map[-sum];
    }
  }
  return cnt;
};

console.log(fourSumCount([1, 2], [-2, -2], [-1, 2], [0, 2]));
```

### 455-Assign-Cookies

```js
/**
 * https://leetcode.com/problems/assign-cookies/description/
 * Difficulty:Easy
 *
 * Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
 *
 * Note:
 * You may assume the greed factor is always positive.
 * You cannot assign more than one cookie to one child.
 * Example 1:
 * Input: [1,2,3], [1,1]
 * Output: 1
 * Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
 * And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
 * You need to output 1.
 *
 */

/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
  var ret = 0;
  g.sort((a, b) => a - b);
  s.sort((a, b) => a - b);
  var gIndex = 0;
  var sIndex = 0;

  while (gIndex < g.length && sIndex < s.length) {
    var gi = g[gIndex];
    var si = s[sIndex];
    if (gi <= si) {
      ret += 1;
      gIndex++;
      sIndex++;
    } else if (gi > si) {
      sIndex++;
    } else {
      break;
    }
  }

  return ret;
};

console.log(findContentChildren([1, 2, 3], [1, 1]));
console.log(findContentChildren([1, 2], [1, 2, 3]));
```

### 459.重复的子字符串

```js
/*
 * @lc app=leetcode.cn id=459 lang=javascript
 *
 * [459] 重复的子字符串
 */
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
  // 正则表达式的模式匹配
  return /^(\w+)\1+$/.test(s);
};

console.log(repeatedSubstringPattern('abab'));
console.log(repeatedSubstringPattern('aba'));
console.log(repeatedSubstringPattern('abcabcabcabc'));
```

### 461-Hamming-Distance

```js
/**
 * https://leetcode.com/problems/hamming-distance/description/
 * Difficulty:Easy
 *
 * The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
 * Given two integers x and y, calculate the Hamming distance.
 * Note:
 * 0 ≤ x, y < 231.
 * Example:
 * Input: x = 1, y = 4
 * Output: 2
 * Explanation:
 * 1   (0 0 0 1)
 * 4   (0 1 0 0)
 * ↑   ↑
 * The above arrows point to positions where the corresponding bits are different.
 *
 */

/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
  var z = x ^ y;
  var ret = 0;
  while (z) {
    ret += z % 2;
    z = Math.floor(z / 2);
  }
  return ret;
};

console.log(hammingDistance(1, 4));
```

### 476-Number-Complement

```js
/**
 * https://leetcode.com/problems/number-complement/description/
 * Difficulty:Easy
 *
 * Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
 * Note:
 *
 * The given integer is guaranteed to fit within the range of a 32-bit signed integer.
 * You could assume no leading zero bit in the integer’s binary representation.
 *
 * Example:
 * Input: 5
 * Output: 2
 * Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
 */

/**
 * @param {number} num
 * @return {number}
 */
var findComplement = function(num) {
  var str = '';

  while (num) {
    str = (num % 2 ? 0 : 1) + str;
    num = Math.floor(num / 2);
  }

  return parseInt(str, 2);
};

console.log(findComplement(5));
console.log(findComplement(2));
```

### 477-Total-Hamming-Distance

```js
/**
 * https://leetcode.com/problems/total-hamming-distance/description/
 * Difficulty:Medium
 *
 * The Hamming distance between two integers is the number of positions at which
 * the corresponding bits are different.
 * Now your job is to find the total Hamming distance between all pairs of the given numbers.
 *
 * Example:
 * Input: 4, 14, 2
 * Output: 6
 * Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
 * showing the four bits relevant in this case). So the answer will be:
 * HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
 *
 * Note:
 * Elements of the given array are in the range of 0 to 10^9
 * Length of the array will not exceed 10^4.
 *
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var totalHammingDistance = function(nums) {
  var ret = 0;
  var maxLen = 0;
  var bArrs = nums.map(n => {
    var arr = [];
    while (n) {
      arr.push(n % 2);
      n = Math.floor(n / 2);
    }
    if (arr.length > maxLen) maxLen = arr.length;

    return arr;
  });

  while (maxLen) {
    var index = maxLen - 1;

    var ones = 0;
    var zeros = 0;
    for (var i = 0; i < bArrs.length; i++) {
      if (bArrs[i][index]) {
        ones++;
      } else {
        zeros++;
      }
    }
    ret += ones * zeros;
    maxLen--;
  }

  return ret;
};

console.log(6 == totalHammingDistance([4, 14, 2]));
```

### 492-Construct-the-Rectangle

```js
/**
 *
 * https://leetcode.com/problems/construct-the-rectangle/description/
 * Difficulty:Easy
 *
 * For a web developer, it is very important to know how to design a web page's size.
 * So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page,
 * whose length L and width W satisfy the following requirements:
 * 1. The area of the rectangular web page you designed must equal to the given target area.
 * 2. The width W should not be larger than the length L, which means L >= W.
 * 3. The difference between length L and width W should be as small as possible.
 * You need to output the length L and the width W of the web page you designed in sequence.
 *
 * Example:
 * Input: 4
 * Output: [2, 2]
 * Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].
 * But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
 *
 * Note:
 * The given area won't exceed 10,000,000 and is a positive integer
 * The web page's width and length you designed must be positive integers.
 * */

/**
 * @param {number} area
 * @return {number[]}
 */
var constructRectangle = function(area) {
  var w = Math.floor(Math.sqrt(area));
  while (area % w != 0) w--;
  return [area / w, w];
};

console.log(constructRectangle(4));
console.log(constructRectangle(17));
```

### 500-Keyboard-Row

```js
/**
 * https://leetcode.com/problems/keyboard-row/description/
 * Difficulty:Easy
 *
 * Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.
 *
 * Example 1:
 * Input: ["Hello", "f", "Dad", "Peace"]
 * Output: ["Alaska", "Dad"]
 * Note:
 * You may use one character in the keyboard more than once.
 * You may assume the input string will only contain letters of alphabet.
 */

/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
  var s = 'qwertyuiopasdfghjklzxcvbnm';
  return words.filter(w => {
    if (!w) return true;
    w = w.toLowerCase();
    var t = row(w[0]);
    for (var i = 1; i < w.length; i++) {
      if (t !== row(w[i])) return false;
    }
    return true;
  });

  function row(ch) {
    var i = s.indexOf(ch);
    if (i < 10) return 0;
    if (i < 19) return 1;
    return 2;
  }
};
console.log(findWords(['Hello', 'Alaska', 'Dad', 'Peace']));
```

### 504-Base-7

```js
/**
 * https://leetcode.com/problems/base-7/description/
 * Difficulty:Easy
 *
 * Given an integer, return its base 7 string representation.
 * Example 1:
 * Input: 100
 * Output: "202"
 * Example 2:
 * Input: -7
 * Output: "-10"
 * Note: The input will be in range of [-1e7, 1e7].
 *
 */

/**
 * @param {number} num
 * @return {string}
 */
var convertToBase7 = function(num) {
  if (num === 0) return '0';
  var str = '';
  var sign = num > 0;
  num = Math.abs(num);
  while (num) {
    str = (num % 7) + str;
    num = Math.floor(num / 7);
  }

  return sign ? str : '-' + str;
};

console.log(convertToBase7(0));
console.log(convertToBase7(100));
console.log(convertToBase7(-7));
```

### 506-Relative-Ranks

```js
/**
 * https://leetcode.com/problems/relative-ranks/description/
 * Difficulty:Easy
 *
 * Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".
 *
 * Example 1:
 * Input: [5, 4, 3, 2, 1]
 * Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
 * Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal".
 * For the left two athletes, you just need to output their relative ranks according to their scores.
 * Note:
 * N is a positive integer and won't exceed 10,000.
 * All the scores of athletes are guaranteed to be unique.
 *
 */

/**
 * @param {number[]} nums
 * @return {string[]}
 */
var findRelativeRanks = function(nums) {
  var medals = ['Gold Medal', 'Silver Medal', 'Bronze Medal'];
  var ranks = [];
  Array.prototype.push.apply(ranks, nums);
  ranks.sort(function(a, b) {
    return b - a;
  });

  return nums.map(n => {
    var rank = ranks.indexOf(n);
    return medals[rank] || rank + 1 + '';
  });
};

// ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
console.log(findRelativeRanks([10, 3, 8, 9, 4]));

console.log(findRelativeRanks([5, 4, 1, 2, 3]));
```

### 520-Detect-Capital

```js
/**
 * https://leetcode.com/problems/detect-capital/description/
 * Difficulty:Easy
 *
 * Given a word, you need to judge whether the usage of capitals in it is right or not.
 * We define the usage of capitals in a word to be right when one of the following cases holds:
 * All letters in this word are capitals, like "USA".
 * All letters in this word are not capitals, like "leetcode".
 * Only the first letter in this word is capital if it has more than one letter, like "Google".
 * Otherwise, we define that this word doesn't use capitals in a right way.
 *
 */

/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
  var len = word.length;
  var upperLen = 0;
  var lowerLen = 0;
  var firstCap = false;
  for (var i = 0; i < len; i++) {
    var ch = word[i];
    if (/[A-Z]/.test(ch)) {
      upperLen++;
      if (i == 0) {
        firstCap = true;
      }
    }
    if (/[a-z]/.test(ch)) {
      lowerLen++;
    }
  }
  if (upperLen == len) return true;
  if (lowerLen == len) return true;
  return upperLen == 1 && firstCap && len > 1;
};

/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
  var isFirstChUpper = false;
  var upperCnt = 0;
  var n = word.length;

  for (let i = 0; i < n; i++) {
    let ch = word[i];
    if (ch >= 'A' && ch <= 'Z') {
      upperCnt++;
      if (i === 0) isFirstChUpper = true;
    }
  }

  if (isFirstChUpper) {
    return upperCnt === 1 || upperCnt === n;
  } else {
    return upperCnt === 0;
  }
};

console.log(detectCapitalUse('USA'));
console.log(detectCapitalUse('FlaG'));
console.log(detectCapitalUse('A'));
console.log(detectCapitalUse('Google'));
console.log(detectCapitalUse('leetcode'));
```

### 523-Continuous-Subarray-Sum

```js
/**
 * https://leetcode.com/problems/continuous-subarray-sum/description/
 * Difficulty:Medium
 *
 * Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer
 *
 * Example 1:
 * Input: [23, 2, 4, 6, 7],  k=6
 * Output: True
 * Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.
 *
 * Example 2:
 * Input: [23, 2, 6, 4, 7],  k=6
 * Output: True
 * Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.
 *
 * Note:
 * The length of the array won't exceed 10,000.
 * You may assume the sum of all the numbers is in the range of a signed 32-bit integer.
 */

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function(nums, k) {
  var arr = [];
  var sum = 0;
  if (nums.length < 2) return false;
  for (var i = 0; i < nums.length - 1; i++) {
    if (nums[i] + nums[i + 1] === 0) return true;
  }

  if (k < 0) k = -k;
  if (k === 0) return false;

  for (i = 0; i < nums.length; i++) {
    sum += nums[i];
    sum = sum % k;
    if (i > 0 && sum === 0) return true;
    var index = arr.indexOf(sum);
    if (index !== -1) {
      return true;
    }
    arr.push(sum);
  }
  return false;
};

console.log(checkSubarraySum([23, 2, 4, 6, 7], 6));
console.log(checkSubarraySum([23, 2, 4, 6, 7], 7));
console.log(checkSubarraySum([23, 2, 4, 6, 7], 8));
console.log(checkSubarraySum([0, 0], 0), true);
console.log(checkSubarraySum([0, 1, 0], 0), false);
console.log(checkSubarraySum([1, 1], 2), true);
```

### 524.通过删除字母匹配到字典里最长单词

```js
/*
 * @lc app=leetcode.cn id=524 lang=javascript
 *
 * [524] 通过删除字母匹配到字典里最长单词
 */
/**
 * @param {string} s
 * @param {string[]} d
 * @return {string}
 */
var findLongestWord = function(s, d) {
  const minSubStr = [];
  for (let i = 0; i < d.length; i++) {
    const target = d[i];
    if (isSubStr(s, target)) {
      if (minSubStr.length === 0) {
        minSubStr.push(target);
      } else if (
        target.length > minSubStr[0].length ||
        (target.length === minSubStr[0].length && target < minSubStr[0])
      ) {
        // 只会等于 1 不会大于 1
        minSubStr[0] = target;
      }
    }
  }
  return minSubStr.length ? minSubStr[0] : '';
};

// 判断是否是子串，通过双指针来判断
function isSubStr(s, p) {
  // 分别指向模式串和标准串
  let i = (j = 0);
  while (i < s.length && j < p.length) {
    if (s[i] === p[j]) {
      j++;
    }
    // 如果两个不匹配的话，就意味着删除对应位置的字符串即可
    i++;
  }
  // 匹配完成.
  // 既然是删除 s 中的一些字符串来匹配 p 所以 p 匹配结束了就表示匹配完成了
  // 否则如果是 s 先匹配结束说明永远都匹配不了 p
  return j === p.length;
}

// console.log(findLongestWord('abpcplea', ["ale", "apple", "monkey", "plea"]))
// console.log(findLongestWord('abpcplea', ["a", "b", "c"]))
// console.log(findLongestWord('bab', ["ba", "ab", "a", "b"]))
```

### 538.convert-bst-to-greater-tree

```js
/*
 * @lc app=leetcode id=538 lang=javascript
 *
 * [538] Convert BST to Greater Tree
 *
 * https://leetcode.com/problems/convert-bst-to-greater-tree/description/
 *
 * algorithms
 * Easy (50.04%)
 * Total Accepted:    75.4K
 * Total Submissions: 149K
 * Testcase Example:  '[5,2,13]'
 *
 * Given a Binary Search Tree (BST), convert it to a Greater Tree such that
 * every key of the original BST is changed to the original key plus sum of all
 * keys greater than the original key in BST.
 *
 *
 * Example:
 *
 * Input: The root of a Binary Search Tree like this:
 * ⁠             5
 * ⁠           /   \
 * ⁠          2     13
 *
 * Output: The root of a Greater Tree like this:
 * ⁠            18
 * ⁠           /   \
 * ⁠         20     13
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
  let res = 0;
  function r(root) {
    if (root === null) return null;

    r(root.right);

    root.val += res;

    res = +root.val;

    r(root.left);

    return root;
  }
  r(root);
  return root;
};
```

### 540.single-element-in-a-sorted-array

```js
/*
 * @lc app=leetcode id=540 lang=javascript
 *给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

示例 1:

输入: [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: [3,3,7,7,10,11,11]
输出: 10
注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
 * [540] Single Element in a Sorted Array
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate1 = function(nums) {
  //   if (nums.length === 1) return nums[0]
  //   nums.sort();
  //   for (let i = 0; i < nums.length; i++) {
  //     if (nums[i] === nums[i + 1]) {
  //       i++;
  //     } else {
  //         return nums[i];
  //     }
  //   }

  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === nums[mid + 1]) {
      if (mid % 2 === 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    } else if (nums[mid] === nums[mid - 1]) {
      if (mid % 2 === 0) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    } else {
      return nums[mid];
    }
  }
};

// 错了。。。。
var singleNonDuplicate = function(nums) {
  // 有序，缺少一个值。
  // 给定的排序数组肯定是单数.
  const n = Math.ceil(nums.length / 2);
  const sum = (nums[0] + nums[nums.length - 1]) * n;
  let sum1 = nums.reduce((sum, num) => sum + num, 0);
  console.log('sum', sum);
  console.log('sum1', sum1);
  return sum - sum1;
};

// console.log(singleNonDuplicate([1, 1, 2, 3, 3, 4, 4, 8, 8]))
// console.log(singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]))
console.log(singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]));
```

### 541.反转字符串-ii

```js
/*
 * @lc app=leetcode.cn id=541 lang=javascript
 *
 * [541] 反转字符串 II
 */
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
  let strArr = [];
  // 1. 截断字符串
  while (s) {
    strArr.push(s.slice(0, 2 * k));
    s = s.slice(2 * k);
  }
  return strArr
    .map(str => {
      return reverseArr(str.split(''), 0, k - 1).join('');
    })
    .join('');
};

// 原地反转
const reverseArr = (arr, start = 0, end = arr.length) => {
  let i = start,
    j = end;
  while (i < j) {
    [arr[i], arr[j]] = [arr[j], arr[i]];
    i++;
    j--;
  }
  return arr;
};

//溜啊
var newReverseStr = function(s, k) {
  if (k > s.length)
    return s
      .split('')
      .reverse()
      .join('');

  const split = s.split('');
  // 将需要翻转部分先翻转，后插入
  for (let i = 0; i < s.length; i += 2 * k) {
    const reverse = split.splice(i, k).reverse();
    split.splice(i, 0, ...reverse);
  }
  return split.join('');
};

console.log(reverseStr('abcdefg', 2));
console.log(newReverseStr('abcdefg', 2));
```

### 543.diameter-of-binary-tree

```js
/*
 * @lc app=leetcode id=543 lang=javascript
 *
 * [543] Diameter of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function maxDepth(root, res) {
  if (root === null) return 0;

  const l = maxDepth(root.left, res);
  const r = maxDepth(root.right, res);
  res.val = Math.max(res.val, l + r);
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
  // 如果不计算max， 直接1+ Math.max(maxLeft, maxRight)， 得到的结果实际上是经过root节点的最大值，并不一定是总体最大值
  // 题目也做了说明， ”最大值不一定经过root“
  if (root === null) return 0;
  const res = {
    val: 0,
  };

  maxDepth(root, res);

  return res.val;
};
```

### 543.二叉树的直径

```js
/*
 * @lc app=leetcode.cn id=543 lang=javascript
 *
 * [543] 二叉树的直径
 * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。
 * 注意：两结点之间的路径长度是以它们之间边的数目表示。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
let max = 0;
var diameterOfBinaryTree = function(root) {
  // if (root == null) return 0;
  depth(root);
  return max;
};

var depth = function(root) {
  if (!root) return 0;
  let l = depth(root.left);
  let r = depth(root.right);
  // 累加结果比较
  max = Math.max(max, l + r);
  // 需要返回最大的深度
  return Math.max(l, r) + 1;
};

console.log(diameterOfBinaryTree({ val: null, left: null, right: null }));
console.log(diameterOfBinaryTree({ val: 1, left: null, right: null }));

// ✘ Wrong Answer
// ✘ 46 / 106 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: 3
// ✘ expected_answer: 0
// ✘ stdout:

// ✘ Wrong Answer
// ✘ 46 / 106 cases passed(N / A)
// ✘ testcase: '[1]'
// ✘ answer: 3
// ✘ expected_answer: 0
// ✘ stdout:
```

### 557-Reverse-Words-in-a-String-III

```js
/**
 * https://leetcode.com/problems/reverse-words-in-a-string-iii/description/
 * Difficulty:Easy
 *
 * Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
 * Example 1:
 * Input: "Let's take LeetCode contest"
 * Output: "s'teL ekat edoCteeL tsetnoc"
 * Note: In the string, each word is separated by single space and there will not be any extra space in the string.
 */

/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s
    .split(' ')
    .map(w =>
      w
        .split('')
        .reverse()
        .join(''),
    )
    .join(' ');
};

console.log(reverseWords(`Let's take LeetCode contest`));
```

### 557.反转字符串中的单词-iii

```js
/*
 * @lc app=leetcode.cn id=557 lang=javascript
 *
 * [557] 反转字符串中的单词 III
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  // 需要注意的是，reverse 是数组拥有的函数，并不是字符串
  return s
    .split(' ')
    .map(item => {
      return item
        .split('')
        .reverse()
        .join('');
    })
    .join(' ');
};

var newReverseWords = function(s) {
  // 正则匹配一个单词，从左到右一个单词一个单词进行匹配
  return s
    .match(/[\w']+/g)
    .map(item => {
      return item
        .split('')
        .reverse()
        .join('');
    })
    .join(' ');
};

console.log(reverseWords("Let's take LeetCode contest"));
console.log(newReverseWords("Let's take LeetCode contest"));
```

### 561-Array-Partition-I

```js
/**
 * https://leetcode.com/problems/array-partition-i/description/
 * Difficulty:Easy
 *
 * Given an array of 2n integers, your task is to group these integers into n pairs of integer,
 * say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
 *
 * Example 1:
 * Input: [1,4,3,2]
 * Output: 4
 * Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
 *
 * Note:
 * n is a positive integer, which is in the range of [1, 10000].
 * All the integers in the array will be in the range of [-10000, 10000].
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
  nums.sort((a, b) => {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  });

  // console.log(nums);
  var sum = 0;
  for (var i = 0; i < nums.length / 2; i++) {
    sum += nums[2 * i];
  }

  return sum;
};

console.log(arrayPairSum([1, 4, 3, 2]));
```

### 605.种花问题

```js
/*
 * @lc app=leetcode.cn id=605 lang=javascript
 *
 * [605] 种花问题
 */
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
  if (n <= 0) return true;
  for (let i = 0; i < flowerbed.length; i++) {
    if (flowerbed[i] === 0) {
      if (
        (i === 0 && (flowerbed[i + 1] === 0 || i + 1 === flowerbed.length)) ||
        (i === flowerbed.length - 1 && flowerbed[i - 1] === 0) ||
        (flowerbed[i - 1] === 0 && flowerbed[i + 1] === 0)
      ) {
        flowerbed[i] = 1;
        n--;
        // 当前位置种了花之后，下一个直接跳过，没必要再验证了
        i++;
      }
    }

    if (n === 0) break;
  }
  return n === 0;
};

// 94% 39%
console.log(canPlaceFlowers([1, 0, 0, 0, 1], 1));
console.log(canPlaceFlowers([1, 0, 0, 0, 1], 2));
console.log(canPlaceFlowers([1, 0, 0, 0, 0, 0, 1], 2));
console.log(canPlaceFlowers([0], 1));
```

### 621.任务调度器

```js
/*
 * @lc app=leetcode.cn id=621 lang=javascript
 *
 * [621] 任务调度器
 */
/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
// 多的任务优先处理，少的任务插缝处理
var leastInterval = function(tasks, n) {
  // map
  const queue = [],
    map = {};
};
```

### 622.设计循环队列

```js
/*
 * @lc app=leetcode.cn id=622 lang=javascript
 *
 * [622] 设计循环队列
 */
/**
 * Initialize your data structure here. Set the size of the queue to be k.
 * @param {number} k
 */
// ✔ Accepted
// ✔ 52 / 52 cases passed(144 ms)
// ✔ Your runtime beats 93.52 % of javascript submissions
// ✔ Your memory usage beats 50 % of javascript submissions(41.7 MB)
var MyCircularQueue = function(k) {
  this.val = [];
  this.maxLength = k;
  this.length = 0;
};

/**
 * Insert an element into the circular queue. Return true if the operation is successful.
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function(value) {
  const { maxLength, length, val } = this;
  if (maxLength - length > 0) {
    val.push(value);
    this.length++;
    return true;
  }
  return false;
};

/**
 * Delete an element from the circular queue. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function() {
  const { maxLength, length, val } = this;
  if (length > 0) {
    val.shift();
    this.length--;
    return true;
  }
  return false;
};

/**
 * Get the front item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Front = function() {
  const { val, length } = this;
  if (length) {
    return val[0];
  }
  return -1;
};

/**
 * Get the last item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function() {
  const { val, length } = this;
  if (length) {
    return val[length - 1];
  }
  return -1;
};

/**
 * Checks whether the circular queue is empty or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function() {
  return this.length === 0;
};

/**
 * Checks whether the circular queue is full or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function() {
  const { maxLength, length } = this;
  return maxLength === length;
};

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * var obj = new MyCircularQueue(k)
 * var param_1 = obj.enQueue(value)
 * var param_2 = obj.deQueue()
 * var param_3 = obj.Front()
 * var param_4 = obj.Rear()
 * var param_5 = obj.isEmpty()
 * var param_6 = obj.isFull()
 */

// const circularQueue = new MyCircularQueue(3); // 设置长度为 3

// console.log(circularQueue.enQueue(1));  // 返回 true
// console.log(circularQueue.enQueue(2));  // 返回 true
// console.log(circularQueue.enQueue(3));  // 返回 true
// console.log(circularQueue.enQueue(4));  // 返回 false，队列已满
// console.log(circularQueue.Rear());  // 返回 3
// console.log(circularQueue.isFull());  // 返回 true
// console.log(circularQueue.deQueue());  // 返回 true
// console.log(circularQueue.enQueue(4));  // 返回 true
// console.log(circularQueue.Rear());
```

### 633.sum-of-square-numbers

```js
/*
 * @lc app=leetcode id=633 lang=javascript
 *
 * [633] Sum of Square Numbers
 * 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。

示例1:

输入: 5
输出: True
解释: 1 * 1 + 2 * 2 = 5


示例2:

输入: 3
输出: False
 */
/**
 * @param {number} c
 * @return {boolean}
 */
var judgeSquareSum = function(c) {
  let start = 0;
  let end = Math.floor(Math.sqrt(c));

  while (start <= end) {
    const powSum = start * start + end * end;
    if (powSum < c) {
      start++;
    } else if (powSum > c) {
      end--;
    } else {
      return true;
    }
  }
  return false;
};

console.log(judgeSquareSum(5));
console.log(judgeSquareSum(3));
```

### 646-Maximum-Length-of-Pair-Chain

```js
/**
 * https://leetcode.com/problems/maximum-length-of-pair-chain/description/
 * Difficulty:Medium
 *
 * You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.
 * Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.
 * Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.
 * Example 1:
 * Input: [[1,2], [2,3], [3,4]]
 * Output: 2
 * Explanation: The longest chain is [1,2] -> [3,4]
 */

/**
 *
 * IN ANY ORDER!
 * SORT FIRST!
 *
 * @param {number[][]} pairs
 * @return {number}
 */
var findLongestChain = function(pairs) {
  var n = pairs.length;
  if (!n) return 0;

  pairs = pairs.sort((a, b) => {
    var diff = a[1] - b[1];
    if (diff > 0) return 1;
    else if (diff === 0) return 0;
    return -1;
  });
  // console.log(pairs);

  var dp = [];
  dp[0] = 1;
  var max = 1;
  for (var i = 1; i < n; i++) {
    var now = pairs[i];
    dp[i] = 1;
    for (var j = 0; j < i; j++) {
      var last = pairs[j];
      if (last[1] < now[0]) {
        dp[i] = Math.max(dp[j] + 1, dp[i]);
      }
    }
  }
  console.log(dp);
  return Math.max(...dp);
};

// console.log(findLongestChain([]));
// console.log(findLongestChain([[1, 2], [2, 3], [3, 4]]));
// console.log(findLongestChain([[1, 2], [3, 4], [5, 46], [1, 2]]));
console.log(
  findLongestChain([
    [3, 4],
    [2, 3],
    [1, 2],
  ]),
);
```

### 647-Palindromic-Substrings

```js
/**
 * https://leetcode.com/problems/palindromic-substrings/description/
 * Difficulty:Medium
 *
 *
 * Given a string, your task is to count how many palindromic substrings in this string.
 *
 * The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
 *
 * Example 1:
 *  Input: "abc"
 *  Output: 3
 *  Explanation: Three palindromic strings: "a", "b", "c".
 *
 * Example 2:
 *  Input: "aaa"
 *  Output: 6
 *  Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
 *
 * Note:
 *  The input string length won't exceed 1000.
 */

/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
  var dp = [];
  var n = s.length;
  for (var i = 0; i < n; i++) {
    dp.push(new Array(n).fill(false));
    // dp[i][i] = 1;
  }
  var cnt = 0;
  for (var i = n - 1; i >= 0; i--) {
    for (var j = i; j < n; j++) {
      if (i === j) dp[i][j] = true;
      else {
        dp[i][j] = s[i] === s[j] ? i + 1 >= j - 1 || dp[i + 1][j - 1] : 0;
      }
      if (dp[i][j]) cnt++;
    }
  }
  // console.log(dp);

  return cnt;
};

// console.log(countSubstrings('abc'));
console.log(countSubstrings('aaaaa'));
```

### 654-Maximum-Binary-Tree

```js
/**
 * https://leetcode.com/problems/maximum-binary-tree/description/
 * Difficulty:Medium
 *
 * Given an integer array with no duplicates.
 * A maximum tree building on this array is defined as follow:
 *
 * The root is the maximum number in the array.
 * The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.
 * The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.
 * Construct the maximum tree by the given array and output the root node of this tree.
 *
 * Example 1:
 * Input: [3,2,1,6,0,5]
 * Output: return the tree root node representing the following tree:
 *     6
 *   /   \
 *  3     5
 *  \    /
 *  2   0
 *   \
 *   1
 * Note:
 * The size of the given array will be in the range [1,1000].
 */

//Definition for a binary tree node.
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
  return helper(nums, 0, nums.length);
};

function helper(nums, s, e) {
  if (e <= s) return null;
  if (s + 1 === e) return new TreeNode(nums[s]);
  else {
    var maxIndex = findMaxIndex(nums, s, e);
    var root = new TreeNode(nums[maxIndex]);
    root.left = helper(nums, s, maxIndex);
    root.right = helper(nums, maxIndex + 1, e);
    return root;
  }
}

function findMaxIndex(nums, s, e) {
  var maxIndex = 0;
  var max = Number.NEGATIVE_INFINITY;
  for (var i = s; i < e; i++) {
    if (nums[i] > max) {
      max = nums[i];
      maxIndex = i;
    }
  }
  return maxIndex;
}

console.log(constructMaximumBinaryTree([3, 2, 1, 6, 0, 5]));
```

### 657-Judge-Route-Circle

```js
/**
 * https://leetcode.com/problems/judge-route-circle/description/
 * Difficulty:Easy
 *
 * Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.
 * The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.
 *
 * Example 1:
 * Input: "UD"
 * Output: true
 *
 * Example 2:
 * Input: "LL"
 * Output: false
 */

/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
  let v = 0;
  let h = 0;
  for (let i = 0; i < moves.length; i++) {
    switch (moves[i]) {
      case 'U':
        v++;
        break;
      case 'D':
        v--;
        break;
      case 'L':
        h--;
        break;
      case 'R':
        h++;
    }
  }
  return v === 0 && h === 0;
};
console.log(judgeCircle('UD'));
console.log(judgeCircle('LL'));
console.log(judgeCircle('UDLLRR'));
```

### 673-Number-of-Longest-Increasing-Subsequence

```js
/**
 * https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/
 * Difficulty:Medium
 *
 * Given an unsorted array of integers, find the number of longest increasing subsequence.
 *
 * Example 1:
 * Input: [1,3,5,4,7]
 * Output: 2
 * Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].
 *
 * Example 2:
 * Input: [2,2,2,2,2]
 * Output: 5
 * Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.
 *
 * Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findNumberOfLIS = function(nums) {
  if (!nums.length) return 0;
  var dp = [];
  var longest = 0;
  for (var i = 0; i < nums.length; i++) {
    var max = 0;
    var count = 0;
    for (var j = 0; j < i; j++) {
      if (nums[j] < nums[i] && dp[j][0] > max) {
        max = dp[j][0];
      }
    }

    for (var j = 0; j < i; j++) {
      if (dp[j][0] === max && nums[j] < nums[i]) {
        count += dp[j][1];
      }
    }

    dp[i] = [max + 1, count ? count : 1];
    longest = Math.max(longest, max + 1);
  }

  return dp.filter(t => t[0] === longest).reduce((a, b) => a + b[1], 0);
};

// console.log(findNumberOfLIS([1, 3, 5, 4, 7]));

console.log(findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]));

// console.log(findNumberOfLIS([1, 3, 5, 4]));
// console.log(findNumberOfLIS([2, 2]));
// console.log(findNumberOfLIS([2]));
// console.log(findNumberOfLIS([2, 2, 2]));
```

### 693-Binary-Number-with-Alternating-Bits

```js
/**
 * https://leetcode.com/problems/binary-number-with-alternating-bits/description/
 * Difficulty:Easy
 *
 * Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.
 *
 * Example 1:
 * Input: 5
 * Output: True
 * Explanation:
 * The binary representation of 5 is: 101
 *
 * Example 2:
 * Input: 7
 * Output: False
 * Explanation:
 * The binary representation of 7 is: 111.
 *
 * Example 3:
 * Input: 11
 * Output: False
 * Explanation:
 * The binary representation of 11 is: 1011.
 *
 * Example 4:
 * Input: 10
 * Output: True
 * Explanation:
 * The binary representation of 10 is: 1010.
 */

/**
 * @param {number} n
 * @return {boolean}
 */
var hasAlternatingBits = function(n) {
  var last = n % 2;
  n = Math.floor(n / 2);

  while (n > 0) {
    var r = n % 2;
    n = Math.floor(n / 2);
    // console.log(last);
    if (r === last) return false;
    last = r;
  }
  return true;
};

console.log(hasAlternatingBits(3));
console.log(hasAlternatingBits(5));
console.log(hasAlternatingBits(7));
console.log(hasAlternatingBits(11));
console.log(hasAlternatingBits(10));
```

### 695-Max-Area-of-Island

```js
/**
 * https://leetcode.com/problems/max-area-of-island/description/
 *
 * Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
 * Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)
 *
 * Example 1:
 * [[0,0,1,0,0,0,0,1,0,0,0,0,0],
 * [0,0,0,0,0,0,0,1,1,1,0,0,0],
 * [0,1,1,0,1,0,0,0,0,0,0,0,0],
 * [0,1,0,0,1,1,0,0,1,0,1,0,0],
 * [0,1,0,0,1,1,0,0,1,1,1,0,0],
 * [0,0,0,0,0,0,0,0,0,0,1,0,0],
 * [0,0,0,0,0,0,0,1,1,1,0,0,0],
 * [0,0,0,0,0,0,0,1,1,0,0,0,0]]
 * Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.
 *
 * Example 2:
 * [[0,0,0,0,0,0,0,0]]
 * Given the above grid, return 0.
 *
 * Note: The length of each dimension in the given grid does not exceed 50.
 *
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxAreaOfIsland = function(grid) {
  var dp = [];
  var m = grid.length;
  if (!m) return 0;
  var n = grid[0].length;
  if (!n) return 0;
  while (dp.push(new Array(n).fill(0)) < m);
  var max = 0;
  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      max = Math.max(dfs(grid, dp, i, j), max);
    }
  }

  // console.log(dp);

  return max;
};

function dfs(grid, dp, i, j) {
  var m = grid.length;
  var n = grid[0].length;

  if (i < 0 || i > m - 1) return 0;
  if (j < 0 || j > n - 1) return 0;
  // console.log(i, j, grid[i][j]);
  if (grid[i][j] === 0) dp[i][j] = -1;
  if (dp[i][j] === 0) {
    dp[i][j] = -1;
    dp[i][j] =
      1 + dfs(grid, dp, i, j - 1) + dfs(grid, dp, i + 1, j) + dfs(grid, dp, i, j + 1) + dfs(grid, dp, i - 1, j);
    return dp[i][j];
  }
  return 0;
}

console.log(
  maxAreaOfIsland([
    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
  ]),
);

console.log(
  maxAreaOfIsland([
    [1, 1, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 0, 1, 1],
  ]),
);
console.log(maxAreaOfIsland([[0, 0, 1, 0, 0, 1, 1, 0]]));
```

### 718-Maximum-Length-of-Repeated-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/
 * Difficulty:Medium
 *
 * Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
 *
 * Example 1:
 * Input:
 * A: [1, 2, 3, 2, 1]
 * B: [3, 2, 1, 4, 7, 8]
 * Output: 3
 * Explanation:
 * The repeated subarray with maximum length is [3, 2, 1].
 *
 * Note:
 * 1 <= len(A), len(B) <= 1000
 * 0 <= A[i], B[i] < 100
 *
 */

/**
 * 解题思路
 *
 * 动态规划
 *
 * dp[i][j] 以 A[i-1] B[j-1] 结尾的最长子串长度
 * dp[i][j] = A[i - 1] === B[j - 1] ? dp[i - 1][j - 1] + 1 : 0;
 *
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
  var m = A.length;
  var n = B.length;
  if (m * n === 0) return 0;
  var dp = [];
  var max = 0;
  for (var i = 0; i <= m; i++) {
    dp.push(new Array(n + 1).fill(0));
  }

  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      dp[i][j] = A[i - 1] === B[j - 1] ? dp[i - 1][j - 1] + 1 : 0;
      max = Math.max(max, dp[i][j]);
    }
  }
  // console.log(dp);

  return max;
};

console.log(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7, 8]));
```

### 728-Self-Dividing-Numbers

```js
/**
 * https://leetcode.com/problems/self-dividing-numbers/description/
 * Difficulty:Easy
 *
 * A self-dividing number is a number that is divisible by every digit it contains.
 *
 * For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
 * Also, a self-dividing number is not allowed to contain the digit zero.
 * Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.
 *
 * Example 1:
 * Input:
 * left = 1, right = 22
 * Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
 * Note:
 * The boundaries of each input argument are 1 <= left <= right <= 10000.
 */

/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function(left, right) {
  var res = [];
  for (var i = left; i <= right; i++) {
    if (isSelfDividingNumber(i)) res.push(i);
  }
  return res;
};

function isSelfDividingNumber(n) {
  var t = n;
  if (!t) return false;
  while (t) {
    var r = t % 10;
    t = Math.floor(t / 10);
    if (!r) return false;
    if (n % r) return false;
  }
  return true;
}

console.log(selfDividingNumbers(1, 22));
```

### 744.寻找比目标字母大的最小字母

```js
/*
 * @lc app=leetcode.cn id=744 lang=javascript
 *
 * [744] 寻找比目标字母大的最小字母
 * 给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。

数组里字母的顺序是循环的。举个例子，如果目标字母target = 'z' 并且有序数组为 letters = ['a', 'b']，则答案返回 'a'。

示例:

输入:
letters = ["c", "f", "j"]
target = "a"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "c"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "d"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "g"
输出: "j"

输入:
letters = ["c", "f", "j"]
target = "j"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "k"
输出: "c"
注:

letters长度范围在[2, 10000]区间内。
letters 仅由小写字母组成，最少包含两个不同的字母。
目标字母target 是一个小写字母。
 */
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
// 二分查找
var nextGreatestLetter = function(letters, target) {
  const n = letters.length;
  let l = 0,
    r = n - 1,
    mid,
    resp;
  while (l <= r) {
    mid = (l + r) >> 1;
    if (letters[mid] === target) {
      // 命中继续取下一个，避免重复的数据
      l = mid + 1;
    } else if (letters[mid] > target) {
      r = mid - 1;
    } else {
      l = mid + 1;
    }
  }
  // 二分查找最终结束，必定是 l === r + 1
  return l < n ? letters[l] : letters[0];
};

// console.log(nextGreatestLetter(["e", "e", "e", "e", "e", "e", "n", "n", "n", "n"], 'e'))
// console.log(nextGreatestLetter([2, 3, 4], 5))
// console.log(nextGreatestLetter([1, 3, 4], 1))
```

### 766

```js
// 766. Toeplitz Matrix

// A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.

// Now given an M x N matrix, return True if and only if the matrix is Toeplitz.

// Example 1:

// Input:
// matrix = [
//   [1,2,3,4],
//   [5,1,2,3],
//   [9,5,1,2]
// ]
// Output: True
// Explanation:
// In the above grid, the diagonals are:
// "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
// In each diagonal all elements are the same, so the answer is True.
// Example 2:

// Input:
// matrix = [
//   [1,2],
//   [2,2]
// ]
// Output: False
// Explanation:
// The diagonal "[1, 2]" has different elements.

// Note:

// matrix will be a 2D array of integers.
// matrix will have a number of rows and columns in range [1, 20].
// matrix[i][j] will be integers in range [0, 99].

// Follow up:

// What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?
// What if the matrix is so large that you can only load up a partial row into the memory at once?

// Time: O(n*m)
// Space: O(1)

function checkDiag(arr, i, j, c, r, v) {
  for (; c < j && r < i; c++, r++) {
    if (arr[r][c] !== v) return false;
  }
  return true;
}

export default function isToeplitzMatrix(arr) {
  if (!arr.length) return true;
  const i = arr.length;
  const j = arr[0].length;
  for (let c = 0; c < arr[0].length; c++) {
    if (!checkDiag(arr, i, j, c, 0, arr[0][c])) return false;
  }
  for (let r = 0; r < arr.length; r++) {
    if (!checkDiag(arr, i, j, 0, r, arr[r][0])) return false;
  }
  return true;
}
```

### 796.旋转字符串

```js
/*
 * @lc app=leetcode.cn id=796 lang=javascript
 *
 * [796] 旋转字符串
 */
/**
 * @param {string} A
 * @param {string} B
 * @return {boolean}
 */
var rotateString = function(A, B) {
  // let offset =
  for (let i = 0; i < A.length; i++) {
    const index = B.indexOf(A[i]);
    if (index === -1) return false;
  }
};

// 1. 找到最长公共子串 如果没有，false
// 2. 截取剩余部分，是否相等
```

### 832

```js
// 832. Flipping an Image

// Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.

// To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].

// To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].

/**
 * @param {number[][]} A
 * @return {number[][]}
 */
export default function flipAndInvertImage(A) {
  // Take the transpose of the matrix
  for (let i = 0; i < A.length; i++) {
    // Flip each row
    for (let j = 0; j < Math.floor(A[i].length / 2); j++) {
      const a = A[i][j];
      const b = A[i][A[i].length - 1 - j];
      A[i][j] = b === 0 ? 1 : 0;
      A[i][A[i].length - 1 - j] = a === 0 ? 1 : 0;
    }
    if (A[i].length % 2 !== 0) {
      A[i][Math.floor(A[i].length / 2)] = A[i][Math.floor(A[i].length / 2)] === 0 ? 1 : 0;
    }
  }
  return A;
}
```

### 876

```js
// This solution uses the 'runner method' mentioned in CTCI

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function middleNode(head) {
  if (!head) return null;
  let next = head;
  let nextNext = head;

  while (next.next && nextNext && nextNext.next && nextNext.next.next) {
    next = next.next;
    nextNext = nextNext.next.next;
  }

  if (nextNext.next) {
    return next.next;
  }

  return next;
}
```

### 905.按奇偶排序数组

```js
/*
 * @lc app=leetcode.cn id=905 lang=javascript
 *
 * [905] 按奇偶排序数组
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParity = function(nums) {
  // 好像不关排序的事情。。。。
  const result = [];
  let length = nums.length,
    start = 0,
    end = length - 1;
  for (let i = 0; i < length; i++) {
    if (nums[i] % 2 === 0) {
      result[start] = nums[i];
      start++;
    } else {
      result[end] = nums[i];
      end--;
    }
  }
  return result;
};

console.log(sortArrayByParity([4, 2, 5, 7]));
console.log(sortArrayByParity([3, 1, 2, 4]));
```

### 912.排序数组

```js
/*
 * @lc app=leetcode.cn id=912 lang=javascript
 *
 * [912] 排序数组
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
  if (nums.length < 2) return nums;
  return quickSort(nums);
};

const quickSort = (arr, start = 0, end = arr.length - 1) => {
  if (start >= end) return;
  let i = start,
    j = end,
    target = arr[start];

  while (i < j) {
    while (i < j && arr[j] >= target) j--;
    while (i < j && arr[i] <= target) i++;

    if (i < j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[start], arr[j]] = [arr[j], arr[start]];
  quickSort(arr, start, i - 1);
  quickSort(arr, i + 1, end);

  return arr;
};

console.log(sortArray([5, 2, 3, 1]));
console.log(sortArray([5, 1, 1, 2, 0, 0]));
```

### 914.卡牌分组

```js
/*
 * @lc app=leetcode.cn id=914 lang=javascript
 *
 * [914] 卡牌分组
 */
/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
  // 统计数字个数
  const numMap = {};
  for (let i = 0; i < deck.length; i++) {
    if (!numMap[deck[i]]) {
      numMap[deck[i]] = 1;
    } else {
      numMap[deck[i]]++;
    }
  }
  const valuesArr = Object.values(numMap).sort((a, b) => (a > b ? 1 : -1));
  // console.log('valuesArr', valuesArr)
  // 也就是说最大公约数得大于 1
  return !valuesArr.find(value => gcd(value, valuesArr[0]) === 1 || value < 2);
};

// 欧里几德算法，辗转相除法。
function gcd(a, b) {
  if (b == 0) {
    return a;
  }
  var r = parseInt(a % b);
  return gcd(b, r);
}

console.log(hasGroupsSizeX([1, 2, 3, 4, 4, 3, 2, 1]));
console.log(hasGroupsSizeX([1, 1, 1, 2, 2, 2, 3, 3]));
console.log(hasGroupsSizeX([1]));
console.log(hasGroupsSizeX([1, 1]));
console.log(hasGroupsSizeX([1, 1, 2, 2, 2, 2]));
console.log(hasGroupsSizeX([1, 1, 1, 1, 2, 2, 2, 2, 2, 2]));
```

### 917.仅仅反转字母

```js
/*
 * @lc app=leetcode.cn id=917 lang=javascript
 *
 * [917] 仅仅反转字母
 *
 * 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。



示例 1：

输入："ab-cd"
输出："dc-ba"
示例 2：

输入："a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
示例 3：

输入："Test1ng-Leet=code-Q!"
输出："Qedo1ct-eeLg=ntse-T!"


提示：

S.length <= 100
33 <= S[i].ASCIIcode <= 122
S 中不包含 \ or "
 */
/**
 * @param {string} S
 * @return {string}
 */
var reverseOnlyLetters = function(S) {
  S = S.split('');
  let left = 0,
    right = S.length - 1,
    temp;
  const reg = /[a-zA-Z]/;
  while (left < right) {
    while (!reg.test(S[left])) left++;
    while (!reg.test(S[right])) right--;
    if (left < right) {
      [S[left], S[right]] = [S[right], S[left]];
      left++;
      right--;
    }
  }
  return S.join('');
};

// console.log(reverseOnlyLetters('ab-cd'))
// console.log(reverseOnlyLetters('ab'))
console.log(reverseOnlyLetters('a-bC-dEf-ghIj'));
// console.log(reverseOnlyLetters('Test1ng-Leet=code-Q!'))
// console.log(reverseOnlyLetters(''))
```

### 922.按奇偶排序数组-ii

```js
/*
 * @lc app=leetcode.cn id=922 lang=javascript
 *
 * [922] 按奇偶排序数组 II
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParityII = function(nums) {
  // 好像不关排序的事情。。。。
  const result = [];
  let even = 0,
    odd = 1;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 === 0) {
      result[even] = nums[i];
      even += 2;
    } else {
      result[odd] = nums[i];
      odd += 2;
    }
  }
  return result;
};

console.log(sortArrayByParityII([4, 2, 5, 7]));
```

### 958.check-completeness-of-a-binary-tree

```js
/*
 * @lc app=leetcode id=958 lang=javascript
 *
 * [958] Check Completeness of a Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isCompleteTree = function(root) {
  if (root === null) return root;
  let cur = root;
  const queue = [];

  while (cur !== null) {
    queue.push(cur.left);
    queue.push(cur.right);
    cur = queue.shift();
  }

  return queue.filter(Boolean).length === 0;
};
```

### 977.有序数组的平方

```js
/*
 * @lc app=leetcode.cn id=977 lang=javascript
 *
 * [977] 有序数组的平方
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */

// 使用双指针，一个用来移动负数， 一个用来移动正数
var sortedSquares = function(A) {
  let i = 0;
  while (i < A.length && A[i] < 0) {
    i++;
  }
  let j = i--,
    resp = [];
  while (i >= 0 && j < A.length) {
    if (Math.abs(A[i]) < Math.abs(A[j])) {
      resp.push(A[i] * A[i]);
      i--;
    } else {
      resp.push(A[j] * A[j]);
      j++;
    }
  }
  while (i >= 0) {
    resp.push(A[i] * A[i]);
    i--;
  }
  while (j < A.length) {
    resp.push(A[j] * A[j]);
    j++;
  }
  return resp;
};

// console.log(sortedSquares([-4, -1, 0, 3, 10]))
// console.log(sortedSquares([-1]))
```

### Add Binary

```js
/**
Given two binary strings, return their sum (also a binary string).

For example,
a = "11"
b = "1"
Return "100".
*/

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
  var lenA = a.length,
    lenB = b.length,
    overFlow = 0,
    charA,
    charB,
    result = '',
    curVal,
    i,
    j;

  for (i = lenA - 1, j = lenB - 1; i >= 0 && j >= 0; i--, j--) {
    charA = parseInt(a.charAt(i));
    charB = parseInt(b.charAt(j));

    curVal = charA + charB + overFlow;

    if (curVal > 1) {
      curVal = curVal - 2;
      overFlow = 1;
    } else {
      overFlow = 0;
    }

    result = curVal + result;
  }

  while (i >= 0) {
    charA = parseInt(a.charAt(i));
    curVal = charA + overFlow;

    if (curVal > 1) {
      curVal = curVal - 2;
      overFlow = 1;
    } else {
      overFlow = 0;
    }
    result = curVal + result;

    i--;
  }

  while (j >= 0) {
    charB = parseInt(b.charAt(j));
    curVal = charB + overFlow;

    if (curVal > 1) {
      curVal = curVal - 2;
      overFlow = 1;
    } else {
      overFlow = 0;
    }

    result = curVal + result;

    j--;
  }

  if (overFlow === 1) {
    result = '1' + result;
  }

  return result;
};
```

### Add Digits

```js
/**
Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.

For example:

Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.

Follow up:
Could you do it without any loop/recursion in O(1) runtime?

Hint:

A naive implementation of the above process is trivial. Could you come up with other methods?
What are all the possible results?
How do they occur, periodically or randomly?
You may find this Wikipedia article useful.
*/

/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {
  return ((num - 1) % 9) + 1;
};
```

### Add Two Numbers

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  var val = 0,
    newHead,
    newTail,
    node;

  if (!l1) {
    return l2;
  }

  if (!l2) {
    return l1;
  }

  while (l1 && l2) {
    val += l1.val + l2.val;
    node = new ListNode(val % 10);

    if (newHead) {
      newTail.next = node;
      newTail = newTail.next;
    } else {
      newHead = node;
      newTail = node;
    }

    val = val >= 10 ? 1 : 0;
    l1 = l1.next;
    l2 = l2.next;
  }

  while (l1) {
    val += l1.val;
    node = new ListNode(val % 10);
    newTail.next = node;
    newTail = newTail.next;
    val = val >= 10 ? 1 : 0;
    l1 = l1.next;
  }

  while (l2) {
    val += l2.val;
    node = new ListNode(val % 10);
    newTail.next = node;
    newTail = newTail.next;
    val = val >= 10 ? 1 : 0;
    l2 = l2.next;
  }

  if (val > 0) {
    node = new ListNode(val);
    newTail.next = node;
  }

  return newHead;
};
```

### Add and Search Word - Data structure design

```js
/**
Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

For example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
Note:
You may assume that all words are consist of lowercase letters a-z.

click to show hint.

You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.
*/

// MEMORY LIMIT EXCEEDED...

/**
 * @constructor
 */

var WordDictionary = function() {
  this.root = TrieNode();
};

var TrieNode = function() {
  var isEnd,
    links = {};

  return {
    containsKey: function(n) {
      return links[n] !== undefined;
    },
    get: function(ch) {
      return links[ch];
    },
    put: function(ch, node) {
      links[ch] = node;
    },
    setEnd: function() {
      isEnd = true;
    },
    isEnd: function() {
      return isEnd;
    },
    getLinks: function() {
      return links;
    },
  };
};

/**
 * @param {string} word
 * @return {void}
 * Adds a word into the data structure.
 */
WordDictionary.prototype.addWord = function(word) {
  var len = word.length,
    node = this.root,
    ch,
    i;

  for (i = 0; i < len; i++) {
    ch = word.charAt(i);

    if (!node.containsKey(ch)) {
      node.put(ch, TrieNode());
    }

    node = node.get(ch);
  }

  node.setEnd();
};

/**
 * @param {string} word
 * @return {boolean}
 * Returns if the word is in the data structure. A word could
 * contain the dot character '.' to represent any one letter.
 */
WordDictionary.prototype.search = function(word) {
  var node = this.root;

  return this.searchHelper(word, node, 0);
};

WordDictionary.prototype.searchHelper = function(word, node, index) {
  var links, ch, i, j;

  if (index === word.length) {
    if (node.isEnd()) {
      return true;
    }

    return false;
  }

  ch = word.charAt(index);

  if (ch === '.') {
    links = node.getLinks();

    for (j in links) {
      if (this.searchHelper(word, links[j], index + 1)) {
        return true;
      }
    }
  } else if (node.containsKey(ch)) {
    return this.searchHelper(word, node.get(ch), index + 1);
  }
  return false;
};
/**
 * Your WordDictionary object will be instantiated and called as such:
 * var wordDictionary = new WordDictionary();
 * wordDictionary.addWord("word");
 * wordDictionary.search("pattern");
 */
```

### Additive Number

```js
/**
Additive number is a string whose digits can form additive sequence.

A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.

For example:
"112358" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.

1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
"199100199" is also an additive number, the additive sequence is: 1, 99, 100, 199.
1 + 99 = 100, 99 + 100 = 199
Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.

Given a string containing only digits '0'-'9', write a function to determine if it's an additive number.

Follow up:
How would you handle overflow for very large input integers?
*/
/**
 * @param {string} num
 * @return {boolean}
 */
var isAdditiveNumber = function(num) {
  var len = num.length,
    i,
    j;

  for (i = 1; i <= len / 2; i++) {
    for (j = 1; j <= len / 2; j++) {
      if (canBeAdded(num.substr(0, i), num.substr(i, j), num.substr(i + j))) {
        return true;
      }
    }
  }

  return false;
};

function canBeAdded(a, b, c) {
  if (
    (a.length > 1 && a.charAt(0) === '0') ||
    (b.length > 1 && b.charAt(0) === '0') ||
    (c.length >= 1 && c.charAt(0) === '0')
  ) {
    return false;
  }

  var aNum = parseInt(a),
    bNum = parseInt(b),
    sum = aNum + bNum + '';

  if (c === sum) {
    return true;
  }

  if (c.substr(0, sum.length) !== sum) {
    return false;
  }

  return canBeAdded(b, sum, c.substr(sum.length));
}
```

### Alien Dictionary

```js
/**
There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

For example,
Given the following words in dictionary,

[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]
The correct order is: "wertf".

Note:
You may assume all letters are in lowercase.
If the order is invalid, return an empty string.
There may be multiple valid order of letters, return any one of them is fine.
*/
/**
 * @param {string[]} words
 * @return {string}
 */
var alienOrder = function(words) {
  if (words.length === 0) {
    return '';
  }

  const len = words.length;
  let map = {}; // value is the prerequisite of key
  let charPreReqCount = {};
  let i;
  let queue = [];
  let result = [];
  let hasCycle = false;

  for (i = 0; i < len; i++) {
    const chars = words[i].split('');

    let j = 0;

    for (j = 0; j < chars.length; j++) {
      if (!map[chars[j]]) {
        map[chars[j]] = [];
        charPreReqCount[chars[j]] = 0;
      }
    }

    if (i === 0 || words[i] === words[i - 1]) {
      continue;
    }

    const cur = words[i];
    const prev = words[i - 1];
    j = 0;

    while (j < cur.length && j < prev.length && cur.charAt(j) === prev.charAt(j)) {
      j++;
    }

    if (j < prev.length && map[prev.charAt(j)].indexOf(cur.charAt(j)) === -1) {
      map[prev.charAt(j)].push(cur.charAt(j));

      charPreReqCount[cur.charAt(j)]++;
    }
  }

  Object.keys(charPreReqCount).forEach(char => {
    if (charPreReqCount[char] === 0) {
      queue.push(char);
    }
  });

  while (queue.length > 0) {
    const char = queue.shift();

    result.push(char);

    for (i = 0; i < map[char].length; i++) {
      charPreReqCount[map[char][i]]--;

      if (charPreReqCount[map[char][i]] === 0) {
        queue.push(map[char][i]);
      }
    }
  }

  // detect cycle
  Object.keys(charPreReqCount).forEach(function(char) {
    if (charPreReqCount[char] !== 0) {
      hasCycle = true;
    }
  });

  return hasCycle ? '' : result.join('');
};
```

### Anagrams

```js
/**
Given an array of strings, return all groups of strings that are anagrams.

Note: All inputs will be in lower-case.
*/

/**
 * @param {string[]} strs
 * @return {string[]}
 */
var anagrams = function(strs) {
  var map = {},
    len = strs.length,
    curStr,
    newArr,
    sortedArr,
    sortedStr,
    result = [],
    i;

  for (i = 0; i < len; i++) {
    curStr = strs[i];
    sortedArr = curStr.split('');
    sortedStr = sortedArr.sort().join('');

    if (map.hasOwnProperty(sortedStr)) {
      map[sortedStr].push(curStr);
    } else {
      newArr = [];
      newArr.push(curStr);
      map[sortedStr] = newArr;
    }
  }

  len = map.length;

  for (var key in map) {
    if (map[key].length > 1) {
      result = result.concat(map[key]);
    }
  }

  return result;
};
```

### Balanced Binary Tree

```js
/**
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
*/

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
  return findDepth(root) === -1 ? false : true;
};

function findDepth(root) {
  if (root === null) {
    return 0;
  }

  var leftDepth = findDepth(root.left),
    rightDepth;

  if (leftDepth === -1) {
    return -1;
  }

  rightDepth = findDepth(root.right);

  if (rightDepth === -1) {
    return -1;
  }

  if (Math.abs(leftDepth - rightDepth) > 1) {
    return -1;
  }

  return Math.max(leftDepth, rightDepth) + 1;
}
```

### Basic Calculator II

```js
/**
Implement a basic calculator to evaluate a simple expression string.

The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.

You may assume that the given expression is always valid.

Some examples:
"3+2*2" = 7
" 3/2 " = 1
" 3+5 / 2 " = 5
Note: Do not use the eval built-in library function.
*/
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  var signs = [],
    nums = [],
    len = s.length,
    num = 0,
    ch,
    i,
    j;

  for (i = 0; i < len; i++) {
    ch = s.charAt(i);

    if (!isNaN(parseInt(ch))) {
      num = 0;
      for (j = i; j < len && !isNaN(parseInt(s.charAt(j))); j++) {
        num = num * 10 + parseInt(s.charAt(j));
      }

      i = j - 1;
      nums.push(num);
    } else if (ch === '-' || ch === '+' || ch === '*' || ch === '/') {
      signs.push(ch);
    }
  }

  for (i = 0; i < signs.length; ) {
    if (signs[i] === '*') {
      num = nums[i] * nums[i + 1];
      nums.splice(i, 2, num);
      signs.splice(i, 1);
    } else if (signs[i] === '/') {
      num = Math.floor(nums[i] / nums[i + 1]);
      nums.splice(i, 2, num);
      signs.splice(i, 1);
    } else {
      i++;
    }
  }

  num = nums.shift();
  for (i = 0; i < signs.length; i++) {
    if (signs[i] === '+') {
      num += nums.shift();
    } else if (signs[i] === '-') {
      num -= nums.shift();
    }
  }

  return num;
};
```

### Basic Calculator

```js
/**
Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .

You may assume that the given expression is always valid.

Some examples:
"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23
Note: Do not use the eval built-in library function.
*/
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  var stack = [],
    len = s.length,
    sum = 0,
    num,
    ch,
    j,
    i;

  stack.push(1);
  stack.push(1);

  for (i = 0; i < len; i++) {
    ch = s.charAt(i);

    if (!isNaN(parseInt(ch))) {
      num = parseInt(ch);

      for (j = i + 1; j < len && !isNaN(parseInt(s.charAt(j))); j++) {
        num = num * 10 + parseInt(s.charAt(j));
      }

      sum += stack.pop() * num;

      i = j - 1;
    } else if (ch === '+' || ch === '(') {
      stack.push(stack[stack.length - 1]);
    } else if (ch === '-') {
      stack.push(stack[stack.length - 1] * -1);
    } else if (ch === ')') {
      stack.pop();
    }
  }

  return sum;
};
```

### Best Time to Buy and Sell Stock II

```js
/**
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  var i,
    length = prices.length,
    low,
    high,
    cur,
    prev,
    temp = 0;
  max = 0;

  if (length === 0 || length === 1) {
    return max;
  }
  low = prices[0];
  high = prices[0];
  prev = low;
  for (i = 1; i < length; i++) {
    cur = prices[i];
    if (cur > prev) {
      high = cur;
      temp = high - low;
    } else if (cur < prev) {
      max += temp;
      temp = 0;
      low = cur;
      high = cur;
    }
    prev = cur;
  }
  if (temp !== 0) {
    max += temp;
  }
  return max;
};
```

### Best Time to Buy and Sell Stock III

```js
/**
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
*/
/**
 * @param {number[]} prices
 * @return {number}
 *
 * 数组l[i]记录了price[0..i]的最大profit，
 * 数组r[i]记录了price[i..n]的最大profit。
 * 已知l[i]，求l[i+1]是简单的，同样已知r[i]，求r[i-1]也很容易。
 * 最后，我们再用O(n)的时间找出最大的l[i]+r[i]，即为题目所求。
 */
var maxProfit = function(prices) {
  var len = prices.length,
    l = [],
    r = [],
    i,
    max,
    min;

  l[0] = 0;
  min = prices[0];

  for (i = 1; i < len; i++) {
    l[i] = Math.max(l[0], prices[i] - min);
    min = Math.min(min, prices[i]);
  }

  r[len - 1] = 0;
  max = prices[len - 1];

  for (i = len - 2; i >= 0; i--) {
    r[i] = Math.max(r[i + 1], max - prices[i]);
    max = Math.max(max, prices[i]);
  }

  max = 0;

  for (i = 0; i < len; i++) {
    max = Math.max(max, l[i] + r[i]);
  }

  return max;
};
```

### Best Time to Buy and Sell Stock with Cooldown

```js
/**
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:

prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
*/
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  var len = prices.length,
    buy = [],
    sell = [],
    i;

  if (len < 2) {
    return 0;
  }

  // buy[i] 是指在第i天手上持有股票的最大收益
  // sell[i] 是指在第i天手上没有股票的最大收益
  buy[0] = 0 - prices[0];
  buy[1] = Math.max(0 - prices[0], 0 - prices[1]);
  sell[0] = 0;
  sell[1] = Math.max(0, buy[0] + prices[1]);

  for (i = 2; i < len; i++) {
    buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
    sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
  }

  return sell[len - 1];
};
```

### Best Time to Buy and Sell Stock

```js
/**
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  var i,
    length = prices.length,
    low,
    high,
    max = 0,
    cur;

  if (length === 0) {
    return 0;
  }
  low = prices[0];
  high = low;
  for (i = 1; i < length; i++) {
    cur = prices[i];
    if (cur > high) {
      high = cur;
    } else if (cur < low) {
      //need to reset low and high in order to make sure you need to buy before you sell
      low = cur;
      high = cur;
    }
    if (high - low > max) {
      max = high - low;
    }
  }
  return max;
};
```

### Binary Search Tree Iterator

```js
/**
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
*/
/**
 * Definition for binary tree
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @constructor
 * @param {TreeNode} root - root of the binary search tree
 */
var BSTIterator = function(root) {
  this.stack = [];

  while (root) {
    this.stack.push(root);
    root = root.left;
  }
};

/**
 * @this BSTIterator
 * @returns {boolean} - whether we have a next smallest number
 */
BSTIterator.prototype.hasNext = function() {
  return this.stack.length > 0;
};

/**
 * @this BSTIterator
 * @returns {number} - the next smallest number
 */
BSTIterator.prototype.next = function() {
  var node = this.stack.pop(),
    result = node.val;

  node = node.right;
  while (node) {
    this.stack.push(node);
    node = node.left;
  }

  return result;
};

/**
 * Your BSTIterator will be called like this:
 * var i = new BSTIterator(root), a = [];
 * while (i.hasNext()) a.push(i.next());
 */
```

### Binary Tree Inorder Traversal

```js
/**
Given a binary tree, return the inorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,3,2].

Note: Recursive solution is trivial, could you do it iteratively?

 * Definition for binary tree
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @returns {number[]}
 */
var inorderTraversal = function(root) {
  var stack = [],
    result = [],
    cur;
  cur = root;
  while (stack.length > 0 || cur !== null) {
    if (cur !== null) {
      stack.push(cur);
      cur = cur.left;
    } else {
      cur = stack.pop();
      result.push(cur.val);
      cur = cur.right;
    }
  }
  return result;
};
```

### Binary Tree Level Order Traversal II

```js
/**
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrderBottom = function(root) {
  var result = [],
    parent = [],
    parentData,
    cur;

  if (root === null) {
    return result;
  }

  parent.push(root);

  while (parent.length > 0) {
    cur = [];
    parentData = [];

    for (var i in parent) {
      parent[i].left ? cur.push(parent[i].left) : null;
      parent[i].right ? cur.push(parent[i].right) : null;
      parentData.push(parent[i].val);
    }

    result.unshift(parentData);

    parent = cur;
  }

  return result;
};
```

### Binary Tree Maximum Path Sum

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
  var max = [];

  max[0] = Number.NEGATIVE_INFINITY;
  getMaxValueToParent(root, max);

  return max[0];
};

/**
 * This function returns the max value that contains current node to its parent
 */
function getMaxValueToParent(root, max) {
  if (root === null) {
    return 0;
  }

  var left = getMaxValueToParent(root.left, max),
    right = getMaxValueToParent(root.right, max),
    maxPathAcrossRootNotToParent = root.val + left + right, // path that contains current node and will not go to its parent
    maxPathAcrossRootToParent = Math.max(root.val, root.val + Math.max(left, right));

  max[0] = Math.max(max[0], maxPathAcrossRootNotToParent, maxPathAcrossRootToParent);

  return maxPathAcrossRootToParent;
}
```

### Binary Tree Paths

```js
/**
Given a binary tree, return all root-to-leaf paths.

For example, given the following binary tree:

   1
 /   \
2     3
 \
  5
All root-to-leaf paths are:

["1->2->5", "1->3"]
*/

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
  var result = [];

  getPaths(root, null, result);

  return result;
};

function getPaths(node, curStr, result) {
  if (node === null) {
    return;
  }

  if (!curStr) {
    curStr = '' + node.val;
  } else {
    curStr += '->' + node.val;
  }

  if (node.left) {
    getPaths(node.left, curStr, result);
  }

  if (node.right) {
    getPaths(node.right, curStr, result);
  }

  if (!node.left && !node.right) {
    result.push(curStr);
  }
}
```

### Binary Tree Preorder Traversal

```js
/**

Given a binary tree, return the preorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,2,3].

Note: Recursive solution is trivial, could you do it iteratively

 * Definition for binary tree
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @returns {number[]}
 */
var preorderTraversal = function(root) {
  var store = [],
    result = [],
    cur;
  if (root === null) {
    return store;
  }
  store.push(root);
  while (store.length > 0) {
    cur = store.pop();
    result.push(cur.val);
    if (cur.right) {
      store.push(cur.right);
    }
    if (cur.left) {
      store.push(cur.left);
    }
  }
  return result;
};
```

### Binary Tree Right Side View

```js
/**
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

For example:
Given the following binary tree,
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
You should return [1, 3, 4].
*/

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
  var queue = [],
    result = [],
    i,
    len;

  if (!root) {
    return result;
  }

  queue.push(root);

  while (queue.length > 0) {
    len = queue.length;

    for (i = 0; i < len; i++) {
      node = queue.shift();

      // first one is the right most
      if (i === 0) {
        result.push(node.val);
      }

      if (node.right) {
        queue.push(node.right);
      }

      if (node.left) {
        queue.push(node.left);
      }
    }
  }

  return result;
};
```

### Binary Tree Upside Down

```js
/**
 Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.
For example:
Given a binary tree {1,2,3,4,5},

    1
   / \
  2   3
 / \
4   5

return the root of the binary tree [4,5,2,#,#,3,1].

   4
  / \
 5   2
    / \
   3   1

confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var upsideDownBinaryTree = function(root) {
  if (!root || (!root.left && !root.right)) {
    return root;
  }

  let newRoot = upsideDownBinaryTree(root.left);

  root.left.left = root.right;
  root.left.right = root;

  root.left = null;
  root.right = null;

  return newRoot;
};
```

### Binary Tree Vertical Order Traversal

```js
/**
Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).

If two nodes are in the same row and column, the order should be from left to right.

Examples:

    Given binary tree [3,9,20,null,null,15,7],

       3
      /\
     /  \
     9  20
        /\
       /  \
      15   7

    return its vertical order traversal as:

    [
      [9],
      [3,15],
      [20],
      [7]
    ]

    Given binary tree [3,9,8,4,0,1,7],

         3
        /\
       /  \
       9   8
      /\  /\
     /  \/  \
     4  01   7

    return its vertical order traversal as:

    [
      [4],
      [9],
      [3,0,1],
      [8],
      [7]
    ]

    Given binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5),

         3
        /\
       /  \
       9   8
      /\  /\
     /  \/  \
     4  01   7
        /\
       /  \
       5   2

    return its vertical order traversal as:

    [
      [4],
      [9,5],
      [3,0,1],
      [8,2],
      [7]
    ]


*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

function TreeColumnNode(col, node) {
  this.col = col;
  this.treeNode = node;
}
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var verticalOrder = function(root) {
  let col = 0;
  let node = root;
  let queue = [];
  let result = [];
  let map = {};
  let min = 0;
  let max = 0;

  if (!node) {
    return result;
  }

  queue.push(new TreeColumnNode(0, root));

  while (queue.length > 0) {
    const node = queue.shift();

    if (map[node.col] === undefined) {
      map[node.col] = [];
    }

    map[node.col].push(node.treeNode.val);

    if (node.treeNode.left) {
      queue.push(new TreeColumnNode(node.col - 1, node.treeNode.left));
      min = Math.min(min, node.col - 1);
    }

    if (node.treeNode.right) {
      queue.push(new TreeColumnNode(node.col + 1, node.treeNode.right));
      max = Math.max(max, node.col + 1);
    }
  }

  for (let i = min; i <= max; i++) {
    result.push(map[i]);
  }

  return result;
};

function helper(node, col, arr) {
  if (!node) {
    return;
  }

  if (node.left) {
    if (arr[col] === undefined) {
      arr[col - 1] = [];
    }

    arr[col - 1].push(node.left);
  }

  if (node.right) {
    if (arr[col] === undefined) {
      arr[col + 1] = [];
    }

    arr[col + 1].push(node.right);
  }

  helper(node.left, col - 1, arr);
  helper(node.right, col + 1, arr);
}
```

### Binary Tree Zigzag Level Order Traversal

```js
/**
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  var result = [],
    cur = [],
    left = true,
    i,
    len,
    temp,
    next;

  if (!root) {
    return result;
  }

  cur.push(root);

  while (cur.length > 0) {
    len = cur.length;
    temp = [];
    next = [];

    for (i = 0; i < len; i++) {
      temp.push(cur[i].val);

      if (cur[i].left) {
        next.push(cur[i].left);
      }

      if (cur[i].right) {
        next.push(cur[i].right);
      }
    }

    if (!left) {
      temp.reverse();
    }

    left = !left;
    result.push(temp);
    cur = next;
  }

  return result;
};

// SOLUTION 2: USE STACK
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  var result = [],
    cur = [],
    left = true,
    i,
    len,
    temp,
    next,
    node;

  if (!root) {
    return result;
  }

  cur.push(root);

  while (cur.length > 0) {
    len = cur.length;
    temp = [];
    next = [];

    node = cur.pop();

    while (node) {
      temp.push(node.val);

      if (left) {
        if (node.left) {
          next.push(node.left);
        }

        if (node.right) {
          next.push(node.right);
        }
      } else {
        if (node.right) {
          next.push(node.right);
        }

        if (node.left) {
          next.push(node.left);
        }
      }

      node = cur.pop();
    }

    result.push(temp);
    cur = next;
    left = !left;
  }

  return result;
};
```

### Bitwise AND of Numbers Range

```js
/**
Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

For example, given the range [5, 7], you should return 4.
*/

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var rangeBitwiseAnd = function(m, n) {
  var offset = 0;

  while (m && n) {
    if (m === n) {
      return m << offset;
    }

    m >>= 1;
    n >>= 1;
    offset++;
  }

  return 0;
};
```

### Bulb Switcher

```js
/**
 * @param {number} n
 * @return {number}
 *
 * 我们知道，每当灯泡会改变状态，也就是 toggle 时，是因为它出现在了某个数的整数倍上。

对于第1个灯泡：1*1，会改变1次状态，即 off -》on

对于第2个灯泡：1*2，2*1，会改变2次状态，即 off -》on -》off

对于第3个灯泡：1*3，3*1，会改变2次状态，即 off -》on -》off

对于第4个灯泡：1*4，2*2，4*1，会改变3次状态，即 off -》on -》off -》on

……

会发现，每当我找到一个数的整数倍，总会找到对称的一个整数倍，例如 1*2，就肯定会有一个 2*1。唯一的例外出现在平方数上，例如 4 = 2*2，只有一次整数倍。

每次作为偶数次整数倍，最终的灯泡都会还原为 off；只有作为奇数次整数倍，最终的灯泡都会 on。
也就是说，最终亮的灯泡数目由小于其的最大平方数确定。
 *
 */
var bulbSwitch = function(n) {
  return Math.floor(Math.sqrt(n));
};
```

### Bulls and Cows

```js
/**
You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.

For example:

Secret number:  "1807"
Friend's guess: "7810"
Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)
Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return "1A3B".

Please note that both secret number and friend's guess may contain duplicate digits, for example:

Secret number:  "1123"
Friend's guess: "0111"
In this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return "1A1B".
You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.
*/
/**
 * @param {string} secret
 * @param {string} guess
 * @return {string}
 */
var getHint = function(secret, guess) {
  var len = secret.length,
    bullCount = 0,
    arr = {},
    cowCount = 0,
    i;

  for (i = 0; i < len; i++) {
    if (!arr[secret.charAt(i)]) {
      arr[secret.charAt(i)] = 1;
    } else {
      arr[secret.charAt(i)]++;
    }
  }

  for (i = 0; i < len; i++) {
    if (secret.charAt(i) === guess.charAt(i)) {
      bullCount++;
      arr[secret.charAt(i)]--;
    }
  }

  for (i = 0; i < len; i++) {
    if (secret.charAt(i) !== guess.charAt(i) && arr.hasOwnProperty(guess.charAt(i)) && arr[guess.charAt(i)] > 0) {
      cowCount++;
      arr[guess.charAt(i)]--;
    }
  }

  return bullCount + 'A' + cowCount + 'B';
};
```

### Burst Balloons

```js
/**
Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.

Find the maximum coins you can collect by bursting the balloons wisely.

Note:
(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.
(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

Example:

Given [3, 1, 5, 8]

Return 167

    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
*/
/**
 * @param {number[]} nums
 * @return {number}
 *
 * 状态转移方程：

dp[l][r] = max(dp[l][r], nums[l] * nums[m] * nums[r] + dp[l][m] + dp[m][r])
dp[l][r]表示扎破(l, r)范围内所有气球获得的最大硬币数，不含边界；

l与r的跨度k从2开始逐渐增大；

三重循环依次枚举范围跨度k，左边界l，中点m；右边界r = l + k；
 */
var maxCoins = function(nums) {
  var len = nums.length,
    dp = [],
    i,
    k,
    l,
    m,
    r;

  for (i = 0; i <= len + 1; i++) {
    dp.push(new Array(len + 1));
  }

  for (i = 0; i <= len + 1; i++) {
    for (k = 0; k <= len + 1; k++) {
      dp[i][k] = 0;
    }
  }

  nums[len + 1] = 1;

  for (i = len; i > 0; i--) {
    nums[i] = nums[i - 1];
  }

  nums[0] = 1;

  len += 2;

  for (k = 2; k < len; k++) {
    for (l = 0; l < len - k; l++) {
      r = l + k;

      for (m = l + 1; m < r; m++) {
        dp[l][r] = Math.max(dp[l][r], dp[l][m] + dp[m][r] + nums[l] * nums[m] * nums[r]);
      }
    }
  }

  return dp[0][len - 1];
};
```

### Candy

```js
/**
There are N children standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum candies you must give?
*/

//TLE
/**
 * @param {number[]} ratings
 * @return {number}
 */
var candy = function(ratings) {
  let len = ratings.length;
  let candies = [];
  let sum = 1;

  candies[0] = 1;

  for (let i = 1; i < len; i++) {
    if (ratings[i] <= ratings[i - 1]) {
      if (candies[i - 1] > 1) {
        candies[i] = 1;
        sum++;
      } else {
        candies[i] = 1;
        sum++;
        let k = i;

        while (k > 0 && ratings[k] < ratings[k - 1] && candies[k - 1] <= candies[k]) {
          candies[k - 1]++;
          sum++;
          k--;
        }
      }
    } else {
      candies[i] = candies[i - 1] + 1;
      sum += candies[i];
    }
  }

  return sum;
};
```

### Climbing Stairs

```js
/**
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
  var arr = [],
    i;

  arr[0] = 0;
  arr[1] = 1;
  arr[2] = 2;

  for (i = 3; i <= n; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[n];
};

// TODO:
// 考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，
// 因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。
var climbStairs1 = function(n) {
  if (n <= 2) return n;
  // 第一步和第二步所耗费的步数
  let pre2 = 1,
    pre1 = 2,
    cur = 0;
  for (let i = 2; i < n.length; i++) {
    cur = pre1 + pre2;
    pre2 = pre1;
    pre1 = cur;
  }
  return pre1;
};

console.log(climbStairs1([1, 2, 3]));
```

### Coin Change

```js
/**
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.

Note:
You may assume that you have an infinite number of each kind of coin.
*/

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  var i = 0,
    arr = [],
    len = coins.length,
    j;

  while (i <= amount) {
    arr.push(Number.MAX_VALUE);
    i++;
  }

  arr[0] = 0;

  for (i = 0; i < len; i++) {
    for (j = coins[i]; j <= amount; j++) {
      arr[j] = Math.min(arr[j], arr[j - coins[i]] + 1);
    }
  }

  return arr[amount] === Number.MAX_VALUE ? -1 : arr[amount];
};
```

### Combination Sum II

```js
/**
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

Note:
All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8,
A solution set is:
[1, 7]
[1, 2, 5]
[2, 6]
[1, 1, 6]
*/
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
  var len = candidates.length,
    result = [],
    i,
    j;

  candidates.sort(function(a, b) {
    return a - b;
  });

  genSum(result, target, [], 0, 0, candidates);

  return result;
};

function genSum(result, target, curArr, index, curSum, nums) {
  if (curSum === target) {
    result.push(curArr);
    return;
  }

  if (curSum > target || index === nums.length) {
    return;
  }

  var len = nums.length,
    i;

  for (i = index; i < len; i++) {
    if (i > index && nums[i] === nums[i - 1]) {
      continue;
    }

    curArr.push(nums[i]);
    genSum(result, target, curArr.concat(), i + 1, curSum + nums[i], nums);
    curArr.pop();
  }
}
```

### Combination Sum III

```js
/**
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

Ensure that numbers within the set are sorted in ascending order.


Example 1:

Input: k = 3, n = 7

Output:

[[1,2,4]]

Example 2:

Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]
*/
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
  var result = [];

  fillResult(0, [], 1, k, n, result);

  return result;
};

function fillResult(curSum, curArr, startNum, k, n, result) {
  if (curArr.length > k || curSum > n) {
    return;
  }

  if (curArr.length === k) {
    if (curSum === n) {
      result.push(curArr.concat());
    }

    return;
  }

  var temp = curArr.concat(),
    curNum,
    i;

  for (i = startNum; i <= 9; i++) {
    temp.push(i);
    fillResult(curSum + i, temp, i + 1, k, n, result);
    temp.pop();
  }
}
```

### Combination Sum

```js
/**
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

The same repeated number may be chosen from C unlimited number of times.

Note:
All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
The solution set must not contain duplicate combinations.
For example, given candidate set 2,3,6,7 and target 7,
A solution set is:
[7]
[2, 2, 3]
*/

/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  var sols = [],
    len = candidates.length,
    curSol = [],
    start = 0,
    i;

  if (len === 0) {
    return sols;
  }
  // sort candidates
  candidates.sort(function(a, b) {
    if (a < b) {
      return -1;
    }

    return 1;
  });

  fillCurSol(start, len, candidates, target, curSol, sols);

  return sols;
};

function fillCurSol(start, len, candidates, target, curSol, sols) {
  // skip duplicates from candidate
  var i, newCurSol; // very important, can't mess up with arrays

  if (target === 0) {
    sols.push(curSol.concat());
    return;
  }

  for (i = start; i < len; i++) {
    if (i > start && candidates[i] === candidates[i - 1]) {
      continue;
    }

    newCurSol = curSol.concat();

    if (candidates[i] <= target) {
      newCurSol.push(candidates[i]);
      fillCurSol(i, len, candidates, target - candidates[i], newCurSol, sols);
      newCurSol.pop();
    }
  }
}
```

### Combinations

```js
/**
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

For example,
If n = 4 and k = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
*/
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
  var result = [];

  helper(1, [], n, k, result);

  return result;
};

function helper(start, curArr, n, k, result) {
  if (curArr.length === k) {
    result.push(curArr);
    return;
  }

  var i, temp;

  for (i = start; i <= n; i++) {
    curArr.push(i);
    helper(i + 1, curArr.concat(), n, k, result);
    curArr.pop();
  }
}
```

### Compare Version Numbers

```js
/**
Compare two version numbers version1 and version2.
If version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

Here is an example of version numbers ordering:

0.1 < 1.1 < 1.2 < 13.37
Credits:
Special thanks to @ts for adding this problem and creating all test cases.

*/

/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function(version1, version2) {
  var arr1 = version1.split('.'),
    arr2 = version2.split('.'),
    len1 = arr1.length,
    len2 = arr2.length,
    a,
    b,
    i,
    j;

  for (i = 0; i < len1 && i < len2; i++) {
    a = parseInt(arr1[i]);
    b = parseInt(arr2[i]);
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    }
  }

  if (len1 > len2) {
    for (j = i; j < len1; j++) {
      if (parseInt(arr1[j]) > 0) {
        return 1;
      }
    }
  } else if (len1 < len2) {
    for (j = i; j < len2; j++) {
      if (parseInt(arr2[j]) > 0) {
        return -1;
      }
    }
  }

  return 0;
};
```

### Construct Binary Tree from Inorder and Postorder Traversal

```js
/**
Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
  var iLen = inorder.length,
    pLen = postorder.length;

  return getRoot(inorder, postorder, 0, iLen - 1, 0, pLen - 1);
};

function getRoot(inorder, postorder, iStart, iEnd, pStart, pEnd) {
  if (iStart > iEnd || pStart > pEnd) {
    return null;
  }

  var value = postorder[pEnd],
    node = new TreeNode(value),
    index = inorder.indexOf(value);

  node.left = getRoot(inorder, postorder, iStart, index - 1, pStart, pStart + index - iStart - 1);
  node.right = getRoot(inorder, postorder, index + 1, iEnd, pStart + index - iStart, pEnd - 1);

  return node;
}
```

### Construct Binary Tree from Preorder and Inorder Traversal

```js
/**
Given preorder and inorder traversal of a tree, construct the binary tree.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  /**
    假设树的先序遍历是12453687，中序遍历是42516837。这里最重要的一点就是先序遍历可以提供根的所在，而根据中序遍历的性质知道根的所在就可以将序列分为左右子树。比如上述例子，我们知道1是根，所以根据中序遍历的结果425是左子树，而6837就是右子树。接下来根据切出来的左右子树的长度又可以在先序便利中确定左右子树对应的子序列(先序遍历也是先左子树后右子树)。根据这个流程，左子树的先序遍历和中序遍历分别是245和425，右子树的先序遍历和中序遍历则是3687和6837，我们重复以上方法，可以继续找到根和左右子树，直到剩下一个元素。可以看出这是一个比较明显的递归过程，对于寻找根所对应的下标，我们可以先建立一个HashMap，以免后面需要进行线行搜索，这样每次递归中就只需要常量操作就可以完成对根的确定和左右子树的分割。
    */
  var map = {},
    len = inorder.length,
    i;

  for (i = 0; i < len; i++) {
    map[inorder[i]] = i;
  }

  return helper(preorder, 0, len - 1, inorder, 0, len - 1, map);
};

function helper(preorder, preL, preR, inorder, inL, inR, map) {
  var root, index;

  if (preL > preR || inL > inR) {
    return null;
  }

  root = new TreeNode(preorder[preL]);
  index = map[root.val];

  root.left = helper(preorder, preL + 1, index - inL + preL, inorder, inL, index - 1, map);
  root.right = helper(preorder, index - inL + preL + 1, preR, inorder, index + 1, inR, map);

  return root;
}
```

### Container With Most Water

```js
/**
Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container.

 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var len = height.length,
    left = 0,
    right = len - 1,
    max = 0;

  while (left < right) {
    max = Math.max(max, (right - left) * Math.min(height[left], height[right]));

    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return max;
};
```

### Contains Duplicate II

```js
/**
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.
*/
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
  var map = {},
    len = nums.length,
    i;

  for (i = 0; i < len; i++) {
    if (map.hasOwnProperty(nums[i])) {
      if (i - map[nums[i]] <= k) {
        return true;
      }

      map[nums[i]] = i;
    } else {
      map[nums[i]] = i;
    }
  }

  return false;
};
```

### Contains Duplicate III

```js
/**
Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.
*/

/**
The idea is like the bucket sort algorithm. Suppose we have consecutive buckets covering the range of nums with each bucket a width of (t+1). If there are two item with difference <= t, one of the two will happen:

(1) the two in the same bucket
(2) the two in neighbor buckets

*/
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} t
 * @return {boolean}
 */
var containsNearbyAlmostDuplicate = function(nums, k, t) {
  var len = nums.length,
    map = {},
    id,
    i;

  if (t < 0) {
    return false;
  }

  for (i = 0; i < len; i++) {
    id = getBucketId(nums[i], t + 1);

    if (map.hasOwnProperty(id)) {
      return true;
    }

    if (map.hasOwnProperty(id - 1) && Math.abs(map[id - 1] - nums[i]) <= t) {
      return true;
    }

    if (map.hasOwnProperty(id + 1) && Math.abs(map[id + 1] - nums[i]) <= t) {
      return true;
    }

    map[id] = nums[i];

    if (i >= k) {
      delete map[getBucketId(nums[i - k], t + 1)];
    }
  }

  return false;
};

function getBucketId(num, bucketLength) {
  return Math.floor(num / bucketLength);
}
```

### Convert Sorted Array to Binary Search Tree

```js
/**
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
  var len = nums.length;

  if (len === 0) {
    return null;
  }

  return getRoot(nums, 0, len - 1);
};

function getRoot(nums, start, end) {
  if (start > end) {
    return null;
  }

  var mid = Math.floor((start + end) / 2),
    node = new TreeNode(nums[mid]);

  node.left = getRoot(nums, start, mid - 1);
  node.right = getRoot(nums, mid + 1, end);

  return node;
}
```

### Convert Sorted List to Binary Search Tree

```js
/**
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
*/

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {TreeNode}
 */
var sortedListToBST = function(head) {
    var len = 0,
      node = head;

    if (!node) {
      return null;
    }

    while (node) {
      len++;
      node = node.next;
    }
    curNode = head;
    return helper(0, len - 1);
  },
  curNode;

// build tree bottom up
function helper(start, end) {
  if (start > end) {
    return null;
  }

  var mid = parseInt((start + end) / 2),
    left,
    right,
    node;

  (left = helper(start, mid - 1)), (node = new TreeNode(curNode.val));
  curNode = curNode.next;
  right = helper(mid + 1, end);

  node.left = left;
  node.right = right;

  return node;
}

// solution 2
var sortedListToBST = function(head) {
  var arr = [],
    node = head,
    len;

  if (!node) {
    return null;
  }

  while (node) {
    arr.push(node);
    node = node.next;
  }

  len = arr.length;

  if (len === 1) {
    return head;
  }

  return getMidNode(0, len - 1, arr);
};

function getMidNode(start, end, arr) {
  if (start > end) {
    return null;
  }

  var mid = parseInt((start + end) / 2),
    node = new TreeNode(arr[mid].val);

  node.left = getMidNode(start, mid - 1, arr);
  node.right = getMidNode(mid + 1, end, arr);

  return node;
}
```

### Count Complete Tree Nodes

```js
/**
Given a complete binary tree, count the number of nodes.

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
  if (root === null) {
    return 0;
  }

  var tmp = root,
    totalDep = 0,
    nodeNumsInLastLevel = 0,
    node = root,
    curDep,
    depSplit;

  while (tmp) {
    tmp = tmp.left;
    totalDep++;
  }

  curDep = 1;
  while (curDep < totalDep) {
    depSplit = findSplit(node);

    if (depSplit + curDep === totalDep) {
      nodeNumsInLastLevel += Math.pow(2, depSplit - 1);
      node = node.right;
    } else {
      node = node.left;
    }

    curDep++;
  }

  return Math.pow(2, totalDep - 1) + nodeNumsInLastLevel;
};

// find the depth of left most node in right subtree of current node
// binary search in last level
function findSplit(root) {
  if (!root || !root.right) {
    return 0;
  }

  var dep = 0,
    tmp = root;

  tmp = tmp.right;
  while (tmp) {
    dep++;
    tmp = tmp.left;
  }

  return dep;
}
```

### Count Primes

```js
/**
Count the number of prime numbers less than a non-negative number, n

 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  var i,
    j,
    result = 0,
    prime;
  if (n === 1) {
    return 0;
  }
  for (i = 2; i < n; i++) {
    prime = true;
    for (j = 2; j * j <= i; j++) {
      if (i % j === 0) {
        prime = false;
        break;
      }
    }
    if (prime) {
      result++;
    }
  }
  return result;
};
```

### Count and Say

```js
/**
The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string.

 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
  function interpret(s, accum, sum) {
    var times = 1,
      num,
      len = s.length,
      i,
      result = '';

    num = s.charAt(0);

    for (i = 1; i < len; i++) {
      if (s.charAt(i) !== num) {
        result += times + num;
        num = s.charAt(i);
        times = 1;
      } else {
        times++;
      }
    }
    if (accum === 1) {
      result = '1';
    } else {
      result += times + num;
    }
    if (accum === sum) {
      return result;
    } else {
      return interpret(result, accum + 1, sum);
    }
  }
  return interpret('1', 1, n);
};
```

### Count of Range Sum

```js
/**
Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.
Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.

Note:
A naive algorithm of O(n2) is trivial. You MUST do better than that.

Example:
Given nums = [-2, 5, -1], lower = -2, upper = 2,
Return 3.
The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.
*/
/**
 * @param {number[]} nums
 * @param {number} lower
 * @param {number} upper
 * @return {number}
 */
var countRangeSum = function(nums, lower, upper) {
  function SegmentTreeNode(min, max) {
    this.min = min;
    this.max = max;
    this.count = 0;
  }

  function buildSegmentTree(valArr, low, high) {
    if (low > high) {
      return null;
    }

    var mid = parseInt((low + high) / 2),
      node = new SegmentTreeNode(valArr[low], valArr[high]);

    if (low === high) {
      return node;
    }

    node.left = buildSegmentTree(valArr, low, mid);
    node.right = buildSegmentTree(valArr, mid + 1, high);

    return node;
  }

  function updateSegmentTree(node, val) {
    if (!node) {
      return;
    }

    if (val >= node.min && val <= node.max) {
      node.count++;
      updateSegmentTree(node.left, val);
      updateSegmentTree(node.right, val);
    }
  }

  function rangeCount(node, min, max) {
    if (!node) {
      return 0;
    }

    if (min > node.max || max < node.min) {
      return 0;
    }

    if (min <= node.min && max >= node.max) {
      return node.count;
    }

    return rangeCount(node.left, min, max) + rangeCount(node.right, min, max);
  }

  var len = nums.length,
    sumSet = new Set(),
    sum = 0,
    result = 0,
    arr,
    root,
    i;

  if (len === 0) {
    return 0;
  }

  for (i = 0; i < len; i++) {
    sum += nums[i];
    sumSet.add(sum);
  }

  arr = Array.from(sumSet);
  arr.sort(function(a, b) {
    return a - b;
  });

  root = buildSegmentTree(arr, 0, arr.length - 1);

  for (i = len - 1; i >= 0; i--) {
    updateSegmentTree(root, sum);
    sum -= nums[i];
    result += rangeCount(root, lower + sum, upper + sum);
  }

  return result;
};
```

### Count of Smaller Numbers After Self

```js
/**
You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].

Example:

Given nums = [5, 2, 6, 1]

To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.
Return the array [2, 1, 1, 0].
*/

/**
 * @param {number[]} nums
 * @return {number[]}
 *
 * 将给定数组从最后一个开始，用二分法插入到一个新的数组，这样新数组就是有序的，那么此时该数字在新数组中的坐标就是原数组中其右边所有较小数字的个数
 */
var countSmaller = function(nums) {
  var result = [],
    tmp = [],
    len = nums.length,
    left,
    right,
    mid,
    i; // array for sorting nums

  for (i = len - 1; i >= 0; i--) {
    left = 0;
    right = tmp.length;

    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (tmp[mid] >= nums[i]) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    result[i] = right;
    tmp.splice(right, 0, nums[i]);
  }

  return result;
};
```

### Counting Bits

```js
// Submission Result: Memory Limit Exceeded More Details

// Last executed input:
// 123456

/**
 * @param {number} num
 * @return {number[]}
 */

/**
当一个数为2的整数幂的时候，1的个数为1，比如2(10) 和4(100)，8(1000)

在这之后就是前一个序列的数+1 比如 9(1001) = 1(1) + 8 (1) = 2

就是把一个数分解为小于它的最大2的整数幂 + x
*/
var countBits = function(num) {
  var result = [],
    pow = 1,
    copyOfPow = 1,
    i;

  result[0] = 0;

  for (i = 1; i <= num; i++) {
    if (i === pow) {
      result[i] = 1;
      copyOfPow = pow;
      pow *= 2;
    } else {
      result[i] = result[copyOfPow] + result[i - copyOfPow];
    }
  }

  return result;
};

/**
倒过来想，一个数 * 2 就是把它的二进制全部左移一位，也就是说 1的个数是相等的。

那么我们可以利用这个结论来做。

res[i /2] 然后看看最低位是否为1即可(上面*2一定是偶数，这边比如15和14除以2都是7，但是15时通过7左移一位并且+1得到，14则是直接左移)

所以res[i] = res[i >>1] + (i&1)
*/
var countBits = function(num) {
  var result = [],
    i;

  result[0] = 0;

  for (i = 1; i <= num; i++) {
    result[i] = result[i >> 1] + (i & 1);
  }

  return result;
};
```

### Course Schedule II

```js
/**
There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

For example:

2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]

4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].

Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.

click to show more hints.

Hints:
This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.
*/
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
  var courses = [],
    prereqCounts = [],
    queue = [],
    temp,
    result = [],
    i,
    j,
    k;

  for (i = 0; i < numCourses; i++) {
    courses.push(new Set());
  }

  // [1] is [0]'s prerequisite
  // To take course [0] you should have finished course [1]
  for (i = 0; i < prerequisites.length; i++) {
    courses[prerequisites[i][1]].add(prerequisites[i][0]);
  }

  for (i = 0; i < numCourses; i++) {
    prereqCounts[i] = 0;
  }

  // count the pre-courses
  for (i = 0; i < numCourses; i++) {
    temp = Array.from(courses[i]);

    for (j = 0; j < temp.length; j++) {
      prereqCounts[temp[j]]++;
    }
  }

  for (i = 0; i < numCourses; i++) {
    if (prereqCounts[i] === 0) {
      queue.push(i);
      prereqCounts[i] = -1;
    }
  }

  while (queue.length > 0) {
    j = queue.shift();
    result.push(j);

    temp = Array.from(courses[j]);

    for (i = 0; i < temp.length; i++) {
      prereqCounts[temp[i]]--;

      if (prereqCounts[temp[i]] === 0) {
        queue.push(temp[i]);
        prereqCounts[temp[i]] = -1;
      }
    }
  }

  if (result.length === numCourses) {
    return result;
  }

  return [];
};
```

### Course Schedule

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */

var constructGraph = function(numNodes, pre) {
  var nodes = [];
  for (var i = 0; i < numNodes; i++) {
    var node = {};
    node.neighbors = [];
    nodes[i] = node;
  }
  for (var j = 0; j < pre.length; j++) {
    var s = pre[j][1];
    var d = pre[j][0];
    nodes[s].neighbors.push(nodes[d]);
  }
  return nodes;
};

// Return true if there is a cycle detected.
var dfs = function(startNode, parents) {
  if (parents.indexOf(startNode) >= 0) return true;
  if (startNode.visited) return false;

  startNode.visited = true;
  var neighbors = startNode.neighbors;
  parents.push(startNode);
  for (var i = 0; i < neighbors.length; i++) {
    var hasCycle = dfs(neighbors[i], parents);
    if (hasCycle) return true;
  }
  parents.pop();
};

var canFinish = function(numCourses, prerequisites) {
  var nodes = constructGraph(numCourses, prerequisites);
  for (var i = 0; i < nodes.length; i++) {
    var hasCycle = dfs(nodes[i], []);
    if (hasCycle) return false;
  }
  return true;
};

// SOLUTION 2
/**
There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

For example:

2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.

2, [[1,0],[0,1]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.

click to show more hints.

Hints:
This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.
*/
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
  var courses = [],
    prereqCounts = [],
    temp,
    setIter,
    i,
    j,
    k;

  for (i = 0; i < numCourses; i++) {
    courses.push(new Set());
  }

  // [1] is [0]'s prerequisite
  for (i = 0; i < prerequisites.length; i++) {
    courses[prerequisites[i][1]].add(prerequisites[i][0]);
  }

  for (i = 0; i < numCourses; i++) {
    prereqCounts[i] = 0;
  }

  // count the pre-courses
  for (i = 0; i < numCourses; i++) {
    temp = Array.from(courses[i]);
    // setIter = temp[Symbol.iterator]();

    // while(setIter.hasNext()) {
    //     prereqCounts[setIter.next()]++;
    // }
    for (j = 0; j < temp.length; j++) {
      prereqCounts[temp[j]]++;
    }
  }

  // remove a non-pre course each time
  for (i = 0; i < numCourses; i++) {
    for (j = 0; j < numCourses; j++) {
      if (prereqCounts[j] === 0) {
        break;
      }
    }

    // if didn't find a non-pre course
    if (j === numCourses) {
      return false;
    }
    prereqCounts[j] = -1;
    // decrease courses that post the course
    temp = Array.from(courses[j]);
    // setIter = temp[Symbol.iterator]();

    // while(setIter.hasNext()) {
    //     prereqCounts[setIter.next()]--;
    // }

    for (k = 0; k < temp.length; k++) {
      prereqCounts[temp[k]]--;
    }
  }

  return true;
};
```

### Create Maximum Number

```js
/**
Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity.

Example 1:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
return [9, 8, 6, 5, 3]

Example 2:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
return [6, 7, 6, 0, 4]

Example 3:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
return [9, 8, 9]
*/

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[]}
 */
var maxNumber = function(nums1, nums2, k) {
  var len1 = nums1.length,
    len2 = nums2.length,
    arr1,
    arr2,
    arr,
    result,
    i;

  for (i = Math.max(0, k - len2); i <= k && i <= len1; i++) {
    arr1 = getMaxSubArr(nums1, i);
    arr2 = getMaxSubArr(nums2, k - i);
    arr = merge(arr1, arr2);

    if (!result) {
      result = arr;
    } else {
      result = getGreaterArr(result, arr);
    }
  }

  return result;
};

// return max sub array of size m
function getMaxSubArr(arr, m) {
  var result = [],
    len = arr.length,
    i,
    j = 0; // top of the stack

  for (i = 0; i < len; i++) {
    while (j > 0 && m - j < len - i && result[j - 1] < arr[i]) {
      //can pop item out of stack
      j--;
    }

    if (j < m) {
      result[j] = arr[i];
      j++;
    }
  }

  return result;
}

//TODO: Integrate getGreaterArr into isGreater function
function getGreaterArr(a, b) {
  var len = a.length,
    i = 0;

  while (i < len) {
    if (a[i] < b[i]) {
      return b;
    } else if (a[i] > b[i]) {
      return a;
    }

    i++;
  }

  return a;
}

function isGreater(a, i, b, j) {
  var len1 = a.length,
    len2 = b.length;

  while (i < len1 && j < len2 && a[i] === b[j]) {
    i++;
    j++;
  }

  if (i === len1) {
    return false;
  }

  if (j === len2) {
    return true;
  }

  return a[i] > b[j];
}

function merge(a, b) {
  var len1 = a.length,
    len2 = b.length,
    i = 0,
    j = 0,
    result = [];

  while (i < len1 && j < len2) {
    if (isGreater(a, i, b, j)) {
      result.push(a[i]);
      i++;
    } else {
      result.push(b[j]);
      j++;
    }
  }

  while (i < len1) {
    result.push(a[i++]);
  }

  while (j < len2) {
    result.push(b[j++]);
  }

  return result;
}
```

### Decode Ways

```js
/**
A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given an encoded message containing digits, determine the total number of ways to decode it.

For example,
Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2.
*/

// http://bangbingsyb.blogspot.com/2014/11/leetcode-decode-ways.html
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  var len = s.length,
    dp = [],
    x,
    y,
    cur,
    i;

  dp[0] = 1;
  dp[1] = 1;

  if (len === 0 || s.charAt(0) < '1' || s.charAt(0) > '9') {
    return 0;
  }

  for (i = 1; i < len; i++) {
    x = s.charAt(i - 1) - '0';
    y = s.charAt(i) - '0';
    cur = x * 10 + y;
    dp[i + 1] = 0;

    if (cur > 9 && cur <= 26) {
      dp[i + 1] += dp[i - 1];
    }

    if (y !== 0) {
      dp[i + 1] += dp[i];
    }

    if (dp[i + 1] === 0) {
      return 0;
    }
  }

  return dp[len];
};
```

### Different Ways to Add Parentheses

```js
/**
Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.


Example 1
Input: "2-1-1".

((2-1)-1) = 0
(2-(1-1)) = 2
Output: [0, 2]


Example 2
Input: "2*3-4*5"

(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
Output: [-34, -14, -10, -10, 10]
*/
/**
 * @param {string} input
 * @return {number[]}
 */
var diffWaysToCompute = function(input) {
  var len = input.length,
    result = [],
    left,
    right,
    curChar,
    i,
    j,
    k;

  for (i = 0; i < len; i++) {
    curChar = input.charAt(i);

    if (curChar === '+' || curChar === '-' || curChar === '*') {
      left = diffWaysToCompute(input.substring(0, i));
      right = diffWaysToCompute(input.substring(i + 1));

      for (j = 0; j < left.length; j++) {
        for (k = 0; k < right.length; k++) {
          if (curChar === '+') {
            result.push(left[j] + right[k]);
          } else if (curChar === '-') {
            result.push(left[j] - right[k]);
          } else {
            result.push(left[j] * right[k]);
          }
        }
      }
    }
  }

  if (result.length === 0) {
    result.push(parseInt(input));
  }

  return result;
};
```

### Distinct Subsequences

```js
/**
Given a string S and a string T, count the number of distinct subsequences of T in S.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

Here is an example:
S = "rabbbit", T = "rabbit"

Return 3.
*/
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 *
 * S[j-1]!= T[i-1]：DP[i][j] = DP[i][j-1]
 * S[j-1]==T[i-1]：DP[i][j] = DP[i-1][j-1] + DP[i][j-1]
 */
var numDistinct = function(s, t) {
  var lenS = s.length,
    lenT = t.length,
    i,
    j,
    dp;

  if (lenS < lenT) {
    return 0;
  }

  if (lenS === lenT) {
    return s === t ? 1 : 0;
  }

  dp = [];

  for (i = 0; i <= lenT; i++) {
    dp.push(new Array(lenS + 1));

    for (j = 0; j <= lenS; j++) {
      dp[i][j] = 0;
    }
  }

  for (j = 0; j <= lenS; j++) {
    dp[0][j] = 1;
  }

  for (i = 0; i < lenT; i++) {
    for (j = 0; j < lenS; j++) {
      dp[i + 1][j + 1] = dp[i + 1][j];

      if (s.charAt(j) === t.charAt(i)) {
        dp[i + 1][j + 1] += dp[i][j];
      }
    }
  }

  return dp[lenT][lenS];
};

// use 1D dp solution
// draw 2D dp realation and try to save space
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 *
 * S[j-1]!= T[i-1]：DP[i][j] = DP[i][j-1]
 * S[j-1]==T[i-1]：DP[i][j] = DP[i-1][j-1] + DP[i][j-1]
 */
var numDistinct = function(s, t) {
  var lenS = s.length,
    lenT = t.length,
    i,
    j,
    dp;

  if (lenS < lenT) {
    return 0;
  }

  if (lenS === lenT) {
    return s === t ? 1 : 0;
  }

  dp = [];
  dp[0] = 1;

  for (i = 1; i <= lenT; i++) {
    dp[i] = 0;
  }

  for (j = 0; j <= lenS; j++) {
    for (i = lenT - 1; i >= 0; i--) {
      if (s.charAt(j) === t.charAt(i)) {
        dp[i + 1] += dp[i];
      }
    }
  }

  return dp[lenT];
};
```

### Divide Two Integers

/\*\*
Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX_INT.
\*/

// TIME LIMIT EXCEEDED

/\*\*

- @param {number} dividend
- @param {number} divisor
- @return {number}
  \*/
  var divide = function(dividend, divisor) {
  if (divisor === 0) {
  return Number.MAX_VALUE;
  }

      if (dividend === 0) {
          return 0;
      }

      var result = 0,
          isNeg = false,
          temp,
          i = 0;

      if (dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0) {
          isNeg = true;
      }

      dividend = Math.abs(dividend);
      divisor = Math.abs(divisor);

      if (divisor === 1 || divisor === -1) {
          return isNeg? -dividend : dividend;
      }

      temp = divisor;

      while (divisor << (i + 1) <= dividend) {
          i++;
      }

      while (dividend >= divisor) {
          temp = divisor << i;

          if (dividend >= temp) {
              result += (1 << i);
              dividend -= temp;
          }

          i--;
      }

      return isNeg? -result : result;

  };

### Edit Distance

```js
/**
Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

a) Insert a character
b) Delete a character
c) Replace a character

 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
  var len1 = word1.length,
    len2 = word2.length,
    matrix = [],
    i,
    j;

  if (len1 === 0 || len2 === 0) {
    return Math.max(len1, len2);
  }
  //initialization
  for (i = 0; i <= len1; i++) {
    matrix[i] = [];
    matrix[i][0] = i;
  }
  for (j = 0; j <= len2; j++) {
    matrix[0][j] = j;
  }

  for (i = 1; i <= len1; i++) {
    for (j = 1; j <= len2; j++) {
      if (word1.charAt(i - 1) === word2.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1;
      }
    }
  }
  return matrix[len1][len2];
};
```

### Evaluate Reverse Polish Notation

```js
/**
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Some examples:
  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
Subscribe to see which companies asked this question
*/
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  var stack = [],
    len = tokens.length,
    ch,
    num,
    i;

  for (i = 0; i < len; i++) {
    ch = tokens[i];

    if (isNaN(parseInt(ch))) {
      if (ch === '+') {
        num = stack.pop() + stack.pop();
        stack.push(num);
      } else if (ch === '-') {
        num = stack.pop();
        num = stack.pop() - num;
        stack.push(num);
      } else if (ch === '*') {
        num = stack.pop() * stack.pop();
        stack.push(num);
      } else if (ch === '/') {
        num = stack.pop();
        num = parseInt(stack.pop() / num);
        stack.push(num);
      }
    } else {
      stack.push(parseInt(ch));
    }
  }

  return stack.pop();
};
```

### Excel Sheet Column Number

```js
/**
Related to question Excel Sheet Column Title

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28

 * @param {string} s
 * @return {number} Return column number
 */
var titleToNumber = function(s) {
  var len = s.length,
    i,
    result = 0;
  for (i = 0; i < len; i++) {
    result += Math.pow(26, len - i - 1) * (s.charAt(i).charCodeAt() - 'A'.charCodeAt() + 1);
  }
  return result;
};
```

### Expression Add Operators

```js
/**
Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.

Examples:
"123", 6 -> ["1+2+3", "1*2*3"]
"232", 8 -> ["2*3+2", "2+3*2"]
"105", 5 -> ["1*0+5","10-5"]
"00", 0 -> ["0+0", "0-0", "0*0"]
"3456237490", 9191 -> []
*/
/**
 * @param {string} num
 * @param {number} target
 * @return {string[]}
 */
var addOperators = function(num, target) {
  var result = [];

  helper(result, '', 0, num, target, 0, 0);

  return result;
};

function helper(result, cur, index, num, target, prev, multi) {
  if (index === num.length) {
    if (prev === target) {
      result.push(cur);
    }

    return;
  }

  var len = num.length,
    temp,
    i;

  for (i = index; i < len; i++) {
    if (num.charAt(index) === '0' && i > index) {
      break;
    }

    temp = parseInt(num.substring(index, i + 1));

    if (cur.length === 0) {
      helper(result, cur + temp, i + 1, num, target, temp, temp);
    } else {
      helper(result, cur + '+' + temp, i + 1, num, target, prev + temp, temp);
      helper(result, cur + '-' + temp, i + 1, num, target, prev - temp, -temp);
      helper(result, cur + '*' + temp, i + 1, num, target, prev - multi + multi * temp, temp * multi);
    }
  }
}
```

### Find Median from Data Stream

```js
/**
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

Examples:
[2,3,4] , the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:

void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.
For example:

add(1)
add(2)
findMedian() -> 1.5
add(3)
findMedian() -> 2
*/

// SOLUTION 1: use a max heap and min heap
// java solution
/**
class MedianFinder {

    private Queue<Long> small = new PriorityQueue(),
                        large = new PriorityQueue();

    public void addNum(int num) {
        large.add((long) num);
        small.add(-large.poll());
        if (large.size() < small.size())
            large.add(-small.poll());
    }

    public double findMedian() {
        return large.size() > small.size()
               ? large.peek()
               : (large.peek() - small.peek()) / 2.0;
    }
};
*/

// SOLUTION 2: BST
/**
 * My BST node, has extra attribute initialized as 0
 */
class BSTNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.size = 1;
  }
}

class BST {
  constructor() {
    this.root = null;
  }

  add(val, node) {
    if (!node) {
      this.root = new BSTNode(val);
      return;
    }

    if (val > node.val) {
      if (node.right) {
        this.add(val, node.right);
      } else {
        node.right = new BSTNode(val);
      }
    } else {
      if (node.left) {
        this.add(val, node.left);
      } else {
        node.left = new BSTNode(val);
      }
    }

    node.size++;
  }

  rank(k) {
    let node = this.root;

    while (true) {
      const leftSize = node.left ? node.left.size : 0;

      if (leftSize === k) {
        return node.val;
      }

      if (leftSize > k) {
        node = node.left;
      } else {
        node = node.right;
        k = k - leftSize - 1;
      }
    }
  }
}

/**
 * @constructor
 */
var MedianFinder = function() {
  this.BST = new BST();
};

/**
 * @param {integer} word
 * @return {void}
 * Adds a num into the data structure.
 */
MedianFinder.prototype.addNum = function(num) {
  this.BST.add(num, this.BST.root);
};

/**
 * @return {double}
 * Return median of current data stream
 */
MedianFinder.prototype.findMedian = function() {
  const size = this.BST.root.size;

  if (size % 2 === 0) {
    return (this.BST.rank(size / 2) + this.BST.rank(size / 2 - 1)) / 2;
  }

  return this.BST.rank(parseInt(size / 2));
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var mf = new MedianFinder();
 * mf.addNum(1);
 * mf.findMedian();
 */
```

### Find Minimum in Rotated Sorted Array II

```js
/**
Follow up for "Find Minimum in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

The array may contain duplicates.
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  var start = 0,
    end = nums.length - 1,
    mid;

  while (start < end) {
    mid = Math.floor((start + end) / 2);

    if (nums[mid] < nums[start]) {
      end = mid;
    } else if (nums[mid] > nums[end]) {
      start = mid + 1;
    } else if (nums[mid] === nums[end] && nums[mid] === nums[start]) {
      end--;
    } else if (nums[mid] === nums[end]) {
      if (nums[mid] < nums[start]) {
        end = mid;
        start++;
      } else {
        end = mid - 1;
      }
    } else if (nums[mid] === nums[start]) {
      if (nums[mid] > nums[end]) {
        start = mid + 1;
      } else {
        start = mid;
        end--;
      }
    } else {
      return nums[start];
    }
  }

  return nums[start];
};

// SOLUTION 2
var findMin = function(nums) {
  var start = 0,
    end = nums.length - 1,
    mid;

  while (start < end) {
    mid = Math.floor((start + end) / 2);

    if (nums[mid] < nums[start]) {
      end = mid;
    } else if (nums[mid] > nums[end]) {
      start = mid + 1;
    } else {
      end--;
    }
  }

  return nums[start];
};
```

### Find Minimum in Rotated Sorted Array

```js
/**
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.
*/

// O(N) solution
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  var len = nums.length,
    i;

  if (len === 0) {
    return null;
  }

  for (i = 1; i < len; i++) {
    if (nums[i] < nums[i - 1]) {
      return nums[i];
    }
  }

  return nums[0];
};

// O(logN) solution

/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  var len = nums.length,
    start = 0,
    end = len - 1,
    mid;

  while (start < end) {
    mid = parseInt((start + end) / 2);

    if (nums[mid] < nums[start]) {
      end = mid;
    } else if (nums[end] < nums[mid]) {
      start = mid + 1;
    } else {
      return nums[start];
    }
  }

  return nums[start];
};
```

### Find Peak Element

```js
/**
A peak element is an element that is greater than its neighbors.

Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that num[-1] = num[n] = -∞.

For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.

click to show spoilers.

Note:
Your solution should be in logarithmic complexity.

 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  var len = nums.length,
    left,
    right,
    mid;

  if (len === 1) {
    return 0;
  }

  left = 0;
  right = len - 1;
  while (left < right) {
    mid = parseInt((left + right) / 2);

    if (nums[mid] <= nums[mid + 1]) {
      left = mid + 1;
    } else if (nums[mid] <= nums[mid - 1]) {
      right = mid - 1;
    } else {
      return mid;
    }
  }
  return left;
};
```

### Find the Celebrity

```js
/**
Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Solve it without division and in O(n).

For example, given [1,2,3,4], return [24,12,8,6].

Follow up:
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)
*/

/**
 * Definition for knows()
 *
 * @param {integer} person a
 * @param {integer} person b
 * @return {boolean} whether a knows b
 * knows = function(a, b) {
 *     ...
 * };
 */

/**
 * @param {function} knows()
 * @return {function}
 */
var solution = function(knows) {
  /**
   * @param {integer} n Total people
   * @return {integer} The celebrity
   */
  return function(n) {
    let candidate = 0;

    for (let i = 1; i < n; i++) {
      // if candidate know i, then swap
      if (knows(candidate, i)) {
        candidate = i;
      }
    }

    // check if a candidate if valid
    for (let i = 0; i < n; i++) {
      if (i !== candidate && (!knows(i, candidate) || knows(candidate, i))) {
        return -1;
      }
    }

    return candidate;
  };
};
```

### Find the Duplicate Number

```js
/**
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

Note:
You must not modify the array (assume the array is read only).
You must use only constant, O(1) extra space.
Your runtime complexity should be less than O(n2).
There is only one duplicate number in the array, but it could be repeated more than once.
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  var fast = 0,
    slow = 0,
    find = 0;

  while (true) {
    fast = nums[nums[fast]];
    slow = nums[slow];

    if (fast === slow) {
      break;
    }
  }

  while (find !== slow) {
    find = nums[find];
    slow = nums[slow];
  }

  return find;
};

// SOLUTION 2
/**
二分法
复杂度
时间 O(NlogN) 空间 O(1)

思路
实际上，我们可以根据抽屉原理简化刚才的暴力法。我们不一定要依次选择数，然后看是否有这个数的重复数，我们可以用二分法先选取n/2，按照抽屉原理，整个数组中如果小于等于n/2的数的数量大于n/2，说明1到n/2这个区间是肯定有重复数字的。比如6个抽屉，如果有7个袜子要放到抽屉里，那肯定有一个抽屉至少两个袜子。这里抽屉就是1到n/2的每一个数，而袜子就是整个数组中小于等于n/2的那些数。这样我们就能知道下次选择的数的范围，如果1到n/2区间内肯定有重复数字，则下次在1到n/2范围内找，否则在n/2到n范围内找。下次找的时候，还是找一半。

注意
我们比较的mid而不是nums[mid]
因为mid是下标，所以判断式应为cnt > mid，最后返回min

代码
public class Solution {
    public int findDuplicate(int[] nums) {
        int min = 0, max = nums.length - 1;
        while(min <= max){
            // 找到中间那个数
            int mid = min + (max - min) / 2;
            int cnt = 0;
            // 计算总数组中有多少个数小于等于中间数
            for(int i = 0; i < nums.length; i++){
                if(nums[i] <= mid){
                    cnt++;
                }
            }
            // 如果小于等于中间数的数量大于中间数，说明前半部分必有重复
            if(cnt > mid){
                max = mid - 1;
            // 否则后半部分必有重复
            } else {
                min = mid + 1;
            }
        }
        return min;
    }
}

*/
```

### First Bad Version

```js
/**
 * Definition for isBadVersion()
 *
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.
*/

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function(isBadVersion) {
  /**
   * @param {integer} n Total versions
   * @return {integer} The first bad version
   */
  return function(n) {
    var start = 1,
      end = n,
      mid = parseInt(n / 2);

    while (start < end) {
      if (isBadVersion(mid)) {
        end = mid;
      } else {
        start = mid + 1;
      }

      mid = parseInt((start + end) / 2);
    }

    return start;
  };
};
```

### First Missing Positive

```js
/**
Given an unsorted integer array, find the first missing positive integer.

For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.

Your algorithm should run in O(n) time and uses constant space.

 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
  var len = nums.length,
    temp,
    i;

  for (i = 0; i < len; i++) {
    while (nums[i] !== i + 1) {
      if (nums[i] > len || nums[i] < 1 || nums[i] === nums[nums[i] - 1]) {
        break;
      }
      temp = nums[nums[i] - 1];
      nums[nums[i] - 1] = nums[i];
      nums[i] = temp;
    }
  }

  for (i = 0; i < len; i++) {
    if (nums[i] !== i + 1) {
      return i + 1;
    }
  }
  return len + 1;
};
```

### Flatten 2D Vector

```js
/**
Implement an iterator to flatten a 2d vector.

For example,
Given 2d vector =

[
  [1,2],
  [3],
  [4,5,6]
]

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,2,3,4,5,6].

Hint:

    How many variables do you need to keep track?
    Two variables is all you need. Try with x and y.
    Beware of empty rows. It could be the first few rows.
    To write correct code, think about the invariant to maintain. What is it?
    The invariant is x and y must always point to a valid point in the 2d vector. Should you maintain your invariant ahead of time or right when you need it?
    Not sure? Think about how you would implement hasNext(). Which is more complex?
    Common logic in two different places should be refactored into a common method.

*/
/**
 * @constructor
 * @param {Integer[][]} vec2d
 */
var Vector2D = function(vec2d) {
  this.vec = vec2d;
  this.row = 0;
  this.col = 0;
};

/**
 * @this Vector2D
 * @returns {boolean}
 */
Vector2D.prototype.hasNext = function() {
  if (this.vec.length === 0) {
    return false;
  }

  if (this.col === this.vec[this.row].length) {
    this.col = 0;
    this.row++;
  }

  while (this.row < this.vec.length && this.vec[this.row].length === 0) {
    this.row++;
  }

  if (this.row === this.vec.length) {
    return false;
  }

  return true;
};

/**
 * @this Vector2D
 * @returns {integer}
 */
Vector2D.prototype.next = function() {
  const val = this.vec[this.row][this.col];

  this.col++;

  return val;
};

/**
 * Your Vector2D will be called like this:
 * var i = new Vector2D(vec2d), a = [];
 * while (i.hasNext()) a.push(i.next());
 */
```

### Flatten Binary Tree to Linked List

```js
/**
Given a binary tree, flatten it to a linked list in-place.

For example,
Given

         1
        / \
       2   5
      / \   \
     3   4   6
The flattened tree should look like:
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6

*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  var queue = [],
    node,
    len,
    i;

  helper(root, queue);

  len = queue.length;
  for (i = 0; i < len; i++) {
    node = queue.shift();
    node.left = null;
    node.right = queue.length > 0 ? queue[0] : null;
  }
};

function helper(root, queue) {
  if (!root) {
    return;
  }

  queue.push(root);
  helper(root.left, queue);
  helper(root.right, queue);
}

// SOLUTION 2
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 * 假设某节点的左右子树T(root->left)和T(root->right)已经flatten成linked list了：

    1
  /    \
 2     5
  \       \
   3      6 <- rightTail
     \
      4  <- leftTail

如何将root、T(root->left)、T(root->right) flatten成一整个linked list？显而易见：

temp = root->right
root->right  = root->left
root->left = NULL
leftTail->right = temp

 */
var flatten = function(root) {
  helper(root);
};

// return tail node
function helper(root) {
  if (!root) {
    return;
  }

  var leftTail = helper(root.left),
    rightTail = helper(root.right),
    temp;

  if (root.left) {
    temp = root.right;
    root.right = root.left;
    root.left = null;
    leftTail.right = temp;
  }

  if (rightTail) {
    return rightTail;
  }

  if (leftTail) {
    return leftTail;
  }

  return root;
}
```

### Flatten Nested List Iterator

```js
/**
Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:
Given the list [[1,1],2,[1,1]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].

Example 2:
Given the list [1,[4,[6]]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].
*/
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
  this.stack = nestedList.reverse();
};

/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
  var next, i;

  while (this.stack.length > 0) {
    next = this.stack[this.stack.length - 1];

    if (next.isInteger()) {
      return true;
    }

    this.stack.pop();

    for (i = next.getList().length - 1; i >= 0; i--) {
      this.stack.push(next.getList()[i]);
    }
  }

  return false;
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
  return this.stack.pop();
};

/**
 * Your NestedIterator will be called like this:
 * var i = new NestedIterator(nestedList), a = [];
 * while (i.hasNext()) a.push(i.next());
 */
```

### Fraction to Recurring Decimal

```js
/**
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

For example,

Given numerator = 1, denominator = 2, return "0.5".
Given numerator = 2, denominator = 1, return "2".
Given numerator = 2, denominator = 3, return "0.(6)".

 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
  var rem,
    quotient,
    map = [],
    collection = '',
    index,
    len;
  result = '';

  if (numerator === 0) {
    return '0';
  }
  if (denominator === 0) {
    return '';
  }

  if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)) {
    result += '-';
  }
  numerator = Math.abs(Number(numerator));
  denominator = Math.abs(Number(denominator));

  quotient = Math.floor(numerator / denominator);
  result += quotient;

  rem = (numerator % denominator) * 10;
  if (rem === 0) {
    return result;
  }

  result += '.';
  while (rem !== 0) {
    quotient = Math.floor(rem / denominator);
    index = map.indexOf(rem);
    if (index === -1) {
      map.push(rem);
      collection += quotient;
    } else {
      collection = collection.substr(0, index) + '(' + collection.substr(index) + ')';
      break;
    }
    rem = (rem % denominator) * 10;
  }
  result += collection;
  return result;
};
```

### Game of Life

```js
/**
According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."

Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

Any live cell with fewer than two live neighbors dies, as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population..
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
Write a function to compute the next state (after one update) of the board given its current state.

Follow up:
Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.
In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?
*/

/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var gameOfLife = function(board) {
  var len = board.length,
    lives,
    cLen,
    i,
    j,
    x,
    y;

  if (len === 0) {
    return;
  }

  cLen = board[0].length;

  for (i = 0; i < len; i++) {
    for (j = 0; j < cLen; j++) {
      lives = 0;

      for (x = Math.max(i - 1, 0); x <= Math.min(i + 1, len - 1); x++) {
        for (y = Math.max(j - 1, 0); y <= Math.min(j + 1, cLen - 1); y++) {
          lives += board[x][y] & 1;
        }
      }

      // only care the ones that'll be live
      if (lives === 3 || lives - board[i][j] === 3) {
        board[i][j] |= 2;
      }
    }
  }

  for (i = 0; i < len; i++) {
    for (j = 0; j < cLen; j++) {
      board[i][j] >>= 1;
    }
  }
};
```

### Gas Station

```js
/**
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.

Note:
The solution is guaranteed to be unique.
*/
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 *
在任何一个节点，其实我们只关心油的损耗，定义：

diff[i] = gas[i] – cost[i]  0<=i <n

那么这题包含两个问题：

1. 能否在环上绕一圈？

2. 如果能，这个起点在哪里？

第一个问题，很简单，我对diff数组做个加和就好了，leftGas = ∑diff[i]， 如果最后leftGas是正值，那么肯定存在这么一个起始点。如果是负值，那说明，油的损耗大于油的供给，不可能有解。得到第一个问题的答案只需要O(n)。

对于第二个问题，起点在哪里？

假设，我们从环上取一个区间[i, j], j>i， 然后对于这个区间的diff加和，定义

sum[i,j] = ∑diff[k] where i<=k<j

如果sum[i,j]小于0，那么这个起点肯定不会在[i,j]这个区间里，跟第一个问题的原理一样。举个例子，假设i是[0,n]的解，那么我们知道 任意sum[k,i-1] (0<=k<i-1) 肯定是小于0的，否则解就应该是k。同理，sum[i,n]一定是大于0的，否则，解就不应该是i，而是i和n之间的某个点。所以第二题的答案，其实就是在0到n之间，找到第一个连续子序列(这个子序列的结尾必然是n)大于0的。

至此，两个问题都可以在一个循环中解决。
 */
var canCompleteCircuit = function(gas, cost) {
  var len = gas.length,
    diff = [],
    curSum = 0,
    sum = 0,
    i,
    startNode = 0;

  for (i = 0; i < len; i++) {
    diff[i] = gas[i] - cost[i];
    sum += diff[i];
    curSum += diff[i];

    if (curSum < 0) {
      startNode = i + 1;
      curSum = 0;
    }
  }

  if (sum < 0) {
    return -1;
  } else {
    return startNode;
  }
};
```

### Generate Parentheses

```js
// TODO: optimize
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  var i = 1,
    result = [];

  if (n === 0) {
    return result;
  }

  result.push('()');

  while (i < n) {
    result = helper(result);
    i++;
  }

  return result;
};

function helper(arr) {
  var len = arr.length,
    result = [],
    len1,
    curStr,
    tmp,
    i,
    j;

  len1 = arr[0].length;

  for (i = 0; i < len; i++) {
    curStr = arr[i];

    for (j = 0; j < len1; j++) {
      tmp = curStr.substring(0, j) + '()' + curStr.substring(j);

      if (result.indexOf(tmp) === -1) {
        result.push(tmp);
      }
    }
  }

  return result;
}
```

### Graph Valid Tree

```js
/**
 Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

For example:

Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.

Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.

Hint:

    Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree?
    According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”

Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.
*/
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {boolean}
 */
var validTree = function(n, edges) {
  let nodes = [];

  for (let i = 0; i < n; i++) {
    nodes[i] = i;
  }

  for (let i = 0; i < edges.length; i++) {
    let start = edges[i][0];
    let end = edges[i][1];

    while (nodes[start] !== start) {
      start = nodes[start];
    }

    while (nodes[end] !== end) {
      end = nodes[end];
    }

    // cycle detected
    if (start === end) {
      return false;
    }

    nodes[start] = end;
  }
  // edges are enough to connect each node
  return edges.length >= n - 1;
};
```

### Gray Code

```js
/**
The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

00 - 0
01 - 1
11 - 3
10 - 2
Note:
For a given n, a gray code sequence is not uniquely defined.

For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.
*/
/**
 * @param {number} n
 * @return {number[]}
 *
 * 例举grey code序列，并找规律 :
n = 0: 0
n = 1: 0, 1
n = 2: 00, 01, 11, 10  (0, 1, 3, 2)
n = 3: 000, 001, 011, 010, 110, 111, 101, 100 (0, 1, 3, 2, 6, 7, 5, 4)
以n = 3为例，grey code中前4个包括了n = 2的所有gray code。后4个则是前4个逆序后加上2^2。

推广：n = i的grey code的前一半包括了n = i-1的所有grey code，而后一半则为前一半逆序后家上2^(i-1)
 */
var grayCode = function(n) {
  var result = [],
    cur,
    i,
    j;

  result[0] = 0;

  if (n === 0) {
    return result;
  }

  for (i = 1; i <= n; i++) {
    for (j = Math.pow(2, i - 1); j > 0; j--) {
      result.push(result[j - 1] + (1 << (i - 1)));
    }
  }

  return result;
};
```

### H-Index II

```js
/**
Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?

Hint:

Expected runtime complexity is in O(log n) and the input is sorted.
*/
/**
 * @param {number[]} citations
 * @return {number}
 */
var hIndex = function(citations) {
  var len = citations.length,
    start = 0,
    end = len - 1,
    mid;

  while (start <= end) {
    mid = parseInt((start + end) / 2);

    if (citations[mid] === len - mid) {
      return len - mid;
    }

    if (citations[mid] > len - mid) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return len - start;
};
```

### H-Index

```js
/**
Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."

For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.

Note: If there are several possible values for h, the maximum one is taken as the h-index.

Hint:

An easy approach is to sort the array first.
What are the possible values of h-index?
A faster approach is to use extra space.

*/
/**
 * @param {number[]} citations
 * @return {number}
 */
var hIndex = function(citations) {
  var len = citations.length,
    i;

  citations.sort(function(a, b) {
    if (a < b) {
      return 1;
    }
    return -1;
  });

  for (i = 0; i < len; i++) {
    if (citations[i] <= i) {
      return i;
    }
  }

  return len;
};

/**
SOLUTION 2:
复杂度
时间 O(N) 空间 O(N)

思路
也可以不对数组排序，我们额外使用一个大小为N+1的数组stats。stats[i]表示有多少文章被引用了i次，这里如果一篇文章引用大于N次，我们就将其当为N次，因为H指数不会超过文章的总数。为了构建这个数组，我们需要先将整个文献引用数组遍历一遍，对相应的格子加一。统计完后，我们从N向1开始遍历这个统计数组。如果遍历到某一个引用次数时，大于或等于该引用次数的文章数量，大于引用次数本身时，我们可以认为这是H指数。之所以不用再向下找，因为我们要取最大的H指数。那如何求大于或等于某个引用次数的文章数量呢？我们可以用一个变量，从高引用次的文章数累加下来。因为我们知道，如果有x篇文章的引用大于等于3次，那引用大于等于2次的文章数量一定是x加上引用次数等于2次的文章数量。

代码
public class Solution {
    public int hIndex(int[] citations) {
        int[] stats = new int[citations.length + 1];
        int n = citations.length;
        // 统计各个引用次数对应多少篇文章
        for(int i = 0; i < n; i++){
            stats[citations[i] <= n ? citations[i] : n] += 1;
        }
        int sum = 0;
        // 找出最大的H指数
        for(int i = n; i > 0; i--){
            // 引用大于等于i次的文章数量，等于引用大于等于i+1次的文章数量，加上引用等于i次的文章数量
            sum += stats[i];
            // 如果引用大于等于i次的文章数量，大于引用次数i，说明是H指数
            if(sum >= i){
                return i;
            }
        }
        return 0;
    }
}

*/
```

### Happy Number

```js
/**
Write an algorithm to determine if a number is "happy".

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 19 is a happy number

12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  var cur = n,
    num,
    i,
    len,
    result = [],
    sum = 0,
    sums = [];
  while (true) {
    while (cur !== 0) {
      num = cur % 10;
      result.push(num);
      cur = (cur - num) / 10;
    }
    len = result.length;
    for (i = 0; i < len; i++) {
      sum += Math.pow(result[i], 2);
    }
    if (sum === 1) {
      return true;
    } else {
      if (sums.indexOf(sum) !== -1) {
        return false;
      } else {
        sums.push(sum);
        result = [];
        cur = sum;
        sum = 0;
      }
    }
  }
};
```

### House Robber II

```js
/**
Note: This is an extension of House Robber.

After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
*/
/**
 * @param {number[]} nums
 * @return {number}
 * 因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢，那我们这里变通一下，如果我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取其中较大的一个即为所求。
 */
var rob = function(nums) {
  var len = nums.length;

  if (len === 0) {
    return 0;
  }

  if (len === 1) {
    return nums[0];
  }

  return Math.max(getMax(0, len - 1, nums), getMax(1, len, nums));
};

function getMax(start, end, nums) {
  var arr = [],
    i;

  if (end - start <= 1) {
    return nums[start];
  }

  arr[start] = nums[start];
  arr[start + 1] = Math.max(nums[start], nums[start + 1]);

  for (i = start + 2; i < end; i++) {
    arr[i] = Math.max(arr[i - 1], arr[i - 2] + nums[i]);
  }

  return arr[end - 1];
}
```

### House Robber III

```js
/**
The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.

Determine the maximum amount of money the thief can rob tonight without alerting the police.

Example 1:
     3
    / \
   2   3
    \   \
     3   1
Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
Example 2:
     3
    / \
   4   5
  / \   \
 1   3   1
Maximum amount of money the thief can rob = 4 + 5 = 9.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
  var result = dfsRob(root);

  return Math.max(result[0], result[1]);
};

// return an array to keep 2 values:
// the maximum money when a root is selected and the maximum value when a root if NOT selected.
function dfsRob(root) {
  if (!root) {
    return [0, 0];
  }

  var left = dfsRob(root.left),
    right = dfsRob(root.right),
    includeRootVal,
    noRootVal;

  includeRootVal = left[1] + right[1] + root.val;
  noRootVal = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);

  return [includeRootVal, noRootVal];
}
```

### House Robber

```js
/**
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  var len = nums.length,
    result = [],
    i;

  if (len === 0) {
    return 0;
  }
  if (len === 1) {
    return nums[0];
  }

  result[0] = nums[0];
  result[1] = Math.max(nums[1], nums[0]);
  for (i = 2; i < len; i++) {
    result[i] = Math.max(result[i - 2] + nums[i], result[i - 1]);
  }

  return result[len - 1];
};
```

### Implement Queue using Stacks

```js
/**
Implement the following operations of a queue using stacks.

push(x) -- Push element x to the back of queue.
pop() -- Removes the element from in front of queue.
peek() -- Get the front element.
empty() -- Return whether the queue is empty.
Notes:
You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).
*/

/**
 * @constructor
 */
var Queue = function() {
  this.stack1 = []; // come in
  this.stack2 = []; // for go out
};

/**
 * @param {number} x
 * @returns {void}
 */
Queue.prototype.push = function(x) {
  var len = this.stack2.length,
    i;

  for (i = 0; i < len; i++) {
    this.stack1.push(this.stack2.pop());
  }

  this.stack1.push(x);

  for (i = 0; i < len + 1; i++) {
    this.stack2.push(this.stack1.pop());
  }
};

/**
 * @returns {void}
 */
Queue.prototype.pop = function() {
  this.stack2.pop();
};

/**
 * @returns {number}
 */
Queue.prototype.peek = function() {
  var x = this.stack2.pop();

  this.stack2.push(x);
  return x;
};

/**
 * @returns {boolean}
 */
Queue.prototype.empty = function() {
  var len = this.stack2.length;

  if (len === 0) {
    return true;
  }

  return false;
};
```

### Implement Stack using Queues

```js
/**
Implement the following operations of a stack using queues.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
empty() -- Return whether the stack is empty.
Notes:
You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.
Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).
Update (2015-06-11):
The class name of the Java function had been updated to MyStack instead of Stack.


*/

/**
 * @constructor
 */
var Stack = function() {
  this.stack1 = [];
  this.stack2 = [];
};

/**
 * @param {number} x
 * @returns {void}
 */
Stack.prototype.push = function(x) {
  var temp;

  this.stack2.push(x);

  while (this.stack1.length > 0) {
    this.stack2.push(this.stack1.shift());
  }

  temp = this.stack2;
  this.stack2 = this.stack1;
  this.stack1 = temp;
};

/**
 * @returns {void}
 */
Stack.prototype.pop = function() {
  return this.stack1.shift();
};

/**
 * @returns {number}
 */
Stack.prototype.top = function() {
  return this.stack1[0];
};

/**
 * @returns {boolean}
 */
Stack.prototype.empty = function() {
  return this.stack1.length === 0;
};
```

### Implement Trie (Prefix Tree)

```js
/**
Implement a trie with insert, search, and startsWith methods.

Note:
You may assume that all inputs are consist of lowercase letters a-z.
*/
/**
 * @constructor
 * Initialize your data structure here.
 */

// MEMORY LIMIT EXCEEDED
var TrieNode = function() {
  var isEnd,
    links = {};

  return {
    containsKey: function(n) {
      return links[n] !== undefined;
    },
    get: function(ch) {
      return links[ch];
    },
    put: function(ch, node) {
      links[ch] = node;
    },
    setEnd: function() {
      isEnd = true;
    },
    isEnd: function() {
      return isEnd;
    },
  };
};

var Trie = function() {
  this.root = TrieNode();
};

/**
 * @param {string} word
 * @return {void}
 * Inserts a word into the trie.
 */
Trie.prototype.insert = function(word) {
  var len = word.length,
    node = this.root,
    ch,
    i;

  for (i = 0; i < len; i++) {
    ch = word.charAt(i);

    if (!node.containsKey(ch)) {
      node.put(ch, TrieNode());
    }

    node = node.get(ch);
  }

  node.setEnd();
};

/**
 * @param {string} word
 * @return {boolean}
 * Returns if the word is in the trie.
 */
Trie.prototype.search = function(word) {
  var node = this.searchPrefix(word);

  return node && node.isEnd();
};

/**
 * @param {string} prefix
 * @return {boolean}
 * Returns if there is any word in the trie
 * that starts with the given prefix.
 */
Trie.prototype.startsWith = function(prefix) {
  return this.searchPrefix(prefix) !== null;
};

Trie.prototype.searchPrefix = function(prefix) {
  var len = prefix.length,
    node = this.root,
    ch,
    i;

  for (i = 0; i < len; i++) {
    ch = prefix.charAt(i);

    if (!node.containsKey(ch)) {
      return null;
    }

    node = node.get(ch);
  }

  return node;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var trie = new Trie();
 * trie.insert("somestring");
 * trie.search("key");
 */ arch('theomachia'),
  search('roughy'),
  search('hypotarsal'),
  search('snooze'),
  search('pronominalize'),
  search('proselytist'),
  search('lingel');
```

### Implement strStr()

```js
/**
Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
*/

/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
  var len1 = haystack.length,
    len2 = needle.length,
    i,
    j;

  if (len2 === 0) {
    return 0;
  }

  if (len1 === 0 || len1 < len2) {
    return -1;
  }

  i = 0;
  while (i <= len1 - len2) {
    if (haystack.substring(i, i + len2) === needle) {
      return i;
    }
    i++;
  }

  return -1;
};
```

### Increasing Triplet Subsequence

```js
/**
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

Formally the function should:
Return true if there exists i, j, k
such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false.
Your algorithm should run in O(n) time complexity and O(1) space complexity.

Examples:
Given [1, 2, 3, 4, 5],
return true.

Given [5, 4, 3, 2, 1],
return false.

Credits:
Special thanks to @DjangoUnchained for adding this problem and creating all test cases.
*/
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
  var len = nums.length,
    x1 = Number.MAX_VALUE,
    x2 = Number.MAX_VALUE,
    i;

  for (i = 0; i < len; i++) {
    if (nums[i] < x1) {
      x1 = nums[i];
    } else if (x1 < nums[i] && nums[i] < x2) {
      x2 = nums[i];
    } else if (nums[i] > x2) {
      return true;
    }
  }

  return false;
};
```

### Inorder Successor in BST

```js
/**
 Given a binary search tree and a node in it, find the in-order successor of that node in the BST.

Note: If the given node has no in-order successor in the tree, return null.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @return {TreeNode}
 *
 * The inorder successor of p is either p's parent or the left most child of p's right child
 */
var inorderSuccessor = function(root, p) {
  if (!root) {
    return null;
  }

  if (root.val <= p.val) {
    return inorderSuccessor(root.right, p);
  }

  let leftMostChild = inorderSuccessor(root.left, p);
  return leftMostChild ? leftMostChild : root;
};
```

### Insert Interval

```js
/**
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].
*/
/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @param {Interval} newInterval
 * @return {Interval[]}
 */
var insert = function(intervals, newInterval) {
  var len = intervals.length,
    result = [],
    insertIndex = 0,
    curInterval,
    i;

  for (i = 0; i < len; i++) {
    curInterval = intervals[i];

    if (curInterval.end < newInterval.start) {
      result.push(curInterval);
      insertIndex++;
    } else if (curInterval.start > newInterval.end) {
      result.push(curInterval);
    } else {
      newInterval.start = Math.min(newInterval.start, curInterval.start);
      newInterval.end = Math.max(newInterval.end, curInterval.end);
    }
  }

  result.splice(insertIndex, 0, newInterval);

  return result;
};
```

### Insertion Sort List

```js
/**
Sort a linked list using insertion sort.
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var insertionSortList = function(head) {
  var dummy = new ListNode(0),
    pre = dummy,
    cur = head,
    next;

  while (cur !== null) {
    next = cur.next;
    pre = dummy;

    while (pre.next && pre.next.val <= cur.val) {
      pre = pre.next;
    }

    cur.next = pre.next;
    pre.next = cur;
    cur = next;
  }

  return dummy.next;
};
```

### Integer Break

```js
/**
Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).

Note: you may assume that n is not less than 2.

Hint:

There is a simple O(n) solution to this problem.
You may check the breaking results of n ranging from 7 to 10 to discover the regularities.
*/
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
  var dp = [],
    i;

  if (n <= 3) {
    return n - 1;
  }

  dp[0] = 0;
  dp[1] = 1;
  dp[2] = 2;
  dp[3] = 3;

  for (i = 4; i <= n; i++) {
    dp[i] = Math.max(dp[i - 2] * 2, dp[i - 3] * 3);
  }

  return dp[n];
};

// SOLUTION 2
/**
 * @param {number} n
 * @return {number}
 * 可以说，拆成3的比拆成2的乘积大。 比如6的时候 2*2*2 < 3*3

我们希望能尽可能的拆成3，然后才是2.

所以，如果

n % 3 == 0:  那么全部拆成3
n % 3 == 1:  2个2剩下的为3    4*3^(x-1) > 1*3^x
n % 3 == 2:  1个2剩下的为3
 */
var integerBreak = function(n) {
  var dp = [],
    i;

  if (n <= 3) {
    return n - 1;
  }

  switch (n % 3) {
    case 0:
      return Math.pow(3, n / 3);
    case 1:
      return 4 * Math.pow(3, parseInt(n / 3) - 1);
    case 2:
      return 2 * Math.pow(3, parseInt(n / 3));
  }
};
```

### Integer to English Words

```js
/**
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.

For example,
123 -> "One Hundred Twenty Three"
12345 -> "Twelve Thousand Three Hundred Forty Five"
1234567 -> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
Hint:

Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.
Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.
There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)
*/
/**
 * @param {number} num
 * @return {string}
 */
var numberToWords = function(num) {
  const belowTen = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'];
  const belowTwenty = [
    'Ten',
    'Eleven',
    'Twelve',
    'Thirteen',
    'Fourteen',
    'Fifteen',
    'Sixteen',
    'Seventeen',
    'Eighteen',
    'Nineteen',
  ];
  const belowHundred = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'];

  function toWordsHelper(num) {
    let str;

    if (num < 10) {
      str = belowTen[num] + ' ';
    } else if (num < 20) {
      str = belowTwenty[num - 10] + ' ';
    } else if (num < 100) {
      str = belowHundred[parseInt(num / 10) - 2] + ' ' + toWordsHelper(num % 10);
    } else if (num < 1000) {
      str = belowTen[parseInt(num / 100)] + ' Hundred ' + toWordsHelper(num % 100);
    } else if (num < 1000000) {
      str = toWordsHelper(parseInt(num / 1000)) + ' Thousand ' + toWordsHelper(num % 1000);
    } else if (num < 1000000000) {
      str = toWordsHelper(parseInt(num / 1000000)) + ' Million ' + toWordsHelper(num % 1000000);
    } else {
      str = toWordsHelper(parseInt(num / 1000000000)) + ' Billion ' + toWordsHelper(num % 1000000000);
    }

    return str.trim();
  }

  let result = toWordsHelper(num);

  if (result === '') {
    return 'Zero';
  }

  return result;
};
```

### Integer to Roman

```js
/**
Given an integer, convert it to a roman numeral.

Input is guaranteed to be within the range from 1 to 3999.
*/
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function(num) {
  var dict = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'],
    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
    len = 13,
    result = '',
    count,
    i;

  for (i = 0; i < len; i++) {
    if (num >= val[i]) {
      count = Math.floor(num / val[i]);

      while (count > 0) {
        result += dict[i];
        count--;
      }

      num %= val[i];
    }
  }

  return result;
};
```

### Interleaving String

```js
/**
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

For example,
Given:
s1 = "aabcc",
s2 = "dbbca",

When s3 = "aadbbcbcac", return true.
When s3 = "aadbbbaccc", return false.
*/

//dp
/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function(s1, s2, s3) {
  let dp = [];
  const len1 = s1.length;
  const len2 = s2.length;
  const len3 = s3.length;

  if (len1 + len2 !== len3) {
    return false;
  }

  for (let i = 0; i <= len1; i++) {
    const arr = new Array(len2 + 1).fill(false);
    dp.push(arr);
  }

  dp[0][0] = true;

  for (let i = 1; i <= len1; i++) {
    dp[i][0] = s1.charAt(i - 1) === s3.charAt(i - 1);

    if (!dp[i][0]) {
      break;
    }
  }

  for (let j = 1; j <= len2; j++) {
    dp[0][j] = s2.charAt(j - 1) === s3.charAt(j - 1);

    if (!dp[0][j]) {
      break;
    }
  }

  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      let k = i + j - 1;

      dp[i][j] =
        (dp[i][j - 1] && s2.charAt(j - 1) === s3.charAt(k)) || (dp[i - 1][j] && s1.charAt(i - 1) === s3.charAt(k));
    }
  }

  return dp[len1][len2];
};

// Time Limit Exceeded
/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function(s1, s2, s3) {
  if (!s1) {
    return s2 === s3;
  }

  if (!s2) {
    return s1 === s3;
  }

  if (s3.length !== s1.length + s2.length) {
    return false;
  }

  const c1 = s1.charAt(0);
  const c2 = s2.charAt(0);
  const c3 = s3.charAt(0);

  if (c1 === c3 && c2 === c3) {
    return isInterleave(s1.substr(1), s2, s3.substr(1)) || isInterleave(s1, s2.substr(1), s3.substr(1));
  }

  if (c1 === c3) {
    return isInterleave(s1.substr(1), s2, s3.substr(1));
  }

  if (c2 === c3) {
    return isInterleave(s1, s2.substr(1), s3.substr(1));
  }

  return false;
};
```

### Intersection of Two Linked Lists

```js
/**
Write a program to find the node at which the intersection of two singly linked lists begins.


For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗
B:     b1 → b2 → b3
begin to intersect at node c1.


Notes:

If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.
*/

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

// better solution

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  let nodeA = headA;
  let nodeB = headB;

  while (nodeA !== nodeB) {
    nodeA = nodeA === null ? headB : nodeA.next;
    nodeB = nodeB === null ? headA : nodeB.next;
  }

  return nodeA;
};

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  var nodeA = headA,
    nodeB = headB,
    isALonger,
    i = 0;

  if (headA === headB) {
    return headA;
  }

  if (headA === null || headB === null) {
    return null;
  }

  while (nodeA.next && nodeB.next) {
    nodeA = nodeA.next;
    nodeB = nodeB.next;
  }

  while (nodeA.next) {
    nodeA = nodeA.next;
    isALonger = true;
    i++;
  }

  while (nodeB.next) {
    nodeB = nodeB.next;
    isALonger = false;
    i++;
  }

  if (nodeA !== nodeB) {
    return null;
  }

  nodeA = headA;
  nodeB = headB;

  while (i > 0) {
    if (isALonger) {
      nodeA = nodeA.next;
    } else {
      nodeB = nodeB.next;
    }

    i--;
  }

  while (nodeA !== nodeB) {
    nodeA = nodeA.next;
    nodeB = nodeB.next;
  }

  return nodeA;
};
```

### Isomorphic Strings

```js
/**
Given two strings s and t, determine if they are isomorphic.

Two strings are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

For example,
Given "egg", "add", return true.

Given "foo", "bar", return false.

Given "paper", "title", return true.

Note:
You may assume both s and t have the same length.
*/

/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
  var len = s.length,
    mapS = {},
    mapT = {},
    curS,
    curT,
    i;

  for (i = 0; i < len; i++) {
    curS = s.charAt(i);
    curT = t.charAt(i);

    if (!mapS.hasOwnProperty(curS)) {
      mapS[curS] = curT;
    } else if (mapS[curS] !== curT) {
      return false;
    }

    if (!mapT.hasOwnProperty(curT)) {
      mapT[curT] = curS;
    } else if (mapT[curT] !== curS) {
      return false;
    }
  }

  return true;
};
```

### Jump Game II

```js
/**
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

Note:
You can assume that you can always reach the last index.
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
  var len = nums.length,
    step = 0,
    last = 0,
    cover = nums[0],
    i;

  for (i = 1; i < len; i++) {
    if (i > last) {
      last = cover;
      step++;
    }

    if (last >= len - 1) {
      break;
    }

    cover = Math.max(cover, nums[i] + i);
  }

  return step;
};

// time limit exceeded
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
  var len = nums.length,
    result = [];

  result[0] = Number.MAX_VALUE;
  helper(0, nums, 0, 0, result);

  return result[0];
};

function helper(index, nums, cover, step, result) {
  if (cover < index || step > result[0]) {
    return;
  }

  if (cover >= nums.length - 1) {
    result[0] = Math.min(result[0], step);
    return;
  }

  var i = index;

  for (i = index; i <= cover; i++) {
    helper(i + 1, nums, Math.max(cover, nums[i] + i), step + 1, result);
  }
}

// memory limit exceed
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
  var len = nums.length,
    dp = [],
    result = Number.MAX_VALUE,
    reachable = [],
    i,
    j;

  for (j = 0; j < len; j++) {
    reachable.push(new Array(len));
    for (i = j + 1; i < len; i++) {
      if (nums[j] + j >= i) {
        reachable[j][i] = true;
      } else {
        break;
      }
    }
  }
  dp[0] = 1;
  for (i = 1; i < len; i++) {
    // since there's always a solution
    dp[i] = dp[i - 1] + 1;

    for (j = 0; j < i; j++) {
      if (reachable[j][i]) {
        dp[i] = Math.min(dp[i], dp[j] + 1);
      }
    }
  }

  return dp[len - 1];
};
```

### Jump Game

```js
/**
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.


 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  var len = nums.length,
    cover = 0,
    i;

  for (i = 0; i < len; i++) {
    if (cover >= i) {
      cover = Math.max(cover, nums[i] + i);
      if (cover >= len - 1) {
        return true;
      }
    } else {
      return false;
    }
  }
};
```

### Kth Smallest Element in a BST

```js
/**
Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note:
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

Follow up:
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

Hint:

Try to utilize the property of a BST.
What if you could modify the BST node's structure?
The optimal runtime complexity is O(height of BST).
*/

// SOLUTION 1
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  var node = root,
    stack = [],
    count = 0,
    right;

  while (node) {
    stack.push(node);
    node = node.left;
  }

  while (stack.length > 0) {
    node = stack.pop();
    count++;

    if (k === count) {
      return node.val;
    }

    right = node.right;

    while (right) {
      stack.push(right);
      right = right.left;
    }
  }

  return null;
};

// SOLUTION 2

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  var leftSums = findNodesSum(root.left);

  if (leftSums + 1 === k) {
    return root.val;
  }

  if (leftSums + 1 < k) {
    return kthSmallest(root.right, k - leftSums - 1);
  }

  return kthSmallest(root.left, k);
};

function findNodesSum(root) {
  if (!root) {
    return 0;
  }

  return findNodesSum(root.left) + findNodesSum(root.right) + 1;
}

// SOLUTION 3: with modifying property
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  addCountToNode(root);

  return findKth(root, k);
};

function addCountToNode(root) {
  if (!root) {
    return null;
  }

  root.count = 1;
  let left = addCountToNode(root.left);
  let right = addCountToNode(root.right);

  if (left) {
    root.count += left.count;
  }

  if (right) {
    root.count += right.count;
  }

  return root;
}

function findKth(root, k) {
  if (!root) {
    return;
  }

  let leftCount;

  if (!root.left) {
    leftCount = 0;
  } else {
    leftCount = root.left.count;
  }

  if (leftCount === k - 1) {
    return root.val;
  }

  if (leftCount > k - 1) {
    return findKth(root.left, k);
  }

  let newCount = k - 1 - leftCount;

  return findKth(root.right, newCount);
}
```

### LRU Cache

```js
/**
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
*/
class Node {
  constructor(key, val) {
    this.key = key;
    this.val = val;
    this.next = null;
    this.prev = null;
  }
}
/**
 * @constructor
 */
var LRUCache = function(capacity) {
  this.list = null;
  this.map = new Map();
  this.head = null;
  this.tail = null;
  this.size = capacity;
  this.curSize = 0;
};

/**
 * @param {number} key
 * @returns {number}
 */
LRUCache.prototype.get = function(key) {
  if (!this.map.get(key)) {
    return -1;
  }

  let node = this.map.get(key);

  if (node === this.head) {
    return node.val;
  }

  // remove node from list
  if (node === this.tail) {
    this.tail.prev.next = null;
    this.tail = this.tail.prev;
  } else {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }

  // insert node to head
  node.next = this.head;
  this.head.prev = node;
  this.head = node;

  return node.val;
};

/**
 * @param {number} key
 * @param {number} value
 * @returns {void}
 */
LRUCache.prototype.set = function(key, value) {
  let newNode = new Node(key, value);

  if (this.curSize === 0) {
    this.head = newNode;
    this.tail = newNode;
    this.curSize++;
  } else {
    newNode.next = this.head;
    this.head.prev = newNode;
    this.head = newNode;
    this.curSize++;
  }

  // update
  if (this.map.get(key)) {
    let oldNode = this.map.get(key);

    if (oldNode === this.tail) {
      this.tail = this.tail.prev;
      this.tail.next = null;
    } else {
      oldNode.prev.next = oldNode.next;
      oldNode.next.prev = oldNode.prev;
    }

    this.curSize--;
    this.map.set(key, newNode);
  } else {
    if (this.curSize > this.size) {
      //delete tail
      this.map.delete(this.tail.key);
      this.tail = this.tail.prev;
      this.tail.next = null;
      this.curSize--;
    }

    this.map.set(key, newNode);
  }
};
```

### Largest Number

```js
/**
Given a list of non negative integers, arrange them such that they form the largest number.

For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.

Note: The result may be very large, so you need to return a string instead of an integer.

 * @param {number[]} nums
 * @return {string}
 */
var largestNumber = function(nums) {
  var i,
    len = nums.length,
    result = '',
    startWithZero = true;
  nums.sort(function(a, b) {
    var x = a + '' + b,
      y = b + '' + a;
    return parseInt(y) - parseInt(x);
  });
  for (i = 0; i < len; i++) {
    if (startWithZero && nums[i] !== 0) {
      startWithZero = false;
    }
    result += nums[i];
  }
  if (startWithZero) {
    return '0';
  }
  return result;
};
```

### Largest Rectangle in Histogram

```js
/**
Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.


Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].


The largest rectangle is shown in the shaded area, which has area = 10 unit.

For example,
Given heights = [2,1,5,6,2,3],
return 10.
*/
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  var len = heights.length,
    stack = [],
    max = 0,
    cur,
    i;

  if (len === 0) {
    return 0;
  }

  heights[len] = 0;
  len++;

  for (i = 0; i < len; ) {
    if (stack.length > 0 && heights[i] <= heights[stack[stack.length - 1]]) {
      cur = stack.pop();
      // 如果栈已经为空，说明到目前为止所有元素(当前下标元素除外)都比出栈元素高度要大(否则栈中肯定还有元素)，所以矩阵面积就是高度乘以当前下标i。
      // 如果栈不为空，那么就是从当前栈顶元素的下一个到当前下标的元素之前都比出栈元素高度大(因为栈顶元素第一个比当前出栈元素小的)。
      max = Math.max(max, heights[cur] * (stack.length === 0 ? i : i - stack[stack.length - 1] - 1));
      continue;
    }

    stack.push(i);
    i++;
  }

  return max;
};
```

### Length of Last Word

```js
/**
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

For example,
Given s = "Hello World",
return 5.
*/

/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
  var arr = s.split(' '),
    len = arr.length,
    i;

  for (i = len - 1; i >= 0; i--) {
    if (arr[i] !== '' && arr[i] !== ' ') {
      return arr[i].length;
    }
  }

  return 0;
};
```

### Linked List Cycle II

```js
/**
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Follow up:
Can you solve it without using extra space?

 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
  if (head === null) {
    return null;
  }
  var slow = head,
    fast = head,
    met = false;

  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) {
      met = true;
      break;
    }
  }

  if (met) {
    fast = head;
    while (fast !== slow) {
      fast = fast.next;
      slow = slow.next;
    }
    return fast;
  } else {
    return null;
  }
};
```

### Linked List Cycle

```js
/**
Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  var slow = head,
    fast = head;

  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast || (fast && fast.next === slow)) {
      return true;
    }
  }
  return false;
};
```

### Longest Common Prefix

```js
/**
Write a function to find the longest common prefix string amongst an array of strings.
*/
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
  var len = strs.length,
    len1,
    curChar,
    i,
    j;

  if (len === 0) {
    return '';
  }

  len1 = strs[0].length;
  for (i = 0; i < len1; i++) {
    curChar = strs[0].charAt(i);
    for (j = 1; j < len; j++) {
      if (strs[j].charAt(i) !== curChar) {
        return i === 0 ? '' : strs[0].substr(0, i);
      }

      if (strs[j].length === i) {
        return strs[j];
      }
    }
  }

  return strs[0];
};
```

### Longest Consecutive Sequence

```js
/**
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  var len = nums.length,
    map = {}, // key is nums[i], value is i
    visited = [],
    maxLen = 0,
    left,
    right,
    curLen,
    i;

  for (i = 0; i < len; i++) {
    map[nums[i]] = i;
  }

  for (var val in map) {
    i = map[val];

    if (visited[i]) {
      continue;
    }

    val = parseInt(val);
    left = val - 1;
    right = val + 1;
    curLen = 1;

    while (map.hasOwnProperty(left)) {
      visited[map[left]] = true;
      curLen++;
      left--;
    }

    while (map.hasOwnProperty(right)) {
      visited[map[right]] = true;
      curLen++;
      right++;
    }

    if (curLen > maxLen) {
      maxLen = curLen;
    }
  }

  return maxLen;
};
```

### Longest Increasing Path in a Matrix

```js
/**
Given an integer matrix, find the length of the longest increasing path.

From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).

Example 1:

nums = [
  [9,9,4],
  [6,6,8],
  [2,1,1]
]
Return 4
The longest increasing path is [1, 2, 6, 9].

Example 2:

nums = [
  [3,4,5],
  [3,2,6],
  [2,2,1]
]
Return 4
The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
*/
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
  var dp = [], // dp[i][j] the longest increasing path starting from matrix[i][j]
    rLen = matrix.length,
    cLen,
    i,
    j,
    max = 0;

  if (rLen === 0) {
    return 0;
  }

  cLen = matrix[0].length;

  for (i = 0; i < rLen; i++) {
    dp.push(new Array(cLen));
  }

  for (i = 0; i < rLen; i++) {
    for (j = 0; j < cLen; j++) {
      dp[i][j] = 0;
    }
  }

  for (i = 0; i < rLen; i++) {
    for (j = 0; j < cLen; j++) {
      max = Math.max(max, dfs(i, j, rLen, cLen, matrix, dp));
    }
  }

  return max;
};

function dfs(i, j, rLen, cLen, matrix, dp) {
  if (dp[i][j] !== 0) {
    return dp[i][j];
  }

  var dx = [1, 0, 0, -1],
    dy = [0, 1, -1, 0],
    max = 1,
    m,
    len,
    x,
    y;

  for (m = 0; m < 4; m++) {
    x = dx[m] + i;
    y = dy[m] + j;

    if (x >= 0 && y >= 0 && x < rLen && y < cLen && matrix[x][y] > matrix[i][j]) {
      max = Math.max(max, 1 + dfs(x, y, rLen, cLen, matrix, dp));
    }
  }

  dp[i][j] = max;

  return max;
}
```

### Longest Increasing Subsequence

```js
/**

*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  var len = nums.length,
    arr = [],
    i,
    j,
    max = 1;

  if (len === 0) {
    return 0;
  }

  for (i = 0; i < len; i++) {
    arr[i] = 1;
    for (j = 0; j < i; j++) {
      if (nums[i] > nums[j] && arr[j] + 1 > arr[i]) {
        arr[i] = arr[j] + 1;
      }

      max = Math.max(max, arr[i]);
    }
  }

  return max;
};
```

### Longest Substring Without Repeating Characters

```js
/**
Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.

Given "bbbbb", the answer is "b", with the length of 1.

Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
*/
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
  var len = s.length,
    max = 0,
    chars = new Set(),
    leftBound = 0,
    ch,
    i;

  for (i = 0; i < len; i++) {
    ch = s.charAt(i);

    if (chars.has(ch)) {
      // find the repeating character
      while (leftBound < i && s.charAt(leftBound) !== ch) {
        chars.delete(s.charAt(leftBound));
        leftBound++;
      }

      leftBound++;
    } else {
      chars.add(ch);
      max = Math.max(max, i - leftBound + 1);
    }
  }

  return max;
};
```

### Longest Valid Parentheses

```js
/**
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For "(()", the longest valid parentheses substring is "()", which has length = 2.

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.
*/

/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  var len = s.length,
    last = -1,
    left = [],
    max = 0,
    i;

  // the important thing here is track the last ')'
  for (i = 0; i < len; i++) {
    if (s.charAt(i) === '(') {
      left.push(i);
    } else {
      if (left.length === 0) {
        last = i;
      } else {
        left.pop();
        if (left.length === 0) {
          max = Math.max(max, i - last);
        } else {
          max = Math.max(max, i - left[left.length - 1]);
        }
      }
    }
  }

  return max;
};
```

### Lowest Common Ancestor of a Binary Search Tree

```js
/**
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (root === null || root === p || root === q) {
    return root;
  }

  if (root.val > p.val) {
    if (root.val < q.val) {
      return root;
    } else {
      return lowestCommonAncestor(root.left, p, q);
    }
  } else {
    if (root.val > q.val) {
      return root;
    } else {
      return lowestCommonAncestor(root.right, p, q);
    }
  }
};
```

### Lowest Common Ancestor of a Binary Tree

```js
/**
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (!root || root === p || root === q) {
    return root;
  }

  var left = lowestCommonAncestor(root.left, p, q),
    right = lowestCommonAncestor(root.right, p, q);

  // q and p in different side
  if (left && right) {
    return root;
  }

  return left ? left : right;
};
```

### Majority Element II

```js
/**
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.

Hint:

How many majority elements could it possibly have?
*/
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  var len = nums.length,
    candidate1,
    count1 = 0,
    candidate2,
    count2 = 0,
    result = [],
    i;

  for (i = 0; i < len; i++) {
    if (nums[i] === candidate1) {
      count1++;
    } else if (nums[i] === candidate2) {
      count2++;
    } else if (count1 === 0) {
      count1++;
      candidate1 = nums[i];
    } else if (count2 === 0) {
      count2++;
      candidate2 = nums[i];
    } else {
      count1--;
      count2--;
    }
  }

  count1 = 0;
  count2 = 0;

  for (i = 0; i < len; i++) {
    if (nums[i] === candidate1) {
      count1++;
    } else if (nums[i] === candidate2) {
      count2++;
    }
  }

  if (count1 > Math.floor(len / 3)) {
    result.push(candidate1);
  }

  if (count2 > Math.floor(len / 3)) {
    result.push(candidate2);
  }

  return result;
};
```

### Majority Element

```js
/**
 * Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
 * You may assume that the array is non-empty and the majority element always exist in the array.
 *
 * @param {number[]} num
 * @return {number}
 */
var majorityElement = function(num) {
  var i,
    length = num.length,
    max,
    list = {};
  if (length === 1) {
    return num[0];
  }
  for (i = 0; i < length; i++) {
    if (list[num[i]]) {
      max = ++list[num[i]];
      if (i > length / 2 - 1 && max >= length / 2) {
        return num[i];
      }
    } else {
      list[num[i]] = 1;
    }
  }
};

// SOLUTION 2: voting
var majorityElement = function(num) {
  var candidate,
    length = num.length,
    count = 1,
    i;

  candidate = num[0];

  for (i = 1; i < length; i++) {
    if (count === 0 || num[i] === candidate) {
      count++;
      candidate = num[i];
    } else {
      count--;
    }
  }

  return candidate;
};
```

### Maximal Rectangle

```js
/**
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.
*/
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
  var rLen = matrix.length,
    cLen,
    dp = [],
    max = 0,
    stack,
    temp,
    curRow,
    i,
    j;

  if (rLen === 0) {
    return 0;
  }

  cLen = matrix[0].length;

  if (cLen === 1 && rLen === 1) {
    return matrix[0][0] === '1' ? 1 : 0;
  }

  for (i = 0; i < rLen; i++) {
    dp.push(new Array(cLen));

    for (j = 0; j < cLen; j++) {
      if (matrix[i][j] === '0') {
        dp[i][j] = 0;
      } else {
        if (i === 0) {
          dp[i][j] = 1;
        } else {
          dp[i][j] = dp[i - 1][j] + 1;
        }
      }
    }
  }

  for (i = 0; i < rLen; i++) {
    stack = [];

    curRow = dp[i].concat();
    curRow.push(0);
    for (j = 0; j < cLen + 1; ) {
      if (stack.length > 0 && curRow[j] <= curRow[stack[stack.length - 1]]) {
        temp = stack.pop();
        max = Math.max(max, dp[i][temp] * (stack.length === 0 ? j : j - stack[stack.length - 1] - 1));
      } else {
        stack.push(j);
        j++;
      }
    }
  }

  return max;
};
```

### Maximal Square

```js
/**
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area.

For example, given the following matrix:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Return 4.
*/

/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
  var lenX = matrix.length,
    area = [],
    temp = [],
    result = 0,
    lenY,
    i,
    j;

  if (lenX === 0) {
    return 0;
  }

  lenY = matrix[0].length;

  // init two dimension array
  for (i = 0; i < lenX; i++) {
    area[i] = [];
  }

  // init first column
  for (j = 0; j < lenY; j++) {
    area[0][j] = parseInt(matrix[0][j]);
    result = Math.max(result, area[0][j]);
  }

  // init first row
  for (i = 0; i < lenX; i++) {
    area[i][0] = parseInt(matrix[i][0]);
    result = Math.max(result, area[i][0]);
  }

  for (i = 1; i < lenX; i++) {
    for (j = 1; j < lenY; j++) {
      area[i][j] = parseInt(matrix[i][j]);

      if (area[i][j]) {
        area[i][j] = Math.min(area[i - 1][j - 1], area[i - 1][j], area[i][j - 1]) + 1;
      }

      result = Math.max(result, area[i][j]);
    }
  }

  return result * result;
};
```

### Maximum Depth of Binary Tree

```js
/**
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
 * Definition for binary tree
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @returns {number}
 */
var maxDepth = function(root) {
  function getGreater(a, b) {
    return a > b ? a : b;
  }
  if (root === null) {
    return 0;
  }
  return getGreater(maxDepth(root.left), maxDepth(root.right)) + 1;
};
```

### Maximum Gap

```js
/**
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Try to solve it in linear time/space.

Return 0 if the array contains less than 2 elements.

You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
*/

/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap = function(nums) {
  var length = nums.length,
    bucket = [],
    max = Number.MIN_VALUE,
    min = Number.MAX_VALUE,
    gap = 0,
    bLen,
    bIndex,
    prev,
    i;

  if (length < 2) {
    return 0;
  }

  for (i = 0; i < length; i++) {
    if (nums[i] > max) {
      max = nums[i];
    }

    if (nums[i] < min) {
      min = nums[i];
    }
  }

  // length of each bucket
  bLen = Math.floor((max - min) / length) + 1;

  for (i = 0; i < length; i++) {
    bIndex = Math.floor((nums[i] - min) / bLen);

    if (!bucket[bIndex]) {
      bucket[bIndex] = [];
      bucket[bIndex].push(nums[i]);
      bucket[bIndex].push(nums[i]);
    } else {
      if (nums[i] < bucket[bIndex][0]) {
        bucket[bIndex][0] = nums[i];
      } else if (nums[i] > bucket[bIndex][1]) {
        bucket[bIndex][1] = nums[i];
      }
    }
  }

  length = bucket.length;
  prev = 0;

  for (i = 1; i < length; i++) {
    if (!bucket[i]) {
      continue;
    }

    gap = Math.max(gap, bucket[i][0] - bucket[prev][1]);
    prev = i;
  }

  return gap;
};
```

### Maximum Product Subarray

```js
/**
Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.
*/

/**
 * @param {number[]} nums
 * @return {number}
 *
 * max_product[i] = max(max_product[i-1]*A[i], min_product[i-1]*A[i], A[i])
 * min_product[i] = min(max_product[i-1]*A[i], min_product[i-1]*A[i], A[i])
 */
var maxProduct = function(nums) {
  var curMax,
    curMin,
    len = nums.length,
    i,
    result,
    temp;

  if (len === 0) {
    return 0;
  }

  curMax = curMin = result = nums[0];

  for (i = 1; i < len; i++) {
    temp = curMax;
    curMax = Math.max(temp * nums[i], curMin * nums[i], nums[i]);
    curMin = Math.min(temp * nums[i], curMin * nums[i], nums[i]);

    result = Math.max(result, curMax);
  }

  return result;
};
```

### Maximum Product of Word Lengths

```js
/**
Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.

Example 1:
Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
Return 16
The two words can be "abcw", "xtfn".

Example 2:
Given ["a", "ab", "abc", "d", "cd", "bcd", "abcd"]
Return 4
The two words can be "ab", "cd".

Example 3:
Given ["a", "aa", "aaa", "aaaa"]
Return 0
No such pair of words.
*/

/**
 * @param {string[]} words
 * @return {number}
 */
var maxProduct = function(words) {
  var len = words.length,
    arr = [],
    result = 0,
    i,
    j;

  for (i = 0; i < len; i++) {
    arr[i] = 0;

    for (j = 0; j < words[i].length; j++) {
      arr[i] |= 1 << (words[i].charCodeAt(j) - 97);
    }
  }

  for (i = 0; i < len; i++) {
    for (j = i + 1; j < len; j++) {
      if ((arr[i] & arr[j]) === 0) {
        result = Math.max(result, words[i].length * words[j].length);
      }
    }
  }

  return result;
};
```

### Maximum Subarray

```js
/**
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.
*/

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  var sum = 0,
    max = Number.NEGATIVE_INFINITY,
    len = nums.length,
    i;

  for (i = 0; i < len; i++) {
    sum += nums[i];

    max = Math.max(sum, max);

    if (sum < 0) {
      sum = 0;
    }
  }

  return max;
};

// divide and conquer

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  return helper(0, nums.length - 1, nums);
};

function helper(start, end, arr) {
  if (start > end) {
    return Number.NEGATIVE_INFINITY;
  }

  if (start === end) {
    return arr[start];
  }

  var mid = Math.floor((start + end) / 2),
    leftMax = Number.NEGATIVE_INFINITY,
    rightMax = Number.NEGATIVE_INFINITY,
    midMax,
    i,
    curSum;

  for (i = mid - 1, curSum = 0; i >= start; i--) {
    curSum += arr[i];
    leftMax = Math.max(curSum, leftMax);
  }

  for (i = mid + 1, curSum = 0; i <= end; i++) {
    curSum += arr[i];
    rightMax = Math.max(curSum, rightMax);
  }

  midMax = arr[mid] + Math.max(leftMax, 0) + Math.max(rightMax, 0);

  return Math.max(midMax, helper(start, mid - 1, arr), helper(mid + 1, end, arr));
}
```

### Median of Two Sorted Arrays

```js
/**
There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).


*/
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  var len1 = nums1.length,
    len2 = nums2.length,
    len = len1 + len2;

  if (len % 2 === 1) {
    return findMedianHelper(0, nums1, 0, nums2, (len + 1) / 2);
  } else {
    return (findMedianHelper(0, nums1, 0, nums2, len / 2) + findMedianHelper(0, nums1, 0, nums2, len / 2 + 1)) / 2;
  }
};

function findMedianHelper(aStart, numsA, bStart, numsB, k) {
  if (aStart >= numsA.length) {
    return numsB[bStart + k - 1];
  }

  if (bStart >= numsB.length) {
    return numsA[aStart + k - 1];
  }

  if (k === 1) {
    return Math.min(numsA[aStart], numsB[bStart]);
  }

  var aKey = aStart + parseInt(k / 2) - 1 < numsA.length ? numsA[aStart + parseInt(k / 2) - 1] : Number.MAX_VALUE,
    bKey = bStart + parseInt(k / 2) - 1 < numsB.length ? numsB[bStart + parseInt(k / 2) - 1] : Number.MAX_VALUE;

  if (aKey < bKey) {
    return findMedianHelper(aStart + parseInt(k / 2), numsA, bStart, numsB, k - parseInt(k / 2));
  }

  return findMedianHelper(aStart, numsA, bStart + parseInt(k / 2), numsB, k - parseInt(k / 2));
}
```

### Meeting Rooms II

```js
/**
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.

For example,
Given [[0, 30],[5, 10],[15, 20]],
return 2.
*/
/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {number}
 */
var minMeetingRooms = function(intervals) {
  let start = [];
  let end = [];
  let len = intervals.length;

  for (let i = 0; i < len; i++) {
    start[i] = intervals[i].start;
    end[i] = intervals[i].end;
  }

  start.sort((a, b) => a - b);
  end.sort((a, b) => a - b);

  let rooms = 0;
  let endIndex = 0;

  for (let i = 0; i < len; i++) {
    if (start[i] < end[endIndex]) {
      rooms++;
    } else {
      endIndex++;
    }
  }

  return rooms;
};
```

### Merge Intervals

```js
/**
Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
*/
/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {Interval[]}
 */
var merge = function(intervals) {
  var len = intervals.length,
    start = null,
    end,
    result = [],
    cur,
    i;

  if (len <= 1) {
    return intervals;
  }

  intervals.sort(function(a, b) {
    if (a.start < b.start) {
      return -1;
    } else if (a.start > b.start) {
      return 1;
    } else {
      return a.end - b.end;
    }
  });

  for (i = 0; i < len; i++) {
    cur = intervals[i];

    if (i === 0) {
      start = cur.start;
      end = cur.end;
    } else {
      if (cur.start <= end) {
        end = Math.max(end, cur.end);
      } else {
        result.push(new Interval(start, end));
        start = cur.start;
        end = cur.end;
      }
    }
  }

  if (start !== null) {
    result.push(new Interval(start, end));
  }

  return result;
};
```

### Merge Sorted Array

```js
/**
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.
*/

/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
  // starting from the end!
  while (m > 0 && n > 0) {
    if (nums1[m - 1] > nums2[n - 1]) {
      nums1[m + n - 1] = nums1[m - 1];
      m--;
    } else {
      nums1[m + n - 1] = nums2[n - 1];
      n--;
    }
  }

  while (n > 0) {
    nums1[n - 1] = nums2[n - 1];
    n--;
  }
};
```

### Merge Two Sorted Lists

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (!l1) {
    return l2;
  }

  if (!l2) {
    return l1;
  }

  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};

// iterative solution
var mergeTwoLists = function(l1, l2) {
  var head1 = l1,
    head2 = l2,
    curHead,
    head;

  if (!head1) {
    return head2;
  }

  if (!head2) {
    return head1;
  }

  if (head1.val < head2.val) {
    head = head1;
    curHead = head;
    head1 = head1.next;
  } else {
    head = head2;
    curHead = head;
    head2 = head2.next;
  }

  while (head1 && head2) {
    if (head1.val < head2.val) {
      curHead.next = head1;
      curHead = head1;
      head1 = head1.next;
    } else {
      curHead.next = head2;
      curHead = head2;
      head2 = head2.next;
    }
  }

  if (head1) {
    curHead.next = head1;
  } else if (head2) {
    curHead.next = head2;
  }

  return head;
};
```

### Merge k Sorted Lists

```js
/**
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  var len = lists.length;

  if (len === 0) {
    return null;
  }

  if (len === 1) {
    return lists[0];
  }

  return mergeHelper(lists, 0, len - 1);
};

function mergeHelper(lists, start, end) {
  if (start === end) {
    return lists[start];
  }

  if (start > end) {
    return null;
  }

  var mid = parseInt((start + end) / 2),
    left,
    right;

  left = mergeHelper(lists, start, mid);
  right = mergeHelper(lists, mid + 1, end);

  return mergeTwoLists(left, right);
}

function mergeTwoLists(left, right) {
  if (!left) {
    return right;
  }

  if (!right) {
    return left;
  }

  var dummy = new ListNode(0),
    prev = dummy,
    node1 = left,
    node2 = right;

  while (node1 && node2) {
    if (node1.val < node2.val) {
      prev.next = node1;
      node1 = node1.next;
    } else {
      prev.next = node2;
      node2 = node2.next;
    }

    prev = prev.next;
  }

  if (node1) {
    prev.next = node1;
  }

  if (node2) {
    prev.next = node2;
  }

  return dummy.next;
}
```

### Min Stack

```js
/**
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.


 * @constructor
 */
var MinStack = function() {
  this.min = [];
  this.arr = [];
};

/**
 * @param {number} x
 * @returns {void}
 */
MinStack.prototype.push = function(x) {
  var len = this.min.length;
  if (this.arr.length === 0) {
    this.min.push(x);
  } else if (this.min[len - 1] >= x) {
    this.min.push(x);
  }
  this.arr.push(x);
};

/**
 * @returns {void}
 */
MinStack.prototype.pop = function() {
  var elem,
    len = this.min.length;
  if (this.arr.length > 0) {
    elem = this.arr.pop();
  }
  if (elem === this.min[len - 1]) {
    this.min.pop();
  }
};

/**
 * @returns {number}
 */
MinStack.prototype.top = function() {
  var len = this.arr.length;
  if (len > 0) {
    return this.arr[len - 1];
  }
};

/**
 * @returns {number}
 */
MinStack.prototype.getMin = function() {
  var len = this.min.length;
  return this.min[len - 1];
};
```

### Minimum Depth of Binary Tree

```js
/**
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
  if (root === null) {
    return 0;
  }

  if (root.left === null) {
    return minDepth(root.right) + 1;
  }

  if (root.right === null) {
    return minDepth(root.left) + 1;
  }

  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
};
```

### Minimum Height Trees

```js
/**
For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.

Format
The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).

You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

Example 1:

Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3
return [1]

Example 2:

Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5
return [3, 4]

Hint:

How many MHTs can a graph have at most?
Note:

(1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”

(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.
*/

/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var findMinHeightTrees = function(n, edges) {
  var map = [], // map[i]是一个一维数组，保存了i节点可以到达的所有节点
    len = edges.length,
    leaves = [],
    newLeaves,
    leaf,
    newLeaf,
    curEdge,
    i,
    j;

  if (len === 0) {
    leaves.push(0);
    return leaves;
  }

  for (i = 0; i < n; i++) {
    map[i] = [];
  }

  for (i = 0; i < len; i++) {
    curEdge = edges[i];
    map[curEdge[0]].push(curEdge[1]);
    map[curEdge[1]].push(curEdge[0]);
  }

  for (i = 0; i < n; i++) {
    if (map[i].length === 1) {
      leaves.push(i);
    }
  }

  while (n > 2) {
    n -= leaves.length;
    newLeaves = [];

    for (i in leaves) {
      leaf = leaves[i];
      for (j in map[leaf]) {
        newLeaf = map[leaf][j];
        map[newLeaf].splice(map[newLeaf].indexOf(leaf), 1);
        map[leaf] = [];

        if (map[newLeaf].length === 1) {
          newLeaves.push(newLeaf);
        }
      }
    }

    leaves = newLeaves;
  }

  return leaves;
};
```

### Minimum Path Sum

```js
/**
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.
*/
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
  var result = [],
    rowL = grid.length,
    columnL,
    i,
    j;

  if (rowL === 0) {
    return result;
  }

  columnL = grid[0].length;

  for (i = 0; i < rowL; i++) {
    result.push(new Array(columnL));
  }

  result[0][0] = grid[0][0];

  for (i = 1; i < columnL; i++) {
    result[0][i] = grid[0][i] + result[0][i - 1];
  }

  for (i = 1; i < rowL; i++) {
    result[i][0] = grid[i][0] + result[i - 1][0];
  }

  for (i = 1; i < rowL; i++) {
    for (j = 1; j < columnL; j++) {
      result[i][j] = Math.min(result[i - 1][j], result[i][j - 1]) + grid[i][j];
    }
  }

  return result[rowL - 1][columnL - 1];
};
```

### Minimum Size Subarray sum

```js
/**
Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return 0 instead.

For example, given the array [2,3,1,2,4,3] and s = 7,
the subarray [4,3] has the minimal length under the problem constraint.

click to show more practice.

More practice:
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
*/
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
// O(n) solution
var minSubArrayLen = function(s, nums) {
  var len = nums.length,
    left = 0,
    right = 0,
    sum = 0,
    result = Number.MAX_VALUE;

  if (len === 0) {
    return 0;
  }

  sum += nums[left];

  while (right < len) {
    while (sum < s && right < len) {
      right++;
      sum += nums[right];
    }

    while (sum >= s) {
      result = Math.min(result, right - left + 1);
      sum -= nums[left];
      left++;
    }
  }

  if (result === Number.MAX_VALUE) {
    return 0;
  }

  return result;
};

//O(nlgn) solution
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
  var len = nums.length,
    right = 0,
    sums = [],
    result = Number.MAX_VALUE,
    i;

  if (len === 0) {
    return 0;
  }

  sums[0] = 0;

  for (i = 1; i <= len; i++) {
    sums[i] = nums[i - 1] + sums[i - 1];
  }

  for (i = 0; i <= len; i++) {
    right = findRight(i + 1, len, s + sums[i], sums);

    if (right === len + 1) {
      break;
    }

    if (result > right - i) {
      result = right - i;
    }
  }

  return result === Number.MAX_VALUE ? 0 : result;
};

function findRight(left, right, key, sums) {
  var mid;

  while (left <= right) {
    mid = Math.floor((left + right) / 2);
    if (sums[mid] >= key) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return left;
}
```

### Minimum Window Substring

```js
/**
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

For example,
S = "ADOBECODEBANC"
T = "ABC"
Minimum window is "BANC".

Note:
If there is no such window in S that covers all characters in T, return the empty string "".

If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.
*/

/**
可以利用两个指针扫描(两个指针分别为start，i)，以S = “e b a d b a c c b”(忽略空格)，T = “abc”为例：

                                                                            0 1 2 3 4 5 6 7 8

初始化 start = i = 0
i 逐渐往后扫描S直到窗口S[start…i]包含所有T的字符，此时i = 6(字符c的位置)
缩减窗口：此时我们注意到窗口并不是最小的，需要调整 start 来缩减窗口。缩减规则为：如果S[start]不在T中 或者 S[start]在T中但是删除后窗口依然可以包含T中的所有字符，那么start = start+1， 直到不满足上述两个缩减规则。缩减后i即为窗口的起始位置，此例中从e开始窗口中要依次删掉e、b、a、d，start最后等于4 ，那么得到一个窗口大小为6-4+1 = 3
start = start+1(此时窗口肯定不会包含所有的T中的字符)，跳转到步骤2继续寻找下一个窗口。本例中还以找到一个窗口start = 5，i = 8，比上个窗口大，因此最终的最小窗口是S[4…6]
*/

/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
  var tSet = {},
    tFoundSet = {},
    hasFound = 0,
    lenS = s.length,
    lenT = t.length,
    winStart = -1,
    winEnd = lenS,
    result,
    start,
    c,
    i,
    j;

  for (i = 0; i < lenT; i++) {
    tFoundSet[t.charAt(i)] = 0;
    tSet[t.charAt(i)] = tSet[t.charAt(i)] ? tSet[t.charAt(i)] + 1 : 1;
  }

  for (i = 0, start = 0; i < lenS; i++) {
    c = s.charAt(i);
    if (tSet.hasOwnProperty(c)) {
      if (tFoundSet[c] < tSet[c]) {
        hasFound++;
      }

      tFoundSet[s.charAt(i)]++;
    }

    if (hasFound === lenT) {
      while (!tSet[s.charAt(start)] || tFoundSet[s.charAt(start)] > tSet[s.charAt(start)]) {
        if (tFoundSet[s.charAt(start)]) {
          tFoundSet[s.charAt(start)]--;
        }
        start++;
      }

      if (winEnd - winStart > i - start) {
        winStart = start;
        winEnd = i;
      }

      tFoundSet[s.charAt(start)]--;
      start++;
      hasFound--;
    }
  }

  return winStart !== -1 ? s.substr(winStart, winEnd - winStart + 1) : '';
};
```

### Missing Number

```js
/**
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

For example,
Given nums = [0, 1, 3] return 2.

Note:
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
  var len = nums.length,
    sum = 0,
    i;

  for (i = 0; i < len; i++) {
    sum += nums[i];
  }

  return (len * (len + 1)) / 2 - sum;
};
```

### Missing Ranges

```js
/**
Given a sorted integer array where the range of elements are [lower, upper] inclusive, return its missing ranges.

For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return ["2", "4->49", "51->74", "76->99"].
*/
/**
 * @param {number[]} nums
 * @param {number} lower
 * @param {number} upper
 * @return {string[]}
 */
var findMissingRanges = function(nums, lower, upper) {
  let start, prev, end;
  let result = [];
  const len = nums.length;

  if (len === 0) {
    if (lower === upper) {
      result.push(lower + '');
    } else {
      result.push(lower + '->' + upper);
    }

    return result;
  }

  start = nums[0];
  prev = nums[0];

  if (start > lower) {
    start--;

    if (lower === start) {
      result.push(lower + '');
    } else {
      result.push(lower + '->' + start);
    }
  }

  for (let i = 1; i < len; i++) {
    if (nums[i] > prev + 1) {
      start = prev + 1;
      end = nums[i] - 1;

      if (start === end) {
        result.push(start + '');
      } else {
        result.push(start + '->' + end);
      }
    }

    prev = nums[i];
  }

  if (prev + 1 === upper) {
    result.push(upper + '');
  } else if (prev + 1 < upper) {
    result.push(prev + 1 + '->' + upper);
  }

  return result;
};
```

### Move Zeroes 2

```js
/**
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].

Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.
*/

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
  var len = nums.length,
    curIndex = 0,
    i;

  for (i = 0; i < len; i++) {
    if (nums[i] === 0) {
      continue;
    }

    nums[curIndex] = nums[i];
    curIndex++;
  }

  for (i = curIndex; i < len; i++) {
    nums[i] = 0;
  }
};
```

### Move Zeroes

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
  y = 0;
  var temp;
  for (var i = 0; i < nums.length; i++) {
    if (nums[i]) {
      temp = nums[i];
      nums[i] = nums[y];
      nums[y] = temp;
      y += 1;
    }
  }
};
```

### Multiply Strings

```js
/**
Given two numbers represented as strings, return multiplication of the numbers as a string.

Note:
The numbers can be arbitrarily large and are non-negative.
Converting the input string to integer is NOT allowed.
You should NOT use internal library such as BigInteger.
*/

// BETTER SOLUTION
//  `num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]`
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
  const len1 = num1.length;
  const len2 = num2.length;
  let result = new Array(len1 + len2).fill(0);

  for (let i = len1 - 1; i >= 0; i--) {
    for (let j = len2 - 1; j >= 0; j--) {
      let value = parseInt(num1.charAt(i)) * parseInt(num2.charAt(j));
      result[i + j + 1] += value;

      if (result[i + j + 1] >= 10) {
        result[i + j] += parseInt(result[i + j + 1] / 10);
        result[i + j + 1] = result[i + j + 1] % 10;
      }
    }
  }

  let string = '';

  for (let i = 0; i < result.length; i++) {
    if (string === '' && result[i] === 0) {
      continue;
    }

    string += result[i];
  }

  return string === '' ? '0' : string;
};

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
  var len1 = num1.length,
    len2 = num2.length,
    result = [],
    carry,
    val,
    arr1,
    arr2,
    i,
    j;

  for (i = 0; i < len1 + len2; i++) {
    result.push(0);
  }

  arr1 = num1.split('').reverse();
  arr2 = num2.split('').reverse();

  for (i = 0; i < len1; i++) {
    val = arr1[i] - '0';
    carry = 0;

    for (j = 0; j < len2; j++) {
      carry += val * (arr2[j] - '0') + result[i + j];
      result[i + j] = carry % 10;
      carry = parseInt(carry / 10);
    }

    if (carry !== 0) {
      result[len2 + i] = carry;
    }
  }

  result = result.reverse();

  i = 0;

  while (i < len1 + len2 - 1 && result[i] === 0) {
    i++;
  }

  return result.slice(i).join('');
};
```

### Next Permutation

```js
/**
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  var len = nums.length,
    partiIndex,
    switchIndex,
    cur,
    i,
    k;

  if (len === 0 || len === 1) {
    return;
  }

  //find the num which breaks the increasing from the end
  for (i = len - 1; i > 0; i--) {
    if (nums[i] > nums[i - 1]) {
      partiIndex = i - 1;
      break;
    }
  }

  if (partiIndex === undefined) {
    for (i = 0; i < len / 2; i++) {
      cur = nums[i];
      nums[i] = nums[len - i - 1];
      nums[len - i - 1] = cur;
    }
  } else {
    //find the number that it can be switched with
    cur = nums[partiIndex];
    for (i = len - 1; i > partiIndex; i--) {
      if (nums[i] > cur) {
        switchIndex = i;
        break;
      }
    }

    nums[partiIndex] = nums[switchIndex];
    nums[switchIndex] = cur;

    for (i = 0; i < (len - 1 - partiIndex) / 2; i++) {
      k = i + partiIndex + 1;
      cur = nums[k];
      nums[k] = nums[len - 1 - i];
      nums[len - 1 - i] = cur;
    }
  }
};
```

### Nim Game

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
  return n % 4 > 0;
};
```

### Number of 1 Bits

```js
/**
Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.

 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  var result = 0;
  while (n > 0) {
    //compare last digit
    //bitwise AND compare
    if ((n & 1) === 1) {
      result++;
    }
    n >>>= 1;
  }
  return result;
};
```

### Number of Digit One

```js
/**
Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

For example:
Given n = 13,
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.

Hint:

Beware of overflow.
*/
/**
intuitive: 每10个数, 有一个个位是1, 每100个数, 有10个十位是1, 每1000个数, 有100个百位是1.  做一个循环, 每次计算单个位上1得总个数(个位,十位, 百位).
例子:
以算百位上1为例子:   假设百位上是0, 1, 和 >=2 三种情况:
    case 1: n=3141092, a= 31410, b=92. 计算百位上1的个数应该为 3141 *100 次.
    case 2: n=3141192, a= 31411, b=92. 计算百位上1的个数应该为 3141 *100 + (92+1) 次.
    case 3: n=3141592, a= 31415, b=92. 计算百位上1的个数应该为 (3141+1) *100 次.
以上三种情况可以用 一个公式概括:
(a + 8) / 10 * m + (a % 10 == 1) * (b + 1);
*/
/**
 * @param {number} n
 * @return {number}
 */
var countDigitOne = function(n) {
  var ones = 0,
    a,
    b,
    m;

  for (m = 1; m <= n; m *= 10) {
    a = Math.floor(n / m);
    b = n % m;
    ones += Math.floor((a + 8) / 10) * m;

    if (a % 10 === 1) {
      ones += b + 1;
    }
  }

  return ones;
};
```

### Number of Islands

```js
/**
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3
*/

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  var len = grid.length,
    result = 0,
    len1,
    i,
    j;

  if (len === 0) {
    return 0;
  }

  len1 = grid[0].length;

  if (len1 === 0) {
    return 0;
  }

  for (i = 0; i < len; i++) {
    for (j = 0; j < len1; j++) {
      if (grid[i][j] !== '1') {
        continue;
      }

      result++;
      dfs(grid, i, j, len, len1);
    }
  }

  return result;
};

function dfs(grid, i, j, len, len1) {
  if (i >= len || j >= len1 || i < 0 || j < 0) {
    return;
  }

  if (grid[i][j] === '1') {
    grid[i][j] = '0';
    dfs(grid, i - 1, j, len, len1);
    dfs(grid, i, j - 1, len, len1);
    dfs(grid, i + 1, j, len, len1);
    dfs(grid, i, j + 1, len, len1);
  }
}
```

### Odd Even Linked List

```js
/**
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example:
Given 1->2->3->4->5->NULL,
return 1->3->5->2->4->NULL.

Note:
The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
  if (head === null) {
    return null;
  }

  var oddHead = head,
    evenHead = head.next,
    oddTail = oddHead,
    evenTail = evenHead,
    node = head.next;

  while (node && node.next) {
    oddTail.next = node.next;
    evenTail.next = node.next.next;
    oddTail = oddTail.next;
    evenTail = evenTail.next;
    node = oddTail.next;
  }

  oddTail.next = evenHead;

  return oddHead;
};
```

### One Edit Distance

```js
/**
Given two strings S and T, determine if they are both one edit distance apart
*/
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isOneEditDistance = function(s, t) {
  for (let i = 0; i < Math.min(s.length, t.length); i++) {
    if (s.charAt(i) !== t.charAt(i)) {
      if (s.length === t.length) {
        return s.substring(i + 1) === t.substring(i + 1);
      } else if (s.length < t.length) {
        return s.substring(i) === t.substring(i + 1);
      } else {
        return s.substring(i + 1) === t.substring(i);
      }
    }
  }

  return Math.abs(s.length - t.length) === 1;
};
```

### Palindrome Linked List

```js
/**
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  var fast = head,
    slow = head,
    midPoint;

  if (head === null || head.next === null) {
    return true;
  }

  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
  }

  midPoint = reverse(slow);
  fast = head;

  while (midPoint && fast && fast.val === midPoint.val) {
    midPoint = midPoint.next;
    fast = fast.next;
  }

  return midPoint === null;
};

function reverse(head) {
  if (!head) {
    return null;
  }

  if (!head.next) {
    return head;
  }

  var newHead = reverse(head.next);

  head.next.next = head;
  head.next = null;

  return newHead;
}
```

### Palindrome Pairs

```js
/**
Given a list of unique words. Find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.

Example 1:
Given words = ["bat", "tab", "cat"]
Return [[0, 1], [1, 0]]
The palindromes are ["battab", "tabbat"]
Example 2:
Given words = ["abcd", "dcba", "lls", "s", "sssll"]
Return [[0, 1], [1, 0], [3, 2], [2, 4]]
The palindromes are ["dcbaabcd", "abcddcba", "slls", "llssssll"]
*/

/**
 * @param {string[]} words
 * @return {number[][]}
 */
var palindromePairs = function(words) {
  var len = words.length,
    map = {},
    palindromeMap = {},
    word,
    wordLen,
    tempArr,
    result = new Set(),
    resultArr = [],
    sub1,
    sub2,
    i,
    j;

  for (i = 0; i < len; i++) {
    map[words[i]] = i;

    // if (isPalindrome(words[i])) {
    //     palindromeMap[words[i]] = i;
    // }
  }

  for (i = 0; i < len; i++) {
    word = words[i];
    wordLen = word.length;

    // if (isPalindrome(word)) {
    //     for (var key in palindromeMap) {
    //         temp = [];

    //         if (palindromeMap[key] !== i) {
    //             temp.push(palindromeMap[key]);
    //             temp.push(i);
    //             result.add(temp);
    //         }
    //     }

    //     continue;
    // }

    for (j = 0; j <= wordLen; j++) {
      sub1 = word.substring(0, j);
      sub2 = word.substring(j, wordLen);

      if (isPalindrome(sub1)) {
        sub2 = sub2
          .split('')
          .reverse()
          .join('');

        if (map.hasOwnProperty(sub2) && map[sub2] !== i) {
          temp = [];
          temp.push(map[sub2]);
          temp.push(i);
          result.add(temp.toString());
        }
      }

      if (isPalindrome(sub2)) {
        sub1 = sub1
          .split('')
          .reverse()
          .join('');

        if (map.hasOwnProperty(sub1) && map[sub1] !== i) {
          temp = [];
          temp.push(i);
          temp.push(map[sub1]);
          result.add(temp.toString());
        }
      }
    }
  }

  result.forEach(function(item) {
    temp = item.split(',');
    temp[0] = parseInt(temp[0]);
    temp[1] = parseInt(temp[1]);
    resultArr.push(temp);
  });

  return resultArr;
};

function isPalindrome(s) {
  var start = 0,
    end = s.length - 1;

  while (start < end) {
    if (s.charAt(start) !== s.charAt(end)) {
      return false;
    }

    start++;
    end--;
  }

  return true;
}
```

### Palindrome Partitioning II

```js
/**
Given a string s, partition s such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of s.

For example, given s = "aab",
Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.
*/
/**
 * @param {string} s
 * @return {number}
 */
var minCut = function(s) {
  const len = s.length;
  let dp = [];
  let cut = [];
  let i, j;

  for (i = 0; i < len; i++) {
    dp.push(new Array(len).fill(false));
  }

  for (i = 0; i < len; i++) {
    for (j = i; j >= 0; j--) {
      if (s.charAt(j) === s.charAt(i) && (i - j < 2 || dp[j + 1][i - 1])) {
        dp[j][i] = true;
      }
    }
  }

  // cur[i] how many cuts from 0 to i
  cut[0] = 0;

  for (i = 1; i <= len; i++) {
    for (j = i; j > 0; j--) {
      if (dp[j - 1][i - 1]) {
        cut[i] = Math.min(cut[i] ? cut[i] : Number.MAX_VALUE, cut[j - 1] + 1);
      }
    }
  }

  return cut[len] - 1;
};
```

### Palindrome Partitioning

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
  var result = [];

  genPartition(s, result, 0, []);

  return result;
};

function genPartition(s, result, index, curArr) {
  if (index === s.length) {
    result.push(curArr);
    return;
  }

  var len = s.length,
    j;

  for (j = index + 1; j <= len; j++) {
    if (isPalindrome(s.substring(index, j))) {
      curArr.push(s.substring(index, j));
      genPartition(s, result, j, curArr.concat());
      curArr.pop();
    }
  }
}

function isPalindrome(a) {
  var len = a.length,
    i = 0,
    j = len - 1;

  if (len === 0 || len === 1) {
    return true;
  }

  while (i < j) {
    if (a.charAt(i) !== a.charAt(j)) {
      return false;
    }
    i++;
    j--;
  }

  return true;
}

// optimize with dp
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
  var result = [],
    isPal = [],
    len = s.length,
    i,
    j;

  for (i = 0; i < len; i++) {
    isPal.push(new Array(len));
  }

  // i can also start from len - 1, then i--
  for (i = 0; i < len; i++) {
    for (j = i; j >= 0; j--) {
      if (s.charAt(i) === s.charAt(j) && (i - j < 2 || isPal[j + 1][i - 1])) {
        isPal[j][i] = true;
      }
    }
  }

  genPartition(s, result, 0, [], isPal);

  return result;
};

function genPartition(s, result, index, curArr, isPal) {
  if (index === s.length) {
    result.push(curArr);
    return;
  }

  var len = s.length,
    j;

  for (j = index; j < len; j++) {
    if (isPal[index][j]) {
      curArr.push(s.substring(index, j + 1));
      genPartition(s, result, j + 1, curArr.concat(), isPal);
      curArr.pop();
    }
  }
}
```

### Partition List

```js
/**
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

For example,
Given 1->4->3->2->5->2 and x = 3,
return 1->2->2->4->3->5.

*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function(head, x) {
  var cur = head,
    next,
    preHead,
    preTail,
    afterHead,
    afterTail;

  if (head === null) {
    return null;
  }

  while (cur) {
    next = cur.next;
    cur.next = null;
    if (cur.val < x) {
      if (!preHead) {
        preHead = cur;
        preTail = cur;
      } else {
        preTail.next = cur;
        preTail = cur;
      }
    } else {
      if (!afterHead) {
        afterHead = cur;
        afterTail = cur;
      } else {
        afterTail.next = cur;
        afterTail = cur;
      }
    }
    cur = next;
  }

  if (preTail) {
    preTail.next = afterHead;
    return preHead;
  } else {
    return afterHead;
  }
};
```

### Pascal's Triangle II

```js
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
  var result = [],
    parent = [],
    curRow,
    i;

  if (rowIndex < 0) {
    return result;
  }

  curRow = 0;
  parent.push(1);
  result.push(1);

  while (curRow < rowIndex) {
    curRow++;
    result = [];
    result.push(1);
    for (i = 1; i < curRow; i++) {
      result[i] = parent[i] + parent[i - 1];
    }

    result.push(1);
    parent = result.concat();
  }

  return result;
};

// in place solution
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
  var result = [],
    curRow,
    i;

  if (rowIndex < 0) {
    return result;
  }

  curRow = 0;
  result.push(1);

  while (curRow < rowIndex) {
    curRow++;

    for (i = curRow - 1; i > 0; i--) {
      result[i] = result[i] + result[i - 1];
    }

    result.push(1);
  }

  return result;
};
```

### Pascal's Triangle

```js
/**
Given numRows, generate the first numRows of Pascal's triangle.

For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
*/
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
  var init = [],
    result = [],
    i;

  if (numRows === 0) {
    return result;
  }

  init.push(1);
  result.push(init);
  i = 1;

  while (i < numRows) {
    result = helper(result, ++i);
  }

  return result;
};

function helper(arr, k) {
  var len = arr.length,
    cur = arr[len - 1],
    result = [],
    i;

  result.push(1);

  for (i = 0; i < len - 1; i++) {
    result[i + 1] = cur[i] + cur[i + 1];
  }

  result.push(1);
  arr.push(result);

  return arr;
}
```

### Patching Array

```js
/**
Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.

Example 1:
nums = [1, 3], n = 6
Return 1.

Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
So we only need 1 patch.

Example 2:
nums = [1, 5, 10], n = 20
Return 2.
The two patches can be [2, 4].

Example 3:
nums = [1, 2, 2], n = 5
Return 0.
*/
/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number}
 * nums[i] <= known_sum，更新已知范围为：[1,known_sum + nums[i] )
   nums[i] >  known_sum,  添加known_sum进数组才能达到最大的范围，所以已知范围更新为：[1,known_sum *2  )
 */

//  time limit exceeded
var minPatches = function(nums, n) {
  var knownSum = 1,
    len = nums.length,
    count = 0,
    i = 0;

  while (knownSum <= n) {
    if (i < len && knownSum >= nums[i]) {
      knownSum += nums[i];
      i++;
    } else {
      knownSum <<= 1;
      count++;
    }
  }

  return count;
};
```

### Path Sum II

```js
/**
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

For example:
Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
return
[
   [5,4,11,2],
   [5,8,4,5]
]
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
  var result = [];

  if (!root) {
    return result;
  }

  genPath(result, root, [], 0, sum);

  return result;
};

function genPath(result, root, curArr, curSum, target) {
  curArr.push(root.val);
  curSum += root.val;

  if (curSum === target && !root.left && !root.right) {
    result.push(curArr);
    return;
  }

  if (root.left) {
    genPath(result, root.left, curArr.concat(), curSum, target);
  }

  if (root.right) {
    genPath(result, root.right, curArr.concat(), curSum, target);
  }
}
```

### Path Sum

```js
/**
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

For example:
Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
  if (root === null) {
    return false;
  }

  return hasFound(root, sum, 0);
};

function hasFound(node, target, curSum) {
  if (node === null) {
    return false;
  }

  var sum = node.val + curSum;

  if (sum === target && !node.left && !node.right) {
    return true;
  }

  return hasFound(node.left, target, sum) || hasFound(node.right, target, sum);
}
```

### Perfect Squares

```js
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  var arr = [],
    i,
    j;

  arr[0] = 0;

  for (i = 1; i <= n; i++) {
    arr[i] = Number.MAX_VALUE;
  }

  for (i = 0; i <= n; i++) {
    for (j = 1; i + j * j <= n; j++) {
      arr[i + j * j] = Math.min(arr[i + j * j], arr[i] + 1);
    }
  }

  return arr[n];
};

// SOLUTION 2
/**
 * 根据四平方和定理，任意一个正整数均可表示为4个整数的平方和，其实是可以表示为4个以内的平方数之和，那么就是说返回结果只有1,2,3或4其中的一个，首先我们将数字化简一下，由于一个数如果含有因子4，那么我们可以把4都去掉，并不影响结果，比如2和8,3和12等等，返回的结果都相同，读者可自行举更多的栗子。
 * 还有一个可以化简的地方就是，如果一个数除以8余7的话，那么肯定是由4个完全平方数组成，这里就不证明了，因为我也不会证明，读者可自行举例验证。那么做完两步后，一个很大的数有可能就会变得很小了，大大减少了运算时间，下面我们就来尝试的将其拆为两个平方数之和，如果拆成功了那么就会返回1或2，因为其中一个平方数可能为0.
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  while (n % 4 === 0) {
    n /= 4;
  }

  if (n % 8 === 7) {
    return 4;
  }

  var i, j;

  // check if it's 1 or 2
  for (i = 0; i * i <= n; i++) {
    j = parseInt(Math.sqrt(n - i * i));
    if (i * i + j * j === n) {
      return i === 0 || j === 0 ? 1 : 2;
    }
  }

  return 3;
};
```

### Permutation Sequence

```js
/**
The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):

"123"
"132"
"213"
"231"
"312"
"321"
Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.
*/
/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var getPermutation = function(n, k) {
  var arr = [],
    num = [],
    result = '',
    i;

  for (i = 1; i <= n; i++) {
    arr.push(i);
    num.push(0);
  }

  k = k - 1; // there're k - 1 permutations before
  i = 0;

  if (k === 0) {
    return arr.join('');
  }

  while (k > 0) {
    num[i] = parseInt(k / getFactorial(n - 1));
    k = k % getFactorial(n - 1);
    n--;
    i++;
  }

  for (i = 0; i < num.length; i++) {
    result += arr[num[i]];
    arr.splice(num[i], 1);
  }

  return result;
};

function getFactorial(n) {
  var result = 1;

  if (n === 0) {
    return 0;
  }

  while (n > 1) {
    result *= n;
    n--;
  }

  return result;
}
```

### Permutations II

```js
/**
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,
[1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].
*/
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
  var len = nums.length,
    result = [];

  nums.sort(function(a, b) {
    return a - b;
  });

  genPerm(result, 0, len, [], [], nums);

  return result;
};

function genPerm(result, index, len, curArr, used, nums) {
  if (curArr.length === len) {
    result.push(curArr);
    return;
  }

  var i;

  for (i = 0; i < len; i++) {
    if (used[i] || (i > 0 && nums[i] === nums[i - 1] && !used[i - 1])) {
      continue;
    }

    curArr.push(nums[i]);
    used[i] = true;
    genPerm(result, i + 1, len, curArr.concat(), used.concat(), nums);
    used[i] = false;
    curArr.pop();
  }
}
```

### Permutations

```js
/**
Given a collection of distinct numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
*/

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  function getPerm(arr, numss, n) {
    var len = arr.length,
      result = [],
      len1,
      x,
      copy,
      i,
      j;

    if (n === numss.length) {
      return arr;
    }

    x = numss[n];
    len1 = arr[0].length;

    for (i = 0; i < len; i++) {
      for (j = 0; j <= len1; j++) {
        copy = arr[i].slice(0);
        copy.splice(j, 0, x);
        result.push(copy);
      }
    }

    return getPerm(result, numss, n + 1);
  }
  var initArr = [],
    initElement = [];

  initArr.push(initElement);
  return getPerm(initArr, nums, 0);
};

// SOLUTION 2, recursion with an array store used
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  var len = nums.length,
    result = [];

  genPerm(result, 0, len, [], [], nums);

  return result;
};

function genPerm(result, index, len, curArr, used, nums) {
  if (curArr.length === len) {
    result.push(curArr);
    return;
  }

  var i;

  for (i = 0; i < len; i++) {
    if (used[i]) {
      continue;
    }

    curArr.push(nums[i]);
    used[i] = true;
    genPerm(result, i + 1, len, curArr.concat(), used.concat(), nums);
    used[i] = false;
    curArr.pop();
  }
}
```

### Plus One

```js
/**
Given a non-negative number represented as an array of digits, plus one to the number.

The digits are stored such that the most significant digit is at the head of the list.
*/
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  var len = digits.length,
    overflow = 1,
    i;

  for (i = len - 1; i >= 0; i--) {
    digits[i] = digits[i] + overflow;
    if (digits[i] === 10) {
      overflow = 1;
      digits[i] = 0;
    } else {
      return digits;
    }
  }

  if (overflow === 1) {
    digits.unshift(1);
    return digits;
  }
};
```

### Populating Next Right Pointers in Each Node II

```js
/**
Follow up for problem "Populating Next Right Pointers in Each Node".

What if the given tree could be any binary tree? Would your previous solution still work?

Note:

You may only use constant extra space.
For example,
Given the following binary tree,
         1
       /  \
      2    3
     / \    \
    4   5    7
After calling your function, the tree should look like:
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \    \
    4-> 5 -> 7 -> NULL
Subscribe to see which companies asked this question
*/
/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
  if (!root) {
    return;
  }

  var curRow = [],
    nextRow = [],
    i;

  curRow.push(root);

  while (curRow.length > 0) {
    for (i = 0; i < curRow.length; i++) {
      if (curRow[i].left) {
        nextRow.push(curRow[i].left);
      }

      if (curRow[i].right) {
        nextRow.push(curRow[i].right);
      }

      if (i < curRow.length - 1) {
        curRow[i].next = curRow[i + 1];
      } else {
        curRow[i].next = null;
      }
    }

    curRow = nextRow;
    nextRow = [];
  }
};

// O(1) space solution

/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
  let nextHead = null;
  let cur = root;
  let nextCur = null;

  while (cur !== null) {
    while (cur !== null) {
      if (cur.left) {
        if (!nextHead) {
          nextHead = cur.left;
          nextCur = nextHead;
        } else {
          nextCur.next = cur.left;
          nextCur = nextCur.next;
        }
      }

      if (cur.right) {
        if (!nextHead) {
          nextHead = cur.right;
          nextCur = nextHead;
        } else {
          nextCur.next = cur.right;
          nextCur = nextCur.next;
        }
      }

      cur = cur.next;
    }

    cur = nextHead;
    nextHead = null;
    nextCur = null;
  }
};
```

### Populating Next Right Pointers in Each Node

```js
/**
Given a binary tree

    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
For example,
Given the following perfect binary tree,
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
After calling your function, the tree should look like:
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL


 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
  var i,
    length,
    curRow = [],
    nextRow = [];

  if (root === null) {
    return;
  }
  cur = root;
  curRow.push(cur);
  length = 1;
  while (length > 0) {
    for (i = 0; i < length; i++) {
      cur = curRow[i];
      cur.next = i < length - 1 ? curRow[i + 1] : null;

      if (cur.left) {
        nextRow.push(cur.left);
      }
      if (cur.right) {
        nextRow.push(cur.right);
      }
    }
    curRow = nextRow;
    nextRow = [];
    length = curRow.length;
  }
};
```

### Pow(x, n)

```js
/**
Implement pow(x, n).
*/
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (n < 0) {
    return 1 / power(x, n);
  }

  return power(x, n);
};

function power(x, n) {
  if (n === 0) {
    return 1;
  }

  var v = power(x, parseInt(n / 2));

  if (n % 2 === 0) {
    return v * v;
  }

  return v * v * x;
}
```

### Power of Four

```js
/**
Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

Example:
Given num = 16, return true. Given num = 5, return false.

Follow up: Could you solve it without loops/recursion?
*/
/**
 * @param {number} num
 * @return {boolean}
 * 在Power of Two中，我们有一个解法是通过判断n & (n - 1)是否为0来判断是否为2的幂，因为4的幂肯定也是2的幂，
 * 所以这也可以用到这题来。那4的幂和2的幂有什么区别呢？根据上一个解法，我们知道4的幂的1只可能在奇数位，
 * 而2的幂的1可能在任意位，所以我们只要判断是不是奇数位是1就行了。
 * 因为根据n & (n - 1)我们已经筛出来那些只有1个1的数了，所以和010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
 * 也就是0x5555555555555555相与就能知道1是在奇数位还是偶数位了。
 */
var isPowerOfFour = function(num) {
  return num > 0 && (num & (num - 1)) === 0 && (num & 0x5555555555555) == num;
};
```

### Power of Three 1

```js
/**
Given an integer, write a function to determine if it is a power of three.

Follow up:
Could you do it without using any loop / recursion?
*/
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  while (n >= 3) {
    if (n % 3 !== 0) {
      break;
    }

    n = n / 3;
  }

  return n === 1;
};

// Math solution
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  return (Math.log10(n) / Math.log10(3)) % 1 === 0;
};
```

### Power of Three

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  if (n == 1) {
    return true;
  }
  if (n === 0 || n % 3 > 0) {
    return false;
  }
  return isPowerOfThree(n / 3);
};
```

### Product of Array Except Self

```js
/**
Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Solve it without division and in O(n).

For example, given [1,2,3,4], return [24,12,8,6].

Follow up:
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)
*/

/**
 * @param {number[]} nums
 * @return {number[]}
 *
 * output[i] =  { i 前面的数的乘积}  X  { i 后面的数的乘积}
问题就解决了，首先从前往后扫描数组一遍，对每一个i，得到{i 前面的数的乘积}(可以称做output_before)，然后在从后往前扫描数组一遍，获得 { i 后面的数的乘积}(可以称做output_after)。 将两数相乘即为所求。
举个例子(如下图)，nums = {1,2,3,4}, 第一遍，从前往后扫描一遍，得到的output_before = {1, 1, 2, 6}. 从后往前扫描一遍，得到的output_after = {24, 12, 4, 1}.
 *
 */
var productExceptSelf = function(nums) {
  var result = [],
    len = nums.length,
    back = 1,
    i;

  if (len === 0) {
    return result;
  }

  result[0] = 1;

  for (i = 1; i < len; i++) {
    result[i] = result[i - 1] * nums[i - 1];
  }

  for (i = len - 2; i >= 0; i--) {
    back *= nums[i + 1];
    result[i] *= back;
  }

  return result;
};
```

### README

### leetcode-js

Javascript solutions for LeetCode problems

### Range Sum Query - Mutable

```js
/**
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

The update(i, val) function modifies nums by updating the element at index i to val.
Example:
Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8
Note:
The array is only modifiable by the update function.
You may assume the number of calls to update and sumRange function is distributed evenly.
*/
/**
 * @constructor
 * @param {number[]} nums
 */
// time limit exceeded...
var NumArray = function(nums) {
  this.nums = nums;

  var length = nums.length,
    i,
    j,
    sum = [];

  for (i = 0; i < length; i++) {
    sum.push(new Array(length));
  }

  for (i = 0; i < length; i++) {
    for (j = i; j < length; j++) {
      if (i === j) {
        sum[i][j] = nums[i];
      } else {
        sum[i][j] = sum[i][j - 1] + nums[j];
      }
    }
  }

  this.sum = sum;
  this.len = length;
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
  var diff = val - this.nums[i],
    m,
    n;

  this.nums[i] = val;

  for (m = 0; m <= i; m++) {
    for (n = i; n < this.len; n++) {
      this.sum[m][n] += diff;
    }
  }
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  return this.sum[i][j];
};

// Segment Tree solution
/**
 * @constructor
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  var length = nums.length,
    i,
    arr = [];

  for (i = 0; i < length; i++) {
    arr[i + length] = nums[i];
  }

  for (i = length - 1; i > 0; i--) {
    arr[i] = arr[2 * i] + arr[2 * i + 1];
  }

  this.arr = arr;
  this.len = length;
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
  i += this.len;

  this.arr[i] = val;

  while (i > 0) {
    i = Math.floor(i / 2);
    this.arr[i] = this.arr[i * 2] + this.arr[i * 2 + 1];
  }
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  var sum = 0,
    l = i + this.len,
    r = j + this.len;

  while (l <= r) {
    if (l % 2 === 1) {
      sum += this.arr[l];
      l++;
    }

    if (r % 2 === 0) {
      sum += this.arr[r];
      r--;
    }

    l = Math.floor(l / 2);
    r = Math.floor(r / 2);
  }

  return sum;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var numArray = new NumArray(nums);
 * numArray.sumRange(0, 1);
 * numArray.update(1, 10);
 * numArray.sumRange(0, 2);
 */
```

### Range Sum Query 2D - Immutable

```js
/**
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

Example:
Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12
Note:
You may assume that the matrix does not change.
There are many calls to sumRegion function.
You may assume that row1 ≤ row2 and col1 ≤ col2.
*/

/**
 * @constructor
 * @param {number[][]} matrix
 */
var NumMatrix = function(matrix) {
  var sum = [],
    rLen = matrix.length,
    cLen,
    i,
    j;

  if (rLen === 0) {
    this.sum = null;
    return;
  }

  cLen = matrix[0].length;

  for (i = 0; i < rLen; i++) {
    sum.push(new Array(cLen));
  }

  sum[0][0] = matrix[0][0];

  for (i = 1; i < rLen; i++) {
    sum[i][0] = sum[i - 1][0] + matrix[i][0];
  }

  for (j = 1; j < cLen; j++) {
    sum[0][j] = sum[0][j - 1] + matrix[0][j];
  }

  for (i = 1; i < rLen; i++) {
    for (j = 1; j < cLen; j++) {
      sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i][j];
    }
  }

  this.sum = sum;
};

/**
 * @param {number} row1
 * @param {number} col1
 * @param {number} row2
 * @param {number} col2
 * @return {number}
 */
NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
  if (!this.sum) {
    return 0;
  }

  var result = this.sum[row2][col2];

  if (row1 > 0) {
    result -= this.sum[row1 - 1][col2];
  }

  if (col1 > 0) {
    result -= this.sum[row2][col1 - 1];
  }

  if (row1 > 0 && col1 > 0) {
    result += this.sum[row1 - 1][col1 - 1];
  }

  return result;
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * var numMatrix = new NumMatrix(matrix);
 * numMatrix.sumRegion(0, 1, 2, 3);
 * numMatrix.sumRegion(1, 2, 3, 4);
 */
```

### Range Sum Query 2D - Mutable

```js
/**
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).

Range Sum Query 2D
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

Example:

Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
update(3, 2, 2)
sumRegion(2, 1, 4, 3) -> 10

Note:

    The matrix is only modifiable by the update function.
    You may assume the number of calls to update and sumRegion function is distributed evenly.
    You may assume that row1 ≤ row2 and col1 ≤ col2.

*/
/**
 * @constructor
 * @param {number[][]} matrix
 */
var NumMatrix = function(matrix) {
  this.matrix = matrix;
  this.rowLen = matrix.length;
  this.colLen = this.rowLen === 0 ? 0 : matrix[0].length;
  this.colSum = []; // colSum[i][j] means column sum from matrix[0][j] to matrix[i][j]

  for (let i = 0; i < this.rowLen; i++) {
    this.colSum.push(new Array(this.colLen).fill(0));
  }

  for (let i = 0; i < this.rowLen; i++) {
    for (let j = 0; j < this.colLen; j++) {
      if (i === 0) {
        this.colSum[i][j] = this.matrix[i][j];
      } else {
        this.colSum[i][j] = this.matrix[i][j] + this.colSum[i - 1][j];
      }
    }
  }
};

/**
 * @param {number} row
 * @param {number} col
 * @param {number} val
 * @return {void}
 */
NumMatrix.prototype.update = function(row, col, val) {
  for (let i = row; i < this.rowLen; i++) {
    this.colSum[i][col] += val - this.matrix[row][col];
  }

  this.matrix[row][col] = val;
};

/**
 * @param {number} row1
 * @param {number} col1
 * @param {number} row2
 * @param {number} col2
 * @return {number}
 */
NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
  let result = 0;

  for (let i = col1; i <= col2; i++) {
    if (row1 === 0) {
      result += this.colSum[row2][i];
    } else {
      result += this.colSum[row2][i] - this.colSum[row1 - 1][i];
    }
  }

  return result;
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * var numMatrix = new NumMatrix(matrix);
 * numMatrix.sumRegion(0, 1, 2, 3);
 * numMatrix.update(1, 1, 10);
 * numMatrix.sumRegion(1, 2, 3, 4);
 */
```

### Range Sum Query

```js
/**
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
Note:
You may assume that the array does not change.
There are many calls to sumRange function.
*/

/**
 * @constructor
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  var len = nums.length,
    i;

  this.sums = [];
  this.sums[0] = 0;

  for (i = 0; i < len; i++) {
    this.sums[i + 1] = this.sums[i] + nums[i];
  }
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  return this.sums[j + 1] - this.sums[i];
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var numArray = new NumArray(nums);
 * numArray.sumRange(0, 1);
 * numArray.sumRange(0, 2);
 */
```

### Read N Characters Given Read4 II - Call multiple times

```js
/**
The API: int read4(char *buf) reads 4 characters at a time from a file.

The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

Note:
The read function may be called multiple times.
*/
/**
 * Definition for read4()
 *
 * @param {character[]} buf Destination buffer
 * @return {number} The number of characters read
 * read4 = function(buf) {
 *     ...
 * };
 */

/**
 * @param {function} read4()
 * @return {function}
 */
var solution = function(read4) {
  let helperBuf = [];
  let count = 0; // how many characters read with read4
  let i = 0;

  /**
   * @param {character[]} buf Destination buffer
   * @param {number} n Maximum number of characters to read
   * @return {number} The number of characters read
   */
  return function(buf, n) {
    let pointer = 0;

    while (pointer < n) {
      if (i === 0) {
        count = read4(helperBuf);
      }

      while (i < count && pointer < n) {
        buf[pointer++] = helperBuf[i++];
      }

      // read4 buffer used up, start over
      if (i === count) {
        i = 0;
      }

      // end of file
      if (count < 4) {
        break;
      }
    }

    return pointer;
  };
};
```

### Reconstruct Itinerary

```js
/**
Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.

Note:
If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].
All airports are represented by three capital letters (IATA code).
You may assume all tickets form at least one valid itinerary.
Example 1:
tickets = [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
Return ["JFK", "MUC", "LHR", "SFO", "SJC"].
Example 2:
tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Return ["JFK","ATL","JFK","SFO","ATL","SFO"].
Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"]. But it is larger in lexical order.
*/
/**
 * @param {string[][]} tickets
 * @return {string[]}
 */
var findItinerary = function(tickets) {
  tickets.sort(function(a, b) {
    if (a[0] < b[0]) {
      return -1;
    } else if (a[0] > b[0]) {
      return 1;
    } else {
      if (a[1] < b[1]) {
        return -1;
      }

      return 1;
    }
  });

  var map = {},
    len = tickets.length,
    result = [],
    i;

  for (i = 0; i < len; i++) {
    if (map[tickets[i][0]] === undefined) {
      map[tickets[i][0]] = {};
      map[tickets[i][0]][tickets[i][1]] = 1;
    } else {
      if (map[tickets[i][0]][tickets[i][1]] === undefined) {
        map[tickets[i][0]][tickets[i][1]] = 1;
      } else {
        map[tickets[i][0]][tickets[i][1]]++;
      }
    }
  }

  result.push('JFK');

  dfs(result, 0, len, map);

  return result;
};

function dfs(result, index, len, map) {
  if (index === len) {
    return true;
  }

  var cur = result[index],
    dests = map[cur],
    count,
    i;

  for (var dest in dests) {
    count = dests[dest];

    if (count > 0) {
      dests[dest]--;
      result.push(dest);
      if (dfs(result, index + 1, len, map)) {
        return true;
      }
      dests[dest]++;
      result.pop();
    }
  }

  return false;
}

// SOLUTION 2: GREEDY https://leetcode.com/discuss/87314/non-recursive-time-space-solution-with-detail-explanations
/**
 * @param {string[][]} tickets
 * @return {string[]}
 */
var findItinerary = function(tickets) {
  tickets.sort(function(a, b) {
    if (a[0] < b[0]) {
      return -1;
    } else if (a[0] > b[0]) {
      return 1;
    } else {
      if (a[1] < b[1]) {
        return -1;
      }

      return 1;
    }
  });

  var map = {},
    len = tickets.length,
    result = [],
    i;

  for (i = 0; i < len; i++) {
    if (map[tickets[i][0]] === undefined) {
      map[tickets[i][0]] = [tickets[i][1]];
    } else {
      map[tickets[i][0]].push(tickets[i][1]);
    }
  }

  dfs('JFK', result, map);

  return result;
};

function dfs(cur, result, map) {
  var arr = map[cur];

  while (arr && arr.length > 0) {
    dfs(arr.shift(), result, map);
  }

  result.unshift(cur);
}
```

### Recover Binary Search Tree

```js
/**
Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.

Note:
A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?
*/

// SOLUTION 1: O(N)
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var recoverTree = function(root) {
  let array = [];
  treeToArray(root, array);

  let node1, node2;

  for (let i = 0; i < array.length - 1; i++) {
    if (array[i][0] > array[i + 1][0]) {
      if (!node1) {
        node1 = array[i][1];
        node2 = array[i + 1][1];
      } else {
        node2 = array[i + 1][1];
      }
    }
  }

  let temp = node1.val;
  node1.val = node2.val;
  node2.val = temp;
};

function treeToArray(root, array) {
  if (!root) {
    return;
  }

  treeToArray(root.left, array);
  array.push([root.val, root]);
  treeToArray(root.right, array);
}

// SOLUTION 2: constant space
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var recoverTree = function(root) {
  let array = [];
  inorderTraverse(root, array);

  let node1 = array[1];
  let node2 = array[2];

  let temp = node1.val;
  node1.val = node2.val;
  node2.val = temp;
};

function inorderTraverse(root, array) {
  if (!root) {
    return;
  }

  inorderTraverse(root.left, array);

  if (array[0] && array[0].val > root.val) {
    if (!array[1]) {
      array[1] = array[0];
      array[2] = root;
    } else {
      array[2] = root;
    }
  }
  array[0] = root;

  inorderTraverse(root.right, array);
}
```

### Rectangle Area

```js
/**
Find the total area covered by two rectilinear rectangles in a 2D plane.

Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.

Rectangle Area
Assume that the total area is never beyond the maximum possible value of int.
*/

/**
 * @param {number} A
 * @param {number} B
 * @param {number} C
 * @param {number} D
 * @param {number} E
 * @param {number} F
 * @param {number} G
 * @param {number} H
 * @return {number}
 */
var computeArea = function(A, B, C, D, E, F, G, H) {
  // S(M ∪ N) = S(M) + S(N) - S(M ∩ N)
  var M = (D - B) * (C - A),
    N = (H - F) * (G - E);

  return M + N - Math.max(Math.min(D, H) - Math.max(B, F), 0) * Math.max(Math.min(C, G) - Math.max(A, E), 0);
};
```

### Regular Expression Matching

```js
/**
Implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true
*/
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 *
 * The most critical observation is that "x*" can either match empty string, or at least one x. In the latter case, it is equivalent to "xx*" or "x*x"
 *
 *
        'match' below including .
    f(i,j) means s where s.len=i matches p where p.len=j
    f(i,j) =
        if (p_j-1 != * ) f(i-1, j-1) and s_i-1 matches p_j-1
        if (p_j-1 == * )
            * matches zero times: f(i,j-2)
            or * matches at least one time: f(i-1,j) and s_i-1 matches p_j-2
 */
var isMatch = function(s, p) {
  var lenS = s.length,
    lenP = p.length,
    f = [],
    i,
    j;

  if (p.length === 0) {
    return s.length === 0;
  }

  if (p.charAt(0) === '*') {
    return false;
  }

  for (i = 0; i <= lenS; i++) {
    f.push(new Array(lenP + 1));
    for (j = 0; j <= lenP; j++) {
      f[i][j] = false;
    }
  }

  f[0][0] = true;

  for (i = 1; i < lenP; i++) {
    if (p.charAt(i) === '*') {
      f[0][i + 1] = f[0][i - 1];
    }
  }

  for (i = 1; i <= lenS; i++) {
    for (j = 1; j <= lenP; j++) {
      if (p.charAt(j - 1) === '*') {
        f[i][j] = f[i][j - 2] || (f[i - 1][j] && (s.charAt(i - 1) === p.charAt(j - 2) || p.charAt(j - 2) === '.'));
      } else {
        f[i][j] = f[i - 1][j - 1] && (s.charAt(i - 1) === p.charAt(j - 1) || p.charAt(j - 1) === '.');
      }
    }
  }

  return f[lenS][lenP];
};

// TIME LIMIT EXCEEDED
var isMatch = function(s, p) {
  var lenS = s.length,
    lenP = p.length,
    i,
    j;

  if (p.length === 0) {
    return s.length === 0;
  }

  if (p.charAt(1) === '*') {
    return (
      isMatch(s, p.substr(2)) ||
      (s.length > 0 && (s.charAt(0) === p.charAt(0) || p.charAt(0) === '.') && isMatch(s.substr(1), p))
    );
  } else {
    return s.length > 0 && (s.charAt(0) === p.charAt(0) || p.charAt(0) === '.') && isMatch(s.substr(1), p.substr(1));
  }
};
```

### Remove Duplicate Letters

```js
/**
Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.

Example:
Given "bcabc"
Return "abc"

Given "cbacdcbc"
Return "acdb"
*/

// recursive solution
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicateLetters = function(s) {
  var count = {},
    len = s.length,
    startPos = 0,
    curChar,
    i;

  if (len === 0) {
    return '';
  }

  for (i = 0; i < len; i++) {
    count[s.charAt(i)] = count[s.charAt(i)] ? count[s.charAt(i)] + 1 : 1;
  }

  for (i = 0; i < len; i++) {
    if (s.charAt(i) < s.charAt(startPos)) {
      startPos = i;
    }

    // find the first non duplicate letter
    if (--count[s.charAt(i)] === 0) {
      break;
    }
  }

  curChar = s.charAt(startPos);

  return curChar + removeDuplicateLetters(s.substr(startPos + 1).replace(new RegExp(curChar, 'g'), ''));
};

// stack solution
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicateLetters = function(s) {
  var count = {},
    len = s.length,
    stack = [],
    visited = {},
    curChar,
    i;

  if (len === 0) {
    return '';
  }

  for (i = 0; i < len; i++) {
    count[s.charAt(i)] = count[s.charAt(i)] ? count[s.charAt(i)] + 1 : 1;
  }

  for (i = 0; i < len; i++) {
    count[s.charAt(i)]--;

    if (visited[s.charAt(i)]) {
      continue;
    }

    while (stack.length > 0 && stack[stack.length - 1] > s.charAt(i) && count[stack[stack.length - 1]] > 0) {
      visited[stack[stack.length - 1]] = false;
      stack.pop();
    }

    stack.push(s.charAt(i));
    visited[s.charAt(i)] = true;
  }

  return stack.join('');
};
```

### Remove Duplicates from Sorted Array II

```js
/**
Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?

For example,
Given sorted array nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  var duplicate = false,
    len = nums.length,
    index = 1,
    i;

  for (i = 1; i < len; i++) {
    if (duplicate && nums[i] === nums[i - 1]) {
      continue;
    }

    if (nums[i] === nums[i - 1]) {
      duplicate = true;
    } else {
      duplicate = false;
    }

    nums[index] = nums[i];
    index++;
  }

  return index;
};
```

### Remove Duplicates from Sorted Array

```js
/**
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

Subscribe to see which companies asked this question
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  var len = nums.length,
    cur,
    i, // original array's index
    j; // new array's index

  if (len === 0) {
    return 0;
  }

  cur = nums[0];

  for (i = 1, j = 0; i < len; i++) {
    if (nums[i] !== cur) {
      j++;
      nums[j] = nums[i];
      cur = nums[i];
    }
  }

  return j + 1;
};
```

### Remove Duplicates from Sorted List II

/\*\*
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

For example,
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.
\*/
/\*\*

- Definition for singly-linked list.
- function ListNode(val) {
-     this.val = val;
-     this.next = null;
- }
  \*/
  /\*\*
- @param {ListNode} head
- @return {ListNode}
  \*/
  var deleteDuplicates = function(head) {
  var dummy = new ListNode(0),
  duplicate = null,
  node;

      dummy.next = head;
      node = head;
      prev = dummy;

      while (node && node.next) {
          if (node.val === duplicate || node.val === node.next.val) {
              duplicate = node.val;
              prev.next = node.next;
          } else {
              prev = prev.next;
          }

          node = node.next;
      }

      if (node && node.val === duplicate) {
          prev.next = null;
      }

      return dummy.next;

  };

### Remove Duplicates from Sorted List

```js
/**
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
*/

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
  var node = head;

  while (node && node.next) {
    if (node.val === node.next.val) {
      node.next = node.next.next;
    } else {
      node = node.next;
    }
  }

  return head;
};
```

### Remove Invalid Parentheses

```js
/**
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

Examples:
"()())()" -> ["()()()", "(())()"]
"(a)())()" -> ["(a)()()", "(a())()"]
")(" -> [""]

*/
/**
 * @param {string} s
 * @return {string[]}
 */
var removeInvalidParentheses = function(s) {
  var result = [];

  dfs(result, s, '', 0, 0);

  if (result.length === 0) {
    result.push('');
  }

  return result;
};

var max = 0; // max is to make sure we're removing the minimum number of parentheses

function dfs(result, str, curStr, leftCount, leftAccumulated) {
  if (str.length === 0) {
    if (curStr.length > 0 && leftCount === 0) {
      if (max < leftAccumulated) {
        max = leftAccumulated;
      }

      if (max === leftAccumulated && result.indexOf(curStr) === -1) {
        result.push(curStr);
      }
    }

    return;
  }

  var char = str.charAt(0);

  if (char === '(') {
    // keep (
    dfs(result, str.substr(1), curStr + '(', leftCount + 1, leftAccumulated + 1);
    // not keep (
    dfs(result, str.substr(1), curStr, leftCount, leftAccumulated);
  } else if (char === ')') {
    if (leftCount > 0) {
      dfs(result, str.substr(1), curStr + ')', leftCount - 1, leftAccumulated);
    }

    dfs(result, str.substr(1), curStr, leftCount, leftAccumulated);
  } else {
    dfs(result, str.substr(1), curStr + char, leftCount, leftAccumulated);
  }
}
```

### Remove Linked List Elements

```js
/**
Remove all elements from a linked list of integers that have value val.

Example
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5

Credits:
Special thanks to @mithmatt for adding this problem and creating all test cases.
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
  var dummyNode = new ListNode(null),
    node;

  if (val === null) {
    return head;
  }

  dummyNode.next = head;
  node = dummyNode;

  while (node.next) {
    if (node.next.val === val) {
      node.next = node.next.next;
    } else {
      node = node.next;
    }
  }

  return dummyNode.next;
};
```

### Remove Nth Node From End of List

```js
/**
Given a linked list, remove the nth node from the end of list and return its head.

For example,

   Given linked list: 1->2->3->4->5, and n = 2.

   After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:
Given n will always be valid.
Try to do this in one pass.
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  var nodeA = head,
    nodeB = head,
    i = 0;

  if (!head) {
    return null;
  }

  while (nodeA.next) {
    nodeA = nodeA.next;
    if (i < n) {
      i++;
    } else {
      nodeB = nodeB.next;
    }
  }

  if (i < n) {
    head = head.next;
    return head;
  }

  if (nodeB.next) {
    nodeB.next = nodeB.next.next;
    return head;
  }

  return null;
};
```

### Reorder List

```js
/**
Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */
var reorderList = function(head) {
  var fast = head,
    slow = head,
    next1,
    next2,
    midHead;

  if (!head || !head.next) {
    return;
  }

  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
  }

  if (fast) {
    midHead = reverse(slow.next);
  } else {
    midHead = reverse(slow);
  }

  fast = head;
  slow = midHead;

  while (fast && slow) {
    next1 = fast.next;
    next2 = slow.next;

    slow.next = fast.next;
    fast.next = slow;

    fast = next1;
    slow = next2;
  }

  if (fast) {
    fast.next = null;
  }
};

function reverse(head) {
  var dummyNode = new ListNode(0),
    prev = dummyNode,
    node,
    next;

  dummyNode.next = head;

  node = head.next;
  head.next = null;

  while (node) {
    next = node.next;
    node.next = prev.next;
    prev.next = node;

    node = next;
  }

  return dummyNode.next;
}
```

### Repeated DNA Sequences

```js
/**
All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.

For example,

Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

Return:
["AAAAACCCCC", "CCCCCAAAAA"].
*/
/**
 * @param {string} s
 * @return {string[]}
 */
var findRepeatedDnaSequences = function(s) {
  var map = new Set(),
    len = s.length,
    result = new Set(),
    code,
    substr,
    i;

  for (i = 9; i < len; i++) {
    substr = s.substr(i - 9, 10);
    code = encode(substr);

    if (map.has(code)) {
      result.add(substr);
    } else {
      map.add(code);
    }
  }

  return Array.from(result);
};

function encode(s) {
  var sum = 0,
    len = s.length,
    c,
    i;

  for (i = 0; i < len; i++) {
    c = s.charAt(i);
    switch (c) {
      case 'A':
        sum = sum * 4;
        break;
      case 'C':
        sum = sum * 4 + 1;
        break;
      case 'G':
        sum = sum * 4 + 2;
        break;
      case 'T':
        sum = sum * 4 + 3;
        break;
    }
  }

  return sum;
}
```

### Restore IP Addresses

```js
/**
Given a string containing only digits, restore it by returning all possible valid IP address combinations.

For example:
Given "25525511135",

return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)
*/
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  var result = [],
    len = s.length;

  if (len > 12) {
    return result;
  }

  helper(result, s, 0, [], len);

  return result;
};

function helper(result, s, index, curArr, len) {
  if (curArr.length === 4) {
    if (index === len) {
      result.push(curArr.join('.'));
    }
    return;
  }

  var i, num;

  // only 3 situations
  for (i = index; i < len && i <= index + 3; i++) {
    num = s.substring(index, i + 1);

    if (isValid(num)) {
      curArr.push(parseInt(num));
      helper(result, s, i + 1, curArr.concat(), len);
      curArr.pop();
    }
  }
}

function isValid(s) {
  if (s.charAt(0) === '0') {
    return s === '0';
  }

  var num = parseInt(s);

  return num >= 0 && num <= 255;
}
```

### Reverse Integer

```js
/**
Reverse digits of an integer.

Example1: x = 123, return 321
Example2: x = -123, return -321

click to show spoilers.

Have you thought about this?
Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!

If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.

Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?

For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

Update (2014-11-10):
Test cases had been added to test the overflow behavior.
*/
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  var isNegative = x < 0 ? true : false,
    divider = 10,
    result = 0,
    reminder;

  if (isNegative) {
    x = x * -1;
  }

  while (x !== 0) {
    reminder = x % 10;
    result = result * 10 + reminder;

    x = Math.floor(x / 10);
  }

  if (result >= 2147483648) {
    return 0;
  }

  return isNegative ? result * -1 : result;
};
```

### Reverse Linked List II

```js
/**
 *Reverse a linked list from position m to n. Do it in-place and in one-pass.

For example:
Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.

Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.
 *
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
Reverse a linked list from position m to n. Do it in-place and in one-pass.

For example:
Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.

Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseBetween = function(head, m, n) {
  var dummy = new ListNode(0),
    newTail,
    prev,
    cur = dummy,
    next,
    i;

  if (m === n || head === null || head.next === null) {
    return head;
  }
  dummy.next = head;
  i = m - 1;

  while (i > 0) {
    cur = cur.next;
    i--;
  }

  prev = cur;
  cur = cur.next;
  newTail = prev.next;

  prev.next = null;
  i = n - m;

  while (cur && i >= 0) {
    next = cur.next;
    cur.next = prev.next;
    prev.next = cur;
    cur = next;
    i--;
  }

  newTail.next = next;
  return dummy.next;
};
```

### Reverse Linked List

```js
/**
Reverse a singly linked list.

click to show more hints.

Hint:
A linked list can be reversed either iteratively or recursively. Could you implement both?
*/

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  var cur = head,
    next;

  head = null;

  while (cur) {
    next = cur.next;
    cur.next = head;

    if (next) {
      head = cur;
      cur = next;
    } else {
      return cur;
    }
  }

  return null;
};

// recursive

var reverseList = function(head) {
  if (!head) {
    return null;
  }

  if (!head.next) {
    return head;
  }

  var newHead = reverseList(head.next);

  head.next.next = head;
  head.next = null;

  return newHead;
};
```

### Reverse Nodes in k-Group

```js
/**
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.

For example,
Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

// iterative solution, not recommended, very easy to make mistakes
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
  var dummy = new ListNode(0),
    i = 0,
    node = head,
    next,
    prevTail,
    curHead,
    curTail,
    nextHead,
    nextTail;

  while (node) {
    node = node.next;
    i++;

    if (i >= k) {
      break;
    }
  }

  if (k === 1 || i < k) {
    return head;
  }

  i = 0;

  dummy.next = head;
  prevTail = dummy;
  node = head;

  while (node) {
    if (i === 0) {
      curTail = node;
      next = node.next;
      node.next = null;
      prevTail.next = node;
    } else {
      next = node.next;
      node.next = prevTail.next;
      prevTail.next = node;
    }

    i++;

    if (i === k) {
      prevTail = curTail;
      i = 0;
    }

    node = next;
  }

  if (i < k) {
    node = prevTail.next;
    prevTail.next = null;

    while (node) {
      next = node.next;
      node.next = prevTail.next;
      prevTail.next = node;
      node = next;
    }
  }

  return dummy.next;
};

// recursive
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
  var i = 0,
    newHead = head,
    dummy = new ListNode(0),
    prev,
    cur,
    next;

  for (i = 0; i < k; i++) {
    if (newHead === null) {
      return head;
    }

    newHead = newHead.next;
  }

  newHead = reverseKGroup(newHead, k);
  cur = head;
  dummy.next = newHead;

  for (i = 0; i < k; i++) {
    next = cur.next;
    cur.next = dummy.next;
    dummy.next = cur;
    cur = next;
  }

  return dummy.next;
};
```

### Reverse String

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseString = function(s) {
  if (!s) {
    return s;
  }

  return s
    .split('')
    .reverse()
    .join('');
};
```

### Reverse Vowels of a String

```js
/**
Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:
Given s = "hello", return "holle".

Example 2:
Given s = "leetcode", return "leotcede".
*/
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  var len = s.length,
    result = s.split(''),
    vowelSet = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']),
    indice = [],
    arr = [],
    ch,
    i;

  for (i = 0; i < len; i++) {
    ch = result[i];

    if (vowelSet.has(ch)) {
      arr.push(ch);
      indice.push(i);
    }
  }

  for (i = 0; i < indice.length; i++) {
    result[indice[i]] = arr.pop();
  }

  return result.join('');
};
```

### Reverse Words in a String

```js
/**
Given an input string, reverse the string word by word.

For example,
Given s = "the sky is blue",
return "blue is sky the".

 * @param {string} str
 * @returns {string}
 */
var reverseWords = function(str) {
  var result = '',
    arr,
    len,
    i;

  if (str === null || str === '') {
    return result;
  }
  arr = str.split(' ');
  len = arr.length;
  for (i = len - 1; i >= 0; i--) {
    if (arr[i].length === 0) {
      continue;
    }
    result += ' ' + arr[i];
  }
  return result.trim();
};
```

### Roman to Integer

```js
/**
Given a roman numeral, convert it to an integer.

Input is guaranteed to be within the range from 1 to 3999.
*/

/**
 * @param {string} s
 * @return {number}
 */

/**
找下subtractive notation的规律，以简单的例子s = IX 说明。
1. 如果按照additive性质的话应该ret = 1+10 = 11。但因为num(X)=10>num(I)=1，ret = 10 - 1。
2. 将subtractive rule转换成等效的additive rule：ret = 1 + (10 - 2*1)

建立一个罗马字符对应整数的hash table ht。
当ht[s[i]] > ht[s[i-1]]，即为subtractive nontation：ret += (ht[s[i]] - 2*ht[s[i-1]])
否则为additive nontation：ret+=ht[s[i]]
*/
var romanToInt = function(s) {
  var len = s.length,
    map = {},
    result = 0,
    i;

  if (len === 0) {
    return 0;
  }

  map['I'] = 1;
  map['V'] = 5;
  map['X'] = 10;
  map['L'] = 50;
  map['C'] = 100;
  map['D'] = 500;
  map['M'] = 1000;

  for (i = 0; i < len; i++) {
    result += map[s.charAt(i)];

    if (i > 0 && map[s.charAt(i)] > map[s.charAt(i - 1)]) {
      result -= 2 * map[s.charAt(i - 1)];
    }
  }

  return result;
};
```

### Rotate Array

```js
/**
Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].

Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
*/

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  var n = nums.length,
    divider,
    pre,
    tmp,
    i,
    j;

  k = k % n;
  divider = gcd_rec(k, n);

  for (i = 0; i < divider; i++) {
    pre = nums[i];
    j = i;

    while ((j + k) % n !== i) {
      tmp = nums[(j + k) % n];
      nums[(j + k) % n] = pre;
      pre = tmp;
      j = (j + k) % n;
    }

    nums[(j + k) % n] = pre;
  }
};

function gcd_rec(a, b) {
  if (b) {
    return gcd_rec(b, a % b);
  } else {
    return Math.abs(a);
  }
}
```

### Rotate Image

```js
/**
You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Follow up:
Could you do this in-place?
*/

/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  var len = matrix.length,
    i,
    level,
    tmp;

  level = 0;

  while (level < len / 2) {
    for (i = level; i < len - level - 1; i++) {
      tmp = matrix[level][i];
      matrix[level][i] = matrix[len - i - 1][level];
      matrix[len - i - 1][level] = matrix[len - 1 - level][len - 1 - i];
      matrix[len - 1 - level][len - 1 - i] = matrix[i][len - 1 - level];
      matrix[i][len - 1 - level] = tmp;
    }
    level++;
  }
};
```

### Rotate List

```js
/**
Given a list, rotate the list to the right by k places, where k is non-negative.

For example:
Given 1->2->3->4->5->NULL and k = 2,
return 4->5->1->2->3->NULL.
*/

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var rotateRight = function(head, k) {
  var pointerA = head,
    pointerB = head,
    len = 0,
    newHead,
    i;

  if (head === null) {
    return null;
  }

  while (pointerA) {
    pointerA = pointerA.next;
    len++;
  }

  k = k % len;

  if (k === 0 || len === 1) {
    return head;
  }

  pointerA = head;
  for (i = 0; i < k; i++) {
    pointerA = pointerA.next;
  }

  while (pointerA && pointerA.next) {
    pointerA = pointerA.next;
    pointerB = pointerB.next;
  }

  newHead = pointerB.next;
  pointerB.next = null;
  pointerA.next = head;

  return newHead;
};
```

### Same Tree

```js
/**
Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

 * Definition for binary tree
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @returns {boolean}
 */
var isSameTree = function(p, q) {
  if (!p && !q) {
    return true;
  }
  if (!p || !q) {
    return false;
  }
  if (p.val !== q.val) {
    return false;
  }
  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

### Scramble String

```js
/**
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of s1 = "great":

    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".

    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
We say that "rgeat" is a scrambled string of "great".

Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".

    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
We say that "rgtae" is a scrambled string of "great".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.
*/
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var isScramble = function(s1, s2) {
  if (s1 === s2) {
    return true;
  }

  if (s1 === null || s2 === null) {
    return false;
  }

  if (s1.length !== s2.length) {
    return false;
  }

  var chars1 = s1.split(''),
    chars2 = s2.split(''),
    len = chars1.length,
    s11,
    s12,
    s21,
    s22,
    i = 0;

  if (len === 1) {
    return s1 === s2;
  }

  chars1.sort();
  chars2.sort();

  while (i < len) {
    if (chars1[i] !== chars2[i]) {
      return false;
    }

    i++;
  }

  for (i = 1; i < len; i++) {
    s11 = s1.slice(0, i);
    s12 = s1.slice(i);
    s21 = s2.slice(0, i);
    s22 = s2.slice(i);

    if (isScramble(s11, s21) && isScramble(s12, s22)) {
      return true;
    }

    s21 = s2.slice(0, len - i);
    s22 = s2.slice(len - i);

    if (isScramble(s11, s22) && isScramble(s12, s21)) {
      return true;
    }
  }

  return false;
};
```

### Search Insert Position

```js
/**
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
  var len = nums.length,
    i;

  for (i = 0; i < len; i++) {
    if (target <= nums[i]) {
      return i;
    }
  }

  return len;
};
```

### Search a 2D Matrix II

```js
/**
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
For example,

Consider the following matrix:

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.

Given target = 20, return false.
*/
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  var rowLen = matrix.length,
    columnLen,
    value,
    i,
    j;

  if (rowLen === 0) {
    return false;
  }

  columnLen = matrix[0].length;

  if (columnLen === 0) {
    return false;
  }

  i = 0;
  j = columnLen - 1;

  while (i < rowLen && j >= 0) {
    value = matrix[i][j];

    if (target > value) {
      i++;
    } else if (target < value) {
      j--;
    } else {
      return true;
    }
  }

  return false;
};

// Time limit exceeded...
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  var rowLen = matrix.length,
    columnLen,
    i,
    j;

  if (rowLen === 0) {
    return false;
  }

  columnLen = matrix[0].length;

  if (columnLen === 0) {
    return false;
  }

  return helper(0, rowLen - 1, 0, columnLen - 1, target, matrix);
};

function helper(rowStart, rowEnd, colStart, colEnd, target, matrix) {
  if (rowStart > rowEnd || colStart > colEnd) {
    return false;
  }

  var rowMid = Math.floor((rowStart + rowEnd) / 2),
    colMid = Math.floor((colStart + colEnd) / 2),
    value = matrix[rowMid][colMid];

  if (value < target) {
    return (
      helper(rowStart, rowEnd, colMid + 1, colEnd, target, matrix) ||
      helper(rowMid + 1, rowEnd, colStart, colMid, target, matrix) ||
      helper(rowMid + 1, rowEnd, colMid + 1, colEnd, target, matrix)
    );
  } else if (value > target) {
    return (
      helper(rowStart, rowEnd - 1, colMid, colEnd, target, matrix) ||
      helper(rowMid, rowEnd, colStart, colMid - 1, target, matrix) ||
      helper(rowStart, rowMid - 1, colStart, colMid - 1, target, matrix)
    );
  }

  return true;
}
```

### Search a 2D Matrix

```js
/**
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,

Consider the following matrix:

[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
Given target = 3, return true.
*/
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  var rLen = matrix.length,
    cLen,
    start,
    end,
    mid,
    i,
    j;

  if (rLen === 0) {
    return false;
  }

  cLen = matrix[0].length;
  start = 0;
  end = rLen * cLen - 1;

  while (start <= end) {
    mid = parseInt((start + end) / 2);
    i = parseInt(mid / cLen);
    j = mid % cLen;

    if (matrix[i][j] === target) {
      return true;
    }

    if (matrix[i][j] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return false;
};
```

### Search for a Range

```js
/**
Given a sorted array of integers, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

For example,
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].


*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  var result = [],
    leftIndex = findLeftMost(target, nums),
    rightIndex = findRightMost(target, nums);

  result.push(leftIndex);
  result.push(rightIndex);

  return result;
};

function findLeftMost(target, nums) {
  var len = nums.length,
    start = 0,
    end = len - 1,
    mid;

  while (start <= end) {
    mid = Math.floor((start + end) / 2);

    if (nums[mid] > target) {
      end = mid - 1;
    } else if (nums[mid] < target) {
      start = mid + 1;
    } else {
      end = mid - 1;
    }
  }

  if (start >= 0 && start < len && nums[start] === target) {
    return start;
  }

  return -1;
}

function findRightMost(target, nums) {
  var len = nums.length,
    start = 0,
    end = len - 1,
    mid;

  while (start <= end) {
    mid = Math.floor((start + end) / 2);

    if (nums[mid] > target) {
      end = mid - 1;
    } else if (nums[mid] < target) {
      start = mid + 1;
    } else {
      start = mid + 1;
    }
  }

  if (end >= 0 && end < len && nums[end] === target) {
    return end;
  }

  return -1;
}
```

### Search in Rotated Sorted Array II

```js
/**
Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?

Write a function to determine if a given target is in the array.
*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {boolean}
 */
var search = function(nums, target) {
  var len = nums.length,
    start = 0,
    end = len - 1,
    mid;

  while (start <= end) {
    mid = parseInt((start + end) / 2);

    if (nums[mid] === target) {
      return true;
    }

    if (nums[mid] < nums[end]) {
      // right half sorted
      if (nums[mid] < target && nums[end] >= target) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    } else if (nums[mid] > nums[end]) {
      // left half sorted
      if (nums[mid] > target && nums[start] <= target) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    } else {
      // don't know which half is sorted
      end--;
    }
  }

  return false;
};
```

### Search in Rotated Sorted Array

```js
/**
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.
*/
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  var len = nums.length,
    start = 0,
    end = len - 1,
    mid;

  while (start <= end) {
    mid = Math.floor((start + end) / 2);

    if (nums[mid] === target) {
      return mid;
    } else if (nums[start] <= nums[mid]) {
      // left side sorted
      if (nums[mid] > target && nums[start] <= target) {
        // nums[mid] !== target, can safely do end = mid - 1
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    } else {
      // right side sorted
      if (nums[mid] < target && nums[end] >= target) {
        // nums[mid] !== target, can safely do start = mid + 1
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    }
  }

  return -1;
};
```

### Serialize and Deserialize Binary Tree

```js
/**
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

For example, you may serialize the following tree

    1
   / \
  2   3
     / \
    4   5
as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
  var result = [];

  sHelper(root, result);
  return result.toString();
};

function sHelper(root, result) {
  if (root === null) {
    result.push('#');
    return;
  }

  result.push(root.val);
  sHelper(root.left, result);
  sHelper(root.right, result);
}
/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
  var arr = data.split(','),
    len = arr.length;

  if (len === 0) {
    return null;
  }

  return buildTree(arr);
};

function buildTree(arr) {
  var curNode, val;

  if (arr.length === 0) {
    return null;
  }

  val = arr.shift();

  if (val === '#') {
    return null;
  }

  curNode = new TreeNode(parseInt(val));
  curNode.left = buildTree(arr);
  curNode.right = buildTree(arr);

  return curNode;
}

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

### Set Matrix Zeroes

```js
/**
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

click to show follow up.

Follow up:
Did you use extra space?
A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?
*/
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
  var rLen = matrix.length,
    cLen,
    i,
    j,
    firstRowZero,
    firstColumnZero;

  if (rLen === 0) {
    return;
  }

  cLen = matrix[0].length;

  if (matrix[0][0] === 0) {
    firstRowZero = true;
    firstColumnZero = true;
  } else {
    for (i = 1; i < cLen; i++) {
      if (matrix[0][i] === 0) {
        firstRowZero = true;
        break;
      }
    }

    for (i = 1; i < rLen; i++) {
      if (matrix[i][0] === 0) {
        firstColumnZero = true;
        break;
      }
    }
  }

  for (i = 1; i < rLen; i++) {
    for (j = 1; j < cLen; j++) {
      if (matrix[i][j] === 0) {
        matrix[0][j] = 0;
        matrix[i][0] = 0;
      }
    }
  }

  for (i = 1; i < cLen; i++) {
    if (matrix[0][i] === 0) {
      for (j = 1; j < rLen; j++) {
        matrix[j][i] = 0;
      }
    }
  }

  for (i = 1; i < rLen; i++) {
    if (matrix[i][0] === 0) {
      for (j = 1; j < cLen; j++) {
        matrix[i][j] = 0;
      }
    }
  }

  if (firstRowZero) {
    for (i = 0; i < cLen; i++) {
      matrix[0][i] = 0;
    }
  }

  if (firstColumnZero) {
    for (j = 0; j < rLen; j++) {
      matrix[j][0] = 0;
    }
  }
};
```

### Shortest Palindrome

```js
/**
Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.

For example:

Given "aacecaaa", return "aaacecaaa".

Given "abcd", return "dcbabcd".
*/

// https://segmentfault.com/a/1190000003059361

/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
  var reverse = s
    .split('')
    .reverse()
    .join('');

  return reverse.substring(0, s.length - getCommonLength(s + '#' + reverse)) + s;
};

function getCommonLength(s) {
  var p = [], // max len of common prefix and suffix from index 0 to i
    len = s.length,
    i = 0,
    j;

  while (i < len) {
    p.push(0);
    i++;
  }

  for (i = 1; i < len; i++) {
    j = p[i - 1];

    while (j > 0 && s.charAt(i) !== s.charAt(j)) {
      j = p[j - 1];
    }

    if (s.charAt(i) === s.charAt(j)) {
      j++;
    }

    p[i] = j;
  }

  return p[len - 1];
}
```

### Simplify Path

```js
/**
Given an absolute path for a file (Unix-style), simplify it.

For example,
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"
click to show corner cases.

Corner Cases:
Did you consider the case where path = "/../"?
In this case, you should return "/".
Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
In this case, you should ignore redundant slashes and return "/home/foo".
*/
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
  var paths = [],
    arr = path.split('/'),
    len = arr.length,
    cur,
    i,
    result = '';

  for (i = 0; i < len; i++) {
    cur = arr[i];

    if (cur === '.' || cur.length === 0) {
      continue;
    }

    if (cur === '..') {
      if (paths.length > 0) {
        paths.pop();
      }
    } else {
      paths.push(cur);
    }
  }

  for (i = 0; i < paths.length; i++) {
    result += '/' + paths[i];
  }

  if (result === '') {
    result = '/';
  }

  return result;
};
```

### Single Number II

```js
/**
Given an array of integers, every element appears three times except for one. Find that single one.

Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
*/

/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  var arr = [],
    len = nums.length,
    num,
    cur,
    result = 0,
    i,
    j;

  for (i = 0; i < 32; i++) {
    arr[i] = 0;
  }

  for (i = 0; i < len; i++) {
    num = nums[i];

    cur = num;
    for (j = 0; j < 32; j++) {
      if (cur === 0) {
        break;
      }

      arr[j] += cur & 1;

      cur = cur >> 1;
    }
  }

  for (i = 0; i < 32; i++) {
    result += arr[i] % 3 << i;
  }

  return result;
};
```

### Single Number III

```js
/**
Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.

For example:

Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].

Note:
The order of the result is not important. So in the above example, [5, 3] is also correct.
Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?
*/
/**
 * @param {number[]} nums
 * @return {number[]}
 *
 * 一个整数有32位bit，对于b和c，除非两者是相同的数，否则一定存在第K位bit，两者是不同的。
 * 当找到这个K以后，就可以按照第K位bit是否等于1，将A数组划分成两个子数组，而这两个子数组分别包含了b和c，那么剩下的就只需要把single number的算法直接应用到这两个子数组上，就可以得到b和c了。
 */
var singleNumber = function(nums) {
  var xor = 0,
    len = nums.length,
    lastDigit,
    x = 0,
    y = 0,
    result = [],
    i;

  for (i = 0; i < len; i++) {
    xor ^= nums[i];
  }

  lastDigit = xor - (xor & (xor - 1));

  for (i = 0; i < len; i++) {
    if ((nums[i] & lastDigit) === 0) {
      x ^= nums[i];
    } else {
      y ^= nums[i];
    }
  }

  result.push(x);
  result.push(y);

  return result;
};
```

### Single Number

```js
/**
 * Given an array of integers, every element appears twice except for one. Find that single one.
 * Note:
 * Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
 *
 * @param {number[]} A
 * @return {number}
 */
var singleNumber = function(A) {
  var length = A.length,
    i,
    result = 0;
  if (length === 1) {
    return A[0];
  }
  for (i = 0; i < length; i++) {
    result = result ^ A[i];
  }
  return result;
};
```

### Sliding Window Maximum

```js
/**
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

For example,
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Therefore, return the max sliding window as [3,3,5,5,6,7].

Note:
You may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.

Follow up:
Could you solve it in linear time?

Hint:

How about using a data structure such as deque (double-ended queue)?
The queue size need not be the same as the window’s size.
Remove redundant elements and the queue should store only elements that need to be considered.
*/
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 *
 * Maintain an array for possible maximum value's index between [i - k + 1, i]
 *
 * if arr[0] < i - k + 1, pop
 * 当下标i从队尾入队时，顺次弹出队列尾部不大于nums[i]的数组下标(这些被弹出的元素由于新元素的加入而变得没有意义)
 * 队头元素即为当前滑动窗口的最大值
 */
var maxSlidingWindow = function(nums, k) {
  var result = [],
    queue = [],
    len = nums.length,
    i;

  if (k > len || k === 0) {
    return result;
  }

  for (i = 0; i < len; i++) {
    while (queue.length > 0 && nums[queue[queue.length - 1]] < nums[i]) {
      queue.pop();
    }

    if (queue[0] < i - k + 1) {
      queue.shift();
    }

    queue.push(i);

    if (i >= k - 1) {
      result.push(nums[queue[0]]);
    }
  }

  return result;
};
```

### Sort Colors

```js
/**
Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.

click to show follow up.

Follow up:
A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.

Could you come up with an one-pass algorithm using only constant space?

 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
  var len = nums.length,
    redEnds = 0,
    blueStarts = len - 1,
    i;

  function swap(m, n, arr) {
    var temp = arr[m];

    arr[m] = arr[n];
    arr[n] = temp;
  }

  for (i = 0; i <= blueStarts; ) {
    if (nums[i] === 0) {
      swap(i, redEnds, nums);
      i++;
      redEnds++;
    } else if (nums[i] === 2) {
      swap(i, blueStarts, nums);
      blueStarts--;
    } else {
      i++;
    }
  }
};
```

### Sort List

```js
/**
Sort a linked list in O(n log n) time using constant space complexity.
*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
  var slow = head,
    fast = head,
    head1 = head,
    head2 = head;

  if (head === null || head.next === null) {
    return head;
  }

  while (fast.next !== null && fast.next.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }

  head1 = slow.next;
  slow.next = null;

  head1 = sortList(head1);
  head2 = sortList(head);

  return merge(head2, head1);
};

function merge(a, b) {
  var dummy = new ListNode(0),
    node = dummy;

  while (a && b) {
    if (a.val < b.val) {
      node.next = a;
      a = a.next;
    } else {
      node.next = b;
      b = b.next;
    }
    node = node.next;
  }

  if (a) {
    node.next = a;
  } else {
    node.next = b;
  }

  return dummy.next;
}
```

### Spiral Matrix II

```js
/**
Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

For example,
Given n = 3,

You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
*/

/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function(n) {
  var curNum = 1,
    total = parseInt(n / 2),
    result = [],
    temp,
    level,
    i,
    j;

  if (n === 0) {
    return result;
  }

  if (n === 1) {
    temp = [1];
    result.push(temp);
    return result;
  }
  // initialization
  for (i = 0; i < n; i++) {
    temp = [];
    for (j = 0; j < n; j++) {
      temp.push(0);
    }

    result.push(temp);
  }

  for (level = 0; level < total; level++) {
    // top
    for (i = level; i < n - level - 1; i++) {
      result[level][i] = curNum;

      if (curNum === n * n) {
        return result;
      }

      curNum++;
    }

    // right
    for (i = level; i < n - level - 1; i++) {
      result[i][n - level - 1] = curNum;
      curNum++;
    }

    // bottom
    for (i = n - level - 1; i > level; i--) {
      result[n - level - 1][i] = curNum;
      curNum++;
    }

    // left
    for (i = n - level - 1; i > level; i--) {
      result[i][level] = curNum;
      curNum++;
    }
  }

  if (curNum === n * n) {
    result[total][total] = curNum;
  }

  return result;
};
```

### Spiral Matrix

```js
/**
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
You should return [1,2,3,6,9,8,7,4,5].
*/

/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  var rowL = matrix.length,
    result = [],
    columnL;

  if (rowL === 0) {
    return result;
  }

  columnL = matrix[0].length;

  helper(0, rowL, columnL, matrix, result);
  return result;
};

function helper(level, row, column, matrix, result) {
  var i;

  if (row === 0 || column === 0) {
    return;
  } else if (row === 1) {
    for (i = 0; i < column; i++) {
      result.push(matrix[level][i + level]);
    }
  } else if (column === 1) {
    for (i = 0; i < row; i++) {
      result.push(matrix[i + level][level]);
    }
  } else {
    // top
    for (i = 0; i < column - 1; i++) {
      result.push(matrix[level][i + level]);
    }

    // right
    for (i = 0; i < row - 1; i++) {
      result.push(matrix[i + level][column + level - 1]);
    }

    // bottom
    for (i = column - 1; i > 0; i--) {
      result.push(matrix[row + level - 1][i + level]);
    }

    // left
    for (i = row - 1; i > 0; i--) {
      result.push(matrix[i + level][level]);
    }

    helper(level + 1, row - 2, column - 2, matrix, result);
  }
}
```

### Sqrt(x)

```js
/**
Implement int sqrt(int x).

Compute and return the square root of x.
*/
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
  var start = 1,
    end = x,
    mid;

  if (x === 0) {
    return 0;
  }

  while (start + 1 < end) {
    mid = start + parseInt((end - start) / 2);

    if (mid * mid <= x) {
      start = mid;
    } else {
      end = mid;
    }
  }

  return start;
};
```

### Strobogrammatic Number II

```js
/**
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).

Find all strobogrammatic numbers that are of length = n.

For example,
Given n = 2, return ["11","69","88","96"].

Hint:
Try to use recursion and notice that it should recurse with n - 2 instead of n - 1.
*/
/**
 * @param {number} n
 * @return {string[]}
 */
var findStrobogrammatic = function(n) {
  return helper(n, n);
};

function helper(cur, n) {
  if (cur === 0) {
    return [''];
  }

  if (cur === 1) {
    return ['1', '8', '0'];
  }

  const list = helper(cur - 2, n);
  let result = [];

  for (let i = 0; i < list.length; i++) {
    if (cur !== n) {
      result.push('0' + list[i] + '0');
    }

    result.push('1' + list[i] + '1');
    result.push('8' + list[i] + '8');
    result.push('6' + list[i] + '9');
    result.push('9' + list[i] + '6');
  }

  return result;
}
```

### Strobogrammatic Number

```js
/**
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).

Write a function to determine if a number is strobogrammatic. The number is represented as a string.

For example, the numbers "69", "88", and "818" are all strobogrammatic.
*/
/**
 * @param {string} num
 * @return {boolean}
 */
var isStrobogrammatic = function(num) {
  let map = new Map();

  map.set('1', '1');
  map.set('6', '9');
  map.set('9', '6');
  map.set('8', '8');
  map.set('0', '0');

  let start = 0;
  let end = num.length - 1;

  while (start <= end) {
    if (!map.has(num.charAt(start)) || map.get(num.charAt(start)) !== num.charAt(end)) {
      return false;
    }

    start++;
    end--;
  }

  return true;
};
```

### Subsets II

```js
/**
Given a collection of integers that might contain duplicates, nums, return all possible subsets.

Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
*/

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
  var result = [],
    len = nums.length;

  nums.sort(function(a, b) {
    return a - b;
  });

  helper(nums, 0, len - 1, [], result);

  return result;
};

function helper(nums, start, end, curArr, result) {
  result.push(curArr);

  var i;

  for (i = start; i <= end; i++) {
    // skip duplicates
    if (i > start && nums[i] === nums[i - 1]) {
      continue;
    }
    curArr.push(nums[i]);
    helper(nums, i + 1, end, curArr.concat(), result);
    curArr.pop();
  }
}
```

### Subsets

```js
/**
Given a set of distinct integers, nums, return all possible subsets.

Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
For example,
If nums = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
*/
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  var result = [],
    len = nums.length;

  nums.sort(function(a, b) {
    return a - b;
  });

  helper(nums, 0, len - 1, [], result);

  return result;
};

function helper(nums, start, end, curArr, result) {
  result.push(curArr);

  var i;

  for (i = start; i <= end; i++) {
    curArr.push(nums[i]);
    helper(nums, i + 1, end, curArr.concat(), result);
    curArr.pop();
  }
}
```

### Substring with Concatenation of All Words

```js
/**
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

For example, given:
s: "barfoothefoobarman"
words: ["foo", "bar"]

You should return the indices: [0,9].
(order does not matter).
*/
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */

// TIME LIMIT EXCEEDED...
var findSubstring = function(s, words) {
  var len = s.length,
    wordsLen = words.length,
    wordLen = words[0].length,
    i,
    j,
    m,
    temp,
    toFound = {},
    found = {},
    result = [];

  for (i = 0; i < wordsLen; i++) {
    if (!toFound[words[i]]) {
      toFound[words[i]] = 1;
    } else {
      toFound[words[i]]++;
    }
  }

  for (i = 0; i < len; i++) {
    found = {};
    j = i;
    for (m = 0; m < wordsLen; m++) {
      temp = s.slice(j, j + wordLen);

      if (!toFound[temp]) {
        break;
      }

      if (toFound[temp]) {
        if (!found[temp]) {
          found[temp] = 1;
        } else {
          found[temp]++;
        }
      }

      if (found[temp] > toFound[temp]) {
        break;
      }

      j += wordLen;
    }

    if (m === wordsLen) {
      result.push(i);
    }
  }

  return result;
};
```

### Sum Root to Leaf Numbers

```js
/**
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

For example,

    1
   / \
  2   3
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.

Return the sum = 12 + 13 = 25.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
  var arr = [0];

  helper(root, 0, arr);

  return arr[0];
};

function helper(node, sum, arr) {
  if (!node) {
    return;
  }

  sum = sum * 10 + node.val;

  if (!node.left && !node.right) {
    arr[0] += sum;
    return;
  }

  if (node.left) {
    helper(node.left, sum, arr);
  }

  if (node.right) {
    helper(node.right, sum, arr);
  }
}
```

### Summary Ranges

```js
/**
Given a sorted integer array without duplicates, return the summary of its ranges.

For example, given [0,1,2,4,5,7], return ["0->2","4->5","7"].
*/

/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
  var len = nums.length,
    result = [],
    curStr = '',
    curLen,
    curNum,
    i;

  if (len === 0) {
    return result;
  }

  curNum = nums[0];
  curStr += curNum;
  curLen = 1;

  for (i = 1; i < len; i++) {
    if (curNum + 1 === nums[i]) {
      curNum++;
      curLen++;
    } else {
      if (curLen > 1) {
        curStr += '->' + curNum;
      }

      result.push(curStr);
      curNum = nums[i];
      curLen = 1;
      curStr = '' + curNum;
    }
  }

  if (curLen > 1) {
    curStr += '->' + curNum;
  }

  result.push(curStr);
  return result;
};
```

### Super Ugly Number

```js
/**
Write a program to find the nth super ugly number.

Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.

Note:
(1) 1 is a super ugly number for any given primes.
(2) The given numbers in primes are in ascending order.
(3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.
*/

/**
 * @param {number} n
 * @param {number[]} primes
 * @return {number}
 */
var nthSuperUglyNumber = function(n, primes) {
  var primeIndex = [],
    result = [],
    len = primes.length,
    tmp,
    min,
    curPrimeIndex,
    i,
    j;

  for (i = 0; i < len; i++) {
    primeIndex.push(0);
  }

  result.push(1);

  for (i = 1; i < n; ) {
    min = Number.MAX_VALUE;
    curPrimeIndex = 0;
    for (j = 0; j < len; j++) {
      tmp = result[primeIndex[j]] * primes[j];

      if (tmp < min) {
        curPrimeIndex = j;
        min = tmp;
      }
    }

    primeIndex[curPrimeIndex]++;

    if (min !== result[i - 1]) {
      result[i] = min;
      i++;
    }
  }

  return result[n - 1];
};
```

### Surrounded Regions

```js
/**
Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

For example,
X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
*/

/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
  if (board === null) {
    return;
  }

  var rowL = board.length,
    columnL,
    i,
    j;

  if (rowL <= 1) {
    return;
  }

  columnL = board[0].length;

  // visit borders
  for (i = 0; i < rowL; i++) {
    visit(board, i, 0, rowL, columnL);
    visit(board, i, columnL - 1, rowL, columnL);
  }

  // visit borders
  for (i = 1; i < columnL - 1; i++) {
    visit(board, 0, i, rowL, columnL);
    visit(board, rowL - 1, i, rowL, columnL);
  }

  // flip all 'O' to 'X' and flip all 'Y' to 'O'
  for (i = 0; i < rowL; i++) {
    for (j = 0; j < columnL; j++) {
      if (board[i][j] === 'O') {
        board[i][j] = 'X';
      } else if (board[i][j] === 'Y') {
        board[i][j] = 'O';
      }
    }
  }
};

// flip connected 0 to 'Y'
function visit(board, i, j, rowL, columnL) {
  if (i < 0 || j < 0 || i >= rowL || j >= columnL || board[i][j] !== 'O') {
    return;
  }

  var queue = [],
    cur,
    row,
    column;

  board[i][j] = 'Y';
  queue.push(i * columnL + j);

  while (queue.length > 0) {
    cur = queue.pop();
    row = Math.floor(cur / columnL);
    column = cur % columnL;

    if (row > 0 && board[row - 1][column] === 'O') {
      queue.push((row - 1) * columnL + column);
      board[row - 1][column] = 'Y';
    }

    if (row < rowL - 1 && board[row + 1][column] === 'O') {
      queue.push((row + 1) * columnL + column);
      board[row + 1][column] = 'Y';
    }

    if (column > 0 && board[row][column - 1] === 'O') {
      queue.push(row * columnL + column - 1);
      board[row][column - 1] = 'Y';
    }

    if (column < columnL - 1 && board[row][column + 1] === 'O') {
      queue.push(row * columnL + column + 1);
      board[row][column + 1] = 'Y';
    }
  }
}
```

### Swap Nodes in Pairs

```js
/**
Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
*/

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
  if (head === null) {
    return null;
  }

  var next = head.next,
    result = next ? next : head,
    prevTail,
    curHead,
    nextHead;

  curHead = head;

  while (next) {
    nextHead = next.next;

    if (prevTail) {
      prevTail.next = next;
    }

    next.next = curHead;
    curHead.next = nextHead;
    prevTail = curHead;

    curHead = nextHead;
    next = curHead && curHead.next;
  }

  return result;
};
```

### Symmetric Tree

```js
/**
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following is not:
    1
   / \
  2   2
   \   \
   3    3
Note:
Bonus points if you could solve it both recursively and iteratively.

confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.


OJ's Binary Tree Serialization:
The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.

Here's an example:
   1
  / \
 2   3
    /
   4
    \
     5
The above binary tree is serialized as "{1,2,3,#,#,4,#,#,5}".
*/

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  if (root === null) {
    return true;
  }

  return isSymmetricHelper(root.left, root.right);
};

function isSymmetricHelper(left, right) {
  if ((left === null && right !== null) || (left !== null && right === null)) {
    return false;
  }

  if (left === null && right === null) {
    return true;
  } else if (left.val !== right.val) {
    return false;
  }

  return isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left);
}
```

### Text Justification

```js
/**
Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

For example,
words: ["This", "is", "an", "example", "of", "text", "justification."]
L: 16.

Return the formatted lines as:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
Note: Each word is guaranteed not to exceed L in length.

click to show corner cases.

Corner Cases:
A line other than the last line might contain only one word. What should you do in this case?
In this case, that line should be left-justified.
*/
/**
 * @param {string[]} words
 * @param {number} maxWidth
 * @return {string[]}
 */
var fullJustify = function(words, maxWidth) {
  var len = words.length,
    lastIndex = -1,
    result = [],
    curLen = 0,
    wordsCount,
    spaceCount,
    extraSpace,
    totalSpace,
    word = '',
    i,
    j;

  if (maxWidth === 0) {
    return [''];
  }

  for (i = 0; i < len; i++) {
    curLen += words[i].length + 1;

    if (curLen - 1 > maxWidth || i === len - 1) {
      if (curLen - 1 > maxWidth && i - lastIndex > 1) {
        curLen -= words[i].length + 1;
        i--;
      }

      wordsCount = i - lastIndex;
      curLen -= wordsCount; // by now, curlen is length without any space

      if (wordsCount === 1) {
        word += words[i];
        word = appendSpace(word, maxWidth - curLen);
      } else if (i === len - 1) {
        totalSpace = maxWidth - curLen;

        for (j = lastIndex + 1; j <= i; j++) {
          word += words[j];

          if (totalSpace > 0) {
            totalSpace--;
            word += ' ';
          }
        }

        if (totalSpace > 0) {
          word = appendSpace(word, totalSpace);
        }
      } else {
        // if n words, then n - 1 spaces
        spaceCount = parseInt((maxWidth - curLen) / (wordsCount - 1));
        extraSpace = (maxWidth - curLen) % (wordsCount - 1);

        for (j = lastIndex + 1; j <= i; j++) {
          word += words[j];

          if (j !== i) {
            word = appendSpace(word, spaceCount);

            if (extraSpace > 0) {
              word += ' ';
              extraSpace--;
            }
          }
        }
      }

      result.push(word);
      word = '';
      lastIndex = i;
      curLen = 0;
    }
  }

  return result;
};

// append k spaces at end of word
function appendSpace(word, k) {
  while (k > 0) {
    word += ' ';
    k--;
  }

  return word;
}
```

### Top K Frequent Elements

```js
/**
Given a non-empty array of integers, return the k most frequent elements.

For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].

Note:
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
*/
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 *
 *  Build a array of list to be buckets with length 1 to sort.
 */
var topKFrequent = function(nums, k) {
  let len = nums.length;
  const bucket = {};
  const freqs = [];
  let result = [];

  nums.forEach(num => {
    if (bucket[num] === undefined) {
      bucket[num] = 1;
    } else {
      bucket[num]++;
    }
  });

  Object.keys(bucket).forEach(num => {
    const freq = bucket[num];
    num = parseInt(num);

    if (freqs[freq] === undefined) {
      freqs[freq] = [num];
    } else {
      freqs[freq].push(num);
    }
  });

  let j = 0;
  for (let i = freqs.length; i >= 0; i--) {
    if (freqs[i] !== undefined) {
      len = freqs[i].length;

      for (let m = 0; m < len; m++) {
        if (j === k) {
          break;
        }

        result.push(freqs[i][m]);
        j++;
      }

      if (j === k) {
        break;
      }
    }
  }

  return result;
};
```

### Trapping Rain Water

```js
/**
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example,
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.


The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!


*/

// add new solution
/**
 * @param {number[]} height
 * @return {number}
 *
 * Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container.
 */
var trap = function(height) {
  var len = height.length,
    leftMax = 0,
    rightMax = 0,
    left = 0,
    right = len - 1,
    sum = 0;

  while (left <= right) {
    if (height[left] <= height[right]) {
      if (height[left] > leftMax) {
        leftMax = height[left];
      } else {
        sum += leftMax - height[left];
      }

      left++;
    } else {
      if (height[right] > rightMax) {
        rightMax = height[right];
      } else {
        sum += rightMax - height[right];
      }

      right--;
    }
  }

  return sum;
};

/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  var len = height.length,
    leftMax = [],
    rightMax = [],
    max,
    sum = 0,
    i;

  leftMax[0] = 0;
  rightMax[len - 1] = 0;

  for (i = 1; i < len; i++) {
    leftMax[i] = Math.max(leftMax[i - 1], height[i - 1]);
  }

  for (i = len - 2; i >= 0; i--) {
    rightMax[i] = Math.max(rightMax[i + 1], height[i + 1]);
  }

  for (i = 1; i < len - 1; i++) {
    max = Math.min(leftMax[i], rightMax[i]);

    if (max - height[i] > 0) {
      sum += max - height[i];
    }
  }

  return sum;
};
```

### Triangle

```js
/**
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.

 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
  var arr = [],
    len = triangle.length - 1,
    i,
    j;

  for (i = 0; i <= len; i++) {
    arr[i] = triangle[len][i];
  }

  for (i = len - 1; i >= 0; i--) {
    for (j = 0; j <= i; j++) {
      arr[j] = triangle[i][j] + Math.min(arr[j], arr[j + 1]);
    }
  }
  return arr[0];
};
```

### Two Sum

```js
/**
Given an array of integers, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2

 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]} two integers in an array, ie: [index1, index2]
 */
var twoSum = function(numbers, target) {
  var map = {},
    i,
    length = numbers.length,
    value,
    neededValue,
    result = [];

  for (i = 0; i < length; i++) {
    value = numbers[i];
    neededValue = target - value;
    if (neededValue in map) {
      result.push(map[neededValue] + 1);
      result.push(i + 1);
      break;
    } else {
      map[value] = i;
    }
  }
  return result;
};
```

### Ugly Number II

```js
/**
Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

Note that 1 is typically treated as an ugly number.

Hint:

The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones.
An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.
The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3.
Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).
*/
/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
  var result = [],
    primeIndex2 = 0,
    primeIndex3 = 0,
    primeIndex5 = 0,
    cur2,
    cur3,
    cur5,
    i;

  result.push(1);

  for (i = 1; i < n; ) {
    cur2 = result[primeIndex2] * 2;
    cur3 = result[primeIndex3] * 3;
    cur5 = result[primeIndex5] * 5;

    cur = Math.min(cur2, cur3, cur5);

    if (cur === cur2) {
      primeIndex2++;
    } else if (cur === cur3) {
      primeIndex3++;
    } else {
      primeIndex5++;
    }

    if (cur !== result[i - 1]) {
      result.push(cur);
      i++;
    }
  }

  return result.pop();
};
```

### Ugly Number

```js
/**
Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.

Note that 1 is typically treated as an ugly number.
*/

/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
  if (num <= 0) {
    return false;
  }

  while (num % 2 === 0) {
    num = num / 2;
  }

  while (num % 3 === 0) {
    num = num / 3;
  }

  while (num % 5 === 0) {
    num = num / 5;
  }

  return num === 1;
};
```

### Unique Binary Search Trees II

```js
/**
Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

For example,
Given n = 3, your program should return all 5 unique BST's shown below.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
  if (n === 0) {
    return [];
  }

  return genTreeHelper(1, n);
};

function genTreeHelper(start, end) {
  var result = [],
    left,
    right,
    node,
    i,
    j,
    k;

  if (start > end) {
    return [null];
  }

  for (i = start; i <= end; i++) {
    left = genTreeHelper(start, i - 1);
    right = genTreeHelper(i + 1, end);
    for (k = 0; k < left.length; k++) {
      for (j = 0; j < right.length; j++) {
        node = new TreeNode(i);
        node.left = left[k];
        node.right = right[j];
        result.push(node);
      }
    }
  }

  return result;
}
```

### Unique Binary Search Trees

```js
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  var i,
    j,
    result = [];

  result[0] = 1;
  result[1] = 1;

  for (i = 2; i <= n; i++) {
    result[i] = 0;
    for (j = 0; j < i; j++) {
      result[i] += result[j] * result[i - 1 - j];
    }
  }
  return result[n];
};
```

### Unique Paths II

```js
/**
Follow up for "Unique Paths":

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is 2.

Note: m and n will be at most 100.


*/
/**
 * @param {number[][]} obstacle
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacle) {
  var rLen = obstacle.length,
    matrix = [],
    cLen,
    i,
    j;

  if (rLen === 0) {
    return 0;
  }

  cLen = obstacle[0].length;

  if (obstacle[0][0] === 1) {
    return 0;
  }

  for (i = 0; i < rLen; i++) {
    matrix.push(new Array(cLen));
  }

  matrix[0][0] = 1;
  for (i = 1; i < cLen; i++) {
    matrix[0][i] = obstacle[0][i] || !matrix[0][i - 1] ? 0 : 1;
  }

  for (i = 1; i < rLen; i++) {
    matrix[i][0] = obstacle[i][0] || !matrix[i - 1][0] ? 0 : 1;
  }

  for (i = 1; i < rLen; i++) {
    for (j = 1; j < cLen; j++) {
      if (obstacle[i][j]) {
        matrix[i][j] = 0;
      } else {
        matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1];
      }
    }
  }

  return matrix[rLen - 1][cLen - 1];
};
```

### Unique Paths

```js
/**
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


Above is a 3 x 7 grid. How many possible unique paths are there?

Note: m and n will be at most 100.
*/
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  var map = [],
    temp,
    i,
    j;

  for (i = 0; i < m; i++) {
    temp = [];
    map.push(temp);
  }

  for (i = 0; i < n; i++) {
    map[0][i] = 1;
  }

  for (i = 0; i < m; i++) {
    map[i][0] = 1;
  }

  for (i = 1; i < m; i++) {
    for (j = 1; j < n; j++) {
      map[i][j] = map[i - 1][j] + map[i][j - 1];
    }
  }

  return map[m - 1][n - 1];
};
```

### Unique Word Abbreviation

```js
/**
An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:

a) it                      --> it    (no abbreviation)

     1
b) d|o|g                   --> d1g

              1    1  1
     1---5----0----5--8
c) i|nternationalizatio|n  --> i18n

              1
     1---5----0
d) l|ocalizatio|n          --> l10n

Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.

Example:

Given dictionary = [ "deer", "door", "cake", "card" ]

isUnique("dear") -> false
isUnique("cart") -> true
isUnique("cane") -> false
isUnique("make") -> true

*/
/**
 * @constructor
 * @param {string[]} dictionary
 */
var ValidWordAbbr = function(dictionary) {
  this.map = new Map();
  this.getAbbr = function(str) {
    const len = str.length;

    if (len <= 2) {
      return str;
    }

    return str.charAt(0) + (len - 2) + str.charAt(len - 1);
  };

  dictionary.forEach(word => {
    const abbr = this.getAbbr(word);

    if (!this.map.has(abbr)) {
      this.map.set(abbr, word);
    } else {
      if (this.map.get(abbr) !== word) {
        this.map.set(abbr, '');
      }
    }
  });
};

/**
 * @param {string} word
 * @return {bool}
 */
ValidWordAbbr.prototype.isUnique = function(word) {
  const abbr = this.getAbbr(word);

  return !this.map.has(abbr) || this.map.get(abbr) === word;
};

/**
 * Your ValidWordAbbr object will be instantiated and called as such:
 * var vwa = new ValidWordAbbr(dictionary);
 * vwa.isUnique("word");
 * vwa.isUnique("anotherWord");
 */
```

### Valid Anagram

```js
/**
Given two strings s and t, write a function to determine if t is an anagram of s.

For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.

Note:
You may assume the string contains only lowercase alphabets.

Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?
*/

/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
  var len = s.length,
    arr = {},
    i;

  if (t.length !== len) {
    return false;
  }

  if (len === 0) {
    return true;
  }

  for (i = 0; i < len; i++) {
    if (!arr[s.charAt(i)]) {
      arr[s.charAt(i)] = 1;
    } else {
      arr[s.charAt(i)]++;
    }
  }

  for (i = 0; i < len; i++) {
    if (typeof arr[t.charAt(i)] === 'undefined' || --arr[t.charAt(i)] < 0) {
      return false;
    }
  }

  return true;
};
```

### Valid Palindrome

```js
/**
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.

 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  var len = s.length,
    str,
    i;

  if (len === 0) {
    return true;
  }

  str = s.replace(/\W/g, '').toLowerCase();
  len = str.length;

  if (len === 0) {
    return true;
  }

  for (i = 0; i < len / 2; i++) {
    if (str.charAt(i) !== str.charAt(len - 1 - i)) {
      return false;
    }
  }
  return true;
};
```

### Valid Parentheses

```js
/**
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  if (s === null) {
    return false;
  }
  var stack = [],
    sets = { '(': ')', '{': '}', '[': ']' },
    len = s.length,
    cur,
    stackTop,
    i;

  for (i = 0; i < len; i++) {
    cur = s.charAt(i);
    if (sets.hasOwnProperty(cur)) {
      stack.push(cur);
    } else {
      if (stack.length === 0) {
        return false;
      } else {
        stackTop = stack.pop();
        if (sets[stackTop] !== cur) {
          return false;
        }
      }
    }
  }
  if (stack.length === 0) {
    return true;
  } else {
    return false;
  }
};
```

### Validate Binary Search Tree

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  return isValidBSTHelper(root, null, null);
};

function isValidBSTHelper(root, min, max) {
  if (root === null) {
    return true;
  }

  if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) {
    return false;
  }

  return isValidBSTHelper(root.left, min, root.val) && isValidBSTHelper(root.right, root.val, max);
}
```

### Verify Preorder Serialization of a Binary Tree

```js
/**
One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.

     _9_
    /   \
   3     2
  / \   / \
 4   1  ###  6
/ \ / \   / \
### ### ### ###   ### #
For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where ### represents a null node.

Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.

Each comma separated value in the string must be either an integer or a character '#' representing null pointer.

You may assume that the input format is always valid, for example it could never contain two consecutive commas such as "1,,3".

Example 1:
"9,3,4,#,#,1,#,#,2,#,6,#,#"
Return true

Example 2:
"1,#"
Return false

Example 3:
"9,#,#,1"
Return false
*/
/**
 * @param {string} preorder
 * @return {boolean}
 * 这个方法简单的说就是不断的砍掉叶子节点。最后看看能不能全部砍掉。

已例子一为例，：”9,3,4,#,#,1,#,#,2,#,6,#,#” 遇到x ### #的时候，就把它变为 ### 我模拟一遍过程：

9,3,4,#,### => 9,3,### 继续读
9,3,#,1,#,### => 9,3,#,### => 9,### 继续读
9,#2,#,6,#,### => 9,#,2,#,### => 9,#,### => #
 */
var isValidSerialization = function(preorder) {
  var arr = preorder.split(','),
    stack = [],
    len = arr.length,
    i;

  for (i = 0; i < len; i++) {
    stack.unshift(arr[i]);

    while (stack.length > 2 && stack[0] === '#' && stack[1] === '#') {
      if (stack[2] === '#') {
        return false;
      }

      stack.shift();
      stack.shift();
      stack[0] = '#';
    }
  }

  return stack.length === 1 && stack[0] === '#';
};

// solution 2

/**
 * @param {string} preorder
 * @return {boolean}
 * 对于二叉树，我们把空的地方也作为叶子节点(如题目中的#)，那么有

所有的非空节点提供2个出度和1个入度(根除外)
所有的空节点但提供0个出度和1个入度
我们在遍历的时候，计算diff = outdegree – indegree. 当一个节点出现的时候，diff – 1，因为它提供一个入度；当节点不是#的时候，diff+2(提供两个出度) 如果序列式合法的，那么遍历过程中diff >=0 且最后结果为0.
 */
var isValidSerialization = function(preorder) {
  var arr = preorder.split(','),
    len = arr.length,
    diff; // outdegree - indegree

  if (arr[0] === '#') {
    if (len > 1) {
      return false;
    }
    return true;
  }

  diff = 2;

  for (i = 1; i < len; i++) {
    diff--; // from parent
    if (diff < 0) {
      return false;
    }

    if (arr[i] !== '#') {
      diff += 2; // have two outdegree
    }
  }

  return diff === 0;
};
```

### Walls and Gates

```js
/**
 You are given a m x n 2D grid initialized with these three possible values.

    -1 - A wall or an obstacle.
    0 - A gate.
    INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.

For example, given the 2D grid:

INF  -1  0  INF
INF INF INF  -1
INF  -1 INF  -1
  0  -1 INF INF

After running your function, the 2D grid should be:

  3  -1   0   1
  2   2   1  -1
  1  -1   2  -1
  0  -1   3   4
*/

/**
 * @param {number[][]} rooms
 * @return {void} Do not return anything, modify rooms in-place instead.
 */
var wallsAndGates = function(rooms) {
  let queue = [];
  let rowLen = rooms.length;
  const MAX_VALUE = 2147483647;
  if (rowLen === 0) {
    return;
  }

  let colLen = rooms[0].length;

  for (let i = 0; i < rowLen; i++) {
    for (let j = 0; j < colLen; j++) {
      if (rooms[i][j] === 0) {
        queue.push([i, j]);
      }
    }
  }

  while (queue.length > 0) {
    const cur = queue.shift();
    const row = cur[0];
    const col = cur[1];
    const val = rooms[row][col];

    if (row + 1 < rowLen && rooms[row + 1][col] === MAX_VALUE) {
      rooms[row + 1][col] = val + 1;
      queue.push([row + 1, col]);
    }

    if (row - 1 >= 0 && rooms[row - 1][col] === MAX_VALUE) {
      rooms[row - 1][col] = val + 1;
      queue.push([row - 1, col]);
    }

    if (col + 1 < colLen && rooms[row][col + 1] === MAX_VALUE) {
      rooms[row][col + 1] = val + 1;
      queue.push([row, col + 1]);
    }

    if (col - 1 >= 0 && rooms[row][col - 1] === MAX_VALUE) {
      rooms[row][col - 1] = val + 1;
      queue.push([row, col - 1]);
    }
  }
};
```

### Wiggle Sort II

```js
/**
Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....

Example:
(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6].
(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].

Note:
You may assume all input has valid answer.

Follow Up:
Can you do it in O(n) time and/or in-place with O(1) extra space?
*/
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var wiggleSort = function(nums) {
  var len = nums.length,
    temp = [],
    midIndex = parseInt((len + 1) / 2),
    i,
    l,
    r,
    medium;

  medium = findKth(0, len - 1, midIndex, nums);

  for (i = 0, l = 0, r = len - 1; i < len; i++) {
    if (nums[i] < medium) {
      temp[l++] = nums[i];
    } else if (nums[i] > medium) {
      temp[r--] = nums[i];
    }
  }

  while (l < midIndex) {
    temp[l++] = medium;
  }

  while (r >= midIndex) {
    temp[r--] = medium;
  }

  r = len;

  for (i = 0; i < len; i++) {
    nums[i] = (i & 1) === 0 ? temp[--l] : temp[--r];
  }
};

function findKth(start, end, k, nums) {
  if (start >= end) {
    return nums[end];
  }

  var index = partition(start, end, nums),
    count = index - start + 1;

  if (count === k) {
    return nums[index];
  }

  if (count < k) {
    return findKth(index + 1, end, k - count, nums);
  }

  return findKth(start, index - 1, k, nums);
}

function partition(start, end, nums) {
  var val = nums[start],
    i,
    j;

  i = start + 1;
  j = end;

  while (true) {
    while (nums[i] <= val) {
      i++;
    }

    while (nums[j] > val) {
      j--;
    }

    if (i >= j) {
      break;
    }

    swap(nums, i, j);
  }

  swap(nums, j, start);

  return j;
}

function swap(nums, i, j) {
  var temp = nums[i];

  nums[i] = nums[j];
  nums[j] = temp;
}
```

### Wildcard Matching

```js
/**
Implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
*/
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  let sIndex = 0;
  let pIndex = 0;
  let startIndex = -1; // startIndex of * in p
  let match = 0; // the position in s that matches with p

  while (sIndex < s.length) {
    // matches, both advance
    if (pIndex < p.length && (s.charAt(sIndex) === p.charAt(pIndex) || p.charAt(pIndex) === '?')) {
      pIndex++;
      sIndex++;
    } else if (pIndex < p.length && p.charAt(pIndex) === '*') {
      startIndex = pIndex;
      match = sIndex;
      pIndex++;
    } else if (startIndex !== -1) {
      pIndex = startIndex + 1;
      match++;
      sIndex = match;
    } else {
      return false;
    }
  }

  while (pIndex < p.length && p.charAt(pIndex) === '*') {
    pIndex++;
  }

  return pIndex === p.length;
};
```

### Word Break II

```js
/**
Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

A solution is ["cats and dog", "cat sand dog"].


*/
// Time limit exceeded...
/**
 * @param {string} s
 * @param {set<string>} wordDict
 *   Note: wordDict is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  const len = s.length;
  let hasSeg = [];
  let result = [];
  let i, j;

  for (i = 0; i <= len; i++) {
    hasSeg.push(new Array(len + 1).fill(false));
  }

  hasSeg[0][0] = true;

  for (i = 0; i <= len; i++) {
    for (j = i; j >= 0; j--) {
      if (wordDict.has(s.slice(j, i))) {
        hasSeg[j][i] = true;
      } else {
        for (let k = j; k < i; k++) {
          if (hasSeg[j][k] && hasSeg[k][i]) {
            hasSeg[j][i] = true;
            break;
          }
        }
      }
    }
  }

  helper(result, [], 0, s, wordDict, hasSeg);

  return result;
};

function helper(result, curArr, startIndex, s, wordDict, hasSeg) {
  if (startIndex === s.length) {
    result.push(curArr.join(' '));
  }

  for (let i = startIndex; i <= s.length; i++) {
    if (hasSeg[startIndex][i]) {
      if (wordDict.has(s.slice(startIndex, i))) {
        curArr.push(s.slice(startIndex, i));
        helper(result, curArr.concat(), i, s, wordDict, hasSeg);
        curArr.pop();
      }
    }
  }
}

// Memory limit exceeded
/**
 * @param {string} s
 * @param {set<string>} wordDict
 *   Note: wordDict is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  let map = {};

  return helper(map, s, wordDict);
};

function helper(map, s, wordDict) {
  if (map.hasOwnProperty(s)) {
    return map[s];
  }

  let result = [];

  if (s.length === 0) {
    result.push('');
    return result;
  }

  wordDict.forEach(word => {
    if (s.startsWith(word)) {
      let subArr = helper(map, s.slice(word.length), wordDict);

      result.push((word + ' ' + subArr.join(' ')).trim());
    }
  });

  map[s] = result;
  return result;
}
```

### Word Break

```js
/**
Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given
s = "leetcode",
dict = ["leet", "code"].

Return true because "leetcode" can be segmented as "leet code".
*/
/**
 * @param {string} s
 * @param {set<string>} wordDict
 *   Note: wordDict is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var hasFound = [],
    len = s.length,
    i,
    j;

  hasFound[0] = true;

  for (i = 1; i <= len; i++) {
    for (j = 0; j < i; j++) {
      if (hasFound[j] && wordDict.has(s.substring(j, i))) {
        hasFound[i] = true;
        break;
      }
    }
  }

  return hasFound[len] === true;
};
```

### Word Ladder

```js
/**
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time
Each intermediate word must exist in the word list
For example,

Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.

Note:
Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
*/
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {Set} wordList
 *   Note: wordList is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
  var visit = {},
    len = beginWord.length,
    queue = [],
    charArr = [
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z',
    ],
    curNode,
    curStr,
    tempStr,
    tempNode,
    i,
    j;

  curNode = new node(beginWord, 1);
  visit[curNode.str] = true;
  queue.push(curNode);

  while (queue.length > 0) {
    curNode = queue.shift();
    curStr = curNode.str;
    for (i = 0; i < len; i++) {
      for (j = 0; j < 26; j++) {
        if (charArr[j] === curStr.charAt(i)) {
          continue;
        }

        tempStr = curStr.substring(0, i) + charArr[j] + curStr.substring(i + 1, len);

        if (tempStr === endWord) {
          return curNode.step + 1;
        }

        if (wordList.has(tempStr) && !visit.hasOwnProperty(tempStr)) {
          visit[tempStr] = true;
          tempNode = new node(tempStr, curNode.step + 1);
          queue.push(tempNode);
        }
      }
    }
  }

  return 0;
};

function node(str, step) {
  this.str = str;
  this.step = step;
}
```

### Word Pattern

```js
/**
Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Examples:
pattern = "abba", str = "dog cat cat dog" should return true.
pattern = "abba", str = "dog cat cat fish" should return false.
pattern = "aaaa", str = "dog cat cat dog" should return false.
pattern = "abba", str = "dog dog dog dog" should return false.
Notes:
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.
*/

/**
 * @param {string} pattern
 * @param {string} str
 * @return {boolean}
 */
var wordPattern = function(pattern, str) {
  var arr = str.split(' '),
    len = arr.length,
    map1 = {},
    map2 = {},
    curChar,
    curString,
    i;

  if (pattern.length !== len) {
    return false;
  }

  for (i = 0; i < len; i++) {
    curChar = pattern.charAt(i);
    curString = arr[i];

    if (!map1.hasOwnProperty(curChar) && !map2.hasOwnProperty(curString)) {
      map1[curChar] = curString;
      map2[curString] = curChar;
    } else if (map1[curChar] !== curString || map2[curString] !== curChar) {
      return false;
    }
  }

  return true;
};
```

### Word Search II

```js
/**
Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =

[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
Return ["eat","oath"].
Note:
You may assume that all inputs are consist of lowercase letters a-z.

click to show hint.

You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?

If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.
*/
/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
  let root = buildTrie(words);
  let result = [];

  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[0].length; j++) {
      dfs(result, root, board, i, j);
    }
  }

  return result;
};

function dfs(result, node, board, i, j) {
  const ch = board[i][j];

  if (ch === '#' || !node.next[ch]) {
    return;
  }

  board[i][j] = '#';
  node = node.next[ch];

  if (node.word) {
    result.push(node.word);
    node.word = null; // dedupe
  }

  if (i > 0) {
    dfs(result, node, board, i - 1, j);
  }

  if (j > 0) {
    dfs(result, node, board, i, j - 1);
  }

  if (i < board.length - 1) {
    dfs(result, node, board, i + 1, j);
  }

  if (j < board[0].length - 1) {
    dfs(result, node, board, i, j + 1);
  }

  board[i][j] = ch;
}

function buildTrie(words) {
  let root = new TrieNode();

  words.forEach(word => {
    const chs = word.split('');
    let node = root;

    for (let i = 0; i < chs.length; i++) {
      const ch = chs[i];

      if (!node.next[ch]) {
        node.next[ch] = new TrieNode();
      }

      node = node.next[ch];
    }

    node.word = word;
  });

  return root;
}

class TrieNode {
  constructor() {
    this.word = null;
    this.next = {};
  }
}
```

### Word Search

```js
/**
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =

[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.
*/
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  var rLen = board.length,
    cLen = board[0].length;

  return helper(word, board, rLen, cLen);
};

function helper(word, board, rLen, cLen) {
  var ch = word.charAt(0),
    i,
    j;

  for (i = 0; i < rLen; i++) {
    for (j = 0; j < cLen; j++) {
      if (board[i][j] === ch) {
        board[i][j] = '*';
        if (bfs(1, word, i, j, board, rLen, cLen)) {
          return true;
        }
        board[i][j] = ch;
      }
    }
  }

  return false;
}

function bfs(index, word, i, j, board, rLen, cLen) {
  if (index === word.length) {
    return true;
  }

  var ch = word.charAt(index);

  if (i - 1 >= 0 && board[i - 1][j] === ch) {
    board[i - 1][j] = '*';

    if (bfs(index + 1, word, i - 1, j, board, rLen, cLen)) {
      return true;
    }

    board[i - 1][j] = ch;
  }

  if (j - 1 >= 0 && board[i][j - 1] === ch) {
    board[i][j - 1] = '*';

    if (bfs(index + 1, word, i, j - 1, board, rLen, cLen)) {
      return true;
    }

    board[i][j - 1] = ch;
  }

  if (i + 1 < rLen && board[i + 1][j] === ch) {
    board[i + 1][j] = '*';

    if (bfs(index + 1, word, i + 1, j, board, rLen, cLen)) {
      return true;
    }

    board[i + 1][j] = ch;
  }

  if (j + 1 < cLen && board[i][j + 1] === ch) {
    board[i][j + 1] = '*';

    if (bfs(index + 1, word, i, j + 1, board, rLen, cLen)) {
      return true;
    }

    board[i][j + 1] = ch;
  }
}
```

### ZigZag Conversion

```js
/**
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);
convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".
*/

// http://www.cnblogs.com/springfor/p/3889414.html
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  var size = 2 * numRows - 2,
    len = s.length,
    result = '',
    mid,
    i,
    j;

  if (numRows === 1) {
    return s;
  }

  for (i = 0; i < numRows; i++) {
    for (j = i; j < len; j += size) {
      result += s.charAt(j);

      // for the middle ones, excluding first row and last row
      if (i !== 0 && i !== numRows - 1) {
        mid = j + size - 2 * i;

        if (mid < len) {
          result += s.charAt(mid);
        }
      }
    }
  }

  return result;
};
```

### Zigzag Iterator

```js
/**
Given two 1d vectors, implement an iterator to return their elements alternately.

For example, given two 1d vectors:

v1 = [1, 2]
v2 = [3, 4, 5, 6]

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].

Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?

Clarification for the follow up question - Update (2015-09-18):
The "Zigzag" order is not clearly defined and is ambiguous for k > 2 cases. If "Zigzag" does not look right to you, replace "Zigzag" with "Cyclic". For example, given the following input:

[1,2,3]
[4,5,6,7]
[8,9]

It should return [1,4,8,2,5,9,3,6,7].
*/
/**
 * @constructor
 * @param {Integer[]} v1
 * @param {Integer[]} v1
 */
var ZigzagIterator = function ZigzagIterator(v1, v2) {
  this.arr = arguments;
  this.list = [];

  for (let i = 0; i < this.arr.length; i++) {
    if (this.arr[i].length > 0) {
      this.list.push([i, 0]);
    }
  }
};

/**
 * @this ZigzagIterator
 * @returns {boolean}
 */
ZigzagIterator.prototype.hasNext = function hasNext() {
  return this.list.length > 0;
};

/**
 * @this ZigzagIterator
 * @returns {integer}
 */
ZigzagIterator.prototype.next = function next() {
  const targetIndex = this.list.shift();
  const val = this.arr[targetIndex[0]][targetIndex[1]];

  if (targetIndex[1] < this.arr[targetIndex[0]].length - 1) {
    this.list.push([targetIndex[0], targetIndex[1] + 1]);
  }

  return val;
};

/**
 * Your ZigzagIterator will be called like this:
 * var i = new ZigzagIterator(v1, v2), a = [];
 * while (i.hasNext()) a.push(i.next());
 */
```
