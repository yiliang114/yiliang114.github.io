---
layout: CustomPages
title: 合集 300-400
date: 2020.09.04
aside: false
draft: true
---

### [322].

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  let max = amount + 1;
  let dp = new Array(amount + 1);
  dp.fill(max);
  dp[0] = 0;

  for (let i = 1; i < max; i++) {
    for (let j = 0; j < coins.length; j++) {
      if (coins[j] <= i) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
      }
    }
  }
  return dp[amount] > amount ? -1 : dp[amount];
};
```

### [324].

```js
var wiggleSort = function(nums) {
  let median = findKthLargest(nums.slice(), parseInt((nums.length + 1) / 2));
  let n = nums.length;
  let left = 0,
    i = 0,
    right = n - 1;
  while (i <= right) {
    if (nums[newIndex(i, n)] > median) {
      swap(nums, newIndex(left++, n), newIndex(i++, n));
    } else if (nums[newIndex(i, n)] < median) {
      swap(nums, newIndex(right--, n), newIndex(i, n));
    } else {
      i++;
    }
  }
};

var findKthLargest = function(nums, k) {
  for (let i = 0; i <= k; i++) {
    let max = i;
    for (let j = i; j < nums.length; j++) {
      if (nums[j] > nums[max]) max = j;
    }
    swap(nums, i, max);
  }
  return nums[k - 1];
};

function newIndex(index, n) {
  return (1 + 2 * index) % (n | 1);
}

function swap(nums, a, b) {
  let tmp = nums[a];
  nums[a] = nums[b];
  nums[b] = tmp;
}

wiggleSort([1, 5, 1, 1, 6, 4]);
```

### [326].

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  return n > 0 && 1162261467 % n == 0;
};
```

### [328].

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
  if (head == null) return null;
  // 定义奇数链表、偶数链表、偶数链表开头指针
  let odd = head,
    even = head.next,
    evenHead = even;
  while (even != null && even.next != null) {
    // 保存奇数偶数链表
    odd.next = even.next;
    odd = odd.next;
    even.next = odd.next;
    even = even.next;
  }
  // 通过偶数链表开头指针合并给奇数链表
  odd.next = evenHead;
  return head;
};
```

### [329].

```js
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
  if (matrix.length == 0) return 0;
  maxLength = 0;
  cache = new Array(matrix.length);
  for (let i = 0; i < matrix.length; i++) {
    let child = new Array(matrix[0].length);
    child.fill(false);
    cache[i] = child;
  }

  for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[0].length; j++) {
      dfs(matrix, i, j, 1);
    }
  }
  return maxLength;
};

function dfs(matrix, i, j, len) {
  if (cache[i][j]) return;
  maxLength = Math.max(maxLength, len);

  let tmp = matrix[i][j];

  if (i > 0 && tmp < matrix[i - 1][j]) dfs(matrix, i - 1, j, len + 1);
  if (i < matrix.length - 1 && tmp < matrix[i + 1][j]) dfs(matrix, i + 1, j, len + 1);
  if (j > 0 && tmp < matrix[i][j - 1]) dfs(matrix, i, j - 1, len + 1);
  if (j < matrix[0].length - 1 && tmp < matrix[i][j + 1]) dfs(matrix, i, j + 1, len + 1);

  cache[i][j] = true;
}

const dirs = [
  [0, 1],
  [1, 0],
  [0, -1],
  [-1, 0],
];

var longestIncreasingPath = function(matrix) {
  if (matrix.length == 0) return 0;
  const m = matrix.length,
    n = matrix[0].length;
  let max = 1;

  let cache = new Array(m);
  for (let i = 0; i < m; i++) {
    let child = new Array(n);
    child.fill(0);
    cache[i] = child;
  }

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      let len = dfs(matrix, i, j, m, n, cache);
      max = Math.max(max, len);
    }
  }
  return max;
};

function dfs(matrix, i, j, m, n, cache) {
  if (cache[i][j] != 0) return cache[i][j];
  let max = 1;
  for (let dir of dirs) {
    let x = i + dir[0],
      y = j + dir[1];
    if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) continue;
    let len = 1 + dfs(matrix, x, y, m, n, cache);
    max = Math.max(max, len);
  }
  cache[i][j] = max;
  return max;
}
```

### [334].

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
  let c1 = Number.MAX_VALUE,
    let = Number.MAX_VALUE;
  for (let x of nums) {
    if (x <= c1) {
      c1 = x; // 最小值
    } else if (x <= c2) {
      c2 = x; // 中间值
    } else {
      return true; // 第三个值
    }
  }
  return false;
};
```

### [341].

```js
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
  this.index = 0;
  this.stack = [];
  for (let val of nestedList) {
    if (val instanceof NestedIterator) {
      while (val.hasNext()) {
        this.stack.push(val.next());
      }
    } else {
      this.stack.push(val);
    }
  }
  console.log(this.stack);
};

/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
  return this.index < this.stack.length;
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
  return this.stack[this.index++];
};

/**
 * Your NestedIterator will be called like this:
 * var i = new NestedIterator(nestedList), a = [];
 * while (i.hasNext()) a.push(i.next());
 */

var nestedList = [];
nestedList.push(new NestedIterator([1, 1]));
nestedList.push(2);
nestedList.push(new NestedIterator([1, 1]));

var i = new NestedIterator(nestedList),
  a = [];
while (i.hasNext()) a.push(i.next());
console.log(a);
```

### [344].

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseString = function(s) {
  return s
    .split('')
    .reverse()
    .join('');
};
```

### [347].

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
  let obj = {};
  for (let num of nums) {
    if (obj[num]) obj[num].count++;
    else obj[num] = { num: num, count: 1 };
  }
  let arr = [];
  for (let k in obj) {
    arr.push(obj[k]);
  }
  arr.sort((a, b) => {
    return b.count - a.count;
  });

  return arr.slice(0, k).map(item => {
    return item.num;
  });
};

console.log(topKFrequent([1, 1, 1, 2, 2, 3], 2));
```

### [350].

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
  nums1.sort(sortFun);
  nums2.sort(sortFun);

  if (nums1.length < nums2.length) {
    let tmp = nums1;
    nums1 = nums2;
    nums2 = tmp;
  }
  const ans = [];
  let index1 = 0,
    index2 = 0;
  while (index1 < nums1.length) {
    if (nums1[index1] == nums2[index2]) {
      ans.push(nums2[index2]);
      index1++;
      index2++;
    } else if (nums1[index1] > nums2[index2]) {
      index2++;
    } else {
      index1++;
    }
  }
  return ans;
};

function sortFun(a, b) {
  return a - b;
}

intersect([-2147483648, 1, 2, 3], [1, -2147483648, -2147483648]);
```

### [371].

```js
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var getSum = function(a, b) {
  if (b == 0) {
    //没有进为的时候完成运算
    return a;
  }
  let sum, carry;
  sum = a ^ b; // 进行异或计算
  carry = (a & b) << 1; // 与计算并向左移一位
  return getSum(sum, carry);
};
```

### [378].

```js
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(matrix, k) {
  // 二分法
  let lo = matrix[0][0],
    hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1; //[lo, hi)
  while (lo < hi) {
    // 中间值
    let mid = lo + parseInt((hi - lo) / 2);
    let count = 0,
      j = matrix[0].length - 1; // j 是矩阵最右侧的 index
    for (let i = 0; i < matrix.length; i++) {
      while (j >= 0 && matrix[i][j] > mid) j--; // 算出中间值是第 j 小的值(是否为k)
      count += j + 1;
    }
    if (count < k) lo = mid + 1;
    else hi = mid;
  }
  // 返回最终的值
  return lo;
};

var kthSmallest = function(matrix, k) {
  let lo = matrix[0][0],
    hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;

  while (lo < hi) {
    let mid = lo + parseInt((hi - lo) / 2);
    let count = 0,
      j = matrix[0].length - 1;
    for (let i = 0; i < matrix.length; i++) {
      while (j >= 0 && matrix[i][j] > mid) j--;
      count += j + 1;
    }
    if (count < k) lo = mid + 1;
    else hi = mid;
  }
  return lo;
};
```

### [380].

```js
/**
 * Initialize your data structure here.
 */
var RandomizedSet = function() {
  this.set = new Set();
};

/**
 * Inserts a value to the set. Returns true if the set did not already contain the specified element.
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function(val) {
  if (this.set.has(val)) {
    return false;
  } else {
    this.set.add(val);
    return true;
  }
};

/**
 * Removes a value from the set. Returns true if the set contained the specified element.
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function(val) {
  if (this.set.has(val)) {
    this.set.delete(val);
    return true;
  } else {
    this.set.add(val);
    return false;
  }
};

/**
 * Get a random element from the set.
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function() {
  const arr = [...this.set];
  return arr[RandomNum(0, arr.length - 1)];
};

function RandomNum(Min, Max) {
  var Range = Max - Min;
  var Rand = Math.random();
  var num = Min + Math.round(Rand * Range);
  return num;
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * var obj = Object.create(RandomizedSet).createNew()
 * var param_1 = obj.insert(val)
 * var param_2 = obj.remove(val)
 * var param_3 = obj.getRandom()
 */

const rs = new RandomizedSet();
console.log(rs.insert(1));
console.log(rs.remove(2));
console.log(rs.insert(2));
```

### [384].

```js
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
  this.nums = nums.slice();
};

/**
 * Resets the array to its original configuration and return it.
 * @return {number[]}
 */
Solution.prototype.reset = function() {
  return this.nums;
};

/**
 * Returns a random shuffling of the array.
 * @return {number[]}
 */
Solution.prototype.shuffle = function() {
  let clone = this.nums.slice();

  for (let i = clone.length - 1; i > 0; i--) {
    swap(clone, i, randRange(0, i - 1));
  }
  return clone;
};

function swap(nums, i, j) {
  let tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}

function randRange(Min, Max) {
  var Range = Max - Min;
  var Rand = Math.random();
  var num = Min + Math.round(Rand * Range);
  return num;
}

/**
 * Your Solution object will be instantiated and called as such:
 * var obj = Object.create(Solution).createNew(nums)
 * var param_1 = obj.reset()
 * var param_2 = obj.shuffle()
 */

var s = new Solution([1, 2, 3, 4, 5, 6, 7, 8]);
console.log(s.shuffle());
console.log(s.reset());
console.log(s.shuffle());
console.log(s.reset());
console.log(s.shuffle());
console.log(s.reset());
console.log(s.shuffle());
console.log(s.reset());
```

### [387].

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  let countObj = {};
  for (let c of s) {
    if (countObj[c]) {
      countObj[c]++;
    } else {
      countObj[c] = 1;
    }
  }
  for (let i = 0; i < s.length; i++) {
    if (countObj[s[i]] == 1) {
      return i;
    }
  }
  return -1;
};

console.log(firstUniqChar('z'));
```

### [395].

```js


class Solution {
    public int longestSubstring(String s, int k) {
        char[] str = s.toCharArray();
        return helper(str, 0, s.length(), k);
    }
    private int helper(char[] str, int start, int end, int k) {
        if (end - start < k) return 0;//substring length shorter than k.
        int[] count = new int[26];
        for (int i = start; i < end; i++) {
            int idx = str[i] - 'a';
            count[idx]++;
        }
        for (int i = 0; i < 26; i++) {
            if (count[i] < k && count[i] > 0) { //count[i]=0 => i+'a' does not exist in the string, skip it.
                for (int j = start; j < end; j++) {
                    if (str[j] == i + 'a') {
                        int left = helper(str, start, j, k);
                        int right = helper(str, j + 1, end, k);
                        return Math.max(left, right);
                    }
                }
            }
        }
        return end - start;
    }
}

/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var longestSubstring = function (s, k) {
    let str = s.split("")
    return helper(str, 0, s.length, k)
};

function helper(str, start, end, k) {
    if (end - start < k) return 0;//substring length shorter than k.
    let count = new Array(26)
    for (let i = start; i < end; i++) {
        let idx = str[i] - 'a'.charCodeAt();
        count[idx]++;
    }
    for (let i = 0; i < 26; i++) {
        if (count[i] < k && count[i] > 0) { //count[i]=0 => i+'a' does not exist in the string, skip it.
            for (let j = start; j < end; j++) {
                if (str[j].charCodeAt() == i + 'a'.charCodeAt()) {
                    let left = helper(str, start, j, k);
                    let right = helper(str, j + 1, end, k);
                    return Math.max(left, right);
                }
            }
        }
    }
    return end - start;
}


longestSubstring("bbaaacbd", 3)
```

### [303].区域和检索-数组不可变

```js
/*
 * @lc app=leetcode.cn id=303 lang=javascript
 *
 * [303] 区域和检索 - 数组不可变
 */
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  if (nums.length === 0) return;
  this.sums = [nums[0]];
  for (let i = 1; i < nums.length; i++) {
    this.sums[i] = this.sums[i - 1] + nums[i];
  }
  this.nums = nums;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  if (i === j) {
    return this.nums[i];
  } else if (i < j) {
    if (i === 0) return this.sums[j];
    return this.sums[j] - this.sums[i - 1];
  }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(i,j)
 */

// var obj = new NumArray([-2, 0, 3, -5, 2, -1])
// // var param_1 = obj.sumRange(0, 2)

// console.log(obj.sums)
// console.log(obj.sumRange(1, 1))
// console.log(obj.sumRange(0, 2))
// console.log(obj.sumRange(2, 5))
// console.log(obj.sumRange(0, 5))
```

### [307].range-sum-query-mutable

```js
/*
 * @lc app=leetcode id=307 lang=javascript
 *
 * [307] Range Sum Query - Mutable
 */
/**
 * @param {number[]} nums
 */
// var NumArray = function(nums) {
//   this.nums = nums;
// };

// /**
//  * @param {number} i
//  * @param {number} val
//  * @return {void}
//  */
// NumArray.prototype.update = function(i, val) {
//   this.nums[i] = val;
// };

// /**
//  * @param {number} i
//  * @param {number} j
//  * @return {number}
//  */
// NumArray.prototype.sumRange = function(i, j) {
//   let res = 0;
//   for (let k = i; k < j + 1; k++) {
//     res += this.nums[k];
//   }

//   return res;
// };

/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  this.nums = nums;

  // Init array representation of segment tree.
  this.segmentTree = [];

  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;
  this.buildTreeRecursively(l, r, cur);
};

NumArray.prototype.buildTreeRecursively = function(l, r, cur) {
  // If low input index and high input index are equal that would mean
  // the we have finished splitting and we are already came to the leaf
  // of the segment tree. We need to copy this leaf value from input
  // array to segment tree.
  if (l === r) {
    return (this.segmentTree[cur] = this.nums[r]);
  }

  // Split input array on two halves and process them recursively.
  const m = Math.floor((l + r) / 2);
  // Process left half of the input array.
  this.buildTreeRecursively(l, m, this.getLeftChildIndex(cur));
  // Process right half of the input array.
  this.buildTreeRecursively(m + 1, r, this.getRightChildIndex(cur));

  // Once every tree leaf is not empty we're able to build tree bottom up using
  // provided operation function.
  this.segmentTree[cur] = this.operation(
    this.segmentTree[this.getLeftChildIndex(cur)],
    this.segmentTree[this.getRightChildIndex(cur)],
  );
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
  this.nums[i] = val;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;

  return this.rangeQueryRecursive(i, j, l, r, cur);
};

NumArray.prototype.rangeQueryRecursive = function(i, j, l, r, cur) {
  if (i <= l && j >= r) {
    // Total overlap.
    return this.segmentTree[cur];
  }

  if (i > r || j < l) {
    // No overlap.
    return this.operationFallback;
  }

  // Partial overlap.
  const m = Math.floor((l + r) / 2);

  const leftOperationResult = this.rangeQueryRecursive(i, j, l, m, this.getLeftChildIndex(cur));

  const rightOperationResult = this.rangeQueryRecursive(i, j, m + 1, r, this.getRightChildIndex(cur));

  return this.sumRange(leftOperationResult, rightOperationResult);
};

NumArray.prototype.getLeftChildIndex = function(parentIndex) {
  return 2 * parentIndex + 1;
};

NumArray.prototype.getRightChildIndex = function(parentIndex) {
  return 2 * parentIndex + 2;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(i,val)
 * var param_2 = obj.sumRange(i,j)
 */
```

### [315].count-of-smaller-numbers-after-self

```js
/*
 * @lc app=leetcode id=315 lang=javascript
 *
 * [315] Count of Smaller Numbers After Self
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
  // Input: [5,2,6,1]
  // Output: [2,1,1,0]
  // 暴力法：
  //   const res = Array(nums.length).fill(0);
  //   for (let i = 0; i < nums.length - 1; i++) {
  //     for (let j = i; j < nums.length; j++) {
  //       if (nums[i] > nums[j]) {
  //         res[i] += 1;
  //       }
  //     }
  //   }

  //   return res;
  //  归并排序
  const res = Array(nums.length).fill(0);

  function merge(arr, l, m, r, res) {
    let i, j, k;
    const n1 = m - l + 1;
    const n2 = r - m;

    /* create temp arrays */
    const L = Array(n1);
    const R = Array(n2);

    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) L[i] = arr[l + i];
    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
    while (i < n1 && j < n2) {
      if (L[i] <= R[j]) {
        arr[k] = L[i];
        i++;
      } else {
        arr[k] = R[j];
        res[k] += 1;
        j++;
      }
      k++;
    }

    /* Copy the remaining elements of L[], if there
       are any */
    while (i < n1) {
      arr[k] = L[i];
      i++;
      k++;
    }

    /* Copy the remaining elements of R[], if there
       are any */
    while (j < n2) {
      arr[k] = R[j];
      j++;
      k++;
    }
  }
  function mergeSort(arr, l, r, res) {
    if (l < r) {
      const m = l + ((r - l) >> 1);

      mergeSort(arr, l, m, res);
      mergeSort(arr, m + 1, r, res);

      merge(arr, l, m, r, res);
    }
    return res;
  }

  return mergeSort(nums, 0, nums.length - 1, res);
};
```

### [326].power-of-three

```js
/*
 * @lc app=leetcode id=326 lang=javascript
 *
 * [326] Power of Three
 *
 * https://leetcode.com/problems/power-of-three/description/
 *
 * algorithms
 * Easy (41.43%)
 * Total Accepted:    [178].8K
 * Total Submissions: [430].4K
 * Testcase Example:  '27'
 *
 * Given an integer, write a function to determine if it is a power of three.
 *
 * Example 1:
 *
 *
 * Input: 27
 * Output: true
 *
 *
 * Example 2:
 *
 *
 * Input: 0
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: 9
 * Output: true
 *
 * Example 4:
 *
 *
 * Input: 45
 * Output: false
 *
 * Follow up:
 * Could you do it without using any loop / recursion?
 */
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  // tag: 数论
  // let i = 0;
  // while(Math.pow(3, i) < n) {
  //     i++;
  // }
  // return Math.pow(3, i) === n;

  // 巧用整除
  return n > 0 && Math.pow(3, 19) % n === 0;
};
// 扩展： 这个方法可以扩展到任意质数，合数则不行
```

### [337].house-robber-iii

```js
/*
 * @lc app=leetcode id=337 lang=javascript
 *
 * [337] House Robber III
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(root) {
  if (root === null) return [0, 0];
  // 0: rob 1: notRob
  const l = helper(root.left);
  const r = helper(root.right);

  const robed = root.val + l[1] + r[1];
  const notRobed = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);

  return [robed, notRobed];
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
  //   if (root === null) return 0;
  //   const notRobed = rob(root.left) + rob(root.right);
  //   const robed =
  //     root.val +
  //     rob(root.left && root.left.left) +
  //     rob(root.left && root.left.right) +
  //     rob(root.right && root.right.left) +
  //     rob(root.right && root.right.right);

  //   return Math.max(notRobed, robed);

  // dp
  const [robed, notRobed] = helper(root);
  return Math.max(robed, notRobed);
};
```

### [338].counting-bits

```js
/*
 * @lc app=leetcode id=338 lang=javascript
 *
 * [338] Counting Bits
 *
 * https://leetcode.com/problems/counting-bits/description/
 *
 * algorithms
 * Medium (64.04%)
 * Total Accepted:    [163].1K
 * Total Submissions: 253K
 * Testcase Example:  '2'
 *
 * Given a non negative integer number num. For every numbers i in the range 0
 * ≤ i ≤ num calculate the number of 1's in their binary representation and
 * return them as an array.
 *
 * Example 1:
 *
 *
 * Input: 2
 * Output: [0,1,1]
 *
 * Example 2:
 *
 *
 * Input: 5
 * Output: [0,1,1,2,1,2]
 *
 *
 * Follow up:
 *
 *
 * It is very easy to come up with a solution with run time
 * O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a
 * single pass?
 * Space complexity should be O(n).
 * Can you do it like a boss? Do it without using any builtin function like
 * __builtin_popcount in c++ or in any other language.
 *
 */
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  // tag: bit dp
  // Time complexity: O(n)
  // Space complexity: O(n)
  const res = [];
  res[0] = 0;

  // 10000100110101
  for (let i = 1; i <= num; i++) {
    if ((i & 1) === 0) {
      // 偶数
      // 偶数最后一位是0，因此右移一位对结果没有影响
      res[i] = res[i >> 1];
    } else {
      // 奇数
      // 奇数最后一位是1，i - 1 的 位数 + 1 就是结果
      res[i] = res[i - 1] + 1;
    }
  }

  return res;
};
```

### 344

```js
// Write a function that reverses a string. The input string is given as an array of characters char[].

// Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

// You may assume all the characters consist of printable ascii characters.

const reverseStringAux = (s, n, m) => {
  if (m === n || s.length === 0 || n > m) return s;
  // swap first and last, in place
  const a = s[n];
  const b = s[m];
  s[n] = b;
  s[m] = a;
  reverseStringAux(s, n + 1, m - 1);
  return s;
};

/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
export default function reverseString(s) {
  return reverseStringAux(s, 0, s.length - 1);
}
```

### [344].reverse-string

```js
/*
 * @lc app=leetcode id=344 lang=javascript
 *
 * [344] Reverse String
 *
 * https://leetcode.com/problems/reverse-string/description/
 *
 * algorithms
 * Easy (62.81%)
 * Total Accepted:    [409].9K
 * Total Submissions: [649].5K
 * Testcase Example:  '["h","e","l","l","o"]'
 *
 * Write a function that reverses a string. The input string is given as an
 * array of characters char[].
 *
 * Do not allocate extra space for another array, you must do this by modifying
 * the input array in-place with O(1) extra memory.
 *
 * You may assume all the characters consist of printable ascii
 * characters.
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: ["h","e","l","l","o"]
 * Output: ["o","l","l","e","h"]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: ["H","a","n","n","a","h"]
 * Output: ["h","a","n","n","a","H"]
 *
 *
 *
 *
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  for (let i = 0; i < s.length >> 1; i++) {
    const temp = s[i];
    s[i] = s[s.length - i - 1];
    s[s.length - i - 1] = temp;
  }
};
```

### [344].反转字符串

```js
/*
 * @lc app=leetcode.cn id=344 lang=javascript
 *
 * [344] 反转字符串
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  if (s.length < 2) return s;
  let i = 0,
    j = s.length - 1;
  while (i < j) {
    // es6 结构
    [s[i], s[j]] = [s[j], s[i]];
    i++;
    j--;
  }
  return s;
};

// 原地交换顺序解决
console.log(reverseString(['h', 'e', 'l', 'l', 'o']));
console.log(reverseString(['H', 'a', 'n', 'n', 'a', 'h']));
```

### [345].reverse-vowels-of-a-string

```js
/*
 * @lc app=leetcode id=345 lang=javascript
 *
 * [345] Reverse Vowels of a String
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
  const res = s.split('');

  let start = 0;
  let end = s.length - 1;
  while (start < end) {
    const startVowel = vowels.includes(s[start]);
    const endVowel = vowels.includes(s[end]);
    if (startVowel && endVowel) {
      const temp = res[start];
      res[start] = res[end];
      res[end] = temp;
      start++;
      end--;
    } else if (startVowel) {
      end--;
    } else if (endVowel) {
      start++;
    } else {
      start++;
      end--;
    }
  }

  return res.join('');
};
```

### [345].反转字符串中的元音字母

```js
/*
 * @lc app=leetcode.cn id=345 lang=javascript
 *
 * [345] 反转字符串中的元音字母
 *
 * 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: "hello"
输出: "holle"
示例 2:

输入: "leetcode"
输出: "leotcede"
说明:
元音字母不包含字母"y"。
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const map = {
    a: true,
    e: true,
    i: true,
    o: true,
    u: true,
    A: true,
    E: true,
    I: true,
    O: true,
    U: true,
  };
  s = s.split('');
  let left = 0,
    right = s.length - 1;
  while (left < right) {
    while (!map[s[left]] && left < right) left++;
    while (!map[s[right]] && left < right) right--;
    if (left < right) {
      [s[left], s[right]] = [s[right], s[left]];
      left++;
      right--;
    }
  }
  return s.join('');
};

// console.log(reverseVowels('hello'))
// console.log(reverseVowels('leetcode'))
console.log(reverseVowels('.,'));
```

### [349].Intersection-of-Two-Arrays

```js
/**
 * https://leetcode.com/problems/intersection-of-two-arrays/description/
 * Difficulty:Easy
 *
 * Given two arrays, write a function to compute their intersection.
 * Example:
 * Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].
 * Note:
 * Each element in the result must be unique.
 * The result can be in any order.
 */

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  var ret = [];
  var map1 = nums1.reduce((map, n) => {
    if (!map[n]) map[n] = 1;
    return map;
  }, {});

  var map2 = nums2.reduce((map, n) => {
    if (map1[n] && !map[n]) {
      ret.push(n);
      map[n] = 1;
    }
    return map;
  }, {});

  return ret;
};
console.log(intersection([1, 2, 2, 1], [2, 2]));
```

### 349

```js
// [349]. Intersection of Two Arrays
// Given two arrays, write a function to compute their intersection.

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
export default function intersection(nums1, nums2) {
  const a = new Set(nums1);
  const b = new Set(nums2);
  const inters = [];
  for (const x of a) {
    if (b.has(x)) inters.push(x);
  }
  return inters;
}
```

### [349].两个数组的交集

```js
/*
 * @lc app=leetcode.cn id=349 lang=javascript
 *
 * [349] 两个数组的交集
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  // nums1 = [...new Set(nums1)]
  // nums2 = [...new Set(nums2)]
  if (nums1.length < nums2.length) {
    let temp = nums1;
    nums1 = nums2;
    nums2 = temp;
  }
  const map = {},
    resp = [];
  for (let i = 0; i < nums1.length; i++) {
    if (!map[nums1[i]]) {
      map[nums1[i]] = true;
    }
  }
  for (let i = 0; i < nums2.length; i++) {
    if (map[nums2[i]]) {
      resp.push(nums2[i]);
    }
  }
  return [...new Set(resp)];
};
// console.log(intersection([4, 9, 5], [9, 4, 9, 8, 4]))
// console.log(intersection([1, 2, 2, 1], [2, 2]))
```

### [350].intersection-of-two-arrays-ii

```js
/*
 * @lc app=leetcode id=350 lang=javascript
 *
 * [350] Intersection of Two Arrays II
 *
 * https://leetcode.com/problems/intersection-of-two-arrays-ii/description/
 *
 * algorithms
 * Easy (46.84%)
 * Total Accepted:    [185].1K
 * Total Submissions: [393].7K
 * Testcase Example:  '[1,2,2,1]\n[2,2]'
 *
 * Given two arrays, write a function to compute their intersection.
 *
 * Example 1:
 *
 *
 * Input: nums1 = [1,2,2,1], nums2 = [2,2]
 * Output: [2,2]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
 * Output: [4,9]
 *
 *
 * Note:
 *
 *
 * Each element in the result should appear as many times as it shows in both
 * arrays.
 * The result can be in any order.
 *
 *
 * Follow up:
 *
 *
 * What if the given array is already sorted? How would you optimize your
 * algorithm?
 * What if nums1's size is small compared to nums2's size? Which algorithm is
 * better?
 * What if elements of nums2 are stored on disk, and the memory is limited such
 * that you cannot load all elements into the memory at once?
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
  const res = [];

  for (let i = 0; i < nums1.length; i++) {
    if (nums2.includes(nums1[i])) {
      // 这里我们对两个数组排序，然后二分查找， 时间复杂度nlogn
      nums2[nums2.indexOf(nums1[i])] = null;
      res.push(nums1[i]);
    }
  }

  return res;
};
```

### [367].有效的完全平方数

```js
/*
 * @lc app=leetcode.cn id=367 lang=javascript
 *
 * [367] 有效的完全平方数
 */
/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
  if (num < 2) return true;
  let mid = 0,
    left = 1,
    end = num,
    product = 0;
  while (left <= end) {
    mid = left + ((end - left) >> 1);
    // console.log('mid', mid)
    product = mid * mid;
    if (product === num) return true;
    if (product > num) {
      end = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return false;
};

console.log(isPerfectSquare(16));
console.log(isPerfectSquare(14));
console.log(isPerfectSquare(2));
console.log(isPerfectSquare(4));
console.log(isPerfectSquare(104976));
```

### 371

```js
// Sum of Two Integers
//
// Calculate the sum of two integers a and b, but you are not allowed to use
// the operator + and -
//
// ex. Given a = 1 and b = 2, return [3].
//

type num = number;

export default function SumTimelineMethod(first: num, second: num): num {
  const _first = new Array(Math.abs(first));
  const _second = new Array(Math.abs(second));
  const negatives = [];
  const positives = [];

  while (_first.length !== 0) {
    // first is positive
    if (_first.length > 0 && first > 0 && negatives.length === 0) {
      positives.push('-');
    } else if (first > 0 && negatives.length > 0) {
      negatives.splice(0, 1);
      // first is negative
    } else if (first < 0 && positives.length === 0) {
      negatives.push('-');
    } else if (first < 0 && positives.length > 0) {
      positives.splice(0, 1);
    }
    _first.splice(0, 1);
  }

  while (_second.length !== 0) {
    if (_second.length > 0 && second > 0 && negatives.length === 0) {
      positives.push('-');
    } else if (second > 0 && negatives.length > 0) {
      negatives.splice(0, 1);
      // second is negative
    } else if (second < 0 && positives.length === 0) {
      negatives.push('-');
    } else if (second < 0 && positives.length > 0) {
      positives.splice(0, 1);
    }
    _second.splice(0, 1);
  }

  return positives.length === 0 ? (negatives.length === 0 ? 0 : negatives.length * -1) : positives.length;
}
```

### [375].猜数字大小-ii

```js
/*
 * @lc app=leetcode.cn id=375 lang=javascript
 *
 * [375] 猜数字大小 II
 */
/**
 * @param {number} n
 * @return {number}
 */
var getMoneyAmount = function(n) {
  let resp = 0,
    mid = 0,
    start = 1,
    end = n;

  // 最少多少，也就是每次都需要选择右边的区间
  while (end - start > 1) {
    mid = parseInt((start + end) / 2);
    // console.log('start: ', start)
    // console.log('end: ', end)
    // console.log('mid: ', mid)
    resp += mid;
    start = mid + 1;
  }

  if (end - start === 1) {
    resp += start;
  }

  return resp;
};

console.log(getMoneyAmount(10));
console.log(getMoneyAmount(2)); // 1
console.log(getMoneyAmount(3)); // 2
console.log(getMoneyAmount(4)); // 3 + 1
console.log(getMoneyAmount(5)); // 3 + 4
console.log(getMoneyAmount(6)); // 3 + 5
```

### [383].Ransom-Note

```js
/**
 *
 Each letter in the magazine string can only be used once in your ransom note.

 Note:
 You may assume that both strings contain only lowercase letters.

 canConstruct("a", "b") -> false
 canConstruct("aa", "ab") -> false
 canConstruct("aa", "aab") -> true

 */

/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
  var canUseMap = magazine.split('').reduce((map, ch) => {
    if (!map[ch]) {
      map[ch] = 1;
    } else {
      map[ch] += 1;
    }
    return map;
  }, {});

  var wantUseMap = ransomNote.split('').reduce((map, ch) => {
    if (!map[ch]) {
      map[ch] = 1;
    } else {
      map[ch] += 1;
    }
    return map;
  }, {});

  for (var k in wantUseMap) {
    if (wantUseMap[k] > (canUseMap[k] || 0)) return false;
  }
  return true;
};
```

### [387].First-Unique-Character-in-a-String

```js
/**
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 * Difficulty:Easy
 *
 * Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.
 *
 * Examples:
 * s = "leetcode"
 * return [0].
 * s = "loveleetcode",
 * return [2].
 * Note: You may assume the string contain only lowercase letters.
 *
 */

/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (var i = 0; i < s.length; i++) {
    var ch = s[i];
    if (s.lastIndexOf(ch) === s.indexOf(ch)) return i;
  }
  return -1;
};

console.log(firstUniqChar('leetcode'));
console.log(firstUniqChar('loveleetcode'));
```

### [387].first-unique-character-in-a-string

```js
/*
 * @lc app=leetcode id=387 lang=javascript
 *
 * [387] First Unique Character in a String
 *
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 *
 * algorithms
 * Easy (49.29%)
 * Total Accepted:    [255].6K
 * Total Submissions: [513].8K
 * Testcase Example:  '"leetcode"'
 *
 *
 * Given a string, find the first non-repeating character in it and return it's
 * index. If it doesn't exist, return -1.
 *
 * Examples:
 *
 * s = "leetcode"
 * return [0].
 *
 * s = "loveleetcode",
 * return [2].
 *
 *
 *
 *
 * Note: You may assume the string contain only lowercase letters.
 *
 */
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
};
```

### [392].Is-Subsequence

```js
/**
 * https://leetcode.com/problems/is-subsequence/description/
 * Difficulty:Medium
 *
 * Given a string s and a string t, check if s is subsequence of t.
 * You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).
 * A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).
 *
 * Example 1:
 * s = "abc", t = "ahbgdc"
 * Return true.
 *
 * Example 2:
 * s = "axc", t = "ahbgdc"
 * Return false.
 *
 * Follow up:
 * If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?
 */

/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
  var i = 0;
  var j = 0;
  var m = s.length;
  var n = t.length;
  while (j < n && i < m) {
    if (s[i] === t[j]) {
      i++;
    }
    j++;
  }

  return i === m;
};

console.log(isSubsequence('abc', 'asssbsssc'));
console.log(isSubsequence('abc', 'asssbsss'));
console.log(isSubsequence('', 'asssbsss'));
```

### [392].判断子序列

```js
/*
 * @lc app=leetcode.cn id=392 lang=javascript
 *
 * [392] 判断子序列
 */
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
// 如果s是t的子序列，也就是说s中的所有字符都会按照顺序出现在t中，
// 因此，使用双指针的方式实现:
var isSubsequence = function(s, t) {
  let i = 0,
    j = 0;
  while (s[i] && t[j]) {
    // 如果字符匹配，则两个都加一位，否则的话，母字符串 + 1
    if (s[i] === t[j]) {
      i++;
    }
    j++;
  }
  return i === s.length;
};

console.log(isSubsequence('abc', 'ahbgdc'));
console.log(isSubsequence('axc', 'ahbgdc'));
```

### 315

给定一个整数数组 nums，按要求返回一个新数组 counts，使得数组 counts 有该性质——counts\[i\] 的值是 nums\[i\] 右侧小于 nums\[i\] 的元素的数量。

**示例**

输入：\[5, 2, 6, 1\]

输出：\[2, 1, 1, 0\]

**解释**

5 的右侧有 2 个更小的元素(2 和 1)

2 的右侧仅有 1 个更小的元素(1)

6 的右侧有 1 个更小的元素(1)

1 的右侧有 0 个更小的元素

#### 解题思路

给定一个数组 nums，里面都是一些整数，现在要求打印输出一个新的数组 counts，counts 数组的每个元素 counts\[i\] 表示 nums 中第 i 个元素右边有多少个数小于 nums\[i\]。

例如，输入数组是 \[5, 2, 6, 1\]，应该输出的结果是 \[2, 1, 1, 0\]。

因为，对于 5，右边有两个数比它小，分别是 2 和 1，所以输出的结果中，第一个元素是 2；对于 2，右边只有 1 比它小，所以第二个元素是 1，类推。

如果使用线段树解法，需要理清线段树的每个节点应该需要包含什么样的信息。

线段树每个节点记录的区间是数组下标所形成的区间，然而对于这道题，因为要统计的是比某个数还要小的数的总和，如果把分段的区间设计成按照数值的大小来划分，并记录下在这个区间中的数的总和，就能快速地知道比当前数还要小的数有多少个。

![](http://s0.lgstatic.com/i/image2/M01/90/ED/CgotOV2IStmAJxNFAHcB4XzkqCg286.gif)

1\. 首先，让从线段树的根节点开始，根节点记录的是数组里最小值到最大值之间的所有元素的总和，然后分割根节点成左区间和右区间，不断地分割下去。

2\. 初始化，每个节点记录的在此区间内的元素数量是 0，接下来从数组的最后一位开始往前遍历，每次遍历，判断这个数落在哪个区间，那么那个区间的数量加一。

3\. 遇到 1，把它加入到线段树里，此时线段树里各个节点所统计的数量会发生变化。

4\. 当前所遇到的最小值就是 1。

5. 把 6 加入到线段树里。

6\. 求比 6 小的数有多少个，即查询线段树，从 1 到 5 之间有多少个数。

7\. 从根节点开始查询。由于所要查询的区间是 1 到 5，无法包含根节点的区间 1 到 6，所以继续往下查询。

8\. 左边，区间 1 到 3 被完全包含在 1 到 5 之间，把该节点所统计好的数返回。

9\. 右边，区间 1 到 5 跟区间 4 到 6 有交叉，继续往下看，区间 4 到 5 完全被包含在 1 到 5 之间，所以可以马上返回，并把统计的数量相加。

10\. 最后得出，在当前位置，在 6 的右边比 6 小的数只有一个。

通过这样的方法，每次把当前的数用线段树进行个数统计，然后再计算出比它小的数即可。算法复杂度是 O(nlogm)。

### [301].remove-invalid-parentheses

#### 题目描述

```
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

Example 1:

Input: "()())()"
Output: ["()()()", "(())()"]
Example 2:

Input: "(a)())()"
Output: ["(a)()()", "(a())()"]
Example 3:

Input: ")("
Output: [""]

```

#### 思路

我们的思路是先写一个函数用来判断给定字符串是否是有效的。 然后再写一个函数，这个函数
依次删除第 i 个字符，判断是否有效，有效则添加进最终的返回数组。

这样的话实现的功能就是， 删除`一个` 小括号使之有效的所有可能。因此只需要递归调用`依次删除第i个字符`的功能就可以了。

而且由于题目要求是要删除最少的小括号，因此我们的思路是使用广度优先遍历，而不是深度有限的遍历。

> 没有动图，请脑补

#### 关键点解析

- 广度有限遍历

- 使用队列简化操作

- 使用一个 visited 的 mapper， 来避免遍历同样的字符串

#### 代码

```js
/*
 * @lc app=leetcode id=301 lang=javascript
 *
 * [301] Remove Invalid Parentheses
 *
 * https://leetcode.com/problems/remove-invalid-parentheses/description/
 *
 * algorithms
 * Hard (38.52%)
 * Total Accepted:    114.3K
 * Total Submissions: 295.4K
 * Testcase Example:  '"()())()"'
 *
 * Remove the minimum number of invalid parentheses in order to make the input
 * string valid. Return all possible results.
 *
 * Note: The input string may contain letters other than the parentheses ( and
 * ).
 *
 * Example 1:
 *
 *
 * Input: "()())()"
 * Output: ["()()()", "(())()"]
 *
 *
 * Example 2:
 *
 *
 * Input: "(a)())()"
 * Output: ["(a)()()", "(a())()"]
 *
 *
 * Example 3:
 *
 *
 * Input: ")("
 * Output: [""]
 *
 */
var isValid = function(s) {
  let openParenthes = 0;
  for (let i = 0; i < s.length; i++) {
    if (s[i] === '(') {
      openParenthes++;
    } else if (s[i] === ')') {
      if (openParenthes === 0) return false;
      openParenthes--;
    }
  }
  return openParenthes === 0;
};
/**
 * @param {string} s
 * @return {string[]}
 */
var removeInvalidParentheses = function(s) {
  if (!s || s.length === 0) return [''];
  const ret = [];
  const queue = [s];
  const visited = {};
  let current = null;
  let removedParentheses = 0; // 只记录最小改动

  while ((current = queue.shift())) {
    let hit = isValid(current);
    if (hit) {
      if (!removedParentheses) {
        removedParentheses = s.length - current.length;
      }
      if (s.length - current.length > removedParentheses) return ret.length === 0 ? [''] : ret;
      ret.unshift(current);
      continue;
    }
    for (let i = 0; i < current.length; i++) {
      if (current[i] !== ')' && current[i] !== '(') continue;
      const subString = current.slice(0, i).concat(current.slice(i + 1));
      if (visited[subString]) continue;
      visited[subString] = true;
      queue.push(subString);
    }
  }

  return ret.length === 0 ? [''] : ret;
};
```

#### 扩展

相似问题:

[validParentheses](./validParentheses.md)

### [309].best-time-to-buy-and-sell-stock-with-cooldown

#### 题目描述

```
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:

Input: [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```

#### 思路

这是一道典型的 DP 问题， DP 问题的核心是找到状态和状态转移方程。

这道题目的状态似乎比我们常见的那种 DP 问题要多，这里的状态有 buy sell cooldown 三种，
我们可以用三个数组来表示这这三个状态，buy,sell, cooldown.

- buy[i]表示第 i 天，且以 buy 结尾的最大利润
- sell[i]表示第 i 天，且以 sell 结尾的最大利润
- cooldown[i]表示第 i 天，且以 sell 结尾的最大利润

我们思考一下，其实 cooldown 这个状态数组似乎没有什么用，因此 cooldown 不会对`profit`产生
任何影响。 我们可以进一步缩小为两种状态。

- buy[i] 表示第 i 天，且以 buy 或者 coolwown 结尾的最大利润
- sell[i] 表示第 i 天，且以 sell 或者 cooldown 结尾的最大利润

对应的状态转移方程如下：

> 这个需要花点时间来理解

```
  buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
  sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
```

我们来分析一下，buy[i]对应第 i 的 action 只能是 buy 或者 cooldown。

- 如果是 cooldown，那么 profit 就是 buy[i - 1]
- 如果是 buy，那么就是`前一个卖的profit减去今天买股票花的钱`，即 sell[i -2] - prices[i]

> 注意这里是 i - 2，不是 i-1 ，因为有 cooldown 的限制

sell[i]对应第 i 的 action 只能是 sell 或者 cooldown。

- 如果是 cooldown，那么 profit 就是 sell[i - 1]
- 如果是 sell，那么就是`前一次买的时候获取的利润加上这次卖的钱`，即 buy[i - 1] + prices[i]

#### 关键点解析

- 多状态动态规划

#### 代码

```js
/*
 * @lc app=leetcode id=309 lang=javascript
 *
 * [309] Best Time to Buy and Sell Stock with Cooldown
 *
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
 *
 * algorithms
 * Medium (43.52%)
 * Total Accepted:    88.3K
 * Total Submissions: 201.4K
 * Testcase Example:  '[1,2,3,0,2]'
 *
 * Say you have an array for which the i^th element is the price of a given
 * stock on day i.
 *
 * Design an algorithm to find the maximum profit. You may complete as many
 * transactions as you like (ie, buy one and sell one share of the stock
 * multiple times) with the following restrictions:
 *
 *
 * You may not engage in multiple transactions at the same time (ie, you must
 * sell the stock before you buy again).
 * After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1
 * day)
 *
 *
 * Example:
 *
 *
 * Input: [1,2,3,0,2]
 * Output: 3
 * Explanation: transactions = [buy, sell, cooldown, buy, sell]
 *
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  if (prices == null || prices.length <= 1) return 0;

  // 定义状态变量
  const buy = [];
  const sell = [];
  // 寻常
  buy[0] = -prices[0];
  buy[1] = Math.max(-prices[0], -prices[1]);
  sell[0] = 0;
  sell[1] = Math.max(0, prices[1] - prices[0]);
  for (let i = 2; i < prices.length; i++) {
    // 状态转移方程
    // 第i天只能是买或者cooldown
    // 如果买利润就是sell[i - 2] - prices[i], 注意这里是i - 2，不是 i-1 ，因为有cooldown的限制
    // cooldown就是buy[i -1]
    buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
    // 第i天只能是卖或者cooldown
    // 如果卖利润就是buy[i  -1] + prices[i]
    // cooldown就是sell[i -1]
    sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
  }

  return Math.max(buy[prices.length - 1], sell[prices.length - 1], 0);
};
```

#### 相关题目

- [121.best-time-to-buy-and-sell-stock](./121.best-time-to-buy-and-sell-stock.md)
- [122.best-time-to-buy-and-sell-stock-ii](./122.best-time-to-buy-and-sell-stock-ii.md)

### [322].coin-change

#### 题目描述

```
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
Note:
You may assume that you have an infinite number of each kind of coin.

```

#### 思路

假如我们把 coin 逆序排列，然后逐个取，取到刚好不大于 amout，依次类推。

```
eg: 对于 [1,2,5] 组成 11 块

- 排序[5,2,1]

- 取第一个5, 更新amout 为 11 - 5 = 6 (1⃣️)
      6 > 5 继续更新 为 6 - 5 = 1 (2⃣️)
      1 < 5 退出

- 取第二个2
      1 < 2 退出

- 取最后一个元素，也就是1

      1 === 1 更新为 1 - 1 = 0 (3⃣️)

- amout 为 0 退出


因此结果是 3
```

熟悉贪心算法的同学应该已经注意到了，这就是贪心算法，贪心算法更 amount 尽快地变得更小。
`经验表明，贪心策略是正确的`。 注意，我说的是经验表明， 贪心算法也有可能出错。 就拿这道题目来说，
他也是不正确的！ 比如 `coins = [1, 5, 11] amout = 15`, 因此这种做法有时候不靠谱，我们还是采用靠谱的做法.

如果我们暴力求解，对于所有的组合都计算一遍，然后比较， 那么这样的复杂度是 2 的 n 次方(这个可以通过数学公式证明，这里不想啰嗦了)，
这个是不可以接受的。那么我们是否可以动态规划解决呢？答案是可以，原因就是可以划分为子问题，子问题可以推导出原问题

对于动态规划我们可以先画一个二维表，然后观察，其是否可以用一维表代替。
关于动态规划为什么要画表，我已经在[这篇文章](../thinkings/dynamic-programming.md)解释了

#### 关键点解析

- 动态规划

- 子问题

用 dp[i] 来表示组成 i 块钱，需要最少的硬币数，那么

1. 第 j 个硬币我可以选择不拿 这个时候， 硬币数 = dp[i]

2. 第 j 个硬币我可以选择拿 这个时候， 硬币数 = dp[i - coins[j]] + 1

- 和背包问题不同， 硬币是可以拿任意个

- 对于每一个 dp[i] 我们都选择遍历一遍 coin， 不断更新 dp[i]

#### 代码

```js
/*
 * @lc app=leetcode id=322 lang=javascript
 *
 * [322] Coin Change
 *
 * https://leetcode.com/problems/coin-change/description/
 *
 * algorithms
 * Medium (29.25%)
 * Total Accepted:    175K
 * Total Submissions: 591.9K
 * Testcase Example:  '[1,2,5]\n11'
 *
 * You are given coins of different denominations and a total amount of money
 * amount. Write a function to compute the fewest number of coins that you need
 * to make up that amount. If that amount of money cannot be made up by any
 * combination of the coins, return -1.
 *
 * Example 1:
 *
 *
 * Input: coins = [1, 2, 5], amount = 11
 * Output: 3
 * Explanation: 11 = 5 + 5 + 1
 *
 * Example 2:
 *
 *
 * Input: coins = [2], amount = 3
 * Output: -1
 *
 *
 * Note:
 * You may assume that you have an infinite number of each kind of coin.
 *
 */
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */

var coinChange = function(coins, amount) {
  if (amount === 0) {
    return 0;
  }
  const dp = Array(amount + 1).fill(Number.MAX_VALUE);
  dp[0] = 0;
  for (let i = 1; i < dp.length; i++) {
    for (let j = 0; j < coins.length; j++) {
      if (i - coins[j] >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
      }
    }
  }

  return dp[dp.length - 1] === Number.MAX_VALUE ? -1 : dp[dp.length - 1];
};
```

#### 扩展

这是一道很简单描述的题目， 因此很多时候会被用到大公司的电面中。

相似问题:

[518.coin-change-2](./518.coin-change-2.md)

### [328].odd-even-linked-list

#### 题目描述

```
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:

Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL
Example 2:

Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
Note:

The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...
```

#### 思路

符合直觉的想法是，先遍历一遍找出奇数的节点。然后再遍历一遍找出偶数节点，最后串起来。

但是有两个问题，如果不修改节点的话，需要借助额外的空间，空间复杂度是 N。如果修改的话，会对第二次遍历(遍历偶数节点)造成影响。

因此可以采用一种做法： 遍历一次，每一步同时修改两个节点就好了，这样就可以规避上面两个问题。

#### 关键点解析

- 用虚拟节点来简化操作

- 循环的结束条件设置为 `odd && odd.next && even && even.next`, 不应该是`odd && even`, 否则需要记录一下奇数节点的最后一个节点，复杂了操作

#### 代码

```js
/*
 * @lc app=leetcode id=328 lang=javascript
 *
 * [328] Odd Even Linked List
 *
 * https://leetcode.com/problems/odd-even-linked-list/description/
 *
 * algorithms
 * Medium (48.22%)
 * Total Accepted:    137.6K
 * Total Submissions: 284.2K
 * Testcase Example:  '[1,2,3,4,5]'
 *
 * Given a singly linked list, group all odd nodes together followed by the
 * even nodes. Please note here we are talking about the node number and not
 * the value in the nodes.
 *
 * You should try to do it in place. The program should run in O(1) space
 * complexity and O(nodes) time complexity.
 *
 * Example 1:
 *
 *
 * Input: 1->2->3->4->5->NULL
 * Output: 1->3->5->2->4->NULL
 *
 *
 * Example 2:
 *
 *
 * Input: 2->1->3->5->6->4->7->NULL
 * Output: 2->3->6->7->1->5->4->NULL
 *
 *
 * Note:
 *
 *
 * The relative order inside both the even and odd groups should remain as it
 * was in the input.
 * The first node is considered odd, the second node even and so on ...
 *
 *
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
  if (!head || !head.next) return head;

  const dummyHead1 = {
    next: head,
  };
  const dummyHead2 = {
    next: head.next,
  };

  let odd = dummyHead1.next;
  let even = dummyHead2.next;

  while (odd && odd.next && even && even.next) {
    const oddNext = odd.next.next;
    const evenNext = even.next.next;

    odd.next = oddNext;
    even.next = evenNext;

    odd = oddNext;
    even = evenNext;
  }

  odd.next = dummyHead2.next;

  return dummyHead1.next;
};
```

### [334].increasing-triplet-subsequence

#### 题目描述

```
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

Formally the function should:

Return true if there exists i, j, k
such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false.
Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.

Example 1:

Input: [1,2,3,4,5]
Output: true
Example 2:

Input: [5,4,3,2,1]
Output: false
```

#### 思路

这道题是求解顺序数字是否有三个递增的排列， 注意这里没有要求连续的，因此诸如滑动窗口的思路是不可以的。
题目要求 O(n)的时间复杂度和 O(1)的空间复杂度，因此暴力的做法就不用考虑了。

我们的目标就是`依次`找到三个数字，其顺序是递增的。因此我们的做法可以是依次遍历，
然后维护三个变量，分别记录最小值，第二小值，第三小值。只要我们能够填满这三个变量就返回 true，否则返回 false。

#### 关键点解析

- 维护三个变量，分别记录最小值，第二小值，第三小值。只要我们能够填满这三个变量就返回 true，否则返回 false

#### 代码

```js
/*
 * @lc app=leetcode id=334 lang=javascript
 *
 * [334] Increasing Triplet Subsequence
 *
 * https://leetcode.com/problems/increasing-triplet-subsequence/description/
 *
 * algorithms
 * Medium (39.47%)
 * Total Accepted:    89.6K
 * Total Submissions: 226.6K
 * Testcase Example:  '[1,2,3,4,5]'
 *
 * Given an unsorted array return whether an increasing subsequence of length 3
 * exists or not in the array.
 *
 * Formally the function should:
 *
 * Return true if there exists i, j, k
 * such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return
 * false.
 *
 * Note: Your algorithm should run in O(n) time complexity and O(1) space
 * complexity.
 *
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,4,5]
 * Output: true
 *
 *
 *
 * Example 2:
 *
 *
 * Input: [5,4,3,2,1]
 * Output: false
 *
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
  if (nums.length < 3) return false;
  let n1 = Number.MAX_VALUE;
  let n2 = Number.MAX_VALUE;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] <= n1) {
      n1 = nums[i];
    } else if (nums[i] <= n2) {
      n2 = nums[i];
    } else {
      return true;
    }
  }

  return false;
};
```

### [342].power-of-four

#### 题目描述

```
Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

Example 1:

Input: 16
Output: true
Example 2:

Input: 5
Output: false
Follow up: Could you solve it without loops/recursion?

```

#### 思路

符合直觉的做法是不停除以 4 直到不能整除，然后判断是否为 1 即可。 代码如下：

```js
while (num && num % 4 == 0) {
  num /= 4;
}
return num == 1;
```

但是这道题目有一个 follow up: “你是否可以不使用循环/递归完成”。因此我们需要换种思路。

我们先来看下，4 的幂次方用 2 进制表示是什么样的.

发现规律： 4 的幂次方的二进制表示 1 的位置都是在奇数位(且不在最低位)，其他位置都为 0

我们还可以发现： 2 的幂次方的特点是最低位之外，其他位置有且仅有一个 1(1 可以在任意位置)

我们进一步分析，如果一个数字是四的幂次方，那么只需要满足：

1. 是 2 的幂次方， 就能保证最低位之外，其他位置有且仅有一个 1
2. 这个 1 不在偶数位置，一定在奇数位置

对于第一点，如果保证一个数字是 2 的幂次方呢？ 显然不能不停除以 2，看结果是否等于 1，这样就循环了。
我们可以使用一个 trick， 如果一个数字 n 是 2 的幂次方，那么 n & (n - 1) 一定等于 0，
这个可以作为思考题，大家思考一下。

对于第二点，我们可以取一个特殊数字，这个特殊数字，奇数位置都是 1，偶数位置都是 0，然后和这个特殊数字
`求与`， 如果等于本身，那么毫无疑问，这个 1 不再偶数位置，一定在奇数位置，因为如果在偶数位置，`求与`的结果就是 0 了
题目要求 n 是 32 位有符号整形，那么我们的特殊数字就应该是`01010101010101010101010101010101`(不用数了，一共 32 位)。

如上图，64 和这个特殊数字求与，得到的是本身。 8 是 2 的次方，但是不是 4 的次方，我们求与结果就是 0 了。

为了体现自己的逼格，我们可以使用计算器，来找一个逼格比较高的数字，这里我选了十六进制，结果是`0x55555555`。

代码见下方代码区。

说实话，这种做法不容易想到，其实还有一种方法。
如果一个数字是 4 的幂次方，那么只需要满足：

1. 是二的倍数
2. 减去 1 是三的倍数

代码如下：

```js
return num > 0 && num & (num - 1 === 0) && (num - 1) % 3 === 0;
```

#### 关键点

- 数论
- 2 的幂次方特点(数学性质以及二进制表示)
- 4 的幂次方特点(数学性质以及二进制表示)

#### 代码

```js
/*
 * @lc app=leetcode id=342 lang=javascript
 *
 * [342] Power of Four
 */
/**
 * @param {number} num
 * @return {boolean}
 */
var isPowerOfFour = function(num) {
  // tag: 数论

  if (num === 1) return true;
  if (num < 4) return false;

  if ((num & (num - 1)) !== 0) return false;

  return (num & 0x55555555) === num;
};
```

### [349].intersection-of-two-arrays

#### 题目描述

```
Given two arrays, write a function to compute their intersection.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Note:

Each element in the result must be unique.
The result can be in any order.

```

#### 思路

先遍历第一个数组，将其存到 hashtable 中，
然后遍历第二个数组，如果在 hashtable 中存在就 push 到 return，然后清空 hashtable 即可。

#### 关键点解析

无

#### 代码

```js
/*
 * @lc app=leetcode id=349 lang=javascript
 *
 * [349] Intersection of Two Arrays
 *
 * https://leetcode.com/problems/intersection-of-two-arrays/description/
 *
 * algorithms
 * Easy (53.11%)
 * Total Accepted:    203.6K
 * Total Submissions: 380.9K
 * Testcase Example:  '[1,2,2,1]\n[2,2]'
 *
 * Given two arrays, write a function to compute their intersection.
 *
 * Example 1:
 *
 *
 * Input: nums1 = [1,2,2,1], nums2 = [2,2]
 * Output: [2]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
 * Output: [9,4]
 *
 *
 * Note:
 *
 *
 * Each element in the result must be unique.
 * The result can be in any order.
 *
 *
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  const visited = {};
  const ret = [];
  for (let i = 0; i < nums1.length; i++) {
    const num = nums1[i];

    visited[num] = num;
  }

  for (let i = 0; i < nums2.length; i++) {
    const num = nums2[i];

    if (visited[num] !== undefined) {
      ret.push(num);
      visited[num] = undefined;
    }
  }

  return ret;
};
```

### [365].water-and-jug-problem

#### 题目描述

```
You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.

If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.

Operations allowed:

Fill any of the jugs completely with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.
Example 1: (From the famous "Die Hard" example)

Input: x = 3, y = 5, z = 4
Output: True
Example 2:

Input: x = 2, y = 6, z = 5
Output: False

```

#### 思路

这是一道关于`数论`的题目，确切地说是关于`裴蜀定理`(英语：Bézout's identity)的题目。

摘自 wiki 的定义：

```
对任意两个整数 a、b，设 d是它们的最大公约数。那么关于未知数  x和  y的线性丢番图方程(称为裴蜀等式)：

ax+by=m

有整数解  (x,y) 当且仅当  m是  d的整数倍。裴蜀等式有解时必然有无穷多个解。

```

因此这道题可以完全转化为`裴蜀定理`。

#### 关键点解析

- 数论
- 裴蜀定理

#### 代码

```js
/*
 * @lc app=leetcode id=365 lang=javascript
 *
 * [365] Water and Jug Problem
 *
 * https://leetcode.com/problems/water-and-jug-problem/description/
 *
 * algorithms
 * Medium (28.76%)
 * Total Accepted:    27K
 * Total Submissions: 93.7K
 * Testcase Example:  '3\n5\n4'
 *
 * You are given two jugs with capacities x and y litres. There is an infinite
 * amount of water supply available. You need to determine whether it is
 * possible to measure exactly z litres using these two jugs.
 *
 * If z liters of water is measurable, you must have z liters of water
 * contained within one or both buckets by the end.
 *
 * Operations allowed:
 *
 *
 * Fill any of the jugs completely with water.
 * Empty any of the jugs.
 * Pour water from one jug into another till the other jug is completely full
 * or the first jug itself is empty.
 *
 *
 * Example 1: (From the famous "Die Hard" example)
 *
 *
 * Input: x = 3, y = 5, z = 4
 * Output: True
 *
 *
 * Example 2:
 *
 *
 * Input: x = 2, y = 6, z = 5
 * Output: False
 *
 */
/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {boolean}
 */
var canMeasureWater = function(x, y, z) {
  if (x + y < z) return false;

  if (z === 0) return true;

  if (x === 0) return y === z;

  if (y === 0) return x === z;

  function GCD(a, b) {
    let min = Math.min(a, b);
    while (min) {
      if (a % min === 0 && b % min === 0) return min;
      min--;
    }
    return 1;
  }

  return z % GCD(x, y) === 0;
};
```

### [371].sum-of-two-integers

#### 题目描述

```
Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.

Example 1:

Input: a = 1, b = 2
Output: 3
Example 2:

Input: a = -2, b = 3
Output: 1

```

#### 思路

不能使用加减法来求加法。 我们只能朝着位元算的角度来思考了。

由于`异或`是`相同则位0，不同则位1`，因此我们可以把异或看成是一种不进位的加减法。

由于`与`是`全部位1则位1，否则位0`，因此我们可以求与之后左移一位来表示进位。

然后我们对上述两个元算结果递归求解即可。 递归的结束条件就是其中一个为 0，我们直接返回另一个。

#### 关键点解析

- 位运算
- 异或是一种不进位的加减法
- 求与之后左移一位来可以表示进位

#### 代码

```js
/*
 * @lc app=leetcode id=371 lang=javascript
 *
 * [371] Sum of Two Integers
 */
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var getSum = function(a, b) {
  if (a === 0) return b;

  if (b === 0) return a;

  return getSum(a ^ b, (a & b) << 1);
};
```

### [378].kth-smallest-element-in-a-sorted-matrix

#### 题目描述

```
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
Note:
You may assume k is always valid, 1 ≤ k ≤ n2.
```

#### 思路

显然用大顶堆可以解决，时间复杂度 Klogn n 为总的数字个数,
但是这种做法没有利用题目中 sorted matrix 的特点，因此不是一种好的做法.

一个巧妙的方法是二分法，我们分别从第一个和最后一个向中间进行扫描，并且计算出中间的数值与数组中的进行比较，
可以通过计算中间值在这个数组中排多少位，然后得到比中间值小的或者大的数字有多少个，然后与 k 进行比较，如果比 k 小则说明中间值太小了，则向后移动，否则向前移动。

这个题目的二分确实很难想，我们来一步一步解释。

最普通的二分法是有序数组中查找指定值(或者说满足某个条件的值)。由于是有序的，我们可以根据索引关系来确定大小关系，
因此这种思路比较直接，但是对于这道题目索引大小和数字大小没有直接的关系，因此这种二分思想就行不通了。

(普通的基于索引判断的二分法)

- 我们能够找到矩阵中最大的元素(右下角)和最小的元素(左上角)。我们可以求出值的中间，而不是上面那种普通二分法的索引的中间。

* 找到中间值之后，我们可以拿这个值去计算有多少元素是小于等于它的。
  具体方式就是比较行的最后一列，如果中间值比最后一列大，说明中间元素肯定大于这一行的所有元素。 否则我们从后往前遍历直到不大于。

- 上一步我们会计算一个 count，我们拿这个 count 和 k 进行比较

- 如果 count 小于 k，说明我们选择的中间值太小了，肯定不符合条件，我们需要调整左区间为 mid + 1

- 如果 count 大于 k，说明我们选择的中间值正好或者太大了。我们调整右区间 mid

> 由于 count 大于 k 也可能我们选择的值是正好的， 因此这里不能调整为 mid - 1， 否则可能会得不到结果

- 最后直接返回 start, end, 或者 mid 都可以，因此三者最终会收敛到矩阵中的一个元素，这个元素也正是我们要找的元素。

整个计算过程是这样的：

这里有一个大家普遍都比较疑惑的点，也是我当初非常疑惑，困扰我很久的点， leetcode 评论区也有很多人来问，就是“能够确保最终我们找到的元素一定在矩阵中么？”

答案是可以, `相等的时候一定在matrix里面。 因为原问题一定有解，找下界使得start不断的逼近于真实的元素`.

我是看了评论区一个大神的评论才明白的，以下是[@GabrielaSong](https://leetcode.com/gabrielasong/)的评论原文：

```
The lo we returned is guaranteed to be an element in the matrix is because:
Let us assume element m is the kth smallest number in the matrix, and x is the number of element m in the matrix.
When we are about to reach convergence, if mid=m-1, its count value (the number of elements which are <= mid) would be k-x,
so we would set lo as (m-1)+1=m, in this case the hi will finally reach lo;
and if mid=m+1, its count value would be k+x-1, so we would set hi as m+1, in this case the lo will finally reach m.
To sum up, because the number lo found by binary search find is exactly the element which has k number of elements in the matrix that are <= lo,
 The equal sign guarantees there exists and only exists one number in range satisfying this condition.
 So lo must be the only element satisfying this element in the matrix.

```

更多解释,可以参考[leetcode discuss](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173/Share-my-thoughts-and-Clean-Java-Code)

> 如果是普通的二分查找，我们是基于索引去找，因此不会有这个问题。

#### 关键点解析

- 二分查找

- 有序矩阵的套路(文章末尾还有一道有序矩阵的题目)

- 堆(优先级队列)

#### 代码

```js
/*
 * @lc app=leetcode id=378 lang=javascript
 *
 * [378] Kth Smallest Element in a Sorted Matrix
 */
function notGreaterCount(matrix, target) {
  // 等价于在matrix 中搜索mid，搜索的过程中利用有序的性质记录比mid小的元素个数

  // 我们选择左下角，作为开始元素
  let curRow = 0;
  // 多少列
  const COL_COUNT = matrix[0].length;
  // 最后一列的索引
  const LAST_COL = COL_COUNT - 1;
  let res = 0;

  while (curRow < matrix.length) {
    // 比较最后一列的数据和target的大小
    if (matrix[curRow][LAST_COL] < target) {
      res += COL_COUNT;
    } else {
      let i = COL_COUNT - 1;
      while (i < COL_COUNT && matrix[curRow][i] > target) {
        i--;
      }
      // 注意这里要加1
      res += i + 1;
    }
    curRow++;
  }

  return res;
}
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(matrix, k) {
  if (matrix.length < 1) return null;
  let start = matrix[0][0];
  let end = matrix[matrix.length - 1][matrix[0].length - 1];
  while (start < end) {
    const mid = start + ((end - start) >> 1);
    const count = notGreaterCount(matrix, mid);
    if (count < k) start = mid + 1;
    else end = mid;
  }
  // 返回start,mid, end 都一样
  return start;
};
```

#### 相关题目

- [240.search-a-2-d-matrix-ii](./240.search-a-2-d-matrix-ii.md)

### [300].longest-increasing-subsequence

```js
/*
 * @lc app=leetcode id=300 lang=javascript
 *
 * [300] Longest Increasing Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  // 时间复杂度O(n^2)
  // if (nums.length === 0) return 0;
  //   const dp = Array(nums.length).fill(1);
  //   let max = 1;
  //   for (let i = 0; i < nums.length; i++) {
  //     for (let j = 0; j < i; j++) {
  //       if (nums[i] > nums[j]) {
  //         dp[i] = Math.max(dp[j] + 1, dp[i]);
  //       }
  //       max = Math.max(max, dp[i]);
  //     }
  //   }
  //   return max;
  // [ 10, 9, 2, 5, 3, 7, 101, 18 ]
  // [ 2, 3, 5, 7, 9, 10, 18, 101 ]
  // 参考： https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation
  // const tails = [];
  // for (let i = 0; i < nums.length; i++) {
  //   let left = 0;
  //   let right = tails.length;
  //   while (left < right) {
  //     const mid = left + (right - left) / 2; // 防止溢出
  //     if (tails[mid] < nums[i]) left = mid + 1;
  //     else right = mid;
  //   }
  //   // 说明nums[i] 比如tails中所有数字都大，我们直接push
  //   if (right === tails.length) tails.push(nums[i]);
  //   else tails[right] = nums[i]; // 否则我们修改tails[right]
  // }
  // return tails.length;
};
```

### [307].range-sum-query-mutable

```js
/*
 * @lc app=leetcode id=307 lang=javascript
 *
 * [307] Range Sum Query - Mutable
 */
/**
 * @param {number[]} nums
 */
// var NumArray = function(nums) {
//   this.nums = nums;
// };

// /**
//  * @param {number} i
//  * @param {number} val
//  * @return {void}
//  */
// NumArray.prototype.update = function(i, val) {
//   this.nums[i] = val;
// };

// /**
//  * @param {number} i
//  * @param {number} j
//  * @return {number}
//  */
// NumArray.prototype.sumRange = function(i, j) {
//   let res = 0;
//   for (let k = i; k < j + 1; k++) {
//     res += this.nums[k];
//   }

//   return res;
// };

/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  this.nums = nums;

  // Init array representation of segment tree.
  this.segmentTree = [];

  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;
  this.buildTreeRecursively(l, r, cur);
};

NumArray.prototype.buildTreeRecursively = function(l, r, cur) {
  // If low input index and high input index are equal that would mean
  // the we have finished splitting and we are already came to the leaf
  // of the segment tree. We need to copy this leaf value from input
  // array to segment tree.
  if (l === r) {
    return (this.segmentTree[cur] = this.nums[r]);
  }

  // Split input array on two halves and process them recursively.
  const m = Math.floor((l + r) / 2);
  // Process left half of the input array.
  this.buildTreeRecursively(l, m, this.getLeftChildIndex(cur));
  // Process right half of the input array.
  this.buildTreeRecursively(m + 1, r, this.getRightChildIndex(cur));

  // Once every tree leaf is not empty we're able to build tree bottom up using
  // provided operation function.
  this.segmentTree[cur] = this.operation(
    this.segmentTree[this.getLeftChildIndex(cur)],
    this.segmentTree[this.getRightChildIndex(cur)],
  );
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
  this.nums[i] = val;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;

  return this.rangeQueryRecursive(i, j, l, r, cur);
};

NumArray.prototype.rangeQueryRecursive = function(i, j, l, r, cur) {
  if (i <= l && j >= r) {
    // Total overlap.
    return this.segmentTree[cur];
  }

  if (i > r || j < l) {
    // No overlap.
    return this.operationFallback;
  }

  // Partial overlap.
  const m = Math.floor((l + r) / 2);

  const leftOperationResult = this.rangeQueryRecursive(i, j, l, m, this.getLeftChildIndex(cur));

  const rightOperationResult = this.rangeQueryRecursive(i, j, m + 1, r, this.getRightChildIndex(cur));

  return this.sumRange(leftOperationResult, rightOperationResult);
};

NumArray.prototype.getLeftChildIndex = function(parentIndex) {
  return 2 * parentIndex + 1;
};

NumArray.prototype.getRightChildIndex = function(parentIndex) {
  return 2 * parentIndex + 2;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(i,val)
 * var param_2 = obj.sumRange(i,j)
 */
```

### [315].count-of-smaller-numbers-after-self

```js
/*
 * @lc app=leetcode id=315 lang=javascript
 *
 * [315] Count of Smaller Numbers After Self
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
  // Input: [5,2,6,1]
  // Output: [2,1,1,0]
  // 暴力法：
  //   const res = Array(nums.length).fill(0);
  //   for (let i = 0; i < nums.length - 1; i++) {
  //     for (let j = i; j < nums.length; j++) {
  //       if (nums[i] > nums[j]) {
  //         res[i] += 1;
  //       }
  //     }
  //   }

  //   return res;
  //  归并排序
  const res = Array(nums.length).fill(0);

  function merge(arr, l, m, r, res) {
    let i, j, k;
    const n1 = m - l + 1;
    const n2 = r - m;

    /* create temp arrays */
    const L = Array(n1);
    const R = Array(n2);

    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) L[i] = arr[l + i];
    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
    while (i < n1 && j < n2) {
      if (L[i] <= R[j]) {
        arr[k] = L[i];
        i++;
      } else {
        arr[k] = R[j];
        res[k] += 1;
        j++;
      }
      k++;
    }

    /* Copy the remaining elements of L[], if there
       are any */
    while (i < n1) {
      arr[k] = L[i];
      i++;
      k++;
    }

    /* Copy the remaining elements of R[], if there
       are any */
    while (j < n2) {
      arr[k] = R[j];
      j++;
      k++;
    }
  }
  function mergeSort(arr, l, r, res) {
    if (l < r) {
      const m = l + ((r - l) >> 1);

      mergeSort(arr, l, m, res);
      mergeSort(arr, m + 1, r, res);

      merge(arr, l, m, r, res);
    }
    return res;
  }

  return mergeSort(nums, 0, nums.length - 1, res);
};
```

### [326].power-of-three

```js
/*
 * @lc app=leetcode id=326 lang=javascript
 *
 * [326] Power of Three
 *
 * https://leetcode.com/problems/power-of-three/description/
 *
 * algorithms
 * Easy (41.43%)
 * Total Accepted:    178.8K
 * Total Submissions: 430.4K
 * Testcase Example:  '27'
 *
 * Given an integer, write a function to determine if it is a power of three.
 *
 * Example 1:
 *
 *
 * Input: 27
 * Output: true
 *
 *
 * Example 2:
 *
 *
 * Input: 0
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: 9
 * Output: true
 *
 * Example 4:
 *
 *
 * Input: 45
 * Output: false
 *
 * Follow up:
 * Could you do it without using any loop / recursion?
 */
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  // tag: 数论
  // let i = 0;
  // while(Math.pow(3, i) < n) {
  //     i++;
  // }
  // return Math.pow(3, i) === n;

  // 巧用整除
  return n > 0 && Math.pow(3, 19) % n === 0;
};
// 扩展： 这个方法可以扩展到任意质数，合数则不行
```

### [337].house-robber-iii

```js
/*
 * @lc app=leetcode id=337 lang=javascript
 *
 * [337] House Robber III
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(root) {
  if (root === null) return [0, 0];
  // 0: rob 1: notRob
  const l = helper(root.left);
  const r = helper(root.right);

  const robed = root.val + l[1] + r[1];
  const notRobed = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);

  return [robed, notRobed];
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
  //   if (root === null) return 0;
  //   const notRobed = rob(root.left) + rob(root.right);
  //   const robed =
  //     root.val +
  //     rob(root.left && root.left.left) +
  //     rob(root.left && root.left.right) +
  //     rob(root.right && root.right.left) +
  //     rob(root.right && root.right.right);

  //   return Math.max(notRobed, robed);

  // dp
  const [robed, notRobed] = helper(root);
  return Math.max(robed, notRobed);
};
```

### [338].counting-bits

```js
/*
 * @lc app=leetcode id=338 lang=javascript
 *
 * [338] Counting Bits
 *
 * https://leetcode.com/problems/counting-bits/description/
 *
 * algorithms
 * Medium (64.04%)
 * Total Accepted:    163.1K
 * Total Submissions: 253K
 * Testcase Example:  '2'
 *
 * Given a non negative integer number num. For every numbers i in the range 0
 * ≤ i ≤ num calculate the number of 1's in their binary representation and
 * return them as an array.
 *
 * Example 1:
 *
 *
 * Input: 2
 * Output: [0,1,1]
 *
 * Example 2:
 *
 *
 * Input: 5
 * Output: [0,1,1,2,1,2]
 *
 *
 * Follow up:
 *
 *
 * It is very easy to come up with a solution with run time
 * O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a
 * single pass?
 * Space complexity should be O(n).
 * Can you do it like a boss? Do it without using any builtin function like
 * __builtin_popcount in c++ or in any other language.
 *
 */
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  // tag: bit dp
  // Time complexity: O(n)
  // Space complexity: O(n)
  const res = [];
  res[0] = 0;

  // 10000100110101
  for (let i = 1; i <= num; i++) {
    if ((i & 1) === 0) {
      // 偶数
      // 偶数最后一位是0，因此右移一位对结果没有影响
      res[i] = res[i >> 1];
    } else {
      // 奇数
      // 奇数最后一位是1，i - 1 的 位数 + 1 就是结果
      res[i] = res[i - 1] + 1;
    }
  }

  return res;
};
```

### [344].reverse-string

```js
/*
 * @lc app=leetcode id=344 lang=javascript
 *
 * [344] Reverse String
 *
 * https://leetcode.com/problems/reverse-string/description/
 *
 * algorithms
 * Easy (62.81%)
 * Total Accepted:    409.9K
 * Total Submissions: 649.5K
 * Testcase Example:  '["h","e","l","l","o"]'
 *
 * Write a function that reverses a string. The input string is given as an
 * array of characters char[].
 *
 * Do not allocate extra space for another array, you must do this by modifying
 * the input array in-place with O(1) extra memory.
 *
 * You may assume all the characters consist of printable ascii
 * characters.
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: ["h","e","l","l","o"]
 * Output: ["o","l","l","e","h"]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: ["H","a","n","n","a","h"]
 * Output: ["h","a","n","n","a","H"]
 *
 *
 *
 *
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  for (let i = 0; i < s.length >> 1; i++) {
    const temp = s[i];
    s[i] = s[s.length - i - 1];
    s[s.length - i - 1] = temp;
  }
};
```

### [345].reverse-vowels-of-a-string

```js
/*
 * @lc app=leetcode id=345 lang=javascript
 *
 * [345] Reverse Vowels of a String
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
  const res = s.split('');

  let start = 0;
  let end = s.length - 1;
  while (start < end) {
    const startVowel = vowels.includes(s[start]);
    const endVowel = vowels.includes(s[end]);
    if (startVowel && endVowel) {
      const temp = res[start];
      res[start] = res[end];
      res[end] = temp;
      start++;
      end--;
    } else if (startVowel) {
      end--;
    } else if (endVowel) {
      start++;
    } else {
      start++;
      end--;
    }
  }

  return res.join('');
};
```

### [350].intersection-of-two-arrays-ii

```js
/*
 * @lc app=leetcode id=350 lang=javascript
 *
 * [350] Intersection of Two Arrays II
 *
 * https://leetcode.com/problems/intersection-of-two-arrays-ii/description/
 *
 * algorithms
 * Easy (46.84%)
 * Total Accepted:    185.1K
 * Total Submissions: 393.7K
 * Testcase Example:  '[1,2,2,1]\n[2,2]'
 *
 * Given two arrays, write a function to compute their intersection.
 *
 * Example 1:
 *
 *
 * Input: nums1 = [1,2,2,1], nums2 = [2,2]
 * Output: [2,2]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
 * Output: [4,9]
 *
 *
 * Note:
 *
 *
 * Each element in the result should appear as many times as it shows in both
 * arrays.
 * The result can be in any order.
 *
 *
 * Follow up:
 *
 *
 * What if the given array is already sorted? How would you optimize your
 * algorithm?
 * What if nums1's size is small compared to nums2's size? Which algorithm is
 * better?
 * What if elements of nums2 are stored on disk, and the memory is limited such
 * that you cannot load all elements into the memory at once?
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
  const res = [];

  for (let i = 0; i < nums1.length; i++) {
    if (nums2.includes(nums1[i])) {
      // 这里我们对两个数组排序，然后二分查找， 时间复杂度nlogn
      nums2[nums2.indexOf(nums1[i])] = null;
      res.push(nums1[i]);
    }
  }

  return res;
};
```

### [387].first-unique-character-in-a-string

```js
/*
 * @lc app=leetcode id=387 lang=javascript
 *
 * [387] First Unique Character in a String
 *
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 *
 * algorithms
 * Easy (49.29%)
 * Total Accepted:    255.6K
 * Total Submissions: 513.8K
 * Testcase Example:  '"leetcode"'
 *
 *
 * Given a string, find the first non-repeating character in it and return it's
 * index. If it doesn't exist, return -1.
 *
 * Examples:
 *
 * s = "leetcode"
 * return 0.
 *
 * s = "loveleetcode",
 * return 2.
 *
 *
 *
 *
 * Note: You may assume the string contain only lowercase letters.
 *
 */
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
};
```
