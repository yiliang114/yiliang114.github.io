---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### 718-Maximum-Length-of-Repeated-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/
 * Difficulty:Medium
 *
 * Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
 *
 * Example 1:
 * Input:
 * A: [1, 2, 3, 2, 1]
 * B: [3, 2, 1, 4, 7, 8]
 * Output: 3
 * Explanation:
 * The repeated subarray with maximum length is [3, 2, 1].
 *
 * Note:
 * 1 <= len(A), len(B) <= 1000
 * 0 <= A[i], B[i] < 100
 *
 */

/**
 * 解题思路
 *
 * 动态规划
 *
 * dp[i][j] 以 A[i-1] B[j-1] 结尾的最长子串长度
 * dp[i][j] = A[i - 1] === B[j - 1] ? dp[i - 1][j - 1] + 1 : 0;
 *
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
  var m = A.length;
  var n = B.length;
  if (m * n === 0) return 0;
  var dp = [];
  var max = 0;
  for (var i = 0; i <= m; i++) {
    dp.push(new Array(n + 1).fill(0));
  }

  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      dp[i][j] = A[i - 1] === B[j - 1] ? dp[i - 1][j - 1] + 1 : 0;
      max = Math.max(max, dp[i][j]);
    }
  }
  // console.log(dp);

  return max;
};

console.log(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7, 8]));
```

### 728-Self-Dividing-Numbers

```js
/**
 * https://leetcode.com/problems/self-dividing-numbers/description/
 * Difficulty:Easy
 *
 * A self-dividing number is a number that is divisible by every digit it contains.
 *
 * For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
 * Also, a self-dividing number is not allowed to contain the digit zero.
 * Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.
 *
 * Example 1:
 * Input:
 * left = 1, right = 22
 * Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
 * Note:
 * The boundaries of each input argument are 1 <= left <= right <= 10000.
 */

/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function(left, right) {
  var res = [];
  for (var i = left; i <= right; i++) {
    if (isSelfDividingNumber(i)) res.push(i);
  }
  return res;
};

function isSelfDividingNumber(n) {
  var t = n;
  if (!t) return false;
  while (t) {
    var r = t % 10;
    t = Math.floor(t / 10);
    if (!r) return false;
    if (n % r) return false;
  }
  return true;
}

console.log(selfDividingNumbers(1, 22));
```

### 744.寻找比目标字母大的最小字母

```js
/*
 * @lc app=leetcode.cn id=744 lang=javascript
 *
 * [744] 寻找比目标字母大的最小字母
 * 给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。

数组里字母的顺序是循环的。举个例子，如果目标字母target = 'z' 并且有序数组为 letters = ['a', 'b']，则答案返回 'a'。

示例:

输入:
letters = ["c", "f", "j"]
target = "a"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "c"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "d"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "g"
输出: "j"

输入:
letters = ["c", "f", "j"]
target = "j"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "k"
输出: "c"
注:

letters长度范围在[2, 10000]区间内。
letters 仅由小写字母组成，最少包含两个不同的字母。
目标字母target 是一个小写字母。
 */
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
// 二分查找
var nextGreatestLetter = function(letters, target) {
  const n = letters.length;
  let l = 0,
    r = n - 1,
    mid,
    resp;
  while (l <= r) {
    mid = (l + r) >> 1;
    if (letters[mid] === target) {
      // 命中继续取下一个，避免重复的数据
      l = mid + 1;
    } else if (letters[mid] > target) {
      r = mid - 1;
    } else {
      l = mid + 1;
    }
  }
  // 二分查找最终结束，必定是 l === r + 1
  return l < n ? letters[l] : letters[0];
};

// console.log(nextGreatestLetter(["e", "e", "e", "e", "e", "e", "n", "n", "n", "n"], 'e'))
// console.log(nextGreatestLetter([2, 3, 4], 5))
// console.log(nextGreatestLetter([1, 3, 4], 1))
```

### 766

```js
// 766. Toeplitz Matrix

// A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.

// Now given an M x N matrix, return True if and only if the matrix is Toeplitz.

// Example 1:

// Input:
// matrix = [
//   [1,2,3,4],
//   [5,1,2,3],
//   [9,5,1,2]
// ]
// Output: True
// Explanation:
// In the above grid, the diagonals are:
// "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
// In each diagonal all elements are the same, so the answer is True.
// Example 2:

// Input:
// matrix = [
//   [1,2],
//   [2,2]
// ]
// Output: False
// Explanation:
// The diagonal "[1, 2]" has different elements.

// Note:

// matrix will be a 2D array of integers.
// matrix will have a number of rows and columns in range [1, 20].
// matrix[i][j] will be integers in range [0, 99].

// Follow up:

// What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?
// What if the matrix is so large that you can only load up a partial row into the memory at once?

// Time: O(n*m)
// Space: O(1)

function checkDiag(arr, i, j, c, r, v) {
  for (; c < j && r < i; c++, r++) {
    if (arr[r][c] !== v) return false;
  }
  return true;
}

export default function isToeplitzMatrix(arr) {
  if (!arr.length) return true;
  const i = arr.length;
  const j = arr[0].length;
  for (let c = 0; c < arr[0].length; c++) {
    if (!checkDiag(arr, i, j, c, 0, arr[0][c])) return false;
  }
  for (let r = 0; r < arr.length; r++) {
    if (!checkDiag(arr, i, j, 0, r, arr[r][0])) return false;
  }
  return true;
}
```

### 796.旋转字符串

```js
/*
 * @lc app=leetcode.cn id=796 lang=javascript
 *
 * [796] 旋转字符串
 */
/**
 * @param {string} A
 * @param {string} B
 * @return {boolean}
 */
var rotateString = function(A, B) {
  // let offset =
  for (let i = 0; i < A.length; i++) {
    const index = B.indexOf(A[i]);
    if (index === -1) return false;
  }
};

// 1. 找到最长公共子串 如果没有，false
// 2. 截取剩余部分，是否相等
```
