---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### [718].Maximum-Length-of-Repeated-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/
 * Difficulty:Medium
 *
 * Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
 *
 * Example 1:
 * Input:
 * A: [1, 2, 3, 2, 1]
 * B: [3, 2, 1, 4, 7, 8]
 * Output: 3
 * Explanation:
 * The repeated subarray with maximum length is [3, 2, 1].
 *
 * Note:
 * 1 <= len(A), len(B) <= 1000
 * 0 <= A[i], B[i] < 100
 *
 */

/**
 * 解题思路
 *
 * 动态规划
 *
 * dp[i][j] 以 A[i-1] B[j-1] 结尾的最长子串长度
 * dp[i][j] = A[i - 1] === B[j - 1] ? dp[i - 1][j - 1] + 1 : 0;
 *
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
  var m = A.length;
  var n = B.length;
  if (m * n === 0) return 0;
  var dp = [];
  var max = 0;
  for (var i = 0; i <= m; i++) {
    dp.push(new Array(n + 1).fill(0));
  }

  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      dp[i][j] = A[i - 1] === B[j - 1] ? dp[i - 1][j - 1] + 1 : 0;
      max = Math.max(max, dp[i][j]);
    }
  }
  // console.log(dp);

  return max;
};

console.log(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7, 8]));
```

### [728].Self-Dividing-Numbers

```js
/**
 * https://leetcode.com/problems/self-dividing-numbers/description/
 * Difficulty:Easy
 *
 * A self-dividing number is a number that is divisible by every digit it contains.
 *
 * For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == [0].
 * Also, a self-dividing number is not allowed to contain the digit zero.
 * Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.
 *
 * Example 1:
 * Input:
 * left = 1, right = 22
 * Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
 * Note:
 * The boundaries of each input argument are 1 <= left <= right <= [10000].
 */

/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function(left, right) {
  var res = [];
  for (var i = left; i <= right; i++) {
    if (isSelfDividingNumber(i)) res.push(i);
  }
  return res;
};

function isSelfDividingNumber(n) {
  var t = n;
  if (!t) return false;
  while (t) {
    var r = t % 10;
    t = Math.floor(t / 10);
    if (!r) return false;
    if (n % r) return false;
  }
  return true;
}

console.log(selfDividingNumbers(1, 22));
```

### [744].寻找比目标字母大的最小字母

```js
/*
 * @lc app=leetcode.cn id=744 lang=javascript
 *
 * [744] 寻找比目标字母大的最小字母
 * 给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。

数组里字母的顺序是循环的。举个例子，如果目标字母target = 'z' 并且有序数组为 letters = ['a', 'b']，则答案返回 'a'。

示例:

输入:
letters = ["c", "f", "j"]
target = "a"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "c"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "d"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "g"
输出: "j"

输入:
letters = ["c", "f", "j"]
target = "j"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "k"
输出: "c"
注:

letters长度范围在[2, 10000]区间内。
letters 仅由小写字母组成，最少包含两个不同的字母。
目标字母target 是一个小写字母。
 */
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
// 二分查找
var nextGreatestLetter = function(letters, target) {
  const n = letters.length;
  let l = 0,
    r = n - 1,
    mid,
    resp;
  while (l <= r) {
    mid = (l + r) >> 1;
    if (letters[mid] === target) {
      // 命中继续取下一个，避免重复的数据
      l = mid + 1;
    } else if (letters[mid] > target) {
      r = mid - 1;
    } else {
      l = mid + 1;
    }
  }
  // 二分查找最终结束，必定是 l === r + 1
  return l < n ? letters[l] : letters[0];
};

// console.log(nextGreatestLetter(["e", "e", "e", "e", "e", "e", "n", "n", "n", "n"], 'e'))
// console.log(nextGreatestLetter([2, 3, 4], 5))
// console.log(nextGreatestLetter([1, 3, 4], 1))
```

### 766

```js
// [766]. Toeplitz Matrix

// A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.

// Now given an M x N matrix, return True if and only if the matrix is Toeplitz.

// Example 1:

// Input:
// matrix = [
//   [1,2,3,4],
//   [5,1,2,3],
//   [9,5,1,2]
// ]
// Output: True
// Explanation:
// In the above grid, the diagonals are:
// "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
// In each diagonal all elements are the same, so the answer is True.
// Example 2:

// Input:
// matrix = [
//   [1,2],
//   [2,2]
// ]
// Output: False
// Explanation:
// The diagonal "[1, 2]" has different elements.

// Note:

// matrix will be a 2D array of integers.
// matrix will have a number of rows and columns in range [1, 20].
// matrix[i][j] will be integers in range [0, 99].

// Follow up:

// What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?
// What if the matrix is so large that you can only load up a partial row into the memory at once?

// Time: O(n*m)
// Space: O(1)

function checkDiag(arr, i, j, c, r, v) {
  for (; c < j && r < i; c++, r++) {
    if (arr[r][c] !== v) return false;
  }
  return true;
}

export default function isToeplitzMatrix(arr) {
  if (!arr.length) return true;
  const i = arr.length;
  const j = arr[0].length;
  for (let c = 0; c < arr[0].length; c++) {
    if (!checkDiag(arr, i, j, c, 0, arr[0][c])) return false;
  }
  for (let r = 0; r < arr.length; r++) {
    if (!checkDiag(arr, i, j, 0, r, arr[r][0])) return false;
  }
  return true;
}
```

### [771].jewels-and-stones 宝石与石头

给定字符串 J  代表石头中宝石的类型，和字符串  S 代表你拥有的石头。 S  中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J  中的字母不重复，J  和  S 中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

示例 1:

输入: J = "aA", S = "aAAbbbb"
输出: 3
示例 2:

输入: J = "z", S = "ZZ"
输出: 0
注意:

S  和  J  最多含有 50 个字母。
 J  中的字符不重复。

#### 正则匹配

时间复杂度比较高，具体复杂度取决于内部回溯的时机。

思路：正则把石头里的宝石 replace 掉，长度相减，就是结果

代码：

```js
let newS = S;
for (let i = 0; i < J.length; i++) {
  newS = newS.replace(new RegExp(J[i], 'g'), '');
}
return S.length - newS.length;
```

#### Hash Table

使用 hash table， 空间换时间的方式。

代码：

```js
const set = {};
let res = 0;

for (let i = 0; i < J.length; i++) {
  set[J[i]] = true;
}

for (let i = 0; i < S.length; i++) {
  if (set[S[i]]) {
    res++;
  }
}
return res;
```

#### JS 一行代码

```js
return S.split('').filter(c => J.indexOf(c) !== -1).length;
```

```js
var numJewelsInStones = function(J, S) {
  let num = 0;
  for (let i = 0; i < S.length; i++) {
    if (J.includes(S[i])) {
      num++;
    }
  }
  return num;
};
```

### [796].旋转字符串

```js
/*
 * @lc app=leetcode.cn id=796 lang=javascript
 *
 * [796] 旋转字符串
 */
/**
 * @param {string} A
 * @param {string} B
 * @return {boolean}
 */
var rotateString = function(A, B) {
  // let offset =
  for (let i = 0; i < A.length; i++) {
    const index = B.indexOf(A[i]);
    if (index === -1) return false;
  }
};

// [1]. 找到最长公共子串 如果没有，false
// [2]. 截取剩余部分，是否相等
```

### [739].daily-temperatures

```js
/*
 * @lc app=leetcode id=739 lang=javascript
 *
 * [739] Daily Temperatures
 */
/**
 * @param {number[]} T
 * @return {number[]}
 */
var dailyTemperatures = function(T) {
  // // 暴力  时间复杂度O(n^2), 空间复杂度O(1)
  // const res = [];
  // for(let i = 0; i < T.length; i++) {
  //     res[i] = 0;
  //     for(let j = i; j < T.length; j++) {
  //         if (T[j] > T[i]) {
  //             res[i] = j - i;
  //             break;
  //         }
  //     }
  // }

  // return res;

  // 递增栈/递减栈
  // 这里我们需要用到递减栈
  // 时间复杂度O(n), 空间复杂度O(n)
  // 典型的空间换时间
  const stack = [];
  const res = [];

  for (let i = 0; i < T.length; i++) {
    res[i] = 0;
    while (stack.length !== 0 && T[i] > T[stack[stack.length - 1]]) {
      const peek = stack.pop();
      res[peek] = i - peek;
    }
    stack.push(i);
  }

  return res;
};
```

### [744].find-smallest-letter-greater-than-target

```js
/*
 * @lc app=leetcode id=744 lang=javascript
 *
 * [744] Find Smallest Letter Greater Than Target
 */
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
  let start = 0;
  let end = letters.length - 1;

  while (start < end) {
    const mid = start + ((end - start) >> 1);
    if (letters[mid] <= target) {
      start = mid + 1;
    } else {
      end = mid;
    }
  }
  // 题目要求找不到的时候，就返回第一个元素(好诡异啊)
  return letters[end] > target ? letters[end] : letters[0];
};
```

### [739].Daily Temperatures

#### 信息卡片

- 题目链接：https://leetcode.com/problems/daily-temperatures/
- tag：`Array` `Stack`

#### 题目描述

```
Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.

For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].

Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].
```

#### 参考答案

暴力，双层 for 循环。`效率很低`

1. 外层是‘当天’T[i]，内层是‘当天’之后 T[j]；
2. 多少天之后比‘当天’温度高就是 j-i；

时间复杂度 O(n^2), 空间复杂度 O(1)

参考 JavaScript 代码：

```js
/**
 * @param {number[]} T
 * @return {number[]}
 * 双层for循环
 */
var dailyTemperatures = function(T) {
  let result = [];
  for (let i = 0; i < T.length; i++) {
    result[i] = 0;
    for (let j = i + 1; j < T.length; j++) {
      if (T[i] < T[j]) {
        result[i] = j - i;
        break;
      }
    }
  }
  return result;
};
```

使用栈,单调递减栈

1. for 循环遍历数组，栈存 T 的下标 i，返回结果数组 result；
2. 拿栈顶元素 peek 与 i 比较，T[peek] >= T[i]则将 i 入栈，T[peek] < T[i]则栈顶值(原数组下标)位置的天数就是 result[peek] = i - peek；
3. 栈顶元素出栈；
4. 重复 2，3 两步；

时间复杂度 O(n), 空间复杂度 O(n)

参考 JavaScript 代码：

```js
/**
 * @param {number[]} T
 * @return {number[]}
 * 递减栈；
 */
var dailyTemperatures = function(T) {
  let stack = [];
  let result = [];
  for (let i = 0; i < T.length; i++) {
    result[i] = 0;
    while (stack.length > 0 && T[stack[stack.length - 1]] < T[i]) {
      let peek = stack.pop();
      result[peek] = i - peek;
    }
    stack.push(i);
  }
  return result;
};
```

### [744]. find smallest letter greater than target

#### 信息卡片

- 题目链接：https://leetcode.com/problems/find-smallest-letter-greater-than-target/
- tag：`Array`

#### 题目描述

```
Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.

Letters also wrap around. For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.

Examples:
    Input:
    letters = ["c", "f", "j"]
    target = "a"
    Output: "c"

    Input:
    letters = ["c", "f", "j"]
    target = "c"
    Output: "f"

    Input:
    letters = ["c", "f", "j"]
    target = "d"
    Output: "f"

    Input:
    letters = ["c", "f", "j"]
    target = "g"
    Output: "j"

    Input:
    letters = ["c", "f", "j"]
    target = "j"
    Output: "c"

    Input:
    letters = ["c", "f", "j"]
    target = "k"
    Output: "c"
Note:
    letters has a length in range [2, 10000].
    letters consists of lowercase letters, and contains at least 2 unique letters.
    target is a lowercase letter.
```

#### 思路

二分查找，提高速度
要求是查找某一个元素，又是在有序的集合中。
所以我们可以用二分查找

1. 排除两种情况；target 小于首元素|| target 大于等于尾元素 => 目标都是首元素
2. 当 target>=letters[mid] 时(我们要的值一定在右边)，调整左区间 min = mid+1;
3. 当 target< letters[mid] 时，调整右区间 max = mid-1;
4. 循环终止条件是 min > max; 最终返回 min 位置元素

#### 建议

在 leetcode 上找一个数组稍微长一点的测试用例，在纸上画出整个过程；对理解很有帮助

#### 参考答案

```js
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
  const length = letters.length;
  let min = 0;
  let max = length - 1;
  if (target >= letters[length - 1] || target < letters[0]) return letters[0];
  while (min <= max) {
    const mid = (max + min) >> 1;
    if (target >= letters[mid]) {
      min = mid + 1;
    } else {
      max = mid - 1;
    }
  }
  return letters[min];
};
```

####### Big Countries

- 题目链接：https://leetcode.com/problems/big-countries/
- tag：`sql`

##### 题目描述

```
There is a table World

+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.

Write a SQL solution to output big countries' name, population and area.

For example, according to the above table, we should output:

+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
```

##### 参考答案

最基本的 sql 语句，没什么好讲的。 如果不会的话，说明对基础语法不熟。

参考代码：

```sql
select name, population, area from World where area > 3000000 or population > 25000000

```
