---
layout: CustomPages
title: æ¯æ—¥ä¸€é¢˜
date: 2020-11-21
aside: false
draft: true
---

### [104].maximum-depth-of-binary-tree

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/maximum-depth-of-binary-tree/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.

```

#### æ€è·¯

ç”±äºæ ‘æ˜¯ä¸€ç§é€’å½’çš„æ•°æ®ç»“æ„ï¼Œå› æ­¤ç”¨é€’å½’å»è§£å†³çš„æ—¶å€™å¾€å¾€éå¸¸å®¹æ˜“ï¼Œè¿™é“é¢˜æ°å·§ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œ
ç”¨é€’å½’å®ç°çš„ä»£ç å¦‚ä¸‹ï¼š

```js
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

å¦‚æœä½¿ç”¨è¿­ä»£å‘¢ï¼Ÿ æˆ‘ä»¬é¦–å…ˆåº”è¯¥æƒ³åˆ°çš„æ˜¯æ ‘çš„å„ç§éå†ï¼Œç”±äºæˆ‘ä»¬æ±‚çš„æ˜¯æ·±åº¦ï¼Œå› æ­¤
ä½¿ç”¨å±‚æ¬¡éå†(BFS)æ˜¯éå¸¸åˆé€‚çš„ã€‚ æˆ‘ä»¬åªéœ€è¦è®°å½•æœ‰å¤šå°‘å±‚å³å¯ã€‚ç›¸å…³æ€è·¯è¯·æŸ¥çœ‹[binary-tree-traversal](../thinkings/binary-tree-traversal.md)

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚ï¼Œæˆ–è€…åœ¨å¯¹æ¯å±‚è¿›è¡Œè¿­ä»£ä¹‹å‰ä¿å­˜å½“å‰é˜Ÿåˆ—å…ƒç´ çš„ä¸ªæ•°(å³å½“å‰å±‚æ‰€å«å…ƒç´ ä¸ªæ•°)

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=104 lang=javascript
 *
 * [104] Maximum Depth of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;

  // å±‚æ¬¡éå† BFS
  let cur = root;
  const queue = [root, null];
  let depth = 1;

  while ((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      // æ³¨æ„âš ï¸ï¼š ä¸å¤„ç†ä¼šæ— é™å¾ªç¯ï¼Œè¿›è€Œå †æ ˆæº¢å‡º
      if (queue.length === 0) return depth;
      depth++;
      queue.push(null);
      continue;
    }
    const l = cur.left;
    const r = cur.right;

    if (l) queue.push(l);
    if (r) queue.push(r);
  }

  return depth;
};
```

C++ Code:

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        auto q = vector<TreeNode*>();
        auto d = 0;
        q.push_back(root);
        while (!q.empty())
        {
            ++d;
            auto sz = q.size();
            for (auto i = 0; i < sz; ++i)
            {
                auto t = q.front();
                q.erase(q.begin());
                if (t->left != nullptr) q.push_back(t->left);
                if (t->right != nullptr) q.push_back(t->right);
            }
        }
        return d;
    }
};
```

#### ç›¸å…³é¢˜ç›®

- [102.binary-tree-level-order-traversal](./102.binary-tree-level-order-traversal.md)
- [103.binary-tree-zigzag-level-order-traversal](./103.binary-tree-zigzag-level-order-traversal.md)

### [11].container-with-most-water

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/container-with-most-water/description/

#### é¢˜ç›®æè¿°

```
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.
```

![11.container-with-most-water-question](../assets/problems/11.container-with-most-water-question.jpg)

```

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.



Example:

Input: [1,8,6,2,5,4,8,3,7]
Output: 49
```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„è§£æ³•æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä¸¤ä¸¤è¿›è¡Œæ±‚è§£ï¼Œè®¡ç®—å¯ä»¥æ‰¿è½½çš„æ°´é‡ã€‚ ç„¶åä¸æ–­æ›´æ–°æœ€å¤§å€¼ï¼Œæœ€åè¿”å›æœ€å¤§å€¼å³å¯ã€‚
è¿™ç§è§£æ³•ï¼Œéœ€è¦ä¸¤å±‚å¾ªç¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2)

eg:

```js
// è¿™ä¸ªè§£æ³•æ¯”è¾ƒæš´åŠ›ï¼Œæ•ˆç‡æ¯”è¾ƒä½
// æ—¶é—´å¤æ‚åº¦æ˜¯O(n^2)
let max = 0;
for (let i = 0; i < height.length; i++) {
  for (let j = i + 1; j < height.length; j++) {
    const currentArea = Math.abs(i - j) * Math.min(height[i], height[j]);
    if (currentArea > max) {
      max = currentArea;
    }
  }
}
return max;
```

> è¿™ç§ç¬¦åˆç›´è§‰çš„è§£æ³•æœ‰ç‚¹åƒå†’æ³¡æ’åºï¼Œ å¤§å®¶å¯ä»¥ç¨å¾®ç±»æ¯”ä¸€ä¸‹

é‚£ä¹ˆæœ‰æ²¡æœ‰æ›´åŠ ä¼˜çš„è§£æ³•å‘¢ï¼Ÿæˆ‘ä»¬æ¥æ¢ä¸ªè§’åº¦æ¥æ€è€ƒè¿™ä¸ªé—®é¢˜ï¼Œä¸Šè¿°çš„è§£æ³•æ˜¯é€šè¿‡ä¸¤ä¸¤ç»„åˆï¼Œè¿™æ— ç–‘æ˜¯å®Œå¤‡çš„ï¼Œ
é‚£æˆ‘é—¨æ˜¯å¦å¯ä»¥å…ˆè®¡ç®—é•¿åº¦ä¸º n çš„é¢ç§¯ï¼Œç„¶åè®¡ç®—é•¿åº¦ä¸º n-1 çš„é¢ç§¯ï¼Œ... è®¡ç®—é•¿åº¦ä¸º 1 çš„é¢ç§¯ã€‚ è¿™æ ·å»ä¸æ–­æ›´æ–°æœ€å¤§å€¼å‘¢ï¼Ÿ
å¾ˆæ˜¾ç„¶è¿™ç§è§£æ³•ä¹Ÿæ˜¯å®Œå¤‡çš„ï¼Œä½†æ˜¯ä¼¼ä¹æ—¶é—´å¤æ‚åº¦è¿˜æ˜¯ O(n ^ 2), ä¸è¦ç€æ€¥ã€‚

è€ƒè™‘ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘ä»¬è®¡ç®— n-1 é•¿åº¦çš„é¢ç§¯çš„æ—¶å€™,æ˜¯ç›´æ¥ç›´æ¥æ’é™¤ä¸€åŠçš„ç»“æœçš„ã€‚

å¦‚å›¾ï¼š

![11.container-with-most-water](../assets/problems/11.container-with-most-water.png)

æ¯”å¦‚æˆ‘ä»¬è®¡ç®— n é¢ç§¯çš„æ—¶å€™ï¼Œå‡å¦‚å·¦ä¾§çš„çº¿æ®µé«˜åº¦æ¯”å³ä¾§çš„é«˜åº¦ä½ï¼Œé‚£ä¹ˆæˆ‘ä»¬é€šè¿‡å·¦ç§»å³æŒ‡é’ˆæ¥å°†é•¿åº¦ç¼©çŸ­ä¸º n-1 çš„åšæ³•æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œ
å› ä¸º`æ–°çš„å½¢æˆçš„é¢ç§¯å˜æˆäº†(n-1) * heightOfLeft è¿™ä¸ªé¢ç§¯ä¸€å®šæ¯”åˆšæ‰çš„é•¿åº¦ä¸ºnçš„é¢ç§¯nn * heightOfLeft å°`

ä¹Ÿå°±æ˜¯è¯´æœ€å¤§é¢ç§¯`ä¸€å®šæ˜¯å½“å‰çš„é¢ç§¯æˆ–è€…é€šè¿‡ç§»åŠ¨çŸ­çš„çº¿æ®µå¾—åˆ°`ã€‚

#### å…³é”®ç‚¹è§£æ

- åŒæŒ‡é’ˆä¼˜åŒ–æ—¶é—´å¤æ‚åº¦

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=11 lang=javascript
 *
 * [11] Container With Most Water
 *
 * https://leetcode.com/problems/container-with-most-water/description/
 *
 * algorithms
 * Medium (42.86%)
 * Total Accepted:    344.3K
 * Total Submissions: 790.1K
 * Testcase Example:  '[1,8,6,2,5,4,8,3,7]'
 *
 * Given n non-negative integers a1, a2, ..., anÂ , where each represents a
 * point at coordinate (i, ai). n vertical lines are drawn such that the two
 * endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together
 * with x-axis forms a container, such that the container contains the most
 * water.
 *
 * Note:Â You may not slant the container and n is at least 2.
 *
 *
 *
 *
 *
 * The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In
 * this case, the max area of water (blue section) the container can containÂ is
 * 49.
 *
 *
 *
 * Example:
 *
 *
 * Input: [1,8,6,2,5,4,8,3,7]
 * Output: 49
 *
 */
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  if (!height || height.length <= 1) return 0;

  // åŒæŒ‡é’ˆæ¥è¿›è¡Œä¼˜åŒ–
  // æ—¶é—´å¤æ‚åº¦æ˜¯O(n)
  let leftPos = 0;
  let rightPos = height.length - 1;
  let max = 0;
  while (leftPos < rightPos) {
    const currentArea = Math.abs(leftPos - rightPos) * Math.min(height[leftPos], height[rightPos]);
    if (currentArea > max) {
      max = currentArea;
    }
    // æ›´æ–°å°çš„
    if (height[leftPos] < height[rightPos]) {
      leftPos++;
    } else {
      // å¦‚æœç›¸ç­‰å°±éšä¾¿äº†
      rightPos--;
    }
  }

  return max;
};
```

C++ Code:

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        auto ret = 0ul, leftPos = 0ul, rightPos = height.size() - 1;
        while( leftPos < rightPos)
        {
            ret = std::max(ret, std::min(height[leftPos], height[rightPos]) * (rightPos - leftPos));
            if (height[leftPos] < height[rightPos]) ++leftPos;
            else --rightPos;
        }
        return ret;
    }
};
```

### [121].best-time-to-buy-and-sell-stock

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/

#### é¢˜ç›®æè¿°

```
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

#### æ€è·¯

ç”±äºæˆ‘ä»¬æ˜¯æƒ³è·å–åˆ°æœ€å¤§çš„åˆ©æ¶¦ï¼Œæˆ‘ä»¬çš„ç­–ç•¥åº”è¯¥æ˜¯ä½ç‚¹ä¹°å…¥ï¼Œé«˜ç‚¹å–å‡ºã€‚

ç”±äºé¢˜ç›®å¯¹äºäº¤æ˜“æ¬¡æ•°æœ‰é™åˆ¶ï¼Œåªèƒ½äº¤æ˜“ä¸€æ¬¡ï¼Œå› æ­¤é—®é¢˜çš„æœ¬è´¨å…¶å®å°±æ˜¯æ±‚æ³¢å³°æµªè°·çš„å·®å€¼çš„æœ€å¤§å€¼ã€‚

ç”¨å›¾è¡¨ç¤ºçš„è¯å°±æ˜¯è¿™æ ·ï¼š

![121.best-time-to-buy-and-sell-stock](../assets/problems/121.best-time-to-buy-and-sell-stock.jpg)

#### å…³é”®ç‚¹è§£æ

- è¿™ç±»é¢˜åªè¦ä½ åœ¨å¿ƒä¸­(æˆ–è€…åˆ«çš„åœ°æ–¹)ç”»å‡ºä¸Šé¢è¿™ç§å›¾å°±å¾ˆå®¹æ˜“è§£å†³

#### ä»£ç 

è¯­è¨€æ”¯æŒï¼šJSï¼ŒPythonï¼ŒC++

JS Code:

```js
/*
 * @lc app=leetcode id=121 lang=javascript
 *
 * [121] Best Time to Buy and Sell Stock
 *
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
 *
 * algorithms
 * Easy (46.34%)
 * Total Accepted:    480.5K
 * Total Submissions: 1M
 * Testcase Example:  '[7,1,5,3,6,4]'
 *
 * Say you have an array for which the i^th element is the price of a given
 * stock on day i.
 *
 * If you were only permitted to complete at most one transaction (i.e., buy
 * one and sell one share of the stock), design an algorithm to find the
 * maximum profit.
 *
 * Note that you cannot sell a stock before you buy one.
 *
 * Example 1:
 *
 *
 * Input: [7,1,5,3,6,4]
 * Output: 5
 * Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit
 * = 6-1 = 5.
 * Not 7-1 = 6, as selling price needs to be larger than buying price.
 *
 *
 * Example 2:
 *
 *
 * Input: [7,6,4,3,1]
 * Output: 0
 * Explanation: In this case, no transaction is done, i.e. max profit = 0.
 *
 *
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let min = prices[0];
  let profit = 0;
  // 7 1 5 3 6 4
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = Math.max(profit, prices[i] - min);
    } else {
      min = Math.min(min, prices[i]);
    }
  }

  return profit;
};
```

Python Code:

```python
### åº”ç”¨Kadane's algorithms
class Solution:
    def maxProfit(self, prices: 'List[int]') -> int:
        """
        step by step
        """
        ### error case
        if len(prices) < 1:
            return 0

        ### caluate the daily gains, break into a subarray problem
        gains = [prices[i]-prices[i-1] for i in range(1, len(prices))]

        loc_max = global_max = 0 #not gains[0] in case of negative
        for i in range(len(gains)):
            loc_max = max(loc_max + gains[i], gains[i])
            if loc_max > global_max:
                global_max = loc_max
"""
Runtime: 48 ms, faster than 34.50% of Python3 online submissions for Best Time to Buy and Sell Stock.
Memory Usage: 14.1 MB, less than 10.26% of Python3 online submissions for Best Time to Buy and Sell Stock.
"""
```

C++ Code:

```
/**
 * ç³»ç»Ÿä¸ŠC++çš„æµ‹è¯•ç”¨ä¾‹ä¸­çš„è¾“å…¥æœ‰[]ï¼Œå› æ­¤éœ€è¦åŠ ä¸€ä¸ªåˆ¤æ–­
 */
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) return 0;
        auto min = prices[0];
        auto profit = 0;
        for (auto i = 1; i < prices.size(); ++i) {
            if (prices[i] > prices[i -1]) {
                profit = max(profit, prices[i] - min);
            } else {
                min = std::min(min, prices[i]);;
            }
        }
        return profit;
    }
};
```

#### ç›¸å…³é¢˜ç›®

- [122.best-time-to-buy-and-sell-stock-ii](./122.best-time-to-buy-and-sell-stock-ii.md)
- [309.best-time-to-buy-and-sell-stock-with-cooldown](./309.best-time-to-buy-and-sell-stock-with-cooldown.md)

### [122].best-time-to-buy-and-sell-stock-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/

#### é¢˜ç›®æè¿°

```
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

#### æ€è·¯

ç”±äºæˆ‘ä»¬æ˜¯æƒ³è·å–åˆ°æœ€å¤§çš„åˆ©æ¶¦ï¼Œæˆ‘ä»¬çš„ç­–ç•¥åº”è¯¥æ˜¯ä½ç‚¹ä¹°å…¥ï¼Œé«˜ç‚¹å–å‡ºã€‚

ç”±äºé¢˜ç›®å¯¹äºäº¤æ˜“æ¬¡æ•°æ²¡æœ‰é™åˆ¶ï¼Œå› æ­¤åªè¦èƒ½å¤Ÿèµšé’±çš„æœºä¼šæˆ‘ä»¬éƒ½ä¸åº”è¯¥æ”¾è¿‡ã€‚

> å¦‚ä¸‹å›¾ï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚å‡ºåŠ ç²—éƒ¨åˆ†çš„æ€»å’Œå³å¯

ç”¨å›¾è¡¨ç¤ºçš„è¯å°±æ˜¯è¿™æ ·ï¼š

![122.best-time-to-buy-and-sell-stock-ii](../assets/problems/122.best-time-to-buy-and-sell-stock-ii.png)

#### å…³é”®ç‚¹è§£æ

- è¿™ç±»é¢˜åªè¦ä½ åœ¨å¿ƒä¸­(æˆ–è€…åˆ«çš„åœ°æ–¹)ç”»å‡ºä¸Šé¢è¿™ç§å›¾å°±å¾ˆå®¹æ˜“è§£å†³

#### ä»£ç 

è¯­è¨€æ”¯æŒï¼šJSï¼ŒPython

JS Code:

```js
/*
 * @lc app=leetcode id=122 lang=javascript
 *
 * [122] Best Time to Buy and Sell Stock II
 *
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/
 *
 * algorithms
 * Easy (50.99%)
 * Total Accepted:    315.5K
 * Total Submissions: 610.9K
 * Testcase Example:  '[7,1,5,3,6,4]'
 *
 * Say you have an array for which the i^th element is the price of a given
 * stock on day i.
 *
 * Design an algorithm to find the maximum profit. You may complete as many
 * transactions as you like (i.e., buy one and sell one share of the stock
 * multiple times).
 *
 * Note: You may not engage in multiple transactions at the same time (i.e.,
 * you must sell the stock before you buy again).
 *
 * Example 1:
 *
 *
 * Input: [7,1,5,3,6,4]
 * Output: 7
 * Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit
 * = 5-1 = 4.
 * Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 =
 * 3.
 *
 *
 * Example 2:
 *
 *
 * Input: [1,2,3,4,5]
 * Output: 4
 * Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit
 * = 5-1 = 4.
 * Note that you cannot buy on day 1, buy on day 2 and sell them later, as you
 * are
 * engaging multiple transactions at the same time. You must sell before buying
 * again.
 *
 *
 * Example 3:
 *
 *
 * Input: [7,6,4,3,1]
 * Output: 0
 * Explanation: In this case, no transaction is done, i.e. max profit = 0.
 *
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let profit = 0;

  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = profit + prices[i] - prices[i - 1];
    }
  }

  return profit;
};
```

Python Code:

```python
class Solution:
    def maxProfit(self, prices: 'List[int]') -> int:
        gains = [prices[i] - prices[i-1] for i in range(1, len(prices))
                 if prices[i] - prices[i-1] > 0]
        return sum(gains)
print(Solution().maxProfit([7, 1, 5, 3, 6, 4]))
#è¯„è®ºåŒºé‡Œéƒ½è®²è¿™æ˜¯ä¸€é“å¼€ç©ç¬‘çš„é€åˆ†é¢˜.
```

#### ç›¸å…³é¢˜ç›®

- [121.best-time-to-buy-and-sell-stock](./121.best-time-to-buy-and-sell-stock.md)
- [309.best-time-to-buy-and-sell-stock-with-cooldown](./309.best-time-to-buy-and-sell-stock-with-cooldown.md)

### [113].path-sum-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/path-sum-ii/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚é›†åˆï¼Œå¹¶ä¸æ˜¯`æ±‚å€¼`ï¼Œè€Œæ˜¯æšä¸¾æ‰€æœ‰å¯èƒ½ï¼Œå› æ­¤åŠ¨æ€è§„åˆ’ä¸æ˜¯ç‰¹åˆ«åˆ‡åˆï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è€ƒè™‘åˆ«çš„æ–¹æ³•ã€‚

è¿™ç§é¢˜ç›®å…¶å®æœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼Œå°±æ˜¯å›æº¯æ³•ã€‚
ç½‘ä¸Šä¹Ÿæœ‰å¤§ç¥ç»™å‡ºäº†è¿™ç§å›æº¯æ³•è§£é¢˜çš„
[é€šç”¨å†™æ³•](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)ï¼Œè¿™é‡Œçš„æ‰€æœ‰çš„è§£æ³•ä½¿ç”¨é€šç”¨æ–¹æ³•è§£ç­”ã€‚
é™¤äº†è¿™é“é¢˜ç›®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é¢˜ç›®å¯ä»¥ç”¨è¿™ç§é€šç”¨è§£æ³•ï¼Œå…·ä½“çš„é¢˜ç›®è§åæ–¹ç›¸å…³é¢˜ç›®éƒ¨åˆ†ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹é€šç”¨è§£æ³•çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ç”»äº†ä¸€å¼ å›¾ï¼š

![backtrack](../assets/problems/backtrack.png)

é€šç”¨å†™æ³•çš„å…·ä½“ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•
- backtrack è§£é¢˜å…¬å¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=113 lang=javascript
 *
 * [113] Path Sum II
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function backtrack(root, sum, res, tempList) {
  if (root === null) return;
  if (root.left === null && root.right === null && sum === root.val) return res.push([...tempList, root.val]);

  tempList.push(root.val);
  backtrack(root.left, sum - root.val, res, tempList);

  backtrack(root.right, sum - root.val, res, tempList);
  tempList.pop();
}
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
  if (root === null) return [];
  const res = [];
  backtrack(root, sum, res, []);
  return res;
};
```

#### ç›¸å…³é¢˜ç›®

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [124].binary-tree-maximum-path-sum

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/binary-tree-maximum-path-sum/description/

#### é¢˜ç›®æè¿°

```
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

#### æ€è·¯

è¿™é“é¢˜ç›®çš„ path è®©æˆ‘è¯¯è§£äº†ï¼Œç„¶åæµªè´¹äº†å¾ˆå¤šæ—¶é—´æ¥è§£è¿™é“é¢˜
æˆ‘è§‰å¾— leetcode ç»™çš„ demo å¤ªå°‘äº†ï¼Œä¸è¶³ä»¥è®©æˆ‘ç†è§£ path çš„æ¦‚å¿µ
å› æ­¤æˆ‘è¿™é‡Œè‡ªå·±ç”»äº†ä¸€ä¸ªå›¾ï¼Œæ¥è¡¥å……ä¸€ä¸‹ï¼Œå¸®åŠ©å¤§å®¶ç†è§£ path çš„æ¦‚å¿µï¼Œä¸è¦åƒæˆ‘ä¸€æ ·ç†è§£é”™å•¦ã€‚

é¦–å…ˆæ˜¯å®˜ç½‘ç»™çš„ä¸¤ä¸ªä¾‹å­ï¼š

![124.binary-tree-maximum-path-sum](../assets/problems/124.binary-tree-maximum-path-sum.jpg)

æ¥ç€æ˜¯æˆ‘è‡ªå·±ç”»çš„ä¸€ä¸ªä¾‹å­ï¼š

![124.binary-tree-maximum-path-sum](../assets/problems/124.binary-tree-maximum-path-sum-1.jpg)

å¤§å®¶å¯ä»¥ç»“åˆä¸Šé¢çš„ demo æ¥ç»§ç»­ç†è§£ä¸€ä¸‹ pathï¼Œ é™¤éä½ ç†è§£äº† pathï¼Œå¦åˆ™ä¸è¦å¾€ä¸‹çœ‹ã€‚

æ ‘çš„é¢˜ç›®ï¼ŒåŸºæœ¬éƒ½æ˜¯è€ƒå¯Ÿé€’å½’æ€æƒ³çš„ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦æ€è€ƒå¦‚ä½•å»å®šä¹‰æˆ‘ä»¬çš„é€’å½’å‡½æ•°ï¼Œ
åœ¨è¿™é‡Œæˆ‘å®šä¹‰äº†ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯ï¼Œ`è¿”å›ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„MathPath`
ä½†æ˜¯æœ‰ä¸¤ä¸ªæ¡ä»¶:

1.  ç¬¬ä¸€æ˜¯è·ŸèŠ‚ç‚¹å¿…é¡»é€‰æ‹©
2.  ç¬¬äºŒæ˜¯å·¦å³å­æ ‘åªèƒ½é€‰æ‹©ä¸€ä¸ª

ä¸ºä»€ä¹ˆè¦æœ‰è¿™ä¸¤ä¸ªæ¡ä»¶?

æˆ‘çš„æƒ³æ³•æ˜¯åŸé—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºï¼š

ä»¥æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åˆ†åˆ«æ±‚å‡º max pathï¼Œæœ€åè®¡ç®—æœ€å¤§å€¼,å› æ­¤ç¬¬ä¸€ä¸ªæ¡ä»¶éœ€è¦æ»¡è¶³.

å¯¹äºç¬¬äºŒä¸ªï¼Œç”±äºé€’å½’å‡½æ•°å­èŠ‚ç‚¹çš„è¿”å›å€¼ä¼šè¢«çˆ¶èŠ‚ç‚¹ä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬å¦‚æœä¸¤ä¸ªå­©å­éƒ½é€‰æ‹©äº†
å°±ä¸ç¬¦åˆ max path çš„å®šä¹‰äº†ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘æ²¡æœ‰ç†è§£é¢˜æ„ï¼Œç»•äº†å¾ˆå¤§å¼¯å­çš„åŸå› ã€‚

å› æ­¤æˆ‘çš„åšæ³•å°±æ˜¯ä¸æ–­è°ƒç”¨é€’å½’å‡½æ•°ï¼Œç„¶ååœ¨è°ƒç”¨è¿‡ç¨‹ä¸­ä¸æ–­è®¡ç®—å’Œæ›´æ–° maxï¼Œæœ€ååœ¨ä¸»å‡½æ•°ä¸­å°† max è¿”å›å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- é€’å½’
- ç†è§£é¢˜ç›®ä¸­çš„ path å®šä¹‰

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=124 lang=javascript
 *
 * [124] Binary Tree Maximum Path Sum
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(node, payload) {
  if (node === null) return 0;

  const l = helper(node.left, payload);
  const r = helper(node.right, payload);

  payload.max = Math.max(node.val + Math.max(0, l) + Math.max(0, r), payload.max);

  return node.val + Math.max(l, r, 0);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
  if (root === null) return 0;
  const payload = {
    max: root.val,
  };
  helper(root, payload);
  return payload.max;
};
```

#### ç›¸å…³é¢˜ç›®

- [113.path-sum-ii](./113.path-sum-ii.md)

### [125].valid-palindrome

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/valid-palindrome/description/

#### é¢˜ç›®æè¿°

```
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Note: For the purpose of this problem, we define empty string as valid palindrome.

Example 1:

Input: "A man, a plan, a canal: Panama"
Output: true
Example 2:

Input: "race a car"
Output: false

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“è€ƒå¯Ÿå›æ–‡çš„é¢˜ç›®ï¼Œè€Œä¸”æ˜¯æœ€ç®€å•çš„å½¢å¼ï¼Œå³åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ã€‚

é’ˆå¯¹è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¤´å°¾åŒæŒ‡é’ˆï¼Œ

- å¦‚æœä¸¤ä¸ªæŒ‡é’ˆçš„å…ƒç´ ä¸ç›¸åŒï¼Œåˆ™ç›´æ¥è¿”å› false,
- å¦‚æœä¸¤ä¸ªæŒ‡é’ˆçš„å…ƒç´ ç›¸åŒï¼Œæˆ‘ä»¬åŒæ—¶æ›´æ–°å¤´å°¾æŒ‡é’ˆï¼Œå¾ªç¯ã€‚ ç›´åˆ°å¤´å°¾æŒ‡é’ˆç›¸é‡ã€‚

æ—¶é—´å¤æ‚åº¦ä¸º O(n).

æ‹¿â€œnoonâ€è¿™æ ·ä¸€ä¸ªå›æ–‡ä¸²æ¥è¯´ï¼Œæˆ‘ä»¬çš„åˆ¤æ–­è¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š

![125.valid-palindrome-1](../assets/problems/125.valid-palindrome-1.png)

æ‹¿â€œabaaâ€è¿™æ ·ä¸€ä¸ªä¸æ˜¯å›æ–‡çš„å­—ç¬¦ä¸²æ¥è¯´ï¼Œæˆ‘ä»¬çš„åˆ¤æ–­è¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š

![125.valid-palindrome-2](../assets/problems/125.valid-palindrome-2.png)

#### å…³é”®ç‚¹è§£æ

- åŒæŒ‡é’ˆ

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=125 lang=javascript
 *
 * [125] Valid Palindrome
 */
// åªå¤„ç†è‹±æ–‡å­—ç¬¦(é¢˜ç›®å¿½ç•¥å¤§å°å†™ï¼Œæˆ‘ä»¬å‰é¢å…¨éƒ¨è½¬åŒ–æˆäº†å°å†™ï¼Œ å› æ­¤è¿™é‡Œæˆ‘ä»¬åªåˆ¤æ–­å°å†™)å’Œæ•°å­—
function isValid(c) {
  const charCode = c.charCodeAt(0);
  const isDigit = charCode >= '0'.charCodeAt(0) && charCode <= '9'.charCodeAt(0);
  const isChar = charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0);

  return isDigit || isChar;
}
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  s = s.toLowerCase();
  let left = 0;
  let right = s.length - 1;

  while (left < right) {
    if (!isValid(s[left])) {
      left++;
      continue;
    }
    if (!isValid(s[right])) {
      right--;
      continue;
    }

    if (s[left] === s[right]) {
      left++;
      right--;
    } else {
      break;
    }
  }

  return right <= left;
};
```

C++ Code:

```
class Solution {
public:
    bool isPalindrome(string s) {
        if (s.empty())
            return true;
        const char* s1 = s.c_str();
        const char* e = s1 + s.length() - 1;
        while (e > s1) {
            if (!isalnum(*s1)) {++s1; continue;}
            if (!isalnum(*e)) {--e; continue;}
            if (tolower(*s1) != tolower(*e)) return false;
            else {--e; ++s1;}
        }
        return true;
    }
};
```

### [128].longest-consecutive-sequence

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/longest-consecutive-sequence/description/

#### é¢˜ç›®æè¿°

```
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Accepted
200,786
Submissions
485,346

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“æœ€æœ€é•¿è¿ç»­æ•°å­—åºåˆ—é•¿åº¦çš„é¢˜ç›®ï¼Œ å®˜ç½‘ç»™å‡ºçš„éš¾åº¦æ˜¯`hard`.

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯å…ˆæ’åºï¼Œç„¶åç”¨ä¸€ä¸ªå˜é‡è®°å½•æœ€å¤§å€¼ï¼Œéå†å»æ›´æ–°æœ€å¤§å€¼å³å¯ï¼Œ

ä»£ç ï¼š

```js
if (nums.length === 0) return 0;
let count = 1;
let maxCount = 1;
// è¿™é‡Œå…¶å®å¯ä»¥ä¸éœ€è¦æ’åºï¼Œè¿™ä¹ˆåšåªä¸è¿‡æ˜¯ä¸ºäº†æ–¹ä¾¿ç†è§£
nums = [...new Set(nums)].sort((a, b) => a - b);
for (let i = 0; i < nums.length - 1; i++) {
  if (nums[i + 1] - nums[i] === 1) {
    count++;
  } else {
    if (count > maxCount) {
      maxCount = count;
    }
    count = 1;
  }
}
return Math.max(count, maxCount);
```

ä½†æ˜¯éœ€è¦æ’åºæ—¶é—´å¤æ‚åº¦ä¼šä¸Šå‡ï¼Œé¢˜ç›®è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n),
é‚£ä¹ˆæˆ‘ä»¬å…¶å®å¯ä»¥ä¸ç”¨æ’åºå»è§£å†³çš„ã€‚

æ€è·¯å°±æ˜¯å°†ä¹‹å‰â€æ’åºä¹‹åï¼Œé€šè¿‡æ¯”è¾ƒå‰åå…ƒç´ æ˜¯å¦ç›¸å·® 1 æ¥åˆ¤æ–­æ˜¯å¦è¿ç»­â€œçš„æ€è·¯æ”¹ä¸º
ä¸æ’åºè€Œæ˜¯`ç›´æ¥éå†ï¼Œç„¶ååœ¨å†…éƒ¨å¾ªç¯é‡Œé¢æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `ï¼Œä½†æ˜¯é©¬ä¸Šæœ‰ä¸€ä¸ª
é—®é¢˜ï¼Œå†…éƒ¨æˆ‘ä»¬`æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `çš„è¿‡ç¨‹å¦‚æœä½¿ç”¨æ•°ç»„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n),
é‚£ä¹ˆæ€»ä½“çš„å¤æ‚åº¦å°±æ˜¯ O(n^2)ï¼Œå®Œå…¨ä¸å¯ä»¥æ¥å—ã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿ

æˆ‘ä»¬æ¢ä¸ªæ€è·¯ï¼Œç”¨ç©ºé—´æ¥æ¢æ—¶é—´ã€‚æ¯”å¦‚ç”¨ç±»ä¼¼äº hashmap è¿™æ ·çš„æ•°æ®ç»“æ„ä¼˜åŒ–æŸ¥è¯¢éƒ¨åˆ†ï¼Œå°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ° O(1), ä»£ç è§åé¢`ä»£ç éƒ¨åˆ†`

#### å…³é”®ç‚¹è§£æ

- ç©ºé—´æ¢æ—¶é—´

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=128 lang=javascript
 *
 * [128] Longest Consecutive Sequence
 *
 * https://leetcode.com/problems/longest-consecutive-sequence/description/
 *
 * algorithms
 * Hard (40.98%)
 * Total Accepted:    200.3K
 * Total Submissions: 484.5K
 * Testcase Example:  '[100,4,200,1,3,2]'
 *
 * Given an unsorted array of integers, find the length of the longest
 * consecutive elements sequence.
 *
 * Your algorithm should run in O(n) complexity.
 *
 * Example:
 *
 *
 * Input:Â [100, 4, 200, 1, 3, 2]
 * Output: 4
 * Explanation: The longest consecutive elements sequence is [1, 2, 3, 4].
 * Therefore its length is 4.
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  nums = new Set(nums);
  let max = 0;
  let y = 0;
  nums.forEach(x => {
    // è¯´æ˜xæ˜¯è¿ç»­åºåˆ—çš„å¼€å¤´å…ƒç´ 
    if (!nums.has(x - 1)) {
      y = x + 1;
      while (nums.has(y)) {
        y = y + 1;
      }
      max = Math.max(max, y - x); // y - x å°±æ˜¯ä»xå¼€å§‹åˆ°æœ€åæœ‰å¤šå°‘è¿ç»­çš„æ•°å­—
    }
  });
  return max;
};
```

### [129].sum-root-to-leaf-numbers

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/sum-root-to-leaf-numbers/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“éå¸¸é€‚åˆè®­ç»ƒé€’å½’çš„é¢˜ç›®ã€‚è™½ç„¶é¢˜ç›®ä¸éš¾ï¼Œä½†æ˜¯è¦æƒ³ä¸€æ¬¡å†™æ­£ç¡®ï¼Œå¹¶ä¸”ä»£ç è¦è¶³å¤Ÿä¼˜é›…å´ä¸æ˜¯å¾ˆå®¹æ˜“ã€‚

è¿™é‡Œæˆ‘ä»¬çš„æ€è·¯æ˜¯å®šä¸€ä¸ªé€’å½’çš„ helper å‡½æ•°ï¼Œç”¨æ¥å¸®åŠ©æˆ‘ä»¬å®Œæˆé€’å½’æ“ä½œã€‚
é€’å½’å‡½æ•°çš„åŠŸèƒ½æ˜¯å°†å®ƒçš„å·¦å³å­æ ‘ç›¸åŠ ï¼Œæ³¨æ„è¿™é‡Œä¸åŒ…æ‹¬è¿™ä¸ªèŠ‚ç‚¹æœ¬èº«ï¼Œå¦åˆ™ä¼šå¤šåŠ ï¼Œ
æˆ‘ä»¬å…¶å®å…³æ³¨çš„å°±æ˜¯å¶å­èŠ‚ç‚¹çš„å€¼ï¼Œç„¶åé€šè¿‡å±‚å±‚å›æº¯åˆ° rootï¼Œè¿”å›å³å¯ã€‚

æ•´ä¸ªè¿‡ç¨‹å¦‚å›¾æ‰€ç¤ºï¼š

![129.sum-root-to-leaf-numbers-1](../assets/problems/129.sum-root-to-leaf-numbers-1.jpg)

é‚£ä¹ˆæ•°å­—å…·ä½“çš„è®¡ç®—é€»è¾‘ï¼Œå¦‚å›¾æ‰€ç¤ºï¼Œç›¸ä¿¡å¤§å®¶é€šè¿‡è¿™ä¸ªä¸éš¾å‘ç°è§„å¾‹ï¼š

![129.sum-root-to-leaf-numbers-2](../assets/problems/129.sum-root-to-leaf-numbers-2.jpg)

#### å…³é”®ç‚¹è§£æ

- é€’å½’åˆ†æ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=129 lang=javascript
 *
 * [129] Sum Root to Leaf Numbers
 */
function helper(node, cur) {
  if (node === null) return 0;
  const next = node.val + cur * 10;

  if (node.left === null && node.right === null) return next;

  const l = helper(node.left, next);
  const r = helper(node.right, next);

  return l + r;
}
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
  // tag: `tree` `dfs` `math`
  return helper(root, 0);
};
```

#### ç›¸å…³é¢˜ç›®

- [sum-of-root-to-leaf-binary-numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)

> è¿™é“é¢˜å’Œæœ¬é¢˜å¤ªåƒäº†ï¼Œè·Ÿä¸€é“é¢˜æ²¡å•¥åŒºåˆ«

### [131].palindrome-partitioning

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/palindrome-partitioning/description/

#### é¢˜ç›®æè¿°

```
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“æ±‚è§£æ‰€æœ‰å¯èƒ½æ€§çš„é¢˜ç›®ï¼Œ è¿™æ—¶å€™å¯ä»¥è€ƒè™‘ä½¿ç”¨å›æº¯æ³•ã€‚ å›æº¯æ³•è§£é¢˜çš„æ¨¡æ¿æˆ‘ä»¬å·²ç»åœ¨å¾ˆå¤šé¢˜ç›®ä¸­ç”¨è¿‡äº†ï¼Œ
è¿™é‡Œå°±ä¸å¤šè¯´äº†ã€‚å¤§å®¶å¯ä»¥ç»“åˆå…¶ä»–å‡ é“é¢˜ç›®åŠ æ·±ä¸€ä¸‹ç†è§£ã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=131 lang=javascript
 *
 * [131] Palindrome Partitioning
 */

function isPalindrom(s) {
  let left = 0;
  let right = s.length - 1;

  while (left < right && s[left] === s[right]) {
    left++;
    right--;
  }

  return left >= right;
}
function backtrack(s, list, tempList, start) {
  const sliced = s.slice(start);

  if (isPalindrom(sliced) && tempList.join('').length === s.length) list.push([...tempList]);

  for (let i = 0; i < sliced.length; i++) {
    const sub = sliced.slice(0, i + 1);
    if (isPalindrom(sub)) {
      tempList.push(sub);
    } else {
      continue;
    }
    backtrack(s, list, tempList, start + i + 1);
    tempList.pop();
  }
}
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
  // "aab"
  // ["aa", "b"]
  // ["a", "a", "b"]
  const list = [];
  backtrack(s, list, [], 0);
  return list;
};
```

#### ç›¸å…³é¢˜ç›®

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)

### [136].single-number

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/single-number/description/

#### é¢˜ç›®æè¿°

```
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
```

#### æ€è·¯

æ ¹æ®é¢˜ç›®æè¿°ï¼Œç”±äºåŠ ä¸Šäº†æ—¶é—´å¤æ‚åº¦å¿…é¡»æ˜¯ O(n)ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦ä¸º O(1)çš„æ¡ä»¶ï¼Œå› æ­¤ä¸èƒ½ç”¨æ’åºæ–¹æ³•ï¼Œä¹Ÿä¸èƒ½ä½¿ç”¨ map æ•°æ®ç»“æ„ã€‚

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨äºŒè¿›åˆ¶å¼‚æˆ–çš„æ€§è´¨æ¥å®Œæˆï¼Œå°†æ‰€æœ‰æ•°å­—å¼‚æˆ–å³å¾—åˆ°å”¯ä¸€å‡ºç°çš„æ•°å­—ã€‚

#### å…³é”®ç‚¹

1. å¼‚æˆ–çš„æ€§è´¨
   ä¸¤ä¸ªæ•°å­—å¼‚æˆ–çš„ç»“æœ`a^b`æ˜¯å°† a å’Œ b çš„äºŒè¿›åˆ¶æ¯ä¸€ä½è¿›è¡Œè¿ç®—ï¼Œå¾—å‡ºçš„æ•°å­—ã€‚ è¿ç®—çš„é€»è¾‘æ˜¯
   å¦‚æœåŒä¸€ä½çš„æ•°å­—ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1

2. å¼‚æˆ–çš„è§„å¾‹

- ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º`0`

- ä»»ä½•æ•°å’Œ 0 å¼‚æˆ–æ˜¯`æœ¬èº«`

3. å¾ˆå¤šäººåªæ˜¯è®°å¾—å¼‚æˆ–çš„æ€§è´¨å’Œè§„å¾‹ï¼Œä½†æ˜¯ç¼ºä¹å¯¹å…¶æœ¬è´¨çš„ç†è§£ï¼Œå¯¼è‡´å¾ˆéš¾æƒ³åˆ°è¿™ç§è§£æ³•(æˆ‘æœ¬äººä¹Ÿæ²¡æƒ³åˆ°)

4. bit è¿ç®—

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=136 lang=javascript
 *
 * [136] Single Number
 *
 * https://leetcode.com/problems/single-number/description/
 *
 * algorithms
 * Easy (59.13%)
 * Total Accepted:    429.3K
 * Total Submissions: 724.1K
 * Testcase Example:  '[2,2,1]'
 *
 * Given a non-emptyÂ array of integers, every element appears twice except for
 * one. Find that single one.
 *
 * Note:
 *
 * Your algorithm should have a linear runtime complexity. Could you implement
 * it without using extra memory?
 *
 * Example 1:
 *
 *
 * Input: [2,2,1]
 * Output: 1
 *
 *
 * Example 2:
 *
 *
 * Input: [4,1,2,1,2]
 * Output: 4
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let ret = 0;
  for (let index = 0; index < nums.length; index++) {
    const element = nums[index];
    ret = ret ^ element;
  }
  return ret;
};
```

#### å»¶ä¼¸

æœ‰ä¸€ä¸ª n ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œé™¤äº†ä¸¤ä¸ªæ•°åªå‡ºç°ä¸€æ¬¡å¤–ï¼Œå…¶ä½™å…ƒç´ éƒ½å‡ºç°ä¸¤æ¬¡ï¼Œè®©ä½ æ‰¾å‡ºè¿™ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°åˆ†åˆ«æ˜¯å‡ ï¼Œè¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n) ä¸”å†å¼€è¾Ÿçš„å†…å­˜ç©ºé—´å›ºå®š(ä¸ n æ— å…³)ã€‚

å’Œä¸Šé¢ä¸€æ ·ï¼Œåªæ˜¯è¿™æ¬¡ä¸æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä¸¤ä¸ªæ•°å­—ã€‚è¿˜æ˜¯æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œæˆ‘ä»¬è¿›è¡Œä¸€æ¬¡å…¨å‘˜å¼‚æˆ–æ“ä½œï¼Œ
å¾—åˆ°çš„ç»“æœå°±æ˜¯é‚£ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„ä¸åŒçš„æ•°å­—çš„å¼‚æˆ–ç»“æœã€‚

æˆ‘ä»¬åˆšæ‰è®²äº†å¼‚æˆ–çš„è§„å¾‹ä¸­æœ‰ä¸€ä¸ª`ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º0`ï¼Œ å› æ­¤æˆ‘ä»¬çš„æ€è·¯æ˜¯èƒ½ä¸èƒ½å°†è¿™ä¸¤ä¸ªä¸åŒçš„æ•°å­—åˆ†æˆä¸¤ç»„ A å’Œ Bã€‚
åˆ†ç»„éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶.

1. ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—åˆ†æˆä¸åŒç»„

2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„

è¿™æ ·æ¯ä¸€ç»„çš„æ•°æ®è¿›è¡Œå¼‚æˆ–å³å¯å¾—åˆ°é‚£ä¸¤ä¸ªæ•°å­—ã€‚

é—®é¢˜çš„å…³é”®ç‚¹æ˜¯æˆ‘ä»¬æ€ä¹ˆè¿›è¡Œåˆ†ç»„å‘¢ï¼Ÿ

ç”±äºå¼‚æˆ–çš„æ€§è´¨æ˜¯ï¼ŒåŒä¸€ä½ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1. æˆ‘ä»¬å°†æ‰€æœ‰æ•°å­—å¼‚æˆ–çš„ç»“æœä¸€å®šä¸æ˜¯ 0ï¼Œä¹Ÿå°±æ˜¯è¯´è‡³å°‘æœ‰ä¸€ä½æ˜¯ 1.

æˆ‘ä»¬éšä¾¿å–ä¸€ä¸ªï¼Œ åˆ†ç»„çš„ä¾æ®å°±æ¥äº†ï¼Œ å°±æ˜¯ä½ å–çš„é‚£ä¸€ä½æ˜¯ 0 åˆ†æˆ 1 ç»„ï¼Œé‚£ä¸€ä½æ˜¯ 1 çš„åˆ†æˆä¸€ç»„ã€‚
è¿™æ ·è‚¯å®šèƒ½ä¿è¯`2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„`, ä¸åŒçš„æ•°å­—ä¼šè¢«åˆ†æˆä¸åŒç»„ä¹ˆã€‚ å¾ˆæ˜æ˜¾å½“ç„¶å¯ä»¥ï¼Œ å› æ­¤æˆ‘ä»¬é€‰æ‹©æ˜¯ 1ï¼Œä¹Ÿå°±æ˜¯
è¯´`ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—`åœ¨é‚£ä¸€ä½ä¸€å®šæ˜¯ä¸åŒçš„ï¼Œå› æ­¤ä¸¤ä¸ªç‹¬ç‰¹å…ƒç´ ä¸€å®šä¼šè¢«åˆ†æˆä¸åŒç»„ã€‚

Doneï¼

### [139].word-break

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/word-break/description/

#### é¢˜ç›®æè¿°

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

#### æ€è·¯

è¿™é“é¢˜æ˜¯ç»™å®šä¸€ä¸ªå­—å…¸å’Œä¸€ä¸ªå¥å­ï¼Œåˆ¤æ–­è¯¥å¥å­æ˜¯å¦å¯ä»¥ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„å‡ºæ¥ï¼Œä¸€ä¸ªå•è¯å¯ä»¥ç”¨å¤šæ¬¡ã€‚

æš´åŠ›çš„æ–¹æ³•æ˜¯æ— è§£çš„ï¼Œå¤æ‚åº¦æå…¶é«˜ã€‚ æˆ‘ä»¬è€ƒè™‘å…¶æ˜¯å¦å¯ä»¥æ‹†åˆ†ä¸ºå°é—®é¢˜æ¥è§£å†³ã€‚
å¯¹äºé—®é¢˜`(s, wordDict)` æˆ‘ä»¬æ˜¯å¦å¯ä»¥ç”¨(s', wordDict) æ¥è§£å†³ã€‚ å…¶ä¸­ s' æ˜¯ s çš„å­åºåˆ—ï¼Œ
å½“ s'å˜æˆå¯»å¸¸(é•¿åº¦ä¸º 0)çš„æ—¶å€™é—®é¢˜å°±è§£å†³äº†ã€‚ æˆ‘ä»¬çŠ¶æ€è½¬ç§»æ–¹ç¨‹å˜æˆäº†è¿™é“é¢˜çš„éš¾ç‚¹ã€‚

æˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ªæ•°ç»„ dp, dp[i]ä»£è¡¨ å­—ç¬¦ä¸² s.substring(0, i) èƒ½å¦ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„æˆï¼Œ
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæˆ‘ä»¬æ— æ³•å»ºç«‹ dp[i] å’Œ dp[i - 1] çš„å…³ç³»ï¼Œ
æˆ‘ä»¬å¯ä»¥å»ºç«‹çš„æ˜¯ dp[i - word.length] å’Œ dp[i] çš„å…³ç³»ã€‚

æˆ‘ä»¬ç”¨å›¾æ¥æ„Ÿå—ä¸€ä¸‹ï¼š

![139.word-break-1](../assets/problems/139.word-break-1.png)

æ²¡æœ‰æ˜ç™½ä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬åˆ†æ­¥éª¤è§£è¯»ä¸€ä¸‹ï¼š

(ä»¥ä¸‹çš„å›¾å·¦è¾¹éƒ½ä»£è¡¨ sï¼Œå³è¾¹éƒ½æ˜¯ dictï¼Œç°è‰²ä»£è¡¨æ²¡æœ‰å¤„ç†çš„å­—ç¬¦ï¼Œç»¿è‰²ä»£è¡¨åŒ¹é…æˆåŠŸï¼Œçº¢è‰²ä»£è¡¨åŒ¹é…å¤±è´¥)

![139.word-break-2](../assets/problems/139.word-break-2.png)

![139.word-break-3](../assets/problems/139.word-break-3.png)

![139.word-break-4](../assets/problems/139.word-break-4.png)

![139.word-break-5](../assets/problems/139.word-break-5.png)

ä¸Šé¢åˆ†æ­¥è§£é‡Šäº†ç®—æ³•çš„åŸºæœ¬è¿‡ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬æ„Ÿæ€§è®¤è¯†ä¸‹è¿™é“é¢˜ï¼Œæˆ‘æŠŠå®ƒæ¯”å–»ä¸º
ä½ æ­£åœ¨`å¾€ä¸€ä¸ªè€å¼æ‰‹ç”µç­’ğŸ”¦ä¸­è£…ç”µæ± `

![139.word-break-6](../assets/problems/139.word-break-6.png)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=139 lang=javascript
 *
 * [139] Word Break
 *
 * https://leetcode.com/problems/word-break/description/
 *
 * algorithms
 * Medium (34.45%)
 * Total Accepted:    317.8K
 * Total Submissions: 913.9K
 * Testcase Example:  '"leetcode"\n["leet","code"]'
 *
 * Given a non-empty string s and a dictionary wordDict containing a list of
 * non-empty words, determine if s can be segmented into a space-separated
 * sequence of one or more dictionary words.
 *
 * Note:
 *
 *
 * The same word in the dictionary may be reused multiple times in the
 * segmentation.
 * You may assume the dictionary does not contain duplicate words.
 *
 *
 * Example 1:
 *
 *
 * Input: s = "leetcode", wordDict = ["leet", "code"]
 * Output: true
 * Explanation: Return true because "leetcode" can be segmented as "leet
 * code".
 *
 *
 * Example 2:
 *
 *
 * Input: s = "applepenapple", wordDict = ["apple", "pen"]
 * Output: true
 * Explanation: Return true because "applepenapple" can be segmented as "apple
 * pen apple".
 * Note that you are allowed to reuse a dictionary word.
 *
 *
 * Example 3:
 *
 *
 * Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
 * Output: false
 *
 *
 */
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  const dp = Array(s.length + 1);
  dp[0] = true;
  for (let i = 0; i < s.length + 1; i++) {
    for (let word of wordDict) {
      if (dp[i - word.length] && word.length <= i) {
        if (s.substring(i - word.length, i) === word) {
          dp[i] = true;
        }
      }
    }
  }

  return dp[s.length] || false;
};
```

### [144].binary-tree-preorder-traversal

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/binary-tree-preorder-traversal/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
Follow up: Recursive solution is trivial, could you do it iteratively?

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯å‰åºéå†ï¼Œè¿™ä¸ªå’Œä¹‹å‰çš„`leetcode 94 å·é—®é¢˜ - ä¸­åºéå†`å®Œå…¨ä¸ä¸€å›äº‹ã€‚

å‰åºéå†æ˜¯`æ ¹å·¦å³`çš„é¡ºåºï¼Œæ³¨æ„æ˜¯`æ ¹`å¼€å§‹ï¼Œé‚£ä¹ˆå°±å¾ˆç®€å•ã€‚ç›´æ¥å…ˆå°†æ ¹èŠ‚ç‚¹å…¥æ ˆï¼Œç„¶å
çœ‹æœ‰æ²¡æœ‰å³èŠ‚ç‚¹ï¼Œæœ‰åˆ™å…¥æ ˆï¼Œå†çœ‹æœ‰æ²¡æœ‰å·¦èŠ‚ç‚¹ï¼Œæœ‰åˆ™å…¥æ ˆã€‚ ç„¶åå‡ºæ ˆä¸€ä¸ªå…ƒç´ ï¼Œé‡å¤å³å¯ã€‚

> å…¶ä»–æ ‘çš„éé€’å½’éå†è¯¾æ²¡è¿™ä¹ˆç®€å•

#### å…³é”®ç‚¹è§£æ

- äºŒå‰æ ‘çš„åŸºæœ¬æ“ä½œ(éå†)
  > ä¸åŒçš„éå†ç®—æ³•å·®å¼‚è¿˜æ˜¯è›®å¤§çš„
- å¦‚æœéé€’å½’çš„è¯åˆ©ç”¨æ ˆæ¥ç®€åŒ–æ“ä½œ

- å¦‚æœæ•°æ®è§„æ¨¡ä¸å¤§çš„è¯ï¼Œå»ºè®®ä½¿ç”¨é€’å½’

- é€’å½’çš„é—®é¢˜éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼Œä¸€ä¸ªæ˜¯ç»ˆæ­¢æ¡ä»¶ï¼Œä¸€ä¸ªå¦‚ä½•ç¼©å°è§„æ¨¡

1. ç»ˆæ­¢æ¡ä»¶ï¼Œè‡ªç„¶æ˜¯å½“å‰è¿™ä¸ªå…ƒç´ æ˜¯ null(é“¾è¡¨ä¹Ÿæ˜¯ä¸€æ ·)

2. ç”±äºäºŒå‰æ ‘æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€’å½’ç»“æ„ï¼Œ æ¯æ¬¡å¤„ç†ä¸€ä¸ªå­æ ‘å…¶å®å°±æ˜¯ç¼©å°äº†è§„æ¨¡ï¼Œ
   éš¾ç‚¹åœ¨äºå¦‚ä½•åˆå¹¶ç»“æœï¼Œè¿™é‡Œçš„åˆå¹¶ç»“æœå…¶å®å°±æ˜¯`mid.concat(left).concat(right)`,
   mid æ˜¯ä¸€ä¸ªå…·ä½“çš„èŠ‚ç‚¹ï¼Œleft å’Œ right`é€’å½’æ±‚å‡ºå³å¯`

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=144 lang=javascript
 *
 * [144] Binary Tree Preorder Traversal
 *
 * https://leetcode.com/problems/binary-tree-preorder-traversal/description/
 *
 * algorithms
 * Medium (50.36%)
 * Total Accepted:    314K
 * Total Submissions: 621.2K
 * Testcase Example:  '[1,null,2,3]'
 *
 * Given a binary tree, return the preorder traversal of its nodes' values.
 *
 * Example:
 *
 *
 * Input:Â [1,null,2,3]
 * â   1
 * â    \
 * â     2
 * â    /
 * â   3
 *
 * Output:Â [1,2,3]
 *
 *
 * Follow up: Recursive solution is trivial, could you do it iteratively?
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
  // 1. Recursive solution

  // if (!root) return [];

  // return [root.val].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));

  // 2. iterative solutuon

  if (!root) return [];
  const ret = [];
  const stack = [root];
  let t = stack.pop();

  while (t) {
    ret.push(t.val);
    if (t.right) {
      stack.push(t.right);
    }
    if (t.left) {
      stack.push(t.left);
    }
    t = stack.pop();
  }

  return ret;
};
```

C++ Code:

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> v;
        vector<TreeNode*> s;
        while (root != NULL || !s.empty()) {
            while (root != NULL) {
                v.push_back(root->val);
                s.push_back(root);
                root = root->left;
            }
            root = s.back()->right;
            s.pop_back();
        }
        return v;
    }
};
```

### [145].binary-tree-postorder-traversal

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/binary-tree-postorder-traversal/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, return the postorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3


return [3,2,1].

Note: Recursive solution is trivial, could you do it iteratively?

```

#### æ€è·¯

ç›¸æ¯”äºå‰åºéå†ï¼Œåç»­éå†æ€ç»´ä¸Šéš¾åº¦è¦å¤§äº›ï¼Œå‰åºéå†æ˜¯é€šè¿‡ä¸€ä¸ª stackï¼Œé¦–å…ˆå‹å…¥çˆ¶äº²ç»“ç‚¹ï¼Œç„¶åå¼¹å‡ºçˆ¶äº²ç»“ç‚¹ï¼Œå¹¶è¾“å‡ºå®ƒçš„ valueï¼Œä¹‹åå‹äººå…¶å³å„¿å­ï¼Œå·¦å„¿å­å³å¯ã€‚

ç„¶è€Œååºéå†ç»“ç‚¹çš„è®¿é—®é¡ºåºæ˜¯ï¼šå·¦å„¿å­ -> å³å„¿å­ -> è‡ªå·±ã€‚é‚£ä¹ˆä¸€ä¸ªç»“ç‚¹éœ€è¦ä¸¤ç§æƒ…å†µä¸‹æ‰èƒ½å¤Ÿè¾“å‡ºï¼š
ç¬¬ä¸€ï¼Œå®ƒå·²ç»æ˜¯å¶å­ç»“ç‚¹ï¼›
ç¬¬äºŒï¼Œå®ƒä¸æ˜¯å¶å­ç»“ç‚¹ï¼Œä½†æ˜¯å®ƒçš„å„¿å­å·²ç»è¾“å‡ºè¿‡ã€‚

é‚£ä¹ˆåŸºäºæ­¤æˆ‘ä»¬åªéœ€è¦è®°å½•ä¸€ä¸‹å½“å‰è¾“å‡ºçš„ç»“ç‚¹å³å¯ã€‚å¯¹äºä¸€ä¸ªæ–°çš„ç»“ç‚¹ï¼Œå¦‚æœå®ƒä¸æ˜¯å¶å­ç»“ç‚¹ï¼Œå„¿å­ä¹Ÿæ²¡æœ‰è®¿é—®ï¼Œé‚£ä¹ˆå°±éœ€è¦å°†å®ƒçš„å³å„¿å­ï¼Œå·¦å„¿å­å‹å…¥ã€‚
å¦‚æœå®ƒæ»¡è¶³è¾“å‡ºæ¡ä»¶ï¼Œåˆ™è¾“å‡ºå®ƒï¼Œå¹¶è®°å½•ä¸‹å½“å‰è¾“å‡ºç»“ç‚¹ã€‚è¾“å‡ºåœ¨ stack ä¸ºç©ºæ—¶ç»“æŸã€‚

#### å…³é”®ç‚¹è§£æ

- äºŒå‰æ ‘çš„åŸºæœ¬æ“ä½œ(éå†)
  > ä¸åŒçš„éå†ç®—æ³•å·®å¼‚è¿˜æ˜¯è›®å¤§çš„
- å¦‚æœéé€’å½’çš„è¯åˆ©ç”¨æ ˆæ¥ç®€åŒ–æ“ä½œ

- å¦‚æœæ•°æ®è§„æ¨¡ä¸å¤§çš„è¯ï¼Œå»ºè®®ä½¿ç”¨é€’å½’

- é€’å½’çš„é—®é¢˜éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼Œä¸€ä¸ªæ˜¯ç»ˆæ­¢æ¡ä»¶ï¼Œä¸€ä¸ªå¦‚ä½•ç¼©å°è§„æ¨¡

1. ç»ˆæ­¢æ¡ä»¶ï¼Œè‡ªç„¶æ˜¯å½“å‰è¿™ä¸ªå…ƒç´ æ˜¯ null(é“¾è¡¨ä¹Ÿæ˜¯ä¸€æ ·)

2. ç”±äºäºŒå‰æ ‘æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€’å½’ç»“æ„ï¼Œ æ¯æ¬¡å¤„ç†ä¸€ä¸ªå­æ ‘å…¶å®å°±æ˜¯ç¼©å°äº†è§„æ¨¡ï¼Œ
   éš¾ç‚¹åœ¨äºå¦‚ä½•åˆå¹¶ç»“æœï¼Œè¿™é‡Œçš„åˆå¹¶ç»“æœå…¶å®å°±æ˜¯`left.concat(right).concat(mid)`,
   mid æ˜¯ä¸€ä¸ªå…·ä½“çš„èŠ‚ç‚¹ï¼Œleft å’Œ right`é€’å½’æ±‚å‡ºå³å¯`

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=145 lang=javascript
 *
 * [145] Binary Tree Postorder Traversal
 *
 * https://leetcode.com/problems/binary-tree-postorder-traversal/description/
 *
 * algorithms
 * Hard (47.06%)
 * Total Accepted:    242.6K
 * Total Submissions: 512.8K
 * Testcase Example:  '[1,null,2,3]'
 *
 * Given a binary tree, return the postorder traversal of its nodes' values.
 *
 * Example:
 *
 *
 * Input:Â [1,null,2,3]
 * â   1
 * â    \
 * â     2
 * â    /
 * â   3
 *
 * Output:Â [3,2,1]
 *
 *
 * Follow up: Recursive solution is trivial, could you do it iteratively?
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
  // 1. Recursive solution

  // if (!root) return [];

  // return postorderTraversal(root.left).concat(postorderTraversal(root.right)).concat(root.val);

  // 2. iterative solutuon

  if (!root) return [];
  const ret = [];
  const stack = [root];
  let p = root; // æ ‡è¯†å…ƒç´ ï¼Œç”¨æ¥åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦åº”è¯¥å‡ºæ ˆ

  while (stack.length > 0) {
    const top = stack[stack.length - 1];
    if (
      top.left === p ||
      top.right === p || // å­èŠ‚ç‚¹å·²ç»éå†è¿‡äº†
      (top.left === null && top.right === null) // å¶å­å…ƒç´ 
    ) {
      p = stack.pop();
      ret.push(p.val);
    } else {
      if (top.right) {
        stack.push(top.right);
      }
      if (top.left) {
        stack.push(top.left);
      }
    }
  }

  return ret;
};
```

### [146].lru-cache

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/lru-cache/description/

#### é¢˜ç›®æè¿°

```
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

```

#### æ€è·¯

ç”±äºæ˜¯ä¿ç•™æ˜¯æœ€è¿‘ä½¿ç”¨çš„ N æ¡æ•°æ®ï¼Œè¿™å°±å’Œé˜Ÿåˆ—çš„ç‰¹æ€§å¾ˆç¬¦åˆï¼Œ å…ˆè¿›å…¥é˜Ÿåˆ—çš„ï¼Œå…ˆå‡ºé˜Ÿåˆ—ã€‚

å› æ­¤æ€è·¯å°±æ˜¯ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥è®°å½•ç›®å‰ç¼“å­˜çš„æ‰€æœ‰ keyï¼Œ æ¯æ¬¡ push éƒ½è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœ
è¶…å‡ºæœ€å¤§å®¹é‡é™åˆ¶åˆ™è¿›è¡Œæ¸…é™¤ç¼“å­˜çš„æ“ä½œï¼Œ å…·ä½“æ¸…é™¤è°å°±æŒ‰ç…§åˆšæ‰è¯´çš„é˜Ÿåˆ—æ–¹å¼è¿›è¡Œå¤„ç†ï¼ŒåŒæ—¶å¯¹ key è¿›è¡Œå…¥é˜Ÿæ“ä½œã€‚

get çš„æ—¶å€™ï¼Œå¦‚æœç¼“å­˜ä¸­æœ‰ï¼Œåˆ™è°ƒæ•´é˜Ÿåˆ—(å…·ä½“æ“ä½œä¸ºåˆ é™¤æŒ‡å®šå…ƒç´ å’Œå…¥é˜Ÿä¸¤ä¸ªæ“ä½œ)ã€‚ ç¼“å­˜ä¸­æ²¡æœ‰åˆ™è¿”å›-1

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—ç®€åŒ–æ“ä½œ

- é˜Ÿåˆ—çš„æ“ä½œæ˜¯è¿™é“é¢˜çš„çµé­‚ï¼Œ å¾ˆå®¹æ˜“å°‘è€ƒè™‘æƒ…å†µ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=146 lang=javascript
 *
 * [146] LRU Cache
 *
 * https://leetcode.com/problems/lru-cache/description/
 *
 * algorithms
 * Hard (24.17%)
 * Total Accepted:    272.8K
 * Total Submissions: 1.1M
 * Testcase Example:  '["LRUCache","put","put","get","put","get","put","get","get","get"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]'
 *
 *
 * Design and implement a data structure for Least Recently Used (LRU) cache.
 * It should support the following operations: get and put.
 *
 *
 *
 * get(key) - Get the value (will always be positive) of the key if the key
 * exists in the cache, otherwise return -1.
 * put(key, value) - Set or insert the value if the key is not already present.
 * When the cache reached its capacity, it should invalidate the least recently
 * used item before inserting a new item.
 *
 *
 * Follow up:
 * Could you do both operations in O(1) time complexity?
 *
 * Example:
 *
 * LRUCache cache = new LRUCache( 2 );
 *
 * cache.put(1, 1);
 * cache.put(2, 2);
 * cache.get(1);       // returns 1
 * cache.put(3, 3);    // evicts key 2
 * cache.get(2);       // returns -1 (not found)
 * cache.put(4, 4);    // evicts key 1
 * cache.get(1);       // returns -1 (not found)
 * cache.get(3);       // returns 3
 * cache.get(4);       // returns 4
 *
 *
 */
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.cache = {};
  this.capacity = capacity;
  this.size = 0;
  this.queue = [];
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit !== undefined) {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
    return hit;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  const hit = this.cache[key];

  // update cache
  this.cache[key] = value;

  if (!hit) {
    // invalid cache and resize size;
    if (this.size === this.capacity) {
      // invalid cache
      const key = this.queue.shift();
      this.cache[key] = undefined;
    } else {
      this.size = this.size + 1;
    }
    this.queue.push(key);
  } else {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
  }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [15].3-sum

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/3sum/description/

#### é¢˜ç›®æè¿°

```
Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]

```

#### æ€è·¯

æˆ‘ä»¬é‡‡ç”¨`åˆ†æ²»`çš„æ€æƒ³. æƒ³è¦æ‰¾å‡ºä¸‰ä¸ªæ•°ç›¸åŠ ç­‰äº 0ï¼Œæˆ‘ä»¬å¯ä»¥æ•°ç»„ä¾æ¬¡éå†ï¼Œ
æ¯ä¸€é¡¹ a[i]æˆ‘ä»¬éƒ½è®¤ä¸ºå®ƒæ˜¯æœ€ç»ˆèƒ½å¤Ÿç”¨ç»„æˆ 0 ä¸­çš„ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯æ‰¾åˆ°
å‰©ä¸‹çš„å…ƒç´ (é™¤ a[i])`ä¸¤ä¸ª`ç›¸åŠ ç­‰äº-a[i].

é€šè¿‡ä¸Šé¢çš„æ€è·¯ï¼Œæˆ‘ä»¬çš„é—®é¢˜è½¬åŒ–ä¸ºäº†`ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­ä¸¤ä¸ªç›¸åŠ ç­‰äºç»™å®šå€¼`ï¼Œ
è¿™ä¸ªé—®é¢˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œ æˆ‘ä»¬åªéœ€è¦å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶ååŒæŒ‡é’ˆè§£å†³å³å¯ã€‚ åŠ ä¸Šæˆ‘ä»¬éœ€è¦å¤–å±‚éå†ä¾æ¬¡æ•°ç»„ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯ O(N^2)ã€‚

æ€è·¯å¦‚å›¾æ‰€ç¤ºï¼š

![15.3-sum](../assets/problems/15.3-sum.png)

> åœ¨è¿™é‡Œä¹‹æ‰€ä»¥è¦æ’åºè§£å†³æ˜¯å› ä¸ºï¼Œ æˆ‘ä»¬ç®—æ³•çš„ç“¶é¢ˆåœ¨è¿™é‡Œä¸åœ¨äºæ’åºï¼Œè€Œåœ¨äº O(N^2)ï¼Œå¦‚æœæˆ‘ä»¬ç“¶é¢ˆæ˜¯æ’åºï¼Œå°±å¯ä»¥è€ƒè™‘åˆ«çš„æ–¹å¼äº†

> å¦‚æœæ‰¾æŸä¸€ä¸ªç‰¹å®šå…ƒç´ ï¼Œä¸€ä¸ªæŒ‡é’ˆå°±å¤Ÿäº†ã€‚å¦‚æœæ˜¯æ‰¾ä¸¤ä¸ªå…ƒç´ æ»¡è¶³ä¸€å®šå…³ç³»(æ¯”å¦‚æ±‚å’Œç­‰äºç‰¹å®šå€¼)ï¼Œéœ€è¦åŒæŒ‡é’ˆï¼Œ
> å½“ç„¶å‰ææ˜¯æ•°ç»„æœ‰åºã€‚

#### å…³é”®ç‚¹è§£æ

- æ’åºä¹‹åï¼Œç”¨åŒæŒ‡é’ˆ
- åˆ†æ²»

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=15 lang=javascript
 *
 * [15] 3Sum
 *
 * https://leetcode.com/problems/3sum/description/
 *
 * algorithms
 * Medium (23.51%)
 * Total Accepted:    531.5K
 * Total Submissions: 2.2M
 * Testcase Example:  '[-1,0,1,2,-1,-4]'
 *
 * Given an array nums of n integers, are there elements a, b, c in nums such
 * that a + b + c = 0? Find all unique triplets in the array which gives the
 * sum of zero.
 *
 * Note:
 *
 * The solution set must not contain duplicate triplets.
 *
 * Example:
 *
 *
 * Given array nums = [-1, 0, 1, 2, -1, -4],
 *
 * A solution set is:
 * [
 * â  [-1, 0, 1],
 * â  [-1, -1, 2]
 * ]
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  if (nums.length < 3) return [];
  const list = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    // skip duplicated result without set
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let left = i;
    let right = nums.length - 1;

    // for each index i
    // we want to find the triplet [i, left, right] which sum to 0
    while (left < right) {
      // skip i === left or i === right, in that case, the index i will be used twice
      if (left === i) {
        left++;
      } else if (right === i) {
        right--;
      } else if (nums[left] + nums[right] + nums[i] === 0) {
        list.push([nums[left], nums[right], nums[i]]);
        // skip duplicated result without set
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        left++;
        // skip duplicated result without set
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        right--;
        continue;
      } else if (nums[left] + nums[right] + nums[i] > 0) {
        right--;
      } else {
        left++;
      }
    }
  }
  return list;
};
```

### [150].evaluate-reverse-polish-notation

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/evaluate-reverse-polish-notation/description/

#### é¢˜ç›®æè¿°

```
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
```

#### æ€è·¯

é€†æ³¢å…°è¡¨è¾¾å¼åˆå«åšåç¼€è¡¨è¾¾å¼ã€‚åœ¨é€šå¸¸çš„è¡¨è¾¾å¼ä¸­ï¼ŒäºŒå…ƒè¿ç®—ç¬¦æ€»æ˜¯ç½®äºä¸ä¹‹ç›¸å…³çš„ä¸¤ä¸ªè¿ç®—å¯¹è±¡ä¹‹é—´ï¼Œè¿™ç§è¡¨ç¤ºæ³•ä¹Ÿç§°ä¸º`ä¸­ç¼€è¡¨ç¤º`ã€‚

æ³¢å…°é€»è¾‘å­¦å®¶ J.Lukasiewicz äº 1929 å¹´æå‡ºäº†å¦ä¸€ç§è¡¨ç¤ºè¡¨è¾¾å¼çš„æ–¹æ³•ï¼ŒæŒ‰æ­¤æ–¹æ³•ï¼Œæ¯ä¸€è¿ç®—ç¬¦éƒ½ç½®äºå…¶è¿ç®—å¯¹è±¡ä¹‹åï¼Œæ•…ç§°ä¸º`åç¼€è¡¨ç¤º`ã€‚

> é€†æ³¢å…°è¡¨è¾¾å¼æ˜¯ä¸€ç§ååˆ†æœ‰ç”¨çš„è¡¨è¾¾å¼ï¼Œå®ƒå°†å¤æ‚è¡¨è¾¾å¼è½¬æ¢ä¸ºå¯ä»¥ä¾é ç®€å•çš„æ“ä½œå¾—åˆ°è®¡ç®—ç»“æœçš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚(a+b)_(c+d)è½¬æ¢ä¸º ab+cd+_

#### å…³é”®ç‚¹

1. æ ˆçš„åŸºæœ¬ç”¨æ³•

2. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦æ³¨æ„/ å’Œ å…¶ä»–å¾ˆå¤šè¯­è¨€æ˜¯ä¸ä¸€æ ·çš„

3. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦å…ˆå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—ã€‚å¦åˆ™æœ‰å¾ˆå¤šæ„æƒ³ä¸åˆ°çš„ç»“æœ

4. æ“ä½œç¬¦çš„é¡ºåºåº”è¯¥æ˜¯ å…ˆå‡ºæ ˆçš„æ˜¯ç¬¬äºŒä½ï¼Œåå‡ºæ ˆçš„æ˜¯ç¬¬ä¸€ä½ã€‚ è¿™åœ¨ä¸ç¬¦åˆäº¤æ¢å¾‹çš„æ“ä½œä¸­å¾ˆé‡è¦ï¼Œ æ¯”å¦‚å‡æ³•å’Œé™¤æ³•ã€‚

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=150 lang=javascript
 *
 * [150] Evaluate Reverse Polish Notation
 *
 * https://leetcode.com/problems/evaluate-reverse-polish-notation/description/
 *
 * algorithms
 * Medium (31.43%)
 * Total Accepted:    153.3K
 * Total Submissions: 485.8K
 * Testcase Example:  '["2","1","+","3","*"]'
 *
 * Evaluate the value of an arithmetic expression in Reverse Polish Notation.
 *
 * Valid operators are +, -, *, /. Each operand may be an integer or another
 * expression.
 *
 * Note:
 *
 *
 * Division between two integers should truncate toward zero.
 * The given RPN expression is always valid. That means the expression would
 * always evaluate to a result and there won'tÂ be anyÂ divideÂ by zero
 * operation.
 *
 *
 * Example 1:
 *
 *
 * Input: ["2", "1", "+", "3", "*"]
 * Output: 9
 * Explanation: ((2 + 1) * 3) = 9
 *
 *
 * Example 2:
 *
 *
 * Input: ["4", "13", "5", "/", "+"]
 * Output: 6
 * Explanation: (4 + (13 / 5)) = 6
 *
 *
 * Example 3:
 *
 *
 * Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
 * Output: 22
 * Explanation:
 * â  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
 * = ((10 * (6 / (12 * -11))) + 17) + 5
 * = ((10 * (6 / -132)) + 17) + 5
 * = ((10 * 0) + 17) + 5
 * = (0 + 17) + 5
 * = 17 + 5
 * = 22
 *
 *
 */
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  // è¿™ç§ç®—æ³•çš„å‰ææ˜¯ tokensæ˜¯æœ‰æ•ˆçš„ï¼Œ
  // å½“ç„¶è¿™ç”±ç®—æ³•æ¥ä¿è¯
  const stack = [];

  for (let index = 0; index < tokens.length; index++) {
    const token = tokens[index];
    // å¯¹äºè¿ç®—æ•°ï¼Œ æˆ‘ä»¬ç›´æ¥å…¥æ ˆ
    if (!Number.isNaN(Number(token))) {
      stack.push(token);
    } else {
      // é‡åˆ°æ“ä½œç¬¦ï¼Œæˆ‘ä»¬ç›´æ¥å¤§èƒ†è¿ç®—ï¼Œä¸ç”¨è€ƒè™‘ç®—æœ¯ä¼˜å…ˆçº§
      // ç„¶åå°†è¿ç®—ç»“æœå…¥æ ˆå³å¯

      // å½“ç„¶å¦‚æœé¢˜ç›®è¿›ä¸€æ­¥æ‰©å±•ï¼Œå…è®¸ä½¿ç”¨å•ç›®ç­‰å…¶ä»–è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬çš„ç®—æ³•éœ€è¦åšå¾®å°çš„è°ƒæ•´
      const a = Number(stack.pop());
      const b = Number(stack.pop());
      if (token === '*') {
        stack.push(b * a);
      } else if (token === '/') {
        stack.push((b / a) >> 0);
      } else if (token === '+') {
        stack.push(b + a);
      } else if (token === '-') {
        stack.push(b - a);
      }
    }
  }

  return stack.pop();
};
```

#### æ‰©å±•

é€†æ³¢å…°è¡¨è¾¾å¼ä¸­åªæ”¹å˜è¿ç®—ç¬¦çš„é¡ºåºï¼Œå¹¶ä¸ä¼šæ”¹å˜æ“ä½œæ•°çš„ç›¸å¯¹é¡ºåºï¼Œè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ€§è´¨ã€‚
å¦å¤–é€†æ³¢å…°è¡¨è¾¾å¼å®Œå…¨ä¸å…³å¿ƒæ“ä½œç¬¦çš„ä¼˜å…ˆçº§ï¼Œè¿™åœ¨ä¸­ç¼€è¡¨è¾¾å¼ä¸­æ˜¯åšä¸åˆ°çš„ï¼Œè¿™å¾ˆæœ‰è¶£ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥ç§ä¸‹æŸ¥æ‰¾èµ„æ–™ç ”ç©¶ä¸‹ä¸ºä»€ä¹ˆä¼šè¿™æ ·ã€‚

### [152].maximum-product-subarray

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/maximum-product-subarray/description/

#### é¢˜ç›®æè¿°

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```

#### æ€è·¯

> è¿™é“é¢˜ç›®çš„é€šè¿‡ç‡éå¸¸ä½

è¿™é“é¢˜ç›®è¦æˆ‘ä»¬æ±‚è§£è¿ç»­çš„ n ä¸ªæ•°ä¸­ä¹˜ç§¯æœ€å¤§çš„ç§¯æ˜¯å¤šå°‘ã€‚è¿™é‡Œæåˆ°äº†è¿ç»­ï¼Œç¬”è€…é¦–å…ˆ
æƒ³åˆ°çš„å°±æ˜¯æ»‘åŠ¨çª—å£ï¼Œä½†æ˜¯è¿™é‡Œæ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬ä¸èƒ½ä»…ä»…ç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼ï¼Œå› æ­¤æœ€å°å€¼(æ¯”å¦‚-20)ä¹˜ä»¥ä¸€ä¸ªæ¯”è¾ƒå°çš„æ•°(æ¯”å¦‚-10)
å¯èƒ½å°±ä¼šå¾ˆå¤§ã€‚ å› æ­¤è¿™ç§æ€è·¯å¹¶ä¸æ–¹ä¾¿ã€‚

é¦–å…ˆæ¥æš´åŠ›æ±‚è§£,æˆ‘ä»¬ä½¿ç”¨ä¸¤å±‚å¾ªç¯æ¥æšä¸¾æ‰€æœ‰å¯èƒ½é¡¹ï¼Œè¿™ç§è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2), ä»£ç å¦‚ä¸‹ï¼š

```js
var maxProduct = function(nums) {
  let max = nums[0];
  let temp = null;
  for (let i = 0; i < nums.length; i++) {
    temp = nums[i];
    max = Math.max(temp, max);
    for (let j = i + 1; j < nums.length; j++) {
      temp *= nums[j];
      max = Math.max(temp, max);
    }
  }

  return max;
};
```

å› æ­¤æˆ‘ä»¬éœ€è¦åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼ï¼Œç„¶åæ¯”è¾ƒå…ƒç´ å’Œè¿™ä¸¤ä¸ªçš„ä¹˜ç§¯ï¼Œå»ä¸æ–­æ›´æ–°æœ€å¤§å€¼ã€‚

![152.maximum-product-subarray](../assets/problems/152.maximum-product-subarray.png)

è¿™ç§æ€è·¯çš„è§£æ³•ç”±äºåªéœ€è¦éå†ä¸€æ¬¡ï¼Œå…¶æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹

- åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=152 lang=javascript
 *
 * [152] Maximum Product Subarray
 *
 * https://leetcode.com/problems/maximum-product-subarray/description/
 *
 * algorithms
 * Medium (28.61%)
 * Total Accepted:    202.8K
 * Total Submissions: 700K
 * Testcase Example:  '[2,3,-2,4]'
 *
 * Given an integer arrayÂ nums, find the contiguous subarray within an array
 * (containing at least one number) which has the largest product.
 *
 * Example 1:
 *
 *
 * Input: [2,3,-2,4]
 * Output: 6
 * Explanation:Â [2,3] has the largest product 6.
 *
 *
 * Example 2:
 *
 *
 * Input: [-2,0,-1]
 * Output: 0
 * Explanation:Â The result cannot be 2, because [-2,-1] is not a subarray.
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  let max = nums[0];
  let min = nums[0];
  let res = nums[0];

  for (let i = 1; i < nums.length; i++) {
    let tmp = min;
    min = Math.min(nums[i], Math.min(max * nums[i], min * nums[i])); // å–æœ€å°
    max = Math.max(nums[i], Math.max(max * nums[i], tmp * nums[i])); /// å–æœ€å¤§
    res = Math.max(res, max);
  }
  return res;
};
```

### [155].min-stack

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/min-stack/description/

#### é¢˜ç›®æè¿°

```
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„æ–¹æ³•æ˜¯ï¼Œæ¯æ¬¡å¯¹æ ˆè¿›è¡Œä¿®æ”¹æ“ä½œ(push å’Œ pop)çš„æ—¶å€™æ›´æ–°æœ€å°å€¼ã€‚ ç„¶å getMin åªéœ€è¦è¿”å›æˆ‘ä»¬è®¡ç®—çš„æœ€å°å€¼å³å¯ï¼Œ
top ä¹Ÿæ˜¯ç›´æ¥è¿”å›æ ˆé¡¶å…ƒç´ å³å¯ã€‚ è¿™ç§åšæ³•æ¯æ¬¡ä¿®æ”¹æ ˆéƒ½éœ€è¦æ›´æ–°æœ€å°å€¼ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦æ˜¯ O(n).

![155.min-stack](../assets/problems/155.min-stack-1.png)

æ˜¯å¦æœ‰æ›´é«˜æ•ˆçš„ç®—æ³•å‘¢ï¼Ÿç­”æ¡ˆæ˜¯æœ‰çš„ã€‚

æˆ‘ä»¬æ¯æ¬¡å…¥æ ˆçš„æ—¶å€™ï¼Œä¿å­˜çš„ä¸å†æ˜¯çœŸæ­£çš„æ•°å­—ï¼Œè€Œæ˜¯å®ƒä¸å½“å‰æœ€å°å€¼çš„å·®(å½“å‰å…ƒç´ æ²¡æœ‰å…¥æ ˆçš„æ—¶å€™çš„æœ€å°å€¼)ã€‚
è¿™æ ·æˆ‘ä»¬ pop å’Œ top çš„æ—¶å€™æ‹¿åˆ°æ ˆé¡¶å…ƒç´ å†åŠ ä¸Š**ä¸Šä¸€ä¸ª**æœ€å°å€¼å³å¯ã€‚
å¦å¤–æˆ‘ä»¬åœ¨ push å’Œ pop çš„æ—¶å€™å»æ›´æ–° minï¼Œè¿™æ · getMin çš„æ—¶å€™å°±ç®€å•äº†ï¼Œç›´æ¥è¿”å› minã€‚

> æ³¨æ„ä¸Šé¢åŠ ç²—çš„â€œä¸Šä¸€ä¸ªâ€ï¼Œä¸æ˜¯â€œå½“å‰çš„æœ€å°å€¼â€

ç»è¿‡ä¸Šé¢çš„åˆ†æï¼Œé—®é¢˜çš„å…³é”®è½¬åŒ–ä¸ºâ€œå¦‚æœæ±‚çš„ä¸Šä¸€ä¸ªæœ€å°å€¼â€ï¼Œè§£å†³è¿™ä¸ªçš„å…³é”®ç‚¹åœ¨äºåˆ©ç”¨ minã€‚

pop æˆ–è€… top çš„æ—¶å€™ï¼š

- å¦‚æœæ ˆé¡¶å…ƒç´ å°äº 0ï¼Œè¯´æ˜æ ˆé¡¶æ˜¯å½“å‰æœ€å°çš„å…ƒç´ ï¼Œå®ƒå‡ºæ ˆä¼šå¯¹ min é€ æˆå½±å“ï¼Œæˆ‘ä»¬éœ€è¦å»æ›´æ–° minã€‚
  ä¸Šä¸€ä¸ªæœ€å°çš„æ˜¯â€œmin - æ ˆé¡¶å…ƒç´ â€,æˆ‘ä»¬éœ€è¦å°†ä¸Šä¸€ä¸ªæœ€å°å€¼æ›´æ–°ä¸ºå½“å‰çš„æœ€å°å€¼

> å› ä¸ºæ ˆé¡¶å…ƒç´ å…¥æ ˆçš„æ—¶å€™çš„é€šè¿‡ `æ ˆé¡¶å…ƒç´  = çœŸå®å€¼ - ä¸Šä¸€ä¸ªæœ€å°çš„å…ƒç´ ` å¾—åˆ°çš„ï¼Œ
> è€ŒçœŸå®å€¼ = minï¼Œ å› æ­¤å¯ä»¥å¾—å‡º`ä¸Šä¸€ä¸ªæœ€å°çš„å…ƒç´  = çœŸå®å€¼ -æ ˆé¡¶å…ƒç´ `

- å¦‚æœæ ˆé¡¶å…ƒç´ å¤§äº 0ï¼Œè¯´æ˜å®ƒå¯¹æœ€å°å€¼`æ²¡æœ‰å½±å“`ï¼Œä¸Šä¸€ä¸ªæœ€å°å€¼å°±æ˜¯ä¸Šä¸Šä¸ªæœ€å°å€¼ã€‚

![155.min-stack-2](../assets/problems/155.min-stack-2.png)
![155.min-stack-3](../assets/problems/155.min-stack-3.png)

#### å…³é”®ç‚¹

- æœ€å°æ ˆå­˜å‚¨çš„ä¸åº”è¯¥æ˜¯çœŸå®å€¼ï¼Œè€Œæ˜¯çœŸå®å€¼å’Œ min çš„å·®å€¼
- top çš„æ—¶å€™æ¶‰åŠåˆ°å¯¹æ•°æ®çš„è¿˜åŸï¼Œè¿™é‡Œåƒä¸‡æ³¨æ„æ˜¯**ä¸Šä¸€ä¸ª**æœ€å°å€¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=155 lang=javascript
 *
 * [155] Min Stack
 */
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = [];
  this.min = Number.MAX_VALUE;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  // update 'min'
  const min = this.min;
  if (x < this.min) {
    this.min = x;
  }
  return this.stack.push(x - min);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const item = this.stack.pop();
  const min = this.min;

  if (item < 0) {
    this.min = min - item;
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const item = this.stack[this.stack.length - 1];
  const min = this.min;

  if (item < 0) {
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.min;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### [167].two-sum-ii-input-array-is-sorted

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/

#### é¢˜ç›®æè¿°

è¿™æ˜¯ leetcode å¤´å·é¢˜ç›®`two sum`çš„ç¬¬äºŒä¸ªç‰ˆæœ¬ï¼Œéš¾åº¦ç®€å•ã€‚

```
Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

Note:

Your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.
Example:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.

```

#### æ€è·¯

ç”±äºé¢˜ç›®æ²¡æœ‰å¯¹ç©ºé—´å¤æ‚åº¦æœ‰æ±‚ï¼Œç”¨ä¸€ä¸ª hashmap å­˜å‚¨å·²ç»è®¿é—®è¿‡çš„æ•°å­—å³å¯ã€‚

å‡å¦‚é¢˜ç›®ç©ºé—´å¤æ‚åº¦æœ‰è¦æ±‚ï¼Œç”±äºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œåªéœ€è¦åŒæŒ‡é’ˆå³å¯ã€‚ä¸€ä¸ª left æŒ‡é’ˆï¼Œä¸€ä¸ª right æŒ‡é’ˆï¼Œ
å¦‚æœ left + right å€¼ å¤§äº target åˆ™ right å·¦ç§»åŠ¨ï¼Œ å¦åˆ™ left å³ç§»ï¼Œä»£ç æ¯”è¾ƒç®€å•ï¼Œ ä¸è´´äº†ã€‚

> å¦‚æœæ•°ç»„æ— åºï¼Œéœ€è¦å…ˆæ’åº(ä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºæ’åºæ˜¯å¤šä¹ˆé‡è¦çš„æ“ä½œ)

#### å…³é”®ç‚¹è§£æ

æ— 

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=167 lang=javascript
 *
 * [167] Two Sum II - Input array is sorted
 *
 * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
 *
 * algorithms
 * Easy (49.46%)
 * Total Accepted:    221.8K
 * Total Submissions: 447K
 * Testcase Example:  '[2,7,11,15]\n9'
 *
 * Given an array of integers that is already sorted in ascending order, find
 * two numbers such that they add up to a specific target number.
 *
 * The function twoSum should return indices of the two numbers such that they
 * add up to the target, where index1 must be less than index2.
 *
 * Note:
 *
 *
 * Your returned answers (both index1 and index2) are not zero-based.
 * You may assume that each input would have exactly one solution and you may
 * not use the same element twice.
 *
 *
 * Example:
 *
 *
 * Input: numbers = [2,7,11,15], target = 9
 * Output: [1,2]
 * Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
 *
 */
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
  const visited = {}; // è®°å½•å‡ºç°çš„æ•°å­—ï¼Œ ç©ºé—´å¤æ‚åº¦N

  for (let index = 0; index < numbers.length; index++) {
    const element = numbers[index];
    if (visited[target - element] !== void 0) {
      return [visited[target - element], index + 1];
    }
    visited[element] = index + 1;
  }
  return [];
};
```

### [169].majority-element

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/majority-element/description/

#### é¢˜ç›®æè¿°

```
Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times.

You may assume that the array is non-empty and the majority element always exist in the array.

Example 1:

Input: [3,2,3]
Output: 3
Example 2:

Input: [2,2,1,1,1,2,2]
Output: 2

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯åˆ©ç”¨é¢å¤–çš„ç©ºé—´å»è®°å½•æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œå¹¶ç”¨ä¸€ä¸ªå•ç‹¬çš„å˜é‡è®°å½•å½“å‰å‡ºç°æ¬¡æ•°æœ€å¤šçš„å…ƒç´ ã€‚

ä½†æ˜¯è¿™ç§åšæ³•ç©ºé—´å¤æ‚åº¦è¾ƒé«˜ï¼Œæœ‰æ²¡æœ‰å¯èƒ½è¿›è¡Œä¼˜åŒ–å‘¢ï¼Ÿ ç­”æ¡ˆå°±æ˜¯ç”¨"æŠ•ç¥¨ç®—æ³•"ã€‚

æŠ•ç¥¨ç®—æ³•çš„åŸç†æ˜¯é€šè¿‡ä¸æ–­æ¶ˆé™¤ä¸åŒå…ƒç´ ç›´åˆ°æ²¡æœ‰ä¸åŒå…ƒç´ ï¼Œå‰©ä¸‹çš„å…ƒç´ å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„å…ƒç´ ã€‚

![169.majority-element](../assets/problems/169.majority-element.png)

#### å…³é”®ç‚¹è§£æ

- æŠ•ç¥¨ç®—æ³•

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=169 lang=javascript
 *
 * [169] Majority Element
 *
 * https://leetcode.com/problems/majority-element/description/
 *
 * algorithms
 * Easy (51.62%)
 * Total Accepted:    365.6K
 * Total Submissions: 702.5K
 * Testcase Example:  '[3,2,3]'
 *
 * Given an array of size n, find the majority element. The majority element is
 * the element that appears more than âŒŠ n/2 âŒ‹ times.
 *
 * You may assume that the array is non-empty and the majority element always
 * exist in the array.
 *
 * Example 1:
 *
 *
 * Input: [3,2,3]
 * Output: 3
 *
 * Example 2:
 *
 *
 * Input: [2,2,1,1,1,2,2]
 * Output: 2
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  let count = 1;
  let majority = nums[0];
  for (let i = 1; i < nums.length; i++) {
    if (count === 0) {
      majority = nums[i];
    }
    if (nums[i] === majority) {
      count++;
    } else {
      count--;
    }
  }
  return majority;
};
```

### [172].factorial-trailing-zeroes

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/factorial-trailing-zeroes/description/

#### é¢˜ç›®æè¿°

```
Given an integer n, return the number of trailing zeroes in n!.

Example 1:

Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.
Example 2:

Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.
Note: Your solution should be in logarithmic time complexity.

```

#### æ€è·¯

æˆ‘ä»¬éœ€è¦æ±‚è§£è¿™ n ä¸ªæ•°å­—ç›¸ä¹˜çš„ç»“æœæœ«å°¾æœ‰å¤šå°‘ä¸ª 0ï¼Œç”±äºé¢˜ç›®è¦æ±‚ log çš„å¤æ‚åº¦ï¼Œå› æ­¤æš´åŠ›æ±‚è§£æ˜¯ä¸è¡Œçš„ã€‚

é€šè¿‡è§‚å¯Ÿï¼Œæˆ‘ä»¬å‘ç°å¦‚æœæƒ³è¦ç»“æœæœ«å°¾æ˜¯ 0ï¼Œå¿…é¡»æ˜¯åˆ†è§£è´¨å› æ•°ä¹‹åï¼Œ2 å’Œ 5 ç›¸ä¹˜æ‰è¡Œï¼ŒåŒæ—¶å› æ•°åˆ†è§£ä¹‹åå‘ç° 5 çš„ä¸ªæ•°è¿œå°äº 2ï¼Œ
å› æ­¤æˆ‘ä»¬åªéœ€è¦æ±‚è§£è¿™ n æ•°å­—åˆ†è§£è´¨å› æ•°ä¹‹åä¸€å…±æœ‰å¤šå°‘ä¸ª 5 å³å¯.

![172.factorial-trailing-zeroes-2](../assets/problems/172.factorial-trailing-zeroes-2.png)

å¦‚å›¾å¦‚æœ n ä¸º 30ï¼Œé‚£ä¹ˆç»“æœåº”è¯¥æ˜¯å›¾ä¸­çº¢è‰² 5 çš„ä¸ªæ•°ï¼Œå³ 7ã€‚

![172.factorial-trailing-zeroes-1](../assets/problems/172.factorial-trailing-zeroes-1.png)

æˆ‘ä»¬çš„ç»“æœå¹¶ä¸æ˜¯ç›´æ¥ f(n) = n / 5, æ¯”å¦‚ n ä¸º 30ï¼Œ 25 ä¸­æ˜¯æœ‰ä¸¤ä¸ª 5 çš„ã€‚
ç±»ä¼¼ï¼Œn ä¸º 150ï¼Œä¼šæœ‰ 7 ä¸ªè¿™æ ·çš„æ•°å­—ï¼Œé€šè¿‡è§‚å¯Ÿæˆ‘ä»¬å‘ç°è§„å¾‹`f(n) = n/5 + n/5^2 + n/5^3 + n/5^4 + n/5^5+..`

![172.factorial-trailing-zeroes-3](../assets/problems/172.factorial-trailing-zeroes-3.png)

å¦‚æœå¯ä»¥å‘ç°ä¸Šé¢çš„è§„å¾‹ï¼Œç”¨é€’å½’è¿˜æ˜¯å¾ªç¯å®ç°è¿™ä¸ªç®—å¼å°±çœ‹ä½ çš„äº†ã€‚

#### å…³é”®ç‚¹è§£æ

- æ•°è®º

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=172 lang=javascript
 *
 * [172] Factorial Trailing Zeroes
 */
/**
 * @param {number} n
 * @return {number}
 */
var trailingZeroes = function(n) {
  // tag: æ•°è®º

  // if (n === 0) return n;

  // é€’å½’ï¼š f(n) = n / 5 + f(n / 5)
  // return Math.floor(n / 5)  + trailingZeroes(Math.floor(n / 5));
  let count = 0;
  while (n >= 5) {
    count += Math.floor(n / 5);
    n = Math.floor(n / 5);
  }
  return count;
};
```

### [19].removeNthNodeFromEndofList

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/remove-nth-node-from-end-of-list/description

#### é¢˜ç›®æè¿°

Given a linked list, remove the n-th node from the end of list and return its head.

Example:

Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?

#### æ€è·¯

åŒæŒ‡é’ˆï¼ŒæŒ‡é’ˆ A å…ˆç§»åŠ¨ n æ¬¡ï¼Œ æŒ‡é’ˆ B å†å¼€å§‹ç§»åŠ¨ã€‚å½“ A åˆ°è¾¾ null çš„æ—¶å€™ï¼Œ æŒ‡é’ˆ b çš„ä½ç½®æ­£å¥½æ˜¯å€’æ•° n

æˆ‘ä»¬å¯ä»¥è®¾æƒ³å‡è®¾è®¾å®šäº†åŒæŒ‡é’ˆ p å’Œ q çš„è¯ï¼Œå½“ q æŒ‡å‘æœ«å°¾çš„ NULLï¼Œp ä¸ q ä¹‹é—´ç›¸éš”çš„å…ƒç´ ä¸ªæ•°ä¸º n æ—¶ï¼Œé‚£ä¹ˆåˆ é™¤æ‰ p çš„ä¸‹ä¸€ä¸ªæŒ‡é’ˆå°±å®Œæˆäº†è¦æ±‚ã€‚

è®¾ç½®è™šæ‹ŸèŠ‚ç‚¹ dummyHead æŒ‡å‘ head

è®¾å®šåŒæŒ‡é’ˆ p å’Œ qï¼Œåˆå§‹éƒ½æŒ‡å‘è™šæ‹ŸèŠ‚ç‚¹ dummyHead

ç§»åŠ¨ qï¼Œç›´åˆ° p ä¸ q ä¹‹é—´ç›¸éš”çš„å…ƒç´ ä¸ªæ•°ä¸º n

åŒæ—¶ç§»åŠ¨ p ä¸ qï¼Œç›´åˆ° q æŒ‡å‘çš„ä¸º NULL

å°† p çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸‹ä¸ªèŠ‚ç‚¹

![19.removeNthNodeFromEndOfList](../assets/19.removeNthNodeFromEndOfList.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

#### å…³é”®ç‚¹è§£æ

1. é“¾è¡¨è¿™ç§æ•°æ®ç»“æ„çš„ç‰¹ç‚¹å’Œä½¿ç”¨

2. ä½¿ç”¨åŒæŒ‡é’ˆ

3. ä½¿ç”¨ä¸€ä¸ª dummyHead ç®€åŒ–æ“ä½œ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=19 lang=javascript
 *
 * [19] Remove Nth Node From End of List
 *
 * https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/
 *
 * algorithms
 * Medium (34.03%)
 * Total Accepted:    360.1K
 * Total Submissions: 1.1M
 * Testcase Example:  '[1,2,3,4,5]\n2'
 *
 * Given a linked list, remove the n-th node from the end of list and return
 * its head.
 *
 * Example:
 *
 *
 * Given linked list: 1->2->3->4->5, and n = 2.
 *
 * After removing the second node from the end, the linked list becomes
 * 1->2->3->5.
 *
 *
 * Note:
 *
 * Given n will always be valid.
 *
 * Follow up:
 *
 * Could you do this in one pass?
 *
 */

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let i = -1;
  const noop = {
    next: null,
  };

  const dummyHead = new ListNode(); // å¢åŠ ä¸€ä¸ªdummyHead ç®€åŒ–æ“ä½œ
  dummyHead.next = head;

  let currentP1 = dummyHead;
  let currentP2 = dummyHead;

  while (currentP1) {
    if (i === n) {
      currentP2 = currentP2.next;
    }

    if (i !== n) {
      i++;
    }

    currentP1 = currentP1.next;
  }

  currentP2.next = ((currentP2 || noop).next || noop).next;

  return dummyHead.next;
};
```

### [190].reverse-bits

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/reverse-bits/description/

#### é¢˜ç›®æè¿°

```
Reverse bits of a given 32 bits unsigned integer.



Example 1:

Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
Example 2:

Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.


Note:

Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.

```

#### æ€è·¯

è¿™é“é¢˜æ˜¯ç»™å®šä¸€ä¸ª 32 ä½çš„æ— ç¬¦å·æ•´å‹ï¼Œè®©ä½ æŒ‰ä½ç¿»è½¬ï¼Œ ç¬¬ä¸€ä½å˜æˆæœ€åä¸€ä½ï¼Œ ç¬¬äºŒä½å˜æˆå€’æ•°ç¬¬äºŒä½ã€‚ã€‚ã€‚

é‚£ä¹ˆæ€è·¯å°±æ˜¯`åŒæŒ‡é’ˆ`

> è¿™ä¸ªæŒ‡é’ˆå¯ä»¥åŠ å¼•å·

- n ä»é«˜ä½å¼€å§‹é€æ­¥å·¦ï¼Œ res ä»ä½ä½(0)å¼€å§‹é€æ­¥å³ç§»
- é€æ­¥åˆ¤æ–­ï¼Œå¦‚æœè¯¥ä½æ˜¯ 1ï¼Œå°± res + 1 , å¦‚æœæ˜¯è¯¥ä½æ˜¯ 0ï¼Œ å°± res + 0
- 32 ä½å…¨éƒ¨éå†å®Œï¼Œåˆ™éå†ç»“æŸ

#### å…³é”®ç‚¹è§£æ

1. å¯ä»¥ç”¨ä»»ä½•æ•°å­—å’Œ 1 è¿›è¡Œä½è¿ç®—çš„ç»“æœéƒ½å–å†³äºè¯¥æ•°å­—æœ€åä¸€ä½çš„ç‰¹æ€§ç®€åŒ–æ“ä½œå’Œæé«˜æ€§èƒ½

eg :

- n & 1 === 1, è¯´æ˜ n çš„æœ€åä¸€ä½æ˜¯ 1
- n & 1 === 0, è¯´æ˜ n çš„æœ€åä¸€ä½æ˜¯ 0

2. å¯¹äº JSï¼ŒES è§„èŒƒåœ¨ä¹‹å‰å¾ˆå¤šç‰ˆæœ¬éƒ½æ˜¯æ²¡æœ‰æ— ç¬¦å·æ•´å½¢çš„ï¼Œ è½¬åŒ–ä¸ºæ— ç¬¦å·ï¼Œå¯ä»¥ç”¨ä¸€ä¸ª trick`n >>> 0`

3. åŒ"æŒ‡é’ˆ" æ¨¡å‹

4. bit è¿ç®—

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=190 lang=javascript
 *
 * [190] Reverse Bits
 *
 * https://leetcode.com/problems/reverse-bits/description/
 *
 * algorithms
 * Easy (30.30%)
 * Total Accepted:    173.7K
 * Total Submissions: 568.2K
 * Testcase Example:  '00000010100101000001111010011100'
 *
 * Reverse bits of a given 32 bits unsigned integer.
 *
 *
 *
 * Example 1:
 *
 *
 * Input: 00000010100101000001111010011100
 * Output: 00111001011110000010100101000000
 * Explanation: The input binary string 00000010100101000001111010011100
 * represents the unsigned integer 43261596, so return 964176192 which its
 * binary representation is 00111001011110000010100101000000.
 *
 *
 * Example 2:
 *
 *
 * Input: 11111111111111111111111111111101
 * Output: 10111111111111111111111111111111
 * Explanation: The input binary string 11111111111111111111111111111101
 * represents the unsigned integer 4294967293, so return 3221225471 which its
 * binary representation is 10101111110010110010011101101001.
 *
 *
 *
 * Note:
 *
 *
 * Note that in some languages such as Java, there is no unsigned integer type.
 * In this case, both input and output will be given as signed integer type and
 * should not affect your implementation, as the internal binary representation
 * of the integer is the same whether it is signed or unsigned.
 * In Java,Â the compiler represents the signed integers using 2's complement
 * notation. Therefore, in Example 2Â above the input represents the signed
 * integer -3Â and the output represents the signed integer -1073741825.
 *
 *
 *
 *
 * Follow up:
 *
 * If this function is called many times, how would you optimize it?
 *
 */
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
  let res = 0;
  for (let i = 0; i < 32; i++) {
    res = (res << 1) + (n & 1);
    n = n >>> 1;
  }

  return res >>> 0;
};
```

### [191].number-of-1-bits

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/number-of-1-bits/description/

#### é¢˜ç›®æè¿°

```
Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight).



Example 1:

Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
Example 2:

Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
Example 3:

Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.


Note:

Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3 above the input represents the signed integer -3.

```

#### æ€è·¯

è¿™ä¸ªé¢˜ç›®çš„å¤§æ„æ˜¯ï¼š ç»™å®šä¸€ä¸ªæ— ç¬¦å·çš„æ•´æ•°ï¼Œ è¿”å›å…¶ç”¨äºŒè¿›åˆ¶è¡¨å¼çš„æ—¶å€™çš„ 1 çš„ä¸ªæ•°ã€‚

è¿™é‡Œç”¨ä¸€ä¸ª trickï¼Œ å¯ä»¥è½»æ¾æ±‚å‡ºã€‚ å°±æ˜¯`n & (n - 1)` å¯ä»¥`æ¶ˆé™¤` n æœ€åçš„ä¸€ä¸ª 1 çš„åŸç†ã€‚

> ä¸ºä»€ä¹ˆèƒ½æ¶ˆé™¤æœ€åä¸€ä¸ª 1ï¼Œ å…¶å®ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œå¤§å®¶è‡ªå·±æƒ³ä¸€ä¸‹

è¿™æ ·æˆ‘ä»¬å¯ä»¥ä¸æ–­è¿›è¡Œ`n = n & (n - 1)`ç›´åˆ° n === 0 ï¼Œ è¯´æ˜æ²¡æœ‰ä¸€ä¸ª 1 äº†ã€‚
è¿™ä¸ªæ—¶å€™`æˆ‘ä»¬æ¶ˆé™¤äº†å¤šå°‘1å˜æˆä¸€ä¸ª1éƒ½æ²¡æœ‰äº†ï¼Œ å°±è¯´æ˜næœ‰å¤šå°‘ä¸ª1äº†`ã€‚

#### å…³é”®ç‚¹è§£æ

1. `n & (n - 1)` å¯ä»¥`æ¶ˆé™¤` n æœ€åçš„ä¸€ä¸ª 1 çš„åŸç† ç®€åŒ–æ“ä½œ

2. bit è¿ç®—

#### ä»£ç 

è¯­è¨€æ”¯æŒï¼šJS, C++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=191 lang=javascript
 *
 * [191] Number of 1 Bits
 *
 * https://leetcode.com/problems/number-of-1-bits/description/
 *
 * algorithms
 * Easy (42.10%)
 * Total Accepted:    247.4K
 * Total Submissions: 583.3K
 * Testcase Example:  '00000000000000000000000000001011'
 *
 * Write a function that takes an unsigned integer and returnÂ the number of '1'
 * bits it has (also known as the Hamming weight).
 *
 *
 *
 * Example 1:
 *
 *
 * Input: 00000000000000000000000000001011
 * Output: 3
 * Explanation: The input binary string 00000000000000000000000000001011Â has a
 * total of three '1' bits.
 *
 *
 * Example 2:
 *
 *
 * Input: 00000000000000000000000010000000
 * Output: 1
 * Explanation: The input binary string 00000000000000000000000010000000Â has a
 * total of one '1' bit.
 *
 *
 * Example 3:
 *
 *
 * Input: 11111111111111111111111111111101
 * Output: 31
 * Explanation: The input binary string 11111111111111111111111111111101 has a
 * total of thirty one '1' bits.
 *
 *
 *
 * Note:
 *
 *
 * Note that in some languages such as Java, there is no unsigned integer type.
 * In this case, the input will be given as signed integer type and should not
 * affect your implementation, as the internal binary representation of the
 * integer is the same whether it is signed or unsigned.
 * In Java,Â the compiler represents the signed integers using 2's complement
 * notation. Therefore, in Example 3Â above the input represents the signed
 * integer -3.
 *
 *
 *
 *
 * Follow up:
 *
 * If this function is called many times, how would you optimize it?
 *
 */
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  let count = 0;
  while (n !== 0) {
    n = n & (n - 1);
    count++;
  }

  return count;
};
```

C++ code:

```
class Solution {
public:
    int hammingWeight(uint32_t v) {
        auto count = 0;
        while (v != 0) {
            v &= (v - 1);
            ++count;
        }
        return count;
    }
};
```

#### æ‰©å±•

å¯ä»¥ä½¿ç”¨ä½æ“ä½œæ¥è¾¾åˆ°ç›®çš„ã€‚ä¾‹å¦‚ 8 ä½çš„æ•´æ•° 21:

![number-of-1-bits](../assets/problems/191.number-of-1-bits.png)

### [198].house-robber

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/house-robber/description/

#### é¢˜ç›®æè¿°

```
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“éå¸¸å…¸å‹ä¸”ç®€å•çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œä½†æ˜¯åœ¨è¿™é‡Œæˆ‘å¸Œæœ›é€šè¿‡è¿™ä¸ªä¾‹å­ï¼Œ
è®©å¤§å®¶å¯¹åŠ¨æ€è§„åˆ’é—®é¢˜æœ‰ä¸€ç‚¹è®¤è¯†ã€‚

ä¸ºä»€ä¹ˆåˆ«äººçš„åŠ¨æ€è§„åˆ’å¯ä»¥é‚£ä¹ˆå†™ï¼Œä¸ºä»€ä¹ˆæ²¡æœ‰ç”¨ dp æ•°ç»„å°±æå®šäº†ã€‚
æ¯”å¦‚åˆ«äººçš„çˆ¬æ¥¼æ¢¯é—®é¢˜æ€ä¹ˆå°±ç”¨ fibnacci æå®šäº†ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿåœ¨è¿™é‡Œæˆ‘ä»¬å°±æ¥çœ‹ä¸‹ã€‚

æ€è·¯è¿˜æ˜¯å’Œå…¶ä»–ç®€å•çš„åŠ¨æ€è§„åˆ’é—®é¢˜ä¸€æ ·ï¼Œæˆ‘ä»¬æœ¬è´¨ä¸Šåœ¨è§£å†³`å¯¹äºç¬¬[i] ä¸ªæˆ¿å­ï¼Œæˆ‘ä»¬æŠ¢è¿˜æ˜¯ä¸æŠ¢ã€‚`çš„é—®é¢˜ã€‚

åˆ¤æ–­çš„æ ‡å‡†å°±æ˜¯æ€»ä»·å€¼å“ªä¸ªæ›´å¤§ï¼Œ é‚£ä¹ˆå¯¹äºæŠ¢çš„è¯`å°±æ˜¯å½“å‰çš„æˆ¿å­å¯ä»¥æŠ¢çš„ä»·å€¼ + dp[i - 2]`

> i - 1 ä¸èƒ½æŠ¢ï¼Œå¦åˆ™ä¼šè§¦å‘è­¦é“ƒ

å¦‚æœä¸æŠ¢çš„è¯ï¼Œå°±æ˜¯`dp[i - 1]`.

> è¿™é‡Œçš„ dp å…¶å®å°±æ˜¯`å­é—®é¢˜`.

çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿä¸éš¾å†™`dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);`.

ä¸Šè¿°è¿‡ç¨‹ç”¨å›¾æ¥è¡¨ç¤ºçš„è¯ï¼Œæ˜¯è¿™æ ·çš„ï¼š

![198.house-robber](../assets/problems/198.house-robber.png)

æˆ‘ä»¬ä»”ç»†è§‚å¯Ÿçš„è¯ï¼Œå…¶å®æˆ‘ä»¬åªéœ€è¦ä¿è¯å‰ä¸€ä¸ª dp[i - 1] å’Œ dp[i - 2] ä¸¤ä¸ªå˜é‡å°±å¥½äº†ï¼Œ
æ¯”å¦‚æˆ‘ä»¬è®¡ç®—åˆ° i = 6 çš„æ—¶å€™ï¼Œå³éœ€è¦è®¡ç®— dp[6]çš„æ—¶å€™ï¼Œ æˆ‘ä»¬éœ€è¦ dp[5], dp[4]ï¼Œä½†æ˜¯æˆ‘ä»¬
ä¸éœ€è¦ dp[3], dp[2] ...

å› æ­¤ä»£ç å¯ä»¥ç®€åŒ–ä¸ºï¼š

```js
let a = 0;
let b = 0;

for (let i = 0; i < nums.length; i++) {
  const temp = b;
  b = Math.max(a + nums[i], b);
  a = temp;
}

return b;
```

å¦‚ä¸Šçš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¤æ‚åº¦è¿›è¡Œä¼˜åŒ–ï¼Œä» O(n)é™ä½åˆ° O(1),
ç±»ä¼¼çš„ä¼˜åŒ–åœ¨ DP é—®é¢˜ä¸­ä¸åœ¨å°‘æ•°ã€‚

> åŠ¨æ€è§„åˆ’é—®é¢˜æ˜¯é€’å½’é—®é¢˜æŸ¥è¡¨ï¼Œé¿å…é‡å¤è®¡ç®—ï¼Œä»è€ŒèŠ‚çœæ—¶é—´ã€‚
> å¦‚æœæˆ‘ä»¬å¯¹é—®é¢˜åŠ ä»¥åˆ†æå’ŒæŠ½è±¡ï¼Œæœ‰å¯èƒ½å¯¹ç©ºé—´ä¸Šè¿›ä¸€æ­¥ä¼˜åŒ–

#### å…³é”®ç‚¹è§£æ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=198 lang=javascript
 *
 * [198] House Robber
 *
 * https://leetcode.com/problems/house-robber/description/
 *
 * algorithms
 * Easy (40.80%)
 * Total Accepted:    312.1K
 * Total Submissions: 762.4K
 * Testcase Example:  '[1,2,3,1]'
 *
 * You are a professional robber planning to rob houses along a street. Each
 * house has a certain amount of money stashed, the only constraint stopping
 * you from robbing each of them is that adjacent houses have security system
 * connected and it will automatically contact the police if two adjacent
 * houses were broken into on the same night.
 *
 * Given a list of non-negative integers representing the amount of money of
 * each house, determine the maximum amount of money you can rob tonight
 * without alerting the police.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,1]
 * Output: 4
 * Explanation: Rob house 1 (money = 1) and then rob house 3 (money =
 * 3).
 * Total amount you can rob = 1 + 3 = 4.
 *
 * Example 2:
 *
 *
 * Input: [2,7,9,3,1]
 * Output: 12
 * Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house
 * 5 (money = 1).
 * Total amount you can rob = 2 + 9 + 1 = 12.
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  // Tag: DP
  const dp = [];
  dp[0] = 0;
  dp[1] = 0;

  for (let i = 2; i < nums.length + 2; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);
  }

  return dp[nums.length + 1];
};
```

### [199].binary-tree-right-side-view

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/binary-tree-right-side-view/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

Example:

Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

#### æ€è·¯

> è¿™é“é¢˜å’Œ leetcode 102 å·é—®é¢˜ã€Š102.binary-tree-level-order-traversalã€‹å¾ˆåƒ

è¿™é“é¢˜å¯ä»¥å€ŸåŠ©`é˜Ÿåˆ—`å®ç°ï¼Œé¦–å…ˆæŠŠ root å…¥é˜Ÿï¼Œç„¶åå…¥é˜Ÿä¸€ä¸ªç‰¹æ®Šå…ƒç´  Null(æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸ)ã€‚

ç„¶åå°±æ˜¯ while(queue.length), æ¯æ¬¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å­èŠ‚ç‚¹(åœ¨è¿™é‡Œæ˜¯ left å’Œ right)æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚

ç„¶åä¸æ–­çš„å‡ºé˜Ÿï¼Œ å¦‚æœå‡ºé˜Ÿçš„æ˜¯ nullï¼Œåˆ™è¡¨å¼è¿™ä¸€å±‚å·²ç»ç»“æŸäº†ï¼Œæˆ‘ä»¬å°±ç»§ç»­ push ä¸€ä¸ª nullã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

- äºŒå‰æ ‘çš„å³è§†å›¾å¯ä»¥çœ‹ä½œæ˜¯å±‚æ¬¡éå†æ¯æ¬¡åªå–æ¯ä¸€å±‚çš„æœ€å³è¾¹çš„å…ƒç´ 

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

Javascript Code:

```js
/*
 * @lc app=leetcode id=199 lang=javascript
 *
 * [199] Binary Tree Right Side View
 *
 * https://leetcode.com/problems/binary-tree-right-side-view/description/
 *
 * algorithms
 * Medium (46.74%)
 * Total Accepted:    156.1K
 * Total Submissions: 332.3K
 * Testcase Example:  '[1,2,3,null,5,null,4]'
 *
 * Given a binary tree, imagine yourself standing on the right side of it,
 * return the values of the nodes you can see ordered from top to bottom.
 *
 * Example:
 *
 *
 * Input:Â [1,2,3,null,5,null,4]
 * Output:Â [1, 3, 4]
 * Explanation:
 *
 * â   1            <---
 * â /   \
 * 2     3         <---
 * â \     \
 * â  5     4       <---
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
  if (!root) return [];

  const ret = [];
  const queue = [root, null];

  let levelNodes = [];

  while (queue.length > 0) {
    const node = queue.shift();
    if (node !== null) {
      levelNodes.push(node.val);
      if (node.right) {
        queue.push(node.right);
      }
      if (node.left) {
        queue.push(node.left);
      }
    } else {
      // ä¸€å±‚éå†å·²ç»ç»“æŸ
      ret.push(levelNodes[0]);
      if (queue.length > 0) {
        queue.push(null);
      }
      levelNodes = [];
    }
  }

  return ret;
};
```

C++ Code:

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        auto ret = vector<int>();
        if (root == nullptr) return ret;
        auto q = queue<const TreeNode*>();
        q.push(root);
        while (!q.empty()) {
            auto sz = q.size();
            for (auto i = 0; i < sz; ++i) {
                auto n = q.front();
                q.pop();
                if (n->left != nullptr ) q.push(n->left);
                if (n->right != nullptr ) q.push(n->right);
                if (i == sz - 1) ret.push_back(n->val);
            }
        }
        return ret;
    }
};
```

#### æ‰©å±•

å‡å¦‚é¢˜ç›®å˜æˆæ±‚äºŒå‰æ ‘çš„å·¦è§†å›¾å‘¢ï¼Ÿ

å¾ˆç®€å•æˆ‘ä»¬åªéœ€è¦å– queue çš„æœ€åä¸€ä¸ªå…ƒç´ å³å¯ã€‚ æˆ–è€…å­˜çš„æ—¶å€™åç€æ¥ä¹Ÿè¡Œ

> å…¶å®æˆ‘ä»¬æ²¡å¿…è¦å­˜å‚¨ levelNodesï¼Œè€Œæ˜¯åªå­˜å‚¨æ¯ä¸€å±‚æœ€å³çš„å…ƒç´ ï¼Œè¿™æ ·ç©ºé—´å¤æ‚åº¦å°±ä¸æ˜¯ n äº†ï¼Œ å°±æ˜¯ logn äº†ã€‚

### [2].addTwoNumbers

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/add-two-numbers/description/

#### é¢˜ç›®æè¿°

```
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.

```

#### æ€è·¯

è®¾ç«‹ä¸€ä¸ªè¡¨ç¤ºè¿›ä½çš„å˜é‡ carriedï¼Œå»ºç«‹ä¸€ä¸ªæ–°é“¾è¡¨ï¼Œ
æŠŠè¾“å…¥çš„ä¸¤ä¸ªé“¾è¡¨ä»å¤´å¾€ååŒæ—¶å¤„ç†ï¼Œæ¯ä¸¤ä¸ªç›¸åŠ ï¼Œå°†ç»“æœåŠ ä¸Š carried åçš„å€¼ä½œä¸ºä¸€ä¸ªæ–°èŠ‚ç‚¹åˆ°æ–°é“¾è¡¨åé¢ã€‚

![2.addTwoNumbers](../assets/2.addTwoNumbers.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

#### å…³é”®ç‚¹è§£æ

1. é“¾è¡¨è¿™ç§æ•°æ®ç»“æ„çš„ç‰¹ç‚¹å’Œä½¿ç”¨

2. ç”¨ä¸€ä¸ª carried å˜é‡æ¥å®ç°è¿›ä½çš„åŠŸèƒ½ï¼Œæ¯æ¬¡ç›¸åŠ ä¹‹åè®¡ç®— carriedï¼Œå¹¶ç”¨äºä¸‹ä¸€ä½çš„è®¡ç®—

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript:

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  var carried = 0; // ç”¨äºè¿›ä½
  const head = new ListNode();
  const noop = {
    val: 0,
    next: null,
  };
  let currentL1 = l1;
  let currentL2 = l2;
  let currentNode = head; // è¿”å›çš„é“¾è¡¨çš„å½“å‰node
  let newNode; // å£°æ˜åœ¨å¤–é¢èŠ‚çœå†…å­˜
  let previousNode; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¾¿äºåˆ é™¤æœ€åä¸€ä¸ªèŠ‚ç‚¹

  while (currentL1 || currentL2) {
    newNode = new ListNode(0);

    currentNode.val = ((currentL1 || noop).val + (currentL2 || noop).val + carried) % 10;

    currentNode.next = newNode;
    previousNode = currentNode;
    currentNode = newNode;

    if ((currentL1 || noop).val + (currentL2 || noop).val + carried >= 10) {
      carried = 1;
    } else {
      carried = 0;
    }

    currentL1 = (currentL1 || noop).next;
    currentL2 = (currentL2 || noop).next;
  }

  if (carried) {
    // è¿˜æœ‰ä½æ²¡è¿›å‘¢
    previousNode.next = new ListNode(carried);
  } else {
    previousNode.next = null;
  }

  return head;
};
```

C++

> C++ä»£ç ä¸ä¸Šé¢çš„ JavaScript ä»£ç ç•¥æœ‰ä¸åŒï¼šå°† carry æ˜¯å¦ä¸º 0 çš„åˆ¤æ–­æ”¾åˆ°äº† while å¾ªç¯ä¸­

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* ret = nullptr;
        ListNode* cur = nullptr;
        int carry = 0;
        while (l1 != nullptr || l2 != nullptr || carry != 0) {
            carry += (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val);
            auto temp = new ListNode(carry % 10);
            carry /= 10;
            if (ret == nullptr) {
                ret = temp;
                cur = ret;
            }
            else {
                cur->next = temp;
                cur = cur->next;
            }
            l1 = l1 == nullptr ? nullptr : l1->next;
            l2 = l2 == nullptr ? nullptr : l2->next;
        }
        return ret;
    }
};
```

#### æ‹“å±•

é€šè¿‡å•é“¾è¡¨çš„å®šä¹‰å¯ä»¥å¾—çŸ¥ï¼Œå•é“¾è¡¨ä¹Ÿæ˜¯é€’å½’ç»“æ„ï¼Œå› æ­¤ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨é€’å½’çš„æ–¹å¼æ¥è¿›è¡Œ reverse æ“ä½œã€‚

> ç”±äºå•é“¾è¡¨æ˜¯çº¿æ€§çš„ï¼Œä½¿ç”¨é€’å½’æ–¹å¼å°†å¯¼è‡´æ ˆçš„ä½¿ç”¨ä¹Ÿæ˜¯çº¿æ€§çš„ï¼Œå½“é“¾è¡¨é•¿åº¦è¾¾åˆ°ä¸€å®šç¨‹åº¦æ—¶ï¼Œé€’å½’ä¼šå¯¼è‡´çˆ†æ ˆï¼Œå› æ­¤ï¼Œç°å®ä¸­å¹¶ä¸æ¨èä½¿ç”¨é€’å½’æ–¹å¼æ¥æ“ä½œé“¾è¡¨ã€‚

##### æè¿°

1. å°†ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼ç›¸åŠ ï¼Œç»“æœè½¬ä¸º 0-10 ä¹‹é—´çš„ä¸ªä½æ•°ï¼Œå¹¶è®¾ç½®è¿›ä½ä¿¡æ¯
2. å°†ä¸¤ä¸ªé“¾è¡¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä»¥åçš„é“¾è¡¨åšå¸¦è¿›ä½çš„é€’å½’ç›¸åŠ 
3. å°†ç¬¬ä¸€æ­¥å¾—åˆ°çš„å¤´èŠ‚ç‚¹çš„ next æŒ‡å‘ç¬¬äºŒæ­¥è¿”å›çš„é“¾è¡¨

##### C++å®ç°

```
// æ™®é€šé€’å½’
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        return addTwoNumbers(l1, l2, 0);
    }

private:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2, int carry) {
        if (l1 == nullptr && l2 == nullptr && carry == 0) return nullptr;
        carry += (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val);
        auto ret = new ListNode(carry % 10);
        ret->next = addTwoNumbers(l1 == nullptr ? l1 : l1->next,
                                 l2 == nullptr ? l2 : l2->next,
                                 carry / 10);
        return ret;
    }
};
// (ç±»ä¼¼)å°¾é€’å½’
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = nullptr;
        addTwoNumbers(head, nullptr, l1, l2, 0);
        return head;
    }

private:
    void addTwoNumbers(ListNode*& head, ListNode* cur, ListNode* l1, ListNode* l2, int carry) {
        if (l1 == nullptr && l2 == nullptr && carry == 0) return;
        carry += (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val);
        auto temp = new ListNode(carry % 10);
        if (cur == nullptr) {
            head = temp;
            cur = head;
        } else {
            cur->next = temp;
            cur = cur->next;
        }
        addTwoNumbers(head, cur, l1 == nullptr ? l1 : l1->next, l2 == nullptr ? l2 : l2->next, carry / 10);
    }
};
```

### [20].validParentheses

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/valid-parentheses/description

#### é¢˜ç›®æè¿°

```
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true
```

#### æ€è·¯

å…³äºè¿™é“é¢˜çš„æ€è·¯ï¼Œé‚“ä¿Šè¾‰è®²çš„éå¸¸å¥½ï¼Œæ²¡æœ‰çœ‹è¿‡çš„åŒå­¦å¯ä»¥çœ‹ä¸€ä¸‹, [è§†é¢‘åœ°å€](http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/courseware/ad1a23c053df4501a3facd66ef6ccfa9/8d6f450e7f7a445098ae1d507fda80f6/)ã€‚

ä½¿ç”¨æ ˆ,éå†è¾“å…¥å­—ç¬¦ä¸²

å¦‚æœå½“å‰å­—ç¬¦ä¸ºå·¦åŠè¾¹æ‹¬å·æ—¶ï¼Œåˆ™å°†å…¶å‹å…¥æ ˆä¸­

å¦‚æœé‡åˆ°å³åŠè¾¹æ‹¬å·æ—¶ï¼Œåˆ†ç±»è®¨è®ºï¼š

1)å¦‚æ ˆä¸ä¸ºç©ºä¸”ä¸ºå¯¹åº”çš„å·¦åŠè¾¹æ‹¬å·ï¼Œåˆ™å–å‡ºæ ˆé¡¶å…ƒç´ ï¼Œç»§ç»­å¾ªç¯

2)è‹¥æ­¤æ—¶æ ˆä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å› false

3)è‹¥ä¸ä¸ºå¯¹åº”çš„å·¦åŠè¾¹æ‹¬å·ï¼Œåä¹‹è¿”å› false

![20.validParentheses](../assets/20.validParentheses.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

> å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœé¢˜ç›®è¦æ±‚åªæœ‰ä¸€ç§æ‹¬å·ï¼Œé‚£ä¹ˆæˆ‘ä»¬å…¶å®å¯ä»¥ä½¿ç”¨æ›´ç®€æ´ï¼Œæ›´çœå†…å­˜çš„æ–¹å¼ - è®¡æ•°å™¨æ¥è¿›è¡Œæ±‚è§£ï¼Œè€Œ
> ä¸å¿…è¦ä½¿ç”¨æ ˆã€‚

> äº‹å®ä¸Šï¼Œè¿™ç±»é—®é¢˜è¿˜å¯ä»¥è¿›ä¸€æ­¥æ‰©å±•ï¼Œæˆ‘ä»¬å¯ä»¥å»è§£æç±»ä¼¼ HTML ç­‰æ ‡è®°è¯­æ³•ï¼Œ æ¯”å¦‚ <p></p> <body></body>

#### å…³é”®ç‚¹è§£æ

1. æ ˆçš„åŸºæœ¬ç‰¹ç‚¹å’Œæ“ä½œ
2. å¦‚æœä½ ç”¨çš„æ˜¯ JS æ²¡æœ‰ç°æˆçš„æ ˆï¼Œå¯ä»¥ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿ
   å…¥ï¼š push å‡º: pop

> å…¥ï¼š push å‡º shift å°±æ˜¯é˜Ÿåˆ—

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒPython

Javascript Code:

```js
/*
 * @lc app=leetcode id=20 lang=javascript
 *
 * [20] Valid Parentheses
 *
 * https://leetcode.com/problems/valid-parentheses/description/
 *
 * algorithms
 * Easy (35.97%)
 * Total Accepted:    530.2K
 * Total Submissions: 1.5M
 * Testcase Example:  '"()"'
 *
 * Given a string containing just the characters '(', ')', '{', '}', '[' and
 * ']', determine if the input string is valid.
 *
 * An input string is valid if:
 *
 *
 * Open brackets must be closed by the same type of brackets.
 * Open brackets must be closed in the correct order.
 *
 *
 * Note that an empty string isÂ also considered valid.
 *
 * Example 1:
 *
 *
 * Input: "()"
 * Output: true
 *
 *
 * Example 2:
 *
 *
 * Input: "()[]{}"
 * Output: true
 *
 *
 * Example 3:
 *
 *
 * Input: "(]"
 * Output: false
 *
 *
 * Example 4:
 *
 *
 * Input: "([)]"
 * Output: false
 *
 *
 * Example 5:
 *
 *
 * Input: "{[]}"
 * Output: true
 *
 *
 */
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  let valid = true;
  const stack = [];
  const mapper = {
    '{': '}',
    '[': ']',
    '(': ')',
  };

  for (let i in s) {
    const v = s[i];
    if (['(', '[', '{'].indexOf(v) > -1) {
      stack.push(v);
    } else {
      const peak = stack.pop();
      if (v !== mapper[peak]) {
        return false;
      }
    }
  }

  if (stack.length > 0) return false;

  return valid;
};
```

Python Code:

```
    class Solution:
        def isValid(self,s):
          stack = []
          map = {
            "{":"}",
            "[":"]",
            "(":")"
          }
          for x in s:
            if x in map:
              stack.append(map[x])
            else:
              if len(stack)!=0:
                top_element = stack.pop()
                if x != top_element:
                  return False
                else:
                  continue
              else:
                return False
          return len(stack) == 0
```

#### æ‰©å±•

å¦‚æœè®©ä½ æ£€æŸ¥ XML æ ‡ç­¾æ˜¯å¦é—­åˆå¦‚ä½•æ£€æŸ¥ï¼Œ æ›´è¿›ä¸€æ­¥å¦‚æœè¦ä½ å®ç°ä¸€ä¸ªç®€å•çš„ XML çš„è§£æå™¨ï¼Œåº”è¯¥æ€ä¹ˆå®ç°ï¼Ÿ

### [201].bitwise-and-of-numbers-range

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/bitwise-and-of-numbers-range/description/

#### é¢˜ç›®æè¿°

```
Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

Example 1:

Input: [5,7]
Output: 4
Example 2:

Input: [0,1]
Output: 0

```

#### æ€è·¯

ä¸€ä¸ªæ˜¾è€Œæ˜“è§çš„è§£æ³•æ˜¯ï¼Œ ä» m åˆ° n ä¾æ¬¡è¿›è¡Œ`æ±‚ä¸`çš„æ“ä½œã€‚

```js
let res = m;
for (let i = m + 1; i <= n; i++) {
  res = res & i;
}
return res;
```

ä½†æ˜¯ï¼Œ å¦‚æœä½ æŠŠè¿™ä¸ª solution æäº¤çš„è¯ï¼Œå¾ˆæ˜¾ç„¶ä¸ä¼šé€šè¿‡ï¼Œ ä¼šè¶…æ—¶ã€‚

æˆ‘ä»¬ä¾æ—§è¿˜æ˜¯ç”¨ trick æ¥ç®€åŒ–æ“ä½œã€‚ æˆ‘ä»¬åˆ©ç”¨çš„æ€§è´¨æ˜¯ï¼Œ n ä¸ªè¿ç»­æ•°å­—æ±‚ä¸çš„æ—¶å€™ï¼Œå‰ m ä½éƒ½æ˜¯ 1.

ä¸¾é¢˜ç›®ç»™çš„ä¾‹å­ï¼š[5,7] å…± 5ï¼Œ 6ï¼Œ7 ä¸‰ä¸ªæ•°å­—ï¼Œ ç”¨äºŒè¿›åˆ¶è¡¨ç¤º 101, 110,111,
è¿™ä¸‰ä¸ªæ•°å­—ç‰¹ç‚¹æ˜¯ç¬¬ä¸€ä½éƒ½æ˜¯ 1ï¼Œåé¢å‡ ä½æ±‚ä¸ä¸€å®šæ˜¯ 0.

å†æ¥ä¸€ä¸ªæ˜æ˜¾çš„ä¾‹å­ï¼š[20, 24], å…± 20ï¼Œ 21ï¼Œ 22ï¼Œ 23ï¼Œ24 äº”ä¸ªæ•°å­—ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºå°±æ˜¯

```
0001 0100
0001 0101
0001 0110
0001 0111
0001 1000
```

è¿™äº”ä¸ªæ•°å­—ç‰¹ç‚¹æ˜¯ç¬¬å››ä½éƒ½æ˜¯ 1ï¼Œåé¢å‡ ä½æ±‚ä¸ä¸€å®šæ˜¯ 0.

å› æ­¤æˆ‘ä»¬çš„æ€è·¯å°±æ˜¯ï¼Œ æ±‚å‡ºè¿™ä¸ªæ•°å­—åŒºé—´çš„æ•°å­—å‰å¤šå°‘ä½éƒ½æ˜¯ 1 äº†ï¼Œé‚£ä¹ˆä»–ä»¬æ±‚ä¸çš„ç»“æœä¸€å®šæ˜¯å‰å‡ ä½æ•°å­—ï¼Œç„¶ååé¢éƒ½æ˜¯ 0.

#### å…³é”®ç‚¹è§£æ

- n ä¸ªè¿ç»­æ•°å­—æ±‚ä¸çš„æ—¶å€™ï¼Œå‰ m ä½éƒ½æ˜¯ 1

- å¯ä»¥ç”¨é€’å½’å®ç°ï¼Œ ä¸ªäººè®¤ä¸ºæ¯”è¾ƒéš¾æƒ³åˆ°

- bit è¿ç®—

ä»£ç ï¼š

```js
n > m ? rangeBitwiseAnd(m / 2, n / 2) << 1 : m;
```

> æ¯æ¬¡é—®é¢˜è§„æ¨¡ç¼©å°ä¸€åŠï¼Œ è¿™æ˜¯äºŒåˆ†æ³•å—ï¼Ÿ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=201 lang=javascript
 *
 * [201] Bitwise AND of Numbers Range
 *
 * https://leetcode.com/problems/bitwise-and-of-numbers-range/description/
 *
 * algorithms
 * Medium (35.58%)
 * Total Accepted:    78.9K
 * Total Submissions: 221.3K
 * Testcase Example:  '5\n7'
 *
 * Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND
 * of all numbers in this range, inclusive.
 *
 * Example 1:
 *
 *
 * Input: [5,7]
 * Output: 4
 *
 *
 * Example 2:
 *
 *
 * Input: [0,1]
 * Output: 0
 */
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var rangeBitwiseAnd = function(m, n) {
  let count = 0;
  while (m !== n) {
    m = m >> 1;
    n = n >> 1;
    count++;
  }

  return n << count;
};
```

### [203].remove-linked-list-elements

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/remove-linked-list-elements/description/

#### é¢˜ç›®æè¿°

```
Remove all elements from a linked list of integers that have value val.

Example:

Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5

```

#### æ€è·¯

è¿™ä¸ªä¸€ä¸ªé“¾è¡¨åŸºæœ¬æ“ä½œçš„é¢˜ç›®ï¼Œæ€è·¯å°±ä¸å¤šè¯´äº†ã€‚

#### å…³é”®ç‚¹è§£æ

- é“¾è¡¨çš„åŸºæœ¬æ“ä½œ(åˆ é™¤æŒ‡å®šèŠ‚ç‚¹)
- è™šæ‹ŸèŠ‚ç‚¹ dummy ç®€åŒ–æ“ä½œ

> å…¶å®è®¾ç½® dummy èŠ‚ç‚¹å°±æ˜¯ä¸ºäº†å¤„ç†ç‰¹æ®Šä½ç½®(å¤´èŠ‚ç‚¹)ï¼Œè¿™è¿™é“é¢˜å°±æ˜¯å¦‚æœå¤´èŠ‚ç‚¹æ˜¯ç»™å®šçš„éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹å‘¢ï¼Ÿ
> ä¸ºäº†ä¿è¯ä»£ç é€»è¾‘çš„ä¸€è‡´æ€§ï¼Œå³ä¸éœ€è¦ä¸ºå¤´èŠ‚ç‚¹ç‰¹æ®Šå®šåˆ¶é€»è¾‘ï¼Œæ‰é‡‡ç”¨çš„è™šæ‹ŸèŠ‚ç‚¹ã€‚

- å¦‚æœè¿ç»­ä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ˜¯è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œè¿™ä¸ªæƒ…å†µå®¹æ˜“è¢«å¿½ç•¥ã€‚
  eg:

```js
// åªæœ‰ä¸‹ä¸ªèŠ‚ç‚¹ä¸æ˜¯è¦åˆ é™¤çš„èŠ‚ç‚¹æ‰æ›´æ–°current
if (!next || next.val !== val) {
  current = next;
}
```

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=203 lang=javascript
 *
 * [203] Remove Linked List Elements
 *
 * https://leetcode.com/problems/remove-linked-list-elements/description/
 *
 * algorithms
 * Easy (35.32%)
 * Total Accepted:    211.9K
 * Total Submissions: 598.6K
 * Testcase Example:  '[1,2,6,3,4,5,6]\n6'
 *
 * Remove all elements from a linked list of integers that have value val.
 *
 * Example:
 *
 *
 * Input:  1->2->6->3->4->5->6, val = 6
 * Output: 1->2->3->4->5
 *
 *
 */

/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
  const dummy = {
    next: head,
  };
  let current = dummy;

  while (current && current.next) {
    let next = current.next;
    if (next.val === val) {
      current.next = next.next;
      next = next.next;
    }

    if (!next || next.val !== val) {
      current = next;
    }
  }

  return dummy.next;
};
```

### [206].reverse-linked-list

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/reverse-linked-list/description/

#### é¢˜ç›®æè¿°

Reverse a singly linked list.

Example:

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
Follow up:

A linked list can be reversed either iteratively or recursively. Could you implement both?

#### æ€è·¯

è¿™ä¸ªå°±æ˜¯å¸¸è§„æ“ä½œäº†ï¼Œä½¿ç”¨ä¸€ä¸ªå˜é‡è®°å½•å‰é©± preï¼Œä¸€ä¸ªå˜é‡è®°å½•åç»§ next.

ä¸æ–­æ›´æ–°`current.next = pre` å°±å¥½äº†

#### å…³é”®ç‚¹è§£æ

- é“¾è¡¨çš„åŸºæœ¬æ“ä½œ(äº¤æ¢)
- è™šæ‹ŸèŠ‚ç‚¹ dummy ç®€åŒ–æ“ä½œ
- æ³¨æ„æ›´æ–° current å’Œ pre çš„ä½ç½®ï¼Œ å¦åˆ™æœ‰å¯èƒ½å‡ºç°æº¢å‡º

#### ä»£ç 

è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript Codeï¼š

```js
/*
 * @lc app=leetcode id=206 lang=javascript
 *
 * [206] Reverse Linked List
 *
 * https://leetcode.com/problems/reverse-linked-list/description/
 *
 * algorithms
 * Easy (52.95%)
 * Total Accepted:    532.6K
 * Total Submissions: 1M
 * Testcase Example:  '[1,2,3,4,5]'
 *
 * Reverse a singly linked list.
 *
 * Example:
 *
 *
 * Input: 1->2->3->4->5->NULL
 * Output: 5->4->3->2->1->NULL
 *
 *
 * Follow up:
 *
 * A linked list can be reversed either iteratively or recursively. Could you
 * implement both?
 *
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (!head || !head.next) return head;

  let cur = head;
  let pre = null;

  while (cur) {
    const next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }

  return pre;
};
```

#### æ‹“å±•

é€šè¿‡å•é“¾è¡¨çš„å®šä¹‰å¯ä»¥å¾—çŸ¥ï¼Œå•é“¾è¡¨ä¹Ÿæ˜¯é€’å½’ç»“æ„ï¼Œå› æ­¤ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨é€’å½’çš„æ–¹å¼æ¥è¿›è¡Œ reverse æ“ä½œã€‚

> ç”±äºå•é“¾è¡¨æ˜¯çº¿æ€§çš„ï¼Œä½¿ç”¨é€’å½’æ–¹å¼å°†å¯¼è‡´æ ˆçš„ä½¿ç”¨ä¹Ÿæ˜¯çº¿æ€§çš„ï¼Œå½“é“¾è¡¨é•¿åº¦è¾¾åˆ°ä¸€å®šç¨‹åº¦æ—¶ï¼Œé€’å½’ä¼šå¯¼è‡´çˆ†æ ˆï¼Œå› æ­¤ï¼Œç°å®ä¸­å¹¶ä¸æ¨èä½¿ç”¨é€’å½’æ–¹å¼æ¥æ“ä½œé“¾è¡¨ã€‚

##### æè¿°

1. é™¤ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¤–ï¼Œé€’å½’å°†é“¾è¡¨ reverse
2. å°†ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ·»åŠ åˆ°å·² reverse çš„é“¾è¡¨ä¹‹å

> è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¯æ¬¡éœ€è¦ä¿å­˜å·²ç» reverse çš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹

##### C++å®ç°

```
// æ™®é€šé€’å½’
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* tail = nullptr;
        return reverseRecursive(head, tail);
    }

    ListNode* reverseRecursive(ListNode *head, ListNode *&tail) {
        if (head == nullptr) {
            tail = nullptr;
            return head;
        }
        if (head->next == nullptr) {
            tail = head;
            return head;
        }
        auto h = reverseRecursive(head->next, tail);
        if (tail != nullptr) {
            tail->next = head;
            tail = head;
            head->next = nullptr;
        }
        return h;
    }
};

// (ç±»ä¼¼)å°¾é€’å½’
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) return head;
        return reverseRecursive(nullptr, head, head->next);
    }

    ListNode* reverseRecursive(ListNode *prev, ListNode *head, ListNode *next)
    {
        if (next == nullptr) return head;
        auto n = next->next;
        next->next = head;
        head->next = prev;
        return reverseRecursive(head, next, n);
    }
};
```

### [208].implement-trie-prefix-tree

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/implement-trie-prefix-tree/description/

#### é¢˜ç›®æè¿°

```
Implement a trie with insert, search, and startsWith methods.

Example:

Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");
trie.search("app");     // returns true
Note:

You may assume that all inputs are consist of lowercase letters a-z.
All inputs are guaranteed to be non-empty strings.

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“å¾ˆç›´æ¥çš„é¢˜ç›®ï¼Œä¸Šæ¥å°±è®©ä½ å®ç°`å‰ç¼€æ ‘(å­—å…¸æ ‘)`ã€‚è¿™ç®—æ˜¯åŸºç¡€æ•°æ®ç»“æ„ä¸­çš„
çŸ¥è¯†äº†ï¼Œä¸æ¸…æ¥šä»€ä¹ˆæ˜¯å­—å…¸æ ‘çš„å¯ä»¥æŸ¥é˜…ç›¸å…³èµ„æ–™ã€‚

æˆ‘ä»¬çœ‹åˆ°é¢˜ç›®ç»™å‡ºçš„ä½¿ç”¨æ–¹æ³•`new Trie`, `insert`,`search`å’Œ`startWith`.

ä¸ºäº†åŒºåˆ†`search`å’Œ`startWith`æˆ‘ä»¬éœ€è¦å¢åŠ ä¸€ä¸ªæ ‡ç¤ºæ¥åŒºåˆ†å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯æŸä¸ªå•è¯çš„ç»“å°¾ã€‚
å› æ­¤èŠ‚ç‚¹çš„æ•°æ®ç»“æ„åº”è¯¥æ˜¯:

```js
function TrieNode(val) {
  this.val = val; // å½“å‰çš„å­—æ¯
  this.children = []; // é¢˜ç›®è¦æ±‚å­—å…¸ä»…æœ‰a-zï¼Œé‚£ä¹ˆå…¶é•¿åº¦æœ€å¤§ä¸º26(26ä¸ªå­—æ¯)
  this.isWord = false;
}
```

æ¯æ¬¡ insert æˆ‘ä»¬å…¶å®éƒ½æ˜¯ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œä¸€ä¸ªä¸€ä¸ªæ‰¾åˆ°æˆ‘ä»¬éœ€è¦æ·»åŠ çš„èŠ‚ç‚¹ï¼Œä¿®æ”¹ children çš„å€¼.

æˆ‘ä»¬åº”è¯¥ä¿®æ”¹å“ªä¸€ä¸ª child å‘¢ï¼Ÿ æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—ç´¢å¼•

```js
function computeIndex(c) {
  return c.charCodeAt(0) - 'a'.charCodeAt(0);
}
```

å…¶å®ä¸ç®¡ insertï¼Œ search å’Œ startWith çš„é€»è¾‘éƒ½æ˜¯å·®ä¸å¤šçš„ï¼Œéƒ½æ˜¯ä» root å‡ºå‘ï¼Œ
æ‰¾åˆ°æˆ‘ä»¬éœ€è¦æ“ä½œçš„ childï¼Œ ç„¶åè¿›è¡Œç›¸åº”æ“ä½œ(æ·»åŠ ï¼Œä¿®æ”¹ï¼Œè¿”å›)ã€‚

![208.implement-trie-prefix-tree-1](../assets/problems/208.implement-trie-prefix-tree-1.png)

#### å…³é”®ç‚¹è§£æ

- å‰ç¼€æ ‘

- æ ¸å¿ƒé€»è¾‘

```js
 const c = word[i];
 const current = computeIndex(c)
if (!ws.children[current]) {
    ws.children[current] = new TrieNode(c);
  }
  ws = ws.children[current]; // æ·±åº¦é€’å¢
}

```

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=208 lang=javascript
 *
 * [208] Implement Trie (Prefix Tree)
 *
 * https://leetcode.com/problems/implement-trie-prefix-tree/description/
 *
 * algorithms
 * Medium (36.93%)
 * Total Accepted:    172K
 * Total Submissions: 455.5K
 * Testcase Example:  '["Trie","insert","search","search","startsWith","insert","search"]\n[[],["apple"],["apple"],["app"],["app"],["app"],["app"]]'
 *
 * Implement a trie with insert, search, and startsWith methods.
 *
 * Example:
 *
 *
 * Trie trie = new Trie();
 *
 * trie.insert("apple");
 * trie.search("apple");   // returns true
 * trie.search("app");     // returns false
 * trie.startsWith("app"); // returns true
 * trie.insert("app");
 * trie.search("app");     // returns true
 *
 *
 * Note:
 *
 *
 * You may assume that all inputs are consist of lowercase letters a-z.
 * All inputs are guaranteed to be non-empty strings.
 *
 *
 */
function TrieNode(val) {
  this.val = val;
  this.children = [];
  this.isWord = false;
}

function computeIndex(c) {
  return c.charCodeAt(0) - 'a'.charCodeAt(0);
}
/**
 * Initialize your data structure here.
 */
var Trie = function() {
  this.root = new TrieNode(null);
};

/**
 * Inserts a word into the trie.
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
  let ws = this.root;
  for (let i = 0; i < word.length; i++) {
    const c = word[i];
    const current = computeIndex(c);
    if (!ws.children[current]) {
      ws.children[current] = new TrieNode(c);
    }
    ws = ws.children[current];
  }
  ws.isWord = true;
};

/**
 * Returns if the word is in the trie.
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
  let ws = this.root;
  for (let i = 0; i < word.length; i++) {
    const c = word[i];
    const current = computeIndex(c);
    if (!ws.children[current]) return false;
    ws = ws.children[current];
  }
  return ws.isWord;
};

/**
 * Returns if there is any word in the trie that starts with the given prefix.
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
  let ws = this.root;
  for (let i = 0; i < prefix.length; i++) {
    const c = prefix[i];
    const current = computeIndex(c);
    if (!ws.children[current]) return false;
    ws = ws.children[current];
  }
  return true;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
```

### [209].minimum-size-subarray-sum

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/minimum-size-subarray-sum/description/

#### é¢˜ç›®æè¿°

```
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum â‰¥ s. If there isn't one, return 0 instead.

Example:

Input: s = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: the subarray [4,3] has the minimal length under the problem constraint.
Follow up:
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).

```

#### æ€è·¯

ç”¨æ»‘åŠ¨çª—å£æ¥è®°å½•åºåˆ—ï¼Œ æ¯å½“æ»‘åŠ¨çª—å£ä¸­çš„ sum è¶…è¿‡ sï¼Œ å°±å»æ›´æ–°æœ€å°å€¼ï¼Œå¹¶æ ¹æ®å…ˆè¿›å…ˆå‡ºçš„åŸåˆ™æ›´æ–°æ»‘åŠ¨çª—å£ï¼Œç›´è‡³ sum åˆšå¥½å°äº s

![209.minimum-size-subarray-sum](../assets/problems/209.minimum-size-subarray-sum.png)

> è¿™é“é¢˜ç›®å’Œ leetcode 3 å·é¢˜ç›®æœ‰ç‚¹åƒï¼Œéƒ½å¯ä»¥ç”¨æ»‘åŠ¨çª—å£çš„æ€è·¯æ¥è§£å†³

#### å…³é”®ç‚¹

- æ»‘åŠ¨çª—å£ç®€åŒ–æ“ä½œ(æ»‘çª—å£é€‚åˆç”¨äºæ±‚è§£è¿™ç§è¦æ±‚`è¿ç»­`çš„é¢˜ç›®)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=209 lang=javascript
 *
 * [209] Minimum Size Subarray Sum
 *
 * https://leetcode.com/problems/minimum-size-subarray-sum/description/
 *
 * algorithms
 * Medium (34.31%)
 * Total Accepted:    166.9K
 * Total Submissions: 484.9K
 * Testcase Example:  '7\n[2,3,1,2,4,3]'
 *
 * Given an array of n positive integers and a positive integer s, find the
 * minimal length of a contiguous subarray of which the sum â‰¥ s. If there isn't
 * one, return 0 instead.
 *
 * Example:
 *
 *
 * Input: s = 7, nums = [2,3,1,2,4,3]
 * Output: 2
 * Explanation: the subarray [4,3] has the minimal length under the problem
 * constraint.
 *
 * Follow up:
 *
 * If you have figured out the O(n) solution, try coding another solution of
 * which the time complexity is O(n log n).
 *
 */
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
  if (nums.length === 0) return 0;
  const slideWindow = [];
  let acc = 0;
  let min = null;

  for (let i = 0; i < nums.length + 1; i++) {
    const num = nums[i];

    while (acc >= s) {
      if (min === null || slideWindow.length < min) {
        min = slideWindow.length;
      }
      acc = acc - slideWindow.shift();
    }

    slideWindow.push(num);

    acc = slideWindow.reduce((a, b) => a + b, 0);
  }

  return min || 0;
};
```

#### æ‰©å±•

å¦‚æœé¢˜ç›®è¦æ±‚æ˜¯ sum = s, è€Œä¸æ˜¯ sum >= s å‘¢ï¼Ÿ

eg:

```js
var minSubArrayLen = function(s, nums) {
  if (nums.length === 0) return 0;
  const slideWindow = [];
  let acc = 0;
  let min = null;

  for (let i = 0; i < nums.length + 1; i++) {
    const num = nums[i];

    while (acc > s) {
      acc = acc - slideWindow.shift();
    }
    if (acc === s) {
      if (min === null || slideWindow.length < min) {
        min = slideWindow.length;
      }
      slideWindow.shift();
    }

    slideWindow.push(num);

    acc = slideWindow.reduce((a, b) => a + b, 0);
  }

  return min || 0;
};
```

### [211].add-and-search-word-data-structure-design

#### é¢˜ç›®åœ°å€(211. æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡)

https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/description/

#### é¢˜ç›®æè¿°

```
è®¾è®¡ä¸€ä¸ªæ”¯æŒä»¥ä¸‹ä¸¤ç§æ“ä½œçš„æ•°æ®ç»“æ„ï¼š

void addWord(word)
bool search(word)
search(word)Â å¯ä»¥æœç´¢æ–‡å­—æˆ–æ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²åªåŒ…å«å­—æ¯Â .Â æˆ–Â a-zÂ ã€‚Â . å¯ä»¥è¡¨ç¤ºä»»ä½•ä¸€ä¸ªå­—æ¯ã€‚

ç¤ºä¾‹:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
è¯´æ˜:

ä½ å¯ä»¥å‡è®¾æ‰€æœ‰å•è¯éƒ½æ˜¯ç”±å°å†™å­—æ¯ a-zÂ ç»„æˆçš„ã€‚

```

#### æ€è·¯

æˆ‘ä»¬é¦–å…ˆä¸è€ƒè™‘å­—ç¬¦"."çš„æƒ…å†µã€‚è¿™ç§æƒ…å†µæ¯”è¾ƒç®€å•ï¼Œæˆ‘ä»¬ addWord ç›´æ¥æ·»åŠ åˆ°æ•°ç»„å°¾éƒ¨ï¼Œsearch åˆ™çº¿æ€§æŸ¥æ‰¾å³å¯ã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬è€ƒè™‘ç‰¹æ®Šå­—ç¬¦â€œ.â€ï¼Œå…¶å®ä¹Ÿä¸éš¾ï¼Œåªä¸è¿‡ search çš„æ—¶å€™ï¼Œåˆ¤æ–­å¦‚æœæ˜¯â€œ.â€, æˆ‘ä»¬è®¤ä¸ºåŒ¹é…åˆ°äº†ï¼Œç»§ç»­å¾€ååŒ¹é…å³å¯ã€‚

ä¸Šé¢çš„ä»£ç å¤æ‚åº¦ä¼šæ¯”è¾ƒé«˜ï¼Œæˆ‘ä»¬è€ƒè™‘ä¼˜åŒ–ã€‚å¦‚æœä½ ç†Ÿæ‚‰å‰ç¼€æ ‘çš„è¯ï¼Œåº”è¯¥æ³¨æ„åˆ°è¿™å¯ä»¥ä½¿ç”¨å‰ç¼€æ ‘æ¥è¿›è¡Œä¼˜åŒ–ã€‚å‰ç¼€æ ‘ä¼˜åŒ–ä¹‹åæ¯æ¬¡æŸ¥æ‰¾å¤æ‚åº¦æ˜¯$O(h)$, å…¶ä¸­ h æ˜¯å‰ç¼€æ ‘æ·±åº¦ï¼Œä¹Ÿå°±æ˜¯æœ€é•¿çš„å­—ç¬¦ä¸²é•¿åº¦ã€‚

å…³äºå‰ç¼€æ ‘ï¼ŒLeetCode æœ‰å¾ˆå¤šé¢˜ç›®ã€‚æœ‰çš„æ˜¯ç›´æ¥è€ƒå¯Ÿï¼Œè®©ä½ å®ç°ä¸€ä¸ªå‰ç¼€æ ‘ï¼Œæœ‰çš„æ˜¯é—´æ¥è€ƒå¯Ÿï¼Œæ¯”å¦‚æœ¬é¢˜ã€‚å‰ç¼€æ ‘ä»£ç è§ä¸‹æ–¹ï¼Œå¤§å®¶ä¹‹åå¯ä»¥ç›´æ¥å½“æˆå‰ç¼€æ ‘çš„è§£é¢˜æ¨¡æ¿ä½¿ç”¨ã€‚

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb5dmstsxxj30mz0gqmzh.jpg)

ç”±äºæˆ‘ä»¬è¿™é“é¢˜éœ€è¦è€ƒè™‘ç‰¹æ®Šå­—ç¬¦"."ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¯¹æ ‡å‡†å‰ç¼€æ ‘åšä¸€ç‚¹æ”¹é€ ï¼Œinsert ä¸åšæ”¹å˜ï¼Œæˆ‘ä»¬åªéœ€è¦æ”¹å˜ search å³å¯ï¼Œä»£ç (Python 3)ï¼š

```python
def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        curr = self.Trie
        for i, w in enumerate(word):
            if w == '.':
                wizards = []
                for k in curr.keys():
                    if k == '#':
                        continue
                    wizards.append(self.search(word[:i] + k + word[i + 1:]))
                return any(wizards)
            if w not in curr:
                return False
            curr = curr[w]
        return "#" in curr
```

æ ‡å‡†çš„å‰ç¼€æ ‘æœç´¢æˆ‘ä¹Ÿè´´ä¸€ä¸‹ä»£ç ï¼Œå¤§å®¶å¯ä»¥å¯¹æ¯”ä¸€ä¸‹ï¼š

```python
def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        curr = self.Trie
        for w in word:
            if w not in curr:
                return False
            curr = curr[w]
        return "#" in curr
```

#### å…³é”®ç‚¹

- å‰ç¼€æ ‘(ä¹Ÿå«å­—å…¸æ ‘)ï¼Œè‹±æ–‡å Trie(è¯»ä½œ tree æˆ–è€… try)

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šPython3

Python3 Codeï¼š

å…³äº Trie çš„ä»£ç :

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.Trie = {}

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        curr = self.Trie
        for w in word:
            if w not in curr:
                curr[w] = {}
            curr = curr[w]
        curr['#'] = 1

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        curr = self.Trie
        for i, w in enumerate(word):
            if w == '.':
                wizards = []
                for k in curr.keys():
                    if k == '#':
                        continue
                    wizards.append(self.search(word[:i] + k + word[i + 1:]))
                return any(wizards)
            if w not in curr:
                return False
            curr = curr[w]
        return "#" in curr
```

ä¸»é€»è¾‘ä»£ç ï¼š

```python
class WordDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie = Trie()

    def addWord(self, word: str) -> None:
        """
        Adds a word into the data structure.
        """
        self.trie.insert(word)

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        """
        return self.trie.search(word)


### Your WordDictionary object will be instantiated and called as such:
### obj = WordDictionary()
### obj.addWord(word)
### param_2 = obj.search(word)
```

#### ç›¸å…³é¢˜ç›®

- [208.implement-trie-prefix-tree](./208.implement-trie-prefix-tree.md)
- [212.word-search-ii](./212.word-search-ii.md)
- [472.concatenated-words](./problems/472.concatenated-words.md)

### [212].word-search-ii

#### é¢˜ç›®åœ°å€(212. å•è¯æœç´¢ II)

https://leetcode-cn.com/problems/word-search-ii/description/

#### é¢˜ç›®æè¿°

```
ç»™å®šä¸€ä¸ªäºŒç»´ç½‘æ ¼Â boardÂ å’Œä¸€ä¸ªå­—å…¸ä¸­çš„å•è¯åˆ—è¡¨ wordsï¼Œæ‰¾å‡ºæ‰€æœ‰åŒæ—¶åœ¨äºŒç»´ç½‘æ ¼å’Œå­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚

å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æ„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–å‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯åœ¨ä¸€ä¸ªå•è¯ä¸­ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚

ç¤ºä¾‹:

è¾“å…¥:
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

è¾“å‡º:Â ["eat","oath"]
è¯´æ˜:
ä½ å¯ä»¥å‡è®¾æ‰€æœ‰è¾“å…¥éƒ½ç”±å°å†™å­—æ¯ a-zÂ ç»„æˆã€‚

æç¤º:

ä½ éœ€è¦ä¼˜åŒ–å›æº¯ç®—æ³•ä»¥é€šè¿‡æ›´å¤§æ•°æ®é‡çš„æµ‹è¯•ã€‚ä½ èƒ½å¦æ—©ç‚¹åœæ­¢å›æº¯ï¼Ÿ
å¦‚æœå½“å‰å•è¯ä¸å­˜åœ¨äºæ‰€æœ‰å•è¯çš„å‰ç¼€ä¸­ï¼Œåˆ™å¯ä»¥ç«‹å³åœæ­¢å›æº¯ã€‚ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„å¯ä»¥æœ‰æ•ˆåœ°æ‰§è¡Œè¿™æ ·çš„æ“ä½œï¼Ÿæ•£åˆ—è¡¨æ˜¯å¦å¯è¡Œï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ å‰ç¼€æ ‘å¦‚ä½•ï¼Ÿå¦‚æœä½ æƒ³å­¦ä¹ å¦‚ä½•å®ç°ä¸€ä¸ªåŸºæœ¬çš„å‰ç¼€æ ‘ï¼Œè¯·å…ˆæŸ¥çœ‹è¿™ä¸ªé—®é¢˜ï¼š å®ç°Trie(å‰ç¼€æ ‘)ã€‚

```

#### æ€è·¯

æˆ‘ä»¬éœ€è¦å¯¹çŸ©é˜µä¸­æ¯ä¸€é¡¹éƒ½è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†(DFS)ã€‚ é€’å½’çš„ç»ˆç‚¹æ˜¯

1. è¶…å‡ºè¾¹ç•Œ
2. é€’å½’è·¯å¾„ä¸Šç»„æˆçš„å•è¯ä¸åœ¨ words çš„å‰ç¼€ã€‚

æ¯”å¦‚é¢˜ç›®ç¤ºä¾‹ï¼šwords = ["oath","pea","eat","rain"]ï¼Œé‚£ä¹ˆå¯¹äº oaï¼Œoat æ»¡è¶³æ¡ä»¶ï¼Œå› ä¸ºä»–ä»¬éƒ½æ˜¯ oath çš„å‰ç¼€ï¼Œä½†æ˜¯ oaa å°±ä¸æ»¡è¶³æ¡ä»¶ã€‚

ä¸ºäº†é˜²æ­¢ç¯çš„å‡ºç°ï¼Œæˆ‘ä»¬éœ€è¦è®°å½•è®¿é—®è¿‡çš„èŠ‚ç‚¹ã€‚è€Œè¿”å›ç»“æœæ˜¯éœ€è¦å»é‡çš„ã€‚å‡ºäºç®€å•è€ƒè™‘ï¼Œæˆ‘ä»¬ä½¿ç”¨é›†åˆ(set)ï¼Œæœ€åè¿”å›çš„æ—¶å€™é‡æ–°è½¬åŒ–ä¸º listã€‚

åˆšæ‰æˆ‘æåˆ°äº†ä¸€ä¸ªå…³é”®è¯â€œå‰ç¼€â€ï¼Œæˆ‘ä»¬è€ƒè™‘ä½¿ç”¨å‰ç¼€æ ‘æ¥ä¼˜åŒ–ã€‚ä½¿å¾—å¤æ‚åº¦é™ä½ä¸º$O(h)$, å…¶ä¸­ h æ˜¯å‰ç¼€æ ‘æ·±åº¦ï¼Œä¹Ÿå°±æ˜¯æœ€é•¿çš„å­—ç¬¦ä¸²é•¿åº¦ã€‚

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb5dmstsxxj30mz0gqmzh.jpg)

#### å…³é”®ç‚¹

- å‰ç¼€æ ‘(ä¹Ÿå«å­—å…¸æ ‘)ï¼Œè‹±æ–‡å Trie(è¯»ä½œ tree æˆ–è€… try)
- DFS
- hashmap ç»“åˆ dfs è®°å½•è®¿é—®è¿‡çš„å…ƒç´ çš„æ—¶å€™ï¼Œæ³¨æ„ç»“æŸä¹‹åéœ€è¦å°† hashmap çš„å€¼é‡ç½®ã€‚(ä¸‹æ–¹ä»£ç çš„`del seen[(i, j)]`)

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šPython3

Python3 Codeï¼š

å…³äº Trie çš„ä»£ç :

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.Trie = {}

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        curr = self.Trie
        for w in word:
            if w not in curr:
                curr[w] = {}
            curr = curr[w]
        curr['#'] = 1

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """

        curr = self.Trie
        for w in prefix:
            if w not in curr:
                return False
            curr = curr[w]
        return True
```

ä¸»é€»è¾‘ä»£ç ï¼š

```python
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        m = len(board)
        if m == 0:
            return []
        n = len(board[0])
        trie = Trie()
        seen = None
        res = set()
        for word in words:
            trie.insert(word)

        def dfs(s, i, j):
            if (i, j) in seen or i < 0 or i >= m or j < 0 or j >= n or not trie.startsWith(s):
                return
            s += board[i][j]
            seen[(i, j)] = True

            if s in words:
                res.add(s)
            dfs(s, i + 1, j)
            dfs(s, i - 1, j)
            dfs(s, i, j + 1)
            dfs(s, i, j - 1)

            del seen[(i, j)]

        for i in range(m):
            for j in range(n):
                seen = dict()
                dfs("", i, j)
        return list(res)
```

#### ç›¸å…³é¢˜ç›®

- [208.implement-trie-prefix-tree](./208.implement-trie-prefix-tree.md)
- [211.add-and-search-word-data-structure-design](./211.add-and-search-word-data-structure-design.md)
- [472.concatenated-words](./problems/472.concatenated-words.md)

### [215].kth-largest-element-in-an-array

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/kth-largest-element-in-an-array/

#### é¢˜ç›®æè¿°

```
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

Input: [3,2,1,5,6,4] and k = 2
Output: 5
Example 2:

Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
Note:
You may assume k is always valid, 1 â‰¤ k â‰¤ array's length.
```

#### æ€è·¯

è¿™é“é¢˜è¦æ±‚åœ¨ä¸€ä¸ªæ— åºçš„æ•°ç»„ä¸­ï¼Œè¿”å›ç¬¬ K å¤§çš„æ•°ã€‚æ ¹æ®æ—¶é—´å¤æ‚åº¦ä¸åŒï¼Œè¿™é¢˜æœ‰ 3 ç§ä¸åŒçš„è§£æ³•ã€‚

###### è§£æ³•ä¸€ (æ’åº)

å¾ˆç›´è§‚çš„è§£æ³•å°±æ˜¯ç»™æ•°ç»„æ’åºï¼Œè¿™æ ·æ±‚è§£ç¬¬`K`å¤§çš„æ•°ï¼Œå°±ç­‰äºæ˜¯ä»å°åˆ°å¤§æ’å¥½åºçš„æ•°ç»„çš„ç¬¬`(n-K)`å°çš„æ•° (n æ˜¯æ•°ç»„çš„é•¿åº¦)ã€‚

ä¾‹å¦‚ï¼š

```
[3,2,1,5,6,4], k = 2
1. æ•°ç»„æ’åºï¼š
 [1,2,3,4,5,6]ï¼Œ
2. æ‰¾ç¬¬(n-k)å°çš„æ•°
 n-k=4, nums[4]=5 (ç¬¬2å¤§çš„æ•°)
```

_æ—¶é—´å¤æ‚åº¦:_ `O(nlogn) - n æ˜¯æ•°ç»„é•¿åº¦ã€‚`

###### è§£æ³•äºŒ - å°é¡¶å †(Heap)

å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º`K`çš„å°é¡¶å †ï¼Œå †é¡¶æ˜¯æœ€å°å…ƒç´ ï¼Œå½“å †çš„`size > K` çš„æ—¶å€™ï¼Œåˆ é™¤å †é¡¶å…ƒç´ .
æ‰«æä¸€éæ•°ç»„ï¼Œæœ€åå †é¡¶å°±æ˜¯ç¬¬`K`å¤§çš„å…ƒç´ ã€‚ ç›´æ¥è¿”å›ã€‚

ä¾‹å¦‚ï¼š
![heap](../assets/problems/215.kth-largest-element-in-an-array-heap.jpg)

_æ—¶é—´å¤æ‚åº¦_ï¼š`O(n * logk) , n is array length`
_ç©ºé—´å¤æ‚åº¦_ï¼š`O(k)`

è·Ÿæ’åºç›¸æ¯”ï¼Œä»¥ç©ºé—´æ¢æ—¶é—´ã€‚

###### è§£æ³•ä¸‰ - Quick Select

Quick Select ç±»ä¼¼å¿«æ’ï¼Œé€‰å– pivotï¼ŒæŠŠå°äº pivot çš„å…ƒç´ éƒ½ç§»åˆ° pivot ä¹‹å‰ï¼Œè¿™æ · pivot æ‰€åœ¨ä½ç½®å°±æ˜¯ç¬¬ pivot index å°çš„å…ƒç´ ã€‚
ä½†æ˜¯ä¸éœ€è¦å®Œå…¨ç»™æ•°ç»„æ’åºï¼Œåªè¦æ‰¾åˆ°å½“å‰ pivot çš„ä½ç½®æ˜¯å¦æ˜¯åœ¨ç¬¬(n-k)å°çš„ä½ç½®ï¼Œå¦‚æœæ˜¯ï¼Œæ‰¾åˆ°ç¬¬ k å¤§çš„æ•°ç›´æ¥è¿”å›ã€‚

å…·ä½“æ­¥éª¤ï¼š

```
1. åœ¨æ•°ç»„åŒºé—´éšæœºå–`pivot index = left + random[right-left]`.
2. æ ¹æ®pivot åš partitionï¼Œåœ¨æ•°ç»„åŒºé—´ï¼ŒæŠŠå°äºpivotçš„æ•°éƒ½ç§»åˆ°pivotå·¦è¾¹ã€‚
3. å¾—åˆ°pivotçš„ä½ç½® indexï¼Œ`compare(index, (n-k))`.
    a. index == n-k -> æ‰¾åˆ°ç¬¬`k`å¤§å…ƒç´ ï¼Œç›´æ¥è¿”å›ç»“æœã€‚
    b. index < n-k -> è¯´æ˜åœ¨`index`å³è¾¹ï¼Œç»§ç»­æ‰¾æ•°ç»„åŒºé—´`[index+1, right]`
    c. index > n-k -> é‚£ä¹ˆç¬¬`k`å¤§æ•°åœ¨`index`å·¦è¾¹ï¼Œç»§ç»­æŸ¥æ‰¾æ•°ç»„åŒºé—´`[left, index-1]`.

ä¾‹å­ï¼Œã€3,2,3,1,2,4,5,5,6]ï¼Œ k = 4

å¦‚ä¸‹å›¾ï¼š
```

![quick select](../assets/problems/215.kth-largest-element-in-an-array-quick-select.jpg)

_æ—¶é—´å¤æ‚åº¦_ï¼š

- å¹³å‡æ˜¯ï¼š`O(n)`
- æœ€åçš„æƒ…å†µæ˜¯ï¼š`O(n * n)`

#### å…³é”®ç‚¹åˆ†æ

1. ç›´æ¥æ’åºå¾ˆç®€å•
2. å †(Heap)ä¸»è¦æ˜¯è¦ç»´æŠ¤ä¸€ä¸ª K å¤§å°çš„å°é¡¶å †ï¼Œæ‰«æä¸€éæ•°ç»„ï¼Œæœ€åå †é¡¶å…ƒç´ å³æ˜¯æ‰€æ±‚ã€‚
3. Quick Select, å…³é”®æ˜¯æ˜¯å– pivotï¼Œå¯¹æ•°ç»„åŒºé—´åš partitionï¼Œæ¯”è¾ƒ pivot çš„ä½ç½®ï¼Œç±»ä¼¼äºŒåˆ†ï¼Œå– pivot å·¦è¾¹æˆ–å³è¾¹ç»§ç»­é€’å½’æŸ¥æ‰¾ã€‚

#### ä»£ç (Java code)

_è§£æ³•ä¸€ - æ’åº_

```java
class KthLargestElementSort {
 public int findKthlargest2(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
  }
}
```

_è§£æ³•äºŒ - Heap (PriorityQueue)_

```java
class KthLargestElementHeap {
  public int findKthLargest(int[] nums, int k) {
      PriorityQueue<Integer> pq = new PriorityQueue<>();
      for (int num : nums) {
        pq.offer(num);
        if (pq.size() > k) {
          pq.poll();
        }
      }
      return pq.poll();
  }
}
```

_è§£æ³•ä¸‰ - Quick Select_

```java
class KthLargestElementQuickSelect {
    static Random random = new Random();
    public int findKthLargest3(int[] nums, int k) {
      int len = nums.length;
      return select(nums, 0, len - 1, len - k);
    }

    private int select(int[] nums, int left, int right, int k) {
      if (left == right) return nums[left];
      // random select pivotIndex between left and right
      int pivotIndex = left + random.nextInt(right - left);
      // do partition, move smaller than pivot number into pivot left
      int pos = partition(nums, left, right, pivotIndex);
      if (pos == k) {
        return nums[pos];
      } else if (pos > k) {
        return select(nums, left, pos - 1, k);
      } else {
        return select(nums, pos + 1, right, k);
      }
    }

    private int partition(int[] nums, int left, int right, int pivotIndex) {
      int pivot = nums[pivotIndex];
      // move pivot to end
      swap(nums, right, pivotIndex);
      int pos = left;
      // move smaller num to pivot left
      for (int i = left; i <= right; i++) {
        if (nums[i] < pivot) {
          swap(nums, pos++, i);
        }
      }
      // move pivot to original place
      swap(nums, right, pos);
      return pos;
    }

    private void swap(int[] nums, int i, int j) {
      int tmp = nums[i];
      nums[i] = nums[j];
      nums[j] = tmp;
    }
}
```

#### å‚è€ƒ(References)

1. [Quick Select Wiki](https://en.wikipedia.org/wiki/Quickselect)

### [219].contains-duplicate-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/contains-duplicate-ii/description/

#### é¢˜ç›®æè¿°

```
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false

```

#### æ€è·¯

ç”±äºé¢˜ç›®æ²¡æœ‰å¯¹ç©ºé—´å¤æ‚åº¦æœ‰æ±‚ï¼Œç”¨ä¸€ä¸ª hashmap å­˜å‚¨å·²ç»è®¿é—®è¿‡çš„æ•°å­—å³å¯,
æ¯æ¬¡è®¿é—®éƒ½ä¼šçœ‹ hashmap ä¸­æ˜¯å¦æœ‰è¿™ä¸ªå…ƒç´ ï¼Œæœ‰çš„è¯æ‹¿å‡ºç´¢å¼•è¿›è¡Œæ¯”å¯¹ï¼Œæ˜¯å¦æ»¡è¶³æ¡ä»¶(ç›¸éš”ä¸å¤§äº k)ï¼Œå¦‚æœæ»¡è¶³è¿”å› true å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

æ— 

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=219 lang=javascript
 *
 * [219] Contains Duplicate II
 *
 * https://leetcode.com/problems/contains-duplicate-ii/description/
 *
 * algorithms
 * Easy (34.75%)
 * Total Accepted:    187.3K
 * Total Submissions: 537.5K
 * Testcase Example:  '[1,2,3,1]\n3'
 *
 * Given an array of integers and an integer k, find out whether there are two
 * distinct indices i and j in the array such that nums[i] = nums[j] and the
 * absolute difference between i and j is at most k.
 *
 *
 * Example 1:
 *
 *
 * Input: nums = [1,2,3,1], k = 3
 * Output: true
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums = [1,0,1,1], k = 1
 * Output: true
 *
 *
 *
 * Example 3:
 *
 *
 * Input: nums = [1,2,3,1,2,3], k = 2
 * Output: false
 *
 *
 *
 *
 *
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
  const visited = {};
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    if (visited[num] !== undefined && i - visited[num] <= k) {
      return true;
    }
    visited[num] = i;
  }
  return false;
};
```

### [226].invert-binary-tree

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/invert-binary-tree/description/

#### é¢˜ç›®æè¿°

```
Invert a binary tree.

Example:

Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
Trivia:
This problem was inspired by this original tweet by Max Howell:

Google: 90% of our engineers use the software you wrote (Homebrew), but you canâ€™t invert a binary tree on a whiteboard so f*** off.
```

#### æ€è·¯

éå†æ ‘(éšä¾¿æ€ä¹ˆéå†)ï¼Œç„¶åå°†å·¦å³å­æ ‘äº¤æ¢ä½ç½®ã€‚

#### å…³é”®ç‚¹è§£æ

- é€’å½’ç®€åŒ–æ“ä½œ
- å¦‚æœæ ‘å¾ˆé«˜ï¼Œå»ºè®®ä½¿ç”¨æ ˆæ¥ä»£æ›¿é€’å½’
- è¿™é“é¢˜ç›®å¯¹é¡ºåºæ²¡è¦æ±‚çš„ï¼Œå› æ­¤é˜Ÿåˆ—æ•°ç»„æ“ä½œéƒ½æ˜¯ä¸€æ ·çš„ï¼Œæ— ä»»ä½•åŒºåˆ«

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=226 lang=javascript
 *
 * [226] Invert Binary Tree
 *
 * https://leetcode.com/problems/invert-binary-tree/description/
 *
 * algorithms
 * Easy (57.14%)
 * Total Accepted:    311K
 * Total Submissions: 540.6K
 * Testcase Example:  '[4,2,7,1,3,6,9]'
 *
 * Invert a binary tree.
 *
 * Example:
 *
 * Input:
 *
 *
 * â     4
 * â   /   \
 * â  2     7
 * â / \   / \
 * 1   3 6   9
 *
 * Output:
 *
 *
 * â     4
 * â   /   \
 * â  7     2
 * â / \   / \
 * 9   6 3   1
 *
 * Trivia:
 * This problem was inspired by this original tweet by Max Howell:
 *
 * Google: 90% of our engineers use the software you wrote (Homebrew), but you
 * canâ€™t invert a binary tree on a whiteboard so f*** off.
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
  if (!root) return root;
  // é€’å½’
  //   const left = root.left;
  //   const right = root.right;
  //   root.right = invertTree(left);
  //   root.left = invertTree(right);
  // æˆ‘ä»¬ç”¨stackæ¥æ¨¡æ‹Ÿé€’å½’
  // æœ¬è´¨ä¸Šé€’å½’æ˜¯åˆ©ç”¨äº†æ‰§è¡Œæ ˆï¼Œæ‰§è¡Œæ ˆä¹Ÿæ˜¯ä¸€ç§æ ˆ
  // å…¶å®è¿™é‡Œä½¿ç”¨é˜Ÿåˆ—ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºè¿™é‡Œé¡ºåºä¸é‡è¦

  const stack = [root];
  let current = null;
  while ((current = stack.shift())) {
    const left = current.left;
    const right = current.right;
    current.right = left;
    current.left = right;
    if (left) {
      stack.push(left);
    }
    if (right) {
      stack.push(right);
    }
  }
  return root;
};
```

### [23].merge-k-sorted-lists

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/merge-k-sorted-lists/description

#### é¢˜ç›®æè¿°

```
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯åˆå¹¶ k ä¸ªå·²æ’åºçš„é“¾è¡¨ï¼Œå·ç§° leetcode ç›®å‰`æœ€éš¾`çš„é“¾è¡¨é¢˜ã€‚ å’Œä¹‹å‰æˆ‘ä»¬è§£å†³çš„[88.merge-sorted-array](./88.merge-sorted-array.md)å¾ˆåƒã€‚
ä»–ä»¬æœ‰ä¸¤ç‚¹åŒºåˆ«ï¼š

1. è¿™é“é¢˜çš„æ•°æ®ç»“æ„æ˜¯é“¾è¡¨ï¼Œé‚£é“æ˜¯æ•°ç»„ã€‚è¿™ä¸ªå…¶å®ä¸å¤æ‚ï¼Œæ¯•ç«Ÿéƒ½æ˜¯çº¿æ€§çš„æ•°æ®ç»“æ„ã€‚

2. è¿™é“é¢˜éœ€è¦åˆå¹¶ k ä¸ªå…ƒç´ ï¼Œé‚£é“åˆ™åªéœ€è¦åˆå¹¶ä¸¤ä¸ªã€‚è¿™ä¸ªæ˜¯ä¸¤é¢˜çš„å…³é”®å·®åˆ«ï¼Œä¹Ÿæ˜¯è¿™é“é¢˜éš¾åº¦ä¸º`hard`çš„åŸå› ã€‚

å› æ­¤æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œè¿™é“é¢˜ç›®æ˜¯`88.merge-sorted-array`çš„è¿›é˜¶ç‰ˆæœ¬ã€‚å…¶å®æ€è·¯ä¹Ÿæœ‰ç‚¹åƒï¼Œæˆ‘ä»¬æ¥å…·ä½“åˆ†æä¸‹ç¬¬äºŒæ¡ã€‚
å¦‚æœä½ ç†Ÿæ‚‰åˆå¹¶æ’åºçš„è¯ï¼Œä½ ä¼šå‘ç°å®ƒå°±æ˜¯`åˆå¹¶æ’åºçš„ä¸€éƒ¨åˆ†`ã€‚

å…·ä½“æˆ‘ä»¬å¯ä»¥æ¥çœ‹ä¸€ä¸ªåŠ¨ç”»

![23.merge-k-sorted-lists](../assets/problems/23.merge-k-sorted-lists.gif)

(åŠ¨ç”»æ¥è‡ª https://zhuanlan.zhihu.com/p/61796021)

#### å…³é”®ç‚¹è§£æ

- åˆ†æ²»
- åˆå¹¶æ’åº(merge sort)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=23 lang=javascript
 *
 * [23] Merge k Sorted Lists
 *
 * https://leetcode.com/problems/merge-k-sorted-lists/description/
 *
 * algorithms
 * Hard (33.14%)
 * Total Accepted:    373.7K
 * Total Submissions: 1.1M
 * Testcase Example:  '[[1,4,5],[1,3,4],[2,6]]'
 *
 * Merge k sorted linked lists and return it as one sorted list. Analyze and
 * describe its complexity.
 *
 * Example:
 *
 *
 * Input:
 * [
 * 1->4->5,
 * 1->3->4,
 * 2->6
 * ]
 * Output: 1->1->2->3->4->4->5->6
 *
 *
 */
function mergeTwoLists(l1, l2) {
  const dummyHead = {};
  let current = dummyHead;
  // l1: 1 -> 3 -> 5
  // l2: 2 -> 4 -> 6
  while (l1 !== null && l2 !== null) {
    if (l1.val < l2.val) {
      current.next = l1; // æŠŠå°çš„æ·»åŠ åˆ°ç»“æœé“¾è¡¨
      current = current.next; // ç§»åŠ¨ç»“æœé“¾è¡¨çš„æŒ‡é’ˆ
      l1 = l1.next; // ç§»åŠ¨å°çš„é‚£ä¸ªé“¾è¡¨çš„æŒ‡é’ˆ
    } else {
      current.next = l2;
      current = current.next;
      l2 = l2.next;
    }
  }

  if (l1 === null) {
    current.next = l2;
  } else {
    current.next = l1;
  }
  return dummyHead.next;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  // å›¾å‚è€ƒï¼š https://zhuanlan.zhihu.com/p/61796021
  if (lists.length === 0) return null;
  if (lists.length === 1) return lists[0];
  if (lists.length === 2) {
    return mergeTwoLists(lists[0], lists[1]);
  }

  const mid = lists.length >> 1;
  const l1 = [];
  for (let i = 0; i < mid; i++) {
    l1[i] = lists[i];
  }

  const l2 = [];
  for (let i = mid, j = 0; i < lists.length; i++, j++) {
    l2[j] = lists[i];
  }

  return mergeTwoLists(mergeKLists(l1), mergeKLists(l2));
};
```

#### ç›¸å…³é¢˜ç›®

-[88.merge-sorted-array](./88.merge-sorted-array.md)

### [230].kth-smallest-element-in-a-bst

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/

#### é¢˜ç›®æè¿°

```
Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note:
You may assume k is always valid, 1 â‰¤ k â‰¤ BST's total elements.

Example 1:

Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1
Example 2:

Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
Follow up:
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

```

#### æ€è·¯

ç”±äºâ€˜ä¸­åºéå†ä¸€ä¸ªäºŒå‰æŸ¥æ‰¾æ ‘(BST)çš„ç»“æœæ˜¯ä¸€ä¸ªæœ‰åºæ•°ç»„â€™ ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦åœ¨éå†åˆ°ç¬¬ k ä¸ªï¼Œè¿”å›å½“å‰å…ƒç´ å³å¯ã€‚
ä¸­åºéå†ç›¸å…³æ€è·¯è¯·æŸ¥çœ‹[binary-tree-traversal](../thinkings/binary-tree-traversal.md)

#### å…³é”®ç‚¹è§£æ

- ä¸­åºéå†

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=230 lang=javascript
 *
 * [230] Kth Smallest Element in a BST
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  const stack = [root];
  let cur = root;
  let i = 0;

  function insertAllLefts(cur) {
    while (cur && cur.left) {
      const l = cur.left;
      stack.push(l);
      cur = l;
    }
  }
  insertAllLefts(cur);

  while ((cur = stack.pop())) {
    i++;
    if (i === k) return cur.val;
    const r = cur.right;

    if (r) {
      stack.push(r);
      insertAllLefts(r);
    }
  }

  return -1;
};
```

#### æ‰©å±•

è¿™é“é¢˜æœ‰ä¸€ä¸ª follow upï¼š

`What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?`

å¤§å®¶å¯ä»¥æ€è€ƒä¸€ä¸‹ã€‚

### [232].implement-queue-using-stacks

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/implement-queue-using-stacks/description/

#### é¢˜ç›®æè¿°

```
Implement the following operations of a queue using stacks.

push(x) -- Push element x to the back of queue.
pop() -- Removes the element from in front of queue.
peek() -- Get the front element.
empty() -- Return whether the queue is empty.
Example:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // returns 1
queue.pop();   // returns 1
queue.empty(); // returns false
Notes:

You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).
```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯è®©æˆ‘ä»¬ç”¨æ ˆæ¥æ¨¡æ‹Ÿå®ç°é˜Ÿåˆ—ã€‚ æˆ‘ä»¬ç›´åˆ°æ ˆå’Œé˜Ÿåˆ—éƒ½æ˜¯ä¸€ç§å—é™çš„æ•°æ®ç»“æ„ã€‚
æ ˆçš„ç‰¹ç‚¹æ˜¯åªèƒ½åœ¨ä¸€ç«¯è¿›è¡Œæ‰€æœ‰æ“ä½œï¼Œé˜Ÿåˆ—çš„ç‰¹ç‚¹æ˜¯åªèƒ½åœ¨ä¸€ç«¯å…¥é˜Ÿï¼Œå¦ä¸€ç«¯å‡ºé˜Ÿã€‚

åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥å€ŸåŠ©å¦å¤–ä¸€ä¸ªæ ˆï¼Œä¹Ÿå°±æ˜¯è¯´ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°é˜Ÿåˆ—çš„æ•ˆæœã€‚è¿™ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ O(n)ã€‚

ç”±äºæ ˆåªèƒ½æ“ä½œä¸€ç«¯ï¼Œå› æ­¤æˆ‘ä»¬ peek æˆ–è€… pop çš„æ—¶å€™ä¹Ÿåªå»æ“ä½œé¡¶éƒ¨å…ƒç´ ï¼Œè¦è¾¾åˆ°ç›®çš„
æˆ‘ä»¬éœ€è¦åœ¨ push çš„æ—¶å€™å°†é˜Ÿå¤´çš„å…ƒç´ æ”¾åˆ°æ ˆé¡¶å³å¯ã€‚

å› æ­¤æˆ‘ä»¬åªéœ€è¦åœ¨ push çš„æ—¶å€™ï¼Œç”¨ä¸€ä¸‹è¾…åŠ©æ ˆå³å¯ã€‚
å…·ä½“åšæ³•æ˜¯å…ˆå°†æ ˆæ¸…ç©ºå¹¶ä¾æ¬¡æ”¾åˆ°å¦ä¸€ä¸ªè¾…åŠ©æ ˆä¸­ï¼Œè¾…åŠ©æ ˆä¸­çš„å…ƒç´ å†æ¬¡æ”¾å›æ ˆä¸­ï¼Œæœ€åå°†æ–°çš„å…ƒç´  push è¿›å»å³å¯ã€‚

æ¯”å¦‚æˆ‘ä»¬ç°åœ¨æ ˆä¸­å·²ç»æ˜¯ 1ï¼Œ2ï¼Œ3ï¼Œ4 äº†ã€‚ æˆ‘ä»¬ç°åœ¨è¦ push ä¸€ä¸ª 5.

push ä¹‹å‰æ˜¯è¿™æ ·çš„ï¼š

![232.implement-queue-using-stacks.drawio](../assets/problems/232.implement-queue-using-stacks-1.jpg)

ç„¶åæˆ‘ä»¬å°†æ ˆä¸­çš„å…ƒç´ è½¬ç§»åˆ°è¾…åŠ©æ ˆï¼š

![232.implement-queue-using-stacks.drawio](../assets/problems/232.implement-queue-using-stacks-2.jpg)

æœ€åå°†æ–°çš„å…ƒç´ æ·»åŠ åˆ°æ ˆé¡¶ã€‚

![232.implement-queue-using-stacks.drawio](../assets/problems/232.implement-queue-using-stacks-3.jpg)

æ•´ä¸ªè¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š

![232.implement-queue-using-stacks.drawio](../assets/problems/232.implement-queue-using-stacks-4.jpg)

#### å…³é”®ç‚¹è§£æ

- åœ¨ push çš„æ—¶å€™åˆ©ç”¨è¾…åŠ©æ ˆ(åŒæ ˆ)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=232 lang=javascript
 *
 * [232] Implement Queue using Stacks
 */
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
  // tag: queue stack array
  this.stack = [];
  this.helperStack = [];
};

/**
 * Push element x to the back of queue.
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
  let cur = null;
  while ((cur = this.stack.pop())) {
    this.helperStack.push(cur);
  }
  this.helperStack.push(x);

  while ((cur = this.helperStack.pop())) {
    this.stack.push(cur);
  }
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
  return this.stack.pop();
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
  return this.stack[this.stack.length - 1];
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
  return this.stack.length === 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

#### æ‰©å±•

- ç±»ä¼¼çš„é¢˜ç›®æœ‰ç”¨é˜Ÿåˆ—å®ç°æ ˆï¼Œæ€è·¯æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œå¤§å®¶æœ‰å…´è¶£å¯ä»¥è¯•ä¸€ä¸‹ã€‚
- æ ˆæ··æ´—ä¹Ÿæ˜¯å€ŸåŠ©å¦å¤–ä¸€ä¸ªæ ˆæ¥å®Œæˆçš„ï¼Œä»è¿™ç‚¹æ¥çœ‹ï¼Œä¸¤è€…æœ‰ç›¸ä¼¼ä¹‹å¤„ã€‚

### [236].lowest-common-ancestor-of-a-binary-tree

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).â€

Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]

```

![236.lowest-common-ancestor-of-a-binary-tree](../assets/problems/236.lowest-common-ancestor-of-a-binary-tree-1.png)

```
Example 1:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
Example 2:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.


Note:

All of the nodes' values will be unique.
p and q are different and both values will exist in the binary tree.
```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚è§£äºŒå‰æ ‘ä¸­ï¼Œä¸¤ä¸ªç»™å®šèŠ‚ç‚¹çš„æœ€è¿‘çš„å…¬å…±ç¥–å…ˆã€‚æ˜¯ä¸€é“éå¸¸ç»å…¸çš„äºŒå‰æ ‘é¢˜ç›®ã€‚

æˆ‘ä»¬ä¹‹å‰è¯´è¿‡æ ‘æ˜¯ä¸€ç§é€’å½’çš„æ•°æ®ç»“æ„ï¼Œå› æ­¤ä½¿ç”¨é€’å½’æ–¹æ³•è§£å†³äºŒå‰æ ‘é—®é¢˜ä»å†™æ³•ä¸Šæ¥çœ‹æ˜¯æœ€ç®€å•çš„ï¼Œè¿™é“é¢˜ç›®ä¹Ÿä¸ä¾‹å¤–ã€‚

ç”¨é€’å½’çš„æ€è·¯å»æ€è€ƒæ ‘æ˜¯ä¸€ç§éå¸¸é‡è¦çš„èƒ½åŠ›ã€‚

å¦‚æœå¤§å®¶è¿™æ ·å»æ€è€ƒçš„è¯ï¼Œé—®é¢˜å°±ä¼šå¾—åˆ°ç®€åŒ–ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯åˆ†åˆ«åœ¨å·¦å³å­æ ‘è¿›è¡ŒæŸ¥æ‰¾ p å’Œ qã€‚ å¦‚æœ p æ²¡æœ‰åœ¨å·¦å­æ ‘ï¼Œé‚£ä¹ˆå®ƒä¸€å®šåœ¨å³å­æ ‘(é¢˜ç›®é™å®š p ä¸€å®šåœ¨æ ‘ä¸­)ï¼Œ
åä¹‹äº¦ç„¶ã€‚

å¯¹äºå…·ä½“çš„ä»£ç è€Œè¨€å°±æ˜¯ï¼Œæˆ‘ä»¬å‡è®¾è¿™ä¸ªæ ‘å°±ä¸€ä¸ªç»“æ„ï¼Œç„¶åå°è¯•å»è§£å†³ï¼Œç„¶ååœ¨é€‚å½“åœ°æ–¹å»é€’å½’è‡ªèº«å³å¯ã€‚ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![236.lowest-common-ancestor-of-a-binary-tree-2](../assets/problems/236.lowest-common-ancestor-of-a-binary-tree-2.png)

æˆ‘ä»¬æ¥çœ‹ä¸‹æ ¸å¿ƒä»£ç ï¼š

```js
// å¦‚æœæˆ‘ä»¬æ‰¾åˆ°äº†pï¼Œç›´æ¥è¿›è¡Œè¿”å›ï¼Œé‚£å¦‚æœä¸‹é¢å°±æ˜¯qå‘¢ï¼Ÿ å…¶å®è¿™æ²¡æœ‰å½±å“ï¼Œä½†æ˜¯è¿˜æ˜¯è¦å¤šè€ƒè™‘ä¸€ä¸‹
if (!root || root === p || root === q) return root;
const left = lowestCommonAncestor(root.left, p, q); // å»å·¦è¾¹æ‰¾ï¼Œæˆ‘ä»¬æœŸæœ›è¿”å›æ‰¾åˆ°çš„èŠ‚ç‚¹
const right = lowestCommonAncestor(root.right, p, q); // å»å³è¾¹æ‰¾ï¼Œæˆ‘ä»¬æœŸæœ›è¿”å›æ‰¾åˆ°çš„èŠ‚ç‚¹
if (!left) return right; // å·¦å­æ ‘æ‰¾ä¸åˆ°ï¼Œè¿”å›å³å­æ ‘
if (!right) return left; // å³å­æ ‘æ‰¾ä¸åˆ°ï¼Œè¿”å›å·¦å­æ ‘
return root; // å·¦å³å­æ ‘åˆ†åˆ«æœ‰ä¸€ä¸ªï¼Œåˆ™è¿”å›root
```

> å¦‚æœæ²¡æœ‰æ˜ç™½çš„è¯ï¼Œè¯·å¤šèŠ±æ—¶é—´æ¶ˆåŒ–ä¸€ä¸‹

#### å…³é”®ç‚¹è§£æ

- ç”¨é€’å½’çš„æ€è·¯å»æ€è€ƒæ ‘

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=236 lang=javascript
 *
 * [236] Lowest Common Ancestor of a Binary Tree
 *
 * https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
 *
 * algorithms
 * Medium (35.63%)
 * Total Accepted:    267.3K
 * Total Submissions: 729.2K
 * Testcase Example:  '[3,5,1,6,2,0,8,null,null,7,4]\n5\n1'
 *
 * Given a binary tree, find the lowest common ancestor (LCA) of two given
 * nodes in the tree.
 *
 * According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor
 * is defined between two nodes pÂ and qÂ as the lowest node in T that has both p
 * and qÂ as descendants (where we allow a node to be a descendant of itself).â€
 *
 * Given the following binary tree:Â  root =Â [3,5,1,6,2,0,8,null,null,7,4]
 *
 *
 *
 * Example 1:
 *
 *
 * Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
 * Output: 3
 * Explanation: The LCA of nodes 5 and 1 is 3.
 *
 *
 * Example 2:
 *
 *
 * Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
 * Output: 5
 * Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant
 * of itself according to the LCA definition.
 *
 *
 *
 *
 * Note:
 *
 *
 * All of the nodes' values will be unique.
 * p and q are different and both values willÂ exist in the binary tree.
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (!root || root === p || root === q) return root;
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  if (!left) return right; // å·¦å­æ ‘æ‰¾ä¸åˆ°ï¼Œè¿”å›å³å­æ ‘
  if (!right) return left; // å³å­æ ‘æ‰¾ä¸åˆ°ï¼Œè¿”å›å·¦å­æ ‘
  return root; // å·¦å³å­æ ‘åˆ†åˆ«æœ‰ä¸€ä¸ªï¼Œåˆ™è¿”å›root
};
```

#### æ‰©å±•

å¦‚æœé€’å½’çš„ç»“æŸæ¡ä»¶æ”¹ä¸º`if (!root || root.left === p || root.right === q) return root;` ä»£è¡¨çš„æ˜¯ä»€ä¹ˆæ„æ€ï¼Œå¯¹ç»“æœæœ‰ä»€ä¹ˆæ ·çš„å½±å“ï¼Ÿ

### [238].product-of-array-except-self

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/product-of-array-except-self/description/

#### é¢˜ç›®æè¿°

```
Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:

Input:  [1,2,3,4]
Output: [24,12,8,6]
Note: Please solve it without division and in O(n).

Follow up:
Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)


```

#### æ€è·¯

è¿™é“é¢˜çš„æ„æ€æ˜¯ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„æ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„æ¯ä¸€é¡¹éƒ½æ˜¯å…¶ä»–é¡¹çš„ä¹˜ç§¯ã€‚
ç¬¦åˆç›´è§‰çš„æ€è·¯æ˜¯ä¸¤å±‚å¾ªç¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n),ä½†æ˜¯é¢˜ç›®è¦æ±‚`Please solve it without division and in O(n)`ã€‚

å› æ­¤æˆ‘ä»¬éœ€è¦æ¢ä¸€ç§æ€è·¯ï¼Œç”±äºè¾“å‡ºçš„æ¯ä¸€é¡¹éƒ½éœ€è¦ç”¨åˆ°åˆ«çš„å…ƒç´ ï¼Œå› æ­¤ä¸€æ¬¡éå†æ˜¯ç»å¯¹ä¸è¡Œçš„ã€‚
è€ƒè™‘æˆ‘ä»¬å…ˆè¿›è¡Œä¸€æ¬¡éå†ï¼Œ ç„¶åç»´æŠ¤ä¸€ä¸ªæ•°ç»„ï¼Œç¬¬ i é¡¹ä»£è¡¨å‰ i ä¸ªå…ƒç´ (ä¸åŒ…æ‹¬ i)çš„ä¹˜ç§¯ã€‚
ç„¶åæˆ‘ä»¬åå‘éå†ä¸€æ¬¡ï¼Œç„¶åç»´æŠ¤å¦ä¸€ä¸ªæ•°ç»„ï¼ŒåŒæ ·æ˜¯ç¬¬ i é¡¹ä»£è¡¨å‰ i ä¸ªå…ƒç´ (ä¸åŒ…æ‹¬ i)çš„ä¹˜ç§¯ã€‚

![238.product-of-array-except-self](../assets/problems/238.product-of-array-except-self.png)

æœ‰æ„æ€çš„æ˜¯ç¬¬ä¸€ä¸ªæ•°ç»„å’Œç¬¬äºŒä¸ªæ•°ç»„çš„åè½¬(reverse)åšä¹˜æ³•(æœ‰ç‚¹åƒå‘é‡è¿ç®—)å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„è¿ç®—ã€‚

å…¶å®æˆ‘ä»¬è¿›ä¸€æ­¥è§‚å¯Ÿï¼Œæˆ‘ä»¬ä¸éœ€è¦çœŸçš„åˆ›å»ºç¬¬äºŒä¸ªæ•°ç»„(ç¬¬äºŒä¸ªæ•°ç»„åªæ˜¯åšä¸­é—´è¿ç®—ä½¿ç”¨)ï¼Œè€Œæ˜¯ç›´æ¥ä¿®æ”¹ç¬¬ä¸€ä¸ªæ•°ç»„å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- ä¸¤æ¬¡éå†ï¼Œ ä¸€æ¬¡æ­£å‘ï¼Œä¸€æ¬¡åå‘ã€‚
- ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ï¼Œç¬¬ i é¡¹ä»£è¡¨å‰ i ä¸ªå…ƒç´ (ä¸åŒ…æ‹¬ i)çš„ä¹˜ç§¯

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=238 lang=javascript
 *
 * [238] Product of Array Except Self
 *
 * https://leetcode.com/problems/product-of-array-except-self/description/
 *
 * algorithms
 * Medium (53.97%)
 * Total Accepted:    246.5K
 * Total Submissions: 451.4K
 * Testcase Example:  '[1,2,3,4]'
 *
 * Given an array nums of n integers where n > 1, Â return an array output such
 * that output[i] is equal to the product of all the elements of nums except
 * nums[i].
 *
 * Example:
 *
 *
 * Input:  [1,2,3,4]
 * Output: [24,12,8,6]
 *
 *
 * Note: Please solve it without division and in O(n).
 *
 * Follow up:
 * Could you solve it with constant space complexity? (The output array does
 * not count as extra space for the purpose of space complexity analysis.)
 *
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  const ret = [];

  for (let i = 0, temp = 1; i < nums.length; i++) {
    ret[i] = temp;
    temp *= nums[i];
  }
  // æ­¤æ—¶ret[i]å­˜æ”¾çš„æ˜¯å‰iä¸ªå…ƒç´ ç›¸ä¹˜çš„ç»“æœ(ä¸åŒ…å«ç¬¬iä¸ª)

  // å¦‚æœæ²¡æœ‰ä¸Šé¢çš„å¾ªç¯çš„è¯ï¼Œ
  // retç»è¿‡ä¸‹é¢çš„å¾ªç¯ä¼šå˜æˆret[i]å­˜æ”¾çš„æ˜¯åiä¸ªå…ƒç´ ç›¸ä¹˜çš„ç»“æœ(ä¸åŒ…å«ç¬¬iä¸ª)

  // æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ret[i]å­˜æ”¾çš„æ‰€æœ‰æ•°å­—ç›¸ä¹˜çš„ç»“æœ(ä¸åŒ…å«ç¬¬iä¸ª)

  // å› æ­¤æˆ‘ä»¬åªéœ€è¦å¯¹äºä¸Šè¿°çš„å¾ªç¯äº§ç”Ÿçš„ret[i]åŸºç¡€ä¸Šè¿ç®—å³å¯
  for (let i = nums.length - 1, temp = 1; i >= 0; i--) {
    ret[i] *= temp;
    temp *= nums[i];
  }
  return ret;
};
```

### [239].sliding-window-maximum

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/sliding-window-maximum/description/

#### é¢˜ç›®æè¿°

```
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.

Example:

Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7]
Explanation:

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Note:
You may assume k is always valid, 1 â‰¤ k â‰¤ input array's size for non-empty array.

Follow up:
Could you solve it in linear time?
```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„æƒ³æ³•æ˜¯ç›´æ¥éå† nums, ç„¶åç„¶åç”¨ä¸€ä¸ªå˜é‡ slideWindow å»æ‰¿è½½ k ä¸ªå…ƒç´ ï¼Œ
ç„¶åå¯¹ slideWindow æ±‚æœ€å¤§å€¼ï¼Œè¿™æ˜¯å¯ä»¥çš„ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n \* k).ä»£ç å¦‚ä¸‹ï¼š

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
  // bad æ—¶é—´å¤æ‚åº¦O(n * k)
  if (nums.length === 0 || k === 0) return [];
  let slideWindow = [];
  const ret = [];
  for (let i = 0; i < nums.length - k + 1; i++) {
    for (let j = 0; j < k; j++) {
      slideWindow.push(nums[i + j]);
    }
    ret.push(Math.max(...slideWindow));
    slideWindow = [];
  }
  return ret;
};
```

ä½†æ˜¯å¦‚æœçœŸçš„æ˜¯è¿™æ ·ï¼Œè¿™é“é¢˜ä¹Ÿä¸ä¼šæ˜¯ hard å§ï¼Ÿè¿™é“é¢˜æœ‰ä¸€ä¸ª follow upï¼Œè¦æ±‚ä½ ç”¨çº¿æ€§çš„æ—¶é—´å»å®Œæˆã€‚
æˆ‘ä»¬å¯ä»¥ç”¨åŒç«¯é˜Ÿåˆ—æ¥å®Œæˆï¼Œæ€è·¯æ˜¯ç”¨ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—æ¥ä¿å­˜`æ¥ä¸‹æ¥çš„æ»‘åŠ¨çª—å£å¯èƒ½æˆä¸ºæœ€å¤§å€¼çš„æ•°`ã€‚å…·ä½“åšæ³•ï¼š

- å…¥é˜Ÿåˆ—

- ç§»é™¤å¤±æ•ˆå…ƒç´ ï¼Œå¤±æ•ˆå…ƒç´ æœ‰ä¸¤ç§

1. ä¸€ç§æ˜¯å·²ç»è¶…å‡ºçª—å£èŒƒå›´äº†ï¼Œæ¯”å¦‚æˆ‘éå†åˆ°ç¬¬ 4 ä¸ªå…ƒç´ ï¼Œk = 3ï¼Œé‚£ä¹ˆ i = 0 çš„å…ƒç´ å°±ä¸åº”è¯¥å‡ºç°åœ¨åŒç«¯é˜Ÿåˆ—ä¸­äº†
   å…·ä½“å°±æ˜¯`ç´¢å¼•å¤§äº i - k + 1çš„å…ƒç´ éƒ½åº”è¯¥è¢«æ¸…é™¤`

2. å°äºå½“å‰å…ƒç´ éƒ½æ²¡æœ‰åˆ©ç”¨ä»·å€¼äº†ï¼Œå…·ä½“å°±æ˜¯`ä»åå¾€å‰éå†(åŒç«¯é˜Ÿåˆ—æ˜¯ä¸€ä¸ªé€’å‡é˜Ÿåˆ—)åŒç«¯é˜Ÿåˆ—ï¼Œå¦‚æœå°äºå½“å‰å…ƒç´ å°±å‡ºé˜Ÿåˆ—`

å¦‚æœä½ ä»”ç»†è§‚å¯Ÿçš„è¯ï¼Œå‘ç°åŒç«¯é˜Ÿåˆ—å…¶å®æ˜¯ä¸€ä¸ªé€’å‡çš„ä¸€ä¸ªé˜Ÿåˆ—ã€‚å› æ­¤é˜Ÿé¦–çš„å…ƒç´ ä¸€å®šæ˜¯æœ€å¤§çš„ã€‚ç”¨å›¾æ¥è¡¨ç¤ºå°±æ˜¯ï¼š

![239.sliding-window-maximum](../assets/problems/239.sliding-window-maximum.png)

#### å…³é”®ç‚¹è§£æ

- åŒç«¯é˜Ÿåˆ—ç®€åŒ–æ—¶é—´å¤æ‚åº¦

- æ»‘åŠ¨çª—å£

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=239 lang=javascript
 *
 * [239] Sliding Window Maximum
 *
 * https://leetcode.com/problems/sliding-window-maximum/description/
 *
 * algorithms
 * Hard (37.22%)
 * Total Accepted:    150.8K
 * Total Submissions: 399.5K
 * Testcase Example:  '[1,3,-1,-3,5,3,6,7]\n3'
 *
 * Given an array nums, there is a sliding window of size k which is moving
 * from the very left of the array to the very right. You can only see the k
 * numbers in the window. Each time the sliding window moves right by one
 * position. Return the max sliding window.
 *
 * Example:
 *
 *
 * Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
 * Output: [3,3,5,5,6,7]
 * Explanation:
 *
 * Window position                Max
 * ---------------               -----
 * [1  3  -1] -3  5  3  6  7       3
 * â 1 [3  -1  -3] 5  3  6  7       3
 * â 1  3 [-1  -3  5] 3  6  7       5
 * â 1  3  -1 [-3  5  3] 6  7       5
 * â 1  3  -1  -3 [5  3  6] 7       6
 * â 1  3  -1  -3  5 [3  6  7]      7
 *
 *
 * Note:
 * You may assume k is always valid, 1 â‰¤ k â‰¤ input array's size for non-empty
 * array.
 *
 * Follow up:
 * Could you solve it in linear time?
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
  // åŒç«¯é˜Ÿåˆ—ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦, æ—¶é—´å¤æ‚åº¦O(n)
  const deque = []; // å­˜æ”¾åœ¨æ¥ä¸‹æ¥çš„æ»‘åŠ¨çª—å£å¯èƒ½æˆä¸ºæœ€å¤§å€¼çš„æ•°
  const ret = [];
  for (let i = 0; i < nums.length; i++) {
    // æ¸…ç©ºå¤±æ•ˆå…ƒç´ 
    while (deque[0] < i - k + 1) {
      deque.shift();
    }

    while (nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    deque.push(i);

    if (i >= k - 1) {
      ret.push(nums[deque[0]]);
    }
  }
  return ret;
};
```

#### æ‰©å±•

##### ä¸ºä»€ä¹ˆç”¨åŒç«¯é˜Ÿåˆ—

å› ä¸ºåˆ é™¤æ— æ•ˆå…ƒç´ çš„æ—¶å€™ï¼Œä¼šæ¸…é™¤é˜Ÿé¦–çš„å…ƒç´ (ç´¢å¼•å¤ªå°äº†
)æˆ–è€…é˜Ÿå°¾(å…ƒç´ å¤ªå°äº†)çš„å…ƒç´ ã€‚ å› æ­¤éœ€è¦åŒæ—¶å¯¹é˜Ÿé¦–å’Œé˜Ÿå°¾è¿›è¡Œæ“ä½œï¼Œä½¿ç”¨åŒç«¯é˜Ÿåˆ—æ˜¯ä¸€ç§åˆä¹æƒ…ç†çš„åšæ³•ã€‚

### [24].swapNodesInPairs

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/swap-nodes-in-pairs/description/

#### é¢˜ç›®æè¿°

Given a linked list, swap every two adjacent nodes and return its head.

You may not modify the values in the list's nodes, only nodes itself may be changed.

Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.

#### æ€è·¯

è®¾ç½®ä¸€ä¸ª dummy èŠ‚ç‚¹ç®€åŒ–æ“ä½œ,dummy next æŒ‡å‘ headã€‚

1. åˆå§‹åŒ– first ä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹
2. åˆå§‹åŒ– second ä¸ºç¬¬äºŒä¸ªèŠ‚ç‚¹
3. åˆå§‹åŒ– current ä¸º dummy
4. first.next = second.next
5. second.next = first
6. current.next = second
7. current ç§»åŠ¨ä¸¤æ ¼
8. é‡å¤

![24.swap-nodes-in-pairs](../assets/24.swap-nodes-in-pairs.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

#### å…³é”®ç‚¹è§£æ

1. é“¾è¡¨è¿™ç§æ•°æ®ç»“æ„çš„ç‰¹ç‚¹å’Œä½¿ç”¨

2. dummyHead ç®€åŒ–æ“ä½œ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=24 lang=javascript
 *
 * [24] Swap Nodes in Pairs
 *
 * https://leetcode.com/problems/swap-nodes-in-pairs/description/
 *
 * algorithms
 * Medium (43.33%)
 * Total Accepted:    287.2K
 * Total Submissions: 661.3K
 * Testcase Example:  '[1,2,3,4]'
 *
 * Given aÂ linked list, swap every two adjacent nodes and return its head.
 *
 * You may not modify the values in the list's nodes, only nodes itself may be
 * changed.
 *
 *
 *
 * Example:
 *
 *
 * Given 1->2->3->4, you should return the list as 2->1->4->3.
 *
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
  const dummy = new ListNode(0);
  dummy.next = head;
  let current = dummy;
  while (current.next != null && current.next.next != null) {
    // åˆå§‹åŒ–åŒæŒ‡é’ˆ
    const first = current.next;
    const second = current.next.next;

    // æ›´æ–°åŒæŒ‡é’ˆå’ŒcurrentæŒ‡é’ˆ
    first.next = second.next;
    second.next = first;
    current.next = second;

    // æ›´æ–°æŒ‡é’ˆ
    current = current.next.next;
  }
  return dummy.next;
};
```

### [240].search-a-2-d-matrix-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/search-a-2d-matrix-ii/description/

#### é¢˜ç›®æè¿°

```
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
Example:

Consider the following matrix:

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.

Given target = 20, return false.

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯ä¸¤å±‚å¾ªç¯éå†ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(m \* n),
æœ‰æ²¡æœ‰æ—¶é—´å¤æ‚åº¦æ›´å¥½çš„åšæ³•å‘¢ï¼Ÿ ç­”æ¡ˆæ˜¯æœ‰ï¼Œé‚£å°±æ˜¯å……åˆ†è¿ç”¨çŸ©é˜µçš„ç‰¹æ€§(æ¨ªå‘çºµå‘éƒ½é€’å¢)ï¼Œ
æˆ‘ä»¬å¯ä»¥ä»è§’è½(å·¦ä¸‹æˆ–è€…å³ä¸Š)å¼€å§‹éå†ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦æ˜¯ O(m + n).

![240.search-a-2-d-matrix-ii](../assets/problems/240.search-a-2-d-matrix-ii.png)

å…¶ä¸­è“è‰²ä»£è¡¨æˆ‘ä»¬é€‰æ‹©çš„èµ·ç‚¹å…ƒç´ ï¼Œ çº¢è‰²ä»£è¡¨ç›®æ ‡å…ƒç´ ã€‚

#### å…³é”®ç‚¹è§£æ

- ä»è§’è½å¼€å§‹éå†ï¼Œåˆ©ç”¨é€’å¢çš„ç‰¹æ€§ç®€åŒ–æ—¶é—´å¤æ‚åº¦

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=240 lang=javascript
 *
 * [240] Search a 2D Matrix II
 *
 * https://leetcode.com/problems/search-a-2d-matrix-ii/description/
 *
 * algorithms
 * Medium (40.30%)
 * Total Accepted:    170K
 * Total Submissions: 419.1K
 * Testcase Example:  '[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]\n5'
 *
 * Write an efficient algorithm that searches for a value in an m x n matrix.
 * This matrix has the following properties:
 *
 *
 * Integers in each row are sorted in ascending from left to right.
 * Integers in each column are sorted in ascending from top to bottom.
 *
 *
 * Example:
 *
 * Consider the following matrix:
 *
 *
 * [
 * â  [1,   4,  7, 11, 15],
 * â  [2,   5,  8, 12, 19],
 * â  [3,   6,  9, 16, 22],
 * â  [10, 13, 14, 17, 24],
 * â  [18, 21, 23, 26, 30]
 * ]
 *
 *
 * GivenÂ targetÂ =Â 5, returnÂ true.
 *
 * GivenÂ targetÂ =Â 20, returnÂ false.
 *
 */
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  if (!matrix || matrix.length === 0) return 0;

  let colIndex = 0;
  let rowIndex = matrix.length - 1;
  while (rowIndex > 0 && target < matrix[rowIndex][colIndex]) {
    rowIndex--;
  }

  while (colIndex < matrix[0].length) {
    if (target === matrix[rowIndex][colIndex]) return true;
    if (target > matrix[rowIndex][colIndex]) {
      colIndex++;
    } else if (rowIndex > 0) {
      rowIndex--;
    } else {
      return false;
    }
  }

  return false;
};
```

### [26].remove-duplicates-from-sorted-array

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/

#### é¢˜ç›®æè¿°

Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

```
// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

#### æ€è·¯

ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ¥è®°å½•éå†çš„åæ ‡ã€‚

- å¼€å§‹æ—¶è¿™ä¸¤ä¸ªæŒ‡é’ˆéƒ½æŒ‡å‘ç¬¬ä¸€ä¸ªæ•°å­—

- å¦‚æœä¸¤ä¸ªæŒ‡é’ˆæŒ‡çš„æ•°å­—ç›¸åŒï¼Œåˆ™å¿«æŒ‡é’ˆå‘å‰èµ°ä¸€æ­¥

- å¦‚æœä¸åŒï¼Œåˆ™ä¸¤ä¸ªæŒ‡é’ˆéƒ½å‘å‰èµ°ä¸€æ­¥

- å½“å¿«æŒ‡é’ˆèµ°å®Œæ•´ä¸ªæ•°ç»„åï¼Œæ…¢æŒ‡é’ˆå½“å‰çš„åæ ‡åŠ  1 å°±æ˜¯æ•°ç»„ä¸­ä¸åŒæ•°å­—çš„ä¸ªæ•°

![26.remove-duplicates-from-sorted-array](../assets/26.remove-duplicates-from-sorted-array.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

#### å…³é”®ç‚¹è§£æ

- åŒæŒ‡é’ˆ

è¿™é“é¢˜å¦‚æœä¸è¦æ±‚ï¼ŒO(n)çš„æ—¶é—´å¤æ‚åº¦ï¼Œ O(1)çš„ç©ºé—´å¤æ‚åº¦çš„è¯ï¼Œä¼šå¾ˆç®€å•ã€‚
ä½†æ˜¯è¿™é“é¢˜æ˜¯è¦æ±‚çš„ï¼Œè¿™ç§é¢˜çš„æ€è·¯ä¸€èˆ¬éƒ½æ˜¯é‡‡ç”¨åŒæŒ‡é’ˆ

- å¦‚æœæ˜¯æ•°æ®æ˜¯æ— åºçš„ï¼Œå°±ä¸å¯ä»¥ç”¨è¿™ç§æ–¹å¼äº†ï¼Œä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºæ’åºåœ¨ç®—æ³•ä¸­çš„åŸºç¡€æ€§å’Œé‡è¦æ€§ã€‚

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=26 lang=javascript
 *
 * [26] Remove Duplicates from Sorted Array
 *
 * https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/
 *
 * algorithms
 * Easy (39.76%)
 * Total Accepted:    539.7K
 * Total Submissions: 1.4M
 * Testcase Example:  '[1,1,2]'
 *
 * Given a sorted array nums, remove the duplicates in-place such that each
 * element appear only once and return the new length.
 *
 * Do not allocate extra space for another array, you must do this by modifying
 * the input array in-place with O(1) extra memory.
 *
 * Example 1:
 *
 *
 * Given nums = [1,1,2],
 *
 * Your function should return length = 2, with the first two elements of nums
 * being 1 and 2 respectively.
 *
 * It doesn't matter what you leave beyond the returned length.
 *
 * Example 2:
 *
 *
 * Given nums = [0,0,1,1,1,2,2,3,3,4],
 *
 * Your function should return length = 5, with the first five elements of nums
 * being modified toÂ 0, 1, 2, 3, andÂ 4 respectively.
 *
 * It doesn't matter what values are set beyondÂ the returned length.
 *
 *
 * Clarification:
 *
 * Confused why the returned value is an integer but your answer is an array?
 *
 * Note that the input array is passed in by reference, which means
 * modification to the input array will be known to the caller as well.
 *
 * Internally you can think of this:
 *
 *
 * // nums is passed in by reference. (i.e., without making a copy)
 * int len = removeDuplicates(nums);
 *
 * // any modification to nums in your function would be known by the caller.
 * // using the length returned by your function, it prints the first len
 * elements.
 * for (int i = 0; i < len; i++) {
 * print(nums[i]);
 * }
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  const size = nums.length;
  let slowP = 0;
  for (let fastP = 0; fastP < size; fastP++) {
    if (nums[fastP] !== nums[slowP]) {
      slowP++;
      nums[slowP] = nums[fastP];
    }
  }
  return slowP + 1;
};
```

### [263].ugly-number

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/ugly-number/description/

#### é¢˜ç›®æè¿°

```
Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example 1:

Input: 6
Output: true
Explanation: 6 = 2 Ã— 3
Example 2:

Input: 8
Output: true
Explanation: 8 = 2 Ã— 2 Ã— 2
Example 3:

Input: 14
Output: false
Explanation: 14 is not ugly since it includes another prime factor 7.
Note:

1 is typically treated as an ugly number.
Input is within the 32-bit signed integer range: [âˆ’231,  231 âˆ’ 1].

```

#### æ€è·¯

é¢˜ç›®è¦æ±‚ç»™å®šä¸€ä¸ªæ•°å­—ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºâ€œä¸‘é™‹æ•°â€(ugly number), ä¸‘é™‹æ•°æ˜¯æŒ‡åªåŒ…å«è´¨å› å­ 2, 3, 5 çš„æ­£æ•´æ•°ã€‚

![263.ugly-number](../assets/problems/263.ugly-number.png)

æ ¹æ®å®šä¹‰ï¼Œæˆ‘ä»¬å°†ç»™å®šæ•°å­—é™¤ä»¥ 2ã€3ã€5(é¡ºåºæ— æ‰€è°“)ï¼Œç›´åˆ°æ— æ³•æ•´é™¤ã€‚
å¦‚æœå¾—åˆ° 1ï¼Œè¯´æ˜æ˜¯æ‰€æœ‰å› å­éƒ½æ˜¯ 2 æˆ– 3 æˆ– 5ï¼Œå¦‚æœä¸æ˜¯ 1ï¼Œåˆ™ä¸æ˜¯ä¸‘é™‹æ•°ã€‚

è¿™å°±å¥½åƒæˆ‘ä»¬åˆ¤æ–­ä¸€ä¸ªæ•°å­—æ˜¯å¦ä¸º n(n ä¸ºå¤§äº 1 çš„æ­£æ•´æ•°)çš„å¹‚æ¬¡æ–¹ä¸€æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦
ä¸æ–­é™¤ä»¥ nï¼Œç›´åˆ°æ— æ³•æ•´é™¤ï¼Œå¦‚æœå¾—åˆ° 1ï¼Œé‚£ä¹ˆå°±æ˜¯ n çš„å¹‚æ¬¡æ–¹ã€‚ è¿™é“é¢˜çš„ä¸åŒåœ¨äº
å®ƒä¸å†æ˜¯æŸä¸€ä¸ªæ•°å­—çš„å¹‚æ¬¡æ–¹ï¼Œè€Œæ˜¯ä¸‰ä¸ªæ•°å­—(2ï¼Œ3ï¼Œ5)ï¼Œä¸è¿‡è§£é¢˜æ€è·¯è¿˜æ˜¯ä¸€æ ·çš„ã€‚

è½¬åŒ–ä¸ºä»£ç å¯ä»¥æ˜¯ï¼š

```js
while (num % 2 === 0) num = num / 2;
while (num % 3 === 0) num = num / 3;
while (num % 5 === 0) num = num / 5;

return num === 1;
```

> æˆ‘ä¸‹æ–¹ç»™å‡ºçš„ä»£ç æ˜¯ç”¨äº†é€’å½’å®ç°ï¼Œåªæ˜¯ç»™å¤§å®¶çœ‹ä¸‹ä¸åŒçš„å†™æ³•è€Œå·²ã€‚

#### å…³é”®ç‚¹

- æ•°è®º
- å› æ•°åˆ†è§£

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=263 lang=javascript
 *
 * [263] Ugly Number
 */
/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
  // TAG: æ•°è®º
  if (num <= 0) return false;
  if (num === 1) return true;

  const list = [2, 3, 5];

  if (list.includes(num)) return true;

  for (let i of list) {
    if (num % i === 0) return isUgly(Math.floor(num / i));
  }
  return false;
};
```

### [279].perfect-squares

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/perfect-squares/description/

#### é¢˜ç›®æè¿°

```
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.

```

#### æ€è·¯

ç›´æ¥é€’å½’å¤„ç†å³å¯ï¼Œä½†æ˜¯è¿™ç§æš´åŠ›çš„è§£æ³•å¾ˆå®¹æ˜“è¶…æ—¶ã€‚å¦‚æœä½ æŠŠé€’å½’çš„è¿‡ç¨‹åŒ–æˆä¸€æ£µæ ‘çš„è¯(å…¶å®å°±æ˜¯é€’å½’æ ‘)ï¼Œ
å¯ä»¥çœ‹å‡ºä¸­é—´æœ‰å¾ˆå¤šé‡å¤çš„è®¡ç®—ã€‚

å¦‚æœèƒ½å°†é‡å¤çš„è®¡ç®—ç¼“å­˜ä¸‹æ¥ï¼Œè¯´ä¸å®šèƒ½å¤Ÿè§£å†³æ—¶é—´å¤æ‚åº¦å¤ªé«˜çš„é—®é¢˜ã€‚

> é€’å½’å¯¹å†…å­˜çš„è¦æ±‚ä¹Ÿå¾ˆé«˜ï¼Œ å¦‚æœæ•°å­—éå¸¸å¤§ï¼Œä¹Ÿä¼šé¢ä¸´çˆ†æ ˆçš„é£é™©ï¼Œå°†é€’å½’è½¬åŒ–ä¸ºå¾ªç¯å¯ä»¥è§£å†³ã€‚

é€’å½’ + ç¼“å­˜çš„æ–¹å¼ä»£ç å¦‚ä¸‹ï¼š

```js
const mapper = {};

function d(n, level) {
  if (n === 0) return level;

  let i = 1;
  const arr = [];

  while (n - i * i >= 0) {
    const hit = mapper[n - i * i];
    if (hit) {
      arr.push(hit + level);
    } else {
      const depth = d(n - i * i, level + 1) - level;
      mapper[n - i * i] = depth;
      arr.push(depth + level);
    }
    i++;
  }

  return Math.min(...arr);
}
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  return d(n, 0);
};
```

å¦‚æœä½¿ç”¨ DPï¼Œå…¶å®æœ¬è´¨ä¸Šå’Œé€’å½’ + ç¼“å­˜ å·®ä¸å¤šã€‚

DP çš„ä»£ç è§ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å¦‚æœç”¨é€’å½’ + ç¼“å­˜ï¼Œ ç¼“å­˜çš„è®¾è®¡å¾ˆé‡è¦
  æˆ‘çš„åšæ³•æ˜¯ key å°±æ˜¯ nï¼Œvalue æ˜¯ä»¥ n ä¸ºèµ·ç‚¹ï¼Œåˆ°è¾¾åº•ç«¯çš„æ·±åº¦ã€‚
  ä¸‹æ¬¡å–å‡ºç¼“å­˜çš„æ—¶å€™ç”¨å½“å‰çš„ level + å­˜çš„æ·±åº¦ å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„ level.

- ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„æ ¸å¿ƒç‚¹è¿˜æ˜¯é€‰å’Œä¸é€‰çš„é—®é¢˜

```js
for (let i = 1; i <= n; i++) {
  for (let j = 1; j * j <= i; j++) {
    // ä¸é€‰(dp[i]) è¿˜æ˜¯  é€‰(dp[i - j * j])
    dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
  }
}
```

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=279 lang=javascript
 *
 * [279] Perfect Squares
 *
 * https://leetcode.com/problems/perfect-squares/description/
 *
 * algorithms
 * Medium (40.98%)
 * Total Accepted:    168.2K
 * Total Submissions: 408.5K
 * Testcase Example:  '12'
 *
 * Given a positive integer n, find the least number of perfect square numbers
 * (for example, 1, 4, 9, 16, ...) which sum to n.
 *
 * Example 1:
 *
 *
 * Input: n = 12
 * Output: 3
 * Explanation: 12 = 4 + 4 + 4.
 *
 * Example 2:
 *
 *
 * Input: n = 13
 * Output: 2
 * Explanation: 13 = 4 + 9.
 */
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  if (n <= 0) {
    return 0;
  }

  const dp = Array(n + 1).fill(Number.MAX_VALUE);
  dp[0] = 0;
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j * j <= i; j++) {
      // ä¸é€‰(dp[i]) è¿˜æ˜¯  é€‰(dp[i - j * j])
      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
    }
  }

  return dp[n];
};
```

### [29].divide-two-integers

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/divide-two-integers/description/

#### é¢˜ç›®æè¿°

```
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [âˆ’231,  231 âˆ’ 1]. For the purpose of this problem, assume that your function returns 231 âˆ’ 1 when the division result overflows.

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯ï¼Œå‡æ•°ä¸€æ¬¡ä¸€æ¬¡å‡å»è¢«å‡æ•°ï¼Œä¸æ–­æ›´æ–°å·®ï¼Œç›´åˆ°å·®å°äº 0ï¼Œæˆ‘ä»¬å‡äº†å¤šå°‘æ¬¡ï¼Œç»“æœå°±æ˜¯å¤šå°‘ã€‚

æ ¸å¿ƒä»£ç ï¼š

```js
let acc = divisor;
let count = 0;

while (dividend - acc >= 0) {
  acc += divisor;
  count++;
}

return count;
```

è¿™ç§åšæ³•ç®€å•ç›´è§‚ï¼Œä½†æ˜¯æ€§èƒ½å´æ¯”è¾ƒå·®. ä¸‹é¢æ¥ä»‹ç»ä¸€ç§æ€§èƒ½æ›´å¥½çš„æ–¹æ³•ã€‚

![29.divide-two-integers](../assets/problems/29.divide-two-integers.png)

é€šè¿‡ä¸Šé¢è¿™æ ·çš„åˆ†æï¼Œæˆ‘ä»¬ç›´åˆ°å¯ä»¥ä½¿ç”¨äºŒåˆ†æ³•æ¥è§£å†³ï¼Œæ€§èƒ½æœ‰å¾ˆå¤§çš„æå‡ã€‚

#### å…³é”®ç‚¹è§£æ

- äºŒåˆ†æŸ¥æ‰¾

- æ­£è´Ÿæ•°çš„åˆ¤æ–­ä¸­ï¼Œè¿™æ ·åˆ¤æ–­æ›´ç®€å•ã€‚

```js
const isNegative = dividend > 0 !== divisor > 0;
```

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=29 lang=javascript
 *
 * [29] Divide Two Integers
 */
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function(dividend, divisor) {
  if (divisor === 1) return dividend;

  // è¿™ç§æ–¹æ³•å¾ˆå·§å¦™ï¼Œå³ç¬¦å·ç›¸åŒåˆ™ä¸ºæ­£ï¼Œä¸åŒåˆ™ä¸ºè´Ÿ
  const isNegative = dividend > 0 !== divisor > 0;

  const MAX_INTERGER = Math.pow(2, 31);

  const res = helper(Math.abs(dividend), Math.abs(divisor));

  // overflow
  if (res > MAX_INTERGER - 1 || res < -1 * MAX_INTERGER) {
    return MAX_INTERGER - 1;
  }

  return isNegative ? -1 * res : res;
};

function helper(dividend, divisor) {
  // äºŒåˆ†æ³•
  if (dividend <= 0) return 0;
  if (dividend < divisor) return 0;
  if (divisor === 1) return dividend;

  let acc = 2 * divisor;
  let count = 1;

  while (dividend - acc > 0) {
    acc += acc;
    count += count;
  }
  // ç›´æ¥ä½¿ç”¨ä½ç§»è¿ç®—ï¼Œæ¯”å¦‚acc >> 1ä¼šæœ‰é—®é¢˜
  const last = dividend - Math.floor(acc / 2);

  return count + helper(last, divisor);
}
```

#### ç›¸å…³é¢˜ç›®

- [875.koko-eating-bananas](./875.koko-eating-bananas.md)

### [295].find-median-from-data-stream

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/find-median-from-data-stream/description/

#### é¢˜ç›®æè¿°

```
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

For example,
[2,3,4], the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:

void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.


Example:

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2


Follow up:

If all integer numbers from the stream are between 0 and 100, how would you optimize it?
If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚åŠ¨æ€æ•°æ®çš„ä¸­ä½æ•°ï¼Œåœ¨ leetcode éš¾åº¦ä¸º`hard`. å¦‚æœè¿™é“é¢˜æ˜¯æ±‚é™æ€æ•°æ®çš„ä¸­ä½æ•°ï¼Œæˆ‘ä»¬ç”¨æ•°ç»„å»å­˜å‚¨ï¼Œ
ç©ºé—´å¤æ‚åº¦ O(1), æ—¶é—´å¤æ‚åº¦ O(1)

> ç©ºé—´å¤æ‚åº¦æŒ‡çš„æ˜¯é™¤äº†å­˜å‚¨æ•°æ®ä¹‹å¤–é¢å¤–å¼€è¾Ÿçš„ç”¨äºè®¡ç®—ç­‰ä»»åŠ¡çš„å†…å­˜ç©ºé—´

ä»£ç ä¹Ÿæ¯”è¾ƒç®€å•

```js
function findMedian(a) {
  return a.length % 2 === 0 ? (a[a.length >> 1] + a[a.length >> (1 + 1)]) / 2 : a[a.length >> 1];
}
```

ä½†æ˜¯é¢˜ç›®è¦æ±‚æ˜¯åŠ¨æ€æ•°æ®ï¼Œ é‚£ä¹ˆæ˜¯å¦å¯ä»¥æ¯æ¬¡æ·»åŠ æ•°æ®çš„æ—¶å€™ï¼Œéƒ½å»æ’ä¸€æ¬¡åºå‘¢ï¼Ÿ
å‡å¦‚æˆ‘ä»¬æ¯æ¬¡æ’å…¥éƒ½ç”¨`å¿«é€Ÿæ’åº`è¿›è¡Œæ’åºçš„è¯ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogn) + O(1)

> O(nlogn) æ˜¯æ’åºçš„æ—¶é—´å¤æ‚åº¦ O(1)æ˜¯æŸ¥è¯¢ä¸­ä½æ•°çš„æ—¶é—´å¤æ‚åº¦

å¦‚æœä½ ç”¨è¿™ç§æ€è·¯è¿›è¡Œçš„è¯ï¼Œ ææ€• leetcode ä¼šè¶…æ—¶ã€‚

é‚£ä¹ˆå¦‚ä½•ä¼˜åŒ–å‘¢ï¼Ÿ ç­”æ¡ˆæ˜¯ä½¿ç”¨å †ï¼Œ Javaï¼Œ C++ç­‰è¯­è¨€éƒ½æœ‰`ä¼˜å…ˆçº§é˜Ÿåˆ—`ä¸­è¿™ç§æ•°æ®ç»“æ„ï¼Œ
ä¼˜å…ˆçº§é˜Ÿåˆ—æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªå †ã€‚ å…³äºå †å’Œä¼˜å…ˆçº§é˜Ÿåˆ—çš„å…³ç³»ï¼Œæˆ‘ä¼šæ”¾åœ¨ã€Šæ•°æ®ç»“æ„å’Œç®—æ³•ã€‹éƒ¨åˆ†è®²è§£ã€‚è¿™é‡Œä¸èµ˜è¿°

å¦‚æœå€ŸåŠ©å †è¿™ç§æ•°æ®ç»“æ„ï¼Œ å°±å¯ä»¥è½»æ˜“å®ç°äº†ã€‚

å…·ä½“çš„åšæ³•æ˜¯ï¼Œå»ºç«‹ä¸¤ä¸ªå †ï¼Œè¿™ä¸¤ä¸ªå †éœ€è¦æ»¡è¶³:

1. å¤§é¡¶å †å…ƒç´ éƒ½æ¯”å°é¡¶å †å°(ç”±äºå †çš„ç‰¹ç‚¹å…¶å®åªè¦æ¯”è¾ƒå †é¡¶å³å¯)
2. å¤§é¡¶å †å…ƒç´ ä¸å°äºå°é¡¶å †ï¼Œä¸”æœ€å¤šæ¯”å°é¡¶å †å¤šä¸€ä¸ªå…ƒç´ 

æ»¡è¶³ä¸Šé¢ä¸¤ä¸ªæ¡ä»¶çš„è¯ï¼Œå¦‚æœæƒ³è¦æ‰¾åˆ°ä¸­ä½æ•°ï¼Œå°±æ¯”è¾ƒç®€å•äº†

- å¦‚æœä¸¤ä¸ªå †æ•°é‡ç›¸ç­‰(æœ¬è´¨æ˜¯æ€»æ•°ä¸ºå¶æ•°), å°±ä¸¤ä¸ªå †é¡¶å…ƒç´ çš„å¹³å‡æ•°
- å¦‚æœä¸¤ä¸ªå †æ•°é‡ä¸ç›¸ç­‰(æœ¬è´¨æ˜¯æ€»æ•°ä¸ºå¥‡æ•°)ï¼Œ å°±å–å¤§é¡¶å †çš„å †é¡¶å…ƒç´ 

æ¯”å¦‚å¯¹äº[1,2,3] æ±‚ä¸­ä½æ•°ï¼š

![295.find-median-from-data-stream-1](../assets/problems/295.find-median-from-data-stream-1.png)

å†æ¯”å¦‚å¯¹äº[1,2,3, 4] æ±‚ä¸­ä½æ•°ï¼š

![295.find-median-from-data-stream-2](../assets/problems/295.find-median-from-data-stream-2.png)

#### å…³é”®ç‚¹è§£æ

- ç”¨ä¸¤ä¸ªå †(ä¸€ä¸ªå¤§é¡¶å †ï¼Œä¸€ä¸ªå°é¡¶å †)æ¥ç®€åŒ–æ—¶é—´å¤æ‚åº¦
- ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—ç®€åŒ–æ“ä½œ

> JavaScript ä¸åƒ Javaï¼Œ C++ç­‰è¯­è¨€éƒ½æœ‰`ä¼˜å…ˆçº§é˜Ÿåˆ—`ä¸­è¿™ç§æ•°æ®ç»“æ„ï¼Œ å› æ­¤å¤§å®¶å¯ä»¥ä½¿ç”¨ç¤¾åŒºçš„å®ç°
> ä¸ªäººè®¤ä¸ºæ²¡æœ‰éè¦çº ç»“äºä¼˜å…ˆçº§é˜Ÿåˆ—æ€ä¹ˆå®ç°ï¼Œ è‡³å°‘è¿™é“é¢˜ä¸æ˜¯è€ƒè¿™ä¸ªçš„
> ä¼˜å…ˆçº§é˜Ÿåˆ—çš„å®ç°ä¸ªäººè®¤ä¸ºå·²ç»è¶…è¿‡äº†è¿™é“é¢˜æƒ³è€ƒå¯Ÿçš„èŒƒç•´

#### ä»£ç 

å¦‚æœä¸ä½¿ç”¨ç°æˆçš„`ä¼˜å…ˆçº§é˜Ÿåˆ—`è¿™ç§æ•°æ®ç»“æ„ï¼Œä»£ç å¯èƒ½æ˜¯è¿™æ ·çš„ï¼š

```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
  this.maxHeap = [];
  this.minHeap = [];
};

function minHeapify() {
  this.minHeap.unshift(null);
  const a = this.minHeap;

  // ä¸ºäº†æ–¹ä¾¿å¤§å®¶ç†è§£ï¼Œè¿™é‡Œé€‰ç”¨äº†ç²—æš´çš„å®ç°
  // æ—¶é—´å¤æ‚åº¦ä¸ºO(n)
  // å…¶å®å¯ä»¥é™åˆ°O(logn)ï¼Œ å…·ä½“ç»†èŠ‚æˆ‘ä¸æƒ³åœ¨è¿™é‡Œè®²è§£å’Œå®ç°
  for (let i = a.length - 1; i >> 1 > 0; i--) {
    // è‡ªä¸‹å¾€ä¸Šå †åŒ–
    if (a[i] < a[i >> 1]) {
      // å¦‚æœå­å…ƒç´ æ›´å°ï¼Œåˆ™äº¤æ¢ä½ç½®
      const temp = a[i];
      this.minHeap[i] = a[i >> 1];
      this.minHeap[i >> 1] = temp;
    }
  }
  this.minHeap.shift(null);
}

function maxHeapify() {
  this.maxHeap.unshift(null);
  const a = this.maxHeap;

  // ä¸ºäº†æ–¹ä¾¿å¤§å®¶ç†è§£ï¼Œè¿™é‡Œé€‰ç”¨äº†ç²—æš´çš„å®ç°
  // æ—¶é—´å¤æ‚åº¦ä¸ºO(n)
  // å…¶å®å¯ä»¥é™åˆ°O(logn)ï¼Œ å…·ä½“ç»†èŠ‚æˆ‘ä¸æƒ³åœ¨è¿™é‡Œè®²è§£å’Œå®ç°
  for (let i = a.length - 1; i >> 1 > 0; i--) {
    // è‡ªä¸‹å¾€ä¸Šå †åŒ–
    if (a[i] > a[i >> 1]) {
      // å¦‚æœå­å…ƒç´ æ›´å¤§ï¼Œåˆ™äº¤æ¢ä½ç½®
      const temp = a[i];
      this.maxHeap[i] = a[i >> 1];
      this.maxHeap[i >> 1] = temp;
    }
  }
  this.maxHeap.shift(null);
}

/**
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
  // ä¸ºäº†å¤§å®¶å®¹æ˜“ç†è§£ï¼Œè¿™éƒ¨åˆ†ä»£ç å†™çš„æ¯”è¾ƒå†—ä½™

  // æ’å…¥
  if (num >= (this.minHeap[0] || Number.MIN_VALUE)) {
    this.minHeap.push(num);
  } else {
    this.maxHeap.push(num);
  }
  // è°ƒæ•´ä¸¤ä¸ªå †çš„èŠ‚ç‚¹æ•°é‡å¹³è¡¡
  // ä½¿å¾—å¤§é¡¶å †çš„æ•°é‡æœ€å¤šå¤§äºå°é¡¶å †ä¸€ä¸ªï¼Œ ä¸”ä¸€å®šä¸å°äºå°é¡¶å †æ•°é‡
  if (this.maxHeap.length > this.minHeap.length + 1) {
    // å¤§é¡¶å †çš„å †é¡¶å…ƒç´ ç§»åŠ¨åˆ°å°é¡¶å †
    this.minHeap.push(this.maxHeap.shift());
  }

  if (this.minHeap.length > this.maxHeap.length) {
    // å°é¡¶å †çš„å †é¡¶å…ƒç´ ç§»åŠ¨åˆ°å¤§é¡¶å †
    this.maxHeap.push(this.minHeap.shift());
  }

  // è°ƒæ•´å †é¡¶å…ƒç´ 
  if (this.maxHeap[0] > this.minHeap[0]) {
    const temp = this.maxHeap[0];
    this.maxHeap[0] = this.minHeap[0];
    this.minHeap[0] = temp;
  }

  // å †åŒ–
  maxHeapify.call(this);
  minHeapify.call(this);
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
  if ((this.maxHeap.length + this.minHeap.length) % 2 === 0) {
    return (this.minHeap[0] + this.maxHeap[0]) / 2;
  } else {
    return this.maxHeap[0];
  }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
```

å…¶ä¸­`minHeapify` å’Œ `maxHeapify` çš„è¿‡ç¨‹éƒ½æœ‰ä¸€ä¸ª hack æ“ä½œï¼Œå°±æ˜¯ï¼š

```js
this.heap.unshift(null);
// ....
this.heap.shift(null);
```

å…¶å®å°±æ˜¯ä¸ºäº†å­˜å‚¨çš„æ•°æ®ä» 1 å¼€å§‹ï¼Œè¿™æ ·æ–¹ä¾¿è®¡ç®—ã€‚ å³å¯¹äºä¸‹æ ‡ä¸º i çš„å…ƒç´ ï¼Œ `i >> 1` ä¸€å®šæ˜¯çˆ¶èŠ‚ç‚¹çš„ä¸‹æ ‡ã€‚

![295.find-median-from-data-stream-3](../assets/problems/295.find-median-from-data-stream-3.png)

> è¿™æ˜¯å› ä¸ºæˆ‘ç”¨æ»¡äºŒå‰æ ‘æ¥å­˜å‚¨çš„å †

è¿™ä¸ªå®ç°æ¯”è¾ƒç¹çï¼Œä¸‹é¢ä»‹ç»ä¸€ç§ä¼˜é›…çš„æ–¹å¼ï¼Œå‡è®¾ JS å’Œ Java å’Œ C++ç­‰è¯­è¨€ä¸€æ ·æœ‰`PriorityQueue`è¿™ç§æ•°æ®ç»“æ„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å®ç°å°±æ¯”è¾ƒç®€å•äº†ã€‚

ä»£ç ï¼š

> å…³äº PriorityQueue çš„å®ç°ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥çœ‹ä¸‹ https://github.com/janogonzalez/priorityqueuejs

```js
/*
 * @lc app=leetcode id=295 lang=javascript
 *
 * [295] Find Median from Data Stream
 *
 * https://leetcode.com/problems/find-median-from-data-stream/description/
 *
 * algorithms
 * Hard (35.08%)
 * Total Accepted:    101.2K
 * Total Submissions: 282.4K
 * Testcase Example:  '["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]\n[[],[1],[2],[],[3],[]]'
 *
 * Median is the middle value in an ordered integer list. If the size of the
 * list is even, there is no middle value. So the median is the mean of the two
 * middle value.
 * For example,
 *
 * [2,3,4], the median is 3
 *
 * [2,3], the median is (2 + 3) / 2 = 2.5
 *
 * Design a data structure that supports the following two operations:
 *
 *
 * void addNum(int num) - Add a integer number from the data stream to the data
 * structure.
 * double findMedian() - Return the median of all elements so far.
 *
 *
 *
 *
 * Example:
 *
 *
 * addNum(1)
 * addNum(2)
 * findMedian() -> 1.5
 * addNum(3)
 * findMedian() -> 2
 *
 *
 *
 *
 * Follow up:
 *
 *
 * If all integer numbers from the stream are between 0Â and 100, how would you
 * optimize it?
 * If 99% of all integer numbers from the stream are between 0 and 100, how
 * would you optimize it?
 *
 *
 */
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
  this.maxHeap = new PriorityQueue((a, b) => a - b);
  this.minHeap = new PriorityQueue((a, b) => b - a);
};

/**
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
  // æˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯å»ºç«‹ä¸¤ä¸ªå †ï¼Œä¸€ä¸ªå¤§é¡¶å †ï¼Œä¸€ä¸ªå°é¡¶å †
  // ç»“åˆä¸­ä½æ•°çš„ç‰¹ç‚¹
  // è¿™ä¸¤ä¸ªå †éœ€è¦æ»¡è¶³:
  // 1. å¤§é¡¶å †å…ƒç´ éƒ½æ¯”å°é¡¶å †å°(ç”±äºå †çš„ç‰¹ç‚¹å…¶å®åªè¦æ¯”è¾ƒå †é¡¶å³å¯)
  // 2. å¤§é¡¶å †å…ƒç´ ä¸å°äºå°é¡¶å †ï¼Œä¸”æœ€å¤šæ¯”å°é¡¶å †å¤šä¸€ä¸ªå…ƒç´ 

  // æ»¡è¶³ä¸Šé¢ä¸¤ä¸ªæ¡ä»¶çš„è¯ï¼Œå¦‚æœæƒ³è¦æ‰¾åˆ°ä¸­ä½æ•°ï¼Œå°±æ¯”è¾ƒç®€å•äº†
  // å¦‚æœä¸¤ä¸ªå †æ•°é‡ç›¸ç­‰(æœ¬è´¨æ˜¯æ€»æ•°ä¸ºå¶æ•°), å°±ä¸¤ä¸ªå †é¡¶å…ƒç´ çš„å¹³å‡æ•°
  // å¦‚æœä¸¤ä¸ªå †æ•°é‡ä¸ç›¸ç­‰(æœ¬è´¨æ˜¯æ€»æ•°ä¸ºå¥‡æ•°)ï¼Œ å°±å–å¤§é¡¶å †çš„å †é¡¶å…ƒç´ 

  // é—®é¢˜å¦‚æœä¿è¯æ»¡è¶³ä¸Šè¿°ä¸¤ä¸ªç‰¹ç‚¹

  // 1. ä¿è¯ç¬¬ä¸€ç‚¹
  this.maxHeap.enq(num);
  // ç”±äºå°é¡¶å †çš„æ‰€æœ‰æ•°éƒ½æ¥è‡ªå¤§é¡¶å †çš„å †é¡¶å…ƒç´ (æœ€å¤§å€¼)
  // å› æ­¤å¯ä»¥ä¿è¯ç¬¬ä¸€ç‚¹
  this.minHeap.enq(this.maxHeap.deq());

  // 2. ä¿è¯ç¬¬äºŒç‚¹
  if (this.maxHeap.size() < this.minHeap.size()) {
    this.maxHeap.enq(this.minHeap.deq());
  }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
  if (this.maxHeap.size() == this.minHeap.size()) return (this.maxHeap.peek() + this.minHeap.peek()) / 2.0;
  else return this.maxHeap.peek();
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
```

### [301].remove-invalid-parentheses

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/remove-invalid-parentheses/description/

#### é¢˜ç›®æè¿°

```
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

Example 1:

Input: "()())()"
Output: ["()()()", "(())()"]
Example 2:

Input: "(a)())()"
Output: ["(a)()()", "(a())()"]
Example 3:

Input: ")("
Output: [""]

```

#### æ€è·¯

æˆ‘ä»¬çš„æ€è·¯æ˜¯å…ˆå†™ä¸€ä¸ªå‡½æ•°ç”¨æ¥åˆ¤æ–­ç»™å®šå­—ç¬¦ä¸²æ˜¯å¦æ˜¯æœ‰æ•ˆçš„ã€‚ ç„¶åå†å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°
ä¾æ¬¡åˆ é™¤ç¬¬ i ä¸ªå­—ç¬¦ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰æ•ˆï¼Œæœ‰æ•ˆåˆ™æ·»åŠ è¿›æœ€ç»ˆçš„è¿”å›æ•°ç»„ã€‚

è¿™æ ·çš„è¯å®ç°çš„åŠŸèƒ½å°±æ˜¯ï¼Œ åˆ é™¤`ä¸€ä¸ª` å°æ‹¬å·ä½¿ä¹‹æœ‰æ•ˆçš„æ‰€æœ‰å¯èƒ½ã€‚å› æ­¤åªéœ€è¦é€’å½’è°ƒç”¨`ä¾æ¬¡åˆ é™¤ç¬¬iä¸ªå­—ç¬¦`çš„åŠŸèƒ½å°±å¯ä»¥äº†ã€‚

è€Œä¸”ç”±äºé¢˜ç›®è¦æ±‚æ˜¯è¦åˆ é™¤æœ€å°‘çš„å°æ‹¬å·ï¼Œå› æ­¤æˆ‘ä»¬çš„æ€è·¯æ˜¯ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†ï¼Œè€Œä¸æ˜¯æ·±åº¦æœ‰é™çš„éå†ã€‚

![301.remove-invalid-parentheses](../assets/problems/301.remove-invalid-parentheses.png)

> æ²¡æœ‰åŠ¨å›¾ï¼Œè¯·è„‘è¡¥

#### å…³é”®ç‚¹è§£æ

- å¹¿åº¦æœ‰é™éå†

- ä½¿ç”¨é˜Ÿåˆ—ç®€åŒ–æ“ä½œ

- ä½¿ç”¨ä¸€ä¸ª visited çš„ mapperï¼Œ æ¥é¿å…éå†åŒæ ·çš„å­—ç¬¦ä¸²

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=301 lang=javascript
 *
 * [301] Remove Invalid Parentheses
 *
 * https://leetcode.com/problems/remove-invalid-parentheses/description/
 *
 * algorithms
 * Hard (38.52%)
 * Total Accepted:    114.3K
 * Total Submissions: 295.4K
 * Testcase Example:  '"()())()"'
 *
 * Remove the minimum number of invalid parentheses in order to make the input
 * string valid. Return all possible results.
 *
 * Note:Â The input string may contain letters other than the parentheses ( and
 * ).
 *
 * Example 1:
 *
 *
 * Input: "()())()"
 * Output: ["()()()", "(())()"]
 *
 *
 * Example 2:
 *
 *
 * Input: "(a)())()"
 * Output: ["(a)()()", "(a())()"]
 *
 *
 * Example 3:
 *
 *
 * Input: ")("
 * Output: [""]
 *
 */
var isValid = function(s) {
  let openParenthes = 0;
  for (let i = 0; i < s.length; i++) {
    if (s[i] === '(') {
      openParenthes++;
    } else if (s[i] === ')') {
      if (openParenthes === 0) return false;
      openParenthes--;
    }
  }
  return openParenthes === 0;
};
/**
 * @param {string} s
 * @return {string[]}
 */
var removeInvalidParentheses = function(s) {
  if (!s || s.length === 0) return [''];
  const ret = [];
  const queue = [s];
  const visited = {};
  let current = null;
  let removedParentheses = 0; // åªè®°å½•æœ€å°æ”¹åŠ¨

  while ((current = queue.shift())) {
    let hit = isValid(current);
    if (hit) {
      if (!removedParentheses) {
        removedParentheses = s.length - current.length;
      }
      if (s.length - current.length > removedParentheses) return ret.length === 0 ? [''] : ret;
      ret.unshift(current);
      continue;
    }
    for (let i = 0; i < current.length; i++) {
      if (current[i] !== ')' && current[i] !== '(') continue;
      const subString = current.slice(0, i).concat(current.slice(i + 1));
      if (visited[subString]) continue;
      visited[subString] = true;
      queue.push(subString);
    }
  }

  return ret.length === 0 ? [''] : ret;
};
```

#### æ‰©å±•

ç›¸ä¼¼é—®é¢˜:

[validParentheses](./validParentheses.md)

### [309].best-time-to-buy-and-sell-stock-with-cooldown

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/

#### é¢˜ç›®æè¿°

```
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:

Input: [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```

#### æ€è·¯

è¿™æ˜¯ä¸€é“å…¸å‹çš„ DP é—®é¢˜ï¼Œ DP é—®é¢˜çš„æ ¸å¿ƒæ˜¯æ‰¾åˆ°çŠ¶æ€å’ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚

è¿™é“é¢˜ç›®çš„çŠ¶æ€ä¼¼ä¹æ¯”æˆ‘ä»¬å¸¸è§çš„é‚£ç§ DP é—®é¢˜è¦å¤šï¼Œè¿™é‡Œçš„çŠ¶æ€æœ‰ buy sell cooldown ä¸‰ç§ï¼Œ
æˆ‘ä»¬å¯ä»¥ç”¨ä¸‰ä¸ªæ•°ç»„æ¥è¡¨ç¤ºè¿™è¿™ä¸‰ä¸ªçŠ¶æ€ï¼Œbuy,sell, cooldown.

- buy[i]è¡¨ç¤ºç¬¬ i å¤©ï¼Œä¸”ä»¥ buy ç»“å°¾çš„æœ€å¤§åˆ©æ¶¦
- sell[i]è¡¨ç¤ºç¬¬ i å¤©ï¼Œä¸”ä»¥ sell ç»“å°¾çš„æœ€å¤§åˆ©æ¶¦
- cooldown[i]è¡¨ç¤ºç¬¬ i å¤©ï¼Œä¸”ä»¥ sell ç»“å°¾çš„æœ€å¤§åˆ©æ¶¦

æˆ‘ä»¬æ€è€ƒä¸€ä¸‹ï¼Œå…¶å® cooldown è¿™ä¸ªçŠ¶æ€æ•°ç»„ä¼¼ä¹æ²¡æœ‰ä»€ä¹ˆç”¨ï¼Œå› æ­¤ cooldown ä¸ä¼šå¯¹`profit`äº§ç”Ÿ
ä»»ä½•å½±å“ã€‚ æˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥ç¼©å°ä¸ºä¸¤ç§çŠ¶æ€ã€‚

- buy[i] è¡¨ç¤ºç¬¬ i å¤©ï¼Œä¸”ä»¥ buy æˆ–è€… coolwown ç»“å°¾çš„æœ€å¤§åˆ©æ¶¦
- sell[i] è¡¨ç¤ºç¬¬ i å¤©ï¼Œä¸”ä»¥ sell æˆ–è€… cooldown ç»“å°¾çš„æœ€å¤§åˆ©æ¶¦

å¯¹åº”çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š

> è¿™ä¸ªéœ€è¦èŠ±ç‚¹æ—¶é—´æ¥ç†è§£

```
  buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
  sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
```

æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹ï¼Œbuy[i]å¯¹åº”ç¬¬ i çš„ action åªèƒ½æ˜¯ buy æˆ–è€… cooldownã€‚

- å¦‚æœæ˜¯ cooldownï¼Œé‚£ä¹ˆ profit å°±æ˜¯ buy[i - 1]
- å¦‚æœæ˜¯ buyï¼Œé‚£ä¹ˆå°±æ˜¯`å‰ä¸€ä¸ªå–çš„profitå‡å»ä»Šå¤©ä¹°è‚¡ç¥¨èŠ±çš„é’±`ï¼Œå³ sell[i -2] - prices[i]

> æ³¨æ„è¿™é‡Œæ˜¯ i - 2ï¼Œä¸æ˜¯ i-1 ï¼Œå› ä¸ºæœ‰ cooldown çš„é™åˆ¶

sell[i]å¯¹åº”ç¬¬ i çš„ action åªèƒ½æ˜¯ sell æˆ–è€… cooldownã€‚

- å¦‚æœæ˜¯ cooldownï¼Œé‚£ä¹ˆ profit å°±æ˜¯ sell[i - 1]
- å¦‚æœæ˜¯ sellï¼Œé‚£ä¹ˆå°±æ˜¯`å‰ä¸€æ¬¡ä¹°çš„æ—¶å€™è·å–çš„åˆ©æ¶¦åŠ ä¸Šè¿™æ¬¡å–çš„é’±`ï¼Œå³ buy[i - 1] + prices[i]

#### å…³é”®ç‚¹è§£æ

- å¤šçŠ¶æ€åŠ¨æ€è§„åˆ’

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=309 lang=javascript
 *
 * [309] Best Time to Buy and Sell Stock with Cooldown
 *
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
 *
 * algorithms
 * Medium (43.52%)
 * Total Accepted:    88.3K
 * Total Submissions: 201.4K
 * Testcase Example:  '[1,2,3,0,2]'
 *
 * Say you have an array for which the i^th element is the price of a given
 * stock on day i.
 *
 * Design an algorithm to find the maximum profit. You may complete as many
 * transactions as you like (ie, buy one and sell one share of the stock
 * multiple times) with the following restrictions:
 *
 *
 * You may not engage in multiple transactions at the same time (ie, you must
 * sell the stock before you buy again).
 * After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1
 * day)
 *
 *
 * Example:
 *
 *
 * Input: [1,2,3,0,2]
 * Output: 3
 * Explanation: transactions = [buy, sell, cooldown, buy, sell]
 *
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  if (prices == null || prices.length <= 1) return 0;

  // å®šä¹‰çŠ¶æ€å˜é‡
  const buy = [];
  const sell = [];
  // å¯»å¸¸
  buy[0] = -prices[0];
  buy[1] = Math.max(-prices[0], -prices[1]);
  sell[0] = 0;
  sell[1] = Math.max(0, prices[1] - prices[0]);
  for (let i = 2; i < prices.length; i++) {
    // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    // ç¬¬iå¤©åªèƒ½æ˜¯ä¹°æˆ–è€…cooldown
    // å¦‚æœä¹°åˆ©æ¶¦å°±æ˜¯sell[i - 2] - prices[i], æ³¨æ„è¿™é‡Œæ˜¯i - 2ï¼Œä¸æ˜¯ i-1 ï¼Œå› ä¸ºæœ‰cooldownçš„é™åˆ¶
    // cooldownå°±æ˜¯buy[i -1]
    buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
    // ç¬¬iå¤©åªèƒ½æ˜¯å–æˆ–è€…cooldown
    // å¦‚æœå–åˆ©æ¶¦å°±æ˜¯buy[i  -1] + prices[i]
    // cooldownå°±æ˜¯sell[i -1]
    sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
  }

  return Math.max(buy[prices.length - 1], sell[prices.length - 1], 0);
};
```

#### ç›¸å…³é¢˜ç›®

- [121.best-time-to-buy-and-sell-stock](./121.best-time-to-buy-and-sell-stock.md)
- [122.best-time-to-buy-and-sell-stock-ii](./122.best-time-to-buy-and-sell-stock-ii.md)

### [31].next-permutation

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/next-permutation/description/

#### é¢˜ç›®æè¿°

```
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 â†’ 1,3,2
3,2,1 â†’ 1,2,3
1,1,5 â†’ 1,5,1

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„æ–¹æ³•æ˜¯æˆ‘ä»¬æŒ‰é¡ºåºæ±‚å‡ºæ‰€æœ‰çš„æ’åˆ—ï¼Œå¦‚æœå½“å‰æ’åˆ—ç­‰äº numsï¼Œé‚£ä¹ˆæˆ‘ç›´æ¥å–ä¸‹ä¸€ä¸ª
ä½†æ˜¯è¿™ç§åšæ³•ä¸ç¬¦åˆ constant space è¦æ±‚(é¢˜ç›®è¦æ±‚ç›´æ¥ä¿®æ”¹åŸæ•°ç»„),æ—¶é—´å¤æ‚åº¦ä¹Ÿå¤ªé«˜ï¼Œä¸º O(n!),è‚¯å®šä¸æ˜¯åˆé€‚çš„è§£ã€‚

è¿™ç§é¢˜ç›®æ¯”è¾ƒæŠ½è±¡ï¼Œå†™å‡ ä¸ªä¾‹å­é€šå¸¸ä¼šå¸®åŠ©ç†è§£é—®é¢˜çš„è§„å¾‹ã€‚æˆ‘æ‰¾äº†å‡ ä¸ªä¾‹å­ï¼Œå…¶ä¸­è“è‰²èƒŒæ™¯è¡¨ç¤ºçš„æ˜¯å½“å‰æ•°å­—æ‰¾ä¸‹ä¸€ä¸ªæ›´å¤§æ’åˆ—çš„æ—¶å€™`éœ€è¦æ”¹å˜çš„å…ƒç´ `.

![31.next-permutation](../assets/problems/31.next-permutation-1.jpg)

æˆ‘ä»¬ä¸éš¾å‘ç°ï¼Œè“è‰²çš„æ•°å­—éƒ½æ˜¯ä»åå¾€å‰ç¬¬ä¸€ä¸ªä¸é€’å¢çš„å…ƒç´ ï¼Œå¹¶ä¸”æˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—
åªéœ€è¦æ”¹å˜è“è‰²çš„ä»¥åŠä¹‹åéƒ¨åˆ†å³å¯ï¼Œå‰é¢çš„ä¸éœ€è¦å˜ã€‚

é‚£ä¹ˆæ€ä¹ˆæ”¹å˜è“è‰²çš„ä»¥åŠåé¢éƒ¨åˆ†å‘¢ï¼Ÿä¸ºäº†ä½¿å¢é‡æœ€å°ï¼Œ
ç”±äºå‰é¢æˆ‘ä»¬è§‚å¯Ÿå‘ç°ï¼Œå…¶å®å‰©ä¸‹çš„å…ƒç´ ä»å·¦åˆ°å³æ˜¯é€’å‡çš„ï¼Œè€Œæˆ‘ä»¬æƒ³è¦å˜æˆé€’å¢çš„ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸æ–­äº¤æ¢é¦–å°¾å…ƒç´ å³å¯ã€‚

å¦å¤–æˆ‘ä»¬ä¹Ÿå¯ä»¥ä»¥å›æº¯çš„è§’åº¦æ¥æ€è€ƒè¿™ä¸ªé—®é¢˜ï¼Œè®©æˆ‘ä»¬å…ˆå›æº¯ä¸€æ¬¡ï¼š

![31.next-permutation-2](../assets/problems/31.next-permutation-2.jpg)

è¿™ä¸ªæ—¶å€™å¯ä»¥é€‰æ‹©çš„å…ƒç´ åªæœ‰ 2ï¼Œæˆ‘ä»¬æ— æ³•ç»„æˆæ›´å¤§çš„æ’åˆ—ï¼Œæˆ‘ä»¬ç»§ç»­å›æº¯ï¼Œç›´åˆ°å¦‚å›¾ï¼š

![31.next-permutation-3](../assets/problems/31.next-permutation-3.jpg)

æˆ‘ä»¬å‘ç°æˆ‘ä»¬å¯ä»¥äº¤æ¢ 4 æˆ–è€… 2 å®ç°å˜å¤§çš„æ•ˆæœï¼Œä½†æ˜¯è¦ä¿è¯å˜å¤§çš„å¹…åº¦æœ€å°(ä¸‹ä¸€ä¸ªæ›´å¤§)ï¼Œ
æˆ‘ä»¬éœ€è¦é€‰æ‹©æœ€å°çš„ï¼Œç”±äºä¹‹å‰æˆ‘ä»¬å‘ç°åé¢æ˜¯ä»å·¦åˆ°å³é€’å‡çš„ï¼Œæ˜¾ç„¶å°±æ˜¯äº¤æ¢æœ€å³é¢å¤§äº 1 çš„ã€‚

ä¹‹åå°±æ˜¯ä¸æ–­äº¤æ¢ä½¿ä¹‹å¹…åº¦æœ€å°ï¼š

![31.next-permutation-4](../assets/problems/31.next-permutation-4.jpg)

#### å…³é”®ç‚¹è§£æ

- å†™å‡ ä¸ªä¾‹å­é€šå¸¸ä¼šå¸®åŠ©ç†è§£é—®é¢˜çš„è§„å¾‹
- åœ¨æœ‰åºæ•°ç»„ä¸­é¦–å°¾æŒ‡é’ˆä¸æ–­äº¤æ¢ä½ç½®å³å¯å®ç° reverse
- æ‰¾åˆ°ä»å³è¾¹èµ·`ç¬¬ä¸€ä¸ªå¤§äºnums[i]çš„`ï¼Œå¹¶å°†å…¶å’Œ nums[i]è¿›è¡Œäº¤æ¢

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=31 lang=javascript
 *
 * [31] Next Permutation
 */

function reverseRange(A, i, j) {
  while (i < j) {
    const temp = A[i];
    A[i] = A[j];
    A[j] = temp;
    i++;
    j--;
  }
}
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  // æ—¶é—´å¤æ‚åº¦O(n) ç©ºé—´å¤æ‚åº¦O(1)
  if (nums == null || nums.length <= 1) return;

  let i = nums.length - 2;
  // ä»åå¾€å‰æ‰¾åˆ°ç¬¬ä¸€ä¸ªé™åºçš„,ç›¸å½“äºæ‰¾åˆ°äº†æˆ‘ä»¬çš„å›æº¯ç‚¹
  while (i > -1 && nums[i + 1] <= nums[i]) i--;

  // å¦‚æœæ‰¾äº†å°±swap
  if (i > -1) {
    let j = nums.length - 1;
    // æ‰¾åˆ°ä»å³è¾¹èµ·ç¬¬ä¸€ä¸ªå¤§äºnums[i]çš„ï¼Œå¹¶å°†å…¶å’Œnums[i]è¿›è¡Œäº¤æ¢
    // å› ä¸ºå¦‚æœäº¤æ¢çš„æ•°å­—æ¯”nums[i]è¿˜è¦å°è‚¯å®šä¸ç¬¦åˆé¢˜æ„
    while (nums[j] <= nums[i]) j--;
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }

  // æœ€åæˆ‘ä»¬åªéœ€è¦å°†å‰©ä¸‹çš„å…ƒç´ ä»å·¦åˆ°å³ï¼Œä¾æ¬¡å¡«å…¥å½“å‰æœ€å°çš„å…ƒç´ å°±å¯ä»¥ä¿è¯æ˜¯å¤§äºå½“å‰æ’åˆ—çš„æœ€å°å€¼äº†
  // [i + 1, A.length -1]çš„å…ƒç´ è¿›è¡Œåè½¬

  reverseRange(nums, i + 1, nums.length - 1);
};
```

#### ç›¸å…³é¢˜ç›®

- [46.next-permutation](./46.next-permutation.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [60.permutation-sequence](./60.permutation-sequence.md)(TODO)

### [32].longest-valid-parentheses

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/longest-valid-parentheses/

#### é¢˜ç›®æè¿°

```
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

#### æ€è·¯(åŠ¨æ€è§„åˆ’)

æ‰€æœ‰çš„åŠ¨æ€è§„åˆ’é—®é¢˜, é¦–å…ˆéœ€è¦è§£å†³çš„å°±æ˜¯å¦‚ä½•å¯»æ‰¾åˆé€‚çš„å­é—®é¢˜.
è¯¥é¢˜éœ€è¦æˆ‘ä»¬æ‰¾åˆ°æœ€é•¿çš„æœ‰æ•ˆæ‹¬å·å¯¹, æˆ‘ä»¬é¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯å®šä¹‰**dp[i]ä¸ºå‰ i ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹é•¿åº¦**, ä½†æ˜¯éšåæˆ‘ä»¬ä¼šå‘ç°, è¿™æ ·çš„å®šä¹‰, æˆ‘ä»¬æ— æ³•æ‰¾åˆ° dp[i]å’Œ dp[i-1]çš„ä»»ä½•å…³ç³».
æ‰€ä»¥, æˆ‘ä»¬éœ€è¦é‡æ–°æ‰¾ä¸€ä¸ªæ–°çš„å®šä¹‰: å®šä¹‰**dp[i]ä¸ºä»¥ç¬¬ i ä¸ªå­—ç¬¦ç»“å°¾çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹é•¿åº¦**. ç„¶å, æˆ‘ä»¬é€šè¿‡ä¸‹é¢è¿™ä¸ªä¾‹å­æ‰¾ä¸€ä¸‹ dp[i]å’Œ dp[i-1]ä¹‹é—´çš„å…³ç³».

```python
s = '(())())'
```

ä»ä¸Šé¢çš„ä¾‹å­æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿå‡ºä¸€ä¸‹å‡ ç‚¹ç»“è®º(**æè¿°ä¸­ i ä¸ºå›¾ä¸­çš„ dp æ•°ç»„çš„ä¸‹æ ‡, å¯¹åº” s çš„ä¸‹æ ‡åº”ä¸º i-1, ç¬¬ i ä¸ªå­—ç¬¦çš„ i ä» 1 å¼€å§‹**).

1. base case: ç©ºå­—ç¬¦ä¸²çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹é•¿åº¦è‚¯å®šä¸º 0, å³: dp[0] = 0;
2. s çš„ç¬¬**1**ä¸ªå­—ç¬¦ç»“å°¾çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹é•¿åº¦ä¸º 0, s çš„ç¬¬**2**ä¸ªå­—ç¬¦ç»“å°¾çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹é•¿åº¦ä¹Ÿä¸º 0, è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®º: æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹ä¸å¯èƒ½ä»¥'('ç»“å°¾, å³: dp[1] = d[2] = 0;
3. å½“ i ç­‰äº 3 æ—¶, æˆ‘ä»¬å¯ä»¥çœ‹å‡º dp[2]=0, dp[3]=2, å› ä¸ºç¬¬ 2 ä¸ªå­—ç¬¦(**s[1]**)å’Œç¬¬ 3 ä¸ªå­—ç¬¦(**s[2]**)æ˜¯é…å¯¹çš„;
   å½“ i ç­‰äº 4 æ—¶, æˆ‘ä»¬å¯ä»¥çœ‹å‡º dp[3]=2, dp[4]=4, å› ä¸ºæˆ‘ä»¬é…å¯¹çš„æ˜¯ç¬¬ 1 ä¸ªå­—ç¬¦(**s[0]**)å’Œç¬¬ 4 ä¸ªå­—ç¬¦(**s[3]**);
   å› æ­¤, æˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®º: å¦‚æœç¬¬**i**ä¸ªå­—ç¬¦å’Œç¬¬<strong>i-1-dp[i-1]</strong>ä¸ªå­—ç¬¦æ˜¯é…å¯¹çš„, åˆ™ dp[i] = dp[i-1] + 2, å…¶ä¸­: i-1-dp[i-1] >= 1, å› ä¸ºç¬¬ 0 ä¸ªå­—ç¬¦æ²¡æœ‰ä»»ä½•æ„ä¹‰;
4. æ ¹æ®ç¬¬ 3 æ¡è§„åˆ™æ¥è®¡ç®—çš„è¯, æˆ‘ä»¬å‘ç° dp[5]=0, dp[6]=2, ä½†æ˜¯æ˜¾ç„¶, dp[6]åº”è¯¥ä¸º 6 æ‰å¯¹, ä½†æ˜¯æˆ‘ä»¬å‘ç°å¯ä»¥å°†"(())"å’Œ"()"è¿›è¡Œæ‹¼æ¥, å³: dp[i] += dp[i-dp[i]], å³: dp[6] = 2 + dp[6-2] = 2 + dp[4] = 6

æ ¹æ®ä»¥ä¸Šè§„åˆ™, æˆ‘ä»¬æ±‚è§£ dp æ•°ç»„çš„ç»“æœä¸º: [0, 0, 0, 2, 4, 0, 6, 0], å…¶ä¸­æœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹çš„é•¿åº¦ä¸º 6. ä»¥ä¸‹ä¸ºå›¾è§£:
![32.longest-valid-parentheses](../assets/problems/32.longest-valid-parentheses.png)

#### å…³é”®ç‚¹è§£æ

1. ç¬¬ 3 ç‚¹ç‰¹å¾, éœ€è¦æ£€æŸ¥çš„å­—ç¬¦æ˜¯ s[i-1]å’Œ s[i-2-dp[i-1]], æ ¹æ®å®šä¹‰å¯çŸ¥: i-1 >= dp[i-1], ä½†æ˜¯ i-2 ä¸ä¸€å®šå¤§äº dp[i-1], å› æ­¤, éœ€è¦æ£€æŸ¥è¶Šç•Œ;
2. ç¬¬ 4 ç‚¹ç‰¹å¾æœ€å®¹æ˜“é—æ¼, è¿˜æœ‰å°±æ˜¯ä¸éœ€è¦æ£€æŸ¥è¶Šç•Œ, å› ä¸ºæ ¹æ®å®šä¹‰å¯çŸ¥: i >= dp[i], æ‰€ä»¥ dp[i-dp[i]]çš„è¾¹ç•Œæƒ…å†µæ˜¯ dp[0];

#### ä»£ç 

- è¯­è¨€æ”¯æŒ: Python

Python Code:

```
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        mlen = 0
        slen = len(s)
        dp = [0] * (slen + 1)
        for i in range(1, len(s) + 1):
            ### æœ‰æ•ˆçš„æ‹¬å·å¯¹ä¸å¯èƒ½ä¼šä»¥'('ç»“å°¾çš„
            if s[i - 1] == '(':
                continue

            left_paren = i - 2 - dp[i - 1]
            if left_paren >= 0 and s[left_paren] == '(':
                dp[i] = dp[i - 1] + 2

                ### æ‹¼æ¥æœ‰æ•ˆæ‹¬å·å¯¹
                if dp[i - dp[i]]:
                    dp[i] += dp[i - dp[i]]

                ### æ›´æ–°æœ€å¤§æœ‰æ•ˆæ‰©å¯¹é•¿åº¦
                if dp[i] > mlen:
                    mlen = dp[i]

        return mlen
```

#### æ‰©å±•

1. å¦‚æœåˆ¤æ–­çš„ä¸ä»…ä»…åªæœ‰'('å’Œ')', è¿˜æœ‰'[', ']', '{'å’Œ'}', è¯¥æ€ä¹ˆåŠ?
2. å¦‚æœè¾“å‡ºçš„ä¸æ˜¯é•¿åº¦, è€Œæ˜¯ä»»æ„ä¸€ä¸ªæœ€é•¿æœ‰æ•ˆæ‹¬å·å¯¹çš„å­—ç¬¦ä¸², è¯¥æ€ä¹ˆåŠ?

### [322].coin-change

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/coin-change/description/

#### é¢˜ç›®æè¿°

```
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
Note:
You may assume that you have an infinite number of each kind of coin.

```

#### æ€è·¯

å‡å¦‚æˆ‘ä»¬æŠŠ coin é€†åºæ’åˆ—ï¼Œç„¶åé€ä¸ªå–ï¼Œå–åˆ°åˆšå¥½ä¸å¤§äº amoutï¼Œä¾æ¬¡ç±»æ¨ã€‚

```
eg: å¯¹äº [1,2,5] ç»„æˆ 11 å—

- æ’åº[5,2,1]

- å–ç¬¬ä¸€ä¸ª5, æ›´æ–°amout ä¸º 11 - 5 = 6 (1âƒ£ï¸)
      6 > 5 ç»§ç»­æ›´æ–° ä¸º 6 - 5 = 1 (2âƒ£ï¸)
      1 < 5 é€€å‡º

- å–ç¬¬äºŒä¸ª2
      1 < 2 é€€å‡º

- å–æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯1

      1 === 1 æ›´æ–°ä¸º 1 - 1 = 0 (3âƒ£ï¸)

- amout ä¸º 0 é€€å‡º


å› æ­¤ç»“æœæ˜¯ 3
```

ç†Ÿæ‚‰è´ªå¿ƒç®—æ³•çš„åŒå­¦åº”è¯¥å·²ç»æ³¨æ„åˆ°äº†ï¼Œè¿™å°±æ˜¯è´ªå¿ƒç®—æ³•ï¼Œè´ªå¿ƒç®—æ³•æ›´ amount å°½å¿«åœ°å˜å¾—æ›´å°ã€‚
`ç»éªŒè¡¨æ˜ï¼Œè´ªå¿ƒç­–ç•¥æ˜¯æ­£ç¡®çš„`ã€‚ æ³¨æ„ï¼Œæˆ‘è¯´çš„æ˜¯ç»éªŒè¡¨æ˜ï¼Œ è´ªå¿ƒç®—æ³•ä¹Ÿæœ‰å¯èƒ½å‡ºé”™ã€‚ å°±æ‹¿è¿™é“é¢˜ç›®æ¥è¯´ï¼Œ
ä»–ä¹Ÿæ˜¯ä¸æ­£ç¡®çš„ï¼ æ¯”å¦‚ `coins = [1, 5, 11] amout = 15`, å› æ­¤è¿™ç§åšæ³•æœ‰æ—¶å€™ä¸é è°±ï¼Œæˆ‘ä»¬è¿˜æ˜¯é‡‡ç”¨é è°±çš„åšæ³•.

å¦‚æœæˆ‘ä»¬æš´åŠ›æ±‚è§£ï¼Œå¯¹äºæ‰€æœ‰çš„ç»„åˆéƒ½è®¡ç®—ä¸€éï¼Œç„¶åæ¯”è¾ƒï¼Œ é‚£ä¹ˆè¿™æ ·çš„å¤æ‚åº¦æ˜¯ 2 çš„ n æ¬¡æ–¹(è¿™ä¸ªå¯ä»¥é€šè¿‡æ•°å­¦å…¬å¼è¯æ˜ï¼Œè¿™é‡Œä¸æƒ³å•°å—¦äº†)ï¼Œ
è¿™ä¸ªæ˜¯ä¸å¯ä»¥æ¥å—çš„ã€‚é‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦å¯ä»¥åŠ¨æ€è§„åˆ’è§£å†³å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥ï¼ŒåŸå› å°±æ˜¯å¯ä»¥åˆ’åˆ†ä¸ºå­é—®é¢˜ï¼Œå­é—®é¢˜å¯ä»¥æ¨å¯¼å‡ºåŸé—®é¢˜

å¯¹äºåŠ¨æ€è§„åˆ’æˆ‘ä»¬å¯ä»¥å…ˆç”»ä¸€ä¸ªäºŒç»´è¡¨ï¼Œç„¶åè§‚å¯Ÿï¼Œå…¶æ˜¯å¦å¯ä»¥ç”¨ä¸€ç»´è¡¨ä»£æ›¿ã€‚
å…³äºåŠ¨æ€è§„åˆ’ä¸ºä»€ä¹ˆè¦ç”»è¡¨ï¼Œæˆ‘å·²ç»åœ¨[è¿™ç¯‡æ–‡ç« ](../thinkings/dynamic-programming.md)è§£é‡Šäº†

#### å…³é”®ç‚¹è§£æ

- åŠ¨æ€è§„åˆ’

- å­é—®é¢˜

ç”¨ dp[i] æ¥è¡¨ç¤ºç»„æˆ i å—é’±ï¼Œéœ€è¦æœ€å°‘çš„ç¡¬å¸æ•°ï¼Œé‚£ä¹ˆ

1. ç¬¬ j ä¸ªç¡¬å¸æˆ‘å¯ä»¥é€‰æ‹©ä¸æ‹¿ è¿™ä¸ªæ—¶å€™ï¼Œ ç¡¬å¸æ•° = dp[i]

2. ç¬¬ j ä¸ªç¡¬å¸æˆ‘å¯ä»¥é€‰æ‹©æ‹¿ è¿™ä¸ªæ—¶å€™ï¼Œ ç¡¬å¸æ•° = dp[i - coins[j]] + 1

- å’ŒèƒŒåŒ…é—®é¢˜ä¸åŒï¼Œ ç¡¬å¸æ˜¯å¯ä»¥æ‹¿ä»»æ„ä¸ª

- å¯¹äºæ¯ä¸€ä¸ª dp[i] æˆ‘ä»¬éƒ½é€‰æ‹©éå†ä¸€é coinï¼Œ ä¸æ–­æ›´æ–° dp[i]

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=322 lang=javascript
 *
 * [322] Coin Change
 *
 * https://leetcode.com/problems/coin-change/description/
 *
 * algorithms
 * Medium (29.25%)
 * Total Accepted:    175K
 * Total Submissions: 591.9K
 * Testcase Example:  '[1,2,5]\n11'
 *
 * You are given coins of different denominations and a total amount of money
 * amount. Write a function to compute the fewest number of coins that you need
 * to make up that amount. If that amount of money cannot be made up by any
 * combination of the coins, return -1.
 *
 * Example 1:
 *
 *
 * Input: coins = [1, 2, 5], amount = 11
 * Output: 3
 * Explanation: 11 = 5 + 5 + 1
 *
 * Example 2:
 *
 *
 * Input: coins = [2], amount = 3
 * Output: -1
 *
 *
 * Note:
 * You may assume that you have an infinite number of each kind of coin.
 *
 */
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */

var coinChange = function(coins, amount) {
  if (amount === 0) {
    return 0;
  }
  const dp = Array(amount + 1).fill(Number.MAX_VALUE);
  dp[0] = 0;
  for (let i = 1; i < dp.length; i++) {
    for (let j = 0; j < coins.length; j++) {
      if (i - coins[j] >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
      }
    }
  }

  return dp[dp.length - 1] === Number.MAX_VALUE ? -1 : dp[dp.length - 1];
};
```

#### æ‰©å±•

è¿™æ˜¯ä¸€é“å¾ˆç®€å•æè¿°çš„é¢˜ç›®ï¼Œ å› æ­¤å¾ˆå¤šæ—¶å€™ä¼šè¢«ç”¨åˆ°å¤§å…¬å¸çš„ç”µé¢ä¸­ã€‚

ç›¸ä¼¼é—®é¢˜:

[518.coin-change-2](./518.coin-change-2.md)

### [328].odd-even-linked-list

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/odd-even-linked-list/description/

#### é¢˜ç›®æè¿°

```
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:

Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL
Example 2:

Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
Note:

The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...
```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„æƒ³æ³•æ˜¯ï¼Œå…ˆéå†ä¸€éæ‰¾å‡ºå¥‡æ•°çš„èŠ‚ç‚¹ã€‚ç„¶åå†éå†ä¸€éæ‰¾å‡ºå¶æ•°èŠ‚ç‚¹ï¼Œæœ€åä¸²èµ·æ¥ã€‚

ä½†æ˜¯æœ‰ä¸¤ä¸ªé—®é¢˜ï¼Œå¦‚æœä¸ä¿®æ”¹èŠ‚ç‚¹çš„è¯ï¼Œéœ€è¦å€ŸåŠ©é¢å¤–çš„ç©ºé—´ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ Nã€‚å¦‚æœä¿®æ”¹çš„è¯ï¼Œä¼šå¯¹ç¬¬äºŒæ¬¡éå†(éå†å¶æ•°èŠ‚ç‚¹)é€ æˆå½±å“ã€‚

å› æ­¤å¯ä»¥é‡‡ç”¨ä¸€ç§åšæ³•ï¼š éå†ä¸€æ¬¡ï¼Œæ¯ä¸€æ­¥åŒæ—¶ä¿®æ”¹ä¸¤ä¸ªèŠ‚ç‚¹å°±å¥½äº†ï¼Œè¿™æ ·å°±å¯ä»¥è§„é¿ä¸Šé¢ä¸¤ä¸ªé—®é¢˜ã€‚

#### å…³é”®ç‚¹è§£æ

- ç”¨è™šæ‹ŸèŠ‚ç‚¹æ¥ç®€åŒ–æ“ä½œ

- å¾ªç¯çš„ç»“æŸæ¡ä»¶è®¾ç½®ä¸º `odd && odd.next && even && even.next`, ä¸åº”è¯¥æ˜¯`odd && even`, å¦åˆ™éœ€è¦è®°å½•ä¸€ä¸‹å¥‡æ•°èŠ‚ç‚¹çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¤æ‚äº†æ“ä½œ

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=328 lang=javascript
 *
 * [328] Odd Even Linked List
 *
 * https://leetcode.com/problems/odd-even-linked-list/description/
 *
 * algorithms
 * Medium (48.22%)
 * Total Accepted:    137.6K
 * Total Submissions: 284.2K
 * Testcase Example:  '[1,2,3,4,5]'
 *
 * Given a singly linked list, group all odd nodes together followed by the
 * even nodes. Please note here we are talking about the node number and not
 * the value in the nodes.
 *
 * You should try to do it in place. The program should run in O(1) space
 * complexity and O(nodes) time complexity.
 *
 * Example 1:
 *
 *
 * Input: 1->2->3->4->5->NULL
 * Output: 1->3->5->2->4->NULL
 *
 *
 * Example 2:
 *
 *
 * Input: 2->1->3->5->6->4->7->NULL
 * Output: 2->3->6->7->1->5->4->NULL
 *
 *
 * Note:
 *
 *
 * The relative order inside both the even and odd groups should remain as it
 * was in the input.
 * The first node is considered odd, the second node even and so on ...
 *
 *
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
  if (!head || !head.next) return head;

  const dummyHead1 = {
    next: head,
  };
  const dummyHead2 = {
    next: head.next,
  };

  let odd = dummyHead1.next;
  let even = dummyHead2.next;

  while (odd && odd.next && even && even.next) {
    const oddNext = odd.next.next;
    const evenNext = even.next.next;

    odd.next = oddNext;
    even.next = evenNext;

    odd = oddNext;
    even = evenNext;
  }

  odd.next = dummyHead2.next;

  return dummyHead1.next;
};
```

### [33].search-in-rotated-sorted-array

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/search-in-rotated-sorted-array/

#### é¢˜ç›®æè¿°

```
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

```

#### æ€è·¯

è¿™æ˜¯ä¸€ä¸ªæˆ‘åœ¨ç½‘ä¸Šçœ‹åˆ°çš„å‰ç«¯å¤´æ¡æŠ€æœ¯ç»ˆé¢çš„ä¸€ä¸ªç®—æ³•é¢˜ã€‚

é¢˜ç›®è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º lognï¼Œå› æ­¤åŸºæœ¬å°±æ˜¯äºŒåˆ†æ³•äº†ã€‚ è¿™é“é¢˜ç›®ä¸æ˜¯ç›´æ¥çš„æœ‰åºæ•°ç»„ï¼Œä¸ç„¶å°±æ˜¯ easy äº†ã€‚

é¦–å…ˆè¦çŸ¥é“ï¼Œæˆ‘ä»¬éšä¾¿é€‰æ‹©ä¸€ä¸ªç‚¹ï¼Œå°†æ•°ç»„åˆ†ä¸ºå‰åä¸¤éƒ¨åˆ†ï¼Œå…¶ä¸­ä¸€éƒ¨åˆ†ä¸€å®šæ˜¯æœ‰åºçš„ã€‚

å…·ä½“æ­¥éª¤ï¼š

- æˆ‘ä»¬å¯ä»¥å…ˆæ‰¾å‡º midï¼Œç„¶åæ ¹æ® mid æ¥åˆ¤æ–­ï¼Œmid æ˜¯åœ¨æœ‰åºçš„éƒ¨åˆ†è¿˜æ˜¯æ— åºçš„éƒ¨åˆ†

å‡å¦‚ mid å°äº startï¼Œåˆ™ mid ä¸€å®šåœ¨å³è¾¹æœ‰åºéƒ¨åˆ†ã€‚
å‡å¦‚ mid å¤§äºç­‰äº startï¼Œ åˆ™ mid ä¸€å®šåœ¨å·¦è¾¹æœ‰åºéƒ¨åˆ†ã€‚

> æ³¨æ„ç­‰å·çš„è€ƒè™‘

- ç„¶åæˆ‘ä»¬ç»§ç»­åˆ¤æ–­ target åœ¨å“ªä¸€éƒ¨åˆ†ï¼Œ æˆ‘ä»¬å°±å¯ä»¥èˆå¼ƒå¦ä¸€éƒ¨åˆ†äº†

æˆ‘ä»¬åªéœ€è¦æ¯”è¾ƒ target å’Œæœ‰åºéƒ¨åˆ†çš„è¾¹ç•Œå…³ç³»å°±è¡Œäº†ã€‚ æ¯”å¦‚ mid åœ¨å³ä¾§æœ‰åºéƒ¨åˆ†ï¼Œå³[mid, end]
é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­ target >= mid && target <= end å°±èƒ½çŸ¥é“ target åœ¨å³ä¾§æœ‰åºéƒ¨åˆ†ï¼Œæˆ‘ä»¬å°±
å¯ä»¥èˆå¼ƒå·¦è¾¹éƒ¨åˆ†äº†(start = mid + 1)ï¼Œ åä¹‹äº¦ç„¶ã€‚

æˆ‘ä»¬ä»¥([6,7,8,1,2,3,4,5], 4)ä¸ºä¾‹è®²è§£ä¸€ä¸‹ï¼š

![search-in-rotated-sorted-array-1](../assets/problems/search-in-rotated-sorted-array-1.jpg)

![search-in-rotated-sorted-array-1](../assets/problems/search-in-rotated-sorted-array-2.jpg)

#### å…³é”®ç‚¹è§£æ

- äºŒåˆ†æ³•
- æ‰¾å‡ºæœ‰åºåŒºé—´ï¼Œç„¶åæ ¹æ® target æ˜¯å¦åœ¨æœ‰åºåŒºé—´èˆå¼ƒä¸€åŠå…ƒç´ 

#### ä»£ç 

- è¯­è¨€æ”¯æŒ: Javascript

```js
/*
 * @lc app=leetcode id=33 lang=javascript
 *
 * [33] Search in Rotated Sorted Array
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  // æ—¶é—´å¤æ‚åº¦ï¼šO(logn)
  // ç©ºé—´å¤æ‚åº¦ï¼šO(1)
  // [6,7,8,1,2,3,4,5]
  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === target) return mid;

    // [start, mid]æœ‰åº

    // ï¸âš ï¸æ³¨æ„è¿™é‡Œçš„ç­‰å·
    if (nums[mid] >= nums[start]) {
      //target åœ¨ [start, mid] ä¹‹é—´

      // å…¶å®targetä¸å¯èƒ½ç­‰äºnums[mid]ï¼Œ ä½†æ˜¯ä¸ºäº†å¯¹ç§°ï¼Œæˆ‘è¿˜æ˜¯åŠ ä¸Šäº†ç­‰å·
      if (target >= nums[start] && target <= nums[mid]) {
        end = mid - 1;
      } else {
        //target ä¸åœ¨ [start, mid] ä¹‹é—´
        start = mid + 1;
      }
    } else {
      // [mid, end]æœ‰åº

      // target åœ¨ [mid, end] ä¹‹é—´
      if (target >= nums[mid] && target <= nums[end]) {
        start = mid + 1;
      } else {
        // target ä¸åœ¨ [mid, end] ä¹‹é—´
        end = mid - 1;
      }
    }
  }

  return -1;
};
```

#### æ‰©å±•

### [334].increasing-triplet-subsequence

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/increasing-triplet-subsequence/description/

#### é¢˜ç›®æè¿°

```
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

Formally the function should:

Return true if there exists i, j, k
such that arr[i] < arr[j] < arr[k] given 0 â‰¤ i < j < k â‰¤ n-1 else return false.
Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.

Example 1:

Input: [1,2,3,4,5]
Output: true
Example 2:

Input: [5,4,3,2,1]
Output: false
```

#### æ€è·¯

è¿™é“é¢˜æ˜¯æ±‚è§£é¡ºåºæ•°å­—æ˜¯å¦æœ‰ä¸‰ä¸ªé€’å¢çš„æ’åˆ—ï¼Œ æ³¨æ„è¿™é‡Œæ²¡æœ‰è¦æ±‚è¿ç»­çš„ï¼Œå› æ­¤è¯¸å¦‚æ»‘åŠ¨çª—å£çš„æ€è·¯æ˜¯ä¸å¯ä»¥çš„ã€‚
é¢˜ç›®è¦æ±‚ O(n)çš„æ—¶é—´å¤æ‚åº¦å’Œ O(1)çš„ç©ºé—´å¤æ‚åº¦ï¼Œå› æ­¤æš´åŠ›çš„åšæ³•å°±ä¸ç”¨è€ƒè™‘äº†ã€‚

æˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯`ä¾æ¬¡`æ‰¾åˆ°ä¸‰ä¸ªæ•°å­—ï¼Œå…¶é¡ºåºæ˜¯é€’å¢çš„ã€‚å› æ­¤æˆ‘ä»¬çš„åšæ³•å¯ä»¥æ˜¯ä¾æ¬¡éå†ï¼Œ
ç„¶åç»´æŠ¤ä¸‰ä¸ªå˜é‡ï¼Œåˆ†åˆ«è®°å½•æœ€å°å€¼ï¼Œç¬¬äºŒå°å€¼ï¼Œç¬¬ä¸‰å°å€¼ã€‚åªè¦æˆ‘ä»¬èƒ½å¤Ÿå¡«æ»¡è¿™ä¸‰ä¸ªå˜é‡å°±è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚

![334.increasing-triplet-subsequence](../assets/problems/334.increasing-triplet-subsequence.png)

#### å…³é”®ç‚¹è§£æ

- ç»´æŠ¤ä¸‰ä¸ªå˜é‡ï¼Œåˆ†åˆ«è®°å½•æœ€å°å€¼ï¼Œç¬¬äºŒå°å€¼ï¼Œç¬¬ä¸‰å°å€¼ã€‚åªè¦æˆ‘ä»¬èƒ½å¤Ÿå¡«æ»¡è¿™ä¸‰ä¸ªå˜é‡å°±è¿”å› trueï¼Œå¦åˆ™è¿”å› false

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=334 lang=javascript
 *
 * [334] Increasing Triplet Subsequence
 *
 * https://leetcode.com/problems/increasing-triplet-subsequence/description/
 *
 * algorithms
 * Medium (39.47%)
 * Total Accepted:    89.6K
 * Total Submissions: 226.6K
 * Testcase Example:  '[1,2,3,4,5]'
 *
 * Given an unsorted array return whether an increasing subsequence of length 3
 * exists or not in the array.
 *
 * Formally the function should:
 *
 * Return true if there exists i, j, k
 * such that arr[i] < arr[j] < arr[k] given 0 â‰¤ i < j < k â‰¤ n-1 else return
 * false.
 *
 * Note: Your algorithm should run in O(n) time complexity and O(1) space
 * complexity.
 *
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,4,5]
 * Output: true
 *
 *
 *
 * Example 2:
 *
 *
 * Input: [5,4,3,2,1]
 * Output: false
 *
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
  if (nums.length < 3) return false;
  let n1 = Number.MAX_VALUE;
  let n2 = Number.MAX_VALUE;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] <= n1) {
      n1 = nums[i];
    } else if (nums[i] <= n2) {
      n2 = nums[i];
    } else {
      return true;
    }
  }

  return false;
};
```

### [342].power-of-four

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/power-of-four/description/

#### é¢˜ç›®æè¿°

```
Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

Example 1:

Input: 16
Output: true
Example 2:

Input: 5
Output: false
Follow up: Could you solve it without loops/recursion?

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯ä¸åœé™¤ä»¥ 4 ç›´åˆ°ä¸èƒ½æ•´é™¤ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦ä¸º 1 å³å¯ã€‚ ä»£ç å¦‚ä¸‹ï¼š

```js
while (num && num % 4 == 0) {
  num /= 4;
}
return num == 1;
```

ä½†æ˜¯è¿™é“é¢˜ç›®æœ‰ä¸€ä¸ª follow up: â€œä½ æ˜¯å¦å¯ä»¥ä¸ä½¿ç”¨å¾ªç¯/é€’å½’å®Œæˆâ€ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦æ¢ç§æ€è·¯ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹ï¼Œ4 çš„å¹‚æ¬¡æ–¹ç”¨ 2 è¿›åˆ¶è¡¨ç¤ºæ˜¯ä»€ä¹ˆæ ·çš„.

![263.342.power-of-four-1](../assets/problems/342.power-of-four-1.png)

å‘ç°è§„å¾‹ï¼š 4 çš„å¹‚æ¬¡æ–¹çš„äºŒè¿›åˆ¶è¡¨ç¤º 1 çš„ä½ç½®éƒ½æ˜¯åœ¨å¥‡æ•°ä½(ä¸”ä¸åœ¨æœ€ä½ä½)ï¼Œå…¶ä»–ä½ç½®éƒ½ä¸º 0

æˆ‘ä»¬è¿˜å¯ä»¥å‘ç°ï¼š 2 çš„å¹‚æ¬¡æ–¹çš„ç‰¹ç‚¹æ˜¯æœ€ä½ä½ä¹‹å¤–ï¼Œå…¶ä»–ä½ç½®æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª 1(1 å¯ä»¥åœ¨ä»»æ„ä½ç½®)

æˆ‘ä»¬è¿›ä¸€æ­¥åˆ†æï¼Œå¦‚æœä¸€ä¸ªæ•°å­—æ˜¯å››çš„å¹‚æ¬¡æ–¹ï¼Œé‚£ä¹ˆåªéœ€è¦æ»¡è¶³ï¼š

1. æ˜¯ 2 çš„å¹‚æ¬¡æ–¹ï¼Œ å°±èƒ½ä¿è¯æœ€ä½ä½ä¹‹å¤–ï¼Œå…¶ä»–ä½ç½®æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª 1
2. è¿™ä¸ª 1 ä¸åœ¨å¶æ•°ä½ç½®ï¼Œä¸€å®šåœ¨å¥‡æ•°ä½ç½®

å¯¹äºç¬¬ä¸€ç‚¹ï¼Œå¦‚æœä¿è¯ä¸€ä¸ªæ•°å­—æ˜¯ 2 çš„å¹‚æ¬¡æ–¹å‘¢ï¼Ÿ æ˜¾ç„¶ä¸èƒ½ä¸åœé™¤ä»¥ 2ï¼Œçœ‹ç»“æœæ˜¯å¦ç­‰äº 1ï¼Œè¿™æ ·å°±å¾ªç¯äº†ã€‚
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ª trickï¼Œ å¦‚æœä¸€ä¸ªæ•°å­— n æ˜¯ 2 çš„å¹‚æ¬¡æ–¹ï¼Œé‚£ä¹ˆ n & (n - 1) ä¸€å®šç­‰äº 0ï¼Œ
è¿™ä¸ªå¯ä»¥ä½œä¸ºæ€è€ƒé¢˜ï¼Œå¤§å®¶æ€è€ƒä¸€ä¸‹ã€‚

å¯¹äºç¬¬äºŒç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å–ä¸€ä¸ªç‰¹æ®Šæ•°å­—ï¼Œè¿™ä¸ªç‰¹æ®Šæ•°å­—ï¼Œå¥‡æ•°ä½ç½®éƒ½æ˜¯ 1ï¼Œå¶æ•°ä½ç½®éƒ½æ˜¯ 0ï¼Œç„¶åå’Œè¿™ä¸ªç‰¹æ®Šæ•°å­—
`æ±‚ä¸`ï¼Œ å¦‚æœç­‰äºæœ¬èº«ï¼Œé‚£ä¹ˆæ¯«æ— ç–‘é—®ï¼Œè¿™ä¸ª 1 ä¸å†å¶æ•°ä½ç½®ï¼Œä¸€å®šåœ¨å¥‡æ•°ä½ç½®ï¼Œå› ä¸ºå¦‚æœåœ¨å¶æ•°ä½ç½®ï¼Œ`æ±‚ä¸`çš„ç»“æœå°±æ˜¯ 0 äº†
é¢˜ç›®è¦æ±‚ n æ˜¯ 32 ä½æœ‰ç¬¦å·æ•´å½¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ç‰¹æ®Šæ•°å­—å°±åº”è¯¥æ˜¯`01010101010101010101010101010101`(ä¸ç”¨æ•°äº†ï¼Œä¸€å…± 32 ä½)ã€‚

![263.342.power-of-four-2](../assets/problems/342.power-of-four-2.png)

å¦‚ä¸Šå›¾ï¼Œ64 å’Œè¿™ä¸ªç‰¹æ®Šæ•°å­—æ±‚ä¸ï¼Œå¾—åˆ°çš„æ˜¯æœ¬èº«ã€‚ 8 æ˜¯ 2 çš„æ¬¡æ–¹ï¼Œä½†æ˜¯ä¸æ˜¯ 4 çš„æ¬¡æ–¹ï¼Œæˆ‘ä»¬æ±‚ä¸ç»“æœå°±æ˜¯ 0 äº†ã€‚

ä¸ºäº†ä½“ç°è‡ªå·±çš„é€¼æ ¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è®¡ç®—å™¨ï¼Œæ¥æ‰¾ä¸€ä¸ªé€¼æ ¼æ¯”è¾ƒé«˜çš„æ•°å­—ï¼Œè¿™é‡Œæˆ‘é€‰äº†åå…­è¿›åˆ¶ï¼Œç»“æœæ˜¯`0x55555555`ã€‚

![263.342.power-of-four](../assets/problems/342.power-of-four.png)

ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

è¯´å®è¯ï¼Œè¿™ç§åšæ³•ä¸å®¹æ˜“æƒ³åˆ°ï¼Œå…¶å®è¿˜æœ‰ä¸€ç§æ–¹æ³•ã€‚
å¦‚æœä¸€ä¸ªæ•°å­—æ˜¯ 4 çš„å¹‚æ¬¡æ–¹ï¼Œé‚£ä¹ˆåªéœ€è¦æ»¡è¶³ï¼š

1. æ˜¯äºŒçš„å€æ•°
2. å‡å» 1 æ˜¯ä¸‰çš„å€æ•°

ä»£ç å¦‚ä¸‹ï¼š

```js
return num > 0 && num & (num - 1 === 0) && (num - 1) % 3 === 0;
```

#### å…³é”®ç‚¹

- æ•°è®º
- 2 çš„å¹‚æ¬¡æ–¹ç‰¹ç‚¹(æ•°å­¦æ€§è´¨ä»¥åŠäºŒè¿›åˆ¶è¡¨ç¤º)
- 4 çš„å¹‚æ¬¡æ–¹ç‰¹ç‚¹(æ•°å­¦æ€§è´¨ä»¥åŠäºŒè¿›åˆ¶è¡¨ç¤º)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=342 lang=javascript
 *
 * [342] Power of Four
 */
/**
 * @param {number} num
 * @return {boolean}
 */
var isPowerOfFour = function(num) {
  // tag: æ•°è®º

  if (num === 1) return true;
  if (num < 4) return false;

  if ((num & (num - 1)) !== 0) return false;

  return (num & 0x55555555) === num;
};
```

### [349].intersection-of-two-arrays

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/intersection-of-two-arrays/description/

#### é¢˜ç›®æè¿°

```
Given two arrays, write a function to compute their intersection.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Note:

Each element in the result must be unique.
The result can be in any order.

```

#### æ€è·¯

å…ˆéå†ç¬¬ä¸€ä¸ªæ•°ç»„ï¼Œå°†å…¶å­˜åˆ° hashtable ä¸­ï¼Œ
ç„¶åéå†ç¬¬äºŒä¸ªæ•°ç»„ï¼Œå¦‚æœåœ¨ hashtable ä¸­å­˜åœ¨å°± push åˆ° returnï¼Œç„¶åæ¸…ç©º hashtable å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

æ— 

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=349 lang=javascript
 *
 * [349] Intersection of Two Arrays
 *
 * https://leetcode.com/problems/intersection-of-two-arrays/description/
 *
 * algorithms
 * Easy (53.11%)
 * Total Accepted:    203.6K
 * Total Submissions: 380.9K
 * Testcase Example:  '[1,2,2,1]\n[2,2]'
 *
 * Given two arrays, write a function to compute their intersection.
 *
 * Example 1:
 *
 *
 * Input: nums1 = [1,2,2,1], nums2 = [2,2]
 * Output: [2]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
 * Output: [9,4]
 *
 *
 * Note:
 *
 *
 * Each element in the result must be unique.
 * The result can be in any order.
 *
 *
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  const visited = {};
  const ret = [];
  for (let i = 0; i < nums1.length; i++) {
    const num = nums1[i];

    visited[num] = num;
  }

  for (let i = 0; i < nums2.length; i++) {
    const num = nums2[i];

    if (visited[num] !== undefined) {
      ret.push(num);
      visited[num] = undefined;
    }
  }

  return ret;
};
```

### [365].water-and-jug-problem

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/water-and-jug-problem/description/

#### é¢˜ç›®æè¿°

```
You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.

If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.

Operations allowed:

Fill any of the jugs completely with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.
Example 1: (From the famous "Die Hard" example)

Input: x = 3, y = 5, z = 4
Output: True
Example 2:

Input: x = 2, y = 6, z = 5
Output: False

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“å…³äº`æ•°è®º`çš„é¢˜ç›®ï¼Œç¡®åˆ‡åœ°è¯´æ˜¯å…³äº`è£´èœ€å®šç†`(è‹±è¯­ï¼šBÃ©zout's identity)çš„é¢˜ç›®ã€‚

æ‘˜è‡ª wiki çš„å®šä¹‰ï¼š

```
å¯¹ä»»æ„ä¸¤ä¸ªæ•´æ•° aã€bï¼Œè®¾ dæ˜¯å®ƒä»¬çš„æœ€å¤§å…¬çº¦æ•°ã€‚é‚£ä¹ˆå…³äºæœªçŸ¥æ•°  xå’Œ  yçš„çº¿æ€§ä¸¢ç•ªå›¾æ–¹ç¨‹(ç§°ä¸ºè£´èœ€ç­‰å¼)ï¼š

ax+by=m

æœ‰æ•´æ•°è§£  (x,y) å½“ä¸”ä»…å½“  mæ˜¯  dçš„æ•´æ•°å€ã€‚è£´èœ€ç­‰å¼æœ‰è§£æ—¶å¿…ç„¶æœ‰æ— ç©·å¤šä¸ªè§£ã€‚

```

å› æ­¤è¿™é“é¢˜å¯ä»¥å®Œå…¨è½¬åŒ–ä¸º`è£´èœ€å®šç†`ã€‚

#### å…³é”®ç‚¹è§£æ

- æ•°è®º
- è£´èœ€å®šç†

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=365 lang=javascript
 *
 * [365] Water and Jug Problem
 *
 * https://leetcode.com/problems/water-and-jug-problem/description/
 *
 * algorithms
 * Medium (28.76%)
 * Total Accepted:    27K
 * Total Submissions: 93.7K
 * Testcase Example:  '3\n5\n4'
 *
 * You are given two jugs with capacities x and y litres. There is an infinite
 * amount of water supply available. You need to determine whether it is
 * possible to measure exactly z litres using these two jugs.
 *
 * If z liters of water is measurable, you must have z liters of water
 * contained within one or both buckets by the end.
 *
 * Operations allowed:
 *
 *
 * Fill any of the jugs completely with water.
 * Empty any of the jugs.
 * Pour water from one jug into another till the other jug is completely full
 * or the first jug itself is empty.
 *
 *
 * Example 1: (From the famous "Die Hard" example)
 *
 *
 * Input: x = 3, y = 5, z = 4
 * Output: True
 *
 *
 * Example 2:
 *
 *
 * Input: x = 2, y = 6, z = 5
 * Output: False
 *
 */
/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {boolean}
 */
var canMeasureWater = function(x, y, z) {
  if (x + y < z) return false;

  if (z === 0) return true;

  if (x === 0) return y === z;

  if (y === 0) return x === z;

  function GCD(a, b) {
    let min = Math.min(a, b);
    while (min) {
      if (a % min === 0 && b % min === 0) return min;
      min--;
    }
    return 1;
  }

  return z % GCD(x, y) === 0;
};
```

### [371].sum-of-two-integers

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/sum-of-two-integers/description/

#### é¢˜ç›®æè¿°

```
Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.

Example 1:

Input: a = 1, b = 2
Output: 3
Example 2:

Input: a = -2, b = 3
Output: 1

```

#### æ€è·¯

ä¸èƒ½ä½¿ç”¨åŠ å‡æ³•æ¥æ±‚åŠ æ³•ã€‚ æˆ‘ä»¬åªèƒ½æœç€ä½å…ƒç®—çš„è§’åº¦æ¥æ€è€ƒäº†ã€‚

ç”±äº`å¼‚æˆ–`æ˜¯`ç›¸åŒåˆ™ä½0ï¼Œä¸åŒåˆ™ä½1`ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æŠŠå¼‚æˆ–çœ‹æˆæ˜¯ä¸€ç§ä¸è¿›ä½çš„åŠ å‡æ³•ã€‚

![371.sum-of-two-integers-1](../assets/problems/371.sum-of-two-integers-1.png)

ç”±äº`ä¸`æ˜¯`å…¨éƒ¨ä½1åˆ™ä½1ï¼Œå¦åˆ™ä½0`ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æ±‚ä¸ä¹‹åå·¦ç§»ä¸€ä½æ¥è¡¨ç¤ºè¿›ä½ã€‚

![371.sum-of-two-integers-2](../assets/problems/371.sum-of-two-integers-2.png)

ç„¶åæˆ‘ä»¬å¯¹ä¸Šè¿°ä¸¤ä¸ªå…ƒç®—ç»“æœé€’å½’æ±‚è§£å³å¯ã€‚ é€’å½’çš„ç»“æŸæ¡ä»¶å°±æ˜¯å…¶ä¸­ä¸€ä¸ªä¸º 0ï¼Œæˆ‘ä»¬ç›´æ¥è¿”å›å¦ä¸€ä¸ªã€‚

#### å…³é”®ç‚¹è§£æ

- ä½è¿ç®—
- å¼‚æˆ–æ˜¯ä¸€ç§ä¸è¿›ä½çš„åŠ å‡æ³•
- æ±‚ä¸ä¹‹åå·¦ç§»ä¸€ä½æ¥å¯ä»¥è¡¨ç¤ºè¿›ä½

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=371 lang=javascript
 *
 * [371] Sum of Two Integers
 */
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var getSum = function(a, b) {
  if (a === 0) return b;

  if (b === 0) return a;

  return getSum(a ^ b, (a & b) << 1);
};
```

### [378].kth-smallest-element-in-a-sorted-matrix

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/

#### é¢˜ç›®æè¿°

```
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
Note:
You may assume k is always valid, 1 â‰¤ k â‰¤ n2.
```

#### æ€è·¯

æ˜¾ç„¶ç”¨å¤§é¡¶å †å¯ä»¥è§£å†³ï¼Œæ—¶é—´å¤æ‚åº¦ Klogn n ä¸ºæ€»çš„æ•°å­—ä¸ªæ•°,
ä½†æ˜¯è¿™ç§åšæ³•æ²¡æœ‰åˆ©ç”¨é¢˜ç›®ä¸­ sorted matrix çš„ç‰¹ç‚¹ï¼Œå› æ­¤ä¸æ˜¯ä¸€ç§å¥½çš„åšæ³•.

ä¸€ä¸ªå·§å¦™çš„æ–¹æ³•æ˜¯äºŒåˆ†æ³•ï¼Œæˆ‘ä»¬åˆ†åˆ«ä»ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå‘ä¸­é—´è¿›è¡Œæ‰«æï¼Œå¹¶ä¸”è®¡ç®—å‡ºä¸­é—´çš„æ•°å€¼ä¸æ•°ç»„ä¸­çš„è¿›è¡Œæ¯”è¾ƒï¼Œ
å¯ä»¥é€šè¿‡è®¡ç®—ä¸­é—´å€¼åœ¨è¿™ä¸ªæ•°ç»„ä¸­æ’å¤šå°‘ä½ï¼Œç„¶åå¾—åˆ°æ¯”ä¸­é—´å€¼å°çš„æˆ–è€…å¤§çš„æ•°å­—æœ‰å¤šå°‘ä¸ªï¼Œç„¶åä¸ k è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœæ¯” k å°åˆ™è¯´æ˜ä¸­é—´å€¼å¤ªå°äº†ï¼Œåˆ™å‘åç§»åŠ¨ï¼Œå¦åˆ™å‘å‰ç§»åŠ¨ã€‚

è¿™ä¸ªé¢˜ç›®çš„äºŒåˆ†ç¡®å®å¾ˆéš¾æƒ³ï¼Œæˆ‘ä»¬æ¥ä¸€æ­¥ä¸€æ­¥è§£é‡Šã€‚

æœ€æ™®é€šçš„äºŒåˆ†æ³•æ˜¯æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾æŒ‡å®šå€¼(æˆ–è€…è¯´æ»¡è¶³æŸä¸ªæ¡ä»¶çš„å€¼)ã€‚ç”±äºæ˜¯æœ‰åºçš„ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®ç´¢å¼•å…³ç³»æ¥ç¡®å®šå¤§å°å…³ç³»ï¼Œ
å› æ­¤è¿™ç§æ€è·¯æ¯”è¾ƒç›´æ¥ï¼Œä½†æ˜¯å¯¹äºè¿™é“é¢˜ç›®ç´¢å¼•å¤§å°å’Œæ•°å­—å¤§å°æ²¡æœ‰ç›´æ¥çš„å…³ç³»ï¼Œå› æ­¤è¿™ç§äºŒåˆ†æ€æƒ³å°±è¡Œä¸é€šäº†ã€‚

![378.kth-smallest-element-in-a-sorted-matrix-1](../assets/problems/378.kth-smallest-element-in-a-sorted-matrix-1.jpg)

(æ™®é€šçš„åŸºäºç´¢å¼•åˆ¤æ–­çš„äºŒåˆ†æ³•)

- æˆ‘ä»¬èƒ½å¤Ÿæ‰¾åˆ°çŸ©é˜µä¸­æœ€å¤§çš„å…ƒç´ (å³ä¸‹è§’)å’Œæœ€å°çš„å…ƒç´ (å·¦ä¸Šè§’)ã€‚æˆ‘ä»¬å¯ä»¥æ±‚å‡ºå€¼çš„ä¸­é—´ï¼Œè€Œä¸æ˜¯ä¸Šé¢é‚£ç§æ™®é€šäºŒåˆ†æ³•çš„ç´¢å¼•çš„ä¸­é—´ã€‚

![378.kth-smallest-element-in-a-sorted-matrix-3](../assets/problems/378.kth-smallest-element-in-a-sorted-matrix-3.jpg)

- æ‰¾åˆ°ä¸­é—´å€¼ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥æ‹¿è¿™ä¸ªå€¼å»è®¡ç®—æœ‰å¤šå°‘å…ƒç´ æ˜¯å°äºç­‰äºå®ƒçš„ã€‚
  å…·ä½“æ–¹å¼å°±æ˜¯æ¯”è¾ƒè¡Œçš„æœ€åä¸€åˆ—ï¼Œå¦‚æœä¸­é—´å€¼æ¯”æœ€åä¸€åˆ—å¤§ï¼Œè¯´æ˜ä¸­é—´å…ƒç´ è‚¯å®šå¤§äºè¿™ä¸€è¡Œçš„æ‰€æœ‰å…ƒç´ ã€‚ å¦åˆ™æˆ‘ä»¬ä»åå¾€å‰éå†ç›´åˆ°ä¸å¤§äºã€‚

![378.kth-smallest-element-in-a-sorted-matrix-2](../assets/problems/378.kth-smallest-element-in-a-sorted-matrix-2.jpg)

- ä¸Šä¸€æ­¥æˆ‘ä»¬ä¼šè®¡ç®—ä¸€ä¸ª countï¼Œæˆ‘ä»¬æ‹¿è¿™ä¸ª count å’Œ k è¿›è¡Œæ¯”è¾ƒ

- å¦‚æœ count å°äº kï¼Œè¯´æ˜æˆ‘ä»¬é€‰æ‹©çš„ä¸­é—´å€¼å¤ªå°äº†ï¼Œè‚¯å®šä¸ç¬¦åˆæ¡ä»¶ï¼Œæˆ‘ä»¬éœ€è¦è°ƒæ•´å·¦åŒºé—´ä¸º mid + 1

- å¦‚æœ count å¤§äº kï¼Œè¯´æ˜æˆ‘ä»¬é€‰æ‹©çš„ä¸­é—´å€¼æ­£å¥½æˆ–è€…å¤ªå¤§äº†ã€‚æˆ‘ä»¬è°ƒæ•´å³åŒºé—´ mid

> ç”±äº count å¤§äº k ä¹Ÿå¯èƒ½æˆ‘ä»¬é€‰æ‹©çš„å€¼æ˜¯æ­£å¥½çš„ï¼Œ å› æ­¤è¿™é‡Œä¸èƒ½è°ƒæ•´ä¸º mid - 1ï¼Œ å¦åˆ™å¯èƒ½ä¼šå¾—ä¸åˆ°ç»“æœ

- æœ€åç›´æ¥è¿”å› start, end, æˆ–è€… mid éƒ½å¯ä»¥ï¼Œå› æ­¤ä¸‰è€…æœ€ç»ˆä¼šæ”¶æ•›åˆ°çŸ©é˜µä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ ä¹Ÿæ­£æ˜¯æˆ‘ä»¬è¦æ‰¾çš„å…ƒç´ ã€‚

æ•´ä¸ªè®¡ç®—è¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š

![378.kth-smallest-element-in-a-sorted-matrix-4](../assets/problems/378.kth-smallest-element-in-a-sorted-matrix-4.jpg)

è¿™é‡Œæœ‰ä¸€ä¸ªå¤§å®¶æ™®ééƒ½æ¯”è¾ƒç–‘æƒ‘çš„ç‚¹ï¼Œä¹Ÿæ˜¯æˆ‘å½“åˆéå¸¸ç–‘æƒ‘ï¼Œå›°æ‰°æˆ‘å¾ˆä¹…çš„ç‚¹ï¼Œ leetcode è¯„è®ºåŒºä¹Ÿæœ‰å¾ˆå¤šäººæ¥é—®ï¼Œå°±æ˜¯â€œèƒ½å¤Ÿç¡®ä¿æœ€ç»ˆæˆ‘ä»¬æ‰¾åˆ°çš„å…ƒç´ ä¸€å®šåœ¨çŸ©é˜µä¸­ä¹ˆï¼Ÿâ€

ç­”æ¡ˆæ˜¯å¯ä»¥, `ç›¸ç­‰çš„æ—¶å€™ä¸€å®šåœ¨matrixé‡Œé¢ã€‚ å› ä¸ºåŸé—®é¢˜ä¸€å®šæœ‰è§£ï¼Œæ‰¾ä¸‹ç•Œä½¿å¾—startä¸æ–­çš„é€¼è¿‘äºçœŸå®çš„å…ƒç´ `.

æˆ‘æ˜¯çœ‹äº†è¯„è®ºåŒºä¸€ä¸ªå¤§ç¥çš„è¯„è®ºæ‰æ˜ç™½çš„ï¼Œä»¥ä¸‹æ˜¯[@GabrielaSong](https://leetcode.com/gabrielasong/)çš„è¯„è®ºåŸæ–‡ï¼š

```
The lo we returned is guaranteed to be an element in the matrix is because:
Let us assume element m is the kth smallest number in the matrix, and x is the number of element m in the matrix.
When we are about to reach convergence, if mid=m-1, its count value (the number of elements which are <= mid) would be k-x,
so we would set lo as (m-1)+1=m, in this case the hi will finally reach lo;
and if mid=m+1, its count value would be k+x-1, so we would set hi as m+1, in this case the lo will finally reach m.
To sum up, because the number lo found by binary search find is exactly the element which has k number of elements in the matrix that are <= lo,
 The equal sign guarantees there exists and only exists one number in range satisfying this condition.
 So lo must be the only element satisfying this element in the matrix.

```

æ›´å¤šè§£é‡Š,å¯ä»¥å‚è€ƒ[leetcode discuss](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173/Share-my-thoughts-and-Clean-Java-Code)

> å¦‚æœæ˜¯æ™®é€šçš„äºŒåˆ†æŸ¥æ‰¾ï¼Œæˆ‘ä»¬æ˜¯åŸºäºç´¢å¼•å»æ‰¾ï¼Œå› æ­¤ä¸ä¼šæœ‰è¿™ä¸ªé—®é¢˜ã€‚

#### å…³é”®ç‚¹è§£æ

- äºŒåˆ†æŸ¥æ‰¾

- æœ‰åºçŸ©é˜µçš„å¥—è·¯(æ–‡ç« æœ«å°¾è¿˜æœ‰ä¸€é“æœ‰åºçŸ©é˜µçš„é¢˜ç›®)

- å †(ä¼˜å…ˆçº§é˜Ÿåˆ—)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=378 lang=javascript
 *
 * [378] Kth Smallest Element in a Sorted Matrix
 */
function notGreaterCount(matrix, target) {
  // ç­‰ä»·äºåœ¨matrix ä¸­æœç´¢midï¼Œæœç´¢çš„è¿‡ç¨‹ä¸­åˆ©ç”¨æœ‰åºçš„æ€§è´¨è®°å½•æ¯”midå°çš„å…ƒç´ ä¸ªæ•°

  // æˆ‘ä»¬é€‰æ‹©å·¦ä¸‹è§’ï¼Œä½œä¸ºå¼€å§‹å…ƒç´ 
  let curRow = 0;
  // å¤šå°‘åˆ—
  const COL_COUNT = matrix[0].length;
  // æœ€åä¸€åˆ—çš„ç´¢å¼•
  const LAST_COL = COL_COUNT - 1;
  let res = 0;

  while (curRow < matrix.length) {
    // æ¯”è¾ƒæœ€åä¸€åˆ—çš„æ•°æ®å’Œtargetçš„å¤§å°
    if (matrix[curRow][LAST_COL] < target) {
      res += COL_COUNT;
    } else {
      let i = COL_COUNT - 1;
      while (i < COL_COUNT && matrix[curRow][i] > target) {
        i--;
      }
      // æ³¨æ„è¿™é‡Œè¦åŠ 1
      res += i + 1;
    }
    curRow++;
  }

  return res;
}
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(matrix, k) {
  if (matrix.length < 1) return null;
  let start = matrix[0][0];
  let end = matrix[matrix.length - 1][matrix[0].length - 1];
  while (start < end) {
    const mid = start + ((end - start) >> 1);
    const count = notGreaterCount(matrix, mid);
    if (count < k) start = mid + 1;
    else end = mid;
  }
  // è¿”å›start,mid, end éƒ½ä¸€æ ·
  return start;
};
```

#### ç›¸å…³é¢˜ç›®

- [240.search-a-2-d-matrix-ii](./240.search-a-2-d-matrix-ii.md)

### [39].combination-sum

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/combination-sum/description/

#### é¢˜ç›®æè¿°

```
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚é›†åˆï¼Œå¹¶ä¸æ˜¯`æ±‚æå€¼`ï¼Œå› æ­¤åŠ¨æ€è§„åˆ’ä¸æ˜¯ç‰¹åˆ«åˆ‡åˆï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è€ƒè™‘åˆ«çš„æ–¹æ³•ã€‚

è¿™ç§é¢˜ç›®å…¶å®æœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼Œå°±æ˜¯å›æº¯æ³•ã€‚
ç½‘ä¸Šä¹Ÿæœ‰å¤§ç¥ç»™å‡ºäº†è¿™ç§å›æº¯æ³•è§£é¢˜çš„
[é€šç”¨å†™æ³•](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)ï¼Œè¿™é‡Œçš„æ‰€æœ‰çš„è§£æ³•ä½¿ç”¨é€šç”¨æ–¹æ³•è§£ç­”ã€‚
é™¤äº†è¿™é“é¢˜ç›®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é¢˜ç›®å¯ä»¥ç”¨è¿™ç§é€šç”¨è§£æ³•ï¼Œå…·ä½“çš„é¢˜ç›®è§åæ–¹ç›¸å…³é¢˜ç›®éƒ¨åˆ†ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹é€šç”¨è§£æ³•çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ç”»äº†ä¸€å¼ å›¾ï¼š

![backtrack](../assets/problems/backtrack.png)

é€šç”¨å†™æ³•çš„å…·ä½“ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•
- backtrack è§£é¢˜å…¬å¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=39 lang=javascript
 *
 * [39] Combination Sum
 *
 * https://leetcode.com/problems/combination-sum/description/
 *
 * algorithms
 * Medium (46.89%)
 * Total Accepted:    326.7K
 * Total Submissions: 684.2K
 * Testcase Example:  '[2,3,6,7]\n7'
 *
 * Given a set of candidate numbers (candidates) (without duplicates) and a
 * target number (target), find all unique combinations in candidatesÂ where the
 * candidate numbers sums to target.
 *
 * The same repeated number may be chosen from candidatesÂ unlimited number of
 * times.
 *
 * Note:
 *
 *
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 *
 *
 * Example 1:
 *
 *
 * Input: candidates = [2,3,6,7], target = 7,
 * A solution set is:
 * [
 * â  [7],
 * â  [2,2,3]
 * ]
 *
 *
 * Example 2:
 *
 *
 * Input: candidates = [2,3,5], target = 8,
 * A solution set is:
 * [
 * [2,2,2,2],
 * [2,3,3],
 * [3,5]
 * ]
 *
 */

function backtrack(list, tempList, nums, remain, start) {
  if (remain < 0) return;
  else if (remain === 0) return list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, remain - nums[i], i); // æ•°å­—å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œ i + 1ä»£è¡¨ä¸å¯ä»¥é‡å¤åˆ©ç”¨
    tempList.pop();
  }
}
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  const list = [];
  backtrack(
    list,
    [],
    candidates.sort((a, b) => a - b),
    target,
    0,
  );
  return list;
};
```

#### ç›¸å…³é¢˜ç›®

- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [40].combination-sum-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/combination-sum-ii/description/

#### é¢˜ç›®æè¿°

```
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚é›†åˆï¼Œå¹¶ä¸æ˜¯`æ±‚æå€¼`ï¼Œå› æ­¤åŠ¨æ€è§„åˆ’ä¸æ˜¯ç‰¹åˆ«åˆ‡åˆï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è€ƒè™‘åˆ«çš„æ–¹æ³•ã€‚

è¿™ç§é¢˜ç›®å…¶å®æœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼Œå°±æ˜¯å›æº¯æ³•ã€‚
ç½‘ä¸Šä¹Ÿæœ‰å¤§ç¥ç»™å‡ºäº†è¿™ç§å›æº¯æ³•è§£é¢˜çš„
[é€šç”¨å†™æ³•](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)ï¼Œè¿™é‡Œçš„æ‰€æœ‰çš„è§£æ³•ä½¿ç”¨é€šç”¨æ–¹æ³•è§£ç­”ã€‚
é™¤äº†è¿™é“é¢˜ç›®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é¢˜ç›®å¯ä»¥ç”¨è¿™ç§é€šç”¨è§£æ³•ï¼Œå…·ä½“çš„é¢˜ç›®è§åæ–¹ç›¸å…³é¢˜ç›®éƒ¨åˆ†ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹é€šç”¨è§£æ³•çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ç”»äº†ä¸€å¼ å›¾ï¼š

![backtrack](../assets/problems/backtrack.png)

é€šç”¨å†™æ³•çš„å…·ä½“ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•
- backtrack è§£é¢˜å…¬å¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=40 lang=javascript
 *
 * [40] Combination Sum II
 *
 * https://leetcode.com/problems/combination-sum-ii/description/
 *
 * algorithms
 * Medium (40.31%)
 * Total Accepted:    212.8K
 * Total Submissions: 519K
 * Testcase Example:  '[10,1,2,7,6,1,5]\n8'
 *
 * Given a collection of candidate numbers (candidates) and a target number
 * (target), find all unique combinations in candidatesÂ where the candidate
 * numbers sums to target.
 *
 * Each number in candidatesÂ may only be used once in the combination.
 *
 * Note:
 *
 *
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 *
 *
 * Example 1:
 *
 *
 * Input: candidates =Â [10,1,2,7,6,1,5], target =Â 8,
 * A solution set is:
 * [
 * â  [1, 7],
 * â  [1, 2, 5],
 * â  [2, 6],
 * â  [1, 1, 6]
 * ]
 *
 *
 * Example 2:
 *
 *
 * Input: candidates =Â [2,5,2,1,2], target =Â 5,
 * A solution set is:
 * [
 * [1,2,2],
 * [5]
 * ]
 *
 *
 */
function backtrack(list, tempList, nums, remain, start) {
  if (remain < 0) return;
  else if (remain === 0) return list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    // å’Œ39.combination-sum çš„å…¶ä¸­ä¸€ä¸ªåŒºåˆ«å°±æ˜¯è¿™é“é¢˜candidateså¯èƒ½æœ‰é‡å¤
    // ä»£ç è¡¨ç¤ºå°±æ˜¯ä¸‹é¢è¿™ä¸€è¡Œ
    if (i > start && nums[i] == nums[i - 1]) continue; // skip duplicates
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, remain - nums[i], i + 1); // i + 1ä»£è¡¨ä¸å¯ä»¥é‡å¤åˆ©ç”¨ï¼Œ i ä»£è¡¨æ•°å­—å¯ä»¥é‡å¤ä½¿ç”¨
    tempList.pop();
  }
}
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
  const list = [];
  backtrack(
    list,
    [],
    candidates.sort((a, b) => a - b),
    target,
    0,
  );
  return list;
};
```

#### ç›¸å…³é¢˜ç›®

- [39.combination-sum](./39.combination-sum.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [416].partition-equal-subset-sum

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/partition-equal-subset-sum/description/

#### é¢˜ç›®æè¿°

```
Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Note:

Each of the array element will not exceed 100.
The array size will not exceed 200.


Example 1:

Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].


Example 2:

Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.


```

#### æ€è·¯

é¢˜ç›®è¦æ±‚ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œ é—®æ˜¯å¦èƒ½åˆ’åˆ†ä¸ºå’Œç›¸ç­‰çš„ä¸¤ä¸ªæ•°ç»„ã€‚

è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„èƒŒåŒ…é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥éå†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸€ä¸ªï¼Œæˆ‘ä»¬éƒ½åˆ†ä¸¤ç§æƒ…å†µè€ƒè™‘ï¼Œæ‹¿æˆ–è€…ä¸æ‹¿ã€‚

èƒŒåŒ…é—®é¢˜å¤„ç†è¿™ç§ç¦»æ•£çš„å¯ä»¥åˆ’åˆ†å­é—®é¢˜è§£å†³çš„é—®é¢˜å¾ˆæœ‰ç”¨ã€‚

![416.partition-equal-subset-sum-1](../assets/problems/416.partition-equal-subset-sum-1.png)

å¦‚æœèƒ½å¤Ÿè¯†åˆ«å‡ºè¿™æ˜¯ä¸€é“èƒŒåŒ…é—®é¢˜ï¼Œé‚£ä¹ˆå°±ç›¸å¯¹å®¹æ˜“äº†ã€‚

![416.partition-equal-subset-sum-2](../assets/problems/416.partition-equal-subset-sum-2.png)

#### å…³é”®ç‚¹è§£æ

- èƒŒåŒ…é—®é¢˜

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=416 lang=javascript
 *
 * [416] Partition Equal Subset Sum
 *
 * https://leetcode.com/problems/partition-equal-subset-sum/description/
 *
 * algorithms
 * Medium (39.97%)
 * Total Accepted:    79.7K
 * Total Submissions: 198.5K
 * Testcase Example:  '[1,5,11,5]'
 *
 * Given a non-empty array containing only positive integers, find if the array
 * can be partitioned into two subsets such that the sum of elements in both
 * subsets is equal.
 *
 * Note:
 *
 *
 * Each of the array element will not exceed 100.
 * The array size will not exceed 200.
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: [1, 5, 11, 5]
 *
 * Output: true
 *
 * Explanation: The array can be partitioned as [1, 5, 5] and [11].
 *
 *
 *
 *
 * Example 2:
 *
 *
 * Input: [1, 2, 3, 5]
 *
 * Output: false
 *
 * Explanation: The array cannot be partitioned into equal sum subsets.
 *
 *
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  let sum = 0;
  for (let num of nums) {
    sum += num;
  }

  if (sum & (1 === 1)) return false;

  const half = sum >> 1;

  let dp = Array(half);
  dp[0] = [true, ...Array(nums.length).fill(false)];

  for (let i = 1; i < nums.length + 1; i++) {
    dp[i] = [true, ...Array(half).fill(false)];
    for (let j = 1; j < half + 1; j++) {
      if (j >= nums[i - 1]) {
        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
      }
    }
  }

  return dp[nums.length][half];
};
```

### [42].trapping-rain-water

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/trapping-rain-water/description/

#### é¢˜ç›®æè¿°

```
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.


The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!


```

![42.trapping-rain-water-1](../assets/problems/42.trapping-rain-water-1.png)

```
Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“é›¨æ°´æ”¶é›†çš„é—®é¢˜ï¼Œ éš¾åº¦ä¸º`hard`. å¦‚å›¾æ‰€ç¤ºï¼Œè®©æˆ‘ä»¬æ±‚ä¸‹è¿‡é›¨ä¹‹åæœ€å¤šå¯ä»¥ç§¯æ”’å¤šå°‘çš„æ°´ã€‚

å¦‚æœé‡‡ç”¨æš´åŠ›æ±‚è§£çš„è¯ï¼Œæ€è·¯åº”è¯¥æ˜¯ height æ•°ç»„ä¾æ¬¡æ±‚å’Œï¼Œç„¶åç›¸åŠ ã€‚

ä¼ªä»£ç :

```js
for (let i = 0; i < height.length; i++) {
  area += (h[i] - height[i]) * 1; // hä¸ºä¸‹é›¨ä¹‹åçš„æ°´ä½
}
```

å¦‚ä¸Šå›¾é‚£ä¹ˆ h ä¸º [1, 1, 2, 2, ,2 ,2, ,3, 2, 2, 2, 1]

é—®é¢˜è½¬åŒ–ä¸ºæ±‚ hï¼Œé‚£ä¹ˆ h[i]åˆç­‰äº`å·¦å³ä¸¤ä¾§æŸ±å­çš„æœ€å¤§å€¼ä¸­çš„è¾ƒå°å€¼`ï¼Œå³
`h[i] = Math.min(å·¦è¾¹æŸ±å­æœ€å¤§å€¼, å³è¾¹æŸ±å­æœ€å¤§å€¼)`

é—®é¢˜çš„å…³é”®åœ¨äºæ±‚è§£`å·¦è¾¹æŸ±å­æœ€å¤§å€¼`å’Œ`å³è¾¹æŸ±å­æœ€å¤§å€¼`,
æˆ‘ä»¬å…¶å®å¯ä»¥ç”¨ä¸¤ä¸ªæ•°ç»„æ¥è¡¨ç¤º`leftMax`, `rightMax`ï¼Œ
ä»¥ leftMax ä¸ºä¾‹ï¼ŒleftMax[i]ä»£è¡¨ i çš„å·¦ä¾§æŸ±å­çš„æœ€å¤§å€¼ï¼Œå› æ­¤æˆ‘ä»¬ç»´æŠ¤ä¸¤ä¸ªæ•°ç»„å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- å»ºæ¨¡ `h[i] = Math.min(å·¦è¾¹æŸ±å­æœ€å¤§å€¼, å³è¾¹æŸ±å­æœ€å¤§å€¼)`(h ä¸ºä¸‹é›¨ä¹‹åçš„æ°´ä½)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=42 lang=javascript
 *
 * [42] Trapping Rain Water
 *
 * https://leetcode.com/problems/trapping-rain-water/description/
 *
 * algorithms
 * Hard (42.06%)
 * Total Accepted:    278.1K
 * Total Submissions: 651.6K
 * Testcase Example:  '[0,1,0,2,1,0,1,3,2,1,2,1]'
 *
 * Given n non-negative integers representing an elevation map where the width
 * of each bar is 1, compute how much water it is able to trap after raining.
 *
 *
 * The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].
 * In this case, 6 units of rain water (blue section) are being trapped. Thanks
 * Marcos for contributing this image!
 *
 * Example:
 *
 *
 * Input: [0,1,0,2,1,0,1,3,2,1,2,1]
 * Output: 6
 *
 */
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  let max = 0;
  let volumn = 0;
  const leftMax = [];
  const rightMax = [];

  for (let i = 0; i < height.length; i++) {
    leftMax[i] = max = Math.max(height[i], max);
  }

  max = 0;

  for (let i = height.length - 1; i >= 0; i--) {
    rightMax[i] = max = Math.max(height[i], max);
  }

  for (let i = 0; i < height.length; i++) {
    volumn = volumn + Math.min(leftMax[i], rightMax[i]) - height[i];
  }

  return volumn;
};
```

### [437].path-sum-iii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/path-sum-iii/description/

#### é¢˜ç›®æè¿°

```
You are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯è¦æˆ‘ä»¬æ±‚è§£å‡ºä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°å­å­™èŠ‚ç‚¹çš„è·¯å¾„ä¸­å’Œä¸ºæŒ‡å®šå€¼ã€‚
æ³¨æ„è¿™é‡Œï¼Œä¸ä¸€å®šæ˜¯ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œä¹Ÿä¸ä¸€å®šåœ¨å¶å­èŠ‚ç‚¹ç»“æŸã€‚

ä¸€ç§ç®€å•çš„æ€è·¯å°±æ˜¯ç›´æ¥é€’å½’è§£å†³ï¼Œç©ºé—´å¤æ‚åº¦ O(n) æ—¶é—´å¤æ‚åº¦ä»‹äº O(nlogn) å’Œ O(n^2)ï¼Œ
å…·ä½“ä»£ç ï¼š

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
// the number of the paths starting from self
function helper(root, sum) {
  if (root === null) return 0;
  const l = helper(root.left, sum - root.val);
  const r = helper(root.right, sum - root.val);

  return l + r + (root.val === sum ? 1 : 0);
}
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number}
 */
var pathSum = function(root, sum) {
  // ç©ºé—´å¤æ‚åº¦O(n) æ—¶é—´å¤æ‚åº¦ä»‹äºO(nlogn) å’Œ O(n^2)
  // tag: dfs tree
  if (root === null) return 0;
  // the number of the paths starting from self
  const self = helper(root, sum);
  // we don't know the answer, so we just pass it down
  const l = pathSum(root.left, sum);
  // we don't know the answer, so we just pass it down
  const r = pathSum(root.right, sum);

  return self + l + r;
};
```

ä½†æ˜¯è¿˜æœ‰ä¸€ç§ç©ºé—´å¤æ‚åº¦æ›´åŠ ä¼˜ç§€çš„ç®—æ³•ï¼Œåˆ©ç”¨ hashmap æ¥é¿å…é‡å¤è®¡ç®—ï¼Œæ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ O(n)ã€‚
è¿™ç§æ€è·¯æ˜¯`subarray-sum-equals-k`çš„å‡çº§ç‰ˆæœ¬ï¼Œå¦‚æœé‚£é“é¢˜ç›®ä½ å¯ä»¥ O(n)è§£å†³ï¼Œè¿™é“é¢˜ç›®éš¾åº¦å°±ä¸ä¼šå¾ˆå¤§ï¼Œ
åªæ˜¯å°†æ•°ç»„æ¢æˆäº†äºŒå‰æ ‘ã€‚å…³äºå…·ä½“çš„æ€è·¯å¯ä»¥çœ‹[è¿™é“é¢˜ç›®](./560.subarray-sum-equals-k.md)

è¿™é‡Œæœ‰ä¸€ä¸ªä¸ä¸€æ ·çš„åœ°æ–¹ï¼Œè¿™é‡Œæˆ‘è¯´æ˜ä¸€ä¸‹ï¼Œå°±æ˜¯ä¸ºä»€ä¹ˆè¦æœ‰`hashmap[acc] = hashmap[acc] - 1;`ï¼Œ
åŸå› å¾ˆç®€å•ï¼Œå°±æ˜¯æˆ‘ä»¬ DFS çš„æ—¶å€™ï¼Œä»åº•éƒ¨å¾€ä¸Šå›æº¯çš„æ—¶å€™ï¼Œmap çš„å€¼åº”è¯¥ä¹Ÿå›æº¯ã€‚å¦‚æœä½ å¯¹å›æº¯æ³•æ¯”è¾ƒç†Ÿæ‚‰çš„è¯ï¼Œ
åº”è¯¥å¾ˆå®¹æ˜“ç†è§£ï¼Œå¦‚æœä¸ç†Ÿæ‚‰å¯ä»¥å‚è€ƒ[è¿™é“é¢˜ç›®](./46.permutations.md)ï¼Œ è¿™é“é¢˜ç›®å°±æ˜¯é€šè¿‡`tempList.pop()`æ¥å®Œæˆçš„ã€‚

å¦å¤–æˆ‘ç”»äº†ä¸€ä¸ªå›¾ï¼Œç›¸ä¿¡çœ‹å®Œä½ å°±æ˜ç™½äº†ã€‚

å½“æˆ‘ä»¬æ‰§è¡Œåˆ°åº•éƒ¨çš„æ—¶å€™ï¼š

![437.path-sum-iii](../assets/problems/437.path-sum-iii-1.jpg)

æ¥ç€å¾€ä¸Šå›æº¯ï¼š

![437.path-sum-iii-2](../assets/problems/437.path-sum-iii-2.jpg)

å¾ˆå®¹æ˜“çœ‹å‡ºï¼Œæˆ‘ä»¬çš„ hashmap ä¸åº”è¯¥æœ‰ç¬¬ä¸€å¼ å›¾çš„é‚£ä¸ªè®°å½•äº†ï¼Œå› æ­¤éœ€è¦å‡å»ã€‚

å…·ä½“å®ç°è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- é€šè¿‡ hashmapï¼Œä»¥æ—¶é—´æ¢ç©ºé—´
- å¯¹äºè¿™ç§è¿ç»­çš„å…ƒç´ æ±‚å’Œé—®é¢˜ï¼Œæœ‰ä¸€ä¸ªå…±åŒçš„æ€è·¯ï¼Œå¯ä»¥å‚è€ƒ[è¿™é“é¢˜ç›®](./560.subarray-sum-equals-k.md)

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJS

```js
/*
 * @lc app=leetcode id=437 lang=javascript
 *
 * [437] Path Sum III
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(root, acc, target, hashmap) {
  // see also : https://leetcode.com/problems/subarray-sum-equals-k/

  if (root === null) return 0;
  let count = 0;
  acc += root.val;
  if (acc === target) count++;
  if (hashmap[acc - target] !== void 0) {
    count += hashmap[acc - target];
  }
  if (hashmap[acc] === void 0) {
    hashmap[acc] = 1;
  } else {
    hashmap[acc] += 1;
  }
  const res = count + helper(root.left, acc, target, hashmap) + helper(root.right, acc, target, hashmap);

  // è¿™é‡Œè¦æ³¨æ„åˆ«å¿˜è®°äº†
  hashmap[acc] = hashmap[acc] - 1;

  return res;
}

var pathSum = function(root, sum) {
  // æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯O(n)
  const hashmap = {};
  return helper(root, 0, sum, hashmap);
};
```

### [445].add-two-numbers-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/add-two-numbers-ii/description/

#### é¢˜ç›®æè¿°

```
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

Example:

Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7

```

#### æ€è·¯

ç”±äºéœ€è¦ä»ä½ä½å¼€å§‹åŠ ï¼Œç„¶åè¿›ä½ã€‚ å› æ­¤å¯ä»¥é‡‡ç”¨æ ˆæ¥ç®€åŒ–æ“ä½œã€‚
ä¾æ¬¡å°†ä¸¤ä¸ªé“¾è¡¨çš„å€¼åˆ†åˆ«å…¥æ ˆ stack1 å’Œ stack2ï¼Œç„¶åç›¸åŠ å…¥æ ˆ stackï¼Œè¿›ä½æ“ä½œç”¨ä¸€ä¸ªå˜é‡ carried è®°å½•å³å¯ã€‚

æœ€åæ ¹æ® stack ç”Ÿæˆæœ€ç»ˆçš„é“¾è¡¨å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- æ ˆçš„åŸºæœ¬æ“ä½œ
- carried å˜é‡è®°å½•è¿›ä½
- å¾ªç¯çš„ç»ˆæ­¢æ¡ä»¶è®¾ç½®æˆ`stack.length > 0` å¯ä»¥ç®€åŒ–æ“ä½œ
- æ³¨æ„ç‰¹æ®Šæƒ…å†µï¼Œ æ¯”å¦‚ 1 + 99 = 100

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=445 lang=javascript
 *
 * [445] Add Two Numbers II
 *
 * https://leetcode.com/problems/add-two-numbers-ii/description/
 *
 * algorithms
 * Medium (49.31%)
 * Total Accepted:    83.7K
 * Total Submissions: 169K
 * Testcase Example:  '[7,2,4,3]\n[5,6,4]'
 *
 * You are given two non-empty linked lists representing two non-negative
 * integers. The most significant digit comes first and each of their nodes
 * contain a single digit. Add the two numbers and return it as a linked list.
 *
 * You may assume the two numbers do not contain any leading zero, except the
 * number 0 itself.
 *
 * Follow up:
 * What if you cannot modify the input lists? In other words, reversing the
 * lists is not allowed.
 *
 *
 *
 * Example:
 *
 * Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
 * Output: 7 -> 8 -> 0 -> 7
 *
 *
 */

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  const stack1 = [];
  const stack2 = [];
  const stack = [];

  let cur1 = l1;
  let cur2 = l2;
  let curried = 0;

  while (cur1) {
    stack1.push(cur1.val);
    cur1 = cur1.next;
  }

  while (cur2) {
    stack2.push(cur2.val);
    cur2 = cur2.next;
  }

  let a = null;
  let b = null;

  while (stack1.length > 0 || stack2.length > 0) {
    a = Number(stack1.pop()) || 0;
    b = Number(stack2.pop()) || 0;

    stack.push((a + b + curried) % 10);

    if (a + b + curried >= 10) {
      curried = 1;
    } else {
      curried = 0;
    }
  }

  if (curried === 1) {
    stack.push(1);
  }

  const dummy = {};

  let current = dummy;

  while (stack.length > 0) {
    current.next = {
      val: stack.pop(),
      next: null,
    };

    current = current.next;
  }

  return dummy.next;
};
```

### [454].4-sum-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/4sum-ii/description/

#### é¢˜ç›®æè¿°

```
Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.

To make problem a bit easier, all A, B, C, D have same length of N where 0 â‰¤ N â‰¤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.

Example:

Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```

#### æ€è·¯

å¦‚æœæŒ‰ç…§å¸¸è§„æ€è·¯å»å®ŒæˆæŸ¥æ‰¾éœ€è¦å››å±‚éå†ï¼Œæ—¶é—´å¤æ‚æ˜¯ O(n^4), æ˜¾ç„¶æ˜¯è¡Œä¸é€šçš„ã€‚
å› æ­¤æˆ‘ä»¬æœ‰å¿…è¦æƒ³ä¸€ç§æ›´åŠ é«˜æ•ˆçš„ç®—æ³•ã€‚

æˆ‘ä¸€ä¸ªæ€è·¯å°±æ˜¯æˆ‘ä»¬å°†å››ä¸ªæ•°ç»„åˆ†æˆä¸¤ç»„ï¼Œä¸¤ä¸¤ç»“åˆã€‚
ç„¶åæˆ‘ä»¬åˆ†åˆ«è®¡ç®—`ä¸¤ä¸¤ç»“åˆèƒ½å¤Ÿç®—å‡ºçš„å’Œæœ‰å“ªäº›ï¼Œä»¥åŠå…¶å¯¹åº”çš„ä¸ªæ•°`ã€‚

å¦‚å›¾ï¼š

![454.4-sum-ii](../assets/problems/454.4-sum-ii.png)

è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¾—åˆ°äº†ä¸¤ä¸ª`hashTable`ï¼Œ æˆ‘ä»¬åªéœ€è¦è¿›è¡Œç®€å•çš„æ•°å­¦è¿ç®—å°±å¯ä»¥å¾—åˆ°ç»“æœã€‚

#### å…³é”®ç‚¹è§£æ

- ç©ºé—´æ¢æ—¶é—´
- ä¸¤ä¸¤åˆ†ç»„ï¼Œæ±‚å‡ºä¸¤ä¸¤ç»“åˆèƒ½å¤Ÿå¾—å‡ºçš„å¯èƒ½æ•°ï¼Œç„¶ååˆå¹¶å³å¯ã€‚

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=454 lang=javascript
 *
 * [454] 4Sum II
 *
 * https://leetcode.com/problems/4sum-ii/description/
 *
 * algorithms
 * Medium (49.93%)
 * Total Accepted:    63.2K
 * Total Submissions: 125.6K
 * Testcase Example:  '[1,2]\n[-2,-1]\n[-1,2]\n[0,2]'
 *
 * Given four lists A, B, C, D of integer values, compute how many tuples (i,
 * j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.
 *
 * To make problem a bit easier, all A, B, C, D have same length of N where 0 â‰¤
 * N â‰¤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result
 * is guaranteed to be at most 2^31 - 1.
 *
 * Example:
 *
 *
 * Input:
 * A = [ 1, 2]
 * B = [-2,-1]
 * C = [-1, 2]
 * D = [ 0, 2]
 *
 * Output:
 * 2
 *
 * Explanation:
 * The two tuples are:
 * 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
 * 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
 *
 *
 *
 *
 */
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
var fourSumCount = function(A, B, C, D) {
  const sumMapper = {};
  let res = 0;
  for (let i = 0; i < A.length; i++) {
    for (let j = 0; j < B.length; j++) {
      sumMapper[A[i] + B[j]] = (sumMapper[A[i] + B[j]] || 0) + 1;
    }
  }

  for (let i = 0; i < C.length; i++) {
    for (let j = 0; j < D.length; j++) {
      res += sumMapper[-(C[i] + D[j])] || 0;
    }
  }

  return res;
};
```

### [46].permutations

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/permutations/description/

#### é¢˜ç›®æè¿°

```
Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚é›†åˆï¼Œå¹¶ä¸æ˜¯`æ±‚æå€¼`ï¼Œå› æ­¤åŠ¨æ€è§„åˆ’ä¸æ˜¯ç‰¹åˆ«åˆ‡åˆï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è€ƒè™‘åˆ«çš„æ–¹æ³•ã€‚

è¿™ç§é¢˜ç›®å…¶å®æœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼Œå°±æ˜¯å›æº¯æ³•ã€‚
ç½‘ä¸Šä¹Ÿæœ‰å¤§ç¥ç»™å‡ºäº†è¿™ç§å›æº¯æ³•è§£é¢˜çš„
[é€šç”¨å†™æ³•](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)ï¼Œè¿™é‡Œçš„æ‰€æœ‰çš„è§£æ³•ä½¿ç”¨é€šç”¨æ–¹æ³•è§£ç­”ã€‚
é™¤äº†è¿™é“é¢˜ç›®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é¢˜ç›®å¯ä»¥ç”¨è¿™ç§é€šç”¨è§£æ³•ï¼Œå…·ä½“çš„é¢˜ç›®è§åæ–¹ç›¸å…³é¢˜ç›®éƒ¨åˆ†ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹é€šç”¨è§£æ³•çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ç”»äº†ä¸€å¼ å›¾ï¼š

![backtrack](../assets/problems/backtrack.png)

é€šç”¨å†™æ³•çš„å…·ä½“ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•
- backtrack è§£é¢˜å…¬å¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=46 lang=javascript
 *
 * [46] Permutations
 *
 * https://leetcode.com/problems/permutations/description/
 *
 * algorithms
 * Medium (53.60%)
 * Total Accepted:    344.6K
 * Total Submissions: 642.9K
 * Testcase Example:  '[1,2,3]'
 *
 * Given a collection of distinct integers, return all possible permutations.
 *
 * Example:
 *
 *
 * Input: [1,2,3]
 * Output:
 * [
 * â  [1,2,3],
 * â  [1,3,2],
 * â  [2,1,3],
 * â  [2,3,1],
 * â  [3,1,2],
 * â  [3,2,1]
 * ]
 *
 *
 */
function backtrack(list, tempList, nums) {
  if (tempList.length === nums.length) return list.push([...tempList]);
  for (let i = 0; i < nums.length; i++) {
    if (tempList.includes(nums[i])) continue;
    tempList.push(nums[i]);
    backtrack(list, tempList, nums);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const list = [];
  backtrack(list, [], nums);
  return list;
};
```

#### ç›¸å…³é¢˜ç›®

- [31.next-permutation](./31.next-permutation.md)
- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [60.permutation-sequence](./60.permutation-sequence.md)(TODO)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [47].permutations-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/permutations-ii/description/

#### é¢˜ç›®æè¿°

```
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚é›†åˆï¼Œå¹¶ä¸æ˜¯`æ±‚æå€¼`ï¼Œå› æ­¤åŠ¨æ€è§„åˆ’ä¸æ˜¯ç‰¹åˆ«åˆ‡åˆï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è€ƒè™‘åˆ«çš„æ–¹æ³•ã€‚

è¿™ç§é¢˜ç›®å…¶å®æœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼Œå°±æ˜¯å›æº¯æ³•ã€‚
ç½‘ä¸Šä¹Ÿæœ‰å¤§ç¥ç»™å‡ºäº†è¿™ç§å›æº¯æ³•è§£é¢˜çš„
[é€šç”¨å†™æ³•](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)ï¼Œè¿™é‡Œçš„æ‰€æœ‰çš„è§£æ³•ä½¿ç”¨é€šç”¨æ–¹æ³•è§£ç­”ã€‚
é™¤äº†è¿™é“é¢˜ç›®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é¢˜ç›®å¯ä»¥ç”¨è¿™ç§é€šç”¨è§£æ³•ï¼Œå…·ä½“çš„é¢˜ç›®è§åæ–¹ç›¸å…³é¢˜ç›®éƒ¨åˆ†ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹é€šç”¨è§£æ³•çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ç”»äº†ä¸€å¼ å›¾ï¼š

![backtrack](../assets/problems/backtrack.png)

é€šç”¨å†™æ³•çš„å…·ä½“ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•
- backtrack è§£é¢˜å…¬å¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=47 lang=javascript
 *
 * [47] Permutations II
 *
 * https://leetcode.com/problems/permutations-ii/description/
 *
 * algorithms
 * Medium (39.29%)
 * Total Accepted:    234.1K
 * Total Submissions: 586.2K
 * Testcase Example:  '[1,1,2]'
 *
 * Given a collection of numbers that might contain duplicates, return all
 * possible unique permutations.
 *
 * Example:
 *
 *
 * Input: [1,1,2]
 * Output:
 * [
 * â  [1,1,2],
 * â  [1,2,1],
 * â  [2,1,1]
 * ]
 *
 *
 */
function backtrack(list, nums, tempList, visited) {
  if (tempList.length === nums.length) return list.push([...tempList]);
  for (let i = 0; i < nums.length; i++) {
    // å’Œ46.permutationsçš„åŒºåˆ«æ˜¯è¿™é“é¢˜çš„numsæ˜¯å¯ä»¥é‡å¤çš„
    // æˆ‘ä»¬éœ€è¦è¿‡æ»¤è¿™ç§æƒ…å†µ
    if (visited[i]) continue; // ä¸èƒ½ç”¨tempList.includes(nums[i])äº†ï¼Œå› ä¸ºæœ‰é‡å¤
    // visited[i - 1] è¿™ä¸ªåˆ¤æ–­å®¹æ˜“å¿½ç•¥
    if (i > 0 && nums[i] === nums[i - 1] && visited[i - 1]) continue;

    visited[i] = true;
    tempList.push(nums[i]);
    backtrack(list, nums, tempList, visited);
    visited[i] = false;
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
  const list = [];
  backtrack(
    list,
    nums.sort((a, b) => a - b),
    [],
    [],
  );
  return list;
};
```

#### ç›¸å…³é¢˜ç›®

- [31.next-permutation](./31.next-permutation.md)
- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [60.permutation-sequence](./60.permutation-sequence.md)(TODO)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [48].rotate-image

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/rotate-image/description/

#### é¢˜ç›®æè¿°

```
You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

```

#### æ€è·¯

è¿™é“é¢˜ç›®è®©æˆ‘ä»¬ in-placeï¼Œä¹Ÿå°±è¯´ç©ºé—´å¤æ‚åº¦è¦æ±‚ O(1)ï¼Œå¦‚æœæ²¡æœ‰è¿™ä¸ªé™åˆ¶çš„è¯ï¼Œå¾ˆç®€å•ã€‚

é€šè¿‡è§‚å¯Ÿå‘ç°ï¼Œæˆ‘ä»¬åªéœ€è¦å°†ç¬¬ i è¡Œå˜æˆç¬¬ n - i - 1 åˆ—ï¼Œ å› æ­¤æˆ‘ä»¬åªéœ€è¦ä¿å­˜ä¸€ä¸ªåŸæœ‰çŸ©é˜µï¼Œç„¶åæŒ‰ç…§è¿™ä¸ªè§„å¾‹ä¸€ä¸ªä¸ªæ›´æ–°å³å¯ã€‚

![48.rotate-image-1](../assets/problems/48.rotate-image-1.png)

ä»£ç ï¼š

```js
var rotate = function(matrix) {
  // æ—¶é—´å¤æ‚åº¦O(n^2) ç©ºé—´å¤æ‚åº¦O(n)
  const oMatrix = JSON.parse(JSON.stringify(matrix)); // clone
  const n = oMatrix.length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      matrix[j][n - i - 1] = oMatrix[i][j];
    }
  }
};
```

å¦‚æœè¦æ±‚ç©ºé—´å¤æ‚åº¦æ˜¯ O(1)çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª temp è®°å½•å³å¯ï¼Œè¿™ä¸ªæ—¶å€™å°±ä¸èƒ½é€ä¸ªéå†äº†ã€‚
æ¯”å¦‚éå†åˆ° 1 çš„æ—¶å€™ï¼Œæˆ‘ä»¬æŠŠ 1 å­˜åˆ° tempï¼Œç„¶åæ›´æ–° 1 çš„å€¼ä¸º 7ã€‚ 1 è¢«æ¢åˆ°äº† 3 çš„ä½ç½®ï¼Œæˆ‘ä»¬å†å°† 3 å­˜åˆ° tempï¼Œä¾æ¬¡ç±»æ¨ã€‚
ä½†æ˜¯è¿™ç§è§£æ³•å†™èµ·æ¥æ¯”è¾ƒéº»çƒ¦ï¼Œè¿™é‡Œæˆ‘å°±ä¸å†™äº†ã€‚

äº‹å®ä¸Šæœ‰ä¸€ä¸ªæ›´åŠ å·§å¦™çš„åšæ³•ï¼Œæˆ‘ä»¬å¯ä»¥å·§å¦™åœ°åˆ©ç”¨å¯¹ç§°è½´æ—‹è½¬è¾¾åˆ°æˆ‘ä»¬çš„ç›®çš„ï¼Œå¦‚å›¾ï¼Œæˆ‘ä»¬å…ˆè¿›è¡Œä¸€æ¬¡ä»¥å¯¹è§’çº¿ä¸ºè½´çš„ç¿»è½¬ï¼Œç„¶å
å†è¿›è¡Œä¸€æ¬¡ä»¥æ°´å¹³è½´å¿ƒçº¿ä¸ºè½´çš„ç¿»è½¬å³å¯ã€‚

![48.rotate-image-2](../assets/problems/48.rotate-image-2.png)

è¿™ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2) ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ O(1)

#### å…³é”®ç‚¹è§£æ

- çŸ©é˜µæ—‹è½¬æ“ä½œ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=48 lang=javascript
 *
 * [48] Rotate Image
 */
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  // æ—¶é—´å¤æ‚åº¦O(n^2) ç©ºé—´å¤æ‚åº¦O(1)

  // åšæ³•ï¼š å…ˆæ²¿ç€å¯¹è§’çº¿ç¿»è½¬ï¼Œç„¶åæ²¿ç€æ°´å¹³çº¿ç¿»è½¬
  const n = matrix.length;
  function swap(arr, [i, j], [m, n]) {
    const temp = arr[i][j];
    arr[i][j] = arr[m][n];
    arr[m][n] = temp;
  }
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i; j++) {
      swap(matrix, [i, j], [n - j - 1, n - i - 1]);
    }
  }

  for (let i = 0; i < n / 2; i++) {
    for (let j = 0; j < n; j++) {
      swap(matrix, [i, j], [n - i - 1, j]);
    }
  }
};
```

### [49].group-anagrams

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/group-anagrams/description/

#### é¢˜ç›®æè¿°

```
Given an array of strings, group anagrams together.

Example:

Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
```

#### æ€è·¯

ä¸€ä¸ªç®€å•çš„è§£æ³•å°±æ˜¯éå†æ•°ç»„ï¼Œç„¶åå¯¹æ¯ä¸€é¡¹éƒ½è¿›è¡Œæ’åºï¼Œç„¶åå°†å…¶æ·»åŠ åˆ° hashTable ä¸­ï¼Œæœ€åè¾“å‡º hashTable ä¸­ä¿å­˜çš„å€¼å³å¯ã€‚

è¿™ç§åšæ³•ç©ºé—´å¤æ‚åº¦ O(n)ï¼Œ å‡è®¾æ’åºç®—æ³•ç”¨çš„å¿«æ’ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸º O(n \* klogk), n ä¸ºæ•°ç»„é•¿åº¦ï¼Œk ä¸ºå­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦

ä»£ç ï¼š

```js
var groupAnagrams = function(strs) {
  const hashTable = {};

  function sort(str) {
    return str
      .split('')
      .sort()
      .join('');
  }

  // è¿™ä¸ªæ–¹æ³•éœ€è¦æ’åºï¼Œå› æ­¤ä¸æ˜¯å¾ˆä¼˜ï¼Œä½†æ˜¯å¾ˆç›´è§‚ï¼Œå®¹æ˜“æƒ³åˆ°
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    const key = sort(str);
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

ä¸‹é¢æˆ‘ä»¬ä»‹ç»å¦å¤–ä¸€ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å»ºç«‹ä¸€ä¸ª 26 é•¿åº¦çš„ counts æ•°ç»„(å¦‚æœåŒºåˆ†å¤§å°å†™ï¼Œæˆ‘ä»¬å¯ä»¥å»ºç«‹ 52 ä¸ªï¼Œå¦‚æœæ”¯æŒå…¶ä»–å­—ç¬¦ä¾æ¬¡ç±»æ¨)ã€‚
ç„¶åæˆ‘ä»¬ç»™æ¯ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå›ºå®šçš„æ•°ç»„ä¸‹æ ‡ï¼Œç„¶åæˆ‘ä»¬åªéœ€è¦æ›´æ–°æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°ã€‚ æœ€åå½¢æˆçš„ counts æ•°ç»„å¦‚æœä¸€è‡´ï¼Œåˆ™è¯´æ˜ä»–ä»¬å¯ä»¥é€šè¿‡
äº¤æ¢é¡ºåºå¾—åˆ°ã€‚è¿™ç§ç®—æ³•ç©ºé—´å¤æ‚åº¦ O(n), æ—¶é—´å¤æ‚åº¦ O(n \* k), n ä¸ºæ•°ç»„é•¿åº¦ï¼Œk ä¸ºå­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦.

![49.group-anagrams](../assets/problems/49.group-anagrams.png)

#### å…³é”®ç‚¹è§£æ

- æ¡¶æ’åº

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=49 lang=javascript
 *
 * [49] Group Anagrams
 */
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  // ç±»ä¼¼æ¡¶æ’åº

  let counts = [];
  const hashTable = {};
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    counts = Array(26).fill(0);
    for (let j = 0; j < str.length; j++) {
      counts[str[j].charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }
    const key = counts.join('');
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

### [494].target-sum

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/target-sum/description/

#### é¢˜ç›®æè¿°

```
You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target S.

Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
Note:
The length of the given array is positive and will not exceed 20.
The sum of elements in the given array will not exceed 1000.
Your output answer is guaranteed to be fitted in a 32-bit integer.

```

#### æ€è·¯

é¢˜ç›®æ˜¯ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œè®©ä½ åœ¨æ•°å­—å‰é¢æ·»åŠ  `+`æˆ–è€…`-`ï¼Œä½¿å…¶å’Œç­‰äº target.

![494.target-sum](../assets/problems/494.target-sum.png)

æš´åŠ›æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯æŒ‡æ•°çº§åˆ«çš„ï¼Œå› æ­¤æˆ‘ä»¬ä¸äºˆè€ƒè™‘ã€‚æˆ‘ä»¬éœ€è¦æ¢ç§æ€è·¯.

æˆ‘ä»¬å°†æœ€ç»ˆçš„ç»“æœåˆ†æˆä¸¤ç»„ï¼Œä¸€ç»„æ˜¯æˆ‘ä»¬æ·»åŠ äº†`+`çš„ï¼Œä¸€ç»„æ˜¯æˆ‘ä»¬æ·»åŠ äº†`-`çš„ã€‚

![494.target-sum-2](../assets/problems/494.target-sum-2.png)

å¦‚ä¸Šå›¾ï¼Œé—®é¢˜è½¬åŒ–ä¸ºå¦‚ä½•æ±‚å…¶ä¸­ä¸€ç»„ï¼Œæˆ‘ä»¬ä¸å¦¨æ±‚å‰é¢æ ‡`+`çš„ä¸€ç»„

> å¦‚æœæ±‚å‡ºä¸€ç»„ï¼Œå¦ä¸€ç»„å®é™…å°±å·²çŸ¥äº†ï¼Œå³æ€»é›†å’Œè¿™ä¸€ç»„çš„å·®é›†ã€‚

é€šè¿‡è¿›ä¸€æ­¥åˆ†æï¼Œæˆ‘ä»¬å¾—åˆ°äº†è¿™æ ·çš„å…³ç³»ï¼š

![494.target-sum-3](../assets/problems/494.target-sum-3.png)

å› æ­¤é—®é¢˜è½¬åŒ–ä¸ºï¼Œæ±‚è§£`sumCount(nums, target)`,å³ nums æ•°ç»„ä¸­èƒ½å¤Ÿç»„æˆ
target çš„æ€»æ•°ä¸€å…±æœ‰å¤šå°‘ç§ï¼Œè¿™æ˜¯ä¸€é“æˆ‘ä»¬ä¹‹å‰åšè¿‡çš„é¢˜ç›®ï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’å¯ä»¥è§£å†³ã€‚

#### å…³é”®ç‚¹è§£æ

- å¯¹å…ƒç´ è¿›è¡Œåˆ†ç»„ï¼Œåˆ†ç»„çš„ä¾æ®æ˜¯ç¬¦å·ï¼Œ æ˜¯`+` æˆ–è€… `-`
- é€šè¿‡æ•°å­¦å…¬å¼æ¨å¯¼å¯ä»¥ç®€åŒ–æˆ‘ä»¬çš„æ±‚è§£è¿‡ç¨‹ï¼Œè¿™éœ€è¦ä¸€ç‚¹`æ•°å­¦çŸ¥è¯†å’Œæ•°å­¦æ„è¯†`

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=494 lang=javascript
 *
 * [494] Target Sum
 *
 * https://leetcode.com/problems/target-sum/description/
 *
 * algorithms
 * Medium (44.86%)
 * Total Accepted:    89.3K
 * Total Submissions: 198.5K
 * Testcase Example:  '[1,1,1,1,1]\n3'
 *
 *
 * You are given a list of non-negative integers, a1, a2, ..., an, and a
 * target, S. Now you have 2 symbols + and -. For each integer, you should
 * choose one from + and - as its new symbol.
 * â 
 *
 * Find out how many ways to assign symbols to make sum of integers equal to
 * target S.
 *
 *
 * Example 1:
 *
 * Input: nums is [1, 1, 1, 1, 1], S is 3.
 * Output: 5
 * Explanation:
 *
 * -1+1+1+1+1 = 3
 * +1-1+1+1+1 = 3
 * +1+1-1+1+1 = 3
 * +1+1+1-1+1 = 3
 * +1+1+1+1-1 = 3
 *
 * There are 5 ways to assign symbols to make the sum of nums be target 3.
 *
 *
 *
 * Note:
 *
 * The length of the given array is positive and will not exceed 20.
 * The sum of elements in the given array will not exceed 1000.
 * Your output answer is guaranteed to be fitted in a 32-bit integer.
 *
 *
 */
// è¿™ä¸ªæ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„é—®é¢˜äº†
// æˆ‘ä»¬è¿™é‡Œéœ€è¦æ±‚è§£çš„æ˜¯numsé‡Œé¢æœ‰å¤šå°‘ç§å¯ä»¥ç»„æˆtargetçš„æ–¹å¼
var sumCount = function(nums, target) {
  // è¿™é‡Œé€šè¿‡è§‚å¯Ÿï¼Œæˆ‘ä»¬æ²¡å¿…è¦ä½¿ç”¨äºŒç»´æ•°ç»„å»å­˜å‚¨è¿™äº›è®¡ç®—ç»“æœ
  // ä½¿ç”¨ä¸€ç»´æ•°ç»„å¯ä»¥æœ‰æ•ˆèŠ‚çœç©ºé—´
  const dp = Array(target + 1).fill(0);
  dp[0] = 1;
  for (let i = 0; i < nums.length; i++) {
    for (let j = target; j >= nums[i]; j--) {
      dp[j] += dp[j - nums[i]];
    }
  }
  return dp[target];
};
const add = nums => nums.reduce((a, b) => (a += b), 0);
/**
 * @param {number[]} nums
 * @param {number} S
 * @return {number}
 */
var findTargetSumWays = function(nums, S) {
  const sum = add(nums);
  if (sum < S) return 0;
  if ((S + sum) % 2 === 1) return 0;
  return sumCount(nums, (S + sum) >> 1);
};
```

#### æ‰©å±•

å¦‚æœè¿™é“é¢˜ç›®å¹¶æ²¡æœ‰é™å®šæ‰€æœ‰çš„å…ƒç´ ä»¥åŠ target éƒ½æ˜¯æ­£æ•°æ€ä¹ˆåŠï¼Ÿ

### [5].longest-palindromic-substring

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/longest-palindromic-substring/description/

#### é¢˜ç›®æè¿°

```
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
```

#### æ€è·¯

è¿™æ˜¯ä¸€é“æœ€é•¿å›æ–‡çš„é¢˜ç›®ï¼Œè¦æˆ‘ä»¬æ±‚å‡ºç»™å®šå­—ç¬¦ä¸²çš„æœ€å¤§å›æ–‡å­ä¸²ã€‚

![5.longest-palindromic-substring](../assets/problems/5.longest-palindromic-substring-1.png)

è§£å†³è¿™ç±»é—®é¢˜çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯ä¸¤ä¸ªå­—â€œå»¶ä¼¸â€ï¼Œå…·ä½“æ¥è¯´

- å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆåœ¨å®ƒå·¦å³åˆ†åˆ«åŠ ä¸Šä¸€ä¸ªç›¸åŒçš„å­—ç¬¦ï¼Œé‚£ä¹ˆå®ƒä¸€å®šè¿˜æ˜¯ä¸€ä¸ªå›æ–‡ä¸²
- å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²ä¸æ˜¯å›æ–‡ä¸²ï¼Œæˆ–è€…åœ¨å›æ–‡ä¸²å·¦å³åˆ†åˆ«åŠ ä¸åŒçš„å­—ç¬¦ï¼Œå¾—åˆ°çš„ä¸€å®šä¸æ˜¯å›æ–‡ä¸²

äº‹å®ä¸Šï¼Œä¸Šé¢çš„åˆ†æå·²ç»å»ºç«‹äº†å¤§é—®é¢˜å’Œå°é—®é¢˜ä¹‹é—´çš„å…³è”ï¼Œ
åŸºäºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å»ºç«‹åŠ¨æ€è§„åˆ’æ¨¡å‹ã€‚

æˆ‘ä»¬å¯ä»¥ç”¨ dp[i][j] è¡¨ç¤º s ä¸­ä» i åˆ° j(åŒ…æ‹¬ i å’Œ j)æ˜¯å¦å¯ä»¥å½¢æˆå›æ–‡ï¼Œ
çŠ¶æ€è½¬ç§»æ–¹ç¨‹åªæ˜¯å°†ä¸Šé¢çš„æè¿°è½¬åŒ–ä¸ºä»£ç å³å¯ï¼š

```js
if (s[i] === s[j] && dp[i + 1][j - 1]) {
  dp[i][j] = true;
}
```

![5.longest-palindromic-substring-2](../assets/problems/5.longest-palindromic-substring-2.png)

base case å°±æ˜¯ä¸€ä¸ªå­—ç¬¦(è½´å¯¹ç§°ç‚¹æ˜¯æœ¬èº«)ï¼Œæˆ–è€…ä¸¤ä¸ªå­—ç¬¦(è½´å¯¹ç§°ç‚¹æ˜¯ä»‹äºä¸¤è€…ä¹‹é—´çš„è™šæ‹Ÿç‚¹)ã€‚

![5.longest-palindromic-substring-3](../assets/problems/5.longest-palindromic-substring-3.png)

#### å…³é”®ç‚¹

- â€å»¶ä¼¸â€œ(extend)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=5 lang=javascript
 *
 * [5] Longest Palindromic Substring
 */
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  // babad
  // tag : dp
  if (!s || s.length === 0) return '';
  let res = s[0];

  const dp = [];

  // å€’ç€éå†ç®€åŒ–æ“ä½œï¼Œ è¿™ä¹ˆåšçš„åŸå› æ˜¯dp[i][..]ä¾èµ–äºdp[i + 1][..]
  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = [];
    for (let j = i; j < s.length; j++) {
      if (j - i === 0) dp[i][j] = true;
      // specail case 1
      else if (j - i === 1 && s[i] === s[j]) dp[i][j] = true;
      // specail case 2
      else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        // state transition
        dp[i][j] = true;
      }

      if (dp[i][j] && j - i + 1 > res.length) {
        // update res
        res = s.slice(i, j + 1);
      }
    }
  }

  return res;
};
```

#### ç›¸å…³é¢˜ç›®

- [516.longest-palindromic-subsequence](./516.longest-palindromic-subsequence.md)

### [516].longest-palindromic-subsequence

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/longest-palindromic-subsequence/description/

#### é¢˜ç›®æè¿°

```
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.

Example 1:
Input:

"bbbab"
Output:
4
One possible longest palindromic subsequence is "bbbb".
Example 2:
Input:

"cbbd"
Output:
2
One possible longest palindromic subsequence is "bb".
```

#### æ€è·¯

è¿™æ˜¯ä¸€é“æœ€é•¿å›æ–‡çš„é¢˜ç›®ï¼Œè¦æˆ‘ä»¬æ±‚å‡ºç»™å®šå­—ç¬¦ä¸²çš„æœ€å¤§å›æ–‡å­åºåˆ—ã€‚

![516.longest-palindromic-subsequence-1](../assets/problems/516.longest-palindromic-subsequence-1.png)

è§£å†³è¿™ç±»é—®é¢˜çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯ä¸¤ä¸ªå­—â€œå»¶ä¼¸â€ï¼Œå…·ä½“æ¥è¯´

- å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆåœ¨å®ƒå·¦å³åˆ†åˆ«åŠ ä¸Šä¸€ä¸ªç›¸åŒçš„å­—ç¬¦ï¼Œé‚£ä¹ˆå®ƒä¸€å®šè¿˜æ˜¯ä¸€ä¸ªå›æ–‡ä¸²ï¼Œå› æ­¤`å›æ–‡é•¿åº¦å¢åŠ 2`
- å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²ä¸æ˜¯å›æ–‡ä¸²ï¼Œæˆ–è€…åœ¨å›æ–‡ä¸²å·¦å³åˆ†åˆ«åŠ ä¸åŒçš„å­—ç¬¦ï¼Œå¾—åˆ°çš„ä¸€å®šä¸æ˜¯å›æ–‡ä¸²,å› æ­¤`å›æ–‡é•¿åº¦ä¸å˜ï¼Œæˆ‘ä»¬å–[i][j-1]å’Œ[i+1][j]çš„è¾ƒå¤§å€¼`

![516.longest-palindromic-subsequence-2](../assets/problems/516.longest-palindromic-subsequence-2.png)

äº‹å®ä¸Šï¼Œä¸Šé¢çš„åˆ†æå·²ç»å»ºç«‹äº†å¤§é—®é¢˜å’Œå°é—®é¢˜ä¹‹é—´çš„å…³è”ï¼Œ
åŸºäºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å»ºç«‹åŠ¨æ€è§„åˆ’æ¨¡å‹ã€‚

æˆ‘ä»¬å¯ä»¥ç”¨ dp[i][j] è¡¨ç¤º s ä¸­ä» i åˆ° j(åŒ…æ‹¬ i å’Œ j)çš„å›æ–‡åºåˆ—é•¿åº¦ï¼Œ
çŠ¶æ€è½¬ç§»æ–¹ç¨‹åªæ˜¯å°†ä¸Šé¢çš„æè¿°è½¬åŒ–ä¸ºä»£ç å³å¯ï¼š

```js
if (s[i] === s[j]) {
  dp[i][j] = dp[i + 1][j - 1] + 2;
} else {
  dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
}
```

base case å°±æ˜¯ä¸€ä¸ªå­—ç¬¦(è½´å¯¹ç§°ç‚¹æ˜¯æœ¬èº«)

![516.longest-palindromic-subsequence-3](../assets/problems/516.longest-palindromic-subsequence-3.png)

#### å…³é”®ç‚¹

- â€å»¶ä¼¸â€œ(extend)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=516 lang=javascript
 *
 * [516] Longest Palindromic Subsequence
 */
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindromeSubseq = function(s) {
  // bbbab è¿”å›4
  // tag : dp
  const dp = [];

  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = Array(s.length).fill(0);
    for (let j = i; j < s.length; j++) {
      if (i - j === 0) dp[i][j] = 1;
      else if (s[i] === s[j]) {
        dp[i][j] = dp[i + 1][j - 1] + 2;
      } else {
        dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
      }
    }
  }

  return dp[0][s.length - 1];
};
```

#### ç›¸å…³é¢˜ç›®

- [5.longest-palindromic-substring](./5.longest-palindromic-substring.md)

### [518].coin-change-2

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/coin-change-2/description/

#### é¢˜ç›®æè¿°

```
You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.



Example 1:

Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
Example 3:

Input: amount = 10, coins = [10]
Output: 1


Note:

You can assume that

0 <= amount <= 5000
1 <= coin <= 5000
the number of coins is less than 500
the answer is guaranteed to fit into signed 32-bit integer

```

#### æ€è·¯

è¿™ä¸ªé¢˜ç›®å’Œ coin-change çš„æ€è·¯æ¯”è¾ƒç±»ä¼¼ã€‚

æˆ‘ä»¬è¿˜æ˜¯æŒ‰ç…§ coin-change çš„æ€è·¯æ¥ï¼Œ å¦‚æœå°†é—®é¢˜ç”»å‡ºæ¥å¤§æ¦‚æ˜¯è¿™æ ·ï¼š

![coin-change-2](../assets/problems/coin-change-2.png)

è¿›ä¸€æ­¥æˆ‘ä»¬å¯ä»¥å¯¹é—®é¢˜è¿›è¡Œç©ºé—´å¤æ‚åº¦ä¸Šçš„ä¼˜åŒ–(è¿™ç§å†™æ³•æ¯”è¾ƒéš¾ä»¥ç†è§£ï¼Œä½†æ˜¯ç›¸å¯¹æ›´çœç©ºé—´)

![coin-change-2-opt](../assets/problems/coin-change-2-opt.png)

> è¿™é‡Œç”¨åŠ¨å›¾ä¼šæ›´å¥½ç†è§£ï¼Œ æœ‰æ—¶é—´çš„è¯æˆ‘ä¼šåšä¸€ä¸ªåŠ¨å›¾å‡ºæ¥ï¼Œ ç°åœ¨å¤§å®¶è„‘è¡¥ä¸€ä¸‹å§

#### å…³é”®ç‚¹è§£æ

- åŠ¨æ€è§„åˆ’

- å­é—®é¢˜

ç”¨ dp[i] æ¥è¡¨ç¤ºç»„æˆ i å—é’±ï¼Œéœ€è¦æœ€å°‘çš„ç¡¬å¸æ•°ï¼Œé‚£ä¹ˆ

1. ç¬¬ j ä¸ªç¡¬å¸æˆ‘å¯ä»¥é€‰æ‹©ä¸æ‹¿ è¿™ä¸ªæ—¶å€™ï¼Œ ç»„æˆæ•° = dp[i]

2. ç¬¬ j ä¸ªç¡¬å¸æˆ‘å¯ä»¥é€‰æ‹©æ‹¿ è¿™ä¸ªæ—¶å€™ï¼Œ ç»„æˆæ•° = dp[i - coins[j]] + dp[i]

- å’ŒèƒŒåŒ…é—®é¢˜ä¸åŒï¼Œ ç¡¬å¸æ˜¯å¯ä»¥æ‹¿ä»»æ„ä¸ª

- å¯¹äºæ¯ä¸€ä¸ª dp[i] æˆ‘ä»¬éƒ½é€‰æ‹©éå†ä¸€é coinï¼Œ ä¸æ–­æ›´æ–° dp[i]

eg:

```js
if (amount === 0) return 1;

const dp = [Array(amount + 1).fill(1)];

for (let i = 1; i < amount + 1; i++) {
  dp[i] = Array(coins.length + 1).fill(0);
  for (let j = 1; j < coins.length + 1; j++) {
    // ä»1å¼€å§‹å¯ä»¥ç®€åŒ–è¿ç®—
    if (i - coins[j - 1] >= 0) {
      // æ³¨æ„è¿™é‡Œæ˜¯coins[j -1]è€Œä¸æ˜¯coins[j]
      dp[i][j] = dp[i][j - 1] + dp[i - coins[j - 1]][j]; // ç”±äºå¯ä»¥é‡å¤ä½¿ç”¨ç¡¬å¸æ‰€ä»¥è¿™é‡Œæ˜¯jä¸æ˜¯j-1
    } else {
      dp[i][j] = dp[i][j - 1];
    }
  }
}

return dp[dp.length - 1][coins.length];
```

- å½“æˆ‘ä»¬é€‰æ‹©ä¸€ç»´æ•°ç»„å»è§£çš„æ—¶å€™ï¼Œå†…å¤–å¾ªç¯å°†ä¼šå¯¹ç»“æœé€ æˆå½±å“

![coin-change-2-wrong](../assets/problems/coin-change-2-wrong.png)

eg:

```js
// è¿™ç§ç­”æ¡ˆæ˜¯ä¸å¯¹çš„ã€‚
// åŸå› åœ¨äºæ¯”å¦‚amount = 5, coins = [1,2,5]
// è¿™ç§ç®—æ³•ä¼šå°†[1,2,2] [2,1,2] [2, 2, 1] ç®—æˆä¸åŒçš„

if (amount === 0) return 1;

const dp = [1].concat(Array(amount).fill(0));

for (let i = 1; i < amount + 1; i++) {
  for (let j = 0; j < coins.length; j++) {
    if (i - coins[j] >= 0) {
      dp[i] = dp[i] + dp[i - coins[j]];
    }
  }
}

return dp[dp.length - 1];

// æ­£ç¡®çš„å†™æ³•åº”è¯¥æ˜¯å†…å¤–å¾ªç¯è°ƒæ¢ä¸€ä¸‹, å…·ä½“å¯ä»¥çœ‹ä¸‹æ–¹ä»£ç åŒº
```

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=518 lang=javascript
 *
 * [518] Coin Change 2
 *
 * https://leetcode.com/problems/coin-change-2/description/
 *
 * algorithms
 * Medium (41.57%)
 * Total Accepted:    39.7K
 * Total Submissions: 94.6K
 * Testcase Example:  '5\n[1,2,5]'
 *
 * You are given coins of different denominations and a total amount of money.
 * Write a function to compute the number of combinations that make up that
 * amount. You may assume that you have infinite number of each kind of
 * coin.
 *
 *
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: amount = 5, coins = [1, 2, 5]
 * Output: 4
 * Explanation: there are four ways to make up the amount:
 * 5=5
 * 5=2+2+1
 * 5=2+1+1+1
 * 5=1+1+1+1+1
 *
 *
 * Example 2:
 *
 *
 * Input: amount = 3, coins = [2]
 * Output: 0
 * Explanation: the amount of 3 cannot be made up just with coins of 2.
 *
 *
 * Example 3:
 *
 *
 * Input: amount = 10, coins = [10]
 * Output: 1
 *
 *
 *
 *
 * Note:
 *
 * You can assume that
 *
 *
 * 0 <= amount <= 5000
 * 1 <= coin <= 5000
 * the number of coins is less than 500
 * the answer is guaranteed to fit into signed 32-bit integer
 *
 *
 */
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function(amount, coins) {
  if (amount === 0) return 1;

  const dp = [1].concat(Array(amount).fill(0));

  for (let j = 0; j < coins.length; j++) {
    for (let i = 1; i < amount + 1; i++) {
      if (i - coins[j] >= 0) {
        dp[i] = dp[i] + dp[i - coins[j]];
      }
    }
  }

  return dp[dp.length - 1];
};
```

#### æ‰©å±•

è¿™æ˜¯ä¸€é“å¾ˆç®€å•æè¿°çš„é¢˜ç›®ï¼Œ å› æ­¤å¾ˆå¤šæ—¶å€™ä¼šè¢«ç”¨åˆ°å¤§å…¬å¸çš„ç”µé¢ä¸­ã€‚

ç›¸ä¼¼é—®é¢˜:

[322.coin-change](./322.coin-change.md)

### [55].jump-game

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/jump-game/description/

#### é¢˜ç›®æè¿°

```
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯ä¸€é“å…¸å‹çš„`å›æº¯`ç±»å‹é¢˜ç›®ã€‚
æ€è·¯å°±æ˜¯ç”¨ä¸€ä¸ªå˜é‡è®°å½•å½“å‰èƒ½å¤Ÿåˆ°è¾¾çš„æœ€å¤§çš„ç´¢å¼•ï¼Œæˆ‘ä»¬é€ä¸ªéå†æ•°ç»„ä¸­çš„å…ƒç´ å»æ›´æ–°è¿™ä¸ªç´¢å¼•ã€‚
å˜é‡å®Œæˆåˆ¤æ–­è¿™ä¸ªç´¢å¼•æ˜¯å¦å¤§äºæ•°ç»„ä¸‹è¡¨å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- å»ºæ¨¡ (è®°å½•å’Œæ›´æ–°å½“å‰ä½ç½®èƒ½å¤Ÿåˆ°è¾¾çš„æœ€å¤§çš„ç´¢å¼•å³å¯)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=55 lang=javascript
 *
 * [55] Jump Game
 *
 * https://leetcode.com/problems/jump-game/description/
 *
 * algorithms
 * Medium (31.38%)
 * Total Accepted:    252.4K
 * Total Submissions: 797.2K
 * Testcase Example:  '[2,3,1,1,4]'
 *
 * Given an array of non-negative integers, you are initially positioned at the
 * first index of the array.
 *
 * Each element in the array represents your maximum jump length at that
 * position.
 *
 * Determine if you are able to reach the last index.
 *
 * Example 1:
 *
 *
 * Input: [2,3,1,1,4]
 * Output: true
 * Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last
 * index.
 *
 *
 * Example 2:
 *
 *
 * Input: [3,2,1,0,4]
 * Output: false
 * Explanation: You will always arrive at index 3 no matter what. Its
 * maximum
 * jump length is 0, which makes it impossible to reach the last index.
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let max = 0; // èƒ½å¤Ÿèµ°åˆ°çš„æ•°ç»„ä¸‹æ ‡

  for (let i = 0; i < nums.length; i++) {
    if (max < i) return false; // å½“å‰è¿™ä¸€æ­¥éƒ½èµ°ä¸åˆ°ï¼Œåé¢æ›´èµ°ä¸åˆ°äº†
    max = Math.max(nums[i] + i, max);
  }

  return max >= nums.length - 1;
};
```

### [56].merge-intervals

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/merge-intervals/description/

#### é¢˜ç›®æè¿°

```
Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

```

#### æ€è·¯

- å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œæ’åºçš„ä¾æ®å°±æ˜¯æ¯ä¸€é¡¹çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¤§å°ã€‚
- ç„¶åæˆ‘ä»¬å¯¹æ•°ç»„è¿›è¡Œéå†ï¼Œéå†çš„æ—¶å€™ä¸¤ä¸¤è¿ç®—(å…·ä½“è¿ç®—é€»è¾‘è§ä¸‹)
- åˆ¤æ–­æ˜¯å¦ç›¸äº¤ï¼Œå¦‚æœä¸ç›¸äº¤ï¼Œåˆ™è·³è¿‡
- å¦‚æœç›¸äº¤ï¼Œåˆ™åˆå¹¶ä¸¤é¡¹

#### å…³é”®ç‚¹è§£æ

- å¯¹æ•°ç»„è¿›è¡Œæ’åºç®€åŒ–æ“ä½œ
- å¦‚æœä¸æ’åºï¼Œéœ€è¦å€ŸåŠ©ä¸€äº› hack,è¿™é‡Œä¸ä»‹ç»äº†

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=56 lang=javascript
 *
 * [56] Merge Intervals
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */

function intersected(a, b) {
  if (a[0] > b[1] || a[1] < b[0]) return false;
  return true;
}

function mergeTwo(a, b) {
  return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];
}
var merge = function(intervals) {
  // è¿™ç§ç®—æ³•éœ€è¦å…ˆæ’åº
  intervals.sort((a, b) => a[0] - b[0]);
  for (let i = 0; i < intervals.length - 1; i++) {
    const cur = intervals[i];
    const next = intervals[i + 1];

    if (intersected(cur, next)) {
      intervals[i] = undefined;
      intervals[i + 1] = mergeTwo(cur, next);
    }
  }
  return intervals.filter(q => q);
};
```

### [560].subarray-sum-equals-k

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/subarray-sum-equals-k/description/

#### é¢˜ç›®æè¿°

```
Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

Example 1:
Input:nums = [1,1,1], k = 2
Output: 2
Note:
The length of the array is in range [1, 20,000].
The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯æš´åŠ›æ±‚è§£æ‰€æœ‰çš„å­æ•°ç»„ï¼Œç„¶ååˆ†åˆ«è®¡ç®—å’Œï¼Œå¦‚æœç­‰äº k,count å°±+1.è¿™ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n^2).

è¿™é‡Œæœ‰ä¸€ç§æ›´åŠ å·§å¦™çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å€ŸåŠ©é¢å¤–çš„ç©ºé—´ï¼Œä½¿ç”¨ hashmap æ¥ç®€åŒ–æ—¶é—´å¤æ‚åº¦ï¼Œè¿™ç§ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å¯ä»¥è¾¾åˆ° O(n).

æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ª hashmapï¼Œhashmap çš„ key ä¸ºç´¯åŠ å€¼ accï¼Œvalue ä¸ºç´¯åŠ å€¼ acc å‡ºç°çš„æ¬¡æ•°ã€‚
æˆ‘ä»¬è¿­ä»£æ•°ç»„ï¼Œç„¶åä¸æ–­æ›´æ–° acc å’Œ hashmapï¼Œå¦‚æœ acc ç­‰äº kï¼Œé‚£ä¹ˆå¾ˆæ˜æ˜¾åº”è¯¥+1. å¦‚æœ hashmap[acc - k] å­˜åœ¨ï¼Œ
æˆ‘ä»¬å°±æŠŠå®ƒåŠ åˆ°ç»“æœä¸­å»å³å¯ã€‚

è¯­è¨€æ¯”è¾ƒéš¾ä»¥è§£é‡Šï¼Œæˆ‘ç”»äº†ä¸€ä¸ªå›¾æ¥æ¼”ç¤º nums = [1,2,3,3,0,3,4,2], k = 6 çš„æƒ…å†µã€‚

![560.subarray-sum-equals-k](../assets/problems/560.subarray-sum-equals-k.jpg)

å¦‚å›¾ï¼Œå½“è®¿é—®åˆ° nums[3]çš„æ—¶å€™ï¼Œhashmap å¦‚å›¾æ‰€ç¤ºï¼Œè¿™ä¸ªæ—¶å€™ count ä¸º 2.
å…¶ä¸­ä¹‹ä¸€æ˜¯[1,2,3],è¿™ä¸ªå¥½ç†è§£ã€‚è¿˜æœ‰ä¸€ä¸ªæ˜¯[3,3].

è¿™ä¸ª[3,3]æ­£æ˜¯æˆ‘ä»¬é€šè¿‡ hashmap[acc - k]å³ hashmap[9 - 6]å¾—åˆ°çš„ã€‚

#### å…³é”®ç‚¹è§£æ

- å¯ä»¥åˆ©ç”¨ hashmap è®°å½•å’Œçš„ç´¯åŠ å€¼æ¥é¿å…é‡å¤è®¡ç®—

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=560 lang=javascript
 *
 * [560] Subarray Sum Equals K
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function(nums, k) {
  const hashmap = {};
  let acc = 0;
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    acc += nums[i];

    if (acc === k) count++;

    if (hashmap[acc - k] !== void 0) {
      count += hashmap[acc - k];
    }

    if (hashmap[acc] === void 0) {
      hashmap[acc] = 1;
    } else {
      hashmap[acc] += 1;
    }
  }

  return count;
};
```

#### æ‰©å±•

è¿™æ˜¯ä¸€é“ç±»ä¼¼çš„é¢˜ç›®ï¼Œä½†æ˜¯ä¼šç¨å¾®å¤æ‚ä¸€ç‚¹, é¢˜ç›®åœ°å€: [437.path-sum-iii](./437.path-sum-iii.md)

### [575].distribute-candies

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/distribute-candies/description/

#### é¢˜ç›®æè¿°

```
Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.
Example 1:
Input: candies = [1,1,2,2,3,3]
Output: 3
Explanation:
There are three different kinds of candies (1, 2 and 3), and two candies for each kind.
Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.
The sister has three different kinds of candies.
Example 2:
Input: candies = [1,1,2,3]
Output: 2
Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].
The sister has two different kinds of candies, the brother has only one kind of candies.
Note:

The length of the given array is in range [2, 10,000], and will be even.
The number in given array is in range [-100,000, 100,000].
```

#### æ€è·¯

ç”±äºç³–æœæ˜¯å¶æ•°ï¼Œå¹¶ä¸”æˆ‘ä»¬åªéœ€è¦åšåˆ°ä¸¤ä¸ªäººç³–æœæ•°é‡ä¸€æ ·å³å¯ã€‚

è€ƒè™‘ä¸¤ç§æƒ…å†µ:

![575.distribute-candies](../assets/problems/575.distribute-candies.png)

- å¦‚æœç³–æœç§ç±»å¤§äº n / 2(ç³–æœç§ç±»æ•°ä¸º n)ï¼Œå¦¹å¦¹æœ€å¤šå¯ä»¥è·å¾—çš„ç³–æœç§ç±»åº”è¯¥æ˜¯`n / 2`(å› ä¸ºå¦¹å¦¹åªæœ‰ n / 2 ä¸ªç³–).
- ç³–æœç§ç±»æ•°å°äº n / 2, å¦¹å¦¹èƒ½å¤Ÿå¾—åˆ°çš„ç³–æœç§ç±»å¯ä»¥æ˜¯ç³–æœçš„ç§ç±»æ•°(ç³–æœç§ç±»æœ¬èº«å°±è¿™ä¹ˆå¤š).

å› æ­¤æˆ‘ä»¬å‘ç°ï¼Œå¦¹å¦¹èƒ½å¤Ÿè·å¾—çš„ç³–æœç§ç±»çš„åˆ¶çº¦å› ç´ å…¶å®æ˜¯ç³–æœç§ç±»æ•°ã€‚

#### å…³é”®ç‚¹è§£æ

- è¿™æ˜¯ä¸€é“é€»è¾‘é¢˜ç›®ï¼Œå› æ­¤å¦‚æœé€»è¾‘åˆ†ææ¸…æ¥šäº†ï¼Œä»£ç æ˜¯è‡ªç„¶è€Œç„¶çš„

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=575 lang=javascript
 *
 * [575] Distribute Candies
 */
/**
 * @param {number[]} candies
 * @return {number}
 */
var distributeCandies = function(candies) {
  const count = new Set(candies);
  return Math.min(count.size, candies.length >> 1);
};
```

### [609].find-duplicate-file-in-system

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/find-duplicate-file-in-system/description/

#### é¢˜ç›®æè¿°

```
Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.

A group of duplicate files consists of at least two files that have exactly the same content.

A single directory info string in the input list has the following format:

"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"

It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.

The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:

"directory_path/file_name.txt"

Example 1:

Input:
["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]
Output:
[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]


Note:

No order is required for the final output.
You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].
The number of files given is in the range of [1,20000].
You may assume no files or directories share the same name in the same directory.
You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.


Follow-up beyond contest:

1. Imagine you are given a real file system, how will you search files? DFS or BFS?

2. If the file content is very large (GB level), how will you modify your solution?

3. If you can only read the file by 1kb each time, how will you modify your solution?

4. What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?

5. How to make sure the duplicated files you find are not false positive?

```

#### æ€è·¯

æ€è·¯å°±æ˜¯ hashtable å»å­˜å‚¨ï¼Œkey ä¸ºæ–‡ä»¶å†…å®¹ï¼Œvalue ä¸º fullfilenameï¼Œ
éå†ä¸€éå»å¡«å…… hashtableï¼Œ æœ€åå°† hashtable ä¸­çš„å€¼æ‰“å°å‡ºæ¥å³å¯ã€‚

> å½“ä¸”ä»…å½“æœ‰é‡å¤å†…å®¹ï¼Œæˆ‘ä»¬æ‰æ‰“å°ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è¿‡æ»¤ä¸€ä¸‹ï¼Œ ç±»ä¼¼ filter(q => q.length >= 2)

#### å…³é”®ç‚¹è§£æ

- hashtable

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=609 lang=javascript
 *
 * [609] Find Duplicate File in System
 *
 * https://leetcode.com/problems/find-duplicate-file-in-system/description/
 *
 * algorithms
 * Medium (54.21%)
 * Total Accepted:    24.1K
 * Total Submissions: 44.2K
 * Testcase Example:  '["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]'
 *
 * Given a list of directory info including directory path, and all the files
 * with contents in this directory, you need to find out all the groups of
 * duplicate files in the file system in terms of their paths.
 *
 * A group of duplicate files consists of at least two files that have exactly
 * the same content.
 *
 * A single directory info string in the input list has the following format:
 *
 * "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ...
 * fn.txt(fn_content)"
 *
 * It means there are n files (f1.txt, f2.txt ... fn.txt with content
 * f1_content, f2_content ... fn_content, respectively) in directory
 * root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the
 * directory is just the root directory.
 *
 * The output is a list of group of duplicate file paths. For each group, it
 * contains all the file paths of the files that have the same content. A file
 * path is a string that has the following format:
 *
 * "directory_path/file_name.txt"
 *
 * Example 1:
 *
 *
 * Input:
 * ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d
 * 4.txt(efgh)", "root 4.txt(efgh)"]
 * Output:
 *
 * [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]
 *
 *
 *
 *
 * Note:
 *
 *
 * No order is required for the final output.
 * You may assume the directory name, file name and file content only has
 * letters and digits, and the length of file content is in the range of
 * [1,50].
 * The number of files given is in the range of [1,20000].
 * You may assume no files or directories share the same name in the same
 * directory.
 * You may assume each given directory info represents a unique directory.
 * Directory path and file info are separated by a single blank space.
 *
 *
 *
 * Follow-up beyond contest:
 *
 *
 * Imagine you are given a real file system, how will you search files? DFS or
 * BFS?
 * If the file content is very large (GB level), how will you modify your
 * solution?
 * If you can only read the file by 1kb each time, how will you modify your
 * solution?
 * What is the time complexity of your modified solution? What is the most
 * time-consuming part and memory consuming part of it? How to optimize?
 * How to make sure the duplicated files you find are not false positive?
 *
 *
 */
/**
 * @param {string[]} paths
 * @return {string[][]}
 */
var findDuplicate = function(paths) {
  const hashmap = {};

  for (let path of paths) {
    const [folder, ...files] = path.split(' ');
    for (let file of files) {
      const lpi = file.indexOf('(');
      const rpi = file.lastIndexOf(')');
      const filename = file.slice(0, lpi);
      const content = file.slice(lpi, rpi);
      const fullname = `${folder}/${filename}`;
      if (!hashmap[content]) hashmap[content] = [];
      hashmap[content].push(fullname);
    }
  }

  return Object.values(hashmap).filter(q => q.length >= 2);
};
```

#### æ‰©å±•

leetcode å®˜æ–¹ç»™çš„æ‰©å±•æˆ‘è§‰å¾—å°±å¾ˆæœ‰æ„æ€ï¼Œè™½ç„¶å¾ˆ`è€å¥—`, è¿™é‡Œè¿˜æ˜¯åˆ—ä¸€ä¸‹å¥½äº†ï¼Œå¤§å®¶å¯ä»¥ä½œä¸ºæ€è€ƒé¢˜æ¥æ€è€ƒä¸€ä¸‹ã€‚

1. Imagine you are given a real file system, how will you search files? DFS or BFS?

2. If the file content is very large (GB level), how will you modify your solution?

3. If you can only read the file by 1kb each time, how will you modify your solution?

4. What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?

5. How to make sure the duplicated files you find are not false positive?

### [62].unique-paths

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/unique-paths/description/

#### é¢˜ç›®æè¿°

```

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
```

![62.unique-paths-1](../assets/problems/62.unique-paths-1.png)

```
Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
```

#### æ€è·¯

è¿™æ˜¯ä¸€é“å…¸å‹çš„é€‚åˆä½¿ç”¨åŠ¨æ€è§„åˆ’è§£å†³çš„é¢˜ç›®ï¼Œå®ƒå’Œçˆ¬æ¥¼æ¢¯ç­‰éƒ½å±äºåŠ¨æ€è§„åˆ’ä¸­æœ€ç®€å•çš„é¢˜ç›®ï¼Œ
å› æ­¤ä¹Ÿç»å¸¸ä¼šè¢«ç”¨äºé¢è¯•ä¹‹ä¸­ã€‚

è¯»å®Œé¢˜ç›®ä½ å°±èƒ½æƒ³åˆ°åŠ¨æ€è§„åˆ’çš„è¯ï¼Œå»ºç«‹æ¨¡å‹å¹¶è§£å†³ææ€•ä¸æ˜¯éš¾äº‹ã€‚å…¶å®æˆ‘ä»¬å¾ˆå®¹æ˜“çœ‹å‡ºï¼Œç”±äºæœºå™¨äººåªèƒ½å³ç§»åŠ¨å’Œä¸‹ç§»åŠ¨ï¼Œ
å› æ­¤ç¬¬[i, j]ä¸ªæ ¼å­çš„æ€»æ•°åº”è¯¥ç­‰äº[i - 1, j] + [i, j -1]ï¼Œ å› ä¸ºç¬¬[i,j]ä¸ªæ ¼å­ä¸€å®šæ˜¯ä»å·¦è¾¹æˆ–è€…ä¸Šé¢ç§»åŠ¨è¿‡æ¥çš„ã€‚

![62.unique-paths-2](../assets/problems/62.unique-paths-2.png)

ä»£ç å¤§æ¦‚æ˜¯ï¼š

```js
const dp = [];
for (let i = 0; i < m + 1; i++) {
  dp[i] = [];
  dp[i][0] = 0;
}
for (let i = 0; i < n + 1; i++) {
  dp[0][i] = 0;
}
for (let i = 1; i < m + 1; i++) {
  for (let j = 1; j < n + 1; j++) {
    dp[i][j] = j === 1 ? 1 : dp[i - 1][j] + dp[i][j - 1]; // è½¬ç§»æ–¹ç¨‹
  }
}

return dp[m][n];
```

ç”±äº dp[i][j] åªä¾èµ–äºå·¦è¾¹çš„å…ƒç´ å’Œä¸Šé¢çš„å…ƒç´ ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œ ä¼˜åŒ–åˆ° O(n).

![62.unique-paths-3](../assets/problems/62.unique-paths-3.png)

å…·ä½“ä»£ç è¯·æŸ¥çœ‹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹

- ç©ºé—´å¤æ‚åº¦å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–åˆ° O(n), è¿™ä¼šæ˜¯ä¸€ä¸ªè€ƒç‚¹
- åŸºæœ¬åŠ¨æ€è§„åˆ’é—®é¢˜

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=62 lang=javascript
 *
 * [62] Unique Paths
 *
 * https://leetcode.com/problems/unique-paths/description/
 *
 * algorithms
 * Medium (46.53%)
 * Total Accepted:    277K
 * Total Submissions: 587.7K
 * Testcase Example:  '3\n2'
 *
 * A robot is located at the top-left corner of a m x n grid (marked 'Start' in
 * the diagram below).
 *
 * The robot can only move either down or right at any point in time. The robot
 * is trying to reach the bottom-right corner of the grid (marked 'Finish' in
 * the diagram below).
 *
 * How many possible unique paths are there?
 *
 *
 * Above is a 7 x 3 grid. How many possible unique paths are there?
 *
 * Note: m and n will be at most 100.
 *
 * Example 1:
 *
 *
 * Input: m = 3, n = 2
 * Output: 3
 * Explanation:
 * From the top-left corner, there are a total of 3 ways to reach the
 * bottom-right corner:
 * 1. Right -> Right -> Down
 * 2. Right -> Down -> Right
 * 3. Down -> Right -> Right
 *
 *
 * Example 2:
 *
 *
 * Input: m = 7, n = 3
 * Output: 28
 *
 *   START
 */
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const dp = Array(n).fill(1);

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[j] = dp[j] + dp[j - 1];
    }
  }

  return dp[n - 1];
};
```

### [73].set-matrix-zeroes

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/set-matrix-zeroes/description/

#### é¢˜ç›®æè¿°

```
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:

Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
Example 2:

Input:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
Follow up:

- A straight forward solution using O(mn) space is probably a bad idea.
- A simple improvement uses O(m + n) space, but still not the best solution.
- Could you devise a constant space solution?

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„æƒ³æ³•æ˜¯ï¼Œä½¿ç”¨ä¸€ä¸ª m + n çš„æ•°ç»„æ¥è¡¨ç¤ºæ¯ä¸€è¡Œæ¯ä¸€åˆ—æ˜¯å¦â€å…¨éƒ¨æ˜¯ 0â€œï¼Œ
å…ˆéå†ä¸€éå»æ„å»ºè¿™æ ·çš„ m + n æ•°ç»„ï¼Œç„¶åæ ¹æ®è¿™ä¸ª m + n æ•°ç»„å»ä¿®æ”¹ matrix å³å¯ã€‚

![73.set-matrix-zeroes-1](../assets/problems/73.set-matrix-zeroes-1.png)

è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ O(m \* n), ç©ºé—´å¤æ‚åº¦ O(m + n).

ä»£ç å¦‚ä¸‹ï¼š

```js
var setZeroes = function(matrix) {
  if (matrix.length === 0) return matrix;
  const m = matrix.length;
  const n = matrix[0].length;
  const zeroes = Array(m + n).fill(false);

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      const item = matrix[i][j];

      if (item === 0) {
        zeroes[i] = true;
        zeroes[m + j] = true;
      }
    }
  }

  for (let i = 0; i < m; i++) {
    if (zeroes[i]) {
      matrix[i] = Array(n).fill(0);
    }
  }

  for (let i = 0; i < n; i++) {
    if (zeroes[m + i]) {
      for (let j = 0; j < m; j++) {
        matrix[j][i] = 0;
      }
    }
  }

  return matrix;
};
```

ä½†æ˜¯è¿™é“é¢˜ç›®è¿˜æœ‰ä¸€ä¸ª follow upï¼Œ è¦æ±‚ä½¿ç”¨ O(1)çš„æ—¶é—´å¤æ‚åº¦ã€‚å› æ­¤ä¸Šè¿°çš„æ–¹æ³•å°±ä¸è¡Œäº†ã€‚
ä½†æ˜¯æˆ‘ä»¬è¦æ€ä¹ˆå»å­˜å–è¿™äº›ä¿¡æ¯(å“ªä¸€è¡Œå“ªä¸€åˆ—åº”è¯¥å…¨éƒ¨ä¸º 0)å‘¢ï¼Ÿ

ä¸€ç§æ€è·¯æ˜¯ä½¿ç”¨ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—çš„æ•°æ®æ¥ä»£æ›¿ä¸Šè¿°çš„ zeros æ•°ç»„ã€‚ è¿™æ ·æˆ‘ä»¬å°±ä¸å¿…å€ŸåŠ©é¢å¤–çš„å­˜å‚¨ç©ºé—´ï¼Œç©ºé—´å¤æ‚åº¦è‡ªç„¶å°±æ˜¯ O(1)äº†ã€‚

ç”±äºæˆ‘ä»¬ä¸èƒ½å…ˆæ“ä½œç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—ï¼Œ å› æ­¤æˆ‘ä»¬éœ€è¦è®°å½•ä¸‹â€ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ˜¯å¦å…¨æ˜¯ 0â€œè¿™æ ·çš„ä¸€ä¸ªæ•°æ®ï¼Œæœ€åæ ¹æ®è¿™ä¸ªä¿¡æ¯å»
ä¿®æ”¹ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—ã€‚

å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š

- è®°å½•ä¸‹â€ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ˜¯å¦å…¨æ˜¯ 0â€œè¿™æ ·çš„ä¸€ä¸ªæ•°æ®
- éå†é™¤äº†ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—ä¹‹å¤–çš„æ‰€æœ‰çš„æ•°æ®ï¼Œå¦‚æœæ˜¯ 0ï¼Œé‚£å°±æ›´æ–°ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—ä¸­å¯¹åº”çš„å…ƒç´ ä¸º 0
  > ä½ å¯ä»¥æŠŠç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—çœ‹æˆæˆ‘ä»¬ä¸Šé¢é‚£ç§è§£æ³•ä½¿ç”¨çš„ m + n æ•°ç»„ã€‚
- æ ¹æ®ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—çš„æ•°æ®ï¼Œæ›´æ–° matrix
- æœ€åæ ¹æ®æˆ‘ä»¬æœ€å¼€å§‹è®°å½•çš„â€ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ˜¯å¦å…¨æ˜¯ 0â€œå»æ›´æ–°ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—å³å¯

![73.set-matrix-zeroes-2](../assets/problems/73.set-matrix-zeroes-2.png)

#### å…³é”®ç‚¹

- ä½¿ç”¨ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ¥æ›¿ä»£æˆ‘ä»¬ m + n æ•°ç»„
- å…ˆè®°å½•ä¸‹â€ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ˜¯å¦å…¨æ˜¯ 0â€œè¿™æ ·çš„ä¸€ä¸ªæ•°æ®ï¼Œå¦åˆ™ä¼šå› ä¸ºåç»­å¯¹ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—çš„æ›´æ–°é€ æˆæ•°æ®ä¸¢å¤±
- æœ€åæ›´æ–°ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=73 lang=javascript
 *
 * [73] Set Matrix Zeroes
 */
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
  if (matrix.length === 0) return matrix;
  const m = matrix.length;
  const n = matrix[0].length;

  // æ—¶é—´å¤æ‚åº¦ O(m * n), ç©ºé—´å¤æ‚åº¦ O(1)
  let firstRow = false; // ç¬¬ä¸€è¡Œæ˜¯å¦åº”è¯¥å…¨éƒ¨ä¸º0
  let firstCol = false; // ç¬¬ä¸€åˆ—æ˜¯å¦åº”è¯¥å…¨éƒ¨ä¸º0

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      const item = matrix[i][j];
      if (item === 0) {
        if (i === 0) {
          firstRow = true;
        }
        if (j === 0) {
          firstCol = true;
        }
        matrix[0][j] = 0;
        matrix[i][0] = 0;
      }
    }
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      const item = matrix[i][j];
      if (matrix[0][j] == 0 || matrix[i][0] == 0) {
        matrix[i][j] = 0;
      }
    }
  }

  // æœ€åå¤„ç†ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—

  if (firstRow) {
    for (let i = 0; i < n; i++) {
      matrix[0][i] = 0;
    }
  }

  if (firstCol) {
    for (let i = 0; i < m; i++) {
      matrix[i][0] = 0;
    }
  }

  return matrix;
};
```

#### æ‰©å±•

ä¸ºä»€ä¹ˆé€‰æ‹©ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—ï¼Œé€‰æ‹©å…¶ä»–è¡Œå’Œåˆ—å¯ä»¥ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

### [75].sort-colors

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/sort-colors/description/

#### é¢˜ç›®æè¿°

Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:

Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Follow up:

A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
Could you come up with a one-pass algorithm using only constant space?

#### æ€è·¯

å…¶å®å°±æ˜¯æ’åºï¼Œè€Œä¸”æ²¡æœ‰è¦æ±‚ç¨³å®šæ€§ï¼Œå°±æ˜¯ç”¨å•¥æ’åºç®—æ³•éƒ½è¡Œã€‚
é¢˜ç›®å¹¶æ²¡æœ‰ç»™å‡ºæ•°æ®è§„æ¨¡ï¼Œå› æ­¤æˆ‘é»˜è®¤æ•°æ®é‡ä¸å¤§ï¼Œç›´æ¥é€‰æ‹©äº†å†’æ³¡æ’åº

#### å…³é”®ç‚¹è§£æ

å†’æ³¡æ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯ N å¹³æ–¹ï¼Œæ— æ³•ä¼˜åŒ–ï¼Œä½†æ˜¯å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–å¸¸æ•°é¡¹ï¼Œ
æ¯”å¦‚å¾ªç¯çš„èµ·æ­¢æ¡ä»¶ã€‚ ç”±äºæ¯ä¸€æ¬¡éå†éƒ½ä¼šå°†æœ€åä¸€ä½â€œå°±ä½â€ï¼Œå› æ­¤å†…å±‚å¾ªç¯çš„æˆªæ­¢æ¡ä»¶å°±å¯ä»¥æ˜¯
`nums.length - i`ï¼Œ è€Œä¸æ˜¯ `nums.length`, å¯ä»¥çœä¸€åŠçš„æ—¶é—´ã€‚

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=75 lang=javascript
 *
 * [75] Sort Colors
 *
 * https://leetcode.com/problems/sort-colors/description/
 *
 * algorithms
 * Medium (41.41%)
 * Total Accepted:    297K
 * Total Submissions: 716.1K
 * Testcase Example:  '[2,0,2,1,1,0]'
 *
 * Given an array with n objects colored red, white or blue, sort them in-place
 * so that objects of the same color are adjacent, with the colors in the order
 * red, white and blue.
 *
 * Here, we will use the integers 0, 1, and 2 to represent the color red,
 * white, and blue respectively.
 *
 * Note:Â You are not suppose to use the library's sort function for this
 * problem.
 *
 * Example:
 *
 *
 * Input: [2,0,2,1,1,0]
 * Output: [0,0,1,1,2,2]
 *
 * Follow up:
 *
 *
 * A rather straight forward solution is a two-pass algorithm using counting
 * sort.
 * First, iterate the array counting number of 0's, 1's, and 2's, then
 * overwrite array with total number of 0's, then 1's and followed by 2's.
 * Could you come up with aÂ one-pass algorithm using only constant space?
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
  function swap(nums, i, j) {
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = 0; j < nums.length - i; j++) {
      if (nums[j] < nums[j - 1]) {
        swap(nums, j - 1, j);
      }
    }
  }
};
```

### [78].subsets

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/subsets/description/

#### é¢˜ç›®æè¿°

```
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]


```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚é›†åˆï¼Œå¹¶ä¸æ˜¯`æ±‚æå€¼`ï¼Œå› æ­¤åŠ¨æ€è§„åˆ’ä¸æ˜¯ç‰¹åˆ«åˆ‡åˆï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è€ƒè™‘åˆ«çš„æ–¹æ³•ã€‚

è¿™ç§é¢˜ç›®å…¶å®æœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼Œå°±æ˜¯å›æº¯æ³•ã€‚
ç½‘ä¸Šä¹Ÿæœ‰å¤§ç¥ç»™å‡ºäº†è¿™ç§å›æº¯æ³•è§£é¢˜çš„
[é€šç”¨å†™æ³•](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)ï¼Œè¿™é‡Œçš„æ‰€æœ‰çš„è§£æ³•ä½¿ç”¨é€šç”¨æ–¹æ³•è§£ç­”ã€‚
é™¤äº†è¿™é“é¢˜ç›®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é¢˜ç›®å¯ä»¥ç”¨è¿™ç§é€šç”¨è§£æ³•ï¼Œå…·ä½“çš„é¢˜ç›®è§åæ–¹ç›¸å…³é¢˜ç›®éƒ¨åˆ†ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹é€šç”¨è§£æ³•çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ç”»äº†ä¸€å¼ å›¾ï¼š

![backtrack](../assets/problems/backtrack.png)

é€šç”¨å†™æ³•çš„å…·ä½“ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•
- backtrack è§£é¢˜å…¬å¼

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=78 lang=javascript
 *
 * [78] Subsets
 *
 * https://leetcode.com/problems/subsets/description/
 *
 * algorithms
 * Medium (51.19%)
 * Total Accepted:    351.6K
 * Total Submissions: 674.8K
 * Testcase Example:  '[1,2,3]'
 *
 * Given a set of distinct integers, nums, return all possible subsets (the
 * power set).
 *
 * Note: The solution set must not contain duplicate subsets.
 *
 * Example:
 *
 *
 * Input: nums = [1,2,3]
 * Output:
 * [
 * â  [3],
 * [1],
 * [2],
 * [1,2,3],
 * [1,3],
 * [2,3],
 * [1,2],
 * []
 * ]
 *
 */
function backtrack(list, tempList, nums, start) {
  list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  const list = [];
  backtrack(list, [], nums, 0);
  return list;
};
```

#### ç›¸å…³é¢˜ç›®

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [86].partition-list

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/partition-list/description/

#### é¢˜ç›®æè¿°

Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example:

Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5

#### æ€è·¯

- è®¾å®šä¸¤ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼ŒdummyHead1 ç”¨æ¥ä¿å­˜å°äºè¯¥å€¼çš„é“¾è¡¨ï¼ŒdummyHead2 æ¥ä¿å­˜å¤§äºç­‰äºè¯¥å€¼çš„é“¾è¡¨

- éå†æ•´ä¸ªåŸå§‹é“¾è¡¨ï¼Œå°†å°äºè¯¥å€¼çš„æ”¾äº dummyHead1 ä¸­ï¼Œå…¶ä½™çš„æ”¾ç½®åœ¨ dummyHead2 ä¸­

éå†ç»“æŸåï¼Œå°† dummyHead2 æ’å…¥åˆ° dummyHead1 åé¢

![86.partition-list](../assets/86.partition-list.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

#### å…³é”®ç‚¹è§£æ

- é“¾è¡¨çš„åŸºæœ¬æ“ä½œ(éå†)
- è™šæ‹ŸèŠ‚ç‚¹ dummy ç®€åŒ–æ“ä½œ
- éå†å®Œæˆä¹‹åè®°å¾—`currentL1.next = null;`å¦åˆ™ä¼šå†…å­˜æº¢å‡º

> å¦‚æœå•çº¯çš„éå†æ˜¯ä¸éœ€è¦ä¸Šé¢æ“ä½œçš„ï¼Œä½†æ˜¯æˆ‘ä»¬çš„éå†ä¼šå¯¼è‡´ currentL1.next å’Œ currentL2.next
> ä¸­æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªä¸æ˜¯ nullï¼Œ å¦‚æœä¸è¿™ä¹ˆæ“ä½œçš„è¯ä¼šå¯¼è‡´ä¸¤ä¸ªé“¾è¡¨æˆç¯ï¼Œé€ æˆæº¢å‡ºã€‚

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=86 lang=javascript
 *
 * [86] Partition List
 *
 * https://leetcode.com/problems/partition-list/description/
 *
 * algorithms
 * Medium (36.41%)
 * Total Accepted:    155.1K
 * Total Submissions: 425.1K
 * Testcase Example:  '[1,4,3,2,5,2]\n3'
 *
 * Given a linked list and a value x, partition it such that all nodes less
 * than x come before nodes greater than or equal to x.
 *
 * You should preserve the original relative order of the nodes in each of the
 * two partitions.
 *
 * Example:
 *
 *
 * Input: head = 1->4->3->2->5->2, x = 3
 * Output: 1->2->2->4->3->5
 *
 *
 */

/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function(head, x) {
  const dummyHead1 = {
    next: null,
  };
  const dummyHead2 = {
    next: null,
  };

  let current = {
    next: head,
  };
  let currentL1 = dummyHead1;
  let currentL2 = dummyHead2;
  while (current.next) {
    current = current.next;
    if (current.val < x) {
      currentL1.next = current;
      currentL1 = current;
    } else {
      currentL2.next = current;
      currentL2 = current;
    }
  }

  currentL2.next = null;

  currentL1.next = dummyHead2.next;

  return dummyHead1.next;
};
```

### [875].koko-eating-bananas

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/koko-eating-bananas/description/

#### é¢˜ç›®æè¿°

```
Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.

Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.

Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.

Return the minimum integer K such that she can eat all the bananas within H hours.



Example 1:

Input: piles = [3,6,7,11], H = 8
Output: 4
Example 2:

Input: piles = [30,11,23,4,20], H = 5
Output: 30
Example 3:

Input: piles = [30,11,23,4,20], H = 6
Output: 23


Note:

1 <= piles.length <= 10^4
piles.length <= H <= 10^9
1 <= piles[i] <= 10^9

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯ï¼Œé€‰æ‹©æœ€å¤§çš„å †çš„é¦™è•‰æ•°ï¼Œç„¶åè¯•ä¸€ä¸‹èƒ½ä¸èƒ½è¡Œï¼Œå¦‚æœä¸è¡Œåˆ™ç›´æ¥è¿”å›ä¸Šæ¬¡è®¡ç®—çš„ç»“æœï¼Œ
å¦‚æœè¡Œï¼Œæˆ‘ä»¬å‡å°‘ 1 ä¸ªé¦™è•‰ï¼Œè¯•è¯•è¡Œä¸è¡Œï¼Œä¾æ¬¡ç±»æ¨ã€‚è®¡ç®—å‡ºåˆšå¥½ä¸è¡Œçš„å³å¯ã€‚è¿™ç§è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ã€‚

è¿™é“é¢˜å¦‚æœèƒ½çœ‹å‡ºæ¥æ˜¯äºŒåˆ†æ³•è§£å†³ï¼Œé‚£ä¹ˆå…¶å®å¾ˆç®€å•ã€‚ä¸ºä»€ä¹ˆå®ƒæ˜¯äºŒåˆ†é—®é¢˜å‘¢ï¼Ÿ
æˆ‘è¿™é‡Œç”»äº†ä¸ªå›¾ï¼Œæˆ‘ç›¸ä¿¡ä½ çœ‹äº†å°±æ˜ç™½äº†ã€‚

![koko-eating-bananas](../assets/problems/koko-eating-bananas.png)

#### å…³é”®ç‚¹è§£æ

- äºŒåˆ†æŸ¥æ‰¾

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=875 lang=javascript
 *
 * [875] Koko Eating Bananas
 *
 * https://leetcode.com/problems/koko-eating-bananas/description/
 *
 * algorithms
 * Medium (44.51%)
 * Total Accepted:    11.3K
 * Total Submissions: 24.8K
 * Testcase Example:  '[3,6,7,11]\n8'
 *
 * Koko loves to eat bananas.Â  There are NÂ piles of bananas, the i-thÂ pile has
 * piles[i] bananas.Â  The guards have gone and will come back in H hours.
 *
 * Koko can decide her bananas-per-hour eating speed of K.Â  Each hour, she
 * chooses some pile of bananas, and eats K bananas from that pile.Â  If the
 * pile has less than K bananas, she eats all of them instead, and won't eat
 * any more bananas during this hour.
 *
 * Koko likes to eat slowly, but still wants to finish eating all the bananas
 * before the guards come back.
 *
 * Return the minimum integer K such that she can eat all the bananas within H
 * hours.
 *
 *
 *
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: piles = [3,6,7,11], H = 8
 * Output: 4
 *
 *
 *
 * Example 2:
 *
 *
 * Input: piles = [30,11,23,4,20], H = 5
 * Output: 30
 *
 *
 *
 * Example 3:
 *
 *
 * Input: piles = [30,11,23,4,20], H = 6
 * Output: 23
 *
 *
 *
 *
 * Note:
 *
 *
 * 1 <= piles.length <= 10^4
 * piles.length <= H <= 10^9
 * 1 <= piles[i] <= 10^9
 *
 *
 *
 *
 *
 */

function canEatAllBananas(piles, H, mid) {
  let h = 0;
  for (let pile of piles) {
    h += Math.ceil(pile / mid);
  }

  return h <= H;
}
/**
 * @param {number[]} piles
 * @param {number} H
 * @return {number}
 */
var minEatingSpeed = function(piles, H) {
  let lo = 1,
    hi = Math.max(...piles);

  while (lo <= hi) {
    let mid = lo + ((hi - lo) >> 1);
    if (canEatAllBananas(piles, H, mid)) {
      hi = mid - 1;
    } else {
      lo = mid + 1;
    }
  }

  return lo; //  ä¸èƒ½é€‰æ‹©hi
};
```

### [877].stone-game

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/stone-game/description/

#### é¢˜ç›®æè¿°

```
Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].

The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.

Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.



Example 1:

Input: [5,3,4,5]
Output: true
Explanation:
Alex starts first, and can only take the first 5 or the last 5.
Say he takes the first 5, so that the row becomes [3, 4, 5].
If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alex, so we return true.


Note:

2 <= piles.length <= 500
piles.length is even.
1 <= piles[i] <= 500
sum(piles) is odd.

```

#### æ€è·¯

ç”±äº piles æ˜¯å¶æ•°çš„ï¼Œå¹¶ä¸” piles çš„æ€»å’Œæ˜¯å¥‡æ•°çš„ã€‚

å› æ­¤ Alex`å¯ä»¥åšåˆ°`è¦ä¸æ‹¿çš„å…¨éƒ¨æ˜¯å¥‡æ•°ï¼Œè¦ä¹ˆå…¨éƒ¨æ˜¯å¶æ•°ã€‚

ä¸¾ä¸ªä¾‹å­ï¼š æ¯”å¦‚ Alex ç¬¬ä¸€æ¬¡å…ˆæ‹¿ç¬¬ä¸€ä¸ª

è¿™é‡Œæœ‰ä¸¤ç§æƒ…å†µï¼š

1. Lee å¦‚æœæ‹¿äº†ç¬¬äºŒå—(å¶æ•°)ï¼Œé‚£ä¹ˆ Alex ç»§ç»­æ‹¿ç¬¬ä¸‰å—ï¼Œä»¥æ­¤ç±»æ¨ã€‚ã€‚ã€‚

2. Lee å¦‚æœæ‹¿äº†æœ€åä¸€å—(å¶æ•°)ï¼Œé‚£ä¹ˆ Alex ç»§ç»­æ‹¿å€’æ•°ç¬¬äºŒå—ï¼Œä»¥æ­¤ç±»æ¨ã€‚ã€‚ã€‚

å› æ­¤ Alex`å¯ä»¥`åšåˆ°åªæ‹¿å¥‡æ•°æˆ–è€…å¶æ•°ï¼Œåªæ˜¯ä»–å¯ä»¥æ§åˆ¶çš„ï¼Œå› æ­¤ä»–è¦åšçš„å°±æ˜¯æ•°ä¸€ä¸‹ï¼Œå¥‡æ•°åŠ èµ·æ¥å¤šè¿˜æ˜¯å¶æ•°åŠ èµ·æ¥å¤šå°±å¥½äº†ã€‚
å¥‡æ•°å¤šå°±å…¨éƒ¨é€‰å¥‡æ•°ï¼Œå¶æ•°å°±å…¨éƒ¨é€‰å¶æ•°ã€‚ Lee æ˜¯æ²¡æœ‰è¿™ç§è‡ªç”±æƒçš„ã€‚

#### å…³é”®ç‚¹è§£æ

- å¯ä»¥ç”¨ DP(åŠ¨æ€è§„åˆ’)

- å¯ä»¥ä»æ•°å­¦çš„è§’åº¦å»åˆ†æ

> ......(ğŸ˜…)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=877 lang=javascript
 *
 * [877] Stone Game
 *
 * https://leetcode.com/problems/stone-game/description/
 *
 * algorithms
 * Medium (60.46%)
 * Total Accepted:    21.4K
 * Total Submissions: 35.3K
 * Testcase Example:  '[5,3,4,5]'
 *
 * Alex and Lee play a game with piles of stones.Â  There are an even number of
 * piles arranged in a row, and each pile has a positive integer number of
 * stones piles[i].
 *
 * The objective of the game is to end with the mostÂ stones.Â  The total number
 * of stones is odd, so there are no ties.
 *
 * Alex and Lee take turns, with Alex starting first.Â  Each turn, a player
 * takes the entire pile of stones from either the beginning or the end of the
 * row.Â  This continues until there are no more piles left, at which point the
 * person with the most stones wins.
 *
 * Assuming Alex and Lee play optimally, return TrueÂ if and only if Alex wins
 * the game.
 *
 *
 *
 * Example 1:
 *
 *
 * Input: [5,3,4,5]
 * Output: true
 * Explanation:
 * Alex starts first, and can only take the first 5 or the last 5.
 * Say he takes the first 5, so that the row becomes [3, 4, 5].
 * If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10
 * points.
 * If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win
 * with 9 points.
 * This demonstrated that taking the first 5 was a winning move for Alex, so we
 * return true.
 *
 *
 *
 *
 * Note:
 *
 *
 * 2 <= piles.length <= 500
 * piles.length is even.
 * 1 <= piles[i] <= 500
 * sum(piles) is odd.
 *
 *
 *
 */
/**
 * @param {number[]} piles
 * @return {boolean}
 */
var stoneGame = function(piles) {
  return true;
};
```

#### æ‰©å±•

è…¾è®¯é¢è¯•é¢˜ï¼šä¸€å…± 100 åªå¼“ç®­ ä½ å’Œä½ çš„å¯¹æ‰‹å…±ç”¨ã€‚ä½ ä»¬æ¯æ¬¡åªèƒ½å°„å‡ºä¸€æ”¯ç®­æˆ–è€…ä¸¤æ”¯ç®­ï¼Œå°„å‡»äº¤æ›¿è¿›è¡Œï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œä¿è¯è‡ªå·±è·èƒœã€‚

ç­”æ¡ˆï¼š å…ˆæ‰‹ï¼Œå‰©ä¸‹çš„æ˜¯ 3 çš„å€æ•°å°±è¡Œ(100-1=99)ï¼Œç„¶åæŒ‰ç…§ 3 çš„å€æ•°å°„ç®­å¿…èµ¢ã€‚
æ¯”å¦‚ä½ å…ˆæ‹¿äº† 1ï¼Œå‰©ä¸‹ 99 ä¸ªã€‚ å¯¹æ‰‹æ‹¿äº† 1ï¼Œä½ å°±æ‹¿ 2ã€‚è¿™æ ·æŒç»­ 33 æ¬¡å°±èµ¢äº†ã€‚å¦‚æœå¯¹æ‰‹æ‹¿äº† 2 ä¸ªï¼Œä½ å°±æ‹¿ 1 ä¸ªï¼Œè¿™æ ·æŒç»­ 33 æ¬¡ä½ ä¹Ÿæ˜¯èµ¢çš„ã€‚

> è¿™æ˜¯ä¸€ç§å…¸å‹çš„åšå¼ˆé—®é¢˜ï¼Œ ä½ å’Œå¯¹æ‰‹äº¤æ›¿è¿›è¡Œï¼Œå¯¹æ‰‹çš„è¡ŒåŠ¨å½±å“ä½ æ¥ä¸‹æ¥çš„ç­–ç•¥ã€‚ è¿™ç®—æ˜¯ä¸€ç§æœ€ç®€å•çš„åšå¼ˆé—®é¢˜äº†

### [88].merge-sorted-array

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/merge-sorted-array/description/

#### é¢˜ç›®æè¿°

```
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:

The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.
Example:

Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯`å°†nums2æ’åˆ°num1çš„æœ«å°¾, ç„¶åæ’åº`

å…·ä½“ä»£ç ï¼š

```js
// è¿™ç§è§£æ³•è¿méƒ½ç”¨ä¸åˆ°
// è¿™æ˜¾ç„¶ä¸æ˜¯å‡ºé¢˜äººçš„æ„æ€
if (n === 0) return;
let current2 = 0;
for (let i = nums1.length - 1; i >= nums1.length - n; i--) {
  nums1[i] = nums2[current2++];
}
nums1.sort((a, b) => a - b); // å½“ç„¶ä½ å¯ä»¥è‡ªå·±å†™æ’åºï¼Œè¿™é‡Œæ‡’å¾—å†™äº†ï¼Œå› ä¸ºå·²ç»åç¦»äº†é¢˜ç›®æœ¬èº«
```

è¿™é“é¢˜ç›®å…¶å®å’ŒåŸºæœ¬æ’åºç®—æ³•ä¸­çš„`merge sort`éå¸¸åƒï¼Œä½†æ˜¯ merge sort å¾ˆå¤šæ—¶å€™ï¼Œåˆå¹¶çš„æ—¶å€™æˆ‘ä»¬é€šå¸¸æ˜¯
æ–°å»ºä¸€ä¸ªæ•°ç»„ï¼Œè¿™æ ·å°±å¾ˆç®€å•ã€‚ ä½†æ˜¯è¿™é“é¢˜ç›®è¦æ±‚çš„æ˜¯`åŸåœ°ä¿®æ”¹`.

è¿™å°±å’Œ merge sort çš„ merge è¿‡ç¨‹æœ‰ç‚¹ä¸åŒï¼Œæˆ‘ä»¬å…ˆæ¥å›é¡¾ä¸€ä¸‹ merge sort çš„ merge è¿‡ç¨‹ã€‚

merge çš„è¿‡ç¨‹`å¯ä»¥`æ˜¯å…ˆæ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„å¤´å…ƒç´ ï¼Œç„¶åå°†è¾ƒå°çš„æ¨åˆ°æœ€ç»ˆçš„æ•°ç»„ä¸­ï¼Œå¹¶å°†å…¶ä»åŸæ•°ç»„ä¸­å‡ºé˜Ÿåˆ—ã€‚
å¾ªç¯ç›´åˆ°ä¸¤ä¸ªæ•°ç»„éƒ½ä¸ºç©ºã€‚

å…·ä½“ä»£ç å¦‚ä¸‹ï¼š

```js
// å°†nums1 å’Œ nums2 åˆå¹¶
function merge(nums1, nums2) {
  let ret = [];
  while (nums1.length || nums2.length) {
    // ä¸ºäº†æ–¹ä¾¿å¤§å®¶ç†è§£ï¼Œè¿™é‡Œä»£ç æœ‰ç‚¹èµ˜ä½™
    if (nums1.length === 0) {
      ret.push(nums2.shift());
      continue;
    }

    if (nums2.length === 0) {
      ret.push(nums1.shift());
      continue;
    }
    const a = nums1[0];
    const b = nums2[0];
    if (a > b) {
      ret.push(nums2.shift());
    } else {
      ret.push(nums1.shift());
    }
  }
  return ret;
}
```

è¿™é‡Œè¦æ±‚åŸåœ°ä¿®æ”¹ï¼Œå…¶å®æˆ‘ä»¬èƒ½åªè¦ä»åå¾€å‰æ¯”è¾ƒï¼Œå¹¶ä»åå¾€å‰æ’å…¥å³å¯ã€‚

æˆ‘ä»¬éœ€è¦ä¸‰ä¸ªæŒ‡é’ˆï¼š

1. current ç”¨äºè®°å½•å½“å‰å¡«è¡¥åˆ°é‚£ä¸ªä½ç½®äº†

2. m ç”¨äºè®°å½• nums1 æ•°ç»„å¤„ç†åˆ°å“ªä¸ªå…ƒç´ äº†

3. n ç”¨äºè®°å½• nums2 æ•°ç»„å¤„ç†åˆ°å“ªä¸ªå…ƒç´ äº†

å¦‚å›¾æ‰€ç¤ºï¼š

- ç°è‰²ä»£è¡¨ num2 æ•°ç»„å·²ç»å¤„ç†è¿‡çš„å…ƒç´ 
- çº¢è‰²ä»£è¡¨å½“å‰æ­£åœ¨è¿›è¡Œæ¯”è¾ƒçš„å…ƒç´ 
- ç»¿è‰²ä»£è¡¨å·²ç»å°±ä½çš„å…ƒç´ 

![88.merge-sorted-array-1](../assets/problems/88.merge-sorted-array-1.png)
![88.merge-sorted-array-2](../assets/problems/88.merge-sorted-array-2.png)
![88.merge-sorted-array-3](../assets/problems/88.merge-sorted-array-3.png)

#### å…³é”®ç‚¹è§£æ

- ä»åå¾€å‰æ¯”è¾ƒï¼Œå¹¶ä»åå¾€å‰æ’å…¥

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=88 lang=javascript
 *
 * [88] Merge Sorted Array
 *
 * https://leetcode.com/problems/merge-sorted-array/description/
 *
 * algorithms
 * Easy (34.95%)
 * Total Accepted:    347.5K
 * Total Submissions: 984.7K
 * Testcase Example:  '[1,2,3,0,0,0]\n3\n[2,5,6]\n3'
 *
 * Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as
 * one sorted array.
 *
 * Note:
 *
 *
 * The number of elements initialized in nums1 and nums2 are m and n
 * respectively.
 * You may assume that nums1 has enough space (size that is greater or equal to
 * m + n) to hold additional elements from nums2.
 *
 *
 * Example:
 *
 *
 * Input:
 * nums1 = [1,2,3,0,0,0], m = 3
 * nums2 = [2,5,6],       n = 3
 *
 * Output:Â [1,2,2,3,5,6]
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
  // è®¾ç½®ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘nums1çš„æœ«å°¾
  // ç„¶åä¸æ–­å·¦ç§»æŒ‡é’ˆæ›´æ–°å…ƒç´ 
  let current = nums1.length - 1;

  while (current >= 0) {
    // æ²¡å¿…è¦ç»§ç»­äº†
    if (n === 0) return;

    // ä¸ºäº†æ–¹ä¾¿å¤§å®¶ç†è§£ï¼Œè¿™é‡Œä»£ç æœ‰ç‚¹èµ˜ä½™
    if (m < 0) {
      nums1[current--] = nums2[--n];
      continue;
    }

    if (n < 0) {
      nums1[current--] = nums1[--m];
      continue;
    }
    // å–å¤§çš„å¡«å…… nums1çš„æœ«å°¾
    // ç„¶åæ›´æ–° m æˆ–è€… n
    if (nums1[m - 1] > nums2[n - 1]) {
      nums1[current--] = nums1[--m];
    } else {
      nums1[current--] = nums2[--n];
    }
  }
};
```

### [887].super-egg-drop

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/super-egg-drop/description/

#### é¢˜ç›®æè¿°

```
You are given K eggs, and you have access to a building with N floors from 1 to N.

Each egg is identical in function, and if an egg breaks, you cannot drop it again.

You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.

Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N).

Your goal is to know with certainty what the value of F is.

What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?



Example 1:

Input: K = 1, N = 2
Output: 2
Explanation:
Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
If it didn't break, then we know with certainty F = 2.
Hence, we needed 2 moves in the worst case to know what F is with certainty.
Example 2:

Input: K = 2, N = 6
Output: 3
Example 3:

Input: K = 3, N = 14
Output: 4


Note:

1 <= K <= 100
1 <= N <= 10000


```

#### æ€è·¯

è¿™æ˜¯ä¸€é“å…¸å‹çš„åŠ¨æ€è§„åˆ’é¢˜ç›®ï¼Œä½†æ˜¯åˆå’Œä¸€èˆ¬çš„åŠ¨æ€è§„åˆ’ä¸ä¸€æ ·ã€‚

æ‹¿é¢˜ç›®ç»™çš„ä¾‹å­ä¸ºä¾‹ï¼Œä¸¤ä¸ªé¸¡è›‹ï¼Œå…­å±‚æ¥¼ï¼Œæˆ‘ä»¬æœ€å°‘æ‰”å‡ æ¬¡ï¼Ÿ

![887.super-egg-drop-1](../assets/problems/887.super-egg-drop-1.png)

ä¸€ä¸ªç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯ï¼Œå»ºç«‹ dp[i][j], ä»£è¡¨ i ä¸ªé¸¡è›‹ï¼Œj å±‚æ¥¼æœ€å°‘æ‰”å‡ æ¬¡ï¼Œç„¶åæˆ‘ä»¬å– dp[K][n]å³å¯ã€‚

ä»£ç å¤§æ¦‚è¿™æ ·çš„ï¼š

```js
const dp = Array(K + 1);
dp[0] = Array(N + 1).fill(0);
for (let i = 1; i < K + 1; i++) {
  dp[i] = [0];
  for (let j = 1; j < N + 1; j++) {
    // åªæœ‰ä¸€ä¸ªé¸¡è›‹
    if (i === 1) {
      dp[i][j] = j;
      continue;
    }
    // åªæœ‰ä¸€å±‚æ¥¼
    if (j === 1) {
      dp[i][j] = 1;
      continue;
    }

    // æ¯ä¸€å±‚æˆ‘ä»¬éƒ½æ¨¡æ‹Ÿä¸€é
    const all = [];
    for (let k = 1; k < j + 1; k++) {
      const brokenCount = dp[i - 1][k - 1]; // å¦‚æœç¢äº†
      const notBrokenCount = dp[i][j - k]; // å¦‚æœæ²¡ç¢
      all.push(Math.max(brokenCount, notBrokenCount)); // æœ€åçš„å¯èƒ½
    }
    dp[i][j] = Math.min(...all) + 1; // æœ€åçš„é›†åˆä¸­æˆ‘ä»¬å–æœ€å¥½çš„æƒ…å†µ
  }
}

return dp[K][N];
```

æœä¸å…¶ç„¶ï¼Œå½“æˆ‘æäº¤çš„æ—¶å€™ï¼Œè¶…æ—¶äº†ã€‚ è¿™ä¸ªçš„æ—¶å¤æ‚åº¦æ˜¯å¾ˆé«˜çš„ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å†…å±‚æš´åŠ›çš„æ±‚è§£æ‰€æœ‰å¯èƒ½ï¼Œç„¶å
å–æœ€å¥½çš„ï¼Œè¿™ä¸ªè¿‡ç¨‹éå¸¸è€—æ—¶ï¼Œå¤§æ¦‚æ˜¯ O(N^2 \* K).

ç„¶åæˆ‘çœ‹äº†ä¸€ä½ leetcode[ç½‘å‹](https://leetcode.com/lee215/)çš„å›ç­”,
ä»–çš„æƒ³æ³•æ˜¯`dp[M][K]means that, given K eggs and M movesï¼Œwhat is the maximum number of floor that we can check.`

æˆ‘ä»¬æŒ‰ç…§ä»–çš„æ€è·¯é‡æ–°å»ºæ¨¡ï¼š

![887.super-egg-drop-2](../assets/problems/887.super-egg-drop-2.png)

å¯ä»¥çœ‹åˆ°å³ä¸‹è§’çš„éƒ¨åˆ†æ ¹æœ¬å°±ä¸éœ€è¦è®¡ç®—ï¼Œä»è€ŒèŠ‚çœå¾ˆå¤šæ—¶é—´

#### å…³é”®ç‚¹è§£æ

- dp å»ºæ¨¡æ€è·¯è¦å‘ç”Ÿå˜åŒ–, å³
  `dp[M][K]means that, given K eggs and M movesï¼Œwhat is the maximum number of floor that we can check.`

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=887 lang=javascript
 *
 * [887] Super Egg Drop
 *
 * https://leetcode.com/problems/super-egg-drop/description/
 *
 * algorithms
 * Hard (24.64%)
 * Total Accepted:    6.2K
 * Total Submissions: 24.9K
 * Testcase Example:  '1\n2'
 *
 * You are given K eggs, and you have access to a building with N floors from 1
 * to N.
 *
 * Each egg is identical in function, and if an egg breaks, you cannot drop it
 * again.
 *
 * You know that there exists a floor F with 0 <= F <= N such that any egg
 * dropped at a floor higher than F will break, and any egg dropped at or below
 * floor F will not break.
 *
 * Each move, you may take an egg (if you have an unbroken one) and drop it
 * from any floor X (withÂ 1 <= X <= N).
 *
 * Your goal is to knowÂ with certaintyÂ what the value of F is.
 *
 * What is the minimum number of moves that you need to know with certainty
 * what F is, regardless of the initial value of F?
 *
 *
 *
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: K = 1, N = 2
 * Output: 2
 * Explanation:
 * Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
 * Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty
 * that F = 1.
 * If it didn't break, then we know with certainty F = 2.
 * Hence, we needed 2 moves in the worst case to know what F is with
 * certainty.
 *
 *
 *
 * Example 2:
 *
 *
 * Input: K = 2, N = 6
 * Output: 3
 *
 *
 *
 * Example 3:
 *
 *
 * Input: K = 3, N = 14
 * Output: 4
 *
 *
 *
 *
 * Note:
 *
 *
 * 1 <= K <= 100
 * 1 <= N <= 10000
 *
 *
 *
 *
 *
 */
/**
 * @param {number} K
 * @param {number} N
 * @return {number}
 */
var superEggDrop = function(K, N) {
  // ä¸é€‰æ‹©dp[K][M]çš„åŸå› æ˜¯dp[M][K]å¯ä»¥ç®€åŒ–æ“ä½œ
  const dp = Array(N + 1)
    .fill(0)
    .map(_ => Array(K + 1).fill(0));

  let m = 0;
  while (dp[m][K] < N) {
    m++;
    for (let k = 1; k <= K; ++k) dp[m][k] = dp[m - 1][k - 1] + 1 + dp[m - 1][k];
  }
  console.log(dp);
  return m;
};
```

### [90].subsets-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/subsets-ii/description/

#### é¢˜ç›®æè¿°

```
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

```

#### æ€è·¯

è¿™é“é¢˜ç›®æ˜¯æ±‚é›†åˆï¼Œå¹¶ä¸æ˜¯`æ±‚æå€¼`ï¼Œå› æ­¤åŠ¨æ€è§„åˆ’ä¸æ˜¯ç‰¹åˆ«åˆ‡åˆï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è€ƒè™‘åˆ«çš„æ–¹æ³•ã€‚

è¿™ç§é¢˜ç›®å…¶å®æœ‰ä¸€ä¸ªé€šç”¨çš„è§£æ³•ï¼Œå°±æ˜¯å›æº¯æ³•ã€‚
ç½‘ä¸Šä¹Ÿæœ‰å¤§ç¥ç»™å‡ºäº†è¿™ç§å›æº¯æ³•è§£é¢˜çš„
[é€šç”¨å†™æ³•](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)ï¼Œè¿™é‡Œçš„æ‰€æœ‰çš„è§£æ³•ä½¿ç”¨é€šç”¨æ–¹æ³•è§£ç­”ã€‚
é™¤äº†è¿™é“é¢˜ç›®è¿˜æœ‰å¾ˆå¤šå…¶ä»–é¢˜ç›®å¯ä»¥ç”¨è¿™ç§é€šç”¨è§£æ³•ï¼Œå…·ä½“çš„é¢˜ç›®è§åæ–¹ç›¸å…³é¢˜ç›®éƒ¨åˆ†ã€‚

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹é€šç”¨è§£æ³•çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ç”»äº†ä¸€å¼ å›¾ï¼š

![backtrack](../assets/problems/backtrack.png)

é€šç”¨å†™æ³•çš„å…·ä½“ä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹è§£æ

- å›æº¯æ³•
- backtrack è§£é¢˜å…¬å¼

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=90 lang=javascript
 *
 * [90] Subsets II
 *
 * https://leetcode.com/problems/subsets-ii/description/
 *
 * algorithms
 * Medium (41.53%)
 * Total Accepted:    197.1K
 * Total Submissions: 469.1K
 * Testcase Example:  '[1,2,2]'
 *
 * Given a collection of integers that might contain duplicates, nums, return
 * all possible subsets (the power set).
 *
 * Note: The solution set must not contain duplicate subsets.
 *
 * Example:
 *
 *
 * Input: [1,2,2]
 * Output:
 * [
 * â  [2],
 * â  [1],
 * â  [1,2,2],
 * â  [2,2],
 * â  [1,2],
 * â  []
 * ]
 *
 *
 */
function backtrack(list, tempList, nums, start) {
  list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    // å’Œ78.subsetsçš„åŒºåˆ«åœ¨äºè¿™é“é¢˜numså¯ä»¥æœ‰é‡å¤
    // å› æ­¤éœ€è¦è¿‡æ»¤è¿™ç§æƒ…å†µ
    if (i > start && nums[i] === nums[i - 1]) continue;
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
  const list = [];
  backtrack(
    list,
    [],
    nums.sort((a, b) => a - b),
    0,
    [],
  );
  return list;
};
```

#### ç›¸å…³é¢˜ç›®

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [113.path-sum-ii](./113.path-sum-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [900].rle-iterator

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/rle-iterator/description/

#### é¢˜ç›®æè¿°

```
Write an iterator that iterates through a run-length encoded sequence.

The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.

The iterator supports one function: next(int n), which exhausts the next n elements (n >= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1 instead.

For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as "three eights, zero nines, two fives".



Example 1:

Input: ["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
Output: [null,8,8,5,-1]
Explanation:
RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).
This maps to the sequence [8,8,8,5,5].
RLEIterator.next is then called 4 times:

.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].

.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].

.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].

.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,
but the second term did not exist.  Since the last term exhausted does not exist, we return -1.

Note:

0 <= A.length <= 1000
A.length is an even integer.
0 <= A[i] <= 10^9
There are at most 1000 calls to RLEIterator.next(int n) per test case.
Each call to RLEIterator.next(int n) will have 1 <= n <= 10^9.

```

#### æ€è·¯

è¿™æ˜¯ä¸€ä¸ªæ¸¸ç¨‹ç¼–ç çš„å…¸å‹é¢˜ç›®ã€‚

è¯¥ç®—æ³•åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯åˆå§‹åŒ–ï¼Œä¸€ä¸ªæ˜¯è°ƒç”¨`next(n)`.

æˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯åˆå§‹åŒ–çš„æ—¶å€™ï¼Œè®°ä½è¿™ä¸ª Aã€‚ ç„¶åæ¯æ¬¡è°ƒç”¨`next(n)`çš„æ—¶å€™åªéœ€è¦

åˆ¤æ–­ n æ˜¯å¦å¤§äº A[i](iä»0å¼€å§‹)

- å¦‚æœå¤§äº A[i], é‚£å°±è¯´æ˜ä¸å¤Ÿï¼Œæˆ‘ä»¬ç§»é™¤æ•°ç»„å‰ä¸¤é¡¹ï¼Œæ›´æ–° nï¼Œé‡å¤ 1

- å¦‚æœå°äº A[i], åˆ™è¯´æ˜å¤Ÿäº†ï¼Œæ›´æ–° A[i]

è¿™æ ·åšï¼Œæˆ‘ä»¬æ¯æ¬¡éƒ½è¦æ›´æ–° Aï¼Œè¿˜æœ‰ä¸€ç§åšæ³•å°±æ˜¯ä¸æ›´æ–° Aï¼Œè€Œæ˜¯`ä¼ªæ›´æ–°`ï¼Œå³ç”¨ä¸€ä¸ªå˜é‡è®°å½•ï¼Œå½“å‰è®¿é—®åˆ°çš„æ•°ç»„ä½ç½®ã€‚

> å¾ˆå¤šæ—¶å€™æˆ‘ä»¬éœ€è¦åŸå§‹çš„ï¼Œé‚£ä¹ˆå°±å¿…é¡»è¿™ç§æ”¾äº†ï¼Œæˆ‘çš„è§£æ³•å°±æ˜¯è¿™ç§æ–¹æ³•ã€‚

#### å…³é”®ç‚¹è§£æ

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=900 lang=javascript
 *
 * [900] RLE Iterator
 *
 * https://leetcode.com/problems/rle-iterator/description/
 *
 * algorithms
 * Medium (49.03%)
 * Total Accepted:    11.6K
 * Total Submissions: 23.5K
 * Testcase Example:  '["RLEIterator","next","next","next","next"]\n[[[3,8,0,9,2,5]],[2],[1],[1],[2]]'
 *
 * Write an iterator that iterates through a run-length encoded sequence.
 *
 * The iterator is initialized by RLEIterator(int[] A), where A is a run-length
 * encoding of someÂ sequence.Â  More specifically,Â for all even i,Â A[i] tells us
 * the number of times that the non-negative integer value A[i+1] is repeated
 * in the sequence.
 *
 * The iterator supports one function:Â next(int n), which exhausts the next n
 * elementsÂ (n >= 1) and returns the last element exhausted in this way.Â  If
 * there is no element left to exhaust, nextÂ returns -1 instead.
 *
 * For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding
 * of the sequence [8,8,8,5,5].Â  This is because the sequence can be read as
 * "three eights, zero nines, two fives".
 *
 *
 *
 * Example 1:
 *
 *
 * Input: ["RLEIterator","next","next","next","next"],
 * [[[3,8,0,9,2,5]],[2],[1],[1],[2]]
 * Output: [null,8,8,5,-1]
 * Explanation:
 * RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).
 * This maps to the sequence [8,8,8,5,5].
 * RLEIterator.next is then called 4 times:
 *
 * .next(2) exhausts 2 terms of the sequence, returning 8.  The remaining
 * sequence is now [8, 5, 5].
 *
 * .next(1) exhausts 1 term of the sequence, returning 8.  The remaining
 * sequence is now [5, 5].
 *
 * .next(1) exhausts 1 term of the sequence, returning 5.  The remaining
 * sequence is now [5].
 *
 * .next(2) exhausts 2 terms, returning -1.  This is because the first term
 * exhausted was 5,
 * but the second term did not exist.  Since the last term exhausted does not
 * exist, we return -1.
 *
 *
 *
 * Note:
 *
 *
 * 0 <= A.length <= 1000
 * A.lengthÂ is an even integer.
 * 0 <= A[i] <= 10^9
 * There are at most 1000 calls to RLEIterator.next(int n) per test case.
 * Each call toÂ RLEIterator.next(int n)Â will have 1 <= n <= 10^9.
 *
 *
 */
/**
 * @param {number[]} A
 */
var RLEIterator = function(A) {
  this.A = A;
  this.current = 0;
};

/**
 * @param {number} n
 * @return {number}
 */
RLEIterator.prototype.next = function(n) {
  const A = this.A;
  while (this.current < A.length && A[this.current] < n) {
    n = n - A[this.current];
    this.current += 2;
  }

  if (this.current >= A.length) {
    return -1;
  }

  A[this.current] = A[this.current] - n; // æ›´æ–°Count
  return A[this.current + 1]; // è¿”å›element
};

/**
 * Your RLEIterator object will be instantiated and called as such:
 * var obj = new RLEIterator(A)
 * var param_1 = obj.next(n)
 */
```

#### æ‰©å±•é˜…è¯»

[å“ˆå¤«æ›¼ç¼–ç å’Œæ¸¸ç¨‹ç¼–ç ](../thinkings/run-length-encode-and-huffman-encode.md)

### [91].decode-ways

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/decode-ways/description/

#### é¢˜ç›®æè¿°

```
A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
Example 2:

Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```

#### æ€è·¯

è¿™é“é¢˜ç›®å’Œçˆ¬æ¥¼æ¢¯é—®é¢˜æœ‰å¼‚æ›²åŒå·¥ä¹‹å¦™ã€‚

è¿™ä¹Ÿæ˜¯ä¸€é“å…¸å‹çš„åŠ¨æ€è§„åˆ’é¢˜ç›®ã€‚æˆ‘ä»¬æ¥æ€è€ƒï¼š

- å¯¹äºä¸€ä¸ªæ•°å­—æ¥è¯´[1,9]è¿™ä¹ä¸ªæ•°å­—èƒ½å¤Ÿè¢«è¯†åˆ«ä¸ºä¸€ç§ç¼–ç æ–¹å¼
- å¯¹äºä¸¤ä¸ªæ•°å­—æ¥è¯´[10, 26]è¿™å‡ ä¸ªæ•°å­—èƒ½è¢«è¯†åˆ«ä¸ºä¸€ç§ç¼–ç æ–¹å¼

æˆ‘ä»¬è€ƒè™‘ç”¨ dp[i]æ¥åˆ‡åˆ†å­é—®é¢˜ï¼Œ é‚£ä¹ˆ dp[i]è¡¨ç¤ºçš„æ„æ€æ˜¯å½“å‰å­—ç¬¦ä¸²çš„ä»¥ç´¢å¼• i ç»“å°¾çš„å­é—®é¢˜ã€‚
è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬æœ€ååªéœ€è¦å– dp[s.length] å°±å¯ä»¥è§£å†³é—®é¢˜äº†ã€‚

å…³äºé€’å½’å…¬å¼ï¼Œè®©æˆ‘ä»¬`å…ˆå±€éƒ¨åæ•´ä½“`ã€‚å¯¹äºå±€éƒ¨ï¼Œæˆ‘ä»¬éå†åˆ°ä¸€ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œ
æˆ‘ä»¬æœ‰ä¸¤ç§æ–¹å¼æ¥ç»„æˆç¼–ç æ–¹å¼ï¼Œç¬¬ä¸€ç§æ˜¯è¿™ä¸ªå…ƒç´ æœ¬èº«(éœ€è¦è‡ªèº«æ˜¯[1,9]),
ç¬¬äºŒç§æ˜¯å®ƒå’Œå‰ä¸€ä¸ªå…ƒç´ ç»„æˆ[10, 26]ã€‚ ç”¨ä¼ªä»£ç æ¥è¡¨ç¤ºçš„è¯å°±æ˜¯ï¼š
`dp[i] = ä»¥è‡ªèº«å»ç¼–ç (ä¸€ä½) + ä»¥å‰é¢çš„å…ƒç´ å’Œè‡ªèº«å»ç¼–ç (ä¸¤ä½)` .è¿™æ˜¾ç„¶æ˜¯å®Œå¤‡çš„ï¼Œ
è¿™æ ·æˆ‘ä»¬é€šè¿‡å±‚å±‚æ¨å¯¼å°±å¯ä»¥å¾—åˆ°ç»“æœã€‚

#### å…³é”®ç‚¹è§£æ

- çˆ¬æ¥¼æ¢¯é—®é¢˜(æˆ‘æŠŠè¿™ç§é¢˜ç›®ç»Ÿç§°ä¸ºçˆ¬æ¥¼æ¢¯é—®é¢˜)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=91 lang=javascript
 *
 * [91] Decode Ways
 *
 * https://leetcode.com/problems/decode-ways/description/
 *
 * algorithms
 * Medium (21.93%)
 * Total Accepted:    254.4K
 * Total Submissions: 1.1M
 * Testcase Example:  '"12"'
 *
 * A message containing letters from A-Z is being encoded to numbers using the
 * following mapping:
 *
 *
 * 'A' -> 1
 * 'B' -> 2
 * ...
 * 'Z' -> 26
 *
 *
 * Given a non-empty string containing only digits, determine the total number
 * of ways to decode it.
 *
 * Example 1:
 *
 *
 * Input: "12"
 * Output: 2
 * Explanation:Â It could be decoded as "AB" (1 2) or "L" (12).
 *
 *
 * Example 2:
 *
 *
 * Input: "226"
 * Output: 3
 * Explanation:Â It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2
 * 6).
 *
 */
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  if (s == null || s.length == 0) {
    return 0;
  }
  const dp = Array(s.length + 1).fill(0);
  dp[0] = 1;
  dp[1] = s[0] !== '0' ? 1 : 0;
  for (let i = 2; i < s.length + 1; i++) {
    const one = +s.slice(i - 1, i);
    const two = +s.slice(i - 2, i);

    if (two >= 10 && two <= 26) {
      dp[i] = dp[i - 2];
    }

    if (one >= 1 && one <= 9) {
      dp[i] += dp[i - 1];
    }
  }

  return dp[dp.length - 1];
};
```

#### æ‰©å±•

å¦‚æœç¼–ç çš„èŒƒå›´ä¸å†æ˜¯ 1-26ï¼Œè€Œæ˜¯ä¸‰ä½çš„è¯æ€ä¹ˆåŠï¼Ÿ

### [92].reverse-linked-list-ii

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/reverse-linked-list-ii/description/

#### é¢˜ç›®æè¿°

Reverse a linked list from position m to n. Do it in one-pass.

Note: 1 â‰¤ m â‰¤ n â‰¤ length of list.

Example:

Input: 1->2->3->4->5->NULL, m = 2, n = 4
Output: 1->4->3->2->5->NULL

#### æ€è·¯

è€ƒè™‘å–å‡ºéœ€è¦åè½¬çš„è¿™ä¸€å°æ®µé“¾è¡¨ï¼Œåè½¬å®Œåå†æ’å…¥åˆ°åŸå…ˆçš„é“¾è¡¨ä¸­ã€‚

ä»¥æœ¬é¢˜ä¸ºä¾‹ï¼š

å˜æ¢çš„æ˜¯ 2,3,4 è¿™ä¸‰ä¸ªç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å…ˆå–å‡º 2ï¼Œç”¨ front æŒ‡é’ˆæŒ‡å‘ 2ï¼Œç„¶åå½“å–å‡º 3 çš„æ—¶å€™ï¼Œæˆ‘ä»¬æŠŠ 3 åŠ åˆ° 2 çš„å‰é¢ï¼ŒæŠŠ front æŒ‡é’ˆå‰ç§»åˆ° 3ï¼Œä¾æ¬¡ç±»æ¨ï¼Œåˆ° 4 ååœæ­¢ï¼Œè¿™æ ·æˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªæ–°é“¾è¡¨ 4->3->2, front æŒ‡é’ˆæŒ‡å‘ 4ã€‚

å¯¹äºåŸé“¾è¡¨æ¥è¯´ï¼Œæœ‰ä¸¤ä¸ªç‚¹çš„ä½ç½®å¾ˆé‡è¦ï¼Œéœ€è¦ç”¨æŒ‡é’ˆè®°å½•ä¸‹æ¥ï¼Œåˆ†åˆ«æ˜¯ 1 å’Œ 5ï¼ŒæŠŠæ–°é“¾è¡¨æ’å…¥çš„æ—¶å€™éœ€è¦è¿™ä¸¤ä¸ªç‚¹çš„ä½ç½®ã€‚

ç”¨ pre æŒ‡é’ˆè®°å½• 1 çš„ä½ç½®

å½“ 4 ç»“ç‚¹è¢«å–èµ°åï¼Œ5 çš„ä½ç½®éœ€è¦è®°ä¸‹æ¥

è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æŠŠå€’ç½®åçš„é‚£ä¸€å°æ®µé“¾è¡¨åŠ å…¥åˆ°åŸé“¾è¡¨ä¸­

![92.reverse-linked-list-ii](../assets/92.reverse-linked-list-ii.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

#### å…³é”®ç‚¹è§£æ

- é“¾è¡¨çš„åŸºæœ¬æ“ä½œ(äº¤æ¢)
- è™šæ‹ŸèŠ‚ç‚¹ dummy ç®€åŒ–æ“ä½œ
- è€ƒè™‘ç‰¹æ®Šæƒ…å†µ m æ˜¯ 1 æˆ–è€… n æ˜¯é“¾è¡¨é•¿åº¦çš„æƒ…å†µ
- ç”¨å››ä¸ªå˜é‡è®°å½•ç‰¹æ®ŠèŠ‚ç‚¹ï¼Œ ç„¶åæ“ä½œè¿™å››ä¸ªèŠ‚ç‚¹ä½¿ä¹‹æŒ‰ç…§ä¸€å®šæ–¹å¼è¿æ¥å³å¯ã€‚

```js
let midStartNode = null;
let preMidStartNode = null;
let midEndNode = null;
let postMidEndNode = null;
```

- æ³¨æ„æ›´æ–° current å’Œ pre çš„ä½ç½®ï¼Œ å¦åˆ™æœ‰å¯èƒ½å‡ºç°æº¢å‡º

#### ä»£ç 

è¯­è¨€æ”¯æŒï¼šJS, C++

JavaScript Code:

```js
/*
 * @lc app=leetcode id=92 lang=javascript
 *
 * [92] Reverse Linked List II
 *
 * https://leetcode.com/problems/reverse-linked-list-ii/description/
 *
 * algorithms
 * Medium (34.13%)
 * Total Accepted:    182.3K
 * Total Submissions: 532.8K
 * Testcase Example:  '[1,2,3,4,5]\n2\n4'
 *
 * Reverse a linked list from position m to n. Do it in one-pass.
 *
 * Note:Â 1 â‰¤ m â‰¤ n â‰¤ length of list.
 *
 * Example:
 *
 *
 * Input: 1->2->3->4->5->NULL, m = 2, n = 4
 * Output: 1->4->3->2->5->NULL
 *
 *
 */

/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */
var reverseBetween = function(head, m, n) {
  // è™šæ‹ŸèŠ‚ç‚¹ï¼Œç®€åŒ–æ“ä½œ
  const dummyHead = {
    next: head,
  };

  let current = dummyHead.next; // å½“å‰éå†çš„èŠ‚ç‚¹
  let pre = current; // å› ä¸ºè¦åè½¬ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è®°ä½å‰ä¸€ä¸ªèŠ‚ç‚¹
  let index = 0; // é“¾è¡¨ç´¢å¼•ï¼Œç”¨æ¥åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šä½ç½®(å¤´å°¾ä½ç½®)

  // ä¸Šé¢æåˆ°çš„å››ä¸ªç‰¹æ®ŠèŠ‚ç‚¹
  let midStartNode = null;
  let preMidStartNode = null;
  let midEndNode = null;
  let postMidEndNode = null;

  while (current) {
    const next = current.next;
    index++;

    // å¯¹ (m - n) èŒƒå›´å†…çš„èŠ‚ç‚¹è¿›è¡Œåè½¬
    if (index > m && index <= n) {
      current.next = pre;
    }

    // ä¸‹é¢å››ä¸ªiféƒ½æ˜¯è¾¹ç•Œ, ç”¨äºæ›´æ–°å››ä¸ªç‰¹æ®ŠèŠ‚ç‚¹çš„å€¼
    if (index === m - 1) {
      preMidStartNode = current;
    }
    if (index === m) {
      midStartNode = current;
    }

    if (index === n + 1) {
      postMidEndNode = current;
    }

    if (index === n) {
      midEndNode = current;
    }

    pre = current;

    current = next;
  }

  // ä¸¤ä¸ªé“¾è¡¨åˆå¹¶èµ·æ¥
  (preMidStartNode || dummyHead).next = midEndNode; // ç‰¹æ®Šæƒ…å†µéœ€è¦è€ƒè™‘
  midStartNode.next = postMidEndNode;

  return dummyHead.next;
};
```

C++ Code:

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int s, int e) {
        if (s == e) return head;
        ListNode* prev = nullptr;
        auto cur = head;
        for (int i = 1; i < s; ++i) {
            prev = cur;
            cur = cur->next;
        }
        // æ­¤æ—¶å„æŒ‡é’ˆæŒ‡å‘ï¼š
        // x -> x -> x -> x  -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> x -> x -> x ->
        // ^head          ^prev ^cur
        ListNode* p = nullptr;
        auto c = cur;
        auto tail = c;
        ListNode* n = nullptr;
        for (int i = s; i <= e; ++i) {
            n = c->next;
            c->next = p;
            p = c;
            c = n;
        }
        // æ­¤æ—¶å„æŒ‡é’ˆæŒ‡å‘ï¼š
        // x -> x -> x -> x     8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 2 -> 1     x -> x -> x ->
        // ^head          ^prev ^p                                 ^cur  ^c
        //                                                         ^tail
        if (prev != nullptr) { // è‹¥æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆä¸ä¸ºç©ºï¼Œåˆ™è¯´æ˜såœ¨é“¾è¡¨ä¸­é—´(ä¸æ˜¯å¤´èŠ‚ç‚¹)
            prev->next = p;
            cur->next = c;
            return head;
        } else {
            if (tail != nullptr) tail->next = c;
            return p;
        }
    }
};
```

### [94].binary-tree-inorder-traversal

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/binary-tree-inorder-traversal/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, return the inorder traversal of its nodes' values. (ä¸­åºéå†)

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?
```

#### æ€è·¯

é€’å½’çš„æ–¹å¼ç›¸å¯¹ç®€å•ï¼Œéé€’å½’çš„æ–¹å¼å€ŸåŠ©æ ˆè¿™ç§æ•°æ®ç»“æ„å®ç°èµ·æ¥ä¼šç›¸å¯¹è½»æ¾ã€‚

å¦‚æœé‡‡ç”¨éé€’å½’ï¼Œå¯ä»¥ç”¨æ ˆ(Stack)çš„æ€è·¯æ¥å¤„ç†é—®é¢˜ã€‚

ä¸­åºéå†çš„é¡ºåºä¸ºå·¦-æ ¹-å³ï¼Œå…·ä½“ç®—æ³•ä¸ºï¼š

- ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå…ˆå°†æ ¹èŠ‚ç‚¹å‹å…¥æ ˆ

- ç„¶åå†å°†å…¶æ‰€æœ‰å·¦å­ç»“ç‚¹å‹å…¥æ ˆï¼Œå–å‡ºæ ˆé¡¶èŠ‚ç‚¹ï¼Œä¿å­˜èŠ‚ç‚¹å€¼

- å†å°†å½“å‰æŒ‡é’ˆç§»åˆ°å…¶å³å­èŠ‚ç‚¹ä¸Šï¼Œè‹¥å­˜åœ¨å³å­èŠ‚ç‚¹ï¼Œåˆ™åœ¨ä¸‹æ¬¡å¾ªç¯æ—¶åˆå¯å°†å…¶æ‰€æœ‰å·¦å­ç»“ç‚¹å‹å…¥æ ˆä¸­ï¼Œ é‡å¤ä¸Šæ­¥éª¤

![94.binary-tree-inorder-traversal](../assets/94.binary-tree-inorder-traversal.gif)

(å›¾ç‰‡æ¥è‡ªï¼š https://github.com/MisterBooo/LeetCodeAnimation)

#### å…³é”®ç‚¹è§£æ

- äºŒå‰æ ‘çš„åŸºæœ¬æ“ä½œ(éå†)
  > ä¸åŒçš„éå†ç®—æ³•å·®å¼‚è¿˜æ˜¯è›®å¤§çš„
- å¦‚æœéé€’å½’çš„è¯åˆ©ç”¨æ ˆæ¥ç®€åŒ–æ“ä½œ

- å¦‚æœæ•°æ®è§„æ¨¡ä¸å¤§çš„è¯ï¼Œå»ºè®®ä½¿ç”¨é€’å½’

- é€’å½’çš„é—®é¢˜éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼Œä¸€ä¸ªæ˜¯ç»ˆæ­¢æ¡ä»¶ï¼Œä¸€ä¸ªå¦‚ä½•ç¼©å°è§„æ¨¡

1. ç»ˆæ­¢æ¡ä»¶ï¼Œè‡ªç„¶æ˜¯å½“å‰è¿™ä¸ªå…ƒç´ æ˜¯ null(é“¾è¡¨ä¹Ÿæ˜¯ä¸€æ ·)

2. ç”±äºäºŒå‰æ ‘æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€’å½’ç»“æ„ï¼Œ æ¯æ¬¡å¤„ç†ä¸€ä¸ªå­æ ‘å…¶å®å°±æ˜¯ç¼©å°äº†è§„æ¨¡ï¼Œ
   éš¾ç‚¹åœ¨äºå¦‚ä½•åˆå¹¶ç»“æœï¼Œè¿™é‡Œçš„åˆå¹¶ç»“æœå…¶å®å°±æ˜¯`left.concat(mid).concat(right)`,
   mid æ˜¯ä¸€ä¸ªå…·ä½“çš„èŠ‚ç‚¹ï¼Œleft å’Œ right`é€’å½’æ±‚å‡ºå³å¯`

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=94 lang=javascript
 *
 * [94] Binary Tree Inorder Traversal
 *
 * https://leetcode.com/problems/binary-tree-inorder-traversal/description/
 *
 * algorithms
 * Medium (55.22%)
 * Total Accepted:    422.4K
 * Total Submissions: 762.1K
 * Testcase Example:  '[1,null,2,3]'
 *
 * Given a binary tree, return the inorder traversal of its nodes' values.
 *
 * Example:
 *
 *
 * Input: [1,null,2,3]
 * â   1
 * â    \
 * â     2
 * â    /
 * â   3
 *
 * Output: [1,3,2]
 *
 * Follow up: Recursive solution is trivial, could you do it iteratively?
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
  // 1. Recursive solution
  // if (!root) return [];
  // const left = root.left ? inorderTraversal(root.left) : [];
  // const right = root.right ? inorderTraversal(root.right) : [];
  // return left.concat([root.val]).concat(right);

  // 2. iterative solutuon
  if (!root) return [];
  const stack = [root];
  const ret = [];
  let left = root.left;

  let item = null; // stack ä¸­å¼¹å‡ºçš„å½“å‰é¡¹

  while (left) {
    stack.push(left);
    left = left.left;
  }

  while ((item = stack.pop())) {
    ret.push(item.val);
    let t = item.right;

    while (t) {
      stack.push(t);
      t = t.left;
    }
  }

  return ret;
};
```

### [98].validate-binary-search-tree

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/validate-binary-search-tree/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.


Example 1:

    2
   / \
  1   3

Input: [2,1,3]
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6

Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.


```

#### æ€è·¯

è¿™é“é¢˜æ˜¯è®©ä½ éªŒè¯ä¸€æ£µæ ‘æ˜¯å¦ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘(BST)ã€‚ ç”±äºä¸­åºéå†çš„æ€§è´¨`å¦‚æœä¸€ä¸ªæ ‘éå†çš„ç»“æœæ˜¯æœ‰åºæ•°ç»„ï¼Œé‚£ä¹ˆä»–ä¹Ÿæ˜¯ä¸€ä¸ªäºŒå‰æŸ¥æ‰¾æ ‘(BST)`,
æˆ‘ä»¬åªéœ€è¦ä¸­åºéå†ï¼Œç„¶åä¸¤ä¸¤åˆ¤æ–­æ˜¯å¦æœ‰é€†åºçš„å…ƒç´ å¯¹å³å¯ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ä¸æ˜¯ BSTï¼Œå¦åˆ™å³ä¸ºä¸€ä¸ª BSTã€‚

#### å…³é”®ç‚¹è§£æ

- äºŒå‰æ ‘çš„åŸºæœ¬æ“ä½œ(éå†)
- ä¸­åºéå†ä¸€ä¸ªäºŒå‰æŸ¥æ‰¾æ ‘(BST)çš„ç»“æœæ˜¯ä¸€ä¸ªæœ‰åºæ•°ç»„
- å¦‚æœä¸€ä¸ªæ ‘éå†çš„ç»“æœæ˜¯æœ‰åºæ•°ç»„ï¼Œé‚£ä¹ˆä»–ä¹Ÿæ˜¯ä¸€ä¸ªäºŒå‰æŸ¥æ‰¾æ ‘(BST)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=98 lang=javascript
 *
 * [98] Validate Binary Search Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  if (root === null) return true;
  if (root.left === null && root.right === null) return true;
  const stack = [root];
  let cur = root;
  let pre = null;

  function insertAllLefts(cur) {
    while (cur && cur.left) {
      const l = cur.left;
      stack.push(l);
      cur = l;
    }
  }
  insertAllLefts(cur);

  while ((cur = stack.pop())) {
    if (pre && cur.val <= pre.val) return false;
    const r = cur.right;

    if (r) {
      stack.push(r);
      insertAllLefts(r);
    }
    pre = cur;
  }

  return true;
};
```

#### ç›¸å…³é¢˜ç›®

[230.kth-smallest-element-in-a-bst](./230.kth-smallest-element-in-a-bst.md)

### [114].flatten-binary-tree-to-linked-list

```js
/*
 * @lc app=leetcode id=114 lang=javascript
 *
 * [114] Flatten Binary Tree to Linked List
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function preorderTraversal(root) {
  if (!root) return [];

  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = null;

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

### [4].median-of-two-sorted-arrays

```js
/*
 * @lc app=leetcode id=4 lang=javascript
 *
 * [4] Median of Two Sorted Arrays
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
function findKth(nums1, nums2, k) {
  if (nums1.length === 0) return nums2[k - 1];
  if (nums2.length === 0) return nums1[k - 1];
  if (k == 1) return Math.min(nums1[0], nums2[0]);
  let i = Math.min(k >> 1, nums1.length);
  let j = Math.min(k >> 1, nums2.length);
  if (nums1[i - 1] > nums2[j - 1]) {
    return findKth(nums1, nums2.slice(j), k - j);
  }

  return findKth(nums1.slice(i), nums2, k - i);
}
var findMedianSortedArrays = function(nums1, nums2) {
  // 1
  // 2 3 4 5
  const m = nums1.length,
    n = nums2.length;
  return (findKth(nums1, nums2, (m + n + 1) >> 1) + findKth(nums1, nums2, (m + n + 2) >> 1)) / 2.0;
};
```

### [594].longest-harmonious-subsequence

```js
/*
 * @lc app=leetcode id=594 lang=javascript
 *
 * [594] Longest Harmonious Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLHS = function(nums) {
  // Input: [1,3,2,2,5,2,3,7]
  // Output: 5
  // Explanation: The longest harmonious subsequence is [3,2,2,2,3].
  if (nums.length === 0) return 0;
  const counts = {};
  let res = 0;

  for (let i = 0; i < nums.length; i++) {
    if (!counts[nums[i]]) {
      counts[nums[i]] = 1;
    } else {
      counts[nums[i]] += 1;
    }
  }

  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i] + 1]) {
      res = Math.max(res, counts[nums[i]] + counts[nums[i] + 1]);
    }
  }

  return res;
};
```

### [647].palindromic-substrings

```js
/*
 * @lc app=leetcode id=647 lang=javascript
 *
 * [647] Palindromic Substrings
 */

function isPalindromic(s) {
  let start = 0;
  let end = s.length - 1;

  while (start < end && s[start] === s[end]) {
    start++;
    end--;
  }

  return start >= end;
}

/**
 *
 * @param {å¯¹ç§°ç‚¹1} i
 * @param {å¯¹ç§°ç‚¹2} j
 * @param {åŸå§‹å­—ç¬¦ä¸²} s
 * @return {ä»¥iï¼Œjä¸ºå¯¹ç§°ç‚¹çš„å­—ç¬¦ä¸²sæœ‰å¤šå°‘å›æ–‡ä¸²} count
 */
function extendPalindromic(i, j, s) {
  const n = s.length;
  let count = 0;
  let start = i;
  let end = j;
  while (s[start] === s[end] && start >= 0 && end < n) {
    start--;
    end++;
    count++;
  }

  return count;
}
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
  // "aaa"
  // "abc"
  // // æš´åŠ›æ³•ï¼Œç©ºé—´å¤æ‚åº¦O(1) æ—¶é—´å¤æ‚åº¦O(n^3)
  // let count = s.length;

  // for(let i = 0; i < s.length - 1; i++) {
  //     for(let j = i + 1; j < s.length; j++) {
  //         if (isPalindromic(s.substring(i, j + 1))) {
  //             count++;
  //         }
  //     }
  // }

  // return count;

  // ä¸­å¿ƒæ‰©å±•æ³•(è¿ç”¨å›æ–‡çš„å¯¹ç§°æ€§)
  // æ—¶é—´å¤æ‚åº¦O(n^2) ç©ºé—´å¤æ‚åº¦O(1)
  const n = s.length;
  let count = 0;

  for (let i = 0; i < n; i++) {
    // ä»¥ å­—ç¬¦s[i]ä¸ºå¯¹ç§°ç‚¹ï¼Œä¸€å…±æœ‰å¤šå°‘å›æ–‡å­—ä¸²
    count += extendPalindromic(i, i, s);
    // ä»¥ å­—ç¬¦s[i]å’Œs[i+1]ä¸ºå¯¹ç§°ç‚¹ï¼Œä¸€å…±æœ‰å¤šå°‘å›æ–‡å­—ä¸²
    count += extendPalindromic(i, i + 1, s);
  }

  return count;
};
```

### [687].longest-univalue-path

```js
/*
 * @lc app=leetcode id=687 lang=javascript
 *
 * [687] Longest Univalue Path
 */

// è¿”å›ç»è¿‡rootçš„ä¸”åªèƒ½å–å·¦å³ä¸€ä¸ªèŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦
function helper(node, res) {
  if (node === null) return 0;
  const l = helper(node.left, res);
  const r = helper(node.right, res);
  let lcnt = 0;
  let rcnt = 0;
  if (node.left && node.val === node.left.val) lcnt = lcnt + l + 1;
  if (node.right && node.val === node.right.val) rcnt = rcnt + r + 1;

  res.max = Math.max(res.max, lcnt + rcnt);

  return Math.max(lcnt, rcnt);
}
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function(root) {
  const res = {
    max: 0,
  };
  helper(root, res);
  return res.max;
};
```

### [739].daily-temperatures

```js
/*
 * @lc app=leetcode id=739 lang=javascript
 *
 * [739] Daily Temperatures
 */
/**
 * @param {number[]} T
 * @return {number[]}
 */
var dailyTemperatures = function(T) {
  // // æš´åŠ›  æ—¶é—´å¤æ‚åº¦O(n^2), ç©ºé—´å¤æ‚åº¦O(1)
  // const res = [];
  // for(let i = 0; i < T.length; i++) {
  //     res[i] = 0;
  //     for(let j = i; j < T.length; j++) {
  //         if (T[j] > T[i]) {
  //             res[i] = j - i;
  //             break;
  //         }
  //     }
  // }

  // return res;

  // é€’å¢æ ˆ/é€’å‡æ ˆ
  // è¿™é‡Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°é€’å‡æ ˆ
  // æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(n)
  // å…¸å‹çš„ç©ºé—´æ¢æ—¶é—´
  const stack = [];
  const res = [];

  for (let i = 0; i < T.length; i++) {
    res[i] = 0;
    while (stack.length !== 0 && T[i] > T[stack[stack.length - 1]]) {
      const peek = stack.pop();
      res[peek] = i - peek;
    }
    stack.push(i);
  }

  return res;
};
```

### [744].find-smallest-letter-greater-than-target

```js
/*
 * @lc app=leetcode id=744 lang=javascript
 *
 * [744] Find Smallest Letter Greater Than Target
 */
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
  let start = 0;
  let end = letters.length - 1;

  while (start < end) {
    const mid = start + ((end - start) >> 1);
    if (letters[mid] <= target) {
      start = mid + 1;
    } else {
      end = mid;
    }
  }
  // é¢˜ç›®è¦æ±‚æ‰¾ä¸åˆ°çš„æ—¶å€™ï¼Œå°±è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ (å¥½è¯¡å¼‚å•Š)
  return letters[end] > target ? letters[end] : letters[0];
};
```

### [950].reveal-cards-in-increasing-order

```js
/*
 * @lc app=leetcode id=950 lang=javascript
 *
 * [950] Reveal Cards In Increasing Order
 */
/**
 * @param {number[]} deck
 * @return {number[]}
 */
var deckRevealedIncreasing = function(deck) {
  const hand = [];
  const table = deck.sort((a, b) => a - b);

  let handTurn = true;
  while (table.length > 0) {
    if (handTurn) {
      hand.unshift(table.pop());
    } else {
      hand.unshift(hand.pop());
    }
    handTurn = !handTurn;
  }
  return hand;
};
```

### three-doors-problem

```js
// true ä»£è¡¨æ¢ä¹‹åèµ¢äº†
// false ä»£è¡¨æ¢äº†ä¹‹åè¾“äº†
function threeDoors() {
  const doors = [0, 0, 1];
  const random = Math.random() * doors.length;
  const pos = Math.floor(random);
  if (doors[pos]) return false;
  console.count(pos);
  return true;
}

const times = 1000000;
for (let i = 0; i < times; i++) {
  const win = threeDoors();
  console.count(win);
}
```

### [102].binary-tree-level-order-traversal

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/binary-tree-level-order-traversal/description/

#### é¢˜ç›®æè¿°

```
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

#### æ€è·¯

è¿™é“é¢˜å¯ä»¥å€ŸåŠ©`é˜Ÿåˆ—`å®ç°ï¼Œé¦–å…ˆæŠŠ root å…¥é˜Ÿï¼Œç„¶åå…¥é˜Ÿä¸€ä¸ªç‰¹æ®Šå…ƒç´  Null(æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸ)ã€‚

ç„¶åå°±æ˜¯ while(queue.length), æ¯æ¬¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å­èŠ‚ç‚¹(åœ¨è¿™é‡Œæ˜¯ left å’Œ right)æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚

ç„¶åä¸æ–­çš„å‡ºé˜Ÿï¼Œ å¦‚æœå‡ºé˜Ÿçš„æ˜¯ nullï¼Œåˆ™è¡¨å¼è¿™ä¸€å±‚å·²ç»ç»“æŸäº†ï¼Œæˆ‘ä»¬å°±ç»§ç»­ push ä¸€ä¸ª nullã€‚

å¦‚æœä¸å…¥é˜Ÿç‰¹æ®Šå…ƒç´  Null æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸï¼Œåˆ™åœ¨ while å¾ªç¯å¼€å§‹æ—¶ä¿å­˜å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ï¼Œä»¥ä¿è¯æ¯æ¬¡åªéå†ä¸€å±‚(å‚è€ƒä¸‹é¢çš„ C++ Code)ã€‚

> å¦‚æœé‡‡ç”¨é€’å½’æ–¹å¼ï¼Œåˆ™éœ€è¦å°†å½“å‰èŠ‚ç‚¹ï¼Œå½“å‰æ‰€åœ¨çš„ level ä»¥åŠç»“æœæ•°ç»„ä¼ é€’ç»™é€’å½’å‡½æ•°ã€‚åœ¨é€’å½’å‡½æ•°ä¸­ï¼Œå–å‡ºèŠ‚ç‚¹çš„å€¼ï¼Œæ·»åŠ åˆ° level å‚æ•°å¯¹åº”ç»“æœæ•°ç»„å…ƒç´ ä¸­(å‚è€ƒä¸‹é¢çš„ C++ Code)ã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

- æ³¨æ„å¡å…¥ null çš„æ—¶å€™ï¼Œåˆ¤æ–­ä¸€ä¸‹å½“å‰é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œä¸ç„¶ä¼šæ— é™å¾ªç¯

#### ä»£ç 

- è¯­è¨€æ”¯æŒï¼šJSï¼ŒC++

Javascript Code:

```js
/*
 * @lc app=leetcode id=102 lang=javascript
 *
 * [102] Binary Tree Level Order Traversal
 *
 * https://leetcode.com/problems/binary-tree-level-order-traversal/description/
 *
 * algorithms
 * Medium (47.18%)
 * Total Accepted:    346.4K
 * Total Submissions: 731.3K
 * Testcase Example:  '[3,9,20,null,null,15,7]'
 *
 * Given a binary tree, return the level order traversal of its nodes' values.
 * (ie, from left to right, level by level).
 *
 *
 * For example:
 * Given binary tree [3,9,20,null,null,15,7],
 *
 *
 * â    3
 * â   / \
 * â  9  20
 * â    /  \
 * â   15   7
 *
 *
 *
 * return its level order traversal as:
 *
 * [
 * â  [3],
 * â  [9,20],
 * â  [15,7]
 * ]
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  if (!root) return [];
  const items = []; // å­˜æ”¾æ‰€æœ‰èŠ‚ç‚¹
  const queue = [root, null]; // null ç®€åŒ–æ“ä½œ
  let levelNodes = []; // å­˜æ”¾æ¯ä¸€å±‚çš„èŠ‚ç‚¹

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      // ä¸€å±‚å·²ç»éå†å®Œäº†
      items.push(levelNodes);
      levelNodes = [];
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

C++ Code:

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

 // è¿­ä»£
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        auto ret = vector<vector<int>>();
        if (root == nullptr) return ret;
        auto q = vector<TreeNode*>();
        q.push_back(root);
        auto level = 0;
        while (!q.empty())
        {
            auto sz = q.size();
            ret.push_back(vector<int>());
            for (auto i = 0; i < sz; ++i)
            {
                auto t = q.front();
                q.erase(q.begin());
                ret[level].push_back(t->val);
                if (t->left != nullptr) q.push_back(t->left);
                if (t->right != nullptr) q.push_back(t->right);
            }
            ++level;
        }
        return ret;
    }
};

// é€’å½’
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> v;
        levelOrder(root, 0, v);
        return v;
    }
private:
    void levelOrder(TreeNode* root, int level, vector<vector<int>>& v) {
        if (root == NULL) return;
        if (v.size() < level + 1) v.resize(level + 1);
        v[level].push_back(root->val);
        levelOrder(root->left, level + 1, v);
        levelOrder(root->right, level + 1, v);
    }
};
```

#### ç›¸å…³é¢˜ç›®

- [103.binary-tree-zigzag-level-order-traversal](./103.binary-tree-zigzag-level-order-traversal.md)
- [104.maximum-depth-of-binary-tree](./104.maximum-depth-of-binary-tree.md)

### [103].binary-tree-zigzag-level-order-traversal

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/

#### é¢˜ç›®æè¿°

å’Œ leetcode 102 åŸºæœ¬æ˜¯ä¸€æ ·çš„ï¼Œæ€è·¯æ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚

```
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```

#### æ€è·¯

è¿™é“é¢˜å¯ä»¥å€ŸåŠ©`é˜Ÿåˆ—`å®ç°ï¼Œé¦–å…ˆæŠŠ root å…¥é˜Ÿï¼Œç„¶åå…¥é˜Ÿä¸€ä¸ªç‰¹æ®Šå…ƒç´  Null(æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸ)ã€‚

ç„¶åå°±æ˜¯ while(queue.length), æ¯æ¬¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å­èŠ‚ç‚¹(åœ¨è¿™é‡Œæ˜¯ left å’Œ right)æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚

ç„¶åä¸æ–­çš„å‡ºé˜Ÿï¼Œ å¦‚æœå‡ºé˜Ÿçš„æ˜¯ nullï¼Œåˆ™è¡¨å¼è¿™ä¸€å±‚å·²ç»ç»“æŸäº†ï¼Œæˆ‘ä»¬å°±ç»§ç»­ push ä¸€ä¸ª nullã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

#### ä»£ç 

```js
/*
 * @lc app=leetcode id=103 lang=javascript
 *
 * [103] Binary Tree Zigzag Level Order Traversal
 *
 * https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/
 *
 * algorithms
 * Medium (40.57%)
 * Total Accepted:    201.2K
 * Total Submissions: 493.7K
 * Testcase Example:  '[3,9,20,null,null,15,7]'
 *
 * Given a binary tree, return the zigzag level order traversal of its nodes'
 * values. (ie, from left to right, then right to left for the next level and
 * alternate between).
 *
 *
 * For example:
 * Given binary tree [3,9,20,null,null,15,7],
 *
 * â    3
 * â   / \
 * â  9  20
 * â    /  \
 * â   15   7
 *
 *
 *
 * return its zigzag level order traversal as:
 *
 * [
 * â  [3],
 * â  [20,9],
 * â  [15,7]
 * ]
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  if (!root) return [];
  const items = [];
  let isOdd = true;
  let levelNodes = [];

  const queue = [root, null];

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      if (!isOdd) {
        levelNodes = levelNodes.reverse();
      }
      items.push(levelNodes);
      levelNodes = [];
      isOdd = !isOdd;
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

#### ç›¸å…³é¢˜ç›®

- [102.binary-tree-level-order-traversal](./102.binary-tree-level-order-traversal.md)
- [104.maximum-depth-of-binary-tree](./104.maximum-depth-of-binary-tree.md)

### [1031].maximum-sum-of-two-non-overlapping-subarrays

#### é¢˜ç›®åœ°å€

https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/

#### é¢˜ç›®æè¿°

```
Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M.  (For clarification, the L-length subarray could occur before or after the M-length subarray.)

Formally, return the largest V for which V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:

0 <= i < i + L - 1 < j < j + M - 1 < A.length, or
0 <= j < j + M - 1 < i < i + L - 1 < A.length.


Example 1:

Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.
Example 2:

Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
Output: 29
Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.
Example 3:

Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3
Output: 31
Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.


Note:

L >= 1
M >= 1
L + M <= A.length <= 1000
0 <= A[i] <= 1000
```

#### æ€è·¯(åŠ¨æ€è§„åˆ’)

é¢˜ç›®ä¸­è¦æ±‚åœ¨å‰ N(æ•°ç»„é•¿åº¦)ä¸ªæ•°ä¸­æ‰¾å‡ºé•¿åº¦åˆ†åˆ«ä¸º L å’Œ M çš„éé‡å å­æ•°ç»„ä¹‹å’Œçš„æœ€å¤§å€¼, å› æ­¤, æˆ‘ä»¬å¯ä»¥å®šä¹‰æ•°ç»„ A ä¸­å‰ i ä¸ªæ•°å¯æ„æˆçš„éé‡å å­æ•°ç»„ L å’Œ M çš„æœ€å¤§å€¼ä¸º SUMM[i], å¹¶æ‰¾åˆ° SUMM[i]å’Œ SUMM[i-1]çš„å…³ç³», é‚£ä¹ˆæœ€ç»ˆè§£å°±æ˜¯ SUMM[N]. ä»¥ä¸‹ä¸ºå›¾è§£:

![1031.Maximum Sum of Two Non-Overlapping Subarrays](../assets/problems/1031.maximum-sum-of-two-non-overlapping-subarrays.png)

#### å…³é”®ç‚¹è§£æ

1. æ³¨æ„å›¾ä¸­æè¿°çš„éƒ½æ˜¯ A[i-1], è€Œä¸æ˜¯ A[i], å› ä¸º base case ä¸ºç©ºæ•°ç»„, è€Œä¸æ˜¯ A[0];
2. æ±‚è§£å›¾ä¸­ ASUM æ•°ç»„çš„æ—¶å€™, æ³¨æ„å®šä¹‰çš„æ˜¯ ASUM[i] = sum(A[0:i]), å› æ­¤å½“ i ç­‰äº 0 æ—¶, A[0:0]ä¸ºç©ºæ•°ç»„, å³: ASUM[0]ä¸º 0, è€Œ ASUM[1]æ‰ç­‰äº A[0];
3. æ±‚è§£å›¾ä¸­ MAXL æ•°ç»„æ—¶, æ³¨æ„ i < L æ—¶, æ²¡æœ‰æ„ä¹‰, å› ä¸ºé•¿åº¦ä¸å¤Ÿ, æ‰€ä»¥ä» i = L æ—¶æ‰å¼€å§‹æ±‚è§£;
4. æ±‚è§£å›¾ä¸­ MAXM æ•°ç»„æ—¶, ä¹Ÿä¸€æ ·, è¦ä» i = M æ—¶æ‰å¼€å§‹æ±‚è§£;
5. æ±‚è§£å›¾ä¸­ SUMM æ•°ç»„æ—¶, å› ä¸ºæˆ‘ä»¬éœ€è¦ä¸€ä¸ª L å­æ•°ç»„å’Œä¸€ä¸ª M å­æ•°ç»„, å› æ­¤é•¿åº¦è¦å¤§äºç­‰äº L+M æ‰æœ‰æ„ä¹‰, æ‰€ä»¥è¦ä» i = L + M æ—¶å¼€å§‹æ±‚è§£.

#### ä»£ç 

- è¯­è¨€æ”¯æŒ: Python

Python Code:

```python
class Solution:
    def maxSumTwoNoOverlap(self, a: List[int], l: int, m: int) -> int:
        """

        define asum[i] as the sum of subarray, a[0:i]
        define maxl[i] as the maximum sum of l-length subarray in a[0:i]
        define maxm[i] as the maximum sum of m-length subarray in a[0:i]
        define msum[i] as the maximum sum of non-overlap l-length subarray and m-length subarray

        case 1: a[i] is both not in l-length subarray and m-length subarray, then msum[i] = msum[i - 1]
        case 2: a[i] is in l-length subarray, then msum[i] = asum[i] - asum[i-l] + maxm[i-l]
        case 3: a[i] is in m-length subarray, then msum[i] = asum[i] - asum[i-m] + maxl[i-m]

        so, msum[i] = max(msum[i - 1], asum[i] - asum[i-l] + maxl[i-l], asum[i] - asum[i-m] + maxm[i-m])
        """

        alen, tlen = len(a), l + m
        asum = [0] * (alen + 1)
        maxl = [0] * (alen + 1)
        maxm = [0] * (alen + 1)
        msum = [0] * (alen + 1)

        for i in range(tlen):
            if i == 1:
                asum[i] = a[i - 1]
            elif i > 1:
                asum[i] = asum[i - 1] + a[i - 1]
            if i >= l:
                maxl[i] = max(maxl[i - 1], asum[i] - asum[i - l])
            if i >= m:
                maxm[i] = max(maxm[i - 1], asum[i] - asum[i - m])

        for i in range(tlen, alen + 1):
            asum[i] = asum[i - 1] + a[i - 1]
            suml = asum[i] - asum[i - l]
            summ = asum[i] - asum[i - m]
            maxl[i] = max(maxl[i - 1], suml)
            maxm[i] = max(maxm[i - 1], summ)
            msum[i] = max(msum[i - 1], suml + maxm[i - l], summ + maxl[i - m])

        return msum[-1]
```

#### æ‰©å±•

1. ä»£ç ä¸­, æ±‚è§£äº† 4 ä¸ªåŠ¨æ€è§„åˆ’æ•°ç»„æ¥æ±‚è§£æœ€ç»ˆå€¼, æœ‰æ²¡æœ‰å¯èƒ½åªç”¨ä¸¤ä¸ªæ•°ç»„æ¥æ±‚è§£è¯¥é¢˜, å¯ä»¥çš„è¯, éœ€è¦ä¿ç•™çš„åˆæ˜¯å“ªä¸¤ä¸ªæ•°ç»„?
2. ä»£ç ä¸­, æ±‚è§£çš„ 4 åŠ¨æ€è§„åˆ’æ•°ç»„çš„é¡ºåºèƒ½å¦æ”¹å˜, å“ªäº›èƒ½æ”¹, å“ªäº›ä¸èƒ½æ”¹?
