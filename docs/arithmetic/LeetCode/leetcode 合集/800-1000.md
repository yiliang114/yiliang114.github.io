---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### 832

```js
// 832. Flipping an Image

// Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.

// To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].

// To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].

/**
 * @param {number[][]} A
 * @return {number[][]}
 */
export default function flipAndInvertImage(A) {
  // Take the transpose of the matrix
  for (let i = 0; i < A.length; i++) {
    // Flip each row
    for (let j = 0; j < Math.floor(A[i].length / 2); j++) {
      const a = A[i][j];
      const b = A[i][A[i].length - 1 - j];
      A[i][j] = b === 0 ? 1 : 0;
      A[i][A[i].length - 1 - j] = a === 0 ? 1 : 0;
    }
    if (A[i].length % 2 !== 0) {
      A[i][Math.floor(A[i].length / 2)] = A[i][Math.floor(A[i].length / 2)] === 0 ? 1 : 0;
    }
  }
  return A;
}
```

### 876

```js
// This solution uses the 'runner method' mentioned in CTCI

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function middleNode(head) {
  if (!head) return null;
  let next = head;
  let nextNext = head;

  while (next.next && nextNext && nextNext.next && nextNext.next.next) {
    next = next.next;
    nextNext = nextNext.next.next;
  }

  if (nextNext.next) {
    return next.next;
  }

  return next;
}
```

### 905.按奇偶排序数组

```js
/*
 * @lc app=leetcode.cn id=905 lang=javascript
 *
 * [905] 按奇偶排序数组
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParity = function(nums) {
  // 好像不关排序的事情。。。。
  const result = [];
  let length = nums.length,
    start = 0,
    end = length - 1;
  for (let i = 0; i < length; i++) {
    if (nums[i] % 2 === 0) {
      result[start] = nums[i];
      start++;
    } else {
      result[end] = nums[i];
      end--;
    }
  }
  return result;
};

console.log(sortArrayByParity([4, 2, 5, 7]));
console.log(sortArrayByParity([3, 1, 2, 4]));
```

### 912.排序数组

```js
/*
 * @lc app=leetcode.cn id=912 lang=javascript
 *
 * [912] 排序数组
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
  if (nums.length < 2) return nums;
  return quickSort(nums);
};

const quickSort = (arr, start = 0, end = arr.length - 1) => {
  if (start >= end) return;
  let i = start,
    j = end,
    target = arr[start];

  while (i < j) {
    while (i < j && arr[j] >= target) j--;
    while (i < j && arr[i] <= target) i++;

    if (i < j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[start], arr[j]] = [arr[j], arr[start]];
  quickSort(arr, start, i - 1);
  quickSort(arr, i + 1, end);

  return arr;
};

console.log(sortArray([5, 2, 3, 1]));
console.log(sortArray([5, 1, 1, 2, 0, 0]));
```

### 914.卡牌分组

```js
/*
 * @lc app=leetcode.cn id=914 lang=javascript
 *
 * [914] 卡牌分组
 */
/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
  // 统计数字个数
  const numMap = {};
  for (let i = 0; i < deck.length; i++) {
    if (!numMap[deck[i]]) {
      numMap[deck[i]] = 1;
    } else {
      numMap[deck[i]]++;
    }
  }
  const valuesArr = Object.values(numMap).sort((a, b) => (a > b ? 1 : -1));
  // console.log('valuesArr', valuesArr)
  // 也就是说最大公约数得大于 1
  return !valuesArr.find(value => gcd(value, valuesArr[0]) === 1 || value < 2);
};

// 欧里几德算法，辗转相除法。
function gcd(a, b) {
  if (b == 0) {
    return a;
  }
  var r = parseInt(a % b);
  return gcd(b, r);
}

console.log(hasGroupsSizeX([1, 2, 3, 4, 4, 3, 2, 1]));
console.log(hasGroupsSizeX([1, 1, 1, 2, 2, 2, 3, 3]));
console.log(hasGroupsSizeX([1]));
console.log(hasGroupsSizeX([1, 1]));
console.log(hasGroupsSizeX([1, 1, 2, 2, 2, 2]));
console.log(hasGroupsSizeX([1, 1, 1, 1, 2, 2, 2, 2, 2, 2]));
```

### 917.仅仅反转字母

```js
/*
 * @lc app=leetcode.cn id=917 lang=javascript
 *
 * [917] 仅仅反转字母
 *
 * 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。



示例 1：

输入："ab-cd"
输出："dc-ba"
示例 2：

输入："a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
示例 3：

输入："Test1ng-Leet=code-Q!"
输出："Qedo1ct-eeLg=ntse-T!"


提示：

S.length <= 100
33 <= S[i].ASCIIcode <= 122
S 中不包含 \ or "
 */
/**
 * @param {string} S
 * @return {string}
 */
var reverseOnlyLetters = function(S) {
  S = S.split('');
  let left = 0,
    right = S.length - 1,
    temp;
  const reg = /[a-zA-Z]/;
  while (left < right) {
    while (!reg.test(S[left])) left++;
    while (!reg.test(S[right])) right--;
    if (left < right) {
      [S[left], S[right]] = [S[right], S[left]];
      left++;
      right--;
    }
  }
  return S.join('');
};

// console.log(reverseOnlyLetters('ab-cd'))
// console.log(reverseOnlyLetters('ab'))
console.log(reverseOnlyLetters('a-bC-dEf-ghIj'));
// console.log(reverseOnlyLetters('Test1ng-Leet=code-Q!'))
// console.log(reverseOnlyLetters(''))
```

### 922.按奇偶排序数组-ii

```js
/*
 * @lc app=leetcode.cn id=922 lang=javascript
 *
 * [922] 按奇偶排序数组 II
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParityII = function(nums) {
  // 好像不关排序的事情。。。。
  const result = [];
  let even = 0,
    odd = 1;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 === 0) {
      result[even] = nums[i];
      even += 2;
    } else {
      result[odd] = nums[i];
      odd += 2;
    }
  }
  return result;
};

console.log(sortArrayByParityII([4, 2, 5, 7]));
```

### 958.check-completeness-of-a-binary-tree

```js
/*
 * @lc app=leetcode id=958 lang=javascript
 *
 * [958] Check Completeness of a Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isCompleteTree = function(root) {
  if (root === null) return root;
  let cur = root;
  const queue = [];

  while (cur !== null) {
    queue.push(cur.left);
    queue.push(cur.right);
    cur = queue.shift();
  }

  return queue.filter(Boolean).length === 0;
};
```

### 977.有序数组的平方

```js
/*
 * @lc app=leetcode.cn id=977 lang=javascript
 *
 * [977] 有序数组的平方
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */

// 使用双指针，一个用来移动负数， 一个用来移动正数
var sortedSquares = function(A) {
  let i = 0;
  while (i < A.length && A[i] < 0) {
    i++;
  }
  let j = i--,
    resp = [];
  while (i >= 0 && j < A.length) {
    if (Math.abs(A[i]) < Math.abs(A[j])) {
      resp.push(A[i] * A[i]);
      i--;
    } else {
      resp.push(A[j] * A[j]);
      j++;
    }
  }
  while (i >= 0) {
    resp.push(A[i] * A[i]);
    i--;
  }
  while (j < A.length) {
    resp.push(A[j] * A[j]);
    j++;
  }
  return resp;
};

// console.log(sortedSquares([-4, -1, 0, 3, 10]))
// console.log(sortedSquares([-1
```
