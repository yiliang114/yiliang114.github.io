---
layout: CustomPages
title: 每日一题
date: 2020-11-21
aside: false
draft: true
---

# SF/azl397985856-leetcode/backlog/112.path-sum

```js
/*
 * @lc app=leetcode id=112 lang=javascript
 *
 * [112] Path Sum
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
  // check
  if (root === null) return false;
  //  if it's leaf:
  if (root.left === null && root.right === null) {
    return root.val === sum;
  }
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
```

# SF/azl397985856-leetcode/backlog/137.single-number-ii

```js
/*
 * @lc app=leetcode id=137 lang=javascript
 *
 * [137] Single Number II
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  // [1,1,1,2]
  let res = 0;
  // 前提是nums中数字都不大于2^31
  for (let i = 0; i < 32; i++) {
    let cnt = 0;
    let bit = 1 << i;
    for (let j = 0; j < nums.length; j++) {
      if (nums[j] & bit) cnt++;
    }
    if (cnt % 3 != 0) res = res | bit;
  }
  return res;
};
```

# SF/azl397985856-leetcode/backlog/141.linked-list-cycle

```js
/*
 * @lc app=leetcode id=141 lang=javascript
 *
 * [141] Linked List Cycle
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

# SF/azl397985856-leetcode/backlog/160.intersection-of-two-linked-lists

```js
/*
 * @lc app=leetcode id=160 lang=javascript
 *
 * [160] Intersection of Two Linked Lists
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // 网上精妙的解法没看懂
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

# SF/azl397985856-leetcode/backlog/189.rotate-array

```js
/*
 * @lc app=leetcode id=189 lang=javascript
 *
 * [189] Rotate Array
 *
 * https://leetcode.com/problems/rotate-array/description/
 *
 * algorithms
 * Easy (29.07%)
 * Total Accepted:    287.3K
 * Total Submissions: 966.9K
 * Testcase Example:  '[1,2,3,4,5,6,7]\n3'
 *
 * Given an array, rotate the array to the right by k steps, where k is
 * non-negative.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,4,5,6,7] and k = 3
 * Output: [5,6,7,1,2,3,4]
 * Explanation:
 * rotate 1 steps to the right: [7,1,2,3,4,5,6]
 * rotate 2 steps to the right: [6,7,1,2,3,4,5]
 * rotate 3 steps to the right: [5,6,7,1,2,3,4]
 *
 *
 * Example 2:
 *
 *
 * Input: [-1,-100,3,99] and k = 2
 * Output: [3,99,-1,-100]
 * Explanation:
 * rotate 1 steps to the right: [99,-1,-100,3]
 * rotate 2 steps to the right: [3,99,-1,-100]
 *
 *
 * Note:
 *
 *
 * Try to come up as many solutions as you can, there are at least 3 different
 * ways to solve this problem.
 * Could you do it in-place with O(1) extra space?
 *
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  // 就像扩容一样操作
  k = k % nums.length;
  const n = nums.length;

  for (let i = nums.length - 1; i >= 0; i--) {
    nums[i + k] = nums[i];
  }

  for (let i = 0; i < k; i++) {
    nums[i] = nums[n + i];
  }
  nums.length = n;
};
```

# SF/azl397985856-leetcode/backlog/202.happy-number

```js
/*
 * @lc app=leetcode id=202 lang=javascript
 *
 * [202] Happy Number
 *
 * https://leetcode.com/problems/happy-number/description/
 *
 * algorithms
 * Easy (44.36%)
 * Total Accepted:    227.2K
 * Total Submissions: 505.7K
 * Testcase Example:  '19'
 *
 * Write an algorithm to determine if a number is "happy".
 *
 * A happy number is a number defined by the following process: Starting with
 * any positive integer, replace the number by the sum of the squares of its
 * digits, and repeat the process until the number equals 1 (where it will
 * stay), or it loops endlessly in a cycle which does not include 1. Those
 * numbers for which this process ends in 1 are happy numbers.
 *
 * Example:
 *
 *
 * Input: 19
 * Output: true
 * Explanation:
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */
function squareSum(n) {
  let sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

function isHappyWithMapper(n, visited) {
  if (n === 1) return true;
  if (visited[n]) return false;
  visited[n] = true;

  return isHappyWithMapper(squareSum(n), visited);
}
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  const visited = {};

  return isHappyWithMapper(n, visited);
};
```

# SF/azl397985856-leetcode/backlog/204.count-primes

```js
/*
 * @lc app=leetcode id=204 lang=javascript
 *
 * [204] Count Primes
 *
 * https://leetcode.com/problems/count-primes/description/
 *
 * algorithms
 * Easy (28.33%)
 * Total Accepted:    229.8K
 * Total Submissions: 798.7K
 * Testcase Example:  '10'
 *
 * Count the number of prime numbers less than a non-negative number, n.
 *
 * Example:
 *
 *
 * Input: 10
 * Output: 4
 * Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
 *
 *
 */
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  // tag: 数论
  // if (n <= 2) return 0;
  // let compositionCount = 0;
  // for(let i = 3; i < n; i++) {
  //     for(let j = i - 1; j > 1 ; j--) {
  //         if (i % j === 0) {
  //             compositionCount++;
  //             break; // 找到一个就可以证明它不是质数了
  //         }
  //     }
  // }
  // return n - compositionCount - 2; // 需要减去1和n这两个数字

  // 上面的方法会超时，因此我们需要进行优化
  // 数学角度来看，如果一个数字可以分解为两个数字相乘(这两个数字不包括0和它本身)，那么它就是合数
  const compositions = []; // compositions[i] 表示i是否是合数
  let count = 0;
  for (let i = 2; i < n; i++) {
    if (!compositions[i]) count++;
    for (let j = 2; i * j < n; j++) {
      compositions[i * j] = true;
    }
  }

  return count;
};
```

# SF/azl397985856-leetcode/backlog/21.merge-two-sorted-lists

```js
/*
 * @lc app=leetcode id=21 lang=javascript
 *
 * [21] Merge Two Sorted Lists
 *
 * https://leetcode.com/problems/merge-two-sorted-lists/description/
 *
 * algorithms
 * Easy (46.02%)
 * Total Accepted:    562.7K
 * Total Submissions: 1.2M
 * Testcase Example:  '[1,2,4]\n[1,3,4]'
 *
 * Merge two sorted linked lists and return it as a new list. The new list
 * should be made by splicing together the nodes of the first two lists.
 *
 * Example:
 *
 * Input: 1->2->4, 1->3->4
 * Output: 1->1->2->3->4->4
 *
 *
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;

  //   if (l1 === null) return l2;
  //   if (l2 === null) return l1;
  //   if (l1.val < l2.val) {
  //     l1.next = mergeTwoLists(l1.next, l2);
  //     return l1;
  //   } else {
  //     l2.next = mergeTwoLists(l1, l2.next);
  //     return l2;
  //   }
};
```

# SF/azl397985856-leetcode/backlog/217.contains-duplicate

```js
/*
 * @lc app=leetcode id=217 lang=javascript
 *
 * [217] Contains Duplicate
 *
 * https://leetcode.com/problems/contains-duplicate/description/
 *
 * algorithms
 * Easy (50.92%)
 * Total Accepted:    324K
 * Total Submissions: 628.5K
 * Testcase Example:  '[1,2,3,1]'
 *
 * Given an array of integers, find if the array contains any duplicates.
 *
 * Your function should return true if any value appears at least twice in the
 * array, and it should return false if every element is distinct.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,1]
 * Output: true
 *
 * Example 2:
 *
 *
 * Input: [1,2,3,4]
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: [1,1,1,3,3,4,3,2,4,2]
 * Output: true
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  // 1. 暴力两层循环两两比较， 时间复杂度O(n^2) 空间复杂度O(1)

  // 2. 先排序，之后比较前后元素是否一致即可，一层循环即可，如果排序使用的比较排序的话时间复杂度O(nlogn) 空间复杂度O(1)

  // 3. 用hashmap ，时间复杂度O(n) 空间复杂度O(n)
  const visited = {};
  for (let i = 0; i < nums.length; i++) {
    if (visited[nums[i]]) return true;
    visited[nums[i]] = true;
  }
  return false;
};
```

# SF/azl397985856-leetcode/backlog/278.first-bad-version

```js
/*
 * @lc app=leetcode id=278 lang=javascript
 *
 * [278] First Bad Version
 */
/**
 * Definition for isBadVersion()
 *
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function(isBadVersion) {
  /**
   * @param {integer} n Total versions
   * @return {integer} The first bad version
   */
  return function(n) {
    let start = 0;
    let end = n;
    while (start <= end) {
      if (start === end) return start;
      const mid = start + ((end - start) >> 1);
      if (isBadVersion(mid)) {
        end = mid;
      } else {
        start = mid + 1;
      }
    }
  };
};
```

# SF/azl397985856-leetcode/backlog/287.find-the-duplicate-number

```js
/*
 * @lc app=leetcode id=287 lang=javascript
 *
 * [287] Find the Duplicate Number
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // Input: [1,3,4,2,2]
  // Output: 2
  nums.sort();

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) return nums[i];
  }
};
```

# SF/azl397985856-leetcode/backlog/300.longest-increasing-subsequence

```js
/*
 * @lc app=leetcode id=300 lang=javascript
 *
 * [300] Longest Increasing Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  // 时间复杂度O(n^2)
  // if (nums.length === 0) return 0;
  //   const dp = Array(nums.length).fill(1);
  //   let max = 1;
  //   for (let i = 0; i < nums.length; i++) {
  //     for (let j = 0; j < i; j++) {
  //       if (nums[i] > nums[j]) {
  //         dp[i] = Math.max(dp[j] + 1, dp[i]);
  //       }
  //       max = Math.max(max, dp[i]);
  //     }
  //   }
  //   return max;
  // [ 10, 9, 2, 5, 3, 7, 101, 18 ]
  // [ 2, 3, 5, 7, 9, 10, 18, 101 ]
  // 参考： https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation
  // const tails = [];
  // for (let i = 0; i < nums.length; i++) {
  //   let left = 0;
  //   let right = tails.length;
  //   while (left < right) {
  //     const mid = left + (right - left) / 2; // 防止溢出
  //     if (tails[mid] < nums[i]) left = mid + 1;
  //     else right = mid;
  //   }
  //   // 说明nums[i] 比如tails中所有数字都大，我们直接push
  //   if (right === tails.length) tails.push(nums[i]);
  //   else tails[right] = nums[i]; // 否则我们修改tails[right]
  // }
  // return tails.length;
};
```

# SF/azl397985856-leetcode/backlog/307.range-sum-query-mutable

```js
/*
 * @lc app=leetcode id=307 lang=javascript
 *
 * [307] Range Sum Query - Mutable
 */
/**
 * @param {number[]} nums
 */
// var NumArray = function(nums) {
//   this.nums = nums;
// };

// /**
//  * @param {number} i
//  * @param {number} val
//  * @return {void}
//  */
// NumArray.prototype.update = function(i, val) {
//   this.nums[i] = val;
// };

// /**
//  * @param {number} i
//  * @param {number} j
//  * @return {number}
//  */
// NumArray.prototype.sumRange = function(i, j) {
//   let res = 0;
//   for (let k = i; k < j + 1; k++) {
//     res += this.nums[k];
//   }

//   return res;
// };

/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  this.nums = nums;

  // Init array representation of segment tree.
  this.segmentTree = [];

  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;
  this.buildTreeRecursively(l, r, cur);
};

NumArray.prototype.buildTreeRecursively = function(l, r, cur) {
  // If low input index and high input index are equal that would mean
  // the we have finished splitting and we are already came to the leaf
  // of the segment tree. We need to copy this leaf value from input
  // array to segment tree.
  if (l === r) {
    return (this.segmentTree[cur] = this.nums[r]);
  }

  // Split input array on two halves and process them recursively.
  const m = Math.floor((l + r) / 2);
  // Process left half of the input array.
  this.buildTreeRecursively(l, m, this.getLeftChildIndex(cur));
  // Process right half of the input array.
  this.buildTreeRecursively(m + 1, r, this.getRightChildIndex(cur));

  // Once every tree leaf is not empty we're able to build tree bottom up using
  // provided operation function.
  this.segmentTree[cur] = this.operation(
    this.segmentTree[this.getLeftChildIndex(cur)],
    this.segmentTree[this.getRightChildIndex(cur)],
  );
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
  this.nums[i] = val;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;

  return this.rangeQueryRecursive(i, j, l, r, cur);
};

NumArray.prototype.rangeQueryRecursive = function(i, j, l, r, cur) {
  if (i <= l && j >= r) {
    // Total overlap.
    return this.segmentTree[cur];
  }

  if (i > r || j < l) {
    // No overlap.
    return this.operationFallback;
  }

  // Partial overlap.
  const m = Math.floor((l + r) / 2);

  const leftOperationResult = this.rangeQueryRecursive(i, j, l, m, this.getLeftChildIndex(cur));

  const rightOperationResult = this.rangeQueryRecursive(i, j, m + 1, r, this.getRightChildIndex(cur));

  return this.sumRange(leftOperationResult, rightOperationResult);
};

NumArray.prototype.getLeftChildIndex = function(parentIndex) {
  return 2 * parentIndex + 1;
};

NumArray.prototype.getRightChildIndex = function(parentIndex) {
  return 2 * parentIndex + 2;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(i,val)
 * var param_2 = obj.sumRange(i,j)
 */
```

# SF/azl397985856-leetcode/backlog/315.count-of-smaller-numbers-after-self

```js
/*
 * @lc app=leetcode id=315 lang=javascript
 *
 * [315] Count of Smaller Numbers After Self
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
  // Input: [5,2,6,1]
  // Output: [2,1,1,0]
  // 暴力法：
  //   const res = Array(nums.length).fill(0);
  //   for (let i = 0; i < nums.length - 1; i++) {
  //     for (let j = i; j < nums.length; j++) {
  //       if (nums[i] > nums[j]) {
  //         res[i] += 1;
  //       }
  //     }
  //   }

  //   return res;
  //  归并排序
  const res = Array(nums.length).fill(0);

  function merge(arr, l, m, r, res) {
    let i, j, k;
    const n1 = m - l + 1;
    const n2 = r - m;

    /* create temp arrays */
    const L = Array(n1);
    const R = Array(n2);

    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) L[i] = arr[l + i];
    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
    while (i < n1 && j < n2) {
      if (L[i] <= R[j]) {
        arr[k] = L[i];
        i++;
      } else {
        arr[k] = R[j];
        res[k] += 1;
        j++;
      }
      k++;
    }

    /* Copy the remaining elements of L[], if there
       are any */
    while (i < n1) {
      arr[k] = L[i];
      i++;
      k++;
    }

    /* Copy the remaining elements of R[], if there
       are any */
    while (j < n2) {
      arr[k] = R[j];
      j++;
      k++;
    }
  }
  function mergeSort(arr, l, r, res) {
    if (l < r) {
      const m = l + ((r - l) >> 1);

      mergeSort(arr, l, m, res);
      mergeSort(arr, m + 1, r, res);

      merge(arr, l, m, r, res);
    }
    return res;
  }

  return mergeSort(nums, 0, nums.length - 1, res);
};
```

# SF/azl397985856-leetcode/backlog/326.power-of-three

```js
/*
 * @lc app=leetcode id=326 lang=javascript
 *
 * [326] Power of Three
 *
 * https://leetcode.com/problems/power-of-three/description/
 *
 * algorithms
 * Easy (41.43%)
 * Total Accepted:    178.8K
 * Total Submissions: 430.4K
 * Testcase Example:  '27'
 *
 * Given an integer, write a function to determine if it is a power of three.
 *
 * Example 1:
 *
 *
 * Input: 27
 * Output: true
 *
 *
 * Example 2:
 *
 *
 * Input: 0
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: 9
 * Output: true
 *
 * Example 4:
 *
 *
 * Input: 45
 * Output: false
 *
 * Follow up:
 * Could you do it without using any loop / recursion?
 */
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  // tag: 数论
  // let i = 0;
  // while(Math.pow(3, i) < n) {
  //     i++;
  // }
  // return Math.pow(3, i) === n;

  // 巧用整除
  return n > 0 && Math.pow(3, 19) % n === 0;
};
// 扩展： 这个方法可以扩展到任意质数，合数则不行
```

# SF/azl397985856-leetcode/backlog/337.house-robber-iii

```js
/*
 * @lc app=leetcode id=337 lang=javascript
 *
 * [337] House Robber III
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(root) {
  if (root === null) return [0, 0];
  // 0: rob 1: notRob
  const l = helper(root.left);
  const r = helper(root.right);

  const robed = root.val + l[1] + r[1];
  const notRobed = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);

  return [robed, notRobed];
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
  //   if (root === null) return 0;
  //   const notRobed = rob(root.left) + rob(root.right);
  //   const robed =
  //     root.val +
  //     rob(root.left && root.left.left) +
  //     rob(root.left && root.left.right) +
  //     rob(root.right && root.right.left) +
  //     rob(root.right && root.right.right);

  //   return Math.max(notRobed, robed);

  // dp
  const [robed, notRobed] = helper(root);
  return Math.max(robed, notRobed);
};
```

# SF/azl397985856-leetcode/backlog/338.counting-bits

```js
/*
 * @lc app=leetcode id=338 lang=javascript
 *
 * [338] Counting Bits
 *
 * https://leetcode.com/problems/counting-bits/description/
 *
 * algorithms
 * Medium (64.04%)
 * Total Accepted:    163.1K
 * Total Submissions: 253K
 * Testcase Example:  '2'
 *
 * Given a non negative integer number num. For every numbers i in the range 0
 * ≤ i ≤ num calculate the number of 1's in their binary representation and
 * return them as an array.
 *
 * Example 1:
 *
 *
 * Input: 2
 * Output: [0,1,1]
 *
 * Example 2:
 *
 *
 * Input: 5
 * Output: [0,1,1,2,1,2]
 *
 *
 * Follow up:
 *
 *
 * It is very easy to come up with a solution with run time
 * O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a
 * single pass?
 * Space complexity should be O(n).
 * Can you do it like a boss? Do it without using any builtin function like
 * __builtin_popcount in c++ or in any other language.
 *
 */
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  // tag: bit dp
  // Time complexity: O(n)
  // Space complexity: O(n)
  const res = [];
  res[0] = 0;

  // 10000100110101
  for (let i = 1; i <= num; i++) {
    if ((i & 1) === 0) {
      // 偶数
      // 偶数最后一位是0，因此右移一位对结果没有影响
      res[i] = res[i >> 1];
    } else {
      // 奇数
      // 奇数最后一位是1，i - 1 的 位数 + 1 就是结果
      res[i] = res[i - 1] + 1;
    }
  }

  return res;
};
```

# SF/azl397985856-leetcode/backlog/34.find-first-and-last-position-of-element-in-sorted-array

```js
/*
 * @lc app=leetcode id=34 lang=javascript
 *
 * [34] Find First and Last Position of Element in Sorted Array
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 题目要求时间复杂度为O(logn)因此很自然想到二分法
  let start = 0;
  let end = nums.length - 1;
  while (start <= end) {
    const mid = start + ((end - start) >> 1);

    if (nums[mid] === target) {
      let left = 0;
      let right = 0;

      while (nums[mid - left] === target) {
        left++;
      }
      while (nums[mid + right] === target) {
        right++;
      }
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return [-1, -1];
};
```

# SF/azl397985856-leetcode/backlog/344.reverse-string

```js
/*
 * @lc app=leetcode id=344 lang=javascript
 *
 * [344] Reverse String
 *
 * https://leetcode.com/problems/reverse-string/description/
 *
 * algorithms
 * Easy (62.81%)
 * Total Accepted:    409.9K
 * Total Submissions: 649.5K
 * Testcase Example:  '["h","e","l","l","o"]'
 *
 * Write a function that reverses a string. The input string is given as an
 * array of characters char[].
 *
 * Do not allocate extra space for another array, you must do this by modifying
 * the input array in-place with O(1) extra memory.
 *
 * You may assume all the characters consist of printable ascii
 * characters.
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: ["h","e","l","l","o"]
 * Output: ["o","l","l","e","h"]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: ["H","a","n","n","a","h"]
 * Output: ["h","a","n","n","a","H"]
 *
 *
 *
 *
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  for (let i = 0; i < s.length >> 1; i++) {
    const temp = s[i];
    s[i] = s[s.length - i - 1];
    s[s.length - i - 1] = temp;
  }
};
```

# SF/azl397985856-leetcode/backlog/345.reverse-vowels-of-a-string

```js
/*
 * @lc app=leetcode id=345 lang=javascript
 *
 * [345] Reverse Vowels of a String
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
  const res = s.split('');

  let start = 0;
  let end = s.length - 1;
  while (start < end) {
    const startVowel = vowels.includes(s[start]);
    const endVowel = vowels.includes(s[end]);
    if (startVowel && endVowel) {
      const temp = res[start];
      res[start] = res[end];
      res[end] = temp;
      start++;
      end--;
    } else if (startVowel) {
      end--;
    } else if (endVowel) {
      start++;
    } else {
      start++;
      end--;
    }
  }

  return res.join('');
};
```

# SF/azl397985856-leetcode/backlog/350.intersection-of-two-arrays-ii

```js
/*
 * @lc app=leetcode id=350 lang=javascript
 *
 * [350] Intersection of Two Arrays II
 *
 * https://leetcode.com/problems/intersection-of-two-arrays-ii/description/
 *
 * algorithms
 * Easy (46.84%)
 * Total Accepted:    185.1K
 * Total Submissions: 393.7K
 * Testcase Example:  '[1,2,2,1]\n[2,2]'
 *
 * Given two arrays, write a function to compute their intersection.
 *
 * Example 1:
 *
 *
 * Input: nums1 = [1,2,2,1], nums2 = [2,2]
 * Output: [2,2]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
 * Output: [4,9]
 *
 *
 * Note:
 *
 *
 * Each element in the result should appear as many times as it shows in both
 * arrays.
 * The result can be in any order.
 *
 *
 * Follow up:
 *
 *
 * What if the given array is already sorted? How would you optimize your
 * algorithm?
 * What if nums1's size is small compared to nums2's size? Which algorithm is
 * better?
 * What if elements of nums2 are stored on disk, and the memory is limited such
 * that you cannot load all elements into the memory at once?
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
  const res = [];

  for (let i = 0; i < nums1.length; i++) {
    if (nums2.includes(nums1[i])) {
      // 这里我们对两个数组排序，然后二分查找， 时间复杂度nlogn
      nums2[nums2.indexOf(nums1[i])] = null;
      res.push(nums1[i]);
    }
  }

  return res;
};
```

# SF/azl397985856-leetcode/backlog/387.first-unique-character-in-a-string

```js
/*
 * @lc app=leetcode id=387 lang=javascript
 *
 * [387] First Unique Character in a String
 *
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 *
 * algorithms
 * Easy (49.29%)
 * Total Accepted:    255.6K
 * Total Submissions: 513.8K
 * Testcase Example:  '"leetcode"'
 *
 *
 * Given a string, find the first non-repeating character in it and return it's
 * index. If it doesn't exist, return -1.
 *
 * Examples:
 *
 * s = "leetcode"
 * return 0.
 *
 * s = "loveleetcode",
 * return 2.
 *
 *
 *
 *
 * Note: You may assume the string contain only lowercase letters.
 *
 */
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
};
```

# SF/azl397985856-leetcode/backlog/409.longest-palindrome

```js
/*
 * @lc app=leetcode id=409 lang=javascript
 *
 * [409] Longest Palindrome
 */
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindrome = function(s) {
  // abccccdd
  let res = 0;
  let hasOdd = false;
  const counts = Array('z'.charCodeAt(0) + 1).fill(0);
  for (let i = 0; i < s.length; i++) {
    counts[s.charCodeAt(i)] += 1;
  }

  for (let i = 0; i < counts.length; i++) {
    if (counts[i] % 2 === 0) {
      res += counts[i];
    } else {
      hasOdd = true;
      res += counts[i] - 1;
    }
  }

  return hasOdd ? res + 1 : res;
};
```

# SF/azl397985856-leetcode/backlog/538.convert-bst-to-greater-tree

```js
/*
 * @lc app=leetcode id=538 lang=javascript
 *
 * [538] Convert BST to Greater Tree
 *
 * https://leetcode.com/problems/convert-bst-to-greater-tree/description/
 *
 * algorithms
 * Easy (50.04%)
 * Total Accepted:    75.4K
 * Total Submissions: 149K
 * Testcase Example:  '[5,2,13]'
 *
 * Given a Binary Search Tree (BST), convert it to a Greater Tree such that
 * every key of the original BST is changed to the original key plus sum of all
 * keys greater than the original key in BST.
 *
 *
 * Example:
 *
 * Input: The root of a Binary Search Tree like this:
 * ⁠             5
 * ⁠           /   \
 * ⁠          2     13
 *
 * Output: The root of a Greater Tree like this:
 * ⁠            18
 * ⁠           /   \
 * ⁠         20     13
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function(root) {
  let res = 0;
  function r(root) {
    if (root === null) return null;

    r(root.right);

    root.val += res;

    res = +root.val;

    r(root.left);

    return root;
  }
  r(root);
  return root;
};
```

# SF/azl397985856-leetcode/backlog/540.single-element-in-a-sorted-array

```js
/*
 * @lc app=leetcode id=540 lang=javascript
 *
 * [540] Single Element in a Sorted Array
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function(nums) {
  //   if (nums.length === 1) return nums[0]
  //   nums.sort();
  //   for (let i = 0; i < nums.length; i++) {
  //     if (nums[i] === nums[i + 1]) {
  //       i++;
  //     } else {
  //         return nums[i];
  //     }
  //   }

  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === nums[mid + 1]) {
      if (mid % 2 === 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    } else if (nums[mid] === nums[mid - 1]) {
      if (mid % 2 === 0) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    } else {
      return nums[mid];
    }
  }
};
```

# SF/azl397985856-leetcode/backlog/543.diameter-of-binary-tree

```js
/*
 * @lc app=leetcode id=543 lang=javascript
 *
 * [543] Diameter of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function maxDepth(root, res) {
  if (root === null) return 0;

  const l = maxDepth(root.left, res);
  const r = maxDepth(root.right, res);
  res.val = Math.max(res.val, l + r);
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
  // 如果不计算max， 直接1+ Math.max(maxLeft, maxRight)， 得到的结果实际上是经过root节点的最大值，并不一定是总体最大值
  // 题目也做了说明， ”最大值不一定经过root“
  if (root === null) return 0;
  const res = {
    val: 0,
  };

  maxDepth(root, res);

  return res.val;
};
```

# SF/azl397985856-leetcode/backlog/633.sum-of-square-numbers

```js
/*
 * @lc app=leetcode id=633 lang=javascript
 *
 * [633] Sum of Square Numbers
 */
/**
 * @param {number} c
 * @return {boolean}
 */
var judgeSquareSum = function(c) {
  let start = 0;
  let end = Math.floor(Math.sqrt(c));

  while (start <= end) {
    const res = Math.pow(start, 2) + Math.pow(end, 2);
    if (res < c) {
      start++;
    } else if (res > c) {
      end--;
    } else {
      return true;
    }
  }
  return false;
};
```

# SF/azl397985856-leetcode/backlog/680.valid-palindrome-ii

```js
/*
 * @lc app=leetcode id=680 lang=javascript
 *
 * [680] Valid Palindrome II
 */
function isPalindrome(s, pos) {
  // deeee
  let start = 0;
  let end = s.length - 1;

  while (start <= end) {
    if (start === pos) {
      start++;
      continue;
    } else if (end === pos) {
      end--;
      continue;
    }
    if (s[start] !== s[end]) return false;
    start++;
    end--;
  }
  return true;
}
/**
 * @param {string} s
 * @return {boolean}
 */
var validPalindrome = function(s) {
  // 时间复杂度O(n^2)
  let start = 0;
  let end = s.length - 1;
  for (let i = 0; i < s.length; i++) {
    if (s[start] !== s[end]) {
      return isPalindrome(s, start) || isPalindrome(s, end);
    }
    start++;
    end--;
  }
  return true;
};
```

# SF/azl397985856-leetcode/backlog/93.restore-ip-addresses

```js
/*
 * @lc app=leetcode id=93 lang=javascript
 *
 * [93] Restore IP Addresses
 */
function backtrack(list, tempList, s, start) {
  if (tempList.length === 4 && tempList.join('') === s && !list.includes(tempList.join('.'))) {
    list.push(tempList.join('.'));
  }
  if (tempList.length > 4) return;

  for (let i = start; i < s.length; i++) {
    for (let j = 0; j < 3; j++) {
      const r = s.slice(i, i + j + 1);
      if (+r > 255) continue;
      if (r[0] === '0' && r.length > 1) continue;
      tempList.push(r);
      backtrack(list, tempList, s, i + j + 1);
      tempList.pop();
    }
  }
}
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  // Given "25525511135",
  // return ["255.255.11.135", "255.255.111.35"].
  if (s.length > 3 * 4) return [];
  const list = [];
  backtrack(list, [], s, 0);
  return list;
};
```

# SF/azl397985856-leetcode/backlog/958.check-completeness-of-a-binary-tree

```js
/*
 * @lc app=leetcode id=958 lang=javascript
 *
 * [958] Check Completeness of a Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isCompleteTree = function(root) {
  if (root === null) return root;
  let cur = root;
  const queue = [];

  while (cur !== null) {
    queue.push(cur.left);
    queue.push(cur.right);
    cur = queue.shift();
  }

  return queue.filter(Boolean).length === 0;
};
```

# 毎日一题 - 134.Gas Station(加油站)

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/gas-station/
- tag：Array

## 题目描述

```
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.
```

## 参考答案

1.暴力求解，时间复杂度 O(n^2)

> 我们可以一次遍历 gas，对于每一个 gas 我们依次遍历后面的 gas，计算 remian，如果 remain 一旦小于 0，就说明不行，我们继续遍历下一个

```js
// bad 时间复杂度0(n^2)
let remain = 0;
const n = gas.length;
for (let i = 0; i < gas.length; i++) {
  remain += gas[i];
  remain -= cost[i];
  let count = 0;
  while (remain >= 0) {
    count++;
    if (coun === n) return i;
    remain += gas[getIndex(i + count, n)];
    remain -= cost[getIndex(i + count, n)];
  }
  remain = 0;
}
retirn - 1;
```

2.比较巧妙的方法，时间复杂度是 O(n)

> 这个方法基于两点：
>
> 2-1:如果站点 i 到达站点 j 走不通,那么从 i 到 j 之间的站点(比如 k)出发一定都走不通。前提 i(以及 i 到 k 之间)不会拖累总体(即 remain >= 0)。
>
> 2-2:如果 cost 总和大于 gas 总和，无论如何也无法走到终点，这个比较好理解。因此假如存在一个站点出发能够到达终点，其实就说明 cost 总和一定小于等于 gas 总和

```js
const n = gas.length;
let total = 0;
let remain = 0;
let start = 0;

for (let i = 0; i < n; i++) {
  total += gas[i];
  total -= cost[i];

  remain += gas[i];
  remain -= cost[i];

  // 如果remain < 0,说明从start到i走不通
  // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
  // 因此我们重新从i + 1开始作为start
  if (remain < 0) {
    remain = 0;
    start = i + 1;
  }
}
// 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

// 如果costu总和大于gas总和，无论如何也无法走到终点
return total >= 0 ? start : -1;
```

# 毎日一题 - 739.Daily Temperatures

## 信息卡片

- 题目链接：https://leetcode.com/problems/daily-temperatures/
- tag：`Array` `Stack`

## 题目描述

```
Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.

For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].

Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].
```

## 参考答案

暴力，双层 for 循环。`效率很低`

1. 外层是‘当天’T[i]，内层是‘当天’之后 T[j]；
2. 多少天之后比‘当天’温度高就是 j-i；

时间复杂度 O(n^2), 空间复杂度 O(1)

参考 JavaScript 代码：

```js
/**
 * @param {number[]} T
 * @return {number[]}
 * 双层for循环
 */
var dailyTemperatures = function(T) {
  let result = [];
  for (let i = 0; i < T.length; i++) {
    result[i] = 0;
    for (let j = i + 1; j < T.length; j++) {
      if (T[i] < T[j]) {
        result[i] = j - i;
        break;
      }
    }
  }
  return result;
};
```

使用栈,单调递减栈

1. for 循环遍历数组，栈存 T 的下标 i，返回结果数组 result；
2. 拿栈顶元素 peek 与 i 比较，T[peek] >= T[i]则将 i 入栈，T[peek] < T[i]则栈顶值(原数组下标)位置的天数就是 result[peek] = i - peek；
3. 栈顶元素出栈；
4. 重复 2，3 两步；

时间复杂度 O(n), 空间复杂度 O(n)

参考 JavaScript 代码：

```js
/**
 * @param {number[]} T
 * @return {number[]}
 * 递减栈；
 */
var dailyTemperatures = function(T) {
  let stack = [];
  let result = [];
  for (let i = 0; i < T.length; i++) {
    result[i] = 0;
    while (stack.length > 0 && T[stack[stack.length - 1]] < T[i]) {
      let peek = stack.pop();
      result[peek] = i - peek;
    }
    stack.push(i);
  }
  return result;
};
```

# 毎日一题 - 744. find smallest letter greater than target

## 信息卡片

- 题目链接：https://leetcode.com/problems/find-smallest-letter-greater-than-target/
- tag：`Array`

## 题目描述

```
Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.

Letters also wrap around. For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.

Examples:
    Input:
    letters = ["c", "f", "j"]
    target = "a"
    Output: "c"

    Input:
    letters = ["c", "f", "j"]
    target = "c"
    Output: "f"

    Input:
    letters = ["c", "f", "j"]
    target = "d"
    Output: "f"

    Input:
    letters = ["c", "f", "j"]
    target = "g"
    Output: "j"

    Input:
    letters = ["c", "f", "j"]
    target = "j"
    Output: "c"

    Input:
    letters = ["c", "f", "j"]
    target = "k"
    Output: "c"
Note:
    letters has a length in range [2, 10000].
    letters consists of lowercase letters, and contains at least 2 unique letters.
    target is a lowercase letter.
```

## 思路

二分查找，提高速度
要求是查找某一个元素，又是在有序的集合中。
所以我们可以用二分查找

1. 排除两种情况；target 小于首元素|| target 大于等于尾元素 => 目标都是首元素
2. 当 target>=letters[mid] 时(我们要的值一定在右边)，调整左区间 min = mid+1;
3. 当 target< letters[mid] 时，调整右区间 max = mid-1;
4. 循环终止条件是 min > max; 最终返回 min 位置元素

## 建议

在 leetcode 上找一个数组稍微长一点的测试用例，在纸上画出整个过程；对理解很有帮助

## 参考答案

```js
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
  const length = letters.length;
  let min = 0;
  let max = length - 1;
  if (target >= letters[length - 1] || target < letters[0]) return letters[0];
  while (min <= max) {
    const mid = (max + min) >> 1;
    if (target >= letters[mid]) {
      min = mid + 1;
    } else {
      max = mid - 1;
    }
  }
  return letters[min];
};
```

##### Big Countries

- 题目链接：https://leetcode.com/problems/big-countries/
- tag：`sql`

### 题目描述

```
There is a table World

+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.

Write a SQL solution to output big countries' name, population and area.

For example, according to the above table, we should output:

+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
```

### 参考答案

最基本的 sql 语句，没什么好讲的。 如果不会的话，说明对基础语法不熟。

参考代码：

```sql
select name, population, area from World where area > 3000000 or population > 25000000

```

# 毎日一题 - 594. Longest Harmonious Subsequence

## 信息卡片

- 题目链接：https://leetcode.com/problems/longest-harmonious-subsequence/
- tag：`Array`

## 题目描述

```
We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.

Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.

Example 1:

  Input: [1,3,2,2,5,2,3,7]
  Output: 5
  Explanation: The longest harmonious subsequence is [3,2,2,2,3].
```

## 思路

1. 将数组中的值作为一个对象中的属性，出现的次数就是属性值
2. 属性差一的值相加，获取最大的，否则返回 0；

## 参考答案

```js
/**
 * @param {number[]} nums
 * @return {number}
 * 使用ES6中的Map
 */
var findLHS = function(nums) {
  if (!nums.length) return 0;
  const map = new Map();
  let max = 0;
  for (let i = 0; i < nums.length; i++) {
    let target = nums[i];
    if (map.has(target)) {
      map.set(target, map.get(target) + 1);
    } else {
      map.set(target, 1);
    }
  }
  for (let key of map.keys()) {
    if (map.has(key + 1)) {
      max = Math.max(map.get(key) + map.get(key + 1), max);
    }
  }
  return max;
};
```

### 其它优秀解法

```js
/**
 * @param {number[]} nums
 * @return {number}
 * for...in遍历
 */
var findLHS = function(nums) {
  if (!nums.length) return 0;
  const counts = {};
  let max = 0;
  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i]]) {
      counts[nums[i]] += 1;
    } else {
      counts[nums[i]] = 1;
    }
  }
  for (let key in counts) {
    // for...in性能低
    if (counts[+key + 1]) {
      max = Math.max(counts[key] + counts[+key + 1], max);
    }
  }
  return max;
};

/**
 * @param {number[]} nums
 * @return {number}
 * 普通遍历
 */
var findLHS = function(nums) {
  if (!nums.length) return 0;
  const counts = {};
  let max = 0;
  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i]]) {
      counts[nums[i]] += 1;
    } else {
      counts[nums[i]] = 1;
    }
  }
  for (let i = 0; i < nums.length; i++) {
    // 有多余的无效遍历
    if (counts[nums[i] + 1]) {
      max = Math.max(max, counts[nums[i]] + counts[nums[i] + 1]);
    }
  }
  return max;
};
```

##### 圆桌一先一后

- 题目链接：暂无
- tag：`逻辑思维`

### 题目描述：

```
考虑一个双人游戏。游戏在一个圆桌上进行。每个游戏者都有足够多的硬币。他们需要在桌子上轮流放置硬币，每次必需且只能放置一枚硬币，要求硬币完全置于桌面内(不能有一部分悬在桌子外面)，并且不能与原来放过的硬币重叠。谁没有地方放置新的硬币，谁就输了。游戏的先行者还是后行者有必胜策略？这种策略是什么？
```

### 参考答案

思路如下：

首先，谁有必胜机会？
假设硬币跟桌子一样大，必然是先手者胜，所以这题的第一问答案必然是先手必胜

再假设硬币的大小是圆桌的“微分”，一个硬币就一个点的大小，那么桌子上就可以放下 ∞ 个硬币，但是因为圆桌本身是个圆，而圆关于圆心对称，所以一定是奇数个点，多出来的这个点是作为对称中心的圆心，再次印证结论先手必胜。

必胜的策略，先手抢圆心，之后保持和对方放置的硬币关于圆心对称即可

### 扩展

**扩展一：**

有 1996 个棋子,两人轮流取棋子,每次允许取其中的 2 个,4 个或 8 个,
谁最后取完棋子,就算获胜.那么先取的人为保证获胜,第一次应取几个棋子?

**参考答案：**

1. 1996 这一类的问题其实 1996 和 11992 关系不大，先记为 M，重要的是可选的{a,b,c...}这些选项
2. 将选项集合记为 K={a,b,c..}，在对方报出 A∈K 后，必有 B∈K 使得 A+B = n \* γ(n 是正整数)，本题中 γ 为 6
3. 确定好 γ 以后，剩下要做的事情就是 M 对 γ 取余，本题中 M%γ=332 余 4
4. 4 是{abc...}里的一个选项，所以先手取 4 个棋子必胜

**扩展二：**

在一个 4×5 的棋盘中,甲,乙两人轮流往棋盘的方格中放棋子,甲先放第一枚棋子,乙只能在与这枚棋子的相邻的格内放棋子(相邻是指有公共边的两个格),甲再放时又必须在乙刚放的棋子的相邻的格内放,以后照此规则放,谁无法放棋子的时候谁失败,如果都按最佳方案,谁取胜?

**扩展三：**

上述的题目全部变成变量，然后用代码写出来

##### squares-of-a-sorted-array

- 题目链接：https://leetcode.com/problems/squares-of-a-sorted-array/
- tag：`Array` `Two Pointers`

### 题目描述

```
Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.



Example 1:

Input: [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Example 2:

Input: [-7,-3,2,3,11]
Output: [4,9,9,49,121]


Note:

1 <= A.length <= 10000
-10000 <= A[i] <= 10000
A is sorted in non-decreasing order.

```

### 思路

典型的双指针问题。我们记录头尾指针，
然后每次`移动两个指针指向的值中绝对值较大的那个`就好了。

这个很好理解，因为是从小到大排列，我们可以获取到最小的元素和最大的元素。
平方较大的元素一定是最小的元素或者最大的元素，因此我们两个指针指向首尾就好了。

更新的策略也很简单，由于我们取得的绝对值是从大到小的，因此我们新建一个数组，
然后从后面往前放就好了。

### 参考答案

```js
/*
 * @lc app=leetcode id=977 lang=javascript
 *
 * [977] Squares of a Sorted Array
 */
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortedSquares = function(A) {
  let start = 0;
  let end = A.length - 1;
  const res = [];
  let cur = 0;

  while (start <= end) {
    if (Math.abs(A[start]) === Math.abs(A[end])) {
      cur++;
      res[A.length - cur] = A[start] * A[start];
      cur++;
      res[A.length - cur] = A[end] * A[end];
      start++;
      end--;
    } else if (Math.abs(A[start]) > Math.abs(A[end])) {
      cur++;
      res[A.length - cur] = A[start] * A[start];
      start++;
    } else {
      cur++;
      res[A.length - cur] = A[end] * A[end];
      end--;
    }
  }

  return res;
};
```

# 毎日一题 - 洗牌算法

## 信息卡片

- 题目链接：暂无
- tag：`Array` `Probability`

## 题目描述

```
假设我们有一个n个元素的数组，要求你实现一个函数，该函数会随机地返回n个元素的排列，要求所有排列出现的概率是一样的。即每一个排列出现的概率都是1/n!.
```

## 参考答案

思路如下

像洗牌一样，从数组中随机取出一个，放入另一个全新的数组中，但这会涉及到数组删除操作.
在这个基础上转换一下思路把从数组中取出的元素放入原数组中，第一次随机删除时，把它与原数组的倒数第一个交换，第 2 次在剩下的元素中随机删除时，把它与原数组的倒数第 2 个交换，第 n-1 次(最后一次不用换)时便完成了洗牌 时间复杂度为 O(n)

```js
function shuffle(list) {
  for (let i = list.length - 1; i >= 1; i--) {
    const random = (Math.random() * (i + 1)) >> 0;
    const temp = list[i];
    list[i] = list[random];
    list[random] = temp;
  }
}
```

注： 概率证明， 任意一个元素放在倒数第一个位置的概率为 1/n,放到倒数第 2 个的概率为 [(n-1)/n ]_ [1/(n-1)] = 1/n,放在倒数第 k 个位置的概率是[(n-1)/n] _ [(n-2)/(n-1)] _..._ [(n-k+1)/(n-k+2)] _[1/(n-k+1)] = 1/n， 因此每一个元素放在任意位置的概率都为 1/n,所有的排列出现的概率则为 1/n _ 1/(n-1) _.._ 1 = 1/n!

注：在交换时，之所以第一次与第 n 个交换不与第一个交换，是因为与第 n 个交换代码更简洁

# 毎日一题 - 524.longest-word-in-dictionary-through-deleting

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/
- tag：`String` `Two Pointers`

## 题目描述

```
给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

示例 1:

输入:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

输出:
"apple"
示例 2:

输入:
s = "abpcplea", d = ["a","b","c"]

输出:
"a"
说明:

1. 所有输入的字符串只包含小写字母。
2. 字典的大小不会超过 1000。
3. 所有输入的字符串长度不会超过 1000。

```

## 参考答案

我们的思路是删除字符串中的某些字符，使得可以组成数组中的字符串，
然后我们找到最长。

`字符串删除某些字符，使之成为另一个字符串`，这本质上是字符串子序列问题。

求解 subSequence 的题目，可以用双指针解决
比如在字符串 a 中查找 b，那么快指针在 a 上，慢指针在 b。 快指针一直更新，慢指针只有两个相等才更新
最后比较慢指针是否走到底了即可

参考 JavaScript 代码：

```js
function isSequence(s, word) {
  if (word.length > s.length) return false;

  let i = 0;
  let j = 0;

  while (i < s.length && j < s.length) {
    if (word[i] === s[j]) i++;
    j++;
  }

  // 说明有s中有word.length个元素和word匹配(且顺序一致)
  // 换句话说就是word是s的子序列
  return i === word.length;
}
/**
 * @param {string} s
 * @param {string[]} d
 * @return {string}
 */
var findLongestWord = function(s, d) {
  let res = '';

  for (let word of d) {
    if (isSequence(s, word)) {
      if (word.length > res.length) res = word;
      else if (word.length === res.length && word.charAt(0) < res.charAt(0)) res = word;
    }
  }

  return res;
};
```

# 毎日一题 - 删除没有头节点的单链表中的指定项

## 信息卡片

- 题目链接：无(来自编程之美)
- tag：`Linked List`

## 题目描述

```
假设有一个没有头指针的单链表，一个指针指向该单链表中间的一个节点(不是第一个，也不是最后一个节点)，
请将该节点从单链表中删除。

```

![2019-07-23](../assets/daily/2019-07-23.jpeg)

## 参考答案

我们可以“移花接木”， 将要删除的节点的后面的节点的值给当前节点，然后删除后面的节点即可。

# 毎日一题 - 灯泡问题

## 信息卡片

- 题目链接：无
- tag：`发散思维`

## 题目描述

```
房子有三盏灯，屋外有三个开关，分别控制这三盏灯，只有进去房间，才能看到哪一个灯是亮的。
请问如何只进一次房间，就能指明哪一个开关控制哪一个灯？

```

## 参考答案

这个问题比较发散，下面的答案仅供参考：

1. 首先你应该问这个灯是什么样的灯
2. 如果是电阻比较大的灯，根据焦耳定律，会有相对比较大的发热
   但是发热 Q = I ^ 2 _ R _ t, 因此发热量除了和电阻有关，其实和电流和 t 都有关系，
   如何评估这种差异，寻找到人能感受到的热量差异，需要面试者自己去探索和分析

# 毎日一题 - 9. Palindrome number

## 信息卡片

- 题目链接：https://leetcode.com/problems/palindrome-number/submissions/
- tag：`Math`

## 题目描述

```
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

  Input: 121
  Output: true

Example 2:

  Input: -121
  Output: false
  Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Example 3:

  Input: 10
  Output: false
  Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

Follow up:

  Coud you solve it without converting the integer to a string?
```

## 参考答案

转成字符串方式

1. 负数都是非回文数，10 的整数倍不是回文。
2. 将数字转为字符串，再逆序排列字符串。两者比较，相等就是回文数。

直接操作整数方式

1. 复制 x 到 temp;
2. 取 temp 末尾数字，方式为 temp 与 10 的求余；组成新数 reverse;
3. 每取完一位,temp 缩小 10 倍并且去掉小数。
4. reverse 要`先扩大十倍`再加上取下来的数
5. 当 temp === 0 时，表示已经取完；reverse 与 x 比较

参考 JavaScript 代码：

```js
/**
 * @param {number} x
 * @return {boolean}
 * 转成字符串
 */
var isPalindrome = function(x) {
  if (x < 0) return false;
  if (x === 0) return true;
  if (x % 10 === 0) return false;
  let reverse = '';
  let str = String(x);
  for (let i = str.length - 1; i >= 0; i--) {
    reverse += str[i];
  }
  return str === reverse;
};

/**
 * @param {number} x
 * @return {boolean}
 * 不转成字符串
 */
var isPalindrome = function(x) {
  if (x < 0) return false;
  if (x === 0) return true;
  if (x % 10 === 0) return false;
  let temp = x;
  let reverse = 0;
  while (temp > 0) {
    let num = temp % 10;
    temp = (temp - num) / 10; // 或 temp = (temp / 10) >> 0,去除小数位
    reverse = reverse * 10 + num;
  }
  return x === reverse;
};
```

# 毎日一题 - 将帅问题

## 信息卡片

- 题目链接：无(来自编程之美)
- tag：`数据压缩`

## 题目描述

![2019-07-26](../assets/daily/2019-07-26.jpeg)

## 参考答案

这是数据压缩问题中的一种。

类似的问题有， 如果将 IP 地址用 4 个字节来表示等等。

这道题的思路，如果我们不考虑用一个字节去存储的话，我们通过观察
坐标，发现“坐标和 3 取余的结果相同的就是同一列”，因此我们可以根据
这个来判断位置是否合法。

我们容易写出类似下面的代码：

```js
for (let i = 0; i < 9; i++) {
  for (let j = 0; j < 9; j++) {
    if (i % 3 !== j % 3) {
      console.log(`${i + 1}, ${j + 1}`);
    }
  }
}
```

可以看出上面的写法用到了两个字节去表示，如何将上面的写法压缩到一个字节呢？

仔细观察我们发现，内存循环和外层循环的长度是一样的，
其实我们内外循环用一个变量表示。

内外循环总共执行了 81 次。 我们定义一个变量为 81.
然后用 i / 9 来表示外层循环的值。 用 i % 9 来表示内层循环的值。

可以看出，i 增加 9 次之后，内存循环会增加 9，外层增加 1，整个过程类似上面。

代码如下：

```js
let i = 81;

while (i-- > 0) {
  if (((i / 9) >> 0) % 3 !== (i % 9) % 3) {
    console.log(`${((i / 9) >> 0) + 1}, ${(i % 9) + 1}`);
  }
}
```

# 毎日一题 - 54.Spiral Matrix

## 信息卡片

- 题目链接：https://leetcode.com/problems/spiral-matrix/
- tag：`Array` `Matrix`

## 题目描述

```
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

  Input:
    [
      [ 1, 2, 3 ],
      [ 4, 5, 6 ],
      [ 7, 8, 9 ]
    ]
  Output: [1,2,3,6,9,8,7,4,5]
Example 2:

  Input:
    [
      [1, 2, 3, 4],
      [5, 6, 7, 8],
      [9,10,11,12]
    ]
  Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

## 参考答案

1. 剥洋葱，row->col->row->col 为一次；
2. row->col、col->row 的切换都伴随读取的初始位置的变化；
3. 结束条件是 row 头>row 尾或者 col 顶>col 底

![剥洋葱](../assets/problems/54.spiral-matrix.jpg)

时间复杂度 O(m\*n), 空间复杂度 O(1)

参考 JavaScript 代码：

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  if (matrix.length === 0) return [];
  let rowT = 0; // 行顶
  let rowB = matrix.length - 1; // 行底
  let colL = 0; // 列左
  let colR = matrix[0].length - 1; // 列右
  let result = [];
  // 顺序是行、列、行、列；每次切换，读取的初始位置都会变化1(+/- 1)
  while (colL <= colR && rowT <= rowB) {
    for (let a = colL; a <= colR; a++) {
      result.push(matrix[rowT][a]);
    }
    rowT++;
    for (let b = rowT; b <= rowB; b++) {
      result.push(matrix[b][colR]);
    }
    colR--;
    for (let c = colR; c >= colL && rowB >= rowT; c--) {
      result.push(matrix[rowB][c]);
    }
    rowB--;
    for (let d = rowB; d >= rowT && colR >= colL; d--) {
      result.push(matrix[d][colL]);
    }
    colL++;
  }
  return result;
};
```

代码只有一个 for 循环的方式，操作方向
例如

> 1 2 3 4 5
> 6 7 8 9 10
> 11 12 13 14 15
>
> 对上面矩阵遍历时的操作
>
> 向右 5 次(算上从左侧第一次进入)
> 向下 2 次
> 向左 4 次
> 向上 1 次
> 向右 3 次
> 向下 0 次 -- 结束

方向有四个，right、down、left、up
四个方向又分两类，水平(right,left)和垂直(down，up)
而在两类方向上的移动最值是 水平 n, 垂直 m;
在遍历过程中，根据`方向切换`来减小 n/m 从而缩小两类方向的移动最值直到结束
四个方向可以用二维数组来表示[ [0, 1], [1, 0], [0, -1], [-1, 0] ]
两类方向各自的初始最大值是[n, m-1]
当 n == 0 || m == 0 表示元素已经全部遍历完

这种写法省去了代码中的 for 循环，但是 while 循环次数却增多了；复杂度没有变化
时间复杂度 O(m\*n), 空间复杂度 O(1)

参考 JavaScript 代码：

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 * 一个for循环,但while变多了
 */
var spiralOrder = function(matrix) {
  if (matrix.length === 0) return [];
  let m = matrix.length;
  let n = matrix[0].length;
  let result = [];
  const dirs = [
    [0, 1],
    [1, 0],
    [0, -1],
    [-1, 0],
  ]; // 控制方向的数组
  // 元素坐标row,col;
  let row = 0;
  let col = -1;
  let steps = [n, m - 1];
  let dir = 0; // 初始方向
  while (steps[dir % 2]) {
    for (let i = 0; i < steps[dir % 2]; i++) {
      // 方向的改变的效果，row/col能增能减
      row += dirs[dir][0];
      col += dirs[dir][1];
      result.push(matrix[row][col]);
    }
    steps[dir % 2]--; // 移动极值缩小
    dir = (dir + 1) % 4; // 方向改变
  }
  return result;
};
```

## 参考

- @stellari [A concise C++ implementation based on Directions](https://leetcode.com/problems/spiral-matrix/discuss/20573/A-concise-C%2B%2B-implementation-based-on-Directions)

##### 走地球问题

- 题目链接：暂无
- tag：`几何`

### 题目描述：

```
地球上有多少个点，使得从该点出发向南走一英里，向东走一英里，再向北走一英里之后恰好回到了起点?
```

### 参考答案

无数个点

思路如下：
首先可以确定的是北极点(从北极点出发，任何角度都是向南)

将地球看成一个标准球体，那么纬线就是无数个长度不等的圆，必然存在纬线满足周长等于`2πkR=1(英里) 其中k为正整数`,即半径为`R=1/2πk`的圆
那么沿着这条纬线(记为 E 纬线)上任意一点向东走一英里，始终会回到原点，只是走的圈数不同而已。
根据题目倒推，在这条纬线以北一英里存在一条纬线(记为 N 纬线)，从 N 纬线的任意一点向南一英里到达 E 纬线 W 点，沿着 E 纬线向东一英里，必会回到 W 点，再向北走一英里恰好可以回到起点。北极点可能包含在这个集合中，也可能不在。
如下图示供参考：
![earth-problem](../assets/daily/2019-07-30.jpg)

所以答案是无数个点

##### 小飞电梯调度问题

- 题目链接：暂无
- tag：`Math` `Dynamic Programming`

### 题目描述：

```
微软亚洲研究所所在的希格玛大厦一共有6部电梯。在高峰时间，每层都有人上下，电梯在每层都停。实习生小飞常常会被每层都停的电梯弄得很不耐烦，于是他提出了这样一个办法：
由于楼层并不太高看没在繁忙的上下班时间，每层电梯从一层往上走时，我们只允许电梯停在其中的某一层。所有的乘客都从一楼上电梯，到达某层楼后，电梯停下来，所有乘客再从这里爬楼梯到自己的目的层。
在一楼的时候，每个乘客选择自己的目的层，电梯则自动计算出应停的楼层。
问：电梯停在哪一层楼，能够保证这次乘坐电梯的所有乘客爬楼梯的层数之和最少。

扩展：

1.如何在O(n)的时间复杂度完成？
2.往上爬楼梯，总是比往下走要累的。假设往上爬一个楼层，要耗费k单位的能量，而往下走只需要耗费1单位的能量，那么如果题目条件改为让所有人消耗的能量最少，这个问题怎么解决呢？
这个问题可以用类似上面的分析方法来解答看，因此笔者不再累述，留给读者自行解决。
3.在一个高楼里面，电梯只在某一个楼层停，这个政策还是不太人性化。如果电梯会在k个楼层停呢？读者可以发挥自己的想象力，看看如何寻找最优方案。
```

### 参考答案

题意是
每层都停 => 只停一层，其余让人爬楼梯；所有人爬梯之和最小
选择目的层(i)，在 i 层下的人数是 T[i]，根据大家选择的目的层计算在哪一层(X)停最优
sum(1 ～ N){T[i]\*|i-x|}的最小值

从简单易想到的方式开始；
从 1 楼开始直到顶层，算出在每层人需要爬梯的总和数组 result
找出 Min(result)下标
时间复杂度是 O(N^2)

```js
/**
 * 两个测试数据
 * nPerson = [0, 1, 3, 4, 2, 3]
 * nPerson = [0, 1, 0, 2, 2, 6]
 */
function original(nPerson) {
  // nPerson首元素设0，使楼层与下标对应
  // nPerson[i] 在i层下的人， N 总楼层
  let result = [0]; // 存各层结果
  let target = 1; // 最小值下标
  for (let x = 1; x < nPerson.length; x++) {
    // 目标楼层x
    result[x] = 0;
    for (let i = 1; i < nPerson.length; i++) {
      // 人在哪层停留
      result[x] += nPerson[i] * Math.abs(x - i);
    }
    if (result[target] > result[x]) {
      target = x;
    }
  }
  return target;
}
```

进一步考虑(动态规划)
假设在 i 层停，共需要爬 Y 阶；在 i 层有 N2 人，在 i 层以下共 N1 人，i 层以上共 N3 人
如果在 i-1 层停，相比 i 层变化 Y+N2+N3-N1 = Y - (N1-N2-N3) => N1 > (N2 + N3)时会减少爬阶数
如果在 i+1 层停，相比 i 层变化 Y-N3+N2+N1 = Y - (N3-N2-N1) => N3 > (N2 + N1)时会减少爬阶数
所以在 N1 > N2+N3 时应该在 i-1 层停，N3 > N2+N1 时应该在 i+1 层停; 否则在 i 层停

初始状态电梯停在第一层，向上进行状态的变迁，开始时 N2 + N1 - N3 < 0
sum 越来越小，直到某一层 N2 + N1 >= N3，就没有必要在往上走了。这时已求出最合适的楼层了

```js
function betterOne(nPerson) {
  // 首元素设空, 下标就与楼层对应了，nPerson的长度-1就是楼层数
  let N1 = 0;
  let N2 = nPerson[1];
  let N3 = 0;
  let target = 1;
  // 第一层时，算出人需要走的楼梯数Y和在一楼以上的人数N3
  for (let i = 2; i < nPerson.length; i++) {
    N3 += nPerson[i];
  }
  // 再来优化
  for (let i = 2; i < nPerson.length; i++) {
    if (N1 + N2 < N3) {
      // 在i+1层停较优
      target = i;
      N1 += N2;
      N3 -= nPerson[i];
      N2 = nPerson[i];
    } else {
      break;
    }
  }
  return target;
}
```

扩展问题 2 的解
向上爬比向下走更耗费体力，假设上楼是下楼耗费能量的 k 倍；k 大于 1
比较消耗能量的大小决定楼层，只需在动态规划方式上增加权重即可

```js
function betterOnewithWeight(nPerson, k) {
  // 首元素设空, 下标就与楼层对应了，nPerson的长度-1就是楼层数
  let N1 = 0;
  let N2 = nPerson[1];
  let N3 = 0;
  let target = 1;
  // 第一层时，算出人需要走的楼梯数Y和在一楼以上的人数N3
  for (let i = 2; i < nPerson.length; i++) {
    N3 += nPerson[i];
  }
  // 再来优化
  for (let i = 2; i < nPerson.length; i++) {
    if (N1 + N2 < N3 * k) {
      // 在i+1层停比较好
      target = i;
      N1 += N2;
      N3 -= nPerson[i];
      N2 = nPerson[i];
    } else {
      break;
    }
  }
  return target;
}
```

### 其他优秀解答

中位数方法

假设两个人在 2 楼和 9 楼下。那么在 2-9 楼之间任意层停，两人走楼梯的层数和是不变的
换一组(第二小、第二大)人也是这么处理
将每个人要去的楼层从低到高逐一排列，找到中位数，此中位数就是最优楼层

时间复杂度 O(N)

```js
/**
 * 中位数方法
 */
function median(nPerson) {
  const newArr = []; // 存楼层
  for (let i = 0; i < nPerson.length; i++) {
    while (nPerson[i] > 0) {
      newArr.push(i);
      nPerson[i]--;
    }
  }
  let len = newArr.length;
  // 返回楼层中位数
  return len % 2 == 1 ? newArr[(len + 1) / 2] : newArr[len / 2];
}
```

# 毎日一题 - 771.jewels-and-stones

## 信息卡片

- 题目链接：https://leetcode.com/problems/jewels-and-stones/
- tag：`String` `Hash Table`

## 题目描述

```
 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

示例 1:

输入: J = "aA", S = "aAAbbbb"
输出: 3
示例 2:

输入: J = "z", S = "ZZ"
输出: 0
注意:

S 和 J 最多含有50个字母。
 J 中的字符不重复。
```

## 参考答案

### 正则匹配

时间复杂度比较高，具体复杂度取决于内部回溯的时机。

思路：正则把石头里的宝石 replace 掉，长度相减，就是结果

代码：

```js
let newS = S;
for (let i = 0; i < J.length; i++) {
  newS = newS.replace(new RegExp(J[i], 'g'), '');
}
return S.length - newS.length;
```

### Hash Table

使用 hash table， 空间换时间的方式。

代码：

```js
const set = {};
let res = 0;

for (let i = 0; i < J.length; i++) {
  set[J[i]] = true;
}

for (let i = 0; i < S.length; i++) {
  if (set[S[i]]) {
    res++;
  }
}
return res;
```

### JS 一行代码

```js
return S.split('').filter(c => J.indexOf(c) !== -1).length;
```

# 毎日一题 - 105.从前序与中序遍历序列构造二叉树

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

* tag：`Tree` `Array`

## 题目描述

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

## 参考答案

递归构造二叉树，时间复杂度 O(n)

> 关键在于前序遍历和中序遍历的特性:

- 前序遍历：根节点是首元素
- 中序遍历：根节点左侧的值是其左子树，右侧的值是其右子树
  > 因此，我们首先要得到从前序序列中获取根节点，然后遍历中序序列，找到根节点的位置，以此直到其左子树和右子树的范围。当我们得到其左子树之后，事情就开始重复了，我们仍然需要根据前序序列中找到这颗左子树的根节点，然后再根据中序序列得到这颗左子树根节点的左右子树，右子树同理。因此实际上就是个回溯。

```c
struct TreeNode* _buildTree(int* preorder, int* pindex, int* inorder, int inbegin, int inend)
{
    if(inbegin>inend)//区间不存在，空树
    {
        return NULL;
    }
    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=preorder[*pindex];
    (*pindex)++;
    if(inbegin==inend)//区间只有一个结点，就是根结点
    {
        root->val=inorder[inbegin];
        root->left=NULL;
        root->right=NULL;
        return root;
    }
    //区间正常
    int rootindex=inbegin;
    while(rootindex<=inend)//用前序的根划分中序为两个子区间
    {
        if(inorder[rootindex]==root->val)
        {
            break;
        }
        else
        {
            ++rootindex;
        }
    }
    //递归创建左子树
    root->left= _buildTree(preorder, pindex, inorder, inbegin, rootindex-1);
    //递归创建右子树
    root->right= _buildTree(preorder, pindex, inorder, rootindex+1, inend);
    return root;
}
```

# 毎日一题 - 1123.最深叶节点的最近公共祖先

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/

* tag：`DFS` `Tree`

## 题目描述

给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。

回想一下：

- 叶节点是二叉树中没有子节点的节点
- 树的根节点的深度为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1
- 如果我们假定 A 是一组节点 S 的最近公共祖先，`<font color="#c7254e" face="Menlo, Monaco, Consolas, Courier New, monospace">S</font>`中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。

**示例 1：**

```
输入：root = [1,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = [1,2,3,4]
输出：[4]
```

**示例 3：**

```
输入：root = [1,2,3,4,5]
输出：[2,4,5]
```

提示：

- 给你的树中将有 1 到 1000 个节点。
- 树中每个节点的值都在 1 到 1000 之间。

## 参考答案

深度优先搜索

> 先来解释一下题目意思，给你一个树根，返回最深叶节点的最近公共祖先，存在以下俩种情况：

- 最深叶节点只有一个，那么这个叶节点本身就是它的最近公共祖先
- 最深叶节点不止一个，那就不断深搜找到最大深度，然后回溯，出递归栈时最后一个左右子树等高的节点就是该树的最深节点的最近祖先
  > 所以代码思路分俩条路:只有一个最深叶节点找到并更新返回值;存在多个最深叶节点，找到最后一个子节点等高的节点更新返回值。后者的存在可以被证明，所以后者可以更改前者的结果。

```
class Solution {
private:
    TreeNode *ans;
    int max_deep;
    int DFS(TreeNode *root, int nums){
        //叶子节点
        if(root->left == NULL && root->right == NULL){
            //更新最大深度，记录最大深度的叶节点
            if(nums>max_deep){
                ans = root;
                max_deep = nums;
            }
            return nums;
        }
        int num_l=0, num_r=0;
        //递归左右子树
        if(root->left) num_l = DFS(root->left, nums+1);
        if(root->right) num_r = DFS(root->right, nums+1);
        //存储多个最深叶节点，递归出最近公共祖先
        if(num_l == num_r && num_l>=max_deep){
            ans = root;
            max_deep = num_l;
        }
        //返回最大深度
        return max(num_l, num_r);
    }
public:
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        //初始化根、最大深度
        ans = root;
        max_deep = INT_MIN;
        int deep_n = DFS(root, 1);
        return ans;
    }
};
```

# 毎日一题 - 64.最小路径和

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/minimum-path-sum/

* tag：`动态规划` `Array`

## 题目描述

给定一个包含非负整数的  m x n  网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
**说明**：每次只能向下或者向右移动一步。
**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

## 参考答案

动态规划求解，时间复杂度 O(n\*m)

> 我们新建一个额外的 dp 数组，与原矩阵大小相同。在这个矩阵中,dp(i,j)表示从坐标(i,j)到右下角的最小路径权值。我们初始化右下角的 dp 值为对应的原矩阵值，然后去填整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：`dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))`

```
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        //剪枝
        int n = grid.size();
        if(n==0)
            return 0;
        int m = grid[0].size();
        if(m==0)
            return 0;
        //初始化第一列
        for(int i=1;i<m;i++)
        {
            grid[0][i] += grid[0][i-1];
        }
        //初始化第一排
        for(int i=1;i<n;i++)
        {
            grid[i][0] += grid[i-1][0];
        }

        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                //计算出到当前位置的最小值
                grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);
            }
        }
        return grid[n-1][m-1];
    }
};
```

# 毎日一题 - 547.朋友圈

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/friend-circles

* tag：`并查集` `BFS`

## 题目描述

班上有  N  名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B  的朋友，B 是 C  的朋友，那么我们可以认为 A 也是 C  的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个  N \* N  的矩阵  M，表示班级中学生之间的朋友关系。如果 M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

**示例 1:**

```
输入:
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。
```

**示例 2:**

```
输入:
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```

注意：

1. N 在[1,200]的范围内。
2. 对于所有学生，有 M[i][i] = 1。
3. 如果有 M[i][j] = 1，则有 M[j][i] = 1。

## 参考答案

### 解法一：并查集

遍历邻接矩阵 M，如果 M[i][j]==1 即二者是朋友，那么合并 i,j 集合，遍历完整个矩阵 M 后则剩余的集合数量就是有多少个朋友圈。其中路径压缩能大大降低算法的时间复杂度：合并时让当前节点归属指向朋友圈的根节点，下次查询时就能快许多。

```
class Solution {
public:
    int findCircleNum(vector<vector<int>>& M) {
        if (M.empty())
            return 0;
        vector<int> pre(M.size());
        for(int i=0; i<M.size(); i++)
            pre[i] = i;//先各自为组，组名也为自己的序号
        int group = M.size();//一开始有多少人就有多少个朋友圈，当每出现一对朋友时就减1，最后就是总的朋友圈数量了。
        for(int i=0; i<M.size(); i++)
        {
            for(int j=0; j<M.size(); j++)
            {
                if (i != j && M[i][j] == 1)
                {
                    int x1 = find(i, pre);//x1为i所属的组
                    int x2 = find(j, pre);//x2为j所属的组
                    if (x1 != x2)
                    {
                        //如果不属于同个朋友圈的话就把i归为j的组
                        pre[x1] = x2;
                        group--;
                    }
                }
            }
        }
        return group;
    }
private:
    int find(int x, vector<int>& pre)
    {
        //“pre[x] = ”这句为路径压缩，直接指向组的根节点，下次查询时就快很多了。
        return pre[x]==x ? x : pre[x] = find(pre[x], pre);
    }
};
```

### 解法二：BFS

时间复杂度 O(n²)

> 可以将题目转换为是在一个图中求连通子图的问题，给出的 N\*N 的矩阵就是邻接矩阵，建立 N 个节点的 visited 数组，从 not visited 的节点开始深度优先遍历，遍历就是在邻接矩阵中去遍历，如果在第 i 个节点的邻接矩阵那一行中的第 j 个位置处 M[i][j]==1 and not visited[j]，就应该 dfs 到这个第 j 个节点的位置，

```java
public class Solution {
    public void dfs(int[][] M, int[] visited, int i) {
        for (int j = 0; j < M.length; j++) {
            if (M[i][j] == 1 && visited[j] == 0) {
                visited[j] = 1;
                dfs(M, visited, j);
            }
        }
    }
    public int findCircleNum(int[][] M) {
        int[] visited = new int[M.length];
        int count = 0;
        for (int i = 0; i < M.length; i++) {
            if (visited[i] == 0) {
                dfs(M, visited, i);
                count++;
            }
        }
        return count;
    }
}
```

# 毎日一题 - 417. 太平洋大西洋水流问题

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/pacific-atlantic-water-flow

* tag：`Backtracking` `DFS`

## 题目描述

给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

提示：

输出坐标的顺序不重要
m 和 n 都小于 150

示例：

```
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
```

## 参考答案

- 方法 1：直接采用回溯法 超时

直接判断 水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标
采用方法是
回溯法(英语：backtracking)是暴力搜索法中的一种。
在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
在这个题目中，这个题目中正好就是如此。
因为需要等到上下左右全部计算完毕才有确定答案。

m 和 n =150，肯定超时。

- 方法 2：动态规划+回溯法

思路：

总体思路还是回溯，我们对能够流入太平洋的(第一行和第一列)开始进行上下左右探测。

同样我们对能够流入大西洋的(最后一行和最后一列)开始进行上下左右探测。

最后将探测结果进行合并即可。合并的条件就是当前单元既能流入太平洋又能流入大西洋。

![集合](https://user-images.githubusercontent.com/5937331/63209454-7c921a80-c113-11e9-8d74-82d0476b8828.png)
扩展：

如果题目改为能够流入大西洋或者太平洋，我们只需要最后合并的时候，条件改为求或即可

## 参考代码

- JavaScript Code

```js
function dfs(i, j, height, m, matrix, rows, cols) {
    if (i >= rows || i < 0) return;
    if (j >= cols || j < 0) return;

    if (matrix[i][j] < height) return;

    if (m[i][j] === true) return;

    m[i][j] = true;

    dfs(i + 1, j, matrix[i][j], m, matrix, rows, cols);
    dfs(i - 1, j, matrix[i][j], m, matrix, rows, cols);
    dfs(i, j + 1, matrix[i][j], m, matrix, rows, cols);
    dfs(i, j - 1, matrix[i][j], m, matrix, rows, cols);
}
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var pacificAtlantic = function(matrix) {
    const rows = matrix.length;
    if (rows === 0) return [];
    const cols = matrix[0].length;
    const pacific = Array.from({
        length: rows
    },
    () = >Array(cols).fill(false));
    const atlantic = Array.from({
        length: rows
    },
    () = >Array(cols).fill(false));
    const res = [];

    for (let i = 0; i < rows; i++) {
        dfs(i, 0, 0, pacific, matrix, rows, cols);
        dfs(i, cols - 1, 0, atlantic, matrix, rows, cols);
    }

    for (let i = 0; i < cols; i++) {
        dfs(0, i, 0, pacific, matrix, rows, cols);
        dfs(rows - 1, i, 0, atlantic, matrix, rows, cols);
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (pacific[i][j] === true && atlantic[i][j] === true) res.push([i, j]);
        }
    }

    return res;
};
```

- C++ Code

  ```
  class Solution {
  public:
  	vector<vector<int> > pacificAtlantic( vector<vector<int> > & matrix )
  	{
  		vector<vector<int> >	out;
  		int			row = matrix.size();
  		if ( 0 == row )
  			return(out);
  		int col = matrix[0].size();
  		if ( 0 == col )
  			return(out);

  		/* 能流动到“太平洋"的陆地 */
  		vector<vector<bool> > dp1( row, vector<bool>( col, false ) );
  		/* 能流动到“大西洋"的陆地 */
  		vector<vector<bool> > dp2( row, vector<bool>( col, false ) );

  		/* 从第一行/最后一行出发寻找连同节点，不变的x坐标 */
  		for ( int j = 0; j < col; j++ )
  		{
  			dfs( 0, j, INT_MIN, matrix, dp1 );
  			dfs( row - 1, j, INT_MIN, matrix, dp2 );
  		}
  		/* 从第一列/最后一列出发寻找连同节点,不变的y坐标 */
  		for ( int i = 0; i < row; i++ )
  		{
  			dfs( i, 0, INT_MIN, matrix, dp1 );
  			dfs( i, col - 1, INT_MIN, matrix, dp2 );
  		}

  		vector<int> temp( 2 );
  		for ( int i = 0; i < row; i++ )
  		{
  			for ( int j = 0; j < col; j++ )
  			{
  				/* 请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 */
  				if ( dp1[i][j] == true && dp2[i][j] == true )
  				{
  					temp[0] = i;
  					temp[1] = j;
  					out.push_back( temp );
  				}
  			}
  		}
  		return(out);
  	}
  ```

void dfs( int row, int col, int height,
vector<vector<int> > & matrix, vector<vector<bool> > & visited )
{
if ( row < 0 || row >= matrix.size() ||
col < 0 || col >= matrix[0].size()
)
{
return;
}

if ( visited[row][col] == true )
{
return;
}

if ( height > matrix[row][col] )
{
return;
}

visited[row][col] = true;

dfs( row + 1, col, matrix[row][col], matrix, visited );
dfs( row - 1, col, matrix[row][col], matrix, visited );
dfs( row, col + 1, matrix[row][col], matrix, visited );
dfs( row, col - 1, matrix[row][col], matrix, visited );
}
};

```


#### 字符串首尾相等的最长子串

## 信息卡片


- 题目链接：无
- tag：`String` `Hash Table`

## 题目描述

```

求一个字符串首尾相等的最长子串，例如 abcba，最长就是 abcba

````

## 参考答案

思路:

头尾两个字母相同的子串，比如 abca，这里头尾相同的就是 a..a 子串，它的长度就是这两个 a 的下标之差+1；

如果是 abcadefa，这里有三个 a，那么这个子串的长度是第一个 a 和最后一个 a 的下标之差+1；

这时候规律就来了，那我只要计算同一个字母第一次出现和最后一次出现的位置就好了嘛，最后再求个最大值；

那这样的话，我们只要一次遍历，用一个 map 把这些位置记下来即可。

但是仔细想想，我存同一个字母的这么多位置，好像最后我也只取这个位置集合的第一个和最后一个啊，那我为什么还要存这么多，存起始位置就好了嘛！
每次遍历到第 2,3,4 个相同字母的时候，我都减去第一个此字母位置的下标再看看这个差值是不是最大的。
所以代码来了：

JavaScript Code:

```js
var LES = function(str) {
  var map = {}; // 用来存储遍历到的字母出现的第一个位置
  var maxLen = 1; // 初始化最大子串长度
  var substrStartIndex = 0; // 最长子串的起始位置
  for (var i = 0; i < str.length; i++) {
    var char = str[i];
    if (map[char] != null) {
      // 如果这个字母之前已经出现过了
      if (i - map[char] + 1 > maxLen) {
        // 那么计算当前这个字母到第一次出现的位置距离，然后比较
        maxLen = i - map[char] + 1;
        substrStartIndex = map[char]; // 如果是最大值，记录下当前最大子串的起始位置
      }
    } else {
      map[char] = i; // 如果这个字母之前没出现过，那么记下它的下标
    }
  }

  return str.slice(substrStartIndex, substrStartIndex + maxLen);
};
````

##### 593. 有效的正方形

- 题目链接：https://leetcode.com/problems/top-k-frequent-elements/description/
- tag：`Hash Table` `Heap`

### 题目描述

```
Given a non-empty array of integers, return the k most frequent elements.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Example 2:


Input: nums = [1], k = 1
Output: [1]

Note:

You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is
the array's size.
```

### 参考答案

模仿 [@raof01](https://github.com/raof01) 的思路写的 JS 代码，

基本思路就是： 证明四个角都是直角， 而证明直角的方式就是边长关系。

四个点一共有六个连接的线段，其中两个是对角线，另外四个是边。

对于直角来说，满足“a _ a + b _ b = c _ c”, 由于是正方形，所以 a = b， 因此 c 就等于
2 _ a \* a , 其中 a 为边长，c 就是对角线的长度。

我们分别计算出距离的平方，如果有四个相同，另外两个相同。 且二者的关系可以满足直角，那么他就有四个直角，他就是一个正方形

```js
/*
 * @lc app=leetcode id=593 lang=javascript
 *
 * [593] Valid Square
 */
function square(p1, p2) {
  const deltaX = p1[0] - p2[0];
  const deltaY = p1[1] - p2[1];

  return deltaX * deltaX + deltaY * deltaY;
}
/**
 * @param {number[]} p1
 * @param {number[]} p2
 * @param {number[]} p3
 * @param {number[]} p4
 * @return {boolean}
 */
var validSquare = function(p1, p2, p3, p4) {
  // 证明四个角都是直角
  // 证明直角的方式就是边长关系
  const squares = [square(p1, p2), square(p1, p3), square(p1, p4), square(p2, p3), square(p2, p4), square(p3, p4)];
  let cnt1 = 0;
  let cnt2 = 0;
  let sum = 0;

  for (let i = 0; i < squares.length; i++) {
    sum += squares[i];
  }

  for (let i = 0; i < squares.length; i++) {
    if (sum === 8 * squares[i]) {
      cnt1++;
    } else if (sum === 4 * squares[i]) {
      cnt2++;
    }
  }

  return cnt1 === 4 && cnt2 === 2;
};
```

### 其他优秀解答

暂无

# 毎日一题 - 桶中取黑白球

## 信息卡片

- tag：`Math` `位运算`

## 题目描述

```
有一个桶，里面有白球，黑球各100个，你必须用以下规则将球取出来：
- 每次从桶里取两个球
- 如果两个球是相同的颜色，那么再放一个黑球
- 如果两个球是不同的颜色，那么再放一个白球。
问：最后一个球是黑球的概率是多少？
```

## 参考答案

### 1. 数学分析原问题

首先我们来仔细读题看看我们有哪些知道的信息：

- 不管什么情况，每次球的总数减 1；
- 两黑：黑球-1，白球 0；
- 两白：黑球+1，白球-2；
- 一黑一白：黑球-1，白球 0；
- 最后两球只要不是一黑一白，最后一球都是黑；

初始状态是 100 个黑球和 100 个白球，从上面三个状态可知道，黑球要么+1 要么-1，而白球要么不变要么-2；在 198 次取球后，我们可知剩余两个球，现在假设剩余的两球为一黑一白，可以证明这是不存在的。

因为白球下降是以 2 的倍数下降，不可能从 100 下降至 1,；故剩余两球肯定不是一黑一白的情况，那么最后一球的情况必然为黑。

### 2. 原问题拓展(n 个黑球和 m 个白球)

在 n+m-2 次取球后，剩余两个球。

由于我们知道白球数下降是以 2 的倍数下降，如果 m 为偶数的话，是不可能下降至 1；即同上 1，最后一球必为黑球。如果 m 为奇数的话，最后必然是 k 黑 1 白(k>=1)，显然对于任意的 k，要么剩余全是黑球，要么黑球不断减 1，最后变为 1 黑 1 白。全黑和 1 黑 1 白最后的结果都是剩余一个白球。

得出结论，最后一球结果无关黑球数量(n>=0),仅与白球数量 m 有关。

- 如果白球 m 为奇数，最后一球必然白；
- 如果白球 m 为偶数，最后一球必然黑；

### 3. 抽象为数学模型，严格证明

不妨设黑球为 0，白球为 1；

- 两黑：F(0,0) = 0；表示两个黑球生一黑；
- 两白：F(1,1) = 0；表示两个白球生一黑；
- 一黑一白：F(0,1) = 0；表示一个黑球一个白球生一白；

仔细观察就会发现这个函数 F 就是 XOR(异或)；

那么 m 个黑球和 n 个白球，就抽象为 m 个 0 和 n 个 1 作异或的结果；而且我们可知异或满足结合律和交换律(证明略，最简单的证明方法枚举)。

那么问题就很简单，对于任意多 0，异或结果依然是 0，所以对于任意多 1，只需要考虑 1 个数的奇偶性就可判断最后剩余 1 个 1 还是 0 个 1；

结论同 2：

- 1(白球)的个数奇数，最后异或结果为 1；
- 1(白球)的个数偶数，最后异或结果为 0；

# 毎日一题 - 水壶问题

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/water-and-jug-problem/
- tag：`Math`

## 题目描述

```
给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。
```

## 参考答案

1.数学分析解答

上面的问题是一个特例，我们可以抽象为[leetcode-365-水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)。

```
有两个容量分别为 x升 和 y升 的水壶(壶1，壶2)以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？
```

解题核心思路(x < y，即壶 1 容量小于壶 2，x == y 的情况后面讨论)：

1. 将壶 2 倒满，往壶 1 倒入至满。
2. 若壶 1 满，记录当前壶 2 中新水量。壶 1 倒出，将壶 2 中剩余的继续往壶 1 中倒入；(当壶 1 满，继续此操作，并记录当前壶 2 中新水量 nw， 若此新水量已被记录，则)。
3. 若出现壶 1 不满时(即此时壶 2 必空)，重复操作 1。

开辟一个新数组 nws 记录所有新水量，对任意 nws[i]，可构造的水量为 nws[i]，nws[i]+x，nws[i]+y。

(其实不需要新数组，因为数学上可以证明新水量的值循环周期呈现，故可以使用一个临时变量 cur，当 cur==x 为终止条件)

数学证明新水量 nw 值是循环周期的：
![1111](https://raw.githubusercontent.com/lvguofeng1303/markdownimage/master/daily/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/math%20prove.jpg)

个别特殊情况考虑：

- x == z || y == z; **true**
- x == 0 || x+y < z; **false**
- x+y == z || z == 0; **true**

```
class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        if(x > y) return canMeasureWater(y, x, z);
        if(x == z || y == z) return true;
        if(x == 0 || x+y < z) return false;
        if(x+y == z || z == 0) return true;
        int cur = y - x;
        while(cur != x){
            if(cur == z) return true;
            if(cur > x){
                if(cur + x == z) return true;
                cur = cur - x;
            }
            else{
                if(cur + y == z || cur + x == z) return true;
                cur = y - x + cur;
            }
        }
        return false;
    }
};
```

2.BFS

不仅可以计算是否能获取 z 升水，而且可以获得最少多少操作可获取 z 升水。(缺点，无法通过，因为需要太大的空间，需要申请一个三维数组记录状态)

核心思想就是状态转移问题：

壶 0(x+y)，壶 1(x)，壶 2(y)，壶 0 是本是无限大水池，同理于定义为大小为 x+y 的壶。用 bfs 的思想，使用一个队列记录所有新的状态。

对于任意状态(c，a，b)，状态转移就是：

- 若 c 不为 0，将壶 0 倒水入壶 1 或壶 2；若 a 不为 0，将壶 1 倒水入壶 0 或壶 2；若 b 不为 0，将壶 2 倒水入壶 0 或壶 1；
- 记录每个新状态，并入队，若此状态访问过则不入队。

特殊情况考虑同 1。

```
class Solution {
public:
    struct state{
        int nums[3];
        state(int xy, int x, int y){
            nums[0] = xy;
            nums[1] = x;
            nums[2] = y;
        }
    };

    state pour_water(state cur, int src, int det, int size[]){
        state ans = cur;
        int need_w = size[det] - cur.nums[det];
        if(need_w <= cur.nums[src]){
            ans.nums[det] += need_w;
            ans.nums[src] -= need_w;
        }
        else{
            ans.nums[det] += ans.nums[src];
            ans.nums[src] = 0;
        }
        return ans;
    }

    bool canMeasureWater(int x, int y, int z) {
        if(x > y) return canMeasureWater(y, x, z);  //
        if(x == z || y == z) return true;
        if(x == 0 || x+y < z) return false;
        if(x+y == z || z == 0) return true;
        int visited[x+y+1][x+1][y+1];
        int water_size[3] = {x+y, x, y};
        memset(visited, 0, sizeof(visited));
        state cur(x+y, 0, 0);
        queue<state> q;
        q.push(cur);
        int step = 0;
        while(!q.empty()){
            int size = q.size();
            while(size){
                state temp(0, 0, 0);
                cur = q.front();
                if(cur.nums[1] + cur.nums[2] == z) return true;
                visited[cur.nums[0]][cur.nums[1]][cur.nums[2]] = 1;
                q.pop();
                if(cur.nums[0] != 0){
                    temp = pour_water(cur, 0, 1, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                    temp = pour_water(cur, 0, 2, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                }
                if(cur.nums[1] != 0){
                    temp = pour_water(cur, 1, 2, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                    temp = pour_water(cur, 1, 0, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                }
                if(cur.nums[2] != 0){
                    temp = pour_water(cur, 2, 1, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                    temp = pour_water(cur, 2, 0, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                }
                size--;
            }
            step++;
        }
        return false;
    }
};
```

# 毎日一题 - 版本号比较

## 信息卡片

- 题目链接：<https://leetcode-cn.com/problems/compare-version-numbers/>
- tag：`String`

## 题目描述

```
比较两个版本号 version1 和 version2。
如果 version1 > version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。

你可以假设版本字符串非空，并且只包含数字和 . 字符。

 . 字符不代表小数点，而是用于分隔数字序列。

例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。

你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级(大版本)和第二级(小版本)修订号分别为 3 和 4。其第三级和第四级修订号均为 0。

示例 1:

输入: version1 = "0.1", version2 = "1.1"
输出: -1
示例 2:

输入: version1 = "1.0.1", version2 = "1"
输出: 1
示例 3:

输入: version1 = "7.5.2.4", version2 = "7.5.3"
输出: -1
示例 4：

输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。
示例 5：

输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。

提示：

版本字符串由以点 (.) 分隔的数字字符串组成。这个数字字符串可能有前导零。
版本字符串不以点开始或结束，并且其中不会有两个连续的点。
```

## 参考答案

### 1. 递归解决

其实这个问题其实简化后就是依次比较每一个修订版本大小，所以问题有以下几点：

1. 获取每个修订版本号大小；
2. 处理每个修订版本号前导零问题；
3. 处理不同版本有不同次数修订版本；

问题 1：这个如果对字符串处理比较熟悉的会比较简单，直接遍历循环找到第一个逗号 first_dot(找不到的情况设为-1)，str.substr(0, first_dot)即可。针对第二，第三个逗号，我们用递归的方案回避，这样每次我们都相当于找第一个逗号前的数字。

问题 2：前导零问题更容易解决，在遍历过程中找到第一个非零数 first_no_zero，str.substr(first_no_zero, first_dot - first_no_zero)。当然更简单的方案是定义初值 v1 = 0，每次计算 v1 = v1\*10 + str[i] - 'a'

问题 3：针对不同次数的修订版本，我们可以在字符串末尾填 0 表示。即有一个版本号 first_dot = -1。

代码如下：

```
class Solution {
public:
    int first_num(string str, int& first_dot){
        int v1 = 0;
        first_dot = -1;
        for(int i = 0; i < str.size(); i++){
            if(str[i] == '.'){
                first_dot = i;
                break;
            }
            else
                v1 =  v1 * 10 + (str[i] - '0');
        }
        return v1;
    }

    int compareVersion(string version1, string version2) {
        int v1 = 0, v2 = 0;
        int v1_first_dot, v2_first_dot;
        v1 = first_num(version1, v1_first_dot);
        v2 = first_num(version2, v2_first_dot);
        if(v1 > v2)
        	return 1;
        else if(v1 < v2)
        	return -1;
        else{
            if(v1_first_dot == -1 && v2_first_dot == -1)
             	return 0;
            if(v1_first_dot == -1)
              	version1 = "0";
            else
              	version1 = version1.substr(v1_first_dot+1);
            if(v2_first_dot == -1)
              	version2 = "0";
            else
              	version2 = version2.substr(v2_first_dot+1);
            return compareVersion(version1, version2);
        }
    }
};

```

### 2. 数组

解析每个版本号，放入数组，依次比较大小。

```c
int compareVersion(char * version1, char * version2){
    if (version1 == NULL || version2 == NULL) return -1;
    int *val1 = (int *)calloc(1024, sizeof(int));
    int *val2 = (int *)calloc(1024, sizeof(int));
    int len1 = strlen(version1), top1 = 0;
    int len2 = strlen(version2), top2 = 0;
    int i, n;
    for (i = 0, n = 0; i < len1; ++i) {  //解析版本1
        if (version1[i] == '.') {
            val1[top1++] = n;
            n = 0;
        }else n = n*10 + (version1[i] & 0x0f);
    }
    val1[top1++] = n;
    for (i = 0, n = 0; i < len2; ++i) {  //解析版本1
        if (version2[i] == '.') {
            val2[top2++] = n;
            n = 0;
        }else n = n*10 + (version2[i] & 0x0f);
    }
    val2[top2++] = n;
    for (i = 0; i < top1 && i < top2; ++i) {  //比较版本大小
        if      (val1[i] > val2[i]) return 1;
        else if (val1[i] < val2[i]) return -1;
    }
    if (i < top1) {  //由于可能有的版本还没遍历完
        while (i < top1) if (val1[i++]) return 1;  //只要版本后面的数字出现的不是0，就意味着两个版本不一样
    }else{
        while (i < top2) if (val2[i++]) return -1;
    }
    return 0;
}
//作者：ljj666
//链接：https://leetcode-cn.com/problems/compare-version-numbers/solution/cyu-yan-jian-jian-dan-dan-de-ji-xing-dai-ma-jie-37/
//来源：力扣(LeetCode)
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# 毎日一题 - 反转每对括号间的子串

## 信息卡片

- 题目链接：https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses
- tag：`String` `Backtracking`

## 题目描述

```
给出一个字符串 s(仅含有小写英文字母和括号)。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。



示例 1：

输入：s = "(abcd)"
输出："dcba"
示例 2：

输入：s = "(u(love)i)"
输出："iloveu"
示例 3：

输入：s = "(ed(et(oc))el)"
输出："leetcode"
示例 4：

输入：s = "a(bcdefghijkl(mno)p)q"
输出："apmnolkjihgfedcbq"


提示：

0 <= s.length <= 2000
s 中只有小写英文字母和括号
我们确保所有括号都是成对出现的
```

## 参考答案

#### 思路

1. 对字符串中的字符遍历

2) 括号是有层次性的，所以这里用递归的方式处理内层的字符串，内层处理完成后回溯。返回内层有括号索引的下一个位置，以及括号内反转完成后的字符串。

3. 在 2 的递归过程中，原字符串也需要作为递归方法的参数传递进来

4) 递归方法的负责处理从当前位置开始到遇到对应的有括号之间的字符串，将其反转；若遇到新的左括号，创建临时的 StringBuilder 用于记录递归方法内反转的字符串，进入新的一层递归；递归完成后临时 StringBuilder 被填充并且是反转后的结果，append 到上一层递归的 StringBuilder 中。

5. 递归回溯到最上层时，StringBuilder 即为最终结果。

6) 更多代码细节可以关注下代码注释

#### 代码如下

```java
package com.jinyang.algorithms.string;

/**
 * Created by Zhang.Jinyang&Hardy on 2019/10/17.
 */
public class ReverseParentheses {

  public static void main(String[] args) {

    /**
     * 用例的类型
     * (ab(cd)ef)
     * ab(cd)
     * ab(cd)ef
     * ((ab)c)def
     * abc(d(ef))
     * */
    String s = "ab((cd)ef)";

    StringBuilder builder = new StringBuilder();
    reverseParentheses(s, 0, builder, 0);
    System.out.println(builder.toString());
  }

  /**
   * leetcode  1190
   * 耗时 1ms
   * 内存消耗  34.6M
   * */
  static int reverseParentheses(String s, int index, StringBuilder stringBuilder, int leftCount) {


    //遍历字符串
    while (index < s.length()) {
      /**
       * case 当前字符为'('
       *      leftCount++; 记录已遍历 但未 找到相对应的右括号 的左括号数目；这里每当当前字符为'('，leftCount+1
       *      case: index 为 0，第一个字符为'('
       *            index ++, 继续遍历
       *      case：index 不为0， 不是第一个字符
       *            递归，index++，new stringBuilder(临时存放从当前'('到其相对应的')'里的字符,不包含'('和')'), leftCount
       *            递归后，new stringBuilder已被填充好 从当前'('到其相对应的')'里的字符 反转后的字符串；且返回参数为下一次要访问的字符下标index
       *            leftCount --；因为进入递归后返回时已经将 当前'(' 与其响应的 ')' 内的字符反转，所以左括号数减1
       *            递归前的 stringBuilder append 递归后，已反转的 new stringBuilder
       *            继续遍历.
       * */
      if (s.charAt(index) == '(') {
        leftCount++;
        if (index != 0) {
          StringBuilder sTemp = new StringBuilder();
          index = reverseParentheses(s, index + 1, sTemp, leftCount);
          leftCount--;
          stringBuilder.append(sTemp);
          continue;
        }

        index++;
        continue;
      }

      /**
       * case 当前字符为')'
       *     反转stringBuilder里的字符位置；
       *     index++；
       *     case：当前leftCount >1 那么当前是在递归过程中
       *          return index;//回溯
       *     case: 当前leftCount <=1 当前不是递归
       *          继续遍历;
       * */
      if (s.charAt(index) == ')') {
        stringBuilder.reverse();
        index++;
        if (leftCount > 1) {
          return index;
        } else {
          continue;
        }
      }

      /**当前字符不是'(' 或 ')'
       * 当前stringBuilder append 当前下标对应的字符
       * index++
       * 继续遍历
       * */
      stringBuilder.append(s.charAt(index));
      index++;
    }
    return index;
  }


}


```

# 毎日一题 - 拼凑硬币

## 信息卡片

- 题目链接：腾讯真题
- tag：`Bit` `DP`

## 题目描述

```
小Q十分富有，拥有非常多的硬币，小Q拥有的硬币是有规律的，对于所有的非负整数K，小Q恰好各有两个面值为2^k的硬币，所有小Q拥有的硬币就是1，1，2，2，4，4，8，8.....小Q有一天去商店购买东西需要支付n元钱，小Q想知道有多少种方案从他拥有的硬币中选取一些拼凑起来恰好是n元(如果两种方案某个面值的硬币选取的个数不一样就考虑为不一样的方案)
```

## 参考答案

### 1. 二进制方案

#### 分析

集合：和为 n 的可选数据集，在本题中就是可选的硬币面值：1，1，2，2，4… 以下统一称为**集合**

1. 由集合中元素的特点可以联想到 **二进制**。如果将集合中的所有元素都用二进制来表示的话：

   1 等于 2 的 0 次方 等于 二进制的 1
   2 等于 2 的 1 次方 等于 二进制的 10
   4 等于 2 的 2 次方 等于 二进制的 100
   ...
   即：
   1=2^0=(1)2; 2=2^1=(10)2; 4 = 2^2 = (100)2;..... .**(等号最后的数都是二进制表示法)**

   集合中的每一个元素都可以表示为 首位为 1 其他位为 0 的二进制数。

2. 集合中元素是成对出现的，那么可以将集合拆分为完全相同的两部分, 每一个数都可以由二进制中指定位置的 1 来表示：

   8 4 2 1 —> 1 1 1 1

   8 4 2 1 —> 1 1 1 1

   那么，若目标数 n 为 11.那么 11 = 1 + 10 = 2 + 9 = 3 + 8 = 4 + 7 = 5 + 6；

   **a.** 以 **1 + 10** 为例 ： 1 的 二进制 1， 10 的二进制为 1010 那么 (11) 就相当于

   取 二进制数 第一位的 1， 第四位的 1 ，第 2 位的 1 [**从右往左**]

   即可组成 十进制的 11。

   **b.** **2 + 9 = (10)2+ (1001)2** ： 取第二位的 1， 第四位的 1， 从第一位的 1 [**从右往左**]

   同理：

   **c.** **3 + 8= (11)2+(1000)2**

   **d.** **4 + 7 = (100)2+(111)2**

   **e.** **5 + 6=(101)2+(110)2**

   > a 和 b ,c 中 其实是同一种方案。可通过**异或运算**进行去重：
   >
   > 比如，这三组方案的异或结果是相同的。1^10 == 2^9 == 3^8 == (1011)2
   >
   > d,e 也是同一种方案

#### 思路

1. 从 i=0 开始**(如果 n=4 那么 0+4 也是一种方案，只不过只选择一个 4 而已)**，i<=(n/2), 每次 i+1 循环开始：循环中将 i^(n-i)的值放到 Set(无重复元素)中
2. **最终**求 Set 的 size 大小。就是最终的方案数。

代码如下：

```
import java.util.HashSet;
import java.util.Set;

public class CoinsOfQy {

  /**测试*/
  public static void main(String[] args) {

    int n = 11;
    int result = coinsOfQy(n);
    System.out.println(result);
  }

  private static int coinsOfQy(int n) {

    Set<Integer> resultSet = new HashSet<>();
    for (int i =0; i<= n/2; i++){
      int r = i^(n-i);
      resultSet.add(r);
    }
    return resultSet.size();
  }
}

```

# 134.gas-station

```js
/*
 * @lc app=leetcode id=134 lang=javascript
 *
 * [134] Gas Station
 */

function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad 时间复杂度O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution 时间复杂度O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // 如果remain < 0, 说明从start到i走不通
    // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
    // 因此我们重新从i + 1开始作为start
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

  // 如果cost总和大于gas总和，无论如何也无法走到终点
  return total >= 0 ? start : -1;
};
```

# 460.lfu-cache

```js
/*
 * @lc app=leetcode id=460 lang=javascript
 *
 * [460] LFU Cache
 */
/**
 * @param {number} capacity
 */
var LFUCache = function(capacity) {
  this.capacity = capacity;
  this.size = 0;
  this.cache = {};
  this.timestamp = 0;
};

/**
 * @param {number} key
 * @return {number}
 */
LFUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit === void 0) {
    return -1;
  }
  hit.count += 1;
  hit.timestamp = this.timestamp++;

  return hit.value;
};

// 时间复杂度O(n)   n其实就是capacity
LFUCache.prototype.evicted = function() {
  // evicted lfu
  let leastCountKey = null;
  let min = Number.MAX_VALUE;

  for (const k in this.cache) {
    const item = this.cache[k];
    if (item.count < min) {
      leastCountKey = k;
      min = item.count;
    } else if (item.count === min && item.timestamp < this.cache[leastCountKey].timestamp) {
      leastCountKey = k;
      min = item.count;
    }
  }

  delete this.cache[leastCountKey];
  this.size--;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LFUCache.prototype.put = function(key, value) {
  if (this.capacity === 0) return;
  const hit = this.cache[key];

  if (hit === void 0) {
    if (this.capacity === this.size) {
      this.evicted();
    }
    this.size++;
    return (this.cache[key] = {
      value,
      timestamp: this.timestamp++,
      count: 1,
    });
  }

  this.cache[key].value = value;
  this.cache[key].timestamp = this.timestamp++;
  return (this.cache[key].count += 1);
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * var obj = new LFUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

# 54.spiral-matrix

```js
/*
 * @lc app=leetcode id=54 lang=javascript
 *
 * [54] Spiral Matrix
 */
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
  // https://leetcode.com/problems/spiral-matrix/discuss/20570/Clean-Java-readable-human-friendly-code
  // brilliant!
  const res = [];
  if (matrix.length == 0) return res;

  let top = 0;
  let bottom = matrix.length - 1;
  let left = 0;
  let right = matrix[0].length - 1;

  while (true) {
    for (let i = left; i <= right; i++) res.push(matrix[top][i]);
    top++;
    if (top > bottom) break;

    for (let i = top; i <= bottom; i++) res.push(matrix[i][right]);
    right--;
    if (left > right) break;

    for (let i = right; i >= left; i--) res.push(matrix[bottom][i]);
    bottom--;
    if (top > bottom) break;

    for (let i = bottom; i >= top; i--) res.push(matrix[i][left]);
    left++;
    if (left > right) break;
  }

  return res;
};
```

# 594.longest-harmonious-subsequence

```js
/*
 * @lc app=leetcode id=594 lang=javascript
 *
 * [594] Longest Harmonious Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLHS = function(nums) {
  // Input: [1,3,2,2,5,2,3,7]
  // Output: 5
  // Explanation: The longest harmonious subsequence is [3,2,2,2,3].
  if (nums.length === 0) return 0;
  const counts = {};
  let res = 0;

  for (let i = 0; i < nums.length; i++) {
    if (!counts[nums[i]]) {
      counts[nums[i]] = 1;
    } else {
      counts[nums[i]] += 1;
    }
  }

  for (let i = 0; i < nums.length; i++) {
    if (counts[nums[i] + 1]) {
      res = Math.max(res, counts[nums[i]] + counts[nums[i] + 1]);
    }
  }

  return res;
};
```

# 1011.capacity-to-ship-packages-within-d-days

## 题目地址(1011. 在 D 天内送达包裹的能力)

https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days

## 题目描述

传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i  个包裹的重量为  weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。

示例 1：

输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。
示例 2：

输入：weights = [3,2,2,4,1,4], D = 3
输出：6
解释：
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4
示例 3：

输入：weights = [1,2,3,1,1], D = 4
输出：3
解释：
第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1

提示：

1 <= D <= weights.length <= 50000
1 <= weights[i] <= 500

## 思路

这道题和[猴子吃香蕉](https://github.com/azl397985856/leetcode/blob/master/problems/875.koko-eating-bananas.md) 简直一摸一样，没有看过的建议看一下那道题。

像这种题如何你能发现本质的考点，那么 AC 是瞬间的事情。 这道题本质上就是从 1，2，3，4，。。。total(其中 toal 是总的货物重量)的有限离散数据中查找给定的数。这里我们不是直接查找 target，而是查找恰好能够在 D 天运完的载货量。

- 容量是 1 可以运完么？
- 容量是 2 可以运完么？
- 容量是 3 可以运完么？
- 。。。
- 容量是 total 可以运完么？(当然可以，因为 D 大于等于 1)

上面不断询问的过程如果回答是 yes 我们直接 return 即可。如果回答是 no，我们继续往下询问。

这是一个典型的二分问题，只不过我们的判断条件略有不同，大概是：

```python
def canShip(opacity):
    # 指定船的容量是否可以在D天运完
lo = 0
hi = total
while lo < hi:
    mid = (lo + hi) // 2
    if canShip(mid):
        hi = mid
    else:
        lo = mid + 1

return lo

```

## 关键点解析

- 能够识别出是给定的有限序列查找一个数字(二分查找)，要求你对二分查找以及变体十分熟悉

## 代码

```python
class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        lo = 0
        hi = 0

        def canShip(opacity):
            days = 1
            remain = opacity
            for weight in weights:
                if weight > opacity:
                    return False
                remain -= weight
                if remain < 0:
                    days += 1
                    remain = opacity - weight
            return days <= D

        for weight in weights:
            hi += weight
        while lo < hi:
            mid = (lo + hi) // 2
            if canShip(mid):
                hi = mid
            else:
                lo = mid + 1

        return lo
```

## 扩展

## 参考

# 1014.best-sightseeing-pair

## 题目地址(1014. 最佳观光组合)

https://leetcode-cn.com/problems/best-sightseeing-pair/description/

## 题目描述

给定正整数数组  A，A[i]  表示第 i 个观光景点的评分，并且两个景点  i 和  j  之间的距离为  j - i。

一对景点(i < j)组成的观光组合的得分为(A[i] + A[j] + i - j)：景点的评分之和减去它们两者之间的距离。

返回一对观光景点能取得的最高分。

示例：

输入：[8,1,5,2,6]
输出：11
解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11

提示：

2 <= A.length <= 50000
1 <= A[i] <= 1000

## 思路

最简单的思路就是两两组合，找出最大的，妥妥超时，我们来看下代码：

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        res = 0
        for i in range(n - 1):
            for j in range(i + 1, n):
                res = max(res, A[i] + A[j] + i - j)
        return res
```

我们思考如何优化。 其实我们可以遍历一遍数组，对于数组的每一项`A[j] - j` 我们都去前面找`最大`的 A[i] + i (这样才能保证结果最大)。

我们考虑使用动态规划来解决, 我们使用 dp[i] 来表示 数组 A 前 i 项的`A[i] + i`的最大值。

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        dp = [float('-inf')] * (n + 1)
        res = 0
        for i in range(n):
            dp[i + 1] = max(dp[i], A[i] + i)
            res = max(res, dp[i] + A[i] - i)
        return res
```

如上其实我们发现，dp[i + 1] 只和 dp[i] 有关，这是一个空间优化的信号。我们其实可以使用一个变量来记录，而不必要使用一个数组，代码见下方。

## 关键点解析

- 空间换时间
- dp 空间优化

## 代码

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        pre = A[0] + 0
        res = 0
        for i in range(1, n):
            res = max(res, pre + A[i] - i)
            pre = max(pre, A[i] + i)
        return res
```

## 小技巧

Python 的代码如果不使用 max，而是使用 if else 效率目测会更高，大家可以试一下。

```python
class Solution:
    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        n = len(A)
        pre = A[0] + 0
        res = 0
        for i in range(1, n):
            # res = max(res, pre + A[i] - i)
            # pre = max(pre, A[i] + i)
            res = res if res > pre + A[i] - i else pre + A[i] - i
            pre = pre if pre > A[i] + i else A[i] + i
        return res
```

# 1015.smallest-integer-divisible-by-k

## 题目地址

https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/description/

## 题目描述

```
给定正整数 K，你需要找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。

返回 N 的长度。如果不存在这样的 N，就返回 -1。



示例 1：

输入：1
输出：1
解释：最小的答案是 N = 1，其长度为 1。
示例 2：

输入：2
输出：-1
解释：不存在可被 2 整除的正整数 N 。
示例 3：

输入：3
输出：3
解释：最小的答案是 N = 111，其长度为 3。


提示：

1 <= K <= 10^5

```

## 思路

这道题是说给定一个 K 值，能否找到一个形如 1，11，111，1111 。。。 这样的数字 n 使得 n % K == 0。

首先容易想到的是如果 K 是 2，4，5， 6，8 结尾的话，一定是不行的。直观的解法是从 1，11，111，1111 。。。 这样一直除下去，直到碰到可以整除的，我们返回即可。 但是如果这个数字根本就无法整除怎么办？没错，我们会无限循环下去。我们应该在什么时刻跳出循环，返回 - 1 (表示不能整除)呢？

我们拿题目给出的不能整除的 2 来说。

- 1 // 2 等于 1
- 11 // 2 等于 1
- 111 // 2 等于 1
- ...

我们再来一个不能整除的例子 6:

- 1 // 6 等于 1
- 11 // 6 等于 5
- 111 // 6 等于 3
- 1111 // 6 等于 1
- 11111 // 6 等于 5
- ...

通过观察我们发现不断整除的过程，会陷入无限循环，对于 2 来说，其循环节就是 1。对于 6 来说，其循环节来说就是 153。而且由于我们的分母是 6，也就是说余数的可能性一共只有六种情况 0,1,2,3,4,5。

上面是感性的认识， 接下来我们从数学上予以证明。上面的算法用公式来表示就是`mod = (10 \* mod + 1) % K`。假如出现了相同的数，我们可以肯定之后会无限循环。比如 153 之后出现了 1，我们可以肯定之后一定是 35。。。 因为我们的 mod 只是和前一个 mod 有关，上面的公式是一个`纯函数`。

## 关键点解析

- 数学(无限循环与循环节)

## 代码

```python
#
# @lc app=leetcode.cn id=1015 lang=python3
#
# [1015] 可被 K 整除的最小整数
# # @lc code=start


class Solution:
    def smallestRepunitDivByK(self, K: int) -> int:
        if K % 10 in [2, 4, 5, 6, 8]:
            return - 1
        seen = set()
        mod = 0
        for i in range(1, K + 1):
            mod = (mod * 10 + 1) % K
            if mod in seen:
                return -1
            if mod == 0:
                return ix
            seen.add(mod)

        # @lc code=end


```

## 相关题目

- [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

# 1019.next-greater-node-in-linked-list

## 题目地址

https://leetcode-cn.com/problems/next-greater-node-in-linked-list/submissions/

## 题目描述

```
给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。

每个节点都可能有下一个更大值(next larger value)：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。

返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。

注意：在下面的示例中，诸如 [2,1,5] 这样的输入(不是输出)是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。



示例 1：

输入：[2,1,5]
输出：[5,5,0]
示例 2：

输入：[2,7,4,3,5]
输出：[7,0,5,5,0]
示例 3：

输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]


提示：

对于链表中的每个节点，1 <= node.val <= 10^9
给定列表的长度在 [0, 10000] 范围内
```

## 思路

看完题目就应该想到单调栈才行，LeetCode 上关于单调栈的题目还不少，难度都不小。但是一旦你掌握了这个算法，那么这些题目对你来说都不是问题了。

如果你不用单调栈，那么可以暴力$O(N^2)$的时间复杂度解决，只需要双层循环即可。但是这种做法应该是过不了关的。使用单调栈可以将时间复杂度降低到线性，当然需要额外的$O(N)$的空间复杂度。

顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。为了描述方便，以下举例及代码以维护一个整数的单调递减栈为例。将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。

例如，栈中自顶向下的元素为 1，2，4，5 ，插入元素 3 时为了保证单调性需要依次弹出元素 :

- 最开始栈是这样的： [5,4,2,1]
- 为了维护递减特性，1,2 需要被移除。此时栈是这样的： [5,4]
- 我们将 3 push 到栈顶即可
- 此时栈是这样的： [5,4,3]

用代码描述如下：

Python Code:

```python
def monoStack(list):
    st = []
    for v in list:
        while len(st) > 0 and v > st[-1]:
            st.pop()
        st.append(v)
    return st
monoStack([5, 4, 2, 1, 3]) # output: [5, 4, 3]
```

## 关键点

- 单调栈(单调递减栈)
- 单调栈的代码模板

## 代码

Python Code:

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
     def nextLargerNodes(self, head):
        res, st = [], []
        while head:
            while len(st) > 0 and head.val > st[-1][1]:
                res[st.pop()[0]] = head.val
            st.append((len(res), head.val))
            res.append(0)
            head = head.next
        return res
```

## 扩展

甚至可以做到 O(1)的空间复杂度，请参考[C# O(n) time O(1) space](<https://leetcode.com/problems/next-greater-node-in-linked-list/discuss/267090/C-O(n)-time-O(1)-space>)

## 相关题目

- [毎日一题 - 739.Daily Temperatures](https://github.com/azl397985856/leetcode/blob/master/daily/2019-06-06.md)

# 1020.number-of-enclaves

## 题目地址

https://leetcode-cn.com/problems/number-of-enclaves/

## 题目描述

```
给出一个二维数组 A，每个单元格为 0(代表海)或 1(代表陆地)。

移动是指在陆地上从一个地方走到另一个地方(朝四个方向之一)或离开网格的边界。

返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。



示例 1：

输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：
有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
示例 2：

输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：
所有 1 都在边界上或可以到达边界。


提示：

1 <= A.length <= 500
1 <= A[i].length <= 500
0 <= A[i][j] <= 1
所有行的大小都相同

```

## 解法一 (暴力法)

### 思路

这是一个典型的可以使用 DFS 进行解决的一类题目， LeetCode 相关的题目有很多。

对于这种题目不管是思路还是代码都有很大的相似性，我们来看下。

暴力法的思路很简单，我们遍历整个矩阵：

- 如果遍历到 0，我们不予理会
- 如果遍历到 1. 我们将其加到 temp
- 我们不断拓展边界(上下左右)
- 如果 dfs 过程中碰到了边界，说明我们可以逃脱，我们将累加的 temp 清空
- 如果 dfs 过程之后没有碰到边界，说明我们无法逃脱。我们将 temp 加到 cnt
- 最终返回 cnt 即可

### 关键点解析

- visited 记录访问过的节点，防止重复计算

### 代码

Python Code:

```python
class Solution:
    temp = 0
    meetEdge = False

    def numEnclaves(self, A: List[List[int]]) -> int:
        cnt = 0
        m = len(A)
        n = len(A[0])
        visited = set()

        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited:
                return
            visited.add((i, j))
            if A[i][j] == 1:
                self.temp += 1
            else:
                return
            if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                self.meetEdge = True
            dfs(i + 1, j)
            dfs(i - 1, j)
            dfs(i, j + 1)
            dfs(i, j - 1)
        for i in range(m):
            for j in range(n):
                dfs(i, j)
                if not self.meetEdge:
                    cnt += self.temp
                self.meetEdge = False
                self.temp = 0
        return cnt

```

## 解法二 (消除法)

### 思路

上面的解法时间复杂度和空间复杂度都很差，我们考虑进行优化， 这里我们使用消除法。

- 从矩阵边界开始 dfs
- 如果碰到 1 就将其变成 0
- 如果碰到 0 则什么都不做
- 最后我们遍历整个矩阵，数一下 1 的个数即可。

### 关键点解析

- dfs 消除法

### 代码

Python Code:

```python
#
# @lc app=leetcode.cn id=1020 lang=python3
#
# [1020] 飞地的数量
# # @lc code=start


class Solution:

    def numEnclaves(self, A: List[List[int]]) -> int:
        cnt = 0
        m = len(A)
        n = len(A[0])

        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or A[i][j] == 0:
                return
            A[i][j] = 0

            dfs(i + 1, j)
            dfs(i - 1, j)
            dfs(i, j + 1)
            dfs(i, j - 1)
        for i in range(m):
            dfs(i, 0)
            dfs(i, n - 1)
        for j in range(1, n - 1):
            dfs(0, j)
            dfs(m - 1, j)
        for i in range(m):
            for j in range(n):
                if A[i][j] == 1:
                    cnt += 1
        return cnt

        # @lc code=end

```

## 参考

- [200.number-of-islands](https://github.com/azl397985856/leetcode/blob/master/problems/200.number-of-islands.md)

# 1023.camelcase-matching

## 题目地址

https://leetcode-cn.com/problems/camelcase-matching/

## 题目描述

```
如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。(我们可以在任何位置插入每个字符，也可以插入 0 个字符。)

给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。



示例 1：

输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
输出：[true,false,true,true,false]
示例：
"FooBar" 可以这样生成："F" + "oo" + "B" + "ar"。
"FootBall" 可以这样生成："F" + "oot" + "B" + "all".
"FrameBuffer" 可以这样生成："F" + "rame" + "B" + "uffer".
示例 2：

输入：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
输出：[true,false,true,false,false]
解释：
"FooBar" 可以这样生成："Fo" + "o" + "Ba" + "r".
"FootBall" 可以这样生成："Fo" + "ot" + "Ba" + "ll".
示例 3：

输出：queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
输入：[false,true,false,false,false]
解释：
"FooBarTest" 可以这样生成："Fo" + "o" + "Ba" + "r" + "T" + "est".


提示：

1 <= queries.length <= 100
1 <= queries[i].length <= 100
1 <= pattern.length <= 100
所有字符串都仅由大写和小写英文字母组成。

```

## 思路

这道题是一道典型的双指针题目。不过这里的双指针并不是指向同一个数组或者字符串，而是指向多个，这道题是指向两个，分别是 query 和 pattern，这种题目非常常见，能够识别和掌握这种题目的解题模板非常重要。对 queries 的每一项我们的逻辑是一样的，这里就以其中一项为例进行讲解。

以 query 为 FooBar，pattern 为 FB 为例。

首先我们来简化一下问题，假如我们没有`可以在任何位置插入每个字符，也可以插入 0 个字符。`这个规则。我们的问题会比较简单，这个时候我们的算法是什么样的呢？一起来看下：

1. 首先我们建立两个指针 i 和 j 分别指向 query 和 pattern 的首字母。
2. 当 i 和 j 指向的字母相同的时候，我们同时向后移动两个指针一个单位。
3. 当 i 和 j 指向的字母不同的时候，我们直接返回 False

假如我们要找到的不是子串，而是子序列怎么办？我们不妨假设判断 pattern 是否是 query 的子序列。 其实 LeetCode 实际上也有这样的题目，我们来看下：

1. 首先我们建立两个指针 i 和 j 分别指向 query 和 pattern 的首字母。
2. 当 i 和 j 指向的字母相同的时候，我们同时向后移动两个指针一个单位。
3. 当 i 和 j 指向的字母不同的时候，我们移动 i 指针。
4. 当 i 超出 query 范围的时候，我们只需要判断 pattern 是否达到了终点即可。当然我们也可以提前退出。

我们直接参考下 LeetCode [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)。

代码：

> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列

Python Code:

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = 0
        j = 0
        while j < len(t):
            if i < len(s) and s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1
            if i >= len (s):
                return True
        return i == len(s)
```

然后我们加上`可以在任何位置插入每个字符，也可以插入 0 个字符。`这个规则。来看下有什么不同：

1. 首先我们建立两个指针 i 和 j 分别指向 query 和 pattern 的首字母。
2. 当 i 和 j 指向的字母相同的时候，我们同时向后移动两个指针一个单位。
3. 当 i 和 j 指向的字母不同的时候，我们继续判断 i 指向的元素是否是小写。
4. 如果是小写我们只把 i 向后移动一个单位。
5. 如果不是小写我们直接返回 False

## 关键点解析

- 双指针
- 字符串匹配
- 子序列
- 子串

## 代码

Python Code:

```python
class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        res = []
        for query in queries:
            i = 0
            j = 0
            while i < len(query):
                if j < len(pattern) and query[i] == pattern[j]:
                    i += 1
                    j += 1
                elif query[i].islower():
                    i += 1
                else:
                    break
            if i == len(query) and j == len(pattern):
                res.append(True)
            else:
                res.append(False)
        return res
```

## 扩展

这是一个符合直觉的解法，但是却不是一个很优秀的解法，那么你有想到什么优秀的解法么？

## 参考

- [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

# 1104.path-in-zigzag-labelled-binary-tree

## 题目地址

https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/description/

## 题目描述

在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。

如下图所示，在奇数行(即，第一行、第三行、第五行……)中，按从左到右的顺序进行标记；

而偶数行(即，第二行、第四行、第六行……)中，按从右到左的顺序进行标记。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaihhb1ysbj310p0gu3zx.jpg)

给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。

示例 1：

输入：label = 14
输出：[1,3,4,14]
示例 2：

输入：label = 26
输出：[1,2,6,10,26]

提示：

1 <= label <= 10^6

## 思路

假如这道题不是之字形，那么就会非常简单。 我们可以根据子节点的 label 轻松地求出父节点的 label，公示是 label // 2(其中 label 为子节点的 label)。

如果是这样的话，这道题应该是 easy 难度，代码也不难写出。我们继续考虑之字形。我们不妨先观察一下，找下规律。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaihn0ktanj30lu093gme.jpg)

以上图最后一行为例，对于 15 节点，之字变换之前对应的应该是 8 节点。14 节点对应的是 9 节点。。。

全部列举出来是这样的：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaihota82cj30mk0b6wfp.jpg)

我们发现之字变换前后的 label 相加是一个定值。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaihpnlpicj309b08dmxl.jpg)

因此我们只需要求解出每一层的这个定值，然后减去当前值就好了。(注意我们不需要区分偶数行和奇数行)
问题的关键转化为求解这个定值，这个定值其实很好求，因为每一层的最大值和最小值我们很容易求，而最大值和最小值的和正是我们要求的这个数字。

最大值和最小值这么求呢？由满二叉树的性质，我们知道每一层的最小值就是`2 ** (level - 1)`，而最大值是`2 ** level - 1`。 因此我们只要知道 level 即可，level 非常容易求出，具体可以看下面代码。

## 关键点

- 满二叉树的性质：

1. 最小值是`2 ** (level - 1)`，最大值是`2 ** level - 1`，其中 level 是树的深度。
2. 假如父节点的索引为 i，那么左子节点就是 2\*i， 右边子节点就是 2\*i + 1。
3. 假如子节点的索引是 i，那么父节点的索引就是 i // 2。

- 先思考一般情况(不是之字形)， 然后通过观察找出规律

## 代码

```python
class Solution:
    def pathInZigZagTree(self, label: int) -> List[int]:
        level = 0
        res = []
        # for each level, ranged from 2 ** (level - 1) to 2 ** level - 1
        while 2 ** level - 1 < label:
            level += 1

        while level > 0:
            res.insert(0, label)
            label = 2 ** (level - 1) + 2 ** level - 1 - label
            label //= 2
            level -= 1
        return res
```

# 1131.maximum-of-absolute-value-expression

## 题目地址(1131. 绝对值表达式的最大值)

https://leetcode-cn.com/problems/maximum-of-absolute-value-expression/description/

## 题目描述

给你两个长度相等的整数数组，返回下面表达式的最大值：

|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|

其中下标 i，j 满足 0 <= i, j < arr1.length。

示例 1：

输入：arr1 = [1,2,3,4], arr2 = [-1,4,5,6]
输出：13
示例 2：

输入：arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]
输出：20

提示：

2 <= arr1.length == arr2.length <= 40000
-10^6 <= arr1[i], arr2[i] <= 10^6

## 解法一(数学分析)

### 思路

如图我们要求的是这样一个表达式的最大值。arr1 和 arr2 为两个不同的数组，且二者长度相同。i 和 j 是两个合法的索引。

> 红色竖线表示的是绝对值的符号

![](https://tva1.sinaimg.cn/large/006tNbRwly1gamo3dx1bej30q003y74f.jpg)

我们对其进行分类讨论，有如下八种情况：

> |arr1[i] -arr1[j]| 两种情况
> |arr2[i] -arr2[j]| 两种情况
> |i - j| 两种情况
> 因此一共是 2 \* 2 \* 2 = 8 种

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gamosnsknej30tg0viq6w.jpg)

由于 i 和 j 之前没有大小关系，也就说二者可以相互替代。因此：

- 1 等价于 8
- 2 等价于 7
- 3 等价于 6
- 4 等价于 5

也就是说我们只需要计算 1，2，3，4 的最大值就可以了。(当然你可以选择其他组合，只要完备就行)

为了方便，我们将 i 和 j 都提取到一起：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gamp5sizefj30qs0g6gmx.jpg)

容易看出等式的最大值就是前面的最大值，和后面最小值的差值。如图：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gamp9c3g9lj30r20kcabx.jpg)

再仔细观察，会发现前面部分和后面部分是一样的，原因还是上面所说的 i 和 j 可以互换。因此我们要做的就是：

- 遍历一遍数组，然后计算四个表达式， arr1[i] + arr2[i] + i，arr1[i] - arr2[i] + i，arr2[i] - arr1[i] + i 和 -1 \* arr2[i] - arr1[i] + i 的 最大值和最小值。
- 然后分别取出四个表达式最大值和最小值的差值(就是这个表达式的最大值)
- 四个表达式最大值再取出最大值

### 关键点

- 数学分析

### 代码

```python
class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        A = []
        B = []
        C = []
        D = []
        for i in range(len(arr1)):
            a, b, c, d = arr1[i] + arr2[i] + i, arr1[i] - arr2[i] + \
                i, arr2[i] - arr1[i] + i, -1 * arr2[i] - arr1[i] + i
            A.append(a)
            B.append(b)
            C.append(c)
            D.append(d)
        return max(max(A) - min(A), max(B) - min(B), max(C) - min(C), max(D) - min(D))
```

## 解法二(曼哈顿距离)

### 思路

![](https://tva1.sinaimg.cn/large/006tNbRwly1gampnn032tj308l0a8mxl.jpg)

(图来自： https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%93%88%E9%A0%93%E8%B7%9D%E9%9B%A2)

一维曼哈顿距离可以理解为一条线上两点之间的距离: |x1 - x2|，其值为 max(x1 - x2, x2 - x1)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gampr362oaj30l004mdfv.jpg)

在平面上，坐标(x1, y1)的点 P1 与坐标(x2, y2)的点 P2 的曼哈顿距离为：|x1-x2| + |y1 - y2|,其值为 max(x1 - x2 + y1 - y2, x2 - x1 + y1 - y2, x1 - x2 + y2 - y1, x2 -x1 + y2 - y1)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gampwhua9fj30rq0lmdgl.jpg)

然后这道题目是更复杂的三维曼哈顿距离，其中(i, arr[i], arr[j])可以看作三位空间中的一个点，问题转化为曼哈顿距离最远的两个点的距离。
延续上面的思路，|x1-x2| + |y1 - y2| + |z1 - z2|,其值为 :

max(

x1 - x2 + y1 - y2 + z1 - z2,

x1 - x2 + y1 - y2 + z2 - z1,

x2 - x1 + y1 - y2 + z1 - z2,

x2 - x1 + y1 - y2 + z2 - z1,

x1 - x2 + y2 - y1 + z1 - z2,

x1 - x2 + y2 - y1 + z2- z1,

x2 -x1 + y2 - y1 + z1 - z2，

x2 -x1 + y2 - y1 + z2 - z1

)

我们可以将 1 和 2 放在一起方便计算：

max(

x1 + y1 + z1 - (x2 + y2 + z2)，

x1 + y1 - z1 - (x2 + y2 - z2)

...

)

我们甚至可以扩展到 n 维，具体代码见下方。

### 关键点

- 曼哈顿距离
- 曼哈顿距离代码模板

> 解题模板可以帮助你快速并且更少错误的解题，更多解题模板请期待我的[新书](https://lucifer.ren/blog/2019/12/11/draft/)(未完成)

### 代码

```python
class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        # 曼哈顿距离模板代码
        sign = [1, -1]
        n = len(arr1)
        dists = []
        # 三维模板
        for a in sign:
            for b in sign:
                for c in sign:
                    maxDist = float('-inf')
                    minDist = float('inf')
                    # 分别计算所有点的曼哈顿距离
                    for i in range(n):
                        dist = arr1[i] * a + arr2[i] * b + i * c
                        maxDist = max(maxDist, dist)
                        minDist = min(minDist, dist)
                    # 将所有的点的曼哈顿距离放到dists中
                    dists.append(maxDist - minDist)
        return max(dists)
```

## 总结

可以看出其实两种解法都是一样的，只是思考角度不一样。

## 相关题目

- [1030. 距离顺序排列矩阵单元格](https://leetcode-cn.com/problems/matrix-cells-in-distance-order/)

![](https://tva1.sinaimg.cn/large/006tNbRwly1gamq577lgsj30xd0jzwjb.jpg)

- [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

# 1168.optimize-water-distribution-in-a-village-cn

## 题目地址

https://leetcode.com/problems/optimize-water-distribution-in-a-village/

## 题目描述

```
There are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.

For each house i, we can either build a well inside it directly with cost wells[i], or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes, where each pipes[i] = [house1, house2, cost] represents the cost to connect house1 and house2 together using a pipe. Connections are bidirectional.

Find the minimum total cost to supply water to all houses.

Example 1:

Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]
Output: 3
Explanation:
The image shows the costs of connecting houses using pipes.
The best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.

Constraints:

1 <= n <= 10000
wells.length == n
0 <= wells[i] <= 10^5
1 <= pipes.length <= 10000
1 <= pipes[i][0], pipes[i][1] <= n
0 <= pipes[i][2] <= 10^5
pipes[i][0] != pipes[i][1]
```

example 1 pic:

![example 1](../assets/problems/1168.optimize-water-distribution-in-a-village-example1.png)

## 思路

题意，在每个城市打井需要一定的花费，也可以用其他城市的井水，城市之间建立连接管道需要一定的花费，怎么样安排可以花费最少的前灌溉所有城市。

这是一道连通所有点的最短路径/最小生成树问题，把城市看成图中的点，管道连接城市看成是连接两个点之间的边。这里打井的花费是直接在点上，而且并不是所有
点之间都有边连接，为了方便，我们可以假想一个点`(root)0`，这里自身点的花费可以与 `0` 连接，花费可以是 `0-i` 之间的花费。这样我们就可以构建一个连通图包含所有的点和边。
那在一个连通图中求最短路径/最小生成树的问题.

参考延伸阅读中，维基百科针对这类题给出的几种解法。

解题步骤：

1. 创建 `POJO EdgeCost(node1, node2, cost) - 节点1 和 节点2 连接边的花费`。
2. 假想一个`root` 点 `0`，构建图
3. 连通所有节点和 `0`，`[0,i] - i 是节点 [1,n]`，`0-1` 是节点 `0` 和 `1` 的边，边的值是节点 `i` 上打井的花费 `wells[i]`;
4. 把打井花费和城市连接点转换成图的节点和边。
5. 对图的边的值排序(从小到大)
6. 遍历图的边，判断两个节点有没有连通 (`Union-Find`)，
   - 已连通就跳过，继续访问下一条边
   - 没有连通，记录花费，连通节点
7. 若所有节点已连通，求得的最小路径即为最小花费，返回
8. 对于每次`union`, 节点数 `n-1`, 如果 `n==0` 说明所有节点都已连通，可以提前退出，不需要继续访问剩余的边。

> 这里用加权 Union-Find 判断两个节点是否连通，和连通未连通的节点。

举例：`n = 5, wells=[1,2,2,3,2], pipes=[[1,2,1],[2,3,1],[4,5,7]]`

如图：

![minimum cost](../assets/problems/1168.optimize-water-distribution-in-a-village-1.png)

从图中可以看到，最后所有的节点都是连通的。

#### 复杂度分析

- _时间复杂度:_ `O(ElogE) - E 是图的边的个数`
- _空间复杂度:_ `O(E)`

> 一个图最多有 `n(n-1)/2 - n 是图中节点个数` 条边 (完全连通图)

## 关键点分析

1. 构建图，得出所有边
2. 对所有边排序
3. 遍历所有的边(从小到大)
4. 对于每条边，检查是否已经连通，若没有连通，加上边上的值，连通两个节点。若已连通，跳过。

## 代码 (`Java/Python3`)

_Java code_

```java
  class OptimizeWaterDistribution {
    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {
      List<EdgeCost> costs = new ArrayList<>();
      for (int i = 1; i <= n; i++) {
        costs.add(new EdgeCost(0, i, wells[i - 1]));
      }
      for (int[] p : pipes) {
        costs.add(new EdgeCost(p[0], p[1], p[2]));
      }
      Collections.sort(costs);
      int minCosts = 0;
      UnionFind uf = new UnionFind(n);
      for (EdgeCost edge : costs) {
        int rootX = uf.find(edge.node1);
        int rootY = uf.find(edge.node2);
        if (rootX == rootY) continue;
        minCosts += edge.cost;
        uf.union(edge.node1, edge.node2);
        // for each union, we connnect one node
        n--;
        // if all nodes already connected, terminate early
        if (n == 0) {
          return minCosts;
        }
      }
      return minCosts;
    }

    class EdgeCost implements Comparable<EdgeCost> {
      int node1;
      int node2;
      int cost;
      public EdgeCost(int node1, int node2, int cost) {
        this.node1 = node1;
        this.node2 = node2;
        this.cost = cost;
      }

      @Override
      public int compareTo(EdgeCost o) {
        return this.cost - o.cost;
      }
    }

    class UnionFind {
      int[] parent;
      int[] rank;
      public UnionFind(int n) {
        parent = new int[n + 1];
        for (int i = 0; i <= n; i++) {
          parent[i] = i;
        }
        rank = new int[n + 1];
      }
      public int find(int x) {
        return x == parent[x] ? x : find(parent[x]);
      }
      public void union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return;
        if (rank[px] >= rank[py]) {
          parent[py] = px;
          rank[px] += rank[py];
        } else {
          parent[px] = py;
          rank[py] += rank[px];
        }
      }
    }
  }
```

_Pythong3 code_

```python
class Solution:
    def minCostToSupplyWater(self, n: int, wells: List[int], pipes: List[List[int]]) -> int:
        union_find = {i: i for i in range(n + 1)}

        def find(x):
            return x if x == union_find[x] else find(union_find[x])

        def union(x, y):
            px = find(x)
            py = find(y)
            union_find[px] = py

        graph_wells = [[cost, 0, i] for i, cost in enumerate(wells, 1)]
        graph_pipes = [[cost, i, j] for i, j, cost in pipes]
        min_costs = 0
        for cost, x, y in sorted(graph_wells + graph_pipes):
            if find(x) == find(y):
                continue
            union(x, y)
            min_costs += cost
            n -= 1
            if n == 0:
                return min_costs
```

# 1186.maximum-subarray-sum-with-one-deletion

## 题目地址

https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/

## 题目描述

```

给你一个整数数组，返回它的某个 非空 子数组(连续元素)在执行一次可选的删除操作后，所能得到的最大元素总和。

换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素(只能删一次哦)，(删除后)子数组中至少应当有一个元素，然后该子数组(剩下)的元素总和是所有子数组之中最大的。

注意，删除一个元素后，子数组 不能为空。

请看示例：

示例 1：

输入：arr = [1,-2,0,3]
输出：4
解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
示例 2：

输入：arr = [1,-2,-2,3]
输出：3
解释：我们直接选出 [3]，这就是最大和。
示例 3：

输入：arr = [-1,-1,-1,-1]
输出：-1
解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。


提示：

1 <= arr.length <= 10^5
-10^4 <= arr[i] <= 10^4

```

## 思路

### 暴力法

符合知觉的做法是求出所有的情况，然后取出最大的。 我们只需要两层循环接口，外循环用于确定我们丢弃的元素，内循环用于计算 subArraySum。

```python
  class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        res = arr[0]
        def maxSubSum(arr, skip):
            res = maxSub = float("-inf")

            for i in range(len(arr)):
                if i == skip:
                    continue
                maxSub = max(arr[i], maxSub + arr[i])
                res = max(res, maxSub)
            return res
		# 这里循环到了len(arr)项，表示的是一个都不删除的情况
        for i in range(len(arr) + 1):
            res = max(res, maxSubSum(arr, i))
        return res
```

### 空间换时间

上面的做法在 LC 上会 TLE， 因此我们需要换一种思路，既然超时了，我们是否可以从空间换时间的角度思考呢？我们可以分别从头尾遍历，建立两个 subArraySub 的数组 l 和 r。 其实这个不难想到，很多题目都用到了这个技巧。

具体做法：

- 一层遍历， 建立 l 数组，l[i]表示从左边开始的以 arr[i]结尾的 subArraySum 的最大值
- 一层遍历， 建立 r 数组，r[i]表示从右边开始的以 arr[i]结尾的 subArraySum 的最大值
- 一层遍历， 计算 l[i - 1] + r[i + 1] 的最大值
  > l[i - 1] + r[i + 1]的含义就是删除 arr[i]的子数组最大值
- 上面的这个步骤得到了删除一个的子数组最大值， 不删除的只需要在上面循环顺便计算一下即可

```python
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        l = [arr[0]] * n
        r = [arr[n - 1]] * n
        if n == 1:
            return arr[0]
        res = arr[0]
        for i in range(1, n):
            l[i] = max(l[i - 1] + arr[i], arr[i])
            res = max(res, l[i])
        for i in range(n - 2, -1, -1):
            r[i] = max(r[i + 1] + arr[i], arr[i])
            res = max(res, r[i])
        for i in range(1, n - 1):
            res = max(res, l[i - 1] + r[i + 1])

        return res

```

### 动态规划

上面的算法虽然时间上有所改善，但是正如标题所说，空间复杂度是 O(n),有没有办法改进呢？答案是使用动态规划。

具体过程：

- 定义 max0，表示以 arr[i]结尾且一个都不漏的最大子数组和
- 定义 max1，表示以 arr[i]或者 arr[i - 1]结尾，可以漏一个的最大子数组和
- 遍历数组，更新 max1 和 max0(注意先更新 max1，因为 max1 用到了上一个 max0)
- 其中`max1 = max(max1 + arr[i], max0)`, 即删除 arr[i - 1]或者删除 arr[i]
- 其中`max0 = max(max0 + arr[i], arr[i])`， 一个都不删除

```python
#
# @lc app=leetcode.cn id=1186 lang=python3
#
# [1186] 删除一次得到子数组最大和
# # @lc code=start


class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        # DP
        max0 = arr[0]
        max1 = arr[0]
        res = arr[0]
        n = len(arr)
        if n == 1:
            return max0

        for i in range(1, n):
            # 先更新max1，再更新max0，因为max1用到了上一个max0
            max1 = max(max1 + arr[i], max0)
            max0 = max(max0 + arr[i], arr[i])
            res = max(res, max0, max1)
        return res


# @lc code=end


```

## 关键点解析

- 空间换时间
- 头尾双数组
- 动态规划

## 相关题目

- [42.trapping-rain-water](./42.trapping-rain-water.md)

# 1218.longest-arithmetic-subsequence-of-given-difference

## 题目地址

https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/

## 题目描述

```

给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。



示例 1：

输入：arr = [1,2,3,4], difference = 1
输出：4
解释：最长的等差子序列是 [1,2,3,4]。
示例 2：

输入：arr = [1,3,5,7], difference = 1
输出：1
解释：最长的等差子序列是任意单个元素。
示例 3：

输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2
输出：4
解释：最长的等差子序列是 [7,5,3,1]。


提示：

1 <= arr.length <= 10^5
-10^4 <= arr[i], difference <= 10^4

```

## 思路

最直观的思路是双层循环，我们暴力的枚举出以每一个元素为开始元素，以最后元素结尾的的所有情况。很明显这是所有的情况，这就是暴力法的精髓， 很明显这种解法会 TLE(超时)，不过我们先来看一下代码，顺着这个思维继续思考。

### 暴力法

```python
  def longestSubsequence(self, arr: List[int], difference: int) -> int:
        n = len(arr)
        res = 1
        for i in range(n):
            count = 1
            for j in range(i + 1, n):
                if arr[i] + difference * count == arr[j]:
                    count += 1

                if count > res:
                    res = count

        return res
```

### 动态规划

上面的时间复杂度是 O(n^2)， 有没有办法降低到 O(n)呢？很容易想到的是空间换时间的解决方案。

我的想法是将`以每一个元素结尾的最长等差子序列的长度`统统存起来，即`dp[num] = maxLen` 这样我们遍历到一个新的元素的时候，就去之前的存储中去找`dp[num - difference]`, 如果找到了，就更新当前的`dp[num] = dp[num - difference] + 1`, 否则就是不进行操作(还是默认值 1)。

这种空间换时间的做法的时间和空间复杂度都是 O(n)。

## 关键点解析

- 将`以每一个元素结尾的最长等差子序列的长度`统统存起来

## 代码

```python
#
# @lc app=leetcode.cn id=1218 lang=python3
#
# [1218] 最长定差子序列
# # @lc code=start


class Solution:

    # 动态规划
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        n = len(arr)
        res = 1
        dp = {}
        for num in arr:
            dp[num] = 1
            if num - difference in dp:
                dp[num] = dp[num - difference] + 1

        return max(dp.values())

# @lc code=end
```

## 相关题目

# 1227.airplane-seat-assignment-probability

## 题目地址(1227. 飞机座位分配概率)

https://leetcode-cn.com/problems/airplane-seat-assignment-probability/description/

## 题目描述

```

有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。

剩下的乘客将会：

如果他们自己的座位还空着，就坐到自己的座位上，

当他们自己的座位被占用时，随机选择其他座位
第 n 位乘客坐在自己的座位上的概率是多少？



示例 1：

输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。
示例 2：

输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。


提示：

1 <= n <= 10^5


```

## 暴力递归

这是一道 LeetCode 为数不多的概率题，我们来看下。

### 思路

我们定义原问题为 f(n)。对于第一个人来说，他有 n 中选择，就是分别选择 n 个座位中的一个。由于选择每个位置的概率是相同的，那么选择每个位置的概率应该都是 1 / n。

我们分三种情况来讨论：

- 如果第一个人选择了第一个人的位置(也就是选择了自己的位置)，那么剩下的人按照票上的座位做就好了，这种情况第 n 个人一定能做到自己的位置
- 如果第一个人选择了第 n 个人的位置，那么第 n 个人肯定坐不到自己的位置。
- 如果第一个人选择了第 i (1 < i < n)个人的位置，那么第 i 个人就相当于变成了“票丢的人”，此时问题转化为 f(n - i + 1)。

此时的问题转化关系如图：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb12n0omuuj31bc0ju405.jpg)
(红色表示票丢的人)

整个过程分析：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb12nhestaj318u0bg76f.jpg)

### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5
        res = 1 / n
        for i in range(2, n):
            res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n
        return res
```

上述代码会栈溢出。

## 暴力递归 + hashtable

### 思路

我们考虑使用记忆化递归来减少重复计算，虽然这种做法可以减少运行时间，但是对减少递归深度没有帮助。还是会栈溢出。

### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    seen = {}

    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5
        if n in self.seen:
            return self.seen[n]
        res = 1 / n
        for i in range(2, n):
            res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n
        self.seen[n] = res
        return res
```

## 动态规划

### 思路

上面做法会栈溢出。其实我们根本不需要运行就应该能判断出栈溢出，题目已经给了数据规模是 1 <= n <= 10 \*\* 5。 这个量级不管什么语言，除非使用尾递归，不然一般都会栈溢出，具体栈深度大家可以查阅相关资料。

既然是栈溢出，那么我们考虑使用迭代来完成。 很容易想到使用动态规划来完成。其实递归都写出来，写一个朴素版的动态规划也难不到哪去，毕竟动态规划就是记录子问题，并建立子问题之间映射而已，这和递归并无本质区别。

### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5

        dp = [1, .5] * n

        for i in range(2, n):
            dp[i] = 1 / n
            for j in range(2, i):
                dp[i] += dp[i - j + 1] * 1 / n
        return dp[-1]
```

这种思路的代码超时了，并且仅仅执行了 35/100 testcase 就超时了。

## 数学分析

### 思路

我们还需要进一步优化时间复杂度，我们需要思考是否可以在线形的时间内完成。

我们继续前面的思路进行分析, 不难得出，我们不妨称其为等式 1：

```
f(n)
= 1/n + 0 + 1/n * (f(n-1) + f(n-2) + ... + f(2))
= 1/n * (f(n-1) + f(n-2) + ... + f(2) + 1)
= 1/n * (f(n-1) + f(n-2) + ... + f(2) + f(1))
```

似乎更复杂了？没关系，我们继续往下看，我们看下 f(n - 1)，我们不妨称其为等式 2。

```
f(n-1) = 1/(n-1) * (f(n-2) + f(n-3) + ... + f(1))
```

我们将等式 1 和等式 2 两边分别同时乘以 n 和 n - 1

```
n * f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(1)
(n-1) * f(n-1) = f(n-2) + f(n-3) + ... + f(1)
```

我们将两者相减：

```
n * f(n) - (n-1)*f(n-1) = f(n-1)
```

我们继续将 (n-1)\*f(n-1) 移到等式右边，得到：

```
n * f(n) = n * f(n-1)
```

也就是说:

```
f(n) = f(n - 1)
```

当然前提是 n 大于 2。

既然如此，我们就可以减少一层循环， 我们用这个思路来优化一下上面的 dp 解法。这种解法终于可以 AC 了。

### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        if n == 2:
            return 0.5

        dp = [1, .5] * n

        for i in range(2, n):
            dp[i] = 1/n+(n-2)/n * dp[n-1]
        return dp[-1]
```

## 优化数学分析

### 思路

上面我们通过数学分析，得出了当 n 大于 2 时：

```
f(n) = f(n - 1)
```

那么是不是意味着我们随便求出一个 n 就好了？ 比如我们求出 n = 2 的时候的值，是不是就知道 n 为任意数的值了。 我们不难想出 n = 2 时候，概率是 0.5，因此只要 n 大于 1 就是 0.5 概率，否则就是 1 概率。

### 代码

代码支持 Python3:

Python3 Code:

```python
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else .5

```

## 关键点

- 概率分析
- 数学推导
- 动态规划
- 递归 + mapper
- 栈限制大小
- 尾递归

# 1260.shift-2d-grid

## 题目地址(1260. 二维网格迁移)

https://leetcode-cn.com/problems/shift-2d-grid/description/

## 题目描述

```

给你一个 n 行 m 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。

每次「迁移」操作将会引发下述活动：

位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。
位于 grid[i][m - 1] 的元素将会移动到 grid[i + 1][0]。
位于 grid[n - 1][m - 1] 的元素将会移动到 grid[0][0]。
请你返回 k 次迁移操作后最终得到的 二维网格。



示例 1：



输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[9,1,2],[3,4,5],[6,7,8]]
示例 2：



输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
示例 3：

输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
输出：[[1,2,3],[4,5,6],[7,8,9]]


提示：

1 <= grid.length <= 50
1 <= grid[i].length <= 50
-1000 <= grid[i][j] <= 1000
0 <= k <= 100


```

## 暴力法

我们直接翻译题目，没有任何 hack 的做法。

### 代码

```python
from copy import deepcopy

class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        n = len(grid)
        m = len(grid[0])
        for _ in range(k):
            old = deepcopy(grid)
            for i in range(n):
                for j in range(m):
                    if j == m - 1:
                            grid[(i + 1) % n][0] = old[i][j]
                    elif i == n - 1 and j == m - 1:
                        grid[0][0] = old[i][j]
                    else:
                        grid[i][j + 1] = old[i][j]
        return grid
```

由于是 easy，上述做法勉强可以过，我们考虑优化。

## 数学分析

### 思路

我们仔细观察矩阵会发现，其实这样的矩阵迁移是有规律的。 如图：
![image](https://user-images.githubusercontent.com/12479470/72203575-4f6e4c00-34a8-11ea-8765-03fc856d4ea6.png)

因此这个问题就转化为我们一直的一维矩阵转移问题，LeetCode 也有原题[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)，同时我也写了一篇文章[文科生都能看懂的循环移位算法](https://lucifer.ren/blog/2019/12/11/rotate-list/)专门讨论这个，最终我们使用的是三次旋转法，相关数学证明也有写，很详细，这里不再赘述。

LeetCode 真的是喜欢换汤不换药呀 😂

### 代码

Python 代码：

```python
#
# @lc app=leetcode.cn id=1260 lang=python3
#
# [1260] 二维网格迁移
# # @lc code=start


class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        n = len(grid)
        m = len(grid[0])
        # 二维到一维
        arr = [grid[i][j] for i in range(n) for j in range(m)]
        # 取模，缩小k的范围，避免无意义的运算
        k %= m * n
        res = []
        # 首尾交换法

        def reverse(l, r):
            while l < r:
                t = arr[l]
                arr[l] = arr[r]
                arr[r] = t
                l += 1
                r -= 1
        # 三次旋转
        reverse(0, m * n - k - 1)
        reverse(m * n - k, m * n - 1)
        reverse(0, m * n - 1)
        # 一维到二维
        row = []
        for i in range(m * n):
            if i > 0 and i % m == 0:
                res.append(row)
                row = []
            row.append(arr[i])
        res.append(row)

        return res

# @lc code=end

```

## 相关题目

- [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

## 参考

- [文科生都能看懂的循环移位算法](https://lucifer.ren/blog/2019/12/11/rotate-list/)

# 1261.find-elements-in-a-contaminated-binary-tree (1261. 在受污染的二叉树中查找元素)

https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/submissions/

## 题目描述

```
给出一个满足下述规则的二叉树：

root.val == 0
如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1
如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2
现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。

请你先还原二叉树，然后实现 FindElements 类：

FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。
bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。


示例 1：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasy4qroxoj308w03b3yi.jpg)

输入：
["FindElements","find","find"]
[[[-1,null,-1]],[1],[2]]
输出：
[null,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1]);
findElements.find(1); // return False
findElements.find(2); // return True
示例 2：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasy5mlo3mj30b405iwep.jpg)

输入：
["FindElements","find","find","find"]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
输出：
[null,true,true,false]
解释：
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False
示例 3：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasy5sr25yj308i07maa8.jpg)

输入：
["FindElements","find","find","find","find"]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
输出：
[null,true,false,false,true]
解释：
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True


提示：

TreeNode.val == -1
二叉树的高度不超过 20
节点的总数在 [1, 10^4] 之间
调用 find() 的总次数在 [1, 10^4] 之间
0 <= target <= 10^6

```

## 暴力法

### 思路

最简单想法就是递归建立树，然后 find 的时候递归查找即可，代码也很简单。

### 代码

Pythpn Code:

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class FindElements:
    node = None
    def __init__(self, root: TreeNode):
        def recover(node):
            if not node:
                return node;
            if node.left:
                node.left.val =  2 * node.val + 1
            if node.right:
                 node.right.val = 2 * node.val + 2
            recover(node.left)
            recover(node.right)
            return node
        root.val = 0
        self.node = recover(root)


    def find(self, target: int) -> bool:
        def findInTree(node, target):
            if not node:
                return False
            if node.val == target:
                return True
            return findInTree(node.left, target) or findInTree(node.right, target)
        return findInTree(self.node, target)




# Your FindElements object will be instantiated and called as such:
# obj = FindElements(root)
# param_1 = obj.find(target)
```

上述代码会超时，我们来考虑优化。

## 空间换时间

### 思路

上述代码会超时，我们考虑使用空间换时间。 建立树的时候，我们将所有值存到一个集合中去。当需要 find 的时候，我们直接查找 set 即可，时间复杂度 O(1)。

### 代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class FindElements:
    def __init__(self, root: TreeNode):
        # set 不能放在init外侧。 因为测试用例之间不会销毁FindElements的变量
        self.seen = set()
        def recover(node):
            if not node:
                return node;
            if node.left:
                node.left.val =  2 * node.val + 1
                self.seen.add(node.left.val)
            if node.right:
                 node.right.val = 2 * node.val + 2
                 self.seen.add(node.right.val)
            recover(node.left)
            recover(node.right)
            return node
        root.val = 0
        self.seen.add(0)
        self.node = recover(root)


    def find(self, target: int) -> bool:
        return target in self.seen




# Your FindElements object will be instantiated and called as such:
# obj = FindElements(root)
# param_1 = obj.find(target)
```

这种解法可以 AC，但是在数据量非常大的时候，可能 MLE，我们继续考虑优化。

## 二进制法

### 思路

这是一种非常巧妙的做法。

如果我们把树中的数全部加 1 会怎么样？

![](https://tva1.sinaimg.cn/large/006tNbRwly1gasypfuvuvj30rs0kudjr.jpg)
(图参考 https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/discuss/431229/Python-Special-Way-for-find()-without-HashSet-O(1)-Space-O(logn)-Time)

仔细观察发现，每一行的左右子树分别有不同的前缀：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gasz0x09koj312y0sgnnt.jpg)

Ok，那么算法就来了。为了便于理解，我们来举个具体的例子，比如 target 是 9，我们首先将其加 1，二进制表示就是 1010。不考虑第一位，就是 010，我们只要：

- 0 向左 👈
- 1 向右 👉
- - 0 向左 👈

就可以找到 9 了。

> 0 表示向左 ， 1 表示向右

### 代码

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class FindElements:
    node = None
    def __init__(self, root: TreeNode):
        def recover(node):
            if not node:
                return node;
            if node.left:
                node.left.val =  2 * node.val + 1
            if node.right:
                 node.right.val = 2 * node.val + 2
            recover(node.left)
            recover(node.right)
            return node
        root.val = 0
        self.node = recover(root)


    def find(self, target: int) -> bool:
        node = self.node
        for bit in bin(target+1)[3:]:
            node = node and (node.left, node.right)[int(bit)]
        return bool(node)




# Your FindElements object will be instantiated and called as such:
# obj = FindElements(root)
# param_1 = obj.find(target)
```

## 关键点解析

- 空间换时间
- 二进制思维
- 将 target + 1

# 1262.greatest-sum-divisible-by-three (1262. 可被三整除的最大和)

https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/description/

## 题目描述

```
给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。



示例 1：

输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18(可被 3 整除的最大和)。
示例 2：

输入：nums = [4]
输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。
示例 3：

输入：nums = [1,2,3,4,4]
输出：12
解释：选出数字 1, 3, 4 以及 4，它们的和是 12(可被 3 整除的最大和)。


提示：

1 <= nums.length <= 4 * 10^4
1 <= nums[i] <= 10^4

```

## 暴力法

### 思路

一种方式是找出所有的能够被 3 整除的子集，然后挑选出和最大的。由于我们选出了所有的子集，那么时间复杂度就是 $O(2^N)$ ， 毫无疑问会超时。这里我们使用回溯法找子集，如果不清楚回溯法，可以参考我之前的题解，很多题目都用到了，比如[78.subsets](https://github.com/azl397985856/leetcode/blob/master/problems/78.subsets.md)。

更多回溯题目，可以访问上方链接查看(可以使用一套模板搞定)：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatuu0yfh8j30f60c4ab3.jpg)

### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        self.res = 0
        def backtrack(temp, start):
            total = sum(temp)
            if total % 3 == 0:
                self.res = max(self.res, total)
            for i in range(start, len(nums)):
                temp.append(nums[i])
                backtrack(temp, i + 1)
                temp.pop(-1)


        backtrack([], 0)

        return self.res
```

## 减法 + 排序

减法的核心思想是，我们求出总和。如果总和不满足题意，我们尝试减去最小的数，使之满足题意。

### 思路

这种算法的思想，具体来说就是：

- 我们将所有的数字加起来，我们不妨设为 total
- total 除以 3，得到一个余数 mod， mod 可能值有 0，1，2.
- 同时我们建立两个数组，一个是余数为 1 的数组 one，一个是余数为 2 的数组 two
- 如果 mod 为 0，我们直接返回即可。
- 如果 mod 为 1，我们可以减去 one 数组中最小的一个(如果有的话)，或者减去两个 two 数组中最小的(如果有的话)，究竟减去谁取决谁更小。
- 如果 mod 为 2，我们可以减去 two 数组中最小的一个(如果有的话)，或者减去两个 one 数组中最小的(如果有的话)，究竟减去谁取决谁更小。

由于我们需要取 one 和 two 中最小的一个或者两个，因此对数组 one 和 two 进行排序是可行的，如果基于排序的话，时间复杂度大致为 $O(NlogN)$，这种算法可以通过。

以题目中的例 1 为例：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatvdy1zb1j30u00x2wgx.jpg)

以题目中的例 2 为例：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gatvem1xm4j30u00xvq59.jpg)

### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        one = []
        two = []
        total = 0

        for num in nums:
            total += num
            if num % 3 == 1:
                one.append(num)
            if num % 3 == 2:
                two.append(num)
        one.sort()
        two.sort()
        if total % 3 == 0:
            return total
        elif total % 3 == 1 and one:
            if len(two) >= 2 and one[0] > two[0] + two[1]:
                return total - two[0] - two[1]
            return total - one[0]
        elif total % 3 == 2 and two:
            if len(one) >= 2 and two[0] > one[0] + one[1]:
                return total - one[0] - one[1]
            return total - two[0]
        return 0
```

## 减法 + 非排序

### 思路

上面的解法使用到了排序。 我们其实观察发现，我们只是用到了 one 和 two 的最小的两个数。因此我们完全可以在线形的时间和常数的空间完成这个算法。我们只需要分别记录 one 和 two 的最小值和次小值即可，在这里，我使用了两个长度为 2 的数组来表示，第一项是最小值，第二项是次小值。

### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        one = [float('inf')] * 2
        two = [float('inf')] * 2
        total = 0

        for num in nums:
            total += num
            if num % 3 == 1:
                if num < one[0]:
                    t = one[0]
                    one[0] = num
                    one[1] = t
                elif num < one[1]:
                    one[1] = num
            if num % 3 == 2:
                if num < two[0]:
                    t = two[0]
                    two[0] = num
                    two[1] = t
                elif num < two[1]:
                    two[1] = num
        if total % 3 == 0:
            return total
        elif total % 3 == 1 and one:
            if len(two) >= 2 and one[0] > two[0] + two[1]:
                return total - two[0] - two[1]
            return total - one[0]
        elif total % 3 == 2 and two:
            if len(one) >= 2 and two[0] > one[0] + one[1]:
                return total - one[0] - one[1]
            return total - two[0]
        return 0
```

## 有限状态机

### 思路

我在[数据结构与算法在前端领域的应用 - 第二篇](https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/) 中讲到了有限状态机。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gatub3vftxj30eq0bfta0.jpg)

状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。

状态机使用非常广泛，比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。

拿本题中来说，我们从左到右扫描数组的过程，将会不断改变状态机的状态。

我们使用 state 数组来表示本题的状态：

- state[0] 表示 mod 为 0 的 最大和
- state[1] 表示 mod 为 1 的 最大和
- state[2] 表示 mod 为 1 的 最大和

我们的状态转移方程就会很容易。说到状态转移方程，你可能会想到动态规划。没错！这种思路可以直接翻译成动态规划，算法完全一样。如果你看过我上面提到的文章，那么状态转移方程对你来说就会很容易。如果你不清楚，那么请往下看：

- 我们从左往右不断读取数字，我们不妨设这个数字为 num。
- 如果 num % 3 为 0。 那么我们的 state[0], state[1], state[2] 可以直接加上 num(题目限定了 num 为非负)， 因为任何数字加上 3 的倍数之后，mod 3 的值是不变的。
- 如果 num % 3 为 1。 我们知道 state[2] + num 会变成一个能被三整除的数，但是这个数字不一定比当前的 state[0]大。 代码表示就是`max(state[2] + num, state[0])`。同理 state[1] 和 state[2] 的转移逻辑类似。
- 同理 num % 3 为 2 也是类似的逻辑。
- 最后我们返回 state[0]即可。

### 代码

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        state = [0, float('-inf'), float('-inf')]

        for num in nums:
            if num % 3 == 0:
                state = [state[0] + num, state[1] + num, state[2] + num]
            if num % 3 == 1:
                a = max(state[2] + num, state[0])
                b = max(state[0] + num, state[1])
                c = max(state[1] + num, state[2])
                state = [a, b, c]
            if num % 3 == 2:
                a = max(state[1] + num, state[0])
                b = max(state[2] + num, state[1])
                c = max(state[0] + num, state[2])
                state = [a, b, c]
        return state[0]
```

当然这个代码还可以简化：

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        state = [0, float('-inf'), float('-inf')]

        for num in nums:
            temp = [0] * 3
            for i in range(3):
                temp[(i + num) % 3] = max(state[(i + num) % 3], state[i] + num)
            state = temp

        return state[0]
```

## 关键点解析

- 贪婪法
- 状态机
- 数学分析

## 扩展

实际上，我们可以采取加法(贪婪策略)，感兴趣的可以试一下。

# 1297.maximum-number-of-occurrences-of-a-substring(1297. 子串的最大出现次数)

https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring

## 题目描述

```
给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：

子串中不同字母的数目必须小于等于 maxLetters 。
子串的长度必须大于等于 minSize 且小于等于 maxSize 。


示例 1：

输入：s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
输出：2
解释：子串 "aab" 在原字符串中出现了 2 次。
它满足所有的要求：2 个不同的字母，长度为 3 (在 minSize 和 maxSize 范围内)。
示例 2：

输入：s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
输出：2
解释：子串 "aaa" 在原字符串中出现了 2 次，且它们有重叠部分。
示例 3：

输入：s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
输出：3
示例 4：

输入：s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
输出：0


提示：

1 <= s.length <= 10^5
1 <= maxLetters <= 26
1 <= minSize <= maxSize <= min(26, s.length)
s 只包含小写英文字母。
```

## 暴力法

题目给的数据量不是很大，为 1 <= maxLetters <= 26，我们试一下暴力法。

### 思路

暴力法如下：

- 先找出所有满足长度大于等于 minSize 且小于等于 maxSize 的所有子串。(平方的复杂度)
- 对于 maxLetter 满足题意的子串，我们统计其出现次数。时间复杂度为 O(k),其中 k 为子串长度
- 返回最大的出现次数

### 代码

Pythpn Code:

```python
class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        n = len(s)
        letters = set()
        cnts = dict()
        res = 0
        for i in range(n - minSize + 1):
            length = minSize
            while i + length <= n and length <= maxSize:
                t = s[i:i + length]
                for c in t:
                    if len(letters) > maxLetters:
                        break
                    letters.add(c)
                if len(letters) <= maxLetters:
                    cnts[t] = cnts.get(t, 0) + 1
                    res = max(res, cnts[t])
                letters.clear()
                length += 1
        return res
```

上述代码会超时。我们来利用剪枝来优化。

## 剪枝

### 思路

还是暴力法的思路，不过我们在此基础上进行一些优化。首先我们需要仔细阅读题目，如果你足够细心或者足够有经验，可能会发现其实题目中 maxSize 没有任何用处，属于干扰信息。

也就是说我们没有必要统计`长度大于等于 minSize 且小于等于 maxSize 的所有子串`，而是统计长度为 minSize 的所有字串即可。原因是，如果一个大于 minSize 长度的字串若是满足条件，那么该子串其中必定有至少一个长度为 minSize 的字串满足条件。因此一个大于 minSize 长度的字串出现了 n 次，那么该子串其中必定有一个长度为 minSize 的子串出现了 n 次。

### 代码

代码支持 Python3，Java：

Python Code：

```python
 def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        counter, res = {}, 0
        for i in range(0, len(s) - minSize + 1):
            sub = s[i : i + minSize]
            if len(set(sub)) <= maxLetters:
                counter[sub] = counter.get(sub, 0) + 1
                res = max(res, counter[sub])
        return res;

# @lc code=end
```

Java Code：

```java
 public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {
    Map<String, Integer> counter = new HashMap<>();
    int res = 0;
    for (int i = 0; i < s.length() - minSize + 1; i++) {
        String substr = s.substring(i, i + minSize);
        if (checkNum(substr, maxLetters)) {
            int newVal = counter.getOrDefault(substr, 0) + 1;
            counter.put(substr, newVal);
            res = Math.max(res, newVal);
        }
    }
    return res;
}
public boolean checkNum(String substr, int maxLetters) {
    Set<Character> set = new HashSet<>();
    for (int i = 0; i < substr.length(); i++)
        set.add(substr.charAt(i));
    return set.size() <= maxLetters;
}

```

## 关键点解析

- 滑动窗口
- 识别题目干扰信息
- 看题目限制条件，对于本题有用的信息是`1 <= maxLetters <= 26`

## 扩展

我们也可以使用滑动窗口来解决，感兴趣的可以试试看。

# 130.surrounded-regions

## 题目地址

https://leetcode.com/problems/surrounded-regions/description/

## 题目描述

```
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
Explanation:

Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.

```

## 思路

我们需要将所有被 X 包围的 O 变成 X，并且题目明确说了边缘的所有 O 都是不可以变成 X 的。

![130.surrounded-regions](../assets/problems/130.surrounded-regions-1.jpg)

其实我们观察会发现，我们除了边缘的 O 以及和边缘 O 连通的 O 是不需要变成 X 的，其他都要变成 X。

经过上面的思考，问题转化为连通区域问题。 这里我们需要标记一下`边缘的O以及和边缘O连通的O`。
我们当然可以用额外的空间去存，但是对于这道题目而言，我们完全可以 mutate。这样就空间复杂度会好一点。

整个过程如图所示：

> 我将`边缘的O以及和边缘O连通的O` 标记为了 "A"

![130.surrounded-regions](../assets/problems/130.surrounded-regions-2.jpg)

## 关键点解析

- 二维数组 DFS 解题模板
- 转化问题为`连通区域问题`
- 直接 mutate 原数组，节省空间

## 代码

- 语言支持：JS，Python3

```js
/*
 * @lc app=leetcode id=130 lang=javascript
 *
 * [130] Surrounded Regions
 */
// 将O以及周边的O转化为A
function mark(board, i, j, rows, cols) {
  if (i < 0 || i > rows - 1 || j < 0 || j > cols - 1 || board[i][j] !== 'O') return;

  board[i][j] = 'A';
  mark(board, i + 1, j, rows, cols);
  mark(board, i - 1, j, rows, cols);
  mark(board, i, j + 1, rows, cols);
  mark(board, i, j - 1, rows, cols);
}
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
  const rows = board.length;
  if (rows === 0) return [];
  const cols = board[0].length;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (i === 0 || i == rows - 1 || j === 0 || j === cols - 1) {
        mark(board, i, j, rows, cols);
      }
    }
  }

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (board[i][j] === 'O') {
        board[i][j] = 'X';
      } else if (board[i][j] === 'A') {
        board[i][j] = 'O';
      }
    }
  }

  return board;
};
```

Python Code：

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        # 如果数组长或宽小于等于2，则不需要替换
        if len(board) <= 2 or len(board[0]) <= 2:
            return

        row, col = len(board), len(board[0])

        def dfs(i, j):
            """
            深度优先算法，如果符合条件，替换为A并进一步测试，否则停止
            """
            if i < 0 or j < 0 or i >= row or j >= col or board[i][j] != 'O':
                return
            board[i][j] = 'A'

            dfs(i - 1, j)
            dfs(i + 1, j)
            dfs(i, j - 1)
            dfs(i, j + 1)

        # 从外围开始
        for i in range(row):
            dfs(i, 0)
            dfs(i, col-1)

        for j in range(col):
            dfs(0, j)
            dfs(row-1, j)

        # 最后完成替换
        for i in range(row):
            for j in range(col):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == 'A':
                    board[i][j] = 'O'
```

## 相关题目

- [200.number-of-islands](./200.number-of-islands.md)

> 解题模板是一样的

# 131.palindrome-partitioning

## 题目地址

https://leetcode.com/problems/palindrome-partitioning/description/

## 题目描述

```
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]

```

## 思路

这是一道求解所有可能性的题目， 这时候可以考虑使用回溯法。 回溯法解题的模板我们已经在很多题目中用过了，
这里就不多说了。大家可以结合其他几道题目加深一下理解。

## 关键点解析

- 回溯法

## 代码

- 语言支持：JS，Python3

```js
/*
 * @lc app=leetcode id=131 lang=javascript
 *
 * [131] Palindrome Partitioning
 */

function isPalindrom(s) {
  let left = 0;
  let right = s.length - 1;

  while (left < right && s[left] === s[right]) {
    left++;
    right--;
  }

  return left >= right;
}
function backtrack(s, list, tempList, start) {
  const sliced = s.slice(start);

  if (isPalindrom(sliced) && tempList.join('').length === s.length) list.push([...tempList]);

  for (let i = 0; i < sliced.length; i++) {
    const sub = sliced.slice(0, i + 1);
    if (isPalindrom(sub)) {
      tempList.push(sub);
    } else {
      continue;
    }
    backtrack(s, list, tempList, start + i + 1);
    tempList.pop();
  }
}
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
  // "aab"
  // ["aa", "b"]
  // ["a", "a", "b"]
  const list = [];
  backtrack(s, list, [], 0);
  return list;
};
```

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        """回溯法"""

        res = []

        def helper(s, tmp):
            """
            如果是空字符串，说明已经处理完毕
            否则逐个字符往前测试，判断是否是回文
            如果是，则处理剩余字符串，并将已经得到的列表作为参数
            """
            if not s:
                res.append(tmp)
            for i in range(1, len(s) + 1):
                if s[:i] == s[:i][::-1]:
                    helper(s[i:], tmp + [s[:i]])

        helper(s, [])
        return res
```

## 相关题目

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)

# 1310.xor-queries-of-a-subarray(1310. 子数组异或查询)

https://leetcode-cn.com/problems/xor-queries-of-a-subarray

## 题目描述

```
有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。

对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值(即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri])作为本次查询的结果。

并返回一个包含给定查询 queries 所有结果的数组。



示例 1：

输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
输出：[2,7,14,8]
解释：
数组中元素的二进制表示形式是：
1 = 0001
3 = 0011
4 = 0100
8 = 1000
查询的 XOR 值为：
[0,1] = 1 xor 3 = 2
[1,2] = 3 xor 4 = 7
[0,3] = 1 xor 3 xor 4 xor 8 = 14
[3,3] = 8
示例 2：

输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
输出：[8,0,4,4]


提示：

1 <= arr.length <= 3 * 10^4
1 <= arr[i] <= 10^9
1 <= queries.length <= 3 * 10^4
queries[i].length == 2
0 <= queries[i][0] <= queries[i][1] < arr.length
```

## 暴力法

### 思路

最直观的思路是双层循环即可，果不其然超时了。

### 代码

```python

class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
 		res = []
        for (L, R) in queries:
            i = L
            xor = 0
            while i <= R:
                xor ^= arr[i]
                i += 1
            res.append(xor)
        return res
```

## 前缀表达式

### 思路

比较常见的是前缀和，这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。

对 [1,2,3,4,5,6] 来说，其前缀和可以是 pre=[1,3,6,10,15,21]。我们可以使用公式 pre[𝑖]=pre[𝑖−1]+nums[𝑖]得到每一位前缀和的值，从而通过前缀和进行相应的计算和解题。其实前缀和的概念很简单，但困难的是如何在题目中使用前缀和以及如何使用前缀和的关系来进行解题。

这道题是前缀对前缀异或，我们利用了异或的性质 `x ^ y ^ x = y`。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqll5r048j30fm0bfglz.jpg)

### 代码

代码支持 Python3，Java，C++：

Python Code：

```python
#
# @lc app=leetcode.cn id=1218 lang=python3
#
# [1218] 最长定差子序列
# # @lc code=start


class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
		pre = [0]
        res = []
        for i in range(len(arr)):
            pre.append(pre[i] ^ arr[i])
        for (L, R) in queries:
            res.append(pre[L] ^ pre[R + 1])
        return res

# @lc code=end
```

Java Code：

```java
  public int[] xorQueries(int[] arr, int[][] queries) {

        int[] preXor = new int[arr.length];
        preXor[0] = 0;

        for (int i = 1; i < arr.length; i++)
            preXor[i] = preXor[i - 1] ^ arr[i - 1];

        int[] res = new int[queries.length];

        for (int i = 0; i < queries.length; i++) {

            int left = queries[i][0], right = queries[i][1];
            res[i] = arr[right] ^ preXor[right] ^ preXor[left];
        }

        return res;
    }

```

C++ Code:

```
class Solution {
public:
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        vector<int>res;
        for(int i=1; i<arr.size(); ++i){
            arr[i]^=arr[i-1];
        }
        for(vector<int>temp :queries){
            if(temp[0]==0){
                res.push_back(arr[temp[1]]);
            }
            else{
                res.push_back(arr[temp[0]-1]^arr[temp[1]]);
            }
        }
        return res;
    }
};
```

## 关键点解析

- 异或的性质 x ^ y ^ x = y
- 前缀表达式

## 相关题目

- [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/description/)

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaql7eqyg6j30u00ft0vx.jpg)

- [1186.删除一次得到子数组最大和](https://lucifer.ren/blog/2019/12/11/leetcode-1186/)

# 1332.remove-palindromic-subsequences(1332. 删除回文子序列)

https://leetcode-cn.com/problems/remove-palindromic-subsequences/

## 题目描述

```
给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。

返回删除给定字符串中所有字符(字符串为空)的最小删除次数。

「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。

「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。



示例 1：

输入：s = "ababa"
输出：1
解释：字符串本身就是回文序列，只需要删除一次。
示例 2：

输入：s = "abb"
输出：2
解释："abb" -> "bb" -> "".
先删除回文子序列 "a"，然后再删除 "bb"。
示例 3：

输入：s = "baabb"
输出：2
解释："baabb" -> "b" -> "".
先删除回文子序列 "baab"，然后再删除 "b"。
示例 4：

输入：s = ""
输出：0


提示：

0 <= s.length <= 1000
s 仅包含字母 'a'  和 'b'
在真实的面试中遇到过这道题？
```

## 思路

这又是一道“抖机灵”的题目，类似的题目有[1297.maximum-number-of-occurrences-of-a-substring](https://github.com/azl397985856/leetcode/blob/77db8fa47c7ee0a14b320f7c2d22f7c61ae53c35/problems/1297.maximum-number-of-occurrences-of-a-substring.md)

由于只有 a 和 b 两个字符。其实最多的消除次数就是 2。因为我们无论如何都可以先消除全部的 1 再消除全部的 2(先消除 2 也一样)，这样只需要两次即可完成。 我们再看一下题目给的一次消除的情况，题目给的例子是“ababa”，我们发现其实它本身就是一个回文串，所以才可以一次全部消除。那么思路就有了：

- 如果 s 是回文，则我们需要一次消除
- 否则需要两次
- 一定要注意特殊情况， 对于空字符串，我们需要 0 次

## 代码

代码支持：Python3

Python3 Code:

```python

class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if s == '':
            return 0
        def isPalindrome(s):
            l = 0
            r = len(s) - 1
            while l < r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True
        return 1 if isPalindrome(s) else 2
```

如果你觉得判断回文不是本题重点，也可以简单实现：

Python3 Code:

```python
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if s == '':
            return 0
        return 1 if s == s[::-1] else 2

```

## 关键点解析

- 注意审题目，一定要利用题目条件“只含有 a 和 b 两个字符”否则容易做的很麻烦

# 1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance(1334. 阈值距离内邻居最少的城市)

https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/

## 题目描述

```
有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。

返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。

注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。



示例 1：

```

![image.png](http://ww1.sinaimg.cn/large/e9f490c8ly1gbh9v5ygtsj20qo0k0aap.jpg)

```



输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
输出：3
解释：城市分布图如上。
每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：
城市 0 -> [城市 1, 城市 2]
城市 1 -> [城市 0, 城市 2, 城市 3]
城市 2 -> [城市 0, 城市 1, 城市 3]
城市 3 -> [城市 1, 城市 2]
城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。
示例 2：

```

![image.png](http://ww1.sinaimg.cn/large/e9f490c8ly1gbh9vg1w43j20qo0k0js8.jpg)

```

输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
输出：0
解释：城市分布图如上。
每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：
城市 0 -> [城市 1]
城市 1 -> [城市 0, 城市 4]
城市 2 -> [城市 3, 城市 4]
城市 3 -> [城市 2, 城市 4]
城市 4 -> [城市 1, 城市 2, 城市 3]
城市 0 在阈值距离 4 以内只有 1 个邻居城市。


提示：

2 <= n <= 100
1 <= edges.length <= n * (n - 1) / 2
edges[i].length == 3
0 <= fromi < toi < n
1 <= weighti, distanceThreshold <= 10^4
所有 (fromi, toi) 都是不同的。


```

## 思路

这道题的本质就是：

1. 在一个无向图中寻找每两个城镇的最小距离，我们使用 Floyd-Warshall 算法(英语：Floyd-Warshall algorithm)，中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法。
2. 筛选最小距离不大于  distanceThreshold 的城镇。
3. 统计每个城镇，其满足条件的城镇有多少个
4. 我们找出最少的即可

Floyd-Warshall 算法的时间复杂度和空间复杂度都是$O(N^3)$, 而空间复杂度可以优化到$O(N^2)$。Floyd-Warshall 的基本思想是对于每两个点之间的最小距离，要么经过中间节点 k，要么不经过，我们取两者的最小值，这是一种动态规划思想，详细的解法可以参考[Floyd-Warshall 算法(wikipedia)](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95)

## 代码

代码支持：Python3

Python3 Code:

```python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        # 构建dist矩阵
        dist = [[float('inf')] * n for _ in  range(n)]
        for i, j, w in edges:
            dist[i][j] = w
            dist[j][i] = w
        for i in range(n):
            dist[i][i] = 0
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

        # 过滤
        res = 0
        minCnt = float('inf')
        for i in range(n):
            cnt = 0
            for d in dist[i]:
                if d <= distanceThreshold:
                    cnt += 1
            if cnt <= minCnt:
                minCnt = cnt
                res = i
        return res


```

## 关键点解析

- Floyd-Warshall 算法
- 你可以将本文给的 Floyd-Warshall 算法当成一种解题模板使用

# 221.maximal-square

## 题目地址

https://leetcode.com/problems/maximal-square/

## 题目描述

```
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

Example:

Input:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
```

## 思路

![221.maximal-square](../assets/problems/221.maximal-square-1.jpg)

符合直觉的做法是暴力求解处所有的正方形，逐一计算面积，然后记录最大的。这种时间复杂度很高。

我们考虑使用动态规划，我们使用 dp[i][j]表示以 matrix[i][j]为右下角的顶点的可以组成的最大正方形的边长。
那么我们只需要计算所有的 i，j 组合，然后求出最大值即可。

我们来看下 dp[i][j] 怎么推导。 首先我们要看 matrix[i][j], 如果 matrix[i][j]等于 0，那么就不用看了，直接等于 0。
如果 matrix[i][j]等于 1，那么我们将 matrix[[i][j]分别往上和往左进行延伸，直到碰到一个 0 为止。

如图 dp[3][3] 的计算。 matrix[3][3]等于 1，我们分别往上和往左进行延伸，直到碰到一个 0 为止，上面长度为 1，左边为 3。
dp[2][2]等于 1(之前已经计算好了)，那么其实这里的瓶颈在于三者的最小值, 即`Min(1, 1, 3)`, 也就是`1`。 那么 dp[3][3] 就等于
`Min(1, 1, 3) + 1`。

![221.maximal-square](../assets/problems/221.maximal-square-2.jpg)

dp[i - 1][j - 1]我们直接拿到，关键是`往上和往左进行延伸`, 最直观的做法是我们内层加一个循环去做就好了。
但是我们仔细观察一下，其实我们根本不需要这样算。 我们可以直接用 dp[i - 1][j]和 dp[i][j -1]。
具体就是`Min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1`。

![221.maximal-square](../assets/problems/221.maximal-square-3.jpg)

事实上，这道题还有空间复杂度 O(N)的解法，其中 N 指的是列数。
大家可以去这个[leetcode 讨论](https://leetcode.com/problems/maximal-square/discuss/61803/C%2B%2B-space-optimized-DP)看一下。

## 关键点解析

- DP
- 递归公式可以利用 dp[i - 1][j]和 dp[i][j -1]的计算结果，而不用重新计算
- 空间复杂度可以降低到 O(n), n 为列数

## 代码

```js
/*
 * @lc app=leetcode id=221 lang=javascript
 *
 * [221] Maximal Square
 */
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
  if (matrix.length === 0) return 0;
  const dp = [];
  const rows = matrix.length;
  const cols = matrix[0].length;
  let max = Number.MIN_VALUE;

  for (let i = 0; i < rows + 1; i++) {
    if (i === 0) {
      dp[i] = Array(cols + 1).fill(0);
    } else {
      dp[i] = [0];
    }
  }

  for (let i = 1; i < rows + 1; i++) {
    for (let j = 1; j < cols + 1; j++) {
      if (matrix[i - 1][j - 1] === '1') {
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
        max = Math.max(max, dp[i][j]);
      } else {
        dp[i][j] = 0;
      }
    }
  }

  return max * max;
};
```

# 229.majority-element-ii

## 题目地址

https://leetcode.com/problems/majority-element-ii/description/

## 题目描述

```
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

Note: The algorithm should run in linear time and in O(1) space.

Example 1:

Input: [3,2,3]
Output: [3]
Example 2:

Input: [1,1,1,3,3,2,2,2]
Output: [1,2]
```

## 思路

这道题目和[169.majority-element](./169.majority-element.md) 很像。

我们仍然可以采取同样的方法 - “摩尔投票法”， 具体的思路可以参考上面的题目。

但是这里有一个不同的是这里的众数不再是超过`1 / 2`,而是超过`1 / 3`。
题目也说明了，超过三分之一的有可能有多个(实际上就是 0，1，2 三种可能)。

因此我们不能只用一个 counter 来解决了。 我们的思路是同时使用两个 counter，其他思路和上一道题目一样。

最后需要注意的是两个 counter 不一定都满足条件，这两个 counter 只是出现次数最多的两个数字。
有可能不满足出现次数大于 1/3， 因此最后我们需要进行过滤筛选。

这里画了一个图，大家可以感受一下：

![229.majority-element-ii-1](../assets/problems/229.majority-element-ii-1.jpeg)

![229.majority-element-ii-1](../assets/problems/229.majority-element-ii-2.jpeg)

## 关键点解析

- 摩尔投票法
- 两个 counter
- 最后得到的只是出现次数最多的两个数字，有可能不满足出现次数大于 1/3

## 代码

JavaScript 代码：

```js
/*
 * @lc app=leetcode id=229 lang=javascript
 *
 * [229] Majority Element II
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  const res = [];
  const len = nums.length;
  let n1 = null,
    n2 = null,
    cnt1 = 0,
    cnt2 = 0;

  for (let i = 0; i < len; i++) {
    if (n1 === nums[i]) {
      cnt1++;
    } else if (n2 === nums[i]) {
      cnt2++;
    } else if (cnt1 === 0) {
      n1 = nums[i];
      cnt1++;
    } else if (cnt2 === 0) {
      n2 = nums[i];
      cnt2++;
    } else {
      cnt1--;
      cnt2--;
    }
  }

  cnt1 = 0;
  cnt2 = 0;

  for (let i = 0; i < len; i++) {
    if (n1 === nums[i]) {
      cnt1++;
    } else if (n2 === nums[i]) {
      cnt2++;
    }
  }

  if (cnt1 > (len / 3) >>> 0) {
    res.push(n1);
  }
  if (cnt2 > (len / 3) >>> 0) {
    res.push(n2);
  }

  return res;
};
```

Java 代码：

```java
/*
 * @lc app=leetcode id=229 lang=java
 *
 * [229] Majority Element II
 */
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> res = new ArrayList<Integer>();
        if (nums == null || nums.length == 0)
            return res;
        int n1 = nums[0], n2 = nums[0], cnt1 = 0, cnt2 = 0, len = nums.length;
        for (int i = 0; i < len; i++) {
            if (nums[i] == n1)
                cnt1++;
            else if (nums[i] == n2)
                cnt2++;
            else if (cnt1 == 0) {
                n1 = nums[i];
                cnt1 = 1;
            } else if (cnt2 == 0) {
                n2 = nums[i];
                cnt2 = 1;
            } else {
                cnt1--;
                cnt2--;
            }
        }
        cnt1 = 0;
        cnt2 = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] == n1)
                cnt1++;
            else if (nums[i] == n2)
                cnt2++;
        }
        if (cnt1 > len / 3)
            res.add(n1);
        if (cnt2 > len / 3 && n1 != n2)
            res.add(n2);
        return res;
    }
}

```

## 扩展

如果题目中 3 变成了 k，怎么解决？

大家可以自己思考一下，我这里给一个参考链接：https://leetcode.com/problems/majority-element-ii/discuss/63500/JAVA-Easy-Version-To-Understand!!!!!!!!!!!!/64925

这个实现说实话不是很好，大家可以优化一下。

# 460.lfu-cache

## 题目地址

https://leetcode.com/problems/lfu-cache/

## 题目描述

```
Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

## 思路

[LFU(Least frequently used)](https://www.wikiwand.com/en/Least_frequently_used) 但内存容量满的情况下，有新的数据进来，需要更多空间的时候，就需要删除被访问频率最少的元素。

举个例子，比如说 cache 容量是 3，按顺序依次放入 `1，2，1，2，1，3`， cache 已存满 3 个元素 (1，2，3)， 这时如果想放入一个新的元素 4 的时候，就需要腾出一个元素空间。
用 LFU，这里就淘汰 3， 因为 3 的次数只出现依次， 1 和 2 出现的次数都比 3 多。

题中 `get` 和 `put` 都是 `O(1)`的时间复杂度，那么删除和增加都是`O(1)`，可以想到用双链表，和`HashMap`，用一个`HashMap, nodeMap,` 保存当前`key`，和 `node{key, value, frequent}`的映射。
这样`get(key)`的操作就是`O(1)`. 如果要删除一个元素，那么就需要另一个`HashMap，freqMap，`保存元素出现次数`(frequent)`和双链表`(DoublyLinkedlist)` 映射，
这里双链表存的是 frequent 相同的元素。每次`get`或`put`的时候，`frequent+1`，然后把`node`插入到双链表的`head node, head.next=node`
每次删除`freqent`最小的双链表的`tail node, tail.prev`。

用给的例子举例说明：

```
1. put(1, 1),
   - 首先查找nodeMap中有没有key=1对应的value，
       没有就新建node(key, value, freq) -> node1(1, 1, 1), 插入 nodeMap，{[1, node1]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把node1 插入doublylinkedlist head->next = node1.
   如下图，
```

![460.lfu-cache-1](../assets/problems/460.lfu-cache-1.jpg)

```
2. put(2, 2),
   - 首先查找nodeMap中有没有key=2对应的value，
       没有就新建node(key, value, freq) -> node2(2, 2, 1), 插入 nodeMap，{[1, node1], [2, node2]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把node2 插入doublylinkedlist head->next = node2.
   如下图，
```

![460.lfu-cache-2](../assets/problems/460.lfu-cache-2.jpg)

```
3. get(1),
   - 首先查找nodeMap中有没有key=1对应的value，nodeMap:{[1, node1], [2, node2]},
       找到node1，把node1 freq+1 -> node1(1,1,2)
   - 更新freqMap，删除freq=1，node1
   - 更新freqMap，插入freq=2，node1
   如下图，
```

![460.lfu-cache-3](../assets/problems/460.lfu-cache-3.jpg)

```
4. put(3, 3),
   - 判断cache的capacity，已满，需要淘汰使用次数最少的元素，找到最小的freq=1，删除双链表tail node.prev
       如果tailnode.prev != null, 删除。然后从nodeMap中删除对应的key。
   - 首先查找nodeMap中有没有key=3对应的value，
       没有就新建node(key, value, freq) -> node3(3, 3, 1), 插入 nodeMap，{[1, node1], [3, node3]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把node3 插入doublylinkedlist head->next = node3.
   如下图，
```

![460.lfu-cache-4](../assets/problems/460.lfu-cache-4.jpg)

```
5. get(2)
   - 查找nodeMap，如果没有对应的key的value，返回 -1。

6. get(3)
   - 首先查找nodeMap中有没有key=3对应的value，nodeMap:{[1, node1], [3, node3]},
       找到node3，把node3 freq+1 -> node3(3,3,2)
   - 更新freqMap，删除freq=1，node3
   - 更新freqMap，插入freq=2，node3
   如下图，
```

![460.lfu-cache-5](../assets/problems/460.lfu-cache-5.jpg)

```
7. put(4, 4),
   - 判断cache的capacity，已满，需要淘汰使用次数最少的元素，找到最小的freq=1，删除双链表tail node.prev
       如果tailnode.prev != null, 删除。然后从nodeMap中删除对应的key。
   - 首先查找nodeMap中有没有key=4对应的value，
       没有就新建node(key, value, freq) -> node4(4, 4, 1), 插入 nodeMap，{[4, node4], [3, node3]}
   - 查找freqMap中有没有freq=1 对应的value，
       没有就新建doublylinkedlist(head, tail), 把 node4 插入doublylinkedlist head->next = node4.
   如下图，
```

![460.lfu-cache-6](../assets/problems/460.lfu-cache-6.jpg)

```
8. get(1)
   - 查找nodeMap，如果没有对应的key的value，返回 -1。

9. get(3)
   - 首先查找nodeMap中有没有key=3对应的value，nodeMap:{[4, node4], [3, node3]},
       找到node3，把node3 freq+1 -> node3(3,3,3)
   - 更新freqMap，删除freq=2，node3
   - 更新freqMap，插入freq=3，node3
   如下图，
```

![460.lfu-cache-7](../assets/problems/460.lfu-cache-7.jpg)

```
10. get(4)
   - 首先查找nodeMap中有没有key=4对应的value，nodeMap:{[4, node4], [3, node3]},
       找到node4，把node4 freq+1 -> node4(4,4,2)
   - 更新freqMap，删除freq=1，node4
   - 更新freqMap，插入freq=2，node4
   如下图，
```

![460.lfu-cache-8](../assets/problems/460.lfu-cache-8.jpg)

## 关键点分析

用两个`Map`分别保存 `nodeMap {key, node}` 和 `freqMap{frequent, DoublyLinkedList}`。
实现`get` 和 `put`操作都是`O(1)`的时间复杂度。

可以用 Java 自带的一些数据结构，比如 HashLinkedHashSet，这样就不需要自己自建 Node，DoublelyLinkedList。
可以很大程度的缩减代码量。

## 代码(Java code)

```java
public class LC460LFUCache {
  class Node {
    int key, val, freq;
    Node prev, next;

    Node(int key, int val) {
      this.key = key;
      this.val = val;
      freq = 1;
    }
  }

  class DoubleLinkedList {
    private Node head;
    private Node tail;
    private int size;

    DoubleLinkedList() {
      head = new Node(0, 0);
      tail = new Node(0, 0);
      head.next = tail;
      tail.prev = head;
    }

    void add(Node node) {
      head.next.prev = node;
      node.next = head.next;
      node.prev = head;
      head.next = node;
      size++;
    }

    void remove(Node node) {
      node.prev.next = node.next;
      node.next.prev = node.prev;
      size--;
    }

    // always remove last node if last node exists
    Node removeLast() {
      if (size > 0) {
        Node node = tail.prev;
        remove(node);
        return node;
      } else return null;
    }
  }

  // cache capacity
  private int capacity;
  // min frequent
  private int minFreq;
  Map<Integer, Node> nodeMap;
  Map<Integer, DoubleLinkedList> freqMap;
  public LC460LFUCache(int capacity) {
    this.minFreq = 0;
    this.capacity = capacity;
    nodeMap = new HashMap<>();
    freqMap = new HashMap<>();
  }

  public int get(int key) {
    Node node = nodeMap.get(key);
    if (node == null) return -1;
    update(node);
    return node.val;
  }

  public void put(int key, int value) {
    if (capacity == 0) return;
    Node node;
    if (nodeMap.containsKey(key)) {
      node = nodeMap.get(key);
      node.val = value;
      update(node);
    } else {
      node = new Node(key, value);
      nodeMap.put(key, node);
      if (nodeMap.size() == capacity) {
        DoubleLinkedList lastList = freqMap.get(minFreq);
        nodeMap.remove(lastList.removeLast().key);
      }
      minFreq = 1;
      DoubleLinkedList newList = freqMap.getOrDefault(node.freq, new DoubleLinkedList());
      newList.add(node);
      freqMap.put(node.freq, newList);
    }
  }

  private void update(Node node) {
    DoubleLinkedList oldList = freqMap.get(node.freq);
    oldList.remove(node);
    if (node.freq == minFreq && oldList.size == 0) minFreq++;
    node.freq++;
    DoubleLinkedList newList = freqMap.getOrDefault(node.freq, new DoubleLinkedList());
    newList.add(node);
    freqMap.put(node.freq, newList);
  }
 }
```

## 参考(References)

1. [LFU(Least frequently used) Cache](https://www.wikiwand.com/en/Least_frequently_used)
2. [LeetCode discussion mylzsd](<https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList>)
3. [LeetCode discussion aaaeeeo](<https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList>)

# 472.concatenated-words

## 题目地址(472. 连接词)

https://leetcode-cn.com/problems/concatenated-words/

## 题目描述

```
给定一个不含重复单词的列表，编写一个程序，返回给定单词列表中所有的连接词。

连接词的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。

示例:

输入: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

输出: ["catsdogcats","dogcatsdog","ratcatdogcat"]

解释: "catsdogcats"由"cats", "dog" 和 "cats"组成;
     "dogcatsdog"由"dog", "cats"和"dog"组成;
     "ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。
说明:

给定数组的元素总数不超过 10000。
给定数组中元素的长度总和不超过 600000。
所有输入字符串只包含小写字母。
不需要考虑答案输出的顺序。
```

## 思路

本题我的思路是直接使用前缀树来解决。**标准的前缀树模板**我在之前的题解中提到了，感兴趣的可以到下方的相关题目中查看。

这道题这里我们不需要 search，我们的做法是：

- 先进行一次遍历，将 words 全部插入(insert)到前缀树中。
- 然后再进行一次遍历，查找每一个单词有几个单词表中的单词组成
- 如果大于 2，则将其加入到 res 中
- 最后返回 res 即可

我们构造的前缀树大概是这样的：

![472.concatenated-words.png](http://ww1.sinaimg.cn/large/e9f490c8ly1gbkcox4r06j21eb15fgq8.jpg)

问题的关键在于第二步中的**查找每一个单词有几个单词表中的单词组成**。 其实如果你了解前缀树的话应该不难写出来。 比如查找 catsdogcats：

- 我们先从 c 到 a 到 t，发现 t 是单词结尾，我们数量 + 1
- 然后将剩下的部分“sdogcats”重新执行上述过程。
- s 发现找不到，我们返回 0
- 因此最终结果是 1

很明显这个逻辑是错误的，正确的划分应该是：

- 我们先从 c 到 a 到 t，再到 s，此时数量 + 1
- 然后将剩下的“dogcats”重复上述过程
- dog 找到了，数量 + 1
- 最后将 cats 加入。也找到了，数量再加 1

由于我们并不知道 cat 这里断开，结果更大？还是 cats 这里断开结果更大？因此我们的做法是将其全部递归求出，然后取出最大值即可。如果我们直接这样递归的话，可能会超时，卡在最后一个测试用例上。一个简单的方式是记忆化递归，从而避免重复计算，经测试这种方法能够通过。

## 代码

代码支持：Python3

Python3 Code:

```python
class Trie:

    def __init__(self):
        self.Trie = {}
        self.visited = {}

    def insert(self, word):
        curr = self.Trie
        for w in word:
            if w not in curr:
                curr[w] = {}
            curr = curr[w]
        curr['#'] = 1

    def cntWords(self, word):
        if not word:
            return 0
        if word in self.visited:
            return self.visited[word]
        curr = self.Trie
        res = float('-inf')

        for i, w in enumerate(word):
            if w not in curr:
                return res
            curr = curr[w]
            if '#' in curr:
                res = max(res, 1 + self.cntWords(word[i + 1:]))
        self.visited[word] = res
        return res


class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        self.trie = Trie()
        res = []

        for word in words:
            self.trie.insert(word)
        for word in words:
            if self.trie.cntWords(word) >= 2:
                res.append(word)
        return res
```

## 关键点分析

- 前缀树

## 相关题目

- [208.implement-trie-prefix-tree](https://github.com/azl397985856/leetcode/blob/b8e8fa5f0554926efa9039495b25ed7fc158372a/problems/208.implement-trie-prefix-tree.md)
- [211.add-and-search-word-data-structure-design](https://github.com/azl397985856/leetcode/blob/b0b69f8f11dace3a9040b54532105d42e88e6599/problems/211.add-and-search-word-data-structure-design.md)
- [212.word-search-ii](https://github.com/azl397985856/leetcode/blob/b0b69f8f11dace3a9040b54532105d42e88e6599/problems/212.word-search-ii.md)
- [0472.concatenated-words](./problems/472.concatenated-words.md)

# 493.reverse-pairs

## 题目地址(493. 翻转对)

https://leetcode-cn.com/problems/reverse-pairs/description/

## 题目描述

```
给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。

你需要返回给定数组中的重要翻转对的数量。

示例 1:

输入: [1,3,2,3,1]
输出: 2
示例 2:

输入: [2,4,3,5,1]
输出: 3
注意:

给定数组的长度不会超过50000。
输入数组中的所有数字都在32位整数的表示范围内。

```

## 暴力法

### 思路

读完这道题你应该就能联想到逆序数才行。求解逆序数最简单的做法是使用双层循环暴力求解。我们仿照求解决逆序数的解法来解这道题(其实唯一的区别就是系数从 1 变成了 2)。

### 代码

代码支持：Python3

Python3 Code:

```python
class Solution(object):
    def reversePairs(self, nums):
        n = len(nums)
        cnt = 0
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] > 2 * nums[j]:
                    cnt += 1
        return cnt
```

## 分治法

### 思路

如果你能够想到逆序数，那么你很可能直到使用类似归并排序的方法可以求解逆序数。实际上逆序数只是归并排序的副产物而已。

我们在正常的归并排序的代码中去计算逆序数即可。由于每次分治的过程，左右两段数组分别是有序的，因此我们可以减少一些运算。 从时间复杂度的角度上讲，我们从$O(N^2)$优化到了 $O(NlogN)$。

具体来说，对两段有序的数组，有序数组内部是不需要计算逆序数的。 我们计算逆序数的逻辑只是计算两个数组之间的逆序数，我们假设两个数组是 A 和 B，并且 A 数组最大的元素不大于 B 数组最小的元素。而要做到这样，我们只需要常规的归并排序即可。

接下来问题转化为求解两个有序数组之间的逆序数，并且两个有序数组之间满足关系`A数组最大的元素不大于B数组最小的元素`。

关于计算逆序数的核心代码(Python3):

```python
l = r = 0
while l < len(left) and r < len(right):
    if left[l] <= 2 * right[r]:
        l += 1
    else:
        self.cnt += len(left) - l
        r += 1
```

### 代码

代码支持：Python3

Python3 Code:

```python
class Solution(object):
    def reversePairs(self, nums):
        self.cnt = 0

        def mergeSort(lst):
            L = len(lst)
            if L <= 1:
                return lst
            return mergeTwo(mergeSort(lst[:L//2]), mergeSort(lst[L//2:]))

        def mergeTwo(left, right):
            l = r = 0
            while l < len(left) and r < len(right):
                if left[l] <= 2 * right[r]:
                    l += 1
                else:
                    self.cnt += len(left) - l
                    r += 1
            return sorted(left+right)

        mergeSort(nums)
        return self.cnt

```

对于具体的排序过程我们偷懒直接使用了语言内置的方法 sorted，这在很多时候是有用的，即使你是参加面试，这种方式通常也是允许的。省略非核心的考点，可以使得问题更加聚焦，这是一种解决问题的思路，在工作中也很有用。

## 关键点解析

- 归并排序
- 逆序数
- 分治
- 识别考点，其他非重点可以使用语言内置方法

## 代码

## 扩展

这道题还有很多别的解法，感性的可以参考下这个题解 [General principles behind problems similar to "Reverse Pairs"](https://leetcode.com/problems/reverse-pairs/discuss/97268/General-principles-behind-problems-similar-to-%22Reverse-Pairs%22)

# 5.longest-palindromic-substring

## 题目地址

https://leetcode.com/problems/longest-palindromic-substring/description/

## 题目描述

```
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
```

## 思路

这是一道最长回文的题目，要我们求出给定字符串的最大回文子串。

![5.longest-palindromic-substring](../assets/problems/5.longest-palindromic-substring-1.png)

解决这类问题的核心思想就是两个字“延伸”，具体来说

- 如果一个字符串是回文串，那么在它左右分别加上一个相同的字符，那么它一定还是一个回文串
- 如果一个字符串不是回文串，或者在回文串左右分别加不同的字符，得到的一定不是回文串

事实上，上面的分析已经建立了大问题和小问题之间的关联，
基于此，我们可以建立动态规划模型。

我们可以用 dp[i][j] 表示 s 中从 i 到 j(包括 i 和 j)是否可以形成回文，
状态转移方程只是将上面的描述转化为代码即可：

```js
if (s[i] === s[j] && dp[i + 1][j - 1]) {
  dp[i][j] = true;
}
```

![5.longest-palindromic-substring-2](../assets/problems/5.longest-palindromic-substring-2.png)

base case 就是一个字符(轴对称点是本身)，或者两个字符(轴对称点是介于两者之间的虚拟点)。

![5.longest-palindromic-substring-3](../assets/problems/5.longest-palindromic-substring-3.png)

## 关键点

- ”延伸“(extend)

## 代码

```js
/*
 * @lc app=leetcode id=5 lang=javascript
 *
 * [5] Longest Palindromic Substring
 */
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  // babad
  // tag : dp
  if (!s || s.length === 0) return '';
  let res = s[0];

  const dp = [];

  // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]
  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = [];
    for (let j = i; j < s.length; j++) {
      if (j - i === 0) dp[i][j] = true;
      // specail case 1
      else if (j - i === 1 && s[i] === s[j]) dp[i][j] = true;
      // specail case 2
      else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        // state transition
        dp[i][j] = true;
      }

      if (dp[i][j] && j - i + 1 > res.length) {
        // update res
        res = s.slice(i, j + 1);
      }
    }
  }

  return res;
};
```

## 相关题目

- [516.longest-palindromic-subsequence](./516.longest-palindromic-subsequence.md)

# 50.pow-x-n

## 题目地址(50. Pow(x, n))

https://leetcode-cn.com/problems/powx-n/description/

## 题目描述

```
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:

输入: 2.00000, 10
输出: 1024.00000
示例 2:

输入: 2.10000, 3
输出: 9.26100
示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
说明:

-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

```

## 解法零 - 遍历法

### 思路

这道题是让我们实现数学函数`幂`，因此直接调用系统内置函数是不被允许的。

符合直觉的做法是`将x乘以n次`，这种做法的时间复杂度是$O(N)$。

经实际测试，这种做法果然超时了。测试用例通过 291/304，在 `0.00001\n2147483647`这个测试用例挂掉了。如果是面试，这个解法可以作为一种兜底解法。

### 代码

语言支持: Python3

Python3 Code:

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            return 1 / self.myPow(x, -n)
        res = 1
        for _ in range(n):
            res *= x
        return res
```

## 解法一 - 普通递归(超时法)

### 思路

首先我们要知道：

- 如果想要求 x ^ 4，那么我们可以求 (x^2)^2
- 如果是奇数，会有一点不同。 比如 x ^ 5 就等价于 x \* (x^2)^2。

> 当然 x ^ 5 可以等价于 (x ^ 2) ^ 2.5, 但是这不相当于直接调用了幂函数了么。对于整数，我们可以很方便的模拟，但是小数就不方便了。

我们的思路就是：

- 将 n 地板除 2，我们不妨设结果为 a
- 那么 myPow(x, n) 就等价于 `myPow(x, a) * myPow(x, n - a)`

很可惜这种算法也会超时，原因在于重复计算会比较多，你可以试一下缓存一下计算看能不能通过。

> 如果你搞不清楚有哪些重复计算，建议画图理解一下。

### 代码

语言支持: Python3

Python3 Code:

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n == 1:
            return x
        if n < 0:
            return 1 / self.myPow(x, -n)
        return self.myPow(x, n // 2) * self.myPow(x, n - n // 2)
```

## 解法二 - 优化递归

### 思路

上面的解法每次直接 myPow 都会调用两次自己。我们不从缓存计算角度，而是从减少这种调用的角度来优化。

我们考虑 myPow 只调用一次自身可以么？ 没错，是可以的。

我们的思路就是：

- 如果 n 是偶数，我们将 n 折半，底数变为 x^2
- 如果 n 是奇数， 我们将 n 减去 1 ，底数不变，得到的结果再乘上底数 x

这样终于可以 AC。

### 代码

语言支持: Python3

Python3 Code:

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n == 1:
            return x
        if n < 0:
            return 1 / self.myPow(x, -n)
        return self.myPow(x _ x, n // 2) if n % 2 == 0 else x _ self.myPow(x, n - 1)
```

## 解法三 - 位运算

### 思路

我们来从位(bit)的角度来看一下这道题。如果你经常看我的题解和文章的话，可能知道我之前写过几次相关的“从位的角度思考分治法”，比如 LeetCode [458.可怜的小猪](https://leetcode-cn.com/problems/poor-pigs/description/)。

以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gbdseolzbmj30t802mjrk.jpg)

![](https://tva1.sinaimg.cn/large/006tNbRwly1gbdssrrsh6j30xp0u040e.jpg)

因此我们的算法就是：

- 不断的求解 x 的 2^0 次方，x 的 2^1 次方，x 的 2^2 次方等等。
- 将 n 转化为二进制表示
- 将 n 的二进制表示中`1的位置`pick 出来。比如 n 的第 i 位为 1，那么就将 x^i pick 出来。
- 将 pick 出来的结果相乘

![](https://tva1.sinaimg.cn/large/006tNbRwly1gbdtiky90rj30vq0hcab4.jpg)

这里有两个问题：

第一个问题是`似乎我们需要存储 x^i 以便后续相乘的时候用到`。实际上，我们并不需要这么做。我们可以采取一次遍历的方式来完成，具体看代码。

第二个问题是，如果我们从低位到高位计算的时候，我们如何判断最高位置是否为 1？我们需要一个 bitmask 来完成，这种算法我们甚至需要借助一个额外的变量。 然而我们可以 hack 一下，直接从高位到低位进行计算，这个时候我们只需要判断最后一位是否为 1 就可以了，这个就简单了，我们直接和 1 进行一次`与运算`即可。

### 代码

语言支持: Python3

Python3 Code:

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n < 0:
            return 1 / self.myPow(x, -n)
        res = 1
        while n:
            if n & 1 == 1:
                res *= x
            x *= x
            n >>= 1
        return res
```

## 关键点解析

- 超时分析
- hashtable
- 数学分析
- 位运算
- 二进制转十进制

## 相关题目

- [458.可怜的小猪](https://leetcode-cn.com/problems/poor-pigs/description/)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbdrfn9n2wj30wn0u0dp2.jpg)

# 501.Find-Mode-in-Binary-Search-Tree

## Problem on LeetCode

https://leetcode.com/problems/find-mode-in-binary-search-tree/

## Description

Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.

Assume a BST is defined as follows:

- The left subtree of a node contains only nodes with keys less than or equal to the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

For example:
Given BST `[1,null,2,2]`,

```bash
   1
    \
     2
    /
   2
```

return `[2]`.

Note: If a tree has more than one mode, you can return them in any order.

Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).

## Ideas

Basically, it needs traversing, counting and recording. `map` can be used to help us to do record and count.
For doing that without using any extra space, the property of BST will be used. For each node, the value of the left child is no greater than its value, while the value of right child is no less than the its value. So, when traversing each node, only the value of previous node is required to be compared with the value of current node for counting.
As the problem shown, an array of intergers will be returned. While the number of modes is unknown, using `ArrayList` to store all outputs is a good choice because `ArrayList` can be converted into array conveniently.

## Codes

Supported Language: `Java`

- Java Code:

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList<> ();
    TreeNode preNode = null;
    int max = 0, count = 0;

    public int[] findMode(TreeNode root) {
        helper(root);
        int[] res = new int[list.size()];
        for (int i=0; i<res.length; i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    private void helper (TreeNode root) {
        if (root == null) return;
        helper(root.left);

        if (preNode != null && root.val == preNode.val) {
            count++;
        } else {
            count = 1;
        }

        if (count > max) {
            list.clear();
            list.add(root.val);
            max = count;
        } else if (max == count) {
            list.add(root.val);
        }
        preNode = root;
        helper(root.right);
    }
}
```

# 53.maximum-sum-subarray-cn

## 题目地址

https://leetcode.com/problems/maximum-subarray/

## 题目描述

```
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
```

## 思路

这道题求解连续最大子序列和，以下从时间复杂度角度分析不同的解题思路。

#### 解法一 - 暴力解 (暴力出奇迹， 噢耶！)

一般情况下，先从暴力解分析，然后再进行一步步的优化。

**原始暴力解：**(超时)

求子序列和，那么我们要知道子序列的首尾位置，然后计算首尾之间的序列和。用 2 个 for 循环可以枚举所有子序列的首尾位置。
然后用一个 for 循环求解序列和。这里时间复杂度太高，`O(n^3)`.

#### 复杂度分析

- _时间复杂度：_ `O(n^3) - n 是数组长度`
- _空间复杂度：_ `O(1)`

#### 解法二 - 前缀和 + 暴力解

**优化暴力解：** (震惊，居然 AC 了)

在暴力解的基础上，用前缀和我们可以优化到暴力解`O(n^2)`, 这里以空间换时间。
这里可以使用原数组表示`prefixSum`, 省空间。

求序列和可以用前缀和(`prefixSum`) 来优化，给定子序列的首尾位置`(l, r),`
那么序列和 `subarraySum=prefixSum[r] - prefixSum[l - 1];`
用一个全局变量`maxSum`, 比较每次求解的子序列和，`maxSum = max(maxSum, subarraySum)`.

#### 复杂度分析

- _时间复杂度：_ `O(n^2) - n 是数组长度`
- _空间复杂度：_ `O(n) - prefixSum 数组空间为n`

> 如果用更改原数组表示前缀和数组，空间复杂度降为`O(1)`

但是时间复杂度还是太高，还能不能更优化。答案是可以，前缀和还可以优化到`O(n)`.

#### 解法三 - 优化前缀和 - from [**@lucifer**](https://github.com/azl397985856)

我们定义函数`S(i)` ，它的功能是计算以 `0(包括 0)`开始加到 `i(包括 i)`的值。

那么 `S(j) - S(i - 1)` 就等于 从 `i` 开始(包括 i)加到 `j`(包括 j)的值。

我们进一步分析，实际上我们只需要遍历一次计算出所有的 `S(i)`, 其中 `i = 0,1,2....,n-1。`
然后我们再减去之前的`S(k)`,其中 `k = 0，1，i - 1`，中的最小值即可。 因此我们需要
用一个变量来维护这个最小值，还需要一个变量维护最大值。

#### 复杂度分析

- _时间复杂度：_ `O(n) - n 是数组长度`
- _空间复杂度：_ `O(1)`

#### 解法四 - [分治法](https://www.wikiwand.com/zh-hans/%E5%88%86%E6%B2%BB%E6%B3%95)

我们把数组`nums`以中间位置(`m`)分为左(`left`)右(`right`)两部分. 那么有，
`left = nums[0]...nums[m - 1]` 和 `right = nums[m + 1]...nums[n-1]`

最大子序列和的位置有以下三种情况：

1. 考虑中间元素`nums[m]`, 跨越左右两部分，这里从中间元素开始，往左求出后缀最大，往右求出前缀最大, 保持连续性。
2. 不考虑中间元素，最大子序列和出现在左半部分，递归求解左边部分最大子序列和
3. 不考虑中间元素，最大子序列和出现在右半部分，递归求解右边部分最大子序列和

分别求出三种情况下最大子序列和，三者中最大值即为最大子序列和。

举例说明，如下图：
![maximum subarray sum divide conquer](../assets/problems/53.maximum-sum-subarray-divideconquer.png)

#### 复杂度分析

- _时间复杂度：_ `O(nlogn) - n 是数组长度`
- _空间复杂度：_ `O(logn)` - 因为调用栈的深度最多是 logn。

#### 解法五 - [动态规划](https://www.wikiwand.com/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

动态规划的难点在于找到状态转移方程，

`dp[i] - 表示到当前位置 i 的最大子序列和`

状态转移方程为：
`dp[i] = max(dp[i - 1] + nums[i], nums[i])`

初始化：`dp[0] = nums[0]`

从状态转移方程中，我们只关注前一个状态的值，所以不需要开一个数组记录位置所有子序列和，只需要两个变量，

`currMaxSum - 累计最大和到当前位置i`

`maxSum - 全局最大子序列和`:

- `currMaxSum = max(currMaxSum + nums[i], nums[i])`
- `maxSum = max(currMaxSum, maxSum)`

如图：
![maximum subarray sum dp](../assets/problems/53.maximum-sum-subarray-dp.png)

#### 复杂度分析

- _时间复杂度:_ `O(n) - n 是数组长度`
- _空间复杂度:_ `O(1)`

## 关键点分析

1. 暴力解，列举所有组合子序列首尾位置的组合，求解最大的子序列和, 优化可以预先处理，得到前缀和
2. 分治法，每次从中间位置把数组分为左右中三部分， 分别求出左右中(这里中是包括中间元素的子序列)最大和。对左右分别深度递归，三者中最大值即为当前最大子序列和。
3. 动态规划，找到状态转移方程，求到当前位置最大和。

## 代码 (`Java/Python3/Javascript`)

#### 解法二 - 前缀和 + 暴力

_Java code_

```java
class MaximumSubarrayPrefixSum {
  public int maxSubArray(int[] nums) {
      int len = nums.length;
      int maxSum = Integer.MIN_VALUE;
      int sum = 0;
      for (int i = 0; i < len; i++) {
        sum = 0;
        for (int j = i; j < len; j++) {
          sum += nums[j];
          maxSum = Math.max(maxSum, sum);
        }
      }
      return maxSum;
  }
}
```

_Python3 code_ `(TLE)`

```python
import sys
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        maxSum = -sys.maxsize
        sum = 0
        for i in range(n):
            sum = 0
            for j in range(i, n):
                sum += nums[j]
                maxSum = max(maxSum, sum)

        return maxSum
```

_Javascript code_ from [**@lucifer**](https://github.com/azl397985856)

```js
function LSS(list) {
  const len = list.length;
  let max = -Number.MAX_VALUE;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum = 0;
    for (let j = i; j < len; j++) {
      sum += list[j];
      if (sum > max) {
        max = sum;
      }
    }
  }

  return max;
}
```

#### 解法三 - 优化前缀和

_Java code_

```java
class MaxSumSubarray {
  public int maxSubArray3(int[] nums) {
      int maxSum = nums[0];
      int sum = 0;
      int minSum = 0;
      for (int num : nums) {
        // prefix Sum
        sum += num;
        // update maxSum
        maxSum = Math.max(maxSum, sum - minSum);
        // update minSum
        minSum = Math.min(minSum, sum);
      }
      return maxSum;
  }
}
```

_Python3 code_

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        maxSum = nums[0]
        minSum = sum = 0
        for i in range(n):
            sum += nums[i]
            maxSum = max(maxSum, sum - minSum)
            minSum = min(minSum, sum)

        return maxSum
```

_Javascript code_ from [**@lucifer**](https://github.com/azl397985856)

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  let min = 0;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum += list[i];
    if (sum - min > max) max = sum - min;
    if (sum < min) {
      min = sum;
    }
  }

  return max;
}
```

#### 解法四 - 分治法

_Java code_

```java
class MaximumSubarrayDivideConquer {
  public int maxSubArrayDividConquer(int[] nums) {
      if (nums == null || nums.length == 0) return 0;
      return helper(nums, 0, nums.length - 1);
    }
    private int helper(int[] nums, int l, int r) {
      if (l > r) return Integer.MIN_VALUE;
      int mid = (l + r) >>> 1;
      int left = helper(nums, l, mid - 1);
      int right = helper(nums, mid + 1, r);
      int leftMaxSum = 0;
      int sum = 0;
      // left surfix maxSum start from index mid - 1 to l
      for (int i = mid - 1; i >= l; i--) {
        sum += nums[i];
        leftMaxSum = Math.max(leftMaxSum, sum);
      }
      int rightMaxSum = 0;
      sum = 0;
      // right prefix maxSum start from index mid + 1 to r
      for (int i = mid + 1; i <= r; i++) {
        sum += nums[i];
        rightMaxSum = Math.max(sum, rightMaxSum);
      }
      // max(left, right, crossSum)
      return Math.max(leftMaxSum + rightMaxSum + nums[mid], Math.max(left, right));
    }
}
```

_Python3 code_

```python
import sys
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        return self.helper(nums, 0, len(nums) - 1)
    def helper(self, nums, l, r):
        if l > r:
            return -sys.maxsize
        mid = (l + r) // 2
        left = self.helper(nums, l, mid - 1)
        right = self.helper(nums, mid + 1, r)
        left_suffix_max_sum = right_prefix_max_sum = 0
        sum = 0
        for i in reversed(range(l, mid)):
            sum += nums[i]
            left_suffix_max_sum = max(left_suffix_max_sum, sum)
        sum = 0
        for i in range(mid + 1, r + 1):
            sum += nums[i]
            right_prefix_max_sum = max(right_prefix_max_sum, sum)
        cross_max_sum = left_suffix_max_sum + right_prefix_max_sum + nums[mid]
        return max(cross_max_sum, left, right)
```

_Javascript code_ from [**@lucifer**](https://github.com/azl397985856)

```js
function helper(list, m, n) {
  if (m === n) return list[m];
  let sum = 0;
  let lmax = -Number.MAX_VALUE;
  let rmax = -Number.MAX_VALUE;
  const mid = ((n - m) >> 1) + m;
  const l = helper(list, m, mid);
  const r = helper(list, mid + 1, n);
  for (let i = mid; i >= m; i--) {
    sum += list[i];
    if (sum > lmax) lmax = sum;
  }

  sum = 0;

  for (let i = mid + 1; i <= n; i++) {
    sum += list[i];
    if (sum > rmax) rmax = sum;
  }

  return Math.max(l, r, lmax + rmax);
}

function LSS(list) {
  return helper(list, 0, list.length - 1);
}
```

#### 解法五 - 动态规划

_Java code_

```java
class MaximumSubarrayDP {
  public int maxSubArray(int[] nums) {
     int currMaxSum = nums[0];
     int maxSum = nums[0];
     for (int i = 1; i < nums.length; i++) {
       currMaxSum = Math.max(currMaxSum + nums[i], nums[i]);
       maxSum = Math.max(maxSum, currMaxSum);
     }
     return maxSum;
  }
}
```

_Python3 code_

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        max_sum_ending_curr_index = max_sum = nums[0]
        for i in range(1, n):
            max_sum_ending_curr_index = max(max_sum_ending_curr_index + nums[i], nums[i])
            max_sum = max(max_sum_ending_curr_index, max_sum)

        return max_sum
```

_Javascript code_ from [**@lucifer**](https://github.com/azl397985856)

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  for (let i = 1; i < len; i++) {
    list[i] = Math.max(0, list[i - 1]) + list[i];
    if (list[i] > max) max = list[i];
  }

  return max;
}
```

## 扩展

- 如果数组是二维数组，求最大子数组的和？
- 如果要求最大子序列的乘积？

## 相似题

- [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)
- [Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)

# 60.permutation-sequence

## 题目地址(第 K 个排列)

https://leetcode-cn.com/problems/permutation-sequence/description/

## 标签

- 数学
- 回溯
- 找规律
- factorial

## 公司

Twitter

## 题目描述

```
给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1, n!]。
示例 1:

输入: n = 3, k = 3
输出: "213"
示例 2:

输入: n = 4, k = 9
输出: "2314"
```

## 思路

LeetCode 上关于排列的题目截止目前(2020-01-06)主要有三种类型：

- 生成全排列
- 生成下一个排列
- 生成第 k 个排列(我们的题目就是这种)

我们不可能求出所有的排列，然后找到第 k 个之后返回。因为排列的组合是 N！，要比 2^n 还要高很多，非常有可能超时。我们必须使用一些巧妙的方法。

我们以题目中的 n= 3 k = 3 为例：

- "123"
- "132"
- "213"
- "231"
- "312"
- "321"

可以看出 1xx，2xx 和 3xx 都有两个，如果你知道阶乘的话，实际上是 2！个。 我们想要找的是第 3 个。那么我们可以直接跳到 2 开头，我们排除了以 1 开头的排列，问题缩小了，我们将 2 加入到结果集，我们不断重复上述的逻辑，知道结果集的元素为 n 即可。

## 关键点解析

- 找规律
- 排列组合

## 代码

- 语言支持: Python3

```python
import math

class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        res = ""
        candidates = [str(i) for i in range(1, n + 1)]

        while n != 0:
            facto = math.factorial(n - 1)
            # i 表示前面被我们排除的组数，也就是k所在的组的下标
            # k // facto 是不行的， 比如在 k % facto == 0的情况下就会有问题
            i = math.ceil(k / facto) - 1
            # 我们把candidates[i]加入到结果集，然后将其弹出candidates(不能重复使用元素)
            res += candidates[i]
            candidates.pop(i)
            # k 缩小了 facto *  i
            k -= facto * i
            # 每次迭代我们实际上就处理了一个元素，n 减去 1，当n == 0 说明全部处理完成，我们退出循环
            n -= 1
        return res
```

# 79.word-search

## 题目地址

https://leetcode.com/problems/word-search/

## 题目描述

```
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

## 思路

在 2D 表中搜索是否有满足给定单词的字符组合，要求所有字符都是相邻的(方向不限). 题中也没有要求字符的起始和结束位置。

在起始位置不确定的情况下，扫描二维数组，找到字符跟给定单词的第一个字符相同的，四个方向(上，下，左，右)分别 DFS 搜索，
如果任意方向满足条件，则返回结果。不满足，回溯，重新搜索。

举例说明：如图二维数组，单词："SEE"

```
1. 扫描二维数组，找到board[1,0] = word[0]，匹配单词首字母。
2. 做DFS(上，下，左，右 四个方向)

如下图：
```

![word search 1](../assets/problems/79.word-search-1.png)

起始位置(1，0)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1，0)为已经访问过，board[1][0] = '*'
2. 上(0，0)字符为 'A' 不匹配,
3. 下(2，0)字符为 'A'，不匹配,
4. 左(-1，0)超越边界，不匹配,
5. 右(1，1)字符 'F'，不匹配

如下图：
```

![word search 2](../assets/problems/79.word-search-2.png)

由于从起始位置 DFS 都不满足条件，所以

```
1. 回溯，标记起始位置(1，0)为未访问。board[1][0] = 'S'.
2. 然后继续扫描二维数组，找到下一个起始位置(1，3)

如下图：
```

![word search 3](../assets/problems/79.word-search-3.png)

起始位置(1，3)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1, 3)为已经访问过，board[1][3] = '*'
2. 上(0，3)字符为 'E', 匹配, 继续DFS搜索(参考位置为(0，3)位置DFS搜索步骤描述)
3. 下(2，3)字符为 'E'，匹配, #2匹配，先进行#2 DFS搜索，由于#2 DFS搜索没有找到与单词匹配，继续DFS搜索(参考位置为(2，3)DFS搜索步骤描述)
4. 左(1，2)字符为 'C'，不匹配,
5. 右(1，4)超越边界，不匹配

如下图：
```

![word search 4](../assets/problems/79.word-search-4.png)

位置(0，3)满足条件，继续 DFS，判断相邻的字符是否匹配单词下一个字符 `E`

```
1. 标记当前字符(0，3)为已经访问过，board[0][3] = '*'
2. 上 (-1，3)超越边界，不匹配
3. 下(1，3)已经访问过，
4. 左(0，2)字符为 'C'，不匹配
5. 右(1，4)超越边界，不匹配

如下图
```

![word search 5](../assets/problems/79.word-search-5.png)

从位置(0，3)DFS 不满足条件，继续位置(2，3)DFS 搜索

```
1. 回溯，标记起始位置(0，3)为未访问。board[0][3] = 'E'.
2. 回到满足条件的位置(2，3)，继续DFS搜索，判断相邻的字符是否匹配单词下一个字符 'E'
3. 上 (1，3)已访问过
4. 下(3，3)超越边界，不匹配
5. 左(2，2)字符为 'E'，匹配
6. 右(2，4)超越边界，不匹配

如下图：
```

![word search 6](../assets/problems/79.word-search-6.png)

单词匹配完成，满足条件，返回 `True`.
![word search 7](../assets/problems/79.word-search-7.png)

#### 复杂度分析

- _时间复杂度：_ `O(m*n) - m 是二维数组行数， n 是二维数组列数`
- _空间复杂度：_ `O(1) - 这里在原数组中标记当前访问过，没有用到额外空间`

> **注意**：如果用 Set 或者是 boolean[][]来标记字符位置是否已经访问过，需要额外的空间 `O(m*n)`.

## 关键点分析

- 遍历二维数组的每一个点，找到起始点相同的字符，做 DFS
- DFS 过程中，要记录已经访问过的节点，防止重复遍历，这里(Java Code 中)用 `*` 表示当前已经访问过，也可以用 Set 或者是 boolean[][]数组记录访问过的节点位置。
- 是否匹配当前单词中的字符，不符合回溯，这里记得把当前 `*` 重新设为当前字符。如果用 Set 或者是 boolean[][]数组，记得把当前位置重设为没有访问过。

## 代码 (`Java/Javascript/Python3`)

```js
/*
 * @lc app=leetcode id=79 lang=javascript
 *
 * [79] Word Search
 */
function DFS(board, row, col, rows, cols, word, cur) {
  // 边界检查
  if (row >= rows || row < 0) return false;
  if (col >= cols || col < 0) return false;

  const item = board[row][col];

  if (item !== word[cur]) return false;

  if (cur + 1 === word.length) return true;

  // 如果你用hashmap记录访问的字母， 那么你需要每次backtrack的时候手动清除hashmap，并且需要额外的空间
  // 这里我们使用一个little trick

  board[row][col] = null;

  // 上下左右
  const res =
    DFS(board, row + 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row - 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row, col - 1, rows, cols, word, cur + 1) ||
    DFS(board, row, col + 1, rows, cols, word, cur + 1);

  board[row][col] = item;

  return res;
}
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  if (word.length === 0) return true;
  if (board.length === 0) return false;

  const rows = board.length;
  const cols = board[0].length;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const hit = DFS(board, i, j, rows, cols, word, 0);
      if (hit) return true;
    }
  }
  return false;
};
```

## 参考(References)

1. [回溯法 Wiki](https://www.wikiwand.com/zh/%E5%9B%9E%E6%BA%AF%E6%B3%95)

# 80.remove-duplicates-from-sorted-array-ii

## 题目地址(删除排序数组中的重复项 II)

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/description/

## 题目描述

```
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。
说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

```

## 思路

”删除排序“类题目截止到现在(2020-1-15)一共有四道题：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gax0eadc5ej30x60ce76i.jpg)

这道题是[26.remove-duplicates-from-sorted-array](./26.remove-duplicates-from-sorted-array.md) 的进阶版本，唯一的不同是不再是全部元素唯一，而是全部元素不超过 2 次。实际上这种问题可以更抽象一步，即“删除排序数组中的重复项，使得相同数字最多出现 k 次”
。 那么这道题 k 就是 2， 26.remove-duplicates-from-sorted-array 的 k 就是 1。

上一题我们使用了快慢指针来实现，这道题也是一样，只不过逻辑稍有不同。 其实快慢指针本质是读写指针，在这里我们的快指针实际上就是读指针，而慢指针恰好相当于写指针。”快慢指针的说法“便于描述和记忆，“读写指针”的说法更便于理解本质。本文中，以下内容均描述为快慢指针。

- 初始化快慢指针 slow ， fast ，全部指向索引为 0 的元素。
- fast 每次移动一格
- 慢指针选择性移动，即只有写入数据之后才移动。是否写入数据取决于 slow - 2 对应的数字和 fast 对应的数字是否一致。
- 如果一致，我们不应该写。 否则我们就得到了三个相同的数字，不符合题意
- 如果不一致，我们需要将 fast 指针的数据写入到 slow 指针。
- 重复这个过程，直到 fast 走到头，说明我们已无数字可写。

图解(红色的两个数字，表示我们需要比较的两个数字)：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0oyt4yhj30n10hpdgc.jpg)

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0p3ri3ij30ga0880ss.jpg)

## 关键点分析

- 快慢指针
- 读写指针
- 删除排序问题

## 代码

代码支持： Python

Python Code：

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        # 写指针
        i = 0
        K = 2
        for num in nums:
            if i < K or num != nums[i-K]:
                nums[i] = num
                i += 1
        return i
```

基于这套代码，你可以轻易地实现 k 为任意正整数的算法。

## 相关题目

正如上面所说，相关题目一共有三道(排除自己)。其中一道我们仓库已经讲到了。剩下两道原理类似，但是实际代码和细节有很大不同，原因就在于数组可以随机访问，而链表不行。 感兴趣的可以做一下剩下的两道链表题。

- 82. 删除排序链表中的重复元素 II

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0txa7gbj31lq0tg0zm.jpg)

- 83. 删除排序链表中的重复元素

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gax0uzm0euj318c0se44t.jpg)

# 874.walking-robot-simulation

## 题目地址(874. 模拟行走机器人)

https://leetcode-cn.com/problems/walking-robot-simulation/submissions/

## 题目描述

```
机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：

-2：向左转 90 度
-1：向右转 90 度
1 <= x <= 9：向前移动 x 个单位长度
在网格上有一些格子被视为障碍物。

第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])

如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。

返回从原点到机器人的最大欧式距离的平方。



示例 1：

输入: commands = [4,-1,3], obstacles = []
输出: 25
解释: 机器人将会到达 (3, 4)
示例 2：

输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出: 65
解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处


提示：

0 <= commands.length <= 10000
0 <= obstacles.length <= 10000
-30000 <= obstacle[i][0] <= 30000
-30000 <= obstacle[i][1] <= 30000
答案保证小于 2 ^ 31


```

## 思路

这道题之所以是简单难度，是因为其没有什么技巧。你只需要看懂题目描述，然后把题目描述转化为代码即可。

唯一需要注意的是查找障碍物的时候如果你采用的是`线形查找`会很慢，很可能会超时。

> 我实际测试了一下，确实会超时

- 一种方式是使用排序，然后二分查找，如果采用基于比较的排序算法，那么这种算法的瓶颈在于排序本身，也就是$O(NlogN)$。
- 另一种方式是使用集合，将 obstacles 放入集合，然后需要的时候进行查询，查询的时候的时间复杂度为$O(1)$。

这里我们采用第二种方式。

接下来我们来“翻译”一下题目。

- 由于机器人只能往前走。因此机器人往东西南北哪个方向走取决于它的`朝向`。
- 我们使用枚举来表示当前机器人的`朝向`。
- 题目只有两种方式改变`朝向`，一种是左转(-2)，另一种是右转(-1)。
- 题目要求的是机器人在`运动过程中距离原点的最大值`，而不是最终位置距离原点的距离。

为了代码书写简单，我建立了一个直角坐标系。用`机器人的朝向和 x 轴正方向的夹角度数`来作为枚举值，并且这个度数是 `0 <= deg < 360`。我们不难知道，其实这个取值就是`0`, `90`,`180`,`270` 四个值。那么当 0 度的时候，我们只需要不断地 x+1，90 度的时候我们不断地 y + 1 等等。

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gbdnsywx97j31020r8gmt.jpg)

## 关键点解析

- 理解题意，这道题容易理解错题意，求解为`最终位置距离原点的距离`
- 建立坐标系
- 使用集合简化线形查找的时间复杂度。

## 代码

代码支持： Python3

Python3 Code:

```python
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        pos = [0, 0]
        deg = 90
        ans = 0
        obstaclesSet = set(map(tuple, obstacles))

        for command in commands:
            if command == -1:
                deg = (deg + 270) % 360
            elif command == -2:
                deg = (deg + 90) % 360
            else:
                if deg == 0:
                    i = 0
                    while i < command and not (pos[0] + 1, pos[1]) in obstaclesSet:
                        pos[0] += 1
                        i += 1
                if deg == 90:
                    i = 0
                    while i < command and not (pos[0], pos[1] + 1) in obstaclesSet:
                        pos[1] += 1
                        i += 1
                if deg == 180:
                    i = 0
                    while i < command and not (pos[0] - 1, pos[1]) in obstaclesSet:
                        pos[0] -= 1
                        i += 1
                if deg == 270:
                    i = 0
                    while i < command and not (pos[0], pos[1] - 1) in obstaclesSet:
                        pos[1] -= 1
                        i += 1
                ans = max(ans, pos[0] ** 2 + pos[1] ** 2)
        return ans
```
