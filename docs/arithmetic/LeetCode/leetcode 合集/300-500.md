---
layout: CustomPages
title: 合集 300-500
date: 2020-09-04
aside: false
draft: true
---

### Q322

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  let max = amount + 1;
  let dp = new Array(amount + 1);
  dp.fill(max);
  dp[0] = 0;

  for (let i = 1; i < max; i++) {
    for (let j = 0; j < coins.length; j++) {
      if (coins[j] <= i) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
      }
    }
  }
  return dp[amount] > amount ? -1 : dp[amount];
};
```

### Q324

```js
var wiggleSort = function(nums) {
  let median = findKthLargest(nums.slice(), parseInt((nums.length + 1) / 2));
  let n = nums.length;
  let left = 0,
    i = 0,
    right = n - 1;
  while (i <= right) {
    if (nums[newIndex(i, n)] > median) {
      swap(nums, newIndex(left++, n), newIndex(i++, n));
    } else if (nums[newIndex(i, n)] < median) {
      swap(nums, newIndex(right--, n), newIndex(i, n));
    } else {
      i++;
    }
  }
};

var findKthLargest = function(nums, k) {
  for (let i = 0; i <= k; i++) {
    let max = i;
    for (let j = i; j < nums.length; j++) {
      if (nums[j] > nums[max]) max = j;
    }
    swap(nums, i, max);
  }
  return nums[k - 1];
};

function newIndex(index, n) {
  return (1 + 2 * index) % (n | 1);
}

function swap(nums, a, b) {
  let tmp = nums[a];
  nums[a] = nums[b];
  nums[b] = tmp;
}

wiggleSort([1, 5, 1, 1, 6, 4]);
```

### Q326

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  return n > 0 && 1162261467 % n == 0;
};
```

### Q328

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
  if (head == null) return null;
  // 定义奇数链表、偶数链表、偶数链表开头指针
  let odd = head,
    even = head.next,
    evenHead = even;
  while (even != null && even.next != null) {
    // 保存奇数偶数链表
    odd.next = even.next;
    odd = odd.next;
    even.next = odd.next;
    even = even.next;
  }
  // 通过偶数链表开头指针合并给奇数链表
  odd.next = evenHead;
  return head;
};
```

### Q329

```js
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
  if (matrix.length == 0) return 0;
  maxLength = 0;
  cache = new Array(matrix.length);
  for (let i = 0; i < matrix.length; i++) {
    let child = new Array(matrix[0].length);
    child.fill(false);
    cache[i] = child;
  }

  for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[0].length; j++) {
      dfs(matrix, i, j, 1);
    }
  }
  return maxLength;
};

function dfs(matrix, i, j, len) {
  if (cache[i][j]) return;
  maxLength = Math.max(maxLength, len);

  let tmp = matrix[i][j];

  if (i > 0 && tmp < matrix[i - 1][j]) dfs(matrix, i - 1, j, len + 1);
  if (i < matrix.length - 1 && tmp < matrix[i + 1][j]) dfs(matrix, i + 1, j, len + 1);
  if (j > 0 && tmp < matrix[i][j - 1]) dfs(matrix, i, j - 1, len + 1);
  if (j < matrix[0].length - 1 && tmp < matrix[i][j + 1]) dfs(matrix, i, j + 1, len + 1);

  cache[i][j] = true;
}

const dirs = [
  [0, 1],
  [1, 0],
  [0, -1],
  [-1, 0],
];

var longestIncreasingPath = function(matrix) {
  if (matrix.length == 0) return 0;
  const m = matrix.length,
    n = matrix[0].length;
  let max = 1;

  let cache = new Array(m);
  for (let i = 0; i < m; i++) {
    let child = new Array(n);
    child.fill(0);
    cache[i] = child;
  }

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      let len = dfs(matrix, i, j, m, n, cache);
      max = Math.max(max, len);
    }
  }
  return max;
};

function dfs(matrix, i, j, m, n, cache) {
  if (cache[i][j] != 0) return cache[i][j];
  let max = 1;
  for (let dir of dirs) {
    let x = i + dir[0],
      y = j + dir[1];
    if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) continue;
    let len = 1 + dfs(matrix, x, y, m, n, cache);
    max = Math.max(max, len);
  }
  cache[i][j] = max;
  return max;
}
```

### Q334

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
  let c1 = Number.MAX_VALUE,
    let = Number.MAX_VALUE;
  for (let x of nums) {
    if (x <= c1) {
      c1 = x; // 最小值
    } else if (x <= c2) {
      c2 = x; // 中间值
    } else {
      return true; // 第三个值
    }
  }
  return false;
};
```

### Q341

```js
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
  this.index = 0;
  this.stack = [];
  for (let val of nestedList) {
    if (val instanceof NestedIterator) {
      while (val.hasNext()) {
        this.stack.push(val.next());
      }
    } else {
      this.stack.push(val);
    }
  }
  console.log(this.stack);
};

/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
  return this.index < this.stack.length;
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
  return this.stack[this.index++];
};

/**
 * Your NestedIterator will be called like this:
 * var i = new NestedIterator(nestedList), a = [];
 * while (i.hasNext()) a.push(i.next());
 */

var nestedList = [];
nestedList.push(new NestedIterator([1, 1]));
nestedList.push(2);
nestedList.push(new NestedIterator([1, 1]));

var i = new NestedIterator(nestedList),
  a = [];
while (i.hasNext()) a.push(i.next());
console.log(a);
```

### Q344

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseString = function(s) {
  return s
    .split('')
    .reverse()
    .join('');
};
```

### Q347

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
  let obj = {};
  for (let num of nums) {
    if (obj[num]) obj[num].count++;
    else obj[num] = { num: num, count: 1 };
  }
  let arr = [];
  for (let k in obj) {
    arr.push(obj[k]);
  }
  arr.sort((a, b) => {
    return b.count - a.count;
  });

  return arr.slice(0, k).map(item => {
    return item.num;
  });
};

console.log(topKFrequent([1, 1, 1, 2, 2, 3], 2));
```

### Q350

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
  nums1.sort(sortFun);
  nums2.sort(sortFun);

  if (nums1.length < nums2.length) {
    let tmp = nums1;
    nums1 = nums2;
    nums2 = tmp;
  }
  const ans = [];
  let index1 = 0,
    index2 = 0;
  while (index1 < nums1.length) {
    if (nums1[index1] == nums2[index2]) {
      ans.push(nums2[index2]);
      index1++;
      index2++;
    } else if (nums1[index1] > nums2[index2]) {
      index2++;
    } else {
      index1++;
    }
  }
  return ans;
};

function sortFun(a, b) {
  return a - b;
}

intersect([-2147483648, 1, 2, 3], [1, -2147483648, -2147483648]);
```

### Q371

```js
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var getSum = function(a, b) {
  if (b == 0) {
    //没有进为的时候完成运算
    return a;
  }
  let sum, carry;
  sum = a ^ b; // 进行异或计算
  carry = (a & b) << 1; // 与计算并向左移一位
  return getSum(sum, carry);
};
```

### Q378

```js
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(matrix, k) {
  // 二分法
  let lo = matrix[0][0],
    hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1; //[lo, hi)
  while (lo < hi) {
    // 中间值
    let mid = lo + parseInt((hi - lo) / 2);
    let count = 0,
      j = matrix[0].length - 1; // j 是矩阵最右侧的 index
    for (let i = 0; i < matrix.length; i++) {
      while (j >= 0 && matrix[i][j] > mid) j--; // 算出中间值是第 j 小的值(是否为k)
      count += j + 1;
    }
    if (count < k) lo = mid + 1;
    else hi = mid;
  }
  // 返回最终的值
  return lo;
};

var kthSmallest = function(matrix, k) {
  let lo = matrix[0][0],
    hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;

  while (lo < hi) {
    let mid = lo + parseInt((hi - lo) / 2);
    let count = 0,
      j = matrix[0].length - 1;
    for (let i = 0; i < matrix.length; i++) {
      while (j >= 0 && matrix[i][j] > mid) j--;
      count += j + 1;
    }
    if (count < k) lo = mid + 1;
    else hi = mid;
  }
  return lo;
};
```

### Q380

```js
/**
 * Initialize your data structure here.
 */
var RandomizedSet = function() {
  this.set = new Set();
};

/**
 * Inserts a value to the set. Returns true if the set did not already contain the specified element.
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function(val) {
  if (this.set.has(val)) {
    return false;
  } else {
    this.set.add(val);
    return true;
  }
};

/**
 * Removes a value from the set. Returns true if the set contained the specified element.
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function(val) {
  if (this.set.has(val)) {
    this.set.delete(val);
    return true;
  } else {
    this.set.add(val);
    return false;
  }
};

/**
 * Get a random element from the set.
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function() {
  const arr = [...this.set];
  return arr[RandomNum(0, arr.length - 1)];
};

function RandomNum(Min, Max) {
  var Range = Max - Min;
  var Rand = Math.random();
  var num = Min + Math.round(Rand * Range);
  return num;
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * var obj = Object.create(RandomizedSet).createNew()
 * var param_1 = obj.insert(val)
 * var param_2 = obj.remove(val)
 * var param_3 = obj.getRandom()
 */

const rs = new RandomizedSet();
console.log(rs.insert(1));
console.log(rs.remove(2));
console.log(rs.insert(2));
```

### Q384

```js
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
  this.nums = nums.slice();
};

/**
 * Resets the array to its original configuration and return it.
 * @return {number[]}
 */
Solution.prototype.reset = function() {
  return this.nums;
};

/**
 * Returns a random shuffling of the array.
 * @return {number[]}
 */
Solution.prototype.shuffle = function() {
  let clone = this.nums.slice();

  for (let i = clone.length - 1; i > 0; i--) {
    swap(clone, i, randRange(0, i - 1));
  }
  return clone;
};

function swap(nums, i, j) {
  let tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}

function randRange(Min, Max) {
  var Range = Max - Min;
  var Rand = Math.random();
  var num = Min + Math.round(Rand * Range);
  return num;
}

/**
 * Your Solution object will be instantiated and called as such:
 * var obj = Object.create(Solution).createNew(nums)
 * var param_1 = obj.reset()
 * var param_2 = obj.shuffle()
 */

var s = new Solution([1, 2, 3, 4, 5, 6, 7, 8]);
console.log(s.shuffle());
console.log(s.reset());
console.log(s.shuffle());
console.log(s.reset());
console.log(s.shuffle());
console.log(s.reset());
console.log(s.shuffle());
console.log(s.reset());
```

### Q387

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  let countObj = {};
  for (let c of s) {
    if (countObj[c]) {
      countObj[c]++;
    } else {
      countObj[c] = 1;
    }
  }
  for (let i = 0; i < s.length; i++) {
    if (countObj[s[i]] == 1) {
      return i;
    }
  }
  return -1;
};

console.log(firstUniqChar('z'));
```

### Q395

```js


class Solution {
    public int longestSubstring(String s, int k) {
        char[] str = s.toCharArray();
        return helper(str, 0, s.length(), k);
    }
    private int helper(char[] str, int start, int end, int k) {
        if (end - start < k) return 0;//substring length shorter than k.
        int[] count = new int[26];
        for (int i = start; i < end; i++) {
            int idx = str[i] - 'a';
            count[idx]++;
        }
        for (int i = 0; i < 26; i++) {
            if (count[i] < k && count[i] > 0) { //count[i]=0 => i+'a' does not exist in the string, skip it.
                for (int j = start; j < end; j++) {
                    if (str[j] == i + 'a') {
                        int left = helper(str, start, j, k);
                        int right = helper(str, j + 1, end, k);
                        return Math.max(left, right);
                    }
                }
            }
        }
        return end - start;
    }
}

/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var longestSubstring = function (s, k) {
    let str = s.split("")
    return helper(str, 0, s.length, k)
};

function helper(str, start, end, k) {
    if (end - start < k) return 0;//substring length shorter than k.
    let count = new Array(26)
    for (let i = start; i < end; i++) {
        let idx = str[i] - 'a'.charCodeAt();
        count[idx]++;
    }
    for (let i = 0; i < 26; i++) {
        if (count[i] < k && count[i] > 0) { //count[i]=0 => i+'a' does not exist in the string, skip it.
            for (let j = start; j < end; j++) {
                if (str[j].charCodeAt() == i + 'a'.charCodeAt()) {
                    let left = helper(str, start, j, k);
                    let right = helper(str, j + 1, end, k);
                    return Math.max(left, right);
                }
            }
        }
    }
    return end - start;
}


longestSubstring("bbaaacbd", 3)
```

### Q454

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
var fourSumCount = function(A, B, C, D) {
  let map = new Map();
  for (let c of C) {
    for (let d of D) {
      let sum = c + d;
      map.set(sum, map.get(sum) ? map.get(sum) + 1 : 1);
    }
  }
  let count = 0;
  for (let a of A) {
    for (let b of B) {
      let sum = a + b;
      if (map.has(-sum)) {
        count += map.get(-sum);
      }
    }
  }
  return count;
};
```


### 303.区域和检索-数组不可变

```js
/*
 * @lc app=leetcode.cn id=303 lang=javascript
 *
 * [303] 区域和检索 - 数组不可变
 */
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  if (nums.length === 0) return;
  this.sums = [nums[0]];
  for (let i = 1; i < nums.length; i++) {
    this.sums[i] = this.sums[i - 1] + nums[i];
  }
  this.nums = nums;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  if (i === j) {
    return this.nums[i];
  } else if (i < j) {
    if (i === 0) return this.sums[j];
    return this.sums[j] - this.sums[i - 1];
  }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(i,j)
 */

// var obj = new NumArray([-2, 0, 3, -5, 2, -1])
// // var param_1 = obj.sumRange(0, 2)

// console.log(obj.sums)
// console.log(obj.sumRange(1, 1))
// console.log(obj.sumRange(0, 2))
// console.log(obj.sumRange(2, 5))
// console.log(obj.sumRange(0, 5))
```

### 307.range-sum-query-mutable

```js
/*
 * @lc app=leetcode id=307 lang=javascript
 *
 * [307] Range Sum Query - Mutable
 */
/**
 * @param {number[]} nums
 */
// var NumArray = function(nums) {
//   this.nums = nums;
// };

// /**
//  * @param {number} i
//  * @param {number} val
//  * @return {void}
//  */
// NumArray.prototype.update = function(i, val) {
//   this.nums[i] = val;
// };

// /**
//  * @param {number} i
//  * @param {number} j
//  * @return {number}
//  */
// NumArray.prototype.sumRange = function(i, j) {
//   let res = 0;
//   for (let k = i; k < j + 1; k++) {
//     res += this.nums[k];
//   }

//   return res;
// };

/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
  this.nums = nums;

  // Init array representation of segment tree.
  this.segmentTree = [];

  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;
  this.buildTreeRecursively(l, r, cur);
};

NumArray.prototype.buildTreeRecursively = function(l, r, cur) {
  // If low input index and high input index are equal that would mean
  // the we have finished splitting and we are already came to the leaf
  // of the segment tree. We need to copy this leaf value from input
  // array to segment tree.
  if (l === r) {
    return (this.segmentTree[cur] = this.nums[r]);
  }

  // Split input array on two halves and process them recursively.
  const m = Math.floor((l + r) / 2);
  // Process left half of the input array.
  this.buildTreeRecursively(l, m, this.getLeftChildIndex(cur));
  // Process right half of the input array.
  this.buildTreeRecursively(m + 1, r, this.getRightChildIndex(cur));

  // Once every tree leaf is not empty we're able to build tree bottom up using
  // provided operation function.
  this.segmentTree[cur] = this.operation(
    this.segmentTree[this.getLeftChildIndex(cur)],
    this.segmentTree[this.getRightChildIndex(cur)],
  );
};

/**
 * @param {number} i
 * @param {number} val
 * @return {void}
 */
NumArray.prototype.update = function(i, val) {
  this.nums[i] = val;
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
  const l = 0;
  const r = this.nums.length - 1;
  const cur = 0;

  return this.rangeQueryRecursive(i, j, l, r, cur);
};

NumArray.prototype.rangeQueryRecursive = function(i, j, l, r, cur) {
  if (i <= l && j >= r) {
    // Total overlap.
    return this.segmentTree[cur];
  }

  if (i > r || j < l) {
    // No overlap.
    return this.operationFallback;
  }

  // Partial overlap.
  const m = Math.floor((l + r) / 2);

  const leftOperationResult = this.rangeQueryRecursive(i, j, l, m, this.getLeftChildIndex(cur));

  const rightOperationResult = this.rangeQueryRecursive(i, j, m + 1, r, this.getRightChildIndex(cur));

  return this.sumRange(leftOperationResult, rightOperationResult);
};

NumArray.prototype.getLeftChildIndex = function(parentIndex) {
  return 2 * parentIndex + 1;
};

NumArray.prototype.getRightChildIndex = function(parentIndex) {
  return 2 * parentIndex + 2;
};

/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * obj.update(i,val)
 * var param_2 = obj.sumRange(i,j)
 */
```

### 315.count-of-smaller-numbers-after-self

```js
/*
 * @lc app=leetcode id=315 lang=javascript
 *
 * [315] Count of Smaller Numbers After Self
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
  // Input: [5,2,6,1]
  // Output: [2,1,1,0]
  // 暴力法：
  //   const res = Array(nums.length).fill(0);
  //   for (let i = 0; i < nums.length - 1; i++) {
  //     for (let j = i; j < nums.length; j++) {
  //       if (nums[i] > nums[j]) {
  //         res[i] += 1;
  //       }
  //     }
  //   }

  //   return res;
  //  归并排序
  const res = Array(nums.length).fill(0);

  function merge(arr, l, m, r, res) {
    let i, j, k;
    const n1 = m - l + 1;
    const n2 = r - m;

    /* create temp arrays */
    const L = Array(n1);
    const R = Array(n2);

    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++) L[i] = arr[l + i];
    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
    while (i < n1 && j < n2) {
      if (L[i] <= R[j]) {
        arr[k] = L[i];
        i++;
      } else {
        arr[k] = R[j];
        res[k] += 1;
        j++;
      }
      k++;
    }

    /* Copy the remaining elements of L[], if there
       are any */
    while (i < n1) {
      arr[k] = L[i];
      i++;
      k++;
    }

    /* Copy the remaining elements of R[], if there
       are any */
    while (j < n2) {
      arr[k] = R[j];
      j++;
      k++;
    }
  }
  function mergeSort(arr, l, r, res) {
    if (l < r) {
      const m = l + ((r - l) >> 1);

      mergeSort(arr, l, m, res);
      mergeSort(arr, m + 1, r, res);

      merge(arr, l, m, r, res);
    }
    return res;
  }

  return mergeSort(nums, 0, nums.length - 1, res);
};
```

### 326.power-of-three

```js
/*
 * @lc app=leetcode id=326 lang=javascript
 *
 * [326] Power of Three
 *
 * https://leetcode.com/problems/power-of-three/description/
 *
 * algorithms
 * Easy (41.43%)
 * Total Accepted:    178.8K
 * Total Submissions: 430.4K
 * Testcase Example:  '27'
 *
 * Given an integer, write a function to determine if it is a power of three.
 *
 * Example 1:
 *
 *
 * Input: 27
 * Output: true
 *
 *
 * Example 2:
 *
 *
 * Input: 0
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: 9
 * Output: true
 *
 * Example 4:
 *
 *
 * Input: 45
 * Output: false
 *
 * Follow up:
 * Could you do it without using any loop / recursion?
 */
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  // tag: 数论
  // let i = 0;
  // while(Math.pow(3, i) < n) {
  //     i++;
  // }
  // return Math.pow(3, i) === n;

  // 巧用整除
  return n > 0 && Math.pow(3, 19) % n === 0;
};
// 扩展： 这个方法可以扩展到任意质数，合数则不行
```

### 337.house-robber-iii

```js
/*
 * @lc app=leetcode id=337 lang=javascript
 *
 * [337] House Robber III
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(root) {
  if (root === null) return [0, 0];
  // 0: rob 1: notRob
  const l = helper(root.left);
  const r = helper(root.right);

  const robed = root.val + l[1] + r[1];
  const notRobed = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);

  return [robed, notRobed];
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
  //   if (root === null) return 0;
  //   const notRobed = rob(root.left) + rob(root.right);
  //   const robed =
  //     root.val +
  //     rob(root.left && root.left.left) +
  //     rob(root.left && root.left.right) +
  //     rob(root.right && root.right.left) +
  //     rob(root.right && root.right.right);

  //   return Math.max(notRobed, robed);

  // dp
  const [robed, notRobed] = helper(root);
  return Math.max(robed, notRobed);
};
```

### 338.counting-bits

```js
/*
 * @lc app=leetcode id=338 lang=javascript
 *
 * [338] Counting Bits
 *
 * https://leetcode.com/problems/counting-bits/description/
 *
 * algorithms
 * Medium (64.04%)
 * Total Accepted:    163.1K
 * Total Submissions: 253K
 * Testcase Example:  '2'
 *
 * Given a non negative integer number num. For every numbers i in the range 0
 * ≤ i ≤ num calculate the number of 1's in their binary representation and
 * return them as an array.
 *
 * Example 1:
 *
 *
 * Input: 2
 * Output: [0,1,1]
 *
 * Example 2:
 *
 *
 * Input: 5
 * Output: [0,1,1,2,1,2]
 *
 *
 * Follow up:
 *
 *
 * It is very easy to come up with a solution with run time
 * O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a
 * single pass?
 * Space complexity should be O(n).
 * Can you do it like a boss? Do it without using any builtin function like
 * __builtin_popcount in c++ or in any other language.
 *
 */
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
  // tag: bit dp
  // Time complexity: O(n)
  // Space complexity: O(n)
  const res = [];
  res[0] = 0;

  // 10000100110101
  for (let i = 1; i <= num; i++) {
    if ((i & 1) === 0) {
      // 偶数
      // 偶数最后一位是0，因此右移一位对结果没有影响
      res[i] = res[i >> 1];
    } else {
      // 奇数
      // 奇数最后一位是1，i - 1 的 位数 + 1 就是结果
      res[i] = res[i - 1] + 1;
    }
  }

  return res;
};
```

### 344

```js
// Write a function that reverses a string. The input string is given as an array of characters char[].

// Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

// You may assume all the characters consist of printable ascii characters.

const reverseStringAux = (s, n, m) => {
  if (m === n || s.length === 0 || n > m) return s;
  // swap first and last, in place
  const a = s[n];
  const b = s[m];
  s[n] = b;
  s[m] = a;
  reverseStringAux(s, n + 1, m - 1);
  return s;
};

/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
export default function reverseString(s) {
  return reverseStringAux(s, 0, s.length - 1);
}
```

### 344.reverse-string

```js
/*
 * @lc app=leetcode id=344 lang=javascript
 *
 * [344] Reverse String
 *
 * https://leetcode.com/problems/reverse-string/description/
 *
 * algorithms
 * Easy (62.81%)
 * Total Accepted:    409.9K
 * Total Submissions: 649.5K
 * Testcase Example:  '["h","e","l","l","o"]'
 *
 * Write a function that reverses a string. The input string is given as an
 * array of characters char[].
 *
 * Do not allocate extra space for another array, you must do this by modifying
 * the input array in-place with O(1) extra memory.
 *
 * You may assume all the characters consist of printable ascii
 * characters.
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: ["h","e","l","l","o"]
 * Output: ["o","l","l","e","h"]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: ["H","a","n","n","a","h"]
 * Output: ["h","a","n","n","a","H"]
 *
 *
 *
 *
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  for (let i = 0; i < s.length >> 1; i++) {
    const temp = s[i];
    s[i] = s[s.length - i - 1];
    s[s.length - i - 1] = temp;
  }
};
```

### 344.反转字符串

```js
/*
 * @lc app=leetcode.cn id=344 lang=javascript
 *
 * [344] 反转字符串
 */
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
  if (s.length < 2) return s;
  let i = 0,
    j = s.length - 1;
  while (i < j) {
    // es6 结构
    [s[i], s[j]] = [s[j], s[i]];
    i++;
    j--;
  }
  return s;
};

// 原地交换顺序解决
console.log(reverseString(['h', 'e', 'l', 'l', 'o']));
console.log(reverseString(['H', 'a', 'n', 'n', 'a', 'h']));
```

### 345.reverse-vowels-of-a-string

```js
/*
 * @lc app=leetcode id=345 lang=javascript
 *
 * [345] Reverse Vowels of a String
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
  const res = s.split('');

  let start = 0;
  let end = s.length - 1;
  while (start < end) {
    const startVowel = vowels.includes(s[start]);
    const endVowel = vowels.includes(s[end]);
    if (startVowel && endVowel) {
      const temp = res[start];
      res[start] = res[end];
      res[end] = temp;
      start++;
      end--;
    } else if (startVowel) {
      end--;
    } else if (endVowel) {
      start++;
    } else {
      start++;
      end--;
    }
  }

  return res.join('');
};
```

### 345.反转字符串中的元音字母

```js
/*
 * @lc app=leetcode.cn id=345 lang=javascript
 *
 * [345] 反转字符串中的元音字母
 *
 * 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: "hello"
输出: "holle"
示例 2:

输入: "leetcode"
输出: "leotcede"
说明:
元音字母不包含字母"y"。
 */
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
  const map = {
    a: true,
    e: true,
    i: true,
    o: true,
    u: true,
    A: true,
    E: true,
    I: true,
    O: true,
    U: true,
  };
  s = s.split('');
  let left = 0,
    right = s.length - 1;
  while (left < right) {
    while (!map[s[left]] && left < right) left++;
    while (!map[s[right]] && left < right) right--;
    if (left < right) {
      [s[left], s[right]] = [s[right], s[left]];
      left++;
      right--;
    }
  }
  return s.join('');
};

// console.log(reverseVowels('hello'))
// console.log(reverseVowels('leetcode'))
console.log(reverseVowels('.,'));
```

### 349-Intersection-of-Two-Arrays

```js
/**
 * https://leetcode.com/problems/intersection-of-two-arrays/description/
 * Difficulty:Easy
 *
 * Given two arrays, write a function to compute their intersection.
 * Example:
 * Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].
 * Note:
 * Each element in the result must be unique.
 * The result can be in any order.
 */

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  var ret = [];
  var map1 = nums1.reduce((map, n) => {
    if (!map[n]) map[n] = 1;
    return map;
  }, {});

  var map2 = nums2.reduce((map, n) => {
    if (map1[n] && !map[n]) {
      ret.push(n);
      map[n] = 1;
    }
    return map;
  }, {});

  return ret;
};
console.log(intersection([1, 2, 2, 1], [2, 2]));
```

### 349

```js
// 349. Intersection of Two Arrays
// Given two arrays, write a function to compute their intersection.

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
export default function intersection(nums1, nums2) {
  const a = new Set(nums1);
  const b = new Set(nums2);
  const inters = [];
  for (const x of a) {
    if (b.has(x)) inters.push(x);
  }
  return inters;
}
```

### 349.两个数组的交集

```js
/*
 * @lc app=leetcode.cn id=349 lang=javascript
 *
 * [349] 两个数组的交集
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  // nums1 = [...new Set(nums1)]
  // nums2 = [...new Set(nums2)]
  if (nums1.length < nums2.length) {
    let temp = nums1;
    nums1 = nums2;
    nums2 = temp;
  }
  const map = {},
    resp = [];
  for (let i = 0; i < nums1.length; i++) {
    if (!map[nums1[i]]) {
      map[nums1[i]] = true;
    }
  }
  for (let i = 0; i < nums2.length; i++) {
    if (map[nums2[i]]) {
      resp.push(nums2[i]);
    }
  }
  return [...new Set(resp)];
};
// console.log(intersection([4, 9, 5], [9, 4, 9, 8, 4]))
// console.log(intersection([1, 2, 2, 1], [2, 2]))
```

### 350.intersection-of-two-arrays-ii

```js
/*
 * @lc app=leetcode id=350 lang=javascript
 *
 * [350] Intersection of Two Arrays II
 *
 * https://leetcode.com/problems/intersection-of-two-arrays-ii/description/
 *
 * algorithms
 * Easy (46.84%)
 * Total Accepted:    185.1K
 * Total Submissions: 393.7K
 * Testcase Example:  '[1,2,2,1]\n[2,2]'
 *
 * Given two arrays, write a function to compute their intersection.
 *
 * Example 1:
 *
 *
 * Input: nums1 = [1,2,2,1], nums2 = [2,2]
 * Output: [2,2]
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
 * Output: [4,9]
 *
 *
 * Note:
 *
 *
 * Each element in the result should appear as many times as it shows in both
 * arrays.
 * The result can be in any order.
 *
 *
 * Follow up:
 *
 *
 * What if the given array is already sorted? How would you optimize your
 * algorithm?
 * What if nums1's size is small compared to nums2's size? Which algorithm is
 * better?
 * What if elements of nums2 are stored on disk, and the memory is limited such
 * that you cannot load all elements into the memory at once?
 *
 *
 */
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
  const res = [];

  for (let i = 0; i < nums1.length; i++) {
    if (nums2.includes(nums1[i])) {
      // 这里我们对两个数组排序，然后二分查找， 时间复杂度nlogn
      nums2[nums2.indexOf(nums1[i])] = null;
      res.push(nums1[i]);
    }
  }

  return res;
};
```

### 367.有效的完全平方数

```js
/*
 * @lc app=leetcode.cn id=367 lang=javascript
 *
 * [367] 有效的完全平方数
 */
/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
  if (num < 2) return true;
  let mid = 0,
    left = 1,
    end = num,
    product = 0;
  while (left <= end) {
    mid = left + ((end - left) >> 1);
    // console.log('mid', mid)
    product = mid * mid;
    if (product === num) return true;
    if (product > num) {
      end = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return false;
};

console.log(isPerfectSquare(16));
console.log(isPerfectSquare(14));
console.log(isPerfectSquare(2));
console.log(isPerfectSquare(4));
console.log(isPerfectSquare(104976));
```

### 371

```js
// Sum of Two Integers
//
// Calculate the sum of two integers a and b, but you are not allowed to use
// the operator + and -
//
// ex. Given a = 1 and b = 2, return 3.
//

type num = number;

export default function SumTimelineMethod(first: num, second: num): num {
  const _first = new Array(Math.abs(first));
  const _second = new Array(Math.abs(second));
  const negatives = [];
  const positives = [];

  while (_first.length !== 0) {
    // first is positive
    if (_first.length > 0 && first > 0 && negatives.length === 0) {
      positives.push('-');
    } else if (first > 0 && negatives.length > 0) {
      negatives.splice(0, 1);
      // first is negative
    } else if (first < 0 && positives.length === 0) {
      negatives.push('-');
    } else if (first < 0 && positives.length > 0) {
      positives.splice(0, 1);
    }
    _first.splice(0, 1);
  }

  while (_second.length !== 0) {
    if (_second.length > 0 && second > 0 && negatives.length === 0) {
      positives.push('-');
    } else if (second > 0 && negatives.length > 0) {
      negatives.splice(0, 1);
      // second is negative
    } else if (second < 0 && positives.length === 0) {
      negatives.push('-');
    } else if (second < 0 && positives.length > 0) {
      positives.splice(0, 1);
    }
    _second.splice(0, 1);
  }

  return positives.length === 0 ? (negatives.length === 0 ? 0 : negatives.length * -1) : positives.length;
}
```

### 375.猜数字大小-ii

```js
/*
 * @lc app=leetcode.cn id=375 lang=javascript
 *
 * [375] 猜数字大小 II
 */
/**
 * @param {number} n
 * @return {number}
 */
var getMoneyAmount = function(n) {
  let resp = 0,
    mid = 0,
    start = 1,
    end = n;

  // 最少多少，也就是每次都需要选择右边的区间
  while (end - start > 1) {
    mid = parseInt((start + end) / 2);
    // console.log('start: ', start)
    // console.log('end: ', end)
    // console.log('mid: ', mid)
    resp += mid;
    start = mid + 1;
  }

  if (end - start === 1) {
    resp += start;
  }

  return resp;
};

console.log(getMoneyAmount(10));
console.log(getMoneyAmount(2)); // 1
console.log(getMoneyAmount(3)); // 2
console.log(getMoneyAmount(4)); // 3 + 1
console.log(getMoneyAmount(5)); // 3 + 4
console.log(getMoneyAmount(6)); // 3 + 5
```

### 383-Ransom-Note

```js
/**
 *
 Each letter in the magazine string can only be used once in your ransom note.

 Note:
 You may assume that both strings contain only lowercase letters.

 canConstruct("a", "b") -> false
 canConstruct("aa", "ab") -> false
 canConstruct("aa", "aab") -> true

 */

/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
  var canUseMap = magazine.split('').reduce((map, ch) => {
    if (!map[ch]) {
      map[ch] = 1;
    } else {
      map[ch] += 1;
    }
    return map;
  }, {});

  var wantUseMap = ransomNote.split('').reduce((map, ch) => {
    if (!map[ch]) {
      map[ch] = 1;
    } else {
      map[ch] += 1;
    }
    return map;
  }, {});

  for (var k in wantUseMap) {
    if (wantUseMap[k] > (canUseMap[k] || 0)) return false;
  }
  return true;
};
```

### 387-First-Unique-Character-in-a-String

```js
/**
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 * Difficulty:Easy
 *
 * Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.
 *
 * Examples:
 * s = "leetcode"
 * return 0.
 * s = "loveleetcode",
 * return 2.
 * Note: You may assume the string contain only lowercase letters.
 *
 */

/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (var i = 0; i < s.length; i++) {
    var ch = s[i];
    if (s.lastIndexOf(ch) === s.indexOf(ch)) return i;
  }
  return -1;
};

console.log(firstUniqChar('leetcode'));
console.log(firstUniqChar('loveleetcode'));
```

### 387.first-unique-character-in-a-string

```js
/*
 * @lc app=leetcode id=387 lang=javascript
 *
 * [387] First Unique Character in a String
 *
 * https://leetcode.com/problems/first-unique-character-in-a-string/description/
 *
 * algorithms
 * Easy (49.29%)
 * Total Accepted:    255.6K
 * Total Submissions: 513.8K
 * Testcase Example:  '"leetcode"'
 *
 *
 * Given a string, find the first non-repeating character in it and return it's
 * index. If it doesn't exist, return -1.
 *
 * Examples:
 *
 * s = "leetcode"
 * return 0.
 *
 * s = "loveleetcode",
 * return 2.
 *
 *
 *
 *
 * Note: You may assume the string contain only lowercase letters.
 *
 */
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
};
```

### 392-Is-Subsequence

```js
/**
 * https://leetcode.com/problems/is-subsequence/description/
 * Difficulty:Medium
 *
 * Given a string s and a string t, check if s is subsequence of t.
 * You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).
 * A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).
 *
 * Example 1:
 * s = "abc", t = "ahbgdc"
 * Return true.
 *
 * Example 2:
 * s = "axc", t = "ahbgdc"
 * Return false.
 *
 * Follow up:
 * If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?
 */

/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
  var i = 0;
  var j = 0;
  var m = s.length;
  var n = t.length;
  while (j < n && i < m) {
    if (s[i] === t[j]) {
      i++;
    }
    j++;
  }

  return i === m;
};

console.log(isSubsequence('abc', 'asssbsssc'));
console.log(isSubsequence('abc', 'asssbsss'));
console.log(isSubsequence('', 'asssbsss'));
```

### 392.判断子序列

```js
/*
 * @lc app=leetcode.cn id=392 lang=javascript
 *
 * [392] 判断子序列
 */
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
// 如果s是t的子序列，也就是说s中的所有字符都会按照顺序出现在t中，
// 因此，使用双指针的方式实现:
var isSubsequence = function(s, t) {
  let i = 0,
    j = 0;
  while (s[i] && t[j]) {
    // 如果字符匹配，则两个都加一位，否则的话，母字符串 + 1
    if (s[i] === t[j]) {
      i++;
    }
    j++;
  }
  return i === s.length;
};

console.log(isSubsequence('abc', 'ahbgdc'));
console.log(isSubsequence('axc', 'ahbgdc'));
```

### 404-Sum-of-Left-Leaves

```js
/**
 * https://leetcode.com/problems/sum-of-left-leaves/description/
 * Difficulty:Easy
 *
 * Find the sum of all left leaves in a given binary tree.
 * Example:
 *     3
 *    / \
 *   9  20
 *      / \
 *    15   7
 * There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
 *
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
  return fn(root, false);
};

function fn(node, isLeft) {
  if (!node) return 0;
  if (!node.left && !node.right) {
    return isLeft ? node.val : 0;
  }

  return fn(node.left, true) + fn(node.right, false);
}
```

### 404

```js
// Sum of Left Leaves
// Find the sum of all left leaves in a given binary tree

//   3
// /   \
// 9    20
//    /   \
//   15   7

// There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const sumOfLeftLeavesAux = (root, sum, isLeft) => {
  if (root === null) return 0;
  if (!root.left && !root.right && isLeft) return root.val;
  if (root.left) sum += sumOfLeftLeavesAux(root.left, 0, true);
  if (root.right) sum += sumOfLeftLeavesAux(root.right, 0, false);
  return sum;
};

export default function sumOfLeftLeaves(root) {
  return sumOfLeftLeavesAux(root, 0, false);
}
```

### 412.fizz-buzz

```js
/*
 * @lc app=leetcode.cn id=412 lang=javascript
 *
 * [412] Fizz Buzz
 */
/**
 * @param {number} n
 * @return {string[]}
 */

// Accepted
// ✔ 8 / 8 cases passed(92 ms)
// ✔ Your runtime beats 70.8 % of javascript submissions
// ✔ Your memory usage beats 44.87 % of javascript submissions(37.3 MB)
var fizzBuzz1 = function(n) {
  let result = [],
    i = 1;
  while (i <= n) {
    if (i % 3 === 0 && i % 5 === 0) {
      result.push('FizzBuzz');
    } else if (i % 3 === 0) {
      result.push('Fizz');
    } else if (i % 5 === 0) {
      result.push('Buzz');
    } else {
      result.push(i + '');
    }
    i++;
  }
  return result;
};

// ✔ Accepted
// ✔ 8 / 8 cases passed(84 ms)
// ✔ Your runtime beats 91.18 % of javascript submissions
// ✔ Your memory usage beats 55.13 % of javascript submissions(37.3 MB)
var fizzBuzz = function(n) {
  let result = [0];
  for (let i = 1; i <= n; i++) {
    result[i] = i % 3 === 0 && i % 5 === 0 ? 'FizzBuzz' : i % 3 === 0 ? 'Fizz' : i % 5 === 0 ? 'Buzz' : i + '';
  }
  result.shift();
  return result;
};

console.log(fizzBuzz(1));
console.log(fizzBuzz(2));
console.log(fizzBuzz(3));
console.log(fizzBuzz(10));
console.log(fizzBuzz(15));
```

### 413-Arithmetic-Slices

```js
/**
 * https://leetcode.com/problems/arithmetic-slices/description/
 * Difficulty:Medium
 *
 * A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
 *
 * For example, these are arithmetic sequence:
 * 1, 3, 5, 7, 9
 * 7, 7, 7, 7
 * 3, -1, -5, -9
 *
 * The following sequence is not arithmetic.
 * 1, 1, 2, 5, 7
 *
 * A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.
 *
 * A slice (P, Q) of array A is called arithmetic if the sequence:
 *
 * A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.
 *
 * The function should return the number of arithmetic slices in the array A.
 *
 * Example:
 * A = [1, 2, 3, 4]
 *
 * return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
 *
 */

/**
 * @param {number[]} A
 * @return {number}
 */
var numberOfArithmeticSlices = function(A) {
  if (A.length < 3) return 0;
  var dp = [];
  if (A[2] - A[1] === A[1] - A[0]) {
    dp[2] = 1;
  } else {
    dp[2] = 0;
  }
  var result = dp[2];

  for (var i = 3; i < A.length; i++) {
    if (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {
      dp[i] = dp[i - 1] + 1;
      result += dp[i];
    } else {
      dp[i] = 0;
    }
  }

  return result;
};
```

### 415-Add-Strings

```js
/**
 * https://leetcode.com/problems/add-strings/description/
 * Difficulty:Easy
 *
 * Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
 * Note:
 *
 * The length of both num1 and num2 is < 5100.
 * Both num1 and num2 contains only digits 0-9.
 * Both num1 and num2 does not contain any leading zero.
 * You must not use any built-in BigInteger library or convert the inputs to integer directly.
 */

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function(num1, num2) {
  var carry = 0;
  var len1 = num1.length;
  var len2 = num2.length;
  var forCount = Math.max(len1, len2);
  var newNum = '';
  for (var i = 0; i < forCount; i++) {
    var a = parseInt(num1[len1 - 1 - i]) || 0;
    var b = parseInt(num2[len2 - 1 - i]) || 0;
    var c = a + b + carry;
    carry = Math.floor(c / 10);
    var e = c % 10;
    newNum = e + newNum;
  }

  if (carry) {
    newNum = carry + newNum;
  }
  return newNum;
};

console.log(addStrings('12', '123') == '135');
```

### 415

```js
// 415. Add Strings

// Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.

// Note:
// The length of both num1 and num2 is < 5100.
// Both num1 and num2 contains only digits 0-9.
// Both num1 and num2 does not contain any leading zero.
// You must not use any built-in BigInteger library or convert the inputs to integer directly.

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
export default function addStrings(num1, num2) {
  let carry = false;
  const str = [];
  for (let i = 0; i < Math.max(num1.length, num2.length) || carry; i++) {
    const a = i < num1.length ? num1[num1.length - 1 - i] : 0;
    const b = i < num2.length ? num2[num2.length - 1 - i] : 0;
    let sum = parseInt(a, 10) + parseInt(b, 10) + (carry === true ? 1 : 0);
    carry = sum > 9;
    sum %= 10;
    str.push(sum);
  }
  return str.reverse().join('');
}
```

### 416-Partition-Equal-Subset-Sum

```js
/**
 * https://leetcode.com/problems/partition-equal-subset-sum/description/
 * Difficulty:Medium
 *
 * Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
 * Note:
 * Each of the array element will not exceed 100.
 * The array size will not exceed 200.
 * Example 1:
 * Input: [1, 5, 11, 5]
 * Output: true
 * Explanation: The array can be partitioned as [1, 5, 5] and [11].
 * Example 2:
 * Input: [1, 2, 3, 5]
 * Output: false
 * Explanation: The array cannot be partitioned into equal sum subsets.
 */

/**
 *
 * 01背包问题
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  var sum = nums.reduce((a, b) => a + b, 0);
  if (sum % 2) return false;
  sum = sum / 2;

  var n = nums.length;
  var dp = [];

  while (dp.push(new Array(sum + 1).fill(0)) < n + 1);

  for (var i = 0; i < n + 1; i++) {
    dp[i][0] = 1;
  }

  for (var i = 1; i < n + 1; i++) {
    for (var j = 1; j < sum + 1; j++) {
      if (dp[i - 1][j]) dp[i][j] = 1;
      if (j >= nums[i - 1] && dp[i - 1][j - nums[i - 1]]) dp[i][j] = 1;
    }
  }

  // console.log(dp);

  return !!dp[n][sum];
};

console.log(canPartition([1, 5]));
console.log(canPartition([1, 5, 11, 5]));
// console.log(canPartition([1, 5, 11, 5, 1, 1]));
// console.log(canPartition([1, 5, 11, 5, 2]));
// console.log(canPartition([1, 5, 11, 5]));
// console.log(canPartition([1, 2, 3, 5]));
```

### 443.压缩字符串

```js
/*
 * @lc app=leetcode.cn id=443 lang=javascript
 *
 * [443] 压缩字符串
 */
/**
 * @param {character[]} chars
 * @return {number}
 */
// TODO: 原地修改
var compress = function(chars) {
  // 0 记录 chars[i] 1 记录次数
  let map = [],
    resp = '';
  for (let i = 0; i < chars.length; i++) {
    if (!map[0]) {
      map[0] = chars[i];
      map[1] = 1;
    } else {
      if (map[0] !== chars[i]) {
        resp += `${map[0]}${map[1] > 1 ? map[1] : ''}`;
        map[0] = chars[i];
        map[1] = 1;
        continue;
      }
      map[1]++;
    }
  }
  resp += `${map[0]}${map[1] > 1 ? map[1] : ''}`;
  return resp.length;
};

console.log(compress(['a', 'a', 'b', 'b', 'c', 'c', 'c']));
console.log(compress(['a']));
console.log(compress(['a', 'a', 'b', 'b', 'c', 'c', 'c']));
console.log(compress(['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b']));
```

### 447-Number-of-Boomerangs

```js
/**
 * https://leetcode.com/problems/number-of-boomerangs/description/
 * Difficulty:Easy
 *
 * Given n points in the plane that are all pairwise distinct,
 * a "boomerang" is a tuple of points (i, j, k) such that the distance
 * between i and j equals the distance between i and k (the order of the tuple matters).
 *
 * Find the number of boomerangs.
 * You may assume that n will be at most 500 and
 * coordinates of points are all in the range [-10000, 10000] (inclusive).
 *
 *
 *
 * Example:
 * Input:
 * [[0,0],[1,0],[2,0]]
 * Output:
 * 2
 * Explanation:
 * The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
 *
 *
 *
 * 解释
 *
 * 给定一个Point的数组, 找到所有的长度为3的Point数组(i, j, k)
 * 使得 i&j, i&k 的距离相同
 * 顺序有关
 *
 */

/**
 * @param {number[][]} points
 * @return {number}
 */
var numberOfBoomerangs = function(points) {
  if (points.length < 3) return 0;
  var ret = 0;
  for (var i = 0; i < points.length; i++) {
    var p1 = points[i];
    var disMap = {};

    for (var j = 0; j < points.length; j++) {
      if (i == j) continue;
      var p2 = points[j];
      var dis = getDis(p1, p2);
      if (disMap[dis] == undefined) disMap[dis] = 1;
      else disMap[dis] += 1;
    }

    for (var key in disMap) {
      var n = disMap[key];
      ret += n * (n - 1);
    }
  }

  return ret;
};

function getDis(p1, p2) {
  var d1 = p2[1] - p1[1];
  var d2 = p2[0] - p1[0];
  return d1 * d1 + d2 * d2;
}

console.log(
  numberOfBoomerangs([
    [0, 0],
    [1, 0],
    [2, 0],
  ]) == 2,
);
console.log(numberOfBoomerangs([[1, 1]]) == 0);
console.log(
  numberOfBoomerangs([
    [1, 1],
    [1, 2],
  ]) == 0,
);
console.log(
  numberOfBoomerangs([
    [0, 0],
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
  ]) == 20,
);
```

### 453-Minimum-Moves-to-Equal-Array-Elements

```js
/**
 * https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/
 * Difficulty:Easy
 *
 * Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.
 * Example:
 * Input:
 * [1,2,3]
 * Output:
 * 3
 * Explanation:
 * Only three moves are needed (remember each move increments two elements):
 * [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
 *
 */

/**
 *
 * reverse thinking!
 *
 * Adding 1 to n - 1 elements is the same as subtracting 1 from one element
 *
 * goal of making the elements in the array equal.
 * So, best way to do this is make all the elements in the array equal to the min element.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var minMoves = function(nums) {
  var min = nums[0];
  for (var i = 1; i < nums.length; i++) {
    min = Math.min(min, nums[i]);
  }

  var ret = 0;
  for (i = 0; i < nums.length; i++) {
    ret += nums[i] - min;
  }
  return ret;
};

console.log(minMoves([1, 999, 1000]));
```

### 454-4Sum-II

```js
/**
 * Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l)
 * there are such that A[i] + B[j] + C[k] + D[l] is zero.

 To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500.
 All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.

 Example:

 Input:
 A = [ 1, 2]
 B = [-2,-1]
 C = [-1, 2]
 D = [ 0, 2]

 Output:
 2

 Explanation:
 The two tuples are:
 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
 */

/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
var fourSumCount = function(A, B, C, D) {
  var cnt = 0;
  var map = {};
  var n = A.length;

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      var sum = A[i] + B[j];
      if (map[sum] === undefined) map[sum] = 1;
      else map[sum]++;
    }
  }

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      var sum = C[i] + D[j];
      if (map[-sum] !== undefined) cnt += map[-sum];
    }
  }
  return cnt;
};

console.log(fourSumCount([1, 2], [-2, -2], [-1, 2], [0, 2]));
```

### 455-Assign-Cookies

```js
/**
 * https://leetcode.com/problems/assign-cookies/description/
 * Difficulty:Easy
 *
 * Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
 *
 * Note:
 * You may assume the greed factor is always positive.
 * You cannot assign more than one cookie to one child.
 * Example 1:
 * Input: [1,2,3], [1,1]
 * Output: 1
 * Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
 * And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
 * You need to output 1.
 *
 */

/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
  var ret = 0;
  g.sort((a, b) => a - b);
  s.sort((a, b) => a - b);
  var gIndex = 0;
  var sIndex = 0;

  while (gIndex < g.length && sIndex < s.length) {
    var gi = g[gIndex];
    var si = s[sIndex];
    if (gi <= si) {
      ret += 1;
      gIndex++;
      sIndex++;
    } else if (gi > si) {
      sIndex++;
    } else {
      break;
    }
  }

  return ret;
};

console.log(findContentChildren([1, 2, 3], [1, 1]));
console.log(findContentChildren([1, 2], [1, 2, 3]));
```

### 459.重复的子字符串

```js
/*
 * @lc app=leetcode.cn id=459 lang=javascript
 *
 * [459] 重复的子字符串
 */
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
  // 正则表达式的模式匹配
  return /^(\w+)\1+$/.test(s);
};

console.log(repeatedSubstringPattern('abab'));
console.log(repeatedSubstringPattern('aba'));
console.log(repeatedSubstringPattern('abcabcabcabc'));
```

### 461-Hamming-Distance

```js
/**
 * https://leetcode.com/problems/hamming-distance/description/
 * Difficulty:Easy
 *
 * The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
 * Given two integers x and y, calculate the Hamming distance.
 * Note:
 * 0 ≤ x, y < 231.
 * Example:
 * Input: x = 1, y = 4
 * Output: 2
 * Explanation:
 * 1   (0 0 0 1)
 * 4   (0 1 0 0)
 * ↑   ↑
 * The above arrows point to positions where the corresponding bits are different.
 *
 */

/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
  var z = x ^ y;
  var ret = 0;
  while (z) {
    ret += z % 2;
    z = Math.floor(z / 2);
  }
  return ret;
};

console.log(hammingDistance(1, 4));
```

### 476-Number-Complement

```js
/**
 * https://leetcode.com/problems/number-complement/description/
 * Difficulty:Easy
 *
 * Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
 * Note:
 *
 * The given integer is guaranteed to fit within the range of a 32-bit signed integer.
 * You could assume no leading zero bit in the integer’s binary representation.
 *
 * Example:
 * Input: 5
 * Output: 2
 * Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
 */

/**
 * @param {number} num
 * @return {number}
 */
var findComplement = function(num) {
  var str = '';

  while (num) {
    str = (num % 2 ? 0 : 1) + str;
    num = Math.floor(num / 2);
  }

  return parseInt(str, 2);
};

console.log(findComplement(5));
console.log(findComplement(2));
```

### 477-Total-Hamming-Distance

```js
/**
 * https://leetcode.com/problems/total-hamming-distance/description/
 * Difficulty:Medium
 *
 * The Hamming distance between two integers is the number of positions at which
 * the corresponding bits are different.
 * Now your job is to find the total Hamming distance between all pairs of the given numbers.
 *
 * Example:
 * Input: 4, 14, 2
 * Output: 6
 * Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
 * showing the four bits relevant in this case). So the answer will be:
 * HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
 *
 * Note:
 * Elements of the given array are in the range of 0 to 10^9
 * Length of the array will not exceed 10^4.
 *
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var totalHammingDistance = function(nums) {
  var ret = 0;
  var maxLen = 0;
  var bArrs = nums.map(n => {
    var arr = [];
    while (n) {
      arr.push(n % 2);
      n = Math.floor(n / 2);
    }
    if (arr.length > maxLen) maxLen = arr.length;

    return arr;
  });

  while (maxLen) {
    var index = maxLen - 1;

    var ones = 0;
    var zeros = 0;
    for (var i = 0; i < bArrs.length; i++) {
      if (bArrs[i][index]) {
        ones++;
      } else {
        zeros++;
      }
    }
    ret += ones * zeros;
    maxLen--;
  }

  return ret;
};

console.log(6 == totalHammingDistance([4, 14, 2]));
```

### 492-Construct-the-Rectangle

```js
/**
 *
 * https://leetcode.com/problems/construct-the-rectangle/description/
 * Difficulty:Easy
 *
 * For a web developer, it is very important to know how to design a web page's size.
 * So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page,
 * whose length L and width W satisfy the following requirements:
 * 1. The area of the rectangular web page you designed must equal to the given target area.
 * 2. The width W should not be larger than the length L, which means L >= W.
 * 3. The difference between length L and width W should be as small as possible.
 * You need to output the length L and the width W of the web page you designed in sequence.
 *
 * Example:
 * Input: 4
 * Output: [2, 2]
 * Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].
 * But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
 *
 * Note:
 * The given area won't exceed 10,000,000 and is a positive integer
 * The web page's width and length you designed must be positive integers.
 * */

/**
 * @param {number} area
 * @return {number[]}
 */
var constructRectangle = function(area) {
  var w = Math.floor(Math.sqrt(area));
  while (area % w != 0) w--;
  return [area / w, w];
};

console.log(constructRectangle(4));
console.log(constructRectangle(17));
```

### 500-Keyboard-Row

```js
/**
 * https://leetcode.com/problems/keyboard-row/description/
 * Difficulty:Easy
 *
 * Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.
 *
 * Example 1:
 * Input: ["Hello", "f", "Dad", "Peace"]
 * Output: ["Alaska", "Dad"]
 * Note:
 * You may use one character in the keyboard more than once.
 * You may assume the input string will only contain letters of alphabet.
 */

/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
  var s = 'qwertyuiopasdfghjklzxcvbnm';
  return words.filter(w => {
    if (!w) return true;
    w = w.toLowerCase();
    var t = row(w[0]);
    for (var i = 1; i < w.length; i++) {
      if (t !== row(w[i])) return false;
    }
    return true;
  });

  function row(ch) {
    var i = s.indexOf(ch);
    if (i < 10) return 0;
    if (i < 19) return 1;
    return 2;
  }
};
console.log(findWords(['Hello', 'Alaska', 'Dad', 'Peace']));
```
