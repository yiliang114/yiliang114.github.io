---
layout: CustomPages
title: LeetCode-合集 100-200
date: 2020.09.04
aside: false
draft: true
---

### [101].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  return helper(root, root);
};

function helper(l, r) {
  if (l == null && r == null) return true;
  if (l == null || r == null) return false;
  return l.val == r.val && helper(l.left, r.right) && helper(l.right, r.left);
}
```

### [102].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  let ans = [];
  helper(root, ans, 0);
  return ans;
};

function helper(node, ans, i) {
  if (node == null) return;
  if (i == ans.length) ans.push([]);
  ans[i].push(node.val);

  helper(node.left, ans, i + 1);
  helper(node.right, ans, i + 1);
}
```

### [104].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### [105].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  return helper(0, 0, inorder.length - 1, preorder, inorder);
};

function helper(preStart, inStart, inEnd, preorder, inorder) {
  if (preStart > preorder.length - 1 || inStart > inEnd) {
    return null;
  }
  let root = new TreeNode(preorder[preStart]);
  let inIndex = 0;
  for (let i = inStart; i <= inEnd; i++) {
    if (inorder[i] == root.val) {
      inIndex = i;
    }
  }
  root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
  root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
  return root;
}
```

### [108].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
  if (nums.length == 0) return null;
  return helper(nums, 0, nums.length - 1);
};

function helper(nums, lo, hi) {
  if (lo > hi) {
    return null;
  }
  let mid = parseInt((lo + hi + 1) / 2);
  let node = new TreeNode(nums[mid]);

  node.left = helper(nums, lo, mid - 1);
  node.right = helper(nums, mid + 1, hi);
  return node;
}

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

console.log(sortedArrayToBST([-10, -3, 0, 5, 9]));
```

### [116].

```js
/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
  if (root == null || root.left == null) return;
  connectNodes(root.left, root.right);
};

function connectNodes(node1, node2) {
  node1.next = node2;
  if (node1.left != null) {
    connectNodes(node1.left, node1.right);
    connectNodes(node1.right, node2.left);
    connectNodes(node2.left, node2.right);
  }
}
```

### [117]. Populating Next Right Pointers in Each Node II

```js
// [117]. Populating Next Right Pointers in Each Node II

// Given a binary tree

// struct Node {
//   int val;
//   Node *left;
//   Node *right;
//   Node *next;
// }
// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

// Initially, all next pointers are set to NULL.

/**
 * // Definition for a Node.
 * function Node(val,left,right,next) {
 *    this.val = val;
 *    this.left = left;
 *    this.right = right;
 *    this.next = next;
 * };
 */
/**
 * @param {Node} root
 * @return {Node}
 */
export default function connect(root) {
  // BFS
  if (!root) return root;
  const depth = new Map();
  // For each level of tree, point
  const queue = [];
  queue.push(root);
  depth.set(root, 0);
  let prev;
  while (queue.length) {
    const item = queue.shift();
    const d = depth.get(item);
    if (prev && d === depth.get(prev)) {
      prev.next = item;
    } else if (prev) prev.next = null;
    prev = item;
    if (item.left) {
      queue.push(item.left);
      depth.set(item.left, d + 1);
    }
    if (item.right) {
      queue.push(item.right);
      depth.set(item.right, d + 1);
    }
  }
  return root;
}
```

### [118].

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
  if (numRows == 0) return [];
  if (numRows == 1) return [[1]];
  if (numRows == 2) return [[1], [1, 1]];
  let ans = [[1], [1, 1]];
  for (let len = 2; len < numRows; len++) {
    let row = [1];
    for (let i = 1; i < ans[len - 1].length; i++) {
      row.push(ans[len - 1][i - 1] + ans[len - 1][i]);
    }
    row.push(1);
    ans.push(row);
  }
  return ans;
};

console.log(generate(5));
```

### [121].

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let maxProfit = 0;
  let minPrice = Number.MAX_SAFE_INTEGER;
  for (let i = 0; i < prices.length; i++) {
    minPrice = Math.min(minPrice, prices[i]);
    maxProfit = Math.max(maxProfit, prices[i] - minPrice);
  }
  return maxProfit;
};
```

### [122].

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let maxProfit = 0;
  let curMin = prices[0];
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > curMin) {
      maxProfit += prices[i] - curMin;
    }
    curMin = prices[i];
  }
  return maxProfit;
};
```

### [124].

```js
let maxValue;

var maxPathSum = function(root) {
  maxValue = Number.MIN_SAFE_INTEGER;
  find(root);
  return maxValue;
};

function find(node) {
  if (node == null) return 0;
  let left = Math.max(0, find(node.left)); // 获取左侧最大和
  let right = Math.max(0, find(node.right)); // 获取右侧最大和
  maxValue = Math.max(maxValue, left + right + node.val); // 获得最大值
  return Math.max(left, right) + node.val; // 返回最大值
}
```

### [125]. 判断回文

#### js reverse 验证

```js
var isPalindrome = function(s) {
  s = s.replace(/[^\w]/g, '').toLowerCase();
  return (
    s
      .split('')
      .reverse()
      .join('') === s
  );
};
```

#### 双指针

```js
var isPalindrome = function(s) {
  s = s.replace(/[^\w]/g, '');
  if (s.length == 0) return true;

  var start = 0,
    end = s.length - 1;
  while (start < end) {
    if (!s[start] || !s[end]) {
      return false;
    }
    if (s[start].toLowerCase() != s[end].toLowerCase()) {
      return false;
    }
    start++;
    end--;
  }
  return true;
};

isPalindrome('A man, a plan, a canal: Panama');
```

#### 双指针思路

- 如果两个指针的元素不相同，则直接返回 false,
- 如果两个指针的元素相同，我们同时更新头尾指针，循环。 直到头尾指针相遇。

时间复杂度为 O(n).

```js
// 只处理英文字符(题目忽略大小写，我们前面全部转化成了小写， 因此这里我们只判断小写)和数字
function isValid(c) {
  const charCode = c.charCodeAt(0);
  const isDigit = charCode >= '0'.charCodeAt(0) && charCode <= '9'.charCodeAt(0);
  const isChar = charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0);

  return isDigit || isChar;
}
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  s = s.toLowerCase();
  let left = 0;
  let right = s.length - 1;

  while (left < right) {
    if (!isValid(s[left])) {
      left++;
      continue;
    }
    if (!isValid(s[right])) {
      right--;
      continue;
    }

    if (s[left] === s[right]) {
      left++;
      right--;
    } else {
      break;
    }
  }

  return right <= left;
};
```

### [127].-DFS-TLE

```js
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
  MinCount = Number.MAX_VALUE;
  dfs(beginWord, endWord, wordList, 1);
  return MinCount == Number.MAX_VALUE ? 0 : MinCount;
};

let MinCount = Number.MAX_VALUE;

function dfs(beginWord, endWord, wordList, count) {
  if (beginWord == endWord) {
    MinCount = Math.min(MinCount, count);
  }
  let max = Number.MAX_VALUE;
  for (let i = 0; i < wordList.length; i++) {
    if (changeOneChar(beginWord, wordList[i])) {
      let clone = wordList.slice();
      clone.splice(i, 1);
      dfs(wordList[i], endWord, clone, count + 1);
    }
  }
}

function changeOneChar(a, b) {
  let count = 0;
  for (let i = 0; i < a.length; i++) if (a[i] != b[i]) count++;
  return count == 1;
}

console.log(ladderLength('hit', 'cog', ['hot', 'cog', 'dot', 'dog', 'hit', 'lot', 'log']));
```

### [127].

```js
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
  if (!wordList.includes(endWord)) return 0;
  let set = new Set(),
    visited = new Set(),
    len = 1;

  set.add(beginWord);
  visited.add(beginWord);
  while (set.size != 0) {
    let tmp = new Set([...set]);

    for (let w of tmp) {
      visited.add(w);
      set.delete(w);

      if (changeOneChar(w, endWord)) return len + 1;

      for (let word of wordList) {
        if (changeOneChar(w, word) && !visited.has(word)) {
          set.add(word);
        }
      }
    }
    len++;
  }
  return 0;
};

function changeOneChar(a, b) {
  let count = 0;
  for (let i = 0; i < a.length; i++) if (a[i] != b[i]) count++;
  return count == 1;
}

let beginWord = 'hit',
  endWord = 'cog',
  wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog'];

ladderLength(beginWord, endWord, wordList);
```

### [128].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  if (nums.length == 0) return 0;
  let count = 0,
    max = 1;
  for (let i = 0, len = nums.length; i < len; i++) {
    let min = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[min]) min = j;
    }
    swap(nums, i, min);
    if (i != 0 && nums[i] == nums[i - 1] + 1) {
      count++;
      max = Math.max(max, count);
    } else if (nums[i] == nums[i - 1]) {
    } else {
      count = 1;
    }
  }
  return max;
};

function swap(nums, a, b) {
  let x = nums[a];
  nums[a] = nums[b];
  nums[b] = x;
}

console.log(longestConsecutive([1, 2, 0, 1]));
```

### [130].

```js
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
  let i, j;
  let row = board.length;
  if (!row) return;
  let col = board[0].length;

  for (i = 0; i < row; i++) {
    check(board, i, 0, row, col);
    if (col > 1) check(board, i, col - 1, row, col);
  }

  for (j = 1; j < col - 1; j++) {
    check(board, 0, j, row, col);
    if (row > 1) check(board, row - 1, j, row, col);
  }

  for (i = 0; i < row; i++) {
    for (j = 0; j < col; j++) {
      if (board[i][j] == 'O') board[i][j] = 'X';
    }
  }
  for (i = 0; i < row; i++) {
    for (j = 0; j < col; j++) {
      if (board[i][j] == '1') board[i][j] = 'O';
    }
  }
};

function check(board, i, j, row, col) {
  if (board[i][j] == 'O') {
    board[i][j] = '1';
    if (i > 1) check(board, i - 1, j, row, col);
    if (j > 1) check(board, i, j - 1, row, col);
    if (i + 1 < row) check(board, i + 1, j, row, col);
    if (j + 1 < col) check(board, i, j + 1, row, col);
  }
}
```

### [131].

```js
let ans = [];
let curList = [];

var partition = function(s) {
  ans = [];
  curList = [];
  backTrack(s, 0);
  return ans;
};

function backTrack(s, l) {
  if (curList.length > 0 && l >= s.length) {
    let r = curList.slice();
    ans.push(r);
  }
  for (let i = l; i < s.length; i++) {
    if (isPalindrome(s, l, i)) {
      if (l == i) curList.push(s[i]);
      else curList.push(s.slice(l, i + 1));
      backTrack(s, i + 1);
      curList.pop();
    }
  }
}

function isPalindrome(s, l, r) {
  if (l == r) return true;
  while (l < r) {
    if (s[l] != s[r]) return false;
    l++;
    r--;
  }
  return true;
}
```

### [136].

```js
var singleNumber = function(nums) {
  var a = 0;
  for (let val of nums) a ^= val;
  return a;
};
```

### [136].Single-Number

```js
// 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

// 说明：

// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

// 示例 1:

// 输入: [2,2,1]
// 输出: 1
// 示例 2:

// 输入: [4,1,2,1,2]
// 输出: 4

// 思路
// 标签：位运算
// 本题根据题意，线性时间复杂度 O(n)O(n)，很容易想到使用 Hash 映射来进行计算，遍历一次后结束得到结果，但是在空间复杂度上会达到 O(n)O(n)，需要使用较多的额外空间
// 既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：

//  [1]. 一个数和 0 做 XOR 运算等于本身：a^0 = a
//  [2]. 一个数和其本身做 XOR 运算等于 0：a^a = 0
//  [3]. XOR 运算满足交换律和结合律：a^b^a = (a^a)^b = 0^b = b

// 故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字
// 时间复杂度：O(n)，空间复杂度：O(1)

// reduce 性能性对好些
// 84 ms	40.2 MB
var singleNumber = function(nums = []) {
  return nums.reduce((ret, n) => ret ^ n, 0);
};

// 88 ms	40.8 MB
var singleNumber1 = function(nums) {
  let ans = 0;
  for (const num of nums) {
    ans ^= num;
  }
  return ans;
};

export default function SingleNumber2(nums = []) {
  for (let i = 0; i < nums.length; i++) {
    if (set.has(nums[i])) {
      set.delete(nums[i]);
    } else {
      set.add(nums[i]);
    }
  }

  const item = Array.from(set)[0];
  set.clear();

  return item;
}

console.log(singleNumber([1, 2, 2]) == 1);
console.log(singleNumber([1, 2, 1]) == 2);
```

### [138].

```js
/**
 * Definition for singly-linked list with a random pointer.
 * function RandomListNode(label) {
 *     this.label = label;
 *     this.next = this.random = null;
 * }
 */

/**
 * @param {RandomListNode} head
 * @return {RandomListNode}
 */
var copyRandomList = function(head) {
  let iter = head,
    next;

  while (iter != null) {
    next = iter.next;

    let copy = new RandomListNode(iter.label);
    iter.next = copy;
    copy.next = next;
    iter = next;
  }

  iter = head;
  while (iter != null) {
    if (iter.random != null) {
      iter.next.random = iter.random.next;
    }
    iter = iter.next.next;
  }

  iter = head;
  let pseudoHead = new RandomListNode(0);
  let copy,
    copyIter = pseudoHead;

  while (iter != null) {
    next = iter.next.next;

    copy = iter.next;
    copyIter.next = copy;
    copyIter = copy;

    iter.next = next;
    iter = next;
  }
  return pseudoHead.next;
};
```

### [139].

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  let dp = new Array(s.length + 1);
  dp.fill(false);
  dp[0] = true;

  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.includes(s.slice(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[s.length];
};
```

### [140].

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  if (canStringBeSegmented(s, wordDict)) {
    return getAllPossibleSegments(s, wordDict, {});
  } else {
    return [];
  }
};
// DFS
function getAllPossibleSegments(s, dict, map) {
  if (s in map) return map[s];
  const result = [];
  if (dict.includes(s)) result.push(s);
  for (let i = 1; i < s.length; i++) {
    const left = s.substring(0, i);
    const right = s.substring(i);
    if (dict.includes(left) && containsSuffix(dict, right)) {
      for (let segment of getAllPossibleSegments(right, dict, map)) {
        result.push(`${left} ${segment}`);
      }
    }
  }
  map[s] = result;
  return result;
}

function containsSuffix(dict, str) {
  for (let i = 0; i < str.length; i++) {
    if (dict.includes(str.substring(i))) return true;
  }
  return false;
}
// 使用 dp 判断能否
function canStringBeSegmented(inputStr, inputDict) {
  const memTable = Array(inputStr.length + 1).fill(false);
  memTable[0] = true;

  for (let i = 1; i <= inputStr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (memTable[j] && inputDict.includes(inputStr.substring(j, i))) {
        memTable[i] = true;
        break;
      }
    }
  }
  return memTable[inputStr.length];
}
```

### [141].

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

### [146].

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.map = {};
  this.set = new Set();
  this.capacity = capacity;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.map[key]) {
    // key already exist, we need to delete the key and add to end
    this.set.delete(key);
    this.set.add(key);
    return this.map[key];
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.map[key]) {
    // remove this key and add back in set, update in hashmap
    this.set.delete(key);
  } else {
    if (this.set.size >= this.capacity) {
      var it = this.set.values();
      var oldKey = it.next().value;
      delete this.map[oldKey];
      this.set.delete(oldKey);
    }
  }
  this.set.add(key);
  this.map[key] = value;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = Object.create(LRUCache).createNew(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [148].

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
  if (head == null || head.next == null) return head;

  let prev = null,
    slow = head,
    fast = head;
  while (fast != null && fase.next != null) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }

  prev.next = null;

  let l1 = sortList(head);
  let l2 = sortList(slow);

  return merge(l1, l2);
};

function merge(l1, l2) {
  let l = new ListNode(0),
    p = l;

  while (l1 != null && l2 != null) {
    if (l1.val < l2.val) {
      p.next = l1;
      l1 = l1.next;
    } else {
      p.next = l2;
      l2 = l2.next;
    }
    p = p.next;
  }

  if (l1 != null) p.next = l1;

  if (l2 != null) p.next = l2;

  return l.next;
}
```

### [149].

```js
/**
 * Definition for a point.
 * function Point(x, y) {
 *     this.x = x;
 *     this.y = y;
 * }
 */
/**
 * @param {Point[]} points
 * @return {number}
 */
var maxPoints = function(points) {
  if (points.length == 0) return 0;
  let maxLength = 1;
  for (let i = 0; i < points.length; i++) {
    let degs = {};
    let samplePoint = 1;
    for (let j = 0; j < points.length; j++) {
      if (i == j) continue;
      if (points[i].x == points[j].x && points[i].y == points[j].y) {
        samplePoint++;
        continue;
      }
      let deg;
      if (points[j].y == points[i].y) deg = Number.MAX_SAFE_INTEGER;
      else deg = (points[j].x - points[i].x) / (points[j].y - points[i].y);

      if (degs[deg]) degs[deg]++;
      else degs[deg] = 1;
    }
    maxLength = Math.max(maxLength, samplePoint);
    for (let k in degs) {
      maxLength = Math.max(maxLength, degs[k] + samplePoint);
    }
  }
  return maxLength;
};

function Point(x, y) {
  this.x = x;
  this.y = y;
}

const p1 = new Point(0, 0);
const p2 = new Point(1, 1);
const p3 = new Point(0, 0);

console.log(maxPoints([p1, p2, p3]));
```

### [150].

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  let index = 0,
    stack = [];

  while (index < tokens.length) {
    if (tokens[index] == '+' || tokens[index] == '-' || tokens[index] == '*' || tokens[index] == '/') {
      if (index < 2) return new Error();
      let num1 = stack.pop();
      let num2 = stack.pop();
      if (tokens[index] == '+') stack.push(num2 + num1);
      else if (tokens[index] == '-') stack.push(num2 - num1);
      else if (tokens[index] == '*') stack.push(num2 * num1);
      else if (tokens[index] == '/') stack.push(parseInt(num2 / num1));
    } else {
      stack.push(parseInt(tokens[index]));
    }
    index++;
  }
  return stack[0];
};

console.log(evalRPN(['2', '1', '+', '3', '*']));
```

### [152].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  if (nums.length == 0) return 0;
  let ans = nums[0],
    max = nums[0],
    min = nums[0];
  for (let i = 1, len = nums.length; i < len; i++) {
    if (nums[i] < 0) {
      let tmp = max;
      max = min;
      min = tmp;
    }
    max = Math.max(nums[i], max * nums[i]);
    min = Math.min(nums[i], min * nums[i]);

    ans = Math.max(max, ans);
  }
  return ans;
};

console.log(maxProduct([-2, 3, -4]));
```

### [155].

```js
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = [];
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.stack.push(x);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  this.stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  let min = this.stack[0];
  for (let val of this.stack) {
    if (val < min) min = val;
  }
  return min;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = Object.create(MinStack).createNew()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### [160].

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  if (headA == null || headB == null) return null;

  let ALen = getLength(headA),
    BLen = getLength(headB),
    lenDiff = Math.abs(ALen - BLen);

  for (let i = 0; i < lenDiff; i++) {
    if (ALen > BLen) headA = headA.next;
    else headB = headB.next;
  }
  let curLen = Math.min(ALen, BLen);
  for (let i = 0; i < curLen; i++) {
    if (headA == headB) {
      return headA;
    }
    headA = headA.next;
    headB = headB.next;
  }
  return null;
};

function getLength(head) {
  let len = 0;
  while (head) {
    len++;
    head = head.next;
  }
  return len;
}
```

### [162].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] > nums[i + 1]) return i;
  }
  return nums.length - 1;
};
```

### [166].

```js
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
  if (numerator == 0) return '0';

  const res = new Array();

  if ((numerator > 0) ^ (denominator > 0)) {
    res.push('-');
  }
  let num = Math.abs(numerator),
    den = Math.abs(denominator);
  res.push(parseInt(num / den));
  if (num % den == 0) return res.join('');

  res.push('.');
  num %= den;

  let map = new Map();
  while (true) {
    let curNum = parseInt((num * 10) / den);
    num = (num * 10) % den;
    if (map.has(curNum)) {
      const index = map.get(curNum);
      res.splice(index, 0, '(');
      res.push(')');
      break;
    } else if (num == 0) {
      res.push(curNum);
      break;
    } else {
      res.push(curNum);
      map.set(curNum, res.length - 1);
    }
  }
  return res.join('');
};
```

### [168].

```js
/**
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
*/
/**
 * @param {number} n
 * @return {string}
 */

// String.fromCharCode(97)
// 'A'.charCodeAt()

// 100 ms	37.6 MB
var convertToTitle = function(n) {
  var result = '',
    cur;

  //97 is the ASCII code for lower case 'a'. If you want uppercase letters, replace 97 with 65 (uppercase 'A').

  while (n > 0) {
    cur = (n - 1) % 26;
    result = String.fromCharCode(65 + cur) + result;
    n = Math.floor((n - 1) / 26);
  }

  return result;
};

// 84 ms	37.7 MB
var convertToTitle1 = function(n) {
  const map = [
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
  ];
  let result = '',
    val;
  while (n > 0) {
    n--;
    val = n % 26;
    result = map[val] + result;
    n = parseInt(n / 26);
    // console.log('n', n);
  }
  return result;
};

let result;

console.log((result = convertToTitle1(1)), result === 'A');
console.log((result = convertToTitle1(28)), result === 'AB');
console.log((result = convertToTitle1(52)), result === 'AZ');
console.log((result = convertToTitle1(701)), result === 'ZY');
```

### [169].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  const mid = parseInt((nums.length + 1) / 2),
    len = nums.length;
  for (let i = 0; i < mid; i++) {
    let min = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[min]) min = j;
    }
    swap(nums, i, min);
  }
  return nums[mid - 1];
};

function swap(arr, a, b) {
  let x = arr[a];
  arr[a] = arr[b];
  arr[b] = x;
}
```

### [171].

```js
/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
  var ans = 0;
  var len = s.length;
  for (let i = 0; i < len; i++) {
    ans += (s[i].charCodeAt(0) - 64) * Math.pow(26, len - 1 - i);
  }
  return ans;
};
```

### [172].

```js
/**
 * @param {number} n
 * @return {number}
 */
// 尾数中的0怎么来的？
// 先考虑，尾数中的0是怎么来的？

// 在1~9的范围内，选两个数字相乘，只有 2*5=10。所以，一对2和5，贡献一个0。
// 不限制范围的话，一对2的倍数和5的倍数，贡献一个0
// 阶乘中，2的倍数肯定比5的倍数多。所以，只需要考虑5的倍数出现了多少次

// 76 ms	39.2 MB
var trailingZeroes = function(n) {
  let count = 0;
  while (n != 0) {
    let tmp = parseInt(n / 5);
    count += tmp;
    n = tmp;
  }
  return count;
};

var trailingZeroes = function(n) {
  var divider = 5,
    reminder = 0;

  while (divider <= n) {
    reminder += Math.floor(n / divider);
    divider = divider * 5;
  }

  return reminder;
};

// 5! 一个 0 5! = 5! * 1
// 10! = 5! * 2
// 15! = 5! * 3
// 20! = 5! * 4

// 80 ms	39.2 MB
var trailingZeroes = function(n) {
  if (n < 5) {
    return 0;
  } else {
    let k = Math.floor(n / 5);
    return k + trailingZeroes(k);
  }
};
```

### [179].

```js
/**
 * @param {number[]} nums
 * @return {string}
 */
var largestNumber = function(nums) {
  nums = nums.map(item => {
    return item + '';
  });

  nums.sort((a, b) => {
    const sort1 = a + b;
    const sort2 = b + a;
    return parseInt(sort2) - parseInt(sort1);
  });

  if (nums[0] == '0') return '0';
  return nums.join('');
};

console.log(largestNumber([5, 10, 7]));
```

### [189].

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  for (let i = 0; i <= k; i++) {
    nums.unshift(nums.pop());
  }
};
```

### [190].

```js
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
  var t = n.toString(2).split('');
  while (t.length < 32) t.unshift('0');
  return parseInt(t.reverse().join(''), 2);
};

reverseBits(1);
```

### [191].

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  let numArr = n.toString(2).split('');
  let count = 0;
  for (let val of numArr) {
    if (val == '1') {
      count++;
    }
  }
  return count;
};
```

### [198].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let a = 0,
    b = 0;
  for (let i = 0; i < nums.length; i++) {
    if (i % 2 == 0) {
      a = Math.max(b, a + nums[i]);
    } else {
      b = Math.max(a, b + nums[i]);
    }
  }
  return Math.max(a, b);
};
```

### [200].

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  if (grid.length == 0) return 0;
  let count = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] == 1) {
        count++;
        helper(i, j, grid);
      }
    }
  }
  return count;
};

function helper(i, j, grid) {
  grid[i][j] = 'OK';
  if (i > 0 && grid[i - 1][j] == 1)
    // 上
    helper(i - 1, j, grid);
  if (i < grid.length - 1 && grid[i + 1][j] == 1)
    // 下
    helper(i + 1, j, grid);
  if (j > 0 && grid[i][j - 1] == 1)
    // 左
    helper(i, j - 1, grid);
  if (i < grid[0].length + 1 && grid[i][j + 1] == 1)
    // 右
    helper(i, j + 1, grid);
}

numIslands([
  ['1', '0', '1', '1', '1'],
  ['1', '0', '1', '0', '1'],
  ['1', '1', '1', '0', '1'],
]);
```

### [104].二叉树的最大深度

```js
/*
 * @lc app=leetcode.cn id=104 lang=javascript
 *
 * [104] 二叉树的最大深度
 *
 * 给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，
返回它的最大深度 3 。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root === null) return 0;
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

function Tree(arr) {
  const head = new TreeNode(null);
  if (arr.length === 0) return head;
  let cur = head;

  return cur;
}
```

```js
function TreeNode(val: any) {
  this.val = val;
  this.left = this.right = null;
}

export default function MaxDepth(root: TreeNode, count: number = 0): number {
  if (!root) return 0;

  const first = MaxDepth(root.left, count);
  const sec = MaxDepth(root.right, count);

  return Math.max(first, sec) + 1;
}

const t = new TreeNode(1);
const t2 = new TreeNode(2);
const t3 = new TreeNode(3);

//           t1
//         /   \
//       t2     null
//      / \
//   null  t3

t.left = t2.right = t3;

// expect(MaxDepth(t)).to.equal(2);
```

### [110].平衡二叉树

```js
//
// Given a binary tree, determine if it is height-balanced.
//
// For this problem, a height-balanced binary tree is defined as a binary tree
// in which the depth of the two subtrees of every node never differ by more
// than [1].
//
// Time Complexity: O(n)
// Space Complexity: O(n+1)

export function TreeNode(val: any) {
  this.val = val;
  this.right = null;
  this.left = this.right;
}

const isBalancedAux = node => {
  if (!node) return 0;
  const left = isBalancedAux(node.left);
  const right = isBalancedAux(node.right);
  if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1;
  return Math.max(left, right) + 1;
};

/**
 * @param {TreeNode} root
 * @return {boolean}
 */
export default function isBalanced(root) {
  if (!root) return true;
  return isBalancedAux(root) !== -1;
}
```

```js
/*
 * @lc app=leetcode.cn id=110 lang=javascript
 *
 * [110] 平衡二叉树
 * 本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。


 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let result = true; // 默认是平衡二叉树，只要找出左右子树高度大于 1 的就不是
var isBalanced = function(root) {
  if (root === null) return true;
  depthMax(root);
  return result;
};

var depthMax = function(root) {
  if (root) {
    let l = depthMax(root.left),
      r = depthMax(root.right);
    if (Math.abs(l - r) > 1) result = false;
    // +1 表示当前层的深度， 需要累加
    return Math.max(l, r) + 1;
  }
  return 0;
};

// function TreeNode(val) {
//   this.val = val;
//   this.left = this.right = null;
// }

// function Tree(arr) {
//   const t = new TreeNode(null)
//   if (arr.length === 0) return t
//   let index = 0, cur = t
//   cur.val = arr[index++]
//   while (index < arr.length) {
//     cur.left = new TreeNode(index++)
//     cur.right = new TreeNode(index++)
//     cur = cur.left
//   }
//   return t
// }

// const t = new TreeNode(null)
// console.log(isBalanced(t))

// TODO:
// ✘ Wrong Answer
// ✘ 195 / 227 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: false
// ✘ expected_answer: true
// ✘ stdout:

// ✘ Wrong Answer
// ✘ 196 / 227 cases passed(N / A)
// ✘ testcase: '[1]'
// ✘ answer: false
// ✘ expected_answer: true
// ✘ stdout:
```

### [111].Minimum-Depth-of-Binary-Tree

```js
/**
 * https://leetcode.com/problems/minimum-depth-of-binary-tree/description/
 * Difficulty:Easy
 *
 * Given a binary tree, find its minimum depth.
 * The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
 *
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
  if (!root) return 0;

  var left = minDepth(root.left);
  var right = minDepth(root.right);

  return left == 0 || right == 0 ? left + right + 1 : Math.min(left, right) + 1;
};
```

```js
const minDepthAux = (root, depth) => {
  if (!root) return Infinity;
  if (!root.left && !root.right) {
    return depth + 1;
  }
  const left = minDepthAux(root.left, depth + 1);
  const right = minDepthAux(root.right, depth + 1);
  return Math.min(left, right);
};

/**
 * @param {TreeNode} root
 * @return {number}
 */
export default function minDepth(root) {
  if (!root) return 0;
  return minDepthAux(root, 0);
}
```

### [112].path-sum 路径总和

```js
/*
 * @lc app=leetcode.cn id=112 lang=javascript
 *
 * [112] 路径总和
 * 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 [5].>[4].>[11].>2。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
  if (root === null) return false;
  if (root.left === null && root.right === null && root.val === sum) return true;
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.right);
};

// Input data:
// [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]
// 22

// Actual
// ✔ runtime: 112 ms
// ✘ answer: false
// ✔ stdout: ''

// Expected
// ✔ runtime: 40 ms
// ✔ answer: true
// ✔ stdout: ''
```

```js
var hasPathSum = function(root, sum) {
  // check
  if (root === null) return false;
  //  if it's leaf:
  if (root.left === null && root.right === null) {
    return root.val === sum;
  }
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
```

### [121].Best-Time-to-Buy-and-Sell-Stock

```js
/**
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
 * Difficulty:Easy
 *
 * Say you have an array for which the ith element is the price of a given stock on day i.
 * If you were only permitted to complete at most one transaction
 * (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
 *
 * Example 1:
 * Input: [7, 1, 5, 3, 6, 4]
 * Output: 5
 * max. difference = [6].1 = 5 (not [7].1 = 6, as selling price needs to be larger than buying price)
 *
 * Example 2:
 * Input: [7, 6, 4, 3, 1]
 * Output: 0
 * In this case, no transaction is done, i.e. max profit = [0].
 */

/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  if (!prices.length) return 0;
  var min = prices[0];
  var max = 0;
  for (var i = 1; i < prices.length; i++) {
    var tmp = prices[i];
    if (tmp < min) min = tmp;
    else if (tmp - min > max) max = tmp - min;
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
```

### [121].买卖股票的最佳时机

```js
/*
 * @lc app=leetcode.cn id=121 lang=javascript
 *
 * [121] 买卖股票的最佳时机
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  // 直接认为 prices length 大于 2
  let max = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    for (let j = i + 1; j < prices.length; j++) {
      const target = prices[j] - prices[i];
      if (target > max) {
        max = target;
      }
    }
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
console.log(maxProfit([1, 4, 2]));
```

### [134].Gas Station(加油站)

```
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.
```

#### 参考答案

1.暴力求解，时间复杂度 O(n^2)

> 我们可以一次遍历 gas，对于每一个 gas 我们依次遍历后面的 gas，计算 remian，如果 remain 一旦小于 0，就说明不行，我们继续遍历下一个

```js
// bad 时间复杂度0(n^2)
let remain = 0;
const n = gas.length;
for (let i = 0; i < gas.length; i++) {
  remain += gas[i];
  remain -= cost[i];
  let count = 0;
  while (remain >= 0) {
    count++;
    if (coun === n) return i;
    remain += gas[getIndex(i + count, n)];
    remain -= cost[getIndex(i + count, n)];
  }
  remain = 0;
}
retirn - 1;
```

2.比较巧妙的方法，时间复杂度是 O(n)

> 这个方法基于两点：
>
> [2].1:如果站点 i 到达站点 j 走不通,那么从 i 到 j 之间的站点(比如 k)出发一定都走不通。前提 i(以及 i 到 k 之间)不会拖累总体(即 remain >= 0)。
>
> [2].2:如果 cost 总和大于 gas 总和，无论如何也无法走到终点，这个比较好理解。因此假如存在一个站点出发能够到达终点，其实就说明 cost 总和一定小于等于 gas 总和

```js
const n = gas.length;
let total = 0;
let remain = 0;
let start = 0;

for (let i = 0; i < n; i++) {
  total += gas[i];
  total -= cost[i];

  remain += gas[i];
  remain -= cost[i];

  // 如果remain < 0,说明从start到i走不通
  // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
  // 因此我们重新从i + 1开始作为start
  if (remain < 0) {
    remain = 0;
    start = i + 1;
  }
}
// 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

// 如果costu总和大于gas总和，无论如何也无法走到终点
return total >= 0 ? start : -1;
```

```js
/*
 * @lc app=leetcode id=134 lang=javascript
 *
 * [134] Gas Station
 */

function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad 时间复杂度O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution 时间复杂度O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // 如果remain < 0, 说明从start到i走不通
    // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
    // 因此我们重新从i + 1开始作为start
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

  // 如果cost总和大于gas总和，无论如何也无法走到终点
  return total >= 0 ? start : -1;
};
```

### [137].single-number-ii

```js
/*
 * @lc app=leetcode id=137 lang=javascript
 *
 * [137] Single Number II
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99
 */
/**
 * @param {number[]} nums
 * @return {number}
 * O(n) 时间复杂度
 */
var singleNumber = function(nums) {
  // [1,1,1,2]
  let res = 0;
  // 前提是nums中数字都不大于2^31
  for (let i = 0; i < 32; i++) {
    let cnt = 0;
    let bit = 1 << i;
    for (let j = 0; j < nums.length; j++) {
      if (nums[j] & bit) cnt++;
    }
    if (cnt % 3 != 0) res = res | bit;
  }
  return res;
};
```

### [138].Copy-List-with-Random-Pointer

```js
/**
 * https://leetcode.com/problems/copy-list-with-random-pointer/description/
 * Difficulty:Medium
 *
 * A linked list is given such that each node contains an additional random pointer
 * which could point to any node in the list or null.
 *
 * Return a deep copy of the list.
 *
 */

// Definition for singly-linked list with a random pointer.
function RandomListNode(label) {
  this.label = label;
  this.next = this.random = null;
}

/**
 * @param {RandomListNode} head
 * @return {RandomListNode}
 */
var copyRandomList = function(head) {
  print(head);

  var p = head;
  // A->B->C
  // A->A'->B->B'->C->C'
  while (p) {
    var copy = new RandomListNode(p.label + "'");
    copy.next = p.next;
    p.next = copy;
    p = copy.next;
  }

  print(head);

  // 构造 A' B' C'.random
  p = head;
  while (p) {
    p.next.random = p.random ? p.random.next : null;
    p = p.next.next;
  }

  print(head);
  // 构造 copy
  var pp = new RandomListNode(0);
  var copy = pp;
  p = head;
  while (p) {
    pp.next = p.next;
    pp = pp.next;

    p.next = pp.next;
    p = p.next;
  }

  print(head);
  print(copy.next);

  return copy.next;
};

var a = new RandomListNode('A');
var b = new RandomListNode('B');
var c = new RandomListNode('C');

a.next = b;
b.next = c;
a.random = c;
b.random = c;
c.random = a;

function print(h) {
  var ls = [];
  var rs = [];
  while (h) {
    ls.push(h.label);
    rs.push(h.random ? h.random.label : 'nil');
    h = h.next;
  }
  console.log(ls.join('->'));
  console.log(rs.join(' '));
  console.log('-------------');
}

console.log(copyRandomList(a));
```

### [139].Word-Break

```js
/**
 * https://leetcode.com/problems/word-break/description/
 * Difficulty:Medium
 *
 * Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.
 *
 * For example, given
 * s = "leetcode",
 * dict = ["leet", "code"].
 * Return true because "leetcode" can be segmented as "leet code".
 */

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var n = s.length;

  var dp = [true];
  for (var i = 1; i < n + 1; i++) {
    for (var j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) > -1) {
        dp[i] = true;
        break;
      } else {
        dp[i] = false;
      }
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(wordBreak('leetcode', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'e']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'leetco']));
```

### [141].linked-list-cycle

```js
/*
 * @lc app=leetcode id=141 lang=javascript
 *
 * [141] Linked List Cycle
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */

//  快慢指针。 如果有环，快指针一定能追上慢指针
var hasCycle1 = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // 快指针一次移动两个
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};

// 哈希表 Set add has 来查询
// 牺牲了空间换时间
var hasCycle = function(head) {
  const set = new Set();
  let curr = head;
  set.add(curr);
  while (curr) {
    if (set.has(curr.next)) {
      return true;
    }
    set.add(curr.next);
    curr = curr.next;
  }
  return false;
};
```

### [145].二叉树的后序遍历

```js
/*
 * @lc app=leetcode.cn id=145 lang=javascript
 *
 * [145] 二叉树的后序遍历
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根
  while (root || stack.length) {
    if (root) {
      stack.push(root);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};

// 递归
// const res = []
// var postorderTraversal = function (root) {
//   if (root === null) return root
//   postorderTraversal(root.left)
//   postorderTraversal(root.right)
//   res.push(root.val)
//   return res
// };
```

### [151].Reverse-Words-in-a-String 单词翻转序列

```js
/**
 * https://leetcode.com/problems/reverse-words-in-a-string/description/
 * Difficulty:Medium
 *
 * Given an input string, reverse the string word by word.
 *
 * For example,
 * Given s = "the sky is blue",
 * return "blue is sky the".
 */

/**
 * @param {string} str
 * @returns {string}
 */
var reverseWords = function(str) {
  return str
    .split(' ')
    .filter(w => w)
    .reverse()
    .join(' ');
};
```

```js
var reverseWords = function(str) {
  var result = '',
    arr,
    len,
    i;

  if (str === null || str === '') {
    return result;
  }
  arr = str.split(' ');
  len = arr.length;
  for (i = len - 1; i >= 0; i--) {
    if (arr[i].length === 0) {
      continue;
    }
    result += ' ' + arr[i];
  }
  return result.trim();
};
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s
    .split(' ')
    .reverse()
    .filter(item => item.length > 0)
    .join(' ');
};

/**
 * @param {string} s
 * @return {string}
 */
var reverseWords2 = function(s) {
  let list = [],
    str = '',
    resStr = '';
  s += ' '; // 加个空格 防止最后一个不是空格的情况, 确保循环到最后能把最后一个加到数组中, 省得再在下面判断
  for (let i = 0; i < s.length; i++) {
    s[i] !== ' ' ? (str += s[i]) : str && (list.push(str), (str = ''));
  }
  for (let j = list.length - 1; j >= 0; j--) {
    resStr += j !== 0 ? list[j] + ' ' : list[j];
  }
  return resStr;
};
```

```js
function ReverseSentence(str) {
  return str
    .split(' ')
    .reverse()
    .join(' ');
}
```

### [152].Maximum-Product-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-product-subarray/description/
 * Difficulty:Medium
 *
 * Find the contiguous subarray within an array (containing at least one number)
 * which has the largest product.
 *
 * For example, given the array [2,3,-2,4],
 * the contiguous subarray [2,3] has the largest product = [6].
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  var a = nums[0];
  var imin = a;
  var imax = a;
  var max = a;

  for (var i = 1; i < nums.length; i++) {
    var t = nums[i];
    if (t < 0) {
      var tmp = imin;
      imin = imax;
      imax = tmp;
    }
    imax = Math.max(t, t * imax);
    imin = Math.min(t, t * imin);
    max = Math.max(max, imax);
  }

  return max;
};

console.log(maxProduct([-1]));
console.log(maxProduct([1]));
console.log(maxProduct([1, 2, 3, -4]));
console.log(maxProduct([2, 3, -2, 4]));
```

### [153].寻找旋转排序数组中的最小值

```js
/*
 * @lc app=leetcode.cn id=153 lang=javascript
 *
 * [153] 寻找旋转排序数组中的最小值
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  let l = 0,
    h = nums.length - 1;
  while (l < h) {
    let mid = l + Math.floor((h - l) / 2);
    if (nums[mid] <= nums[h]) {
      h = mid;
    } else {
      l = mid + 1;
    }
  }
  return nums[l];
};

// console.log(findMin([3, 4, 5, 1, 2]))
// console.log(findMin([4, 5, 6, 7, 0, 1, 2]))
```

### [155].最小栈

```js
/*
 * @lc app=leetcode.cn id=155 lang=javascript
 *
 * [155] 最小栈
 */
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.value = [];
  this.minIndex = -1;
  return this;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.value.push(x);
  if (this.minIndex === -1 || this.value[this.minIndex] > x) {
    // 栈顶
    this.minIndex = this.value.length - 1;
  }
  return this.value.length;
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const popValue = this.value.pop();
  this.minIndex = 0;
  for (let i = 0; i < this.value.length; i++) {
    if (this.value[i] < this.value[this.minIndex]) {
      this.minIndex = i;
    }
  }
  return popValue;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const length = this.value.length;
  return this.value[length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.value[this.minIndex];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

const minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
console.log(minStack.getMin());
console.log(minStack.pop());
console.log(minStack.top());
console.log(minStack.getMin());
```

### [160].intersection-of-two-linked-lists

```js
/*
 * @lc app=leetcode id=160 lang=javascript
 *
 * [160] Intersection of Two Linked Lists
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // 网上精妙的解法没看懂
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

### [162].Find-Peak-Element

```js
/**
 * https://leetcode.com/problems/find-peak-element/description/
 * Difficulty:Medium
 *
 * A peak element is an element that is greater than its neighbors.
 * Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
 * The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
 * You may imagine that num[-1] = num[n] = -∞.
 * For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number [2].
 */

/**
 *
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  for (var i = 1; i < nums.length; i++) {
    if (nums[i - 1] > nums[i]) return i - 1;
  }
  return nums.length - 1;
};

// ================================================

/**
 * 二分查找
 *
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  if (nums.length <= 1) return 0;
  var l = 0;
  var h = nums.length - 1;
  while (l < h) {
    var mid = Math.floor((l + h) / 2);
    if (nums[mid] > nums[mid + 1]) h = mid;
    else l = mid + 1;
  }
  return l;
};

// ================================================

console.log(findPeakElement([3, 2, 1]), 0);
console.log(findPeakElement([1, 2, 3, 1]), 2);
console.log(findPeakElement([1, 3, 2]), 1);
```

### [164].最大间距

```js
/*
 * @lc app=leetcode.cn id=164 lang=javascript
 *
 * [164] 最大间距
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap1 = function(nums) {
  const map = {};
  // 用空间牺牲来换时间，一次遍历即可
  for (let i = 0; i < nums.length; i++) {
    map[nums[i]] = true;
  }
  // key number 类型默认会排序输出
  const keys = Object.keys(map);
  let max = 0;
  for (let i = 0; i < keys.length - 1; i++) {
    let tmp = keys[i + 1] - keys[i];
    if (max < tmp) {
      max = tmp;
    }
  }
  return max;
};

var maximumGap = function(nums) {
  let maxGap = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    // 每次应该默认基准值为最小，在剩余部分中尝试找出一个更小的数
    let minIndex = i;
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }
    // 每次循环， a[i] 位都将是未选择出的数据中的最小值
    if (minIndex !== i) {
      [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    }
    // console.log('nums: ', nums)
    if (i > 0) {
      const tmp = nums[i] - nums[i - 1];
      maxGap = tmp > maxGap ? tmp : maxGap;
      // console.log('maxGap  ==== ', maxGap)
    }
  }
  // 倒数第二个与倒数第一个值差
  const tmp = nums[nums.length - 1] - nums[nums.length - 2];
  maxGap = tmp > maxGap ? tmp : maxGap;
  return maxGap;
};

console.log(maximumGap([3, 6, 9, 1]));
console.log(maximumGap([10]));
console.log(maximumGap([1, 10000000]));

// console.log(maximumGap1([3, 6, 9, 1]))
// console.log(maximumGap1([10]))
```

### [167].Two-Sum-II-Input-array-is-sorted

```js
/**
 * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
 * Difficulty:Easy
 *
 * Given an array of integers that is already sorted in ascending order,
 * find two numbers such that they add up to a specific target number.
 * The function twoSum should return indices of the two numbers such that they add up to the target,
 * where index1 must be less than index2.
 *
 * Please note that your returned answers (both index1 and index2) are not zero-based.
 * You may assume that each input would have exactly one solution and you may not use the same element twice.
 *
 * Input: numbers=[2, 7, 11, 15], target=9
 * Output: index1=1, index2=2
 *
 */

/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
  for (var i = 0; i < numbers.length - 1; i++) {
    for (var j = i + 1; j < numbers.length; j++) {
      if (numbers[i] + numbers[j] === target) return [i + 1, j + 1];
    }
  }
};

// ==========================================

/**
 * 双指针
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  var lo = 0;
  var hi = nums.length - 1;

  while (nums[lo] + nums[hi] !== target) {
    if (nums[lo] + nums[hi] > target) hi--;
    else lo++;
  }
  return [lo + 1, hi + 1];
};

console.log(twoSum([2, 7, 11, 15], 9));
```

### [167].两数之和 II - 输入有序数组

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值(index1 和 index2)不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2。

```js
//  indexOf 太低效了。。。。
var twoSum1 = function(numbers, target) {
  for (let i = 0; i < numbers.length; i++) {
    const find = target - numbers[i];
    let index = numbers.findStart(find, i + 1);
    // console.log('index', index)
    if (index !== -1) {
      return [i + 1, index + 1];
    }
  }
};

Array.prototype.findStart = function(target, start) {
  let index = this.slice(start).indexOf(target);
  return index !== -1 ? index + start : -1;
};

// 暴力循环法
var twoSum2 = function(numbers, target) {
  for (let i = 0; i < numbers.length - 1; i++) {
    for (let j = i + 1; j < numbers.length; j++) {
      // 下标从 0 开始
      if (numbers[i] + numbers[j] === target) return [i + 1, j + 1];
    }
  }
};

// 使用双指针
var twoSum = function(numbers, target) {
  let left = 0,
    right = numbers.length - 1,
    temp;
  while (left < right) {
    temp = numbers[left] + numbers[right];
    if (temp === target) {
      return [left + 1, right + 1];
    } else if (temp > target) {
      right--;
    } else {
      left++;
    }
  }
};

console.log(twoSum([2, 7, 11, 15], 9));
console.log(twoSum([0, 0, 3, 4], 0));
console.log(twoSum([-1, -2, 0, 0, 3, 4], 0));
```

```js
const handler = (num, target) => {
  num = num.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  const length = num.length;
  let jizhun = num[length - 1],
    res;
  for (let i = 0; i < num.length; i++) {
    if (target - num[i] <= jizhun) {
      // 最大也只能是 基准值
      jizhun = target - num[i];
      const index = num.indexOf(jizhun);
      if (index > -1) {
        res = [num[i], num[index]];
        break;
      }
    }
  }
  return res;
};

const a = [3, 2, 4],
  b = 6;
const res = handler(a, b);
console.log(res);
```

### 169

```js
// [169]. Majority Element

// Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

// You may assume that the array is non-empty and the majority element always exist in the array.

// Example 1:

// Input: [3,2,3]
// Output: 3
// Example 2:

// Input: [2,2,1,1,1,2,2]
// Output: 2

// Time: O(n)
// Sace: O(1)

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function majorityElement(nums) {
  if (!nums.length) return 0;
  let majorityIndex = 0;
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    // If current num === majority number, count++
    if (nums[i] === nums[majorityIndex]) {
      count++;
    } else {
      count--;
    }
    // If count === 0, set to current num
    if (count === 0) {
      majorityIndex = i;
      count = 1;
    }
  }

  return nums[majorityIndex];
}
```

### [169].求众数

```js
/*
 * @lc app=leetcode.cn id=169 lang=javascript
 *
 * [169] 求众数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (nums.length === 1) return nums[0];
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > parseInt(nums.length / 2)) {
        return key;
      }
    }
    // console.log('i', i)
  }
};

// console.log(majorityElement([1]))
// console.log(majorityElement([3, 2, 3]))
// console.log(majorityElement([2, 2, 1, 1, 1, 2, 2]))
```

### [171].Excel-Sheet-Column-Number

```js
/**
 * https://leetcode.com/problems/excel-sheet-column-number/description/
 * Difficulty:Easy
 *
 * Given a column title as appear in an Excel sheet, return its corresponding column number.
 * For example:
 * A -> 1
 * B -> 2
 * C -> 3
 * ...
 * Z -> 26
 * AA -> 27
 * AB -> 28
 */

/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
  var num = 0;
  var aCode = 'A'.charCodeAt(0);
  for (var i = 0; i < s.length; i++) {
    var n = 1 + s.charCodeAt(i) - aCode;
    num = num * 26 + n;
  }
  return num;
};

console.log(titleToNumber('AA'));
```

### 189

```js
// [189]. Rotate Array

// Given an array, rotate the array to the right by k steps, where k is non-negative.

// Example 1:

// Input: [1,2,3,4,5,6,7] and k = 3
// Output: [5,6,7,1,2,3,4]
// Explanation:
// rotate 1 steps to the right: [7,1,2,3,4,5,6]
// rotate 2 steps to the right: [6,7,1,2,3,4,5]
// rotate 3 steps to the right: [5,6,7,1,2,3,4]
// Example 2:

// Input: [-1,-100,3,99] and k = 2
// Output: [3,99,-1,-100]
// Explanation:
// rotate 1 steps to the right: [99,-1,-100,3]
// rotate 2 steps to the right: [3,99,-1,-100]
// Note:

// Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
// Could you do it in-place with O(1) extra space?

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */

const reverse = (arr, i, j) => {
  while (i < j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    i++;
    j--;
  }
  return arr;
};

export default function rotate(nums, k) {
  k %= nums.length;
  reverse(nums, 0, nums.length - 1);
  reverse(nums, 0, k - 1);
  return reverse(nums, k, nums.length - 1);
}
```

### [189].rotate-array

```js
/*
 * @lc app=leetcode id=189 lang=javascript
 *
 * [189] Rotate Array
 *
 * https://leetcode.com/problems/rotate-array/description/
 *
 * algorithms
 * Easy (29.07%)
 * Total Accepted:    [287].3K
 * Total Submissions: [966].9K
 * Testcase Example:  '[1,2,3,4,5,6,7]\n3'
 *
 * Given an array, rotate the array to the right by k steps, where k is
 * non-negative.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,4,5,6,7] and k = 3
 * Output: [5,6,7,1,2,3,4]
 * Explanation:
 * rotate 1 steps to the right: [7,1,2,3,4,5,6]
 * rotate 2 steps to the right: [6,7,1,2,3,4,5]
 * rotate 3 steps to the right: [5,6,7,1,2,3,4]
 *
 *
 * Example 2:
 *
 *
 * Input: [-1,-100,3,99] and k = 2
 * Output: [3,99,-1,-100]
 * Explanation:
 * rotate 1 steps to the right: [99,-1,-100,3]
 * rotate 2 steps to the right: [3,99,-1,-100]
 *
 *
 * Note:
 *
 *
 * Try to come up as many solutions as you can, there are at least 3 different
 * ways to solve this problem.
 * Could you do it in-place with O(1) extra space?
 *
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  // 就像扩容一样操作
  k = k % nums.length;
  const n = nums.length;

  for (let i = nums.length - 1; i >= 0; i--) {
    nums[i + k] = nums[i];
  }

  for (let i = 0; i < k; i++) {
    nums[i] = nums[n + i];
  }
  nums.length = n;
};
```

### [189].旋转数组

```js
var rotate = function(nums, k) {
  if (nums.length === 0) return [];
  k %= nums.length;

  let last = nums[0];
  for (let i = 0; i < nums.length; i += 4) {
    if (i < k) {
      last = nums[i];
      nums[i] = nums[nums.length - k + i];
    } else {
      last = nums[i];
      nums[i] = nums[i - 3];
    }
  }
  nums[0] = start;

  return nums;
};

console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));
console.log(rotate([-1, -100, 3, 99], 2));
```

### [190].Reverse-Bits

```js
/**
 * https://leetcode.com/problems/reverse-bits/#/description
 * Difficulty:Easy
 *
 * Reverse bits of a given 32 bits unsigned integer.
 *
 * For example, given input 43261596 (represented in binary as 00000010100101000001111010011100),
 *
 * return 964176192 (represented in binary as 00111001011110000010100101000000).
 *
 * 00000010100101000001111010011100
 * 00111001011110000010100101000000
 */

/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
  // reverse binary str
  var str = '';
  var i = 32;
  while (i--) {
    str += n % 2;
    n = Math.floor(n / 2);
  }

  return parseInt(str, 2);
};

console.log(reverseBits(43261596) == 964176192);
```

### [191].Number-of-[1].Bits

```js
/**
 *
 * https://leetcode.com/problems/number-of-[1].bits/description
 * Difficulty:Easy
 *
 * Write a function that takes an unsigned integer and returns the number of ’1' bits it has
 * (also known as the Hamming weight).
 *
 * For example, the [32].bit integer ’11' has binary representation
 * 00000000000000000000000000001011, so the function should return [3].
 */

/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  var weight = 0;

  while (n > 0) {
    weight += n % 2;
    n = Math.floor(n / 2);
  }
  return weight;
};

console.log(hammingWeight(11) == 3);
console.log(hammingWeight(0) == 0);
console.log(hammingWeight(1) == 1);
```

### [191].位-[1].的个数

```js
/*
 * @lc app=leetcode.cn id=191 lang=javascript
 *
 * [191] 位1的个数
 */
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight1 = function(n) {
  let count = 0;
  while (n) {
    // 直接判断二进制最低为的数是不是1
    count += n & 1;
    // 每一步都右移一位
    n >>= 1;
  }
  return count;
};

// TODO: JS 超出值范围
console.log(hammingWeight(00000000000000000000000000001011));
console.log(hammingWeight(00000000000000000000000010000000));
console.log(hammingWeight('11111111111111111111111111111101'));
```

### [198].House-Robber

```js
/**
 * https://leetcode.com/problems/house-robber/description/
 * Difficulty:Easy
 *
 * You are a professional robber planning to rob houses along a street.
 * Each house has a certain amount of money stashed,
 * the only constraint stopping you from robbing each of them is that adjacent houses have security system connected
 * and it will automatically contact the police if two adjacent houses were broken into on the same night.

 Given a list of non-negative integers representing the amount of money of each house,
 determine the maximum amount of money you can rob tonight without alerting the police.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  if (!nums.length) return 0;
  var dp = [0, nums[0]];
  var max = nums[0];
  for (var i = 1; i < nums.length; i++) {
    dp[i + 1] = Math.max(dp[i], dp[i - 1] + nums[i]);
    max = Math.max(dp[i + 1], max);
  }
  return max;
};

console.log(rob([5, 2, 3, 5, 8]));
```

### 198

```js
// [198]. House Robber

// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint
// stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police
// if two adjacent houses were broken into on the same night.

// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob
// tonight without alerting the police.

// Explaination:
// https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems

const robAux = (nums, i, map) => {
  if (i >= nums.length) return 0;
  if (map.has(i)) return map.get(i);
  const a = robAux(nums, i + 1, map);
  const b = robAux(nums, i + 2, map);
  const curr = Math.max(a, b + nums[i]);
  map.set(i, curr);
  return curr;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function rob(nums) {
  const map = new Map();
  return robAux(nums, 0, map);
}
```

### [102].binary-tree-level-order-traversal

#### 题目描述

```
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

#### 思路

这道题可以借助`队列`实现，首先把 root 入队，然后入队一个特殊元素 Null(来表示每层的结束)。

然后就是 while(queue.length), 每次处理一个节点，都将其子节点(在这里是 left 和 right)放到队列中。

然后不断的出队， 如果出队的是 null，则表式这一层已经结束了，我们就继续 push 一个 null。

如果不入队特殊元素 Null 来表示每层的结束，则在 while 循环开始时保存当前队列的长度，以保证每次只遍历一层(参考下面的 C++ Code)。

> 如果采用递归方式，则需要将当前节点，当前所在的 level 以及结果数组传递给递归函数。在递归函数中，取出节点的值，添加到 level 参数对应结果数组元素中(参考下面的 C++ Code)。

#### 关键点解析

- 队列

- 队列中用 Null(一个特殊元素)来划分每层

- 树的基本操作- 遍历 - 层次遍历(BFS)

- 注意塞入 null 的时候，判断一下当前队列是否为空，不然会无限循环

#### 代码

```js
/*
 * @lc app=leetcode id=102 lang=javascript
 *
 * [102] Binary Tree Level Order Traversal
 *
 * https://leetcode.com/problems/binary-tree-level-order-traversal/description/
 *
 * algorithms
 * Medium (47.18%)
 * Total Accepted:    346.4K
 * Total Submissions: 731.3K
 * Testcase Example:  '[3,9,20,null,null,15,7]'
 *
 * Given a binary tree, return the level order traversal of its nodes' values.
 * (ie, from left to right, level by level).
 *
 *
 * For example:
 * Given binary tree [3,9,20,null,null,15,7],
 *
 *
 * ⁠   3
 * ⁠  / \
 * ⁠ 9  20
 * ⁠   /  \
 * ⁠  15   7
 *
 *
 *
 * return its level order traversal as:
 *
 * [
 * ⁠ [3],
 * ⁠ [9,20],
 * ⁠ [15,7]
 * ]
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  if (!root) return [];
  const items = []; // 存放所有节点
  const queue = [root, null]; // null 简化操作
  let levelNodes = []; // 存放每一层的节点

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      // 一层已经遍历完了
      items.push(levelNodes);
      levelNodes = [];
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

#### 相关题目

- [103.binary-tree-zigzag-level-order-traversal](./103.binary-tree-zigzag-level-order-traversal.md)
- [104.maximum-depth-of-binary-tree](./104.maximum-depth-of-binary-tree.md)

### [103].binary-tree-zigzag-level-order-traversal

#### 题目描述

和 leetcode 102 基本是一样的，思路是完全一样的。

```
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```

#### 思路

这道题可以借助`队列`实现，首先把 root 入队，然后入队一个特殊元素 Null(来表示每层的结束)。

然后就是 while(queue.length), 每次处理一个节点，都将其子节点(在这里是 left 和 right)放到队列中。

然后不断的出队， 如果出队的是 null，则表式这一层已经结束了，我们就继续 push 一个 null。

#### 关键点解析

- 队列

- 队列中用 Null(一个特殊元素)来划分每层

- 树的基本操作- 遍历 - 层次遍历(BFS)

#### 代码

```js
/*
 * @lc app=leetcode id=103 lang=javascript
 *
 * [103] Binary Tree Zigzag Level Order Traversal
 *
 * https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/
 *
 * algorithms
 * Medium (40.57%)
 * Total Accepted:    201.2K
 * Total Submissions: 493.7K
 * Testcase Example:  '[3,9,20,null,null,15,7]'
 *
 * Given a binary tree, return the zigzag level order traversal of its nodes'
 * values. (ie, from left to right, then right to left for the next level and
 * alternate between).
 *
 *
 * For example:
 * Given binary tree [3,9,20,null,null,15,7],
 *
 * ⁠   3
 * ⁠  / \
 * ⁠ 9  20
 * ⁠   /  \
 * ⁠  15   7
 *
 *
 *
 * return its zigzag level order traversal as:
 *
 * [
 * ⁠ [3],
 * ⁠ [20,9],
 * ⁠ [15,7]
 * ]
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  if (!root) return [];
  const items = [];
  let isOdd = true;
  let levelNodes = [];

  const queue = [root, null];

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      if (!isOdd) {
        levelNodes = levelNodes.reverse();
      }
      items.push(levelNodes);
      levelNodes = [];
      isOdd = !isOdd;
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

#### 相关题目

- [102.binary-tree-level-order-traversal](./102.binary-tree-level-order-traversal.md)
- [104.maximum-depth-of-binary-tree](./104.maximum-depth-of-binary-tree.md)

### [104].maximum-depth-of-binary-tree

#### 题目描述

```
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.

```

#### 思路

由于树是一种递归的数据结构，因此用递归去解决的时候往往非常容易，这道题恰巧也是如此，
用递归实现的代码如下：

```js
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

如果使用迭代呢？ 我们首先应该想到的是树的各种遍历，由于我们求的是深度，因此
使用层次遍历(BFS)是非常合适的。 我们只需要记录有多少层即可。相关思路请查看[binary-tree-traversal](../thinkings/binary-tree-traversal.md)

#### 关键点解析

- 队列

- 队列中用 Null(一个特殊元素)来划分每层，或者在对每层进行迭代之前保存当前队列元素的个数(即当前层所含元素个数)

- 树的基本操作- 遍历 - 层次遍历(BFS)

#### 代码

```js
/*
 * @lc app=leetcode id=104 lang=javascript
 *
 * [104] Maximum Depth of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;

  // 层次遍历 BFS
  let cur = root;
  const queue = [root, null];
  let depth = 1;

  while ((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      // 注意⚠️： 不处理会无限循环，进而堆栈溢出
      if (queue.length === 0) return depth;
      depth++;
      queue.push(null);
      continue;
    }
    const l = cur.left;
    const r = cur.right;

    if (l) queue.push(l);
    if (r) queue.push(r);
  }

  return depth;
};
```

#### 相关题目

- [102.binary-tree-level-order-traversal](./102.binary-tree-level-order-traversal.md)
- [103.binary-tree-zigzag-level-order-traversal](./103.binary-tree-zigzag-level-order-traversal.md)

### [121].best-time-to-buy-and-sell-stock

#### 题目描述

```
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

#### 思路

由于我们是想获取到最大的利润，我们的策略应该是低点买入，高点卖出。

由于题目对于交易次数有限制，只能交易一次，因此问题的本质其实就是求波峰浪谷的差值的最大值。

用图表示的话就是这样：

#### 关键点解析

- 这类题只要你在心中(或者别的地方)画出上面这种图就很容易解决

#### 代码

```js
/*
 * @lc app=leetcode id=121 lang=javascript
 *
 * [121] Best Time to Buy and Sell Stock
 *
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
 *
 * algorithms
 * Easy (46.34%)
 * Total Accepted:    480.5K
 * Total Submissions: 1M
 * Testcase Example:  '[7,1,5,3,6,4]'
 *
 * Say you have an array for which the i^th element is the price of a given
 * stock on day i.
 *
 * If you were only permitted to complete at most one transaction (i.e., buy
 * one and sell one share of the stock), design an algorithm to find the
 * maximum profit.
 *
 * Note that you cannot sell a stock before you buy one.
 *
 * Example 1:
 *
 *
 * Input: [7,1,5,3,6,4]
 * Output: 5
 * Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit
 * = 6-1 = 5.
 * Not 7-1 = 6, as selling price needs to be larger than buying price.
 *
 *
 * Example 2:
 *
 *
 * Input: [7,6,4,3,1]
 * Output: 0
 * Explanation: In this case, no transaction is done, i.e. max profit = 0.
 *
 *
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let min = prices[0];
  let profit = 0;
  // 7 1 5 3 6 4
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = Math.max(profit, prices[i] - min);
    } else {
      min = Math.min(min, prices[i]);
    }
  }

  return profit;
};
```

Python Code:

```python
### 应用Kadane's algorithms
class Solution:
    def maxProfit(self, prices: 'List[int]') -> int:
        """
        step by step
        """
        ### error case
        if len(prices) < 1:
            return 0

        ### caluate the daily gains, break into a subarray problem
        gains = [prices[i]-prices[i-1] for i in range(1, len(prices))]

        loc_max = global_max = 0 #not gains[0] in case of negative
        for i in range(len(gains)):
            loc_max = max(loc_max + gains[i], gains[i])
            if loc_max > global_max:
                global_max = loc_max
"""
Runtime: 48 ms, faster than 34.50% of Python3 online submissions for Best Time to Buy and Sell Stock.
Memory Usage: 14.1 MB, less than 10.26% of Python3 online submissions for Best Time to Buy and Sell Stock.
"""
```

#### 相关题目

- [122.best-time-to-buy-and-sell-stock-ii](./122.best-time-to-buy-and-sell-stock-ii.md)
- [309.best-time-to-buy-and-sell-stock-with-cooldown](./309.best-time-to-buy-and-sell-stock-with-cooldown.md)

### [122].best-time-to-buy-and-sell-stock-ii

#### 题目描述

```
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

#### 思路

由于我们是想获取到最大的利润，我们的策略应该是低点买入，高点卖出。

由于题目对于交易次数没有限制，因此只要能够赚钱的机会我们都不应该放过。

> 如下图，我们只需要求出加粗部分的总和即可

用图表示的话就是这样：

#### 关键点解析

- 这类题只要你在心中(或者别的地方)画出上面这种图就很容易解决

#### 代码

语言支持：JS，Python

JS Code:

```js
/*
 * @lc app=leetcode id=122 lang=javascript
 *
 * [122] Best Time to Buy and Sell Stock II
 *
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/
 *
 * algorithms
 * Easy (50.99%)
 * Total Accepted:    315.5K
 * Total Submissions: 610.9K
 * Testcase Example:  '[7,1,5,3,6,4]'
 *
 * Say you have an array for which the i^th element is the price of a given
 * stock on day i.
 *
 * Design an algorithm to find the maximum profit. You may complete as many
 * transactions as you like (i.e., buy one and sell one share of the stock
 * multiple times).
 *
 * Note: You may not engage in multiple transactions at the same time (i.e.,
 * you must sell the stock before you buy again).
 *
 * Example 1:
 *
 *
 * Input: [7,1,5,3,6,4]
 * Output: 7
 * Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit
 * = 5-1 = 4.
 * Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 =
 * 3.
 *
 *
 * Example 2:
 *
 *
 * Input: [1,2,3,4,5]
 * Output: 4
 * Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit
 * = 5-1 = 4.
 * Note that you cannot buy on day 1, buy on day 2 and sell them later, as you
 * are
 * engaging multiple transactions at the same time. You must sell before buying
 * again.
 *
 *
 * Example 3:
 *
 *
 * Input: [7,6,4,3,1]
 * Output: 0
 * Explanation: In this case, no transaction is done, i.e. max profit = 0.
 *
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let profit = 0;

  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = profit + prices[i] - prices[i - 1];
    }
  }

  return profit;
};
```

Python Code:

```python
class Solution:
    def maxProfit(self, prices: 'List[int]') -> int:
        gains = [prices[i] - prices[i-1] for i in range(1, len(prices))
                 if prices[i] - prices[i-1] > 0]
        return sum(gains)
print(Solution().maxProfit([7, 1, 5, 3, 6, 4]))
#评论区里都讲这是一道开玩笑的送分题.
```

#### 相关题目

- [121.best-time-to-buy-and-sell-stock](./121.best-time-to-buy-and-sell-stock.md)
- [309.best-time-to-buy-and-sell-stock-with-cooldown](./309.best-time-to-buy-and-sell-stock-with-cooldown.md)

### [113].path-sum-ii

#### 题目描述

```
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
```

#### 思路

这道题目是求集合，并不是`求值`，而是枚举所有可能，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=113 lang=javascript
 *
 * [113] Path Sum II
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function backtrack(root, sum, res, tempList) {
  if (root === null) return;
  if (root.left === null && root.right === null && sum === root.val) return res.push([...tempList, root.val]);

  tempList.push(root.val);
  backtrack(root.left, sum - root.val, res, tempList);

  backtrack(root.right, sum - root.val, res, tempList);
  tempList.pop();
}
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
  if (root === null) return [];
  const res = [];
  backtrack(root, sum, res, []);
  return res;
};
```

#### 相关题目

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [131.palindrome-partitioning](./131.palindrome-partitioning.md)

### [114].flatten-binary-tree-to-linked-list

```js
/*
 * @lc app=leetcode id=114 lang=javascript
 *
 * [114] Flatten Binary Tree to Linked List
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function preorderTraversal(root) {
  if (!root) return [];

  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = null;

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

### [124].binary-tree-maximum-path-sum

#### 题目描述

```
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

#### 思路

这道题目的 path 让我误解了，然后浪费了很多时间来解这道题
我觉得 leetcode 给的 demo 太少了，不足以让我理解 path 的概念
因此我这里自己画了一个图，来补充一下，帮助大家理解 path 的概念，不要像我一样理解错啦。

首先是官网给的两个例子：

接着是我自己画的一个例子：

大家可以结合上面的 demo 来继续理解一下 path， 除非你理解了 path，否则不要往下看。

树的题目，基本都是考察递归思想的。因此我们需要思考如何去定义我们的递归函数，
在这里我定义了一个递归函数，它的功能是，`返回以当前节点为根节点的MathPath`
但是有两个条件:

1.  第一是跟节点必须选择
2.  第二是左右子树只能选择一个

为什么要有这两个条件?

我的想法是原问题可以转化为：

以每一个节点为根节点，我们分别求出 max path，最后计算最大值,因此第一个条件需要满足.

对于第二个，由于递归函数子节点的返回值会被父节点使用，因此我们如果两个孩子都选择了
就不符合 max path 的定义了，这也是我没有理解题意，绕了很大弯子的原因。

因此我的做法就是不断调用递归函数，然后在调用过程中不断计算和更新 max，最后在主函数中将 max 返回即可。

#### 关键点解析

- 递归
- 理解题目中的 path 定义

#### 代码

```js
/*
 * @lc app=leetcode id=124 lang=javascript
 *
 * [124] Binary Tree Maximum Path Sum
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function helper(node, payload) {
  if (node === null) return 0;

  const l = helper(node.left, payload);
  const r = helper(node.right, payload);

  payload.max = Math.max(node.val + Math.max(0, l) + Math.max(0, r), payload.max);

  return node.val + Math.max(l, r, 0);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
  if (root === null) return 0;
  const payload = {
    max: root.val,
  };
  helper(root, payload);
  return payload.max;
};
```

#### 相关题目

- [113.path-sum-ii](./113.path-sum-ii.md)

### [128].longest-consecutive-sequence

#### 题目描述

```
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Accepted
200,786
Submissions
485,346

```

#### 思路

这是一道最最长连续数字序列长度的题目， 官网给出的难度是`hard`.

符合直觉的做法是先排序，然后用一个变量记录最大值，遍历去更新最大值即可，

代码：

```js
if (nums.length === 0) return 0;
let count = 1;
let maxCount = 1;
// 这里其实可以不需要排序，这么做只不过是为了方便理解
nums = [...new Set(nums)].sort((a, b) => a - b);
for (let i = 0; i < nums.length - 1; i++) {
  if (nums[i + 1] - nums[i] === 1) {
    count++;
  } else {
    if (count > maxCount) {
      maxCount = count;
    }
    count = 1;
  }
}
return Math.max(count, maxCount);
```

但是需要排序时间复杂度会上升，题目要求时间复杂度为 O(n),
那么我们其实可以不用排序去解决的。

思路就是将之前”排序之后，通过比较前后元素是否相差 1 来判断是否连续“的思路改为
不排序而是`直接遍历，然后在内部循环里面查找是否存在当前值的邻居元素`，但是马上有一个
问题，内部我们`查找是否存在当前值的邻居元素`的过程如果使用数组时间复杂度是 O(n),
那么总体的复杂度就是 O(n^2)，完全不可以接受。怎么办呢？

我们换个思路，用空间来换时间。比如用类似于 hashmap 这样的数据结构优化查询部分，将时间复杂度降低到 O(1), 代码见后面`代码部分`

#### 关键点解析

- 空间换时间

#### 代码

```js
/*
 * @lc app=leetcode id=128 lang=javascript
 *
 * [128] Longest Consecutive Sequence
 *
 * https://leetcode.com/problems/longest-consecutive-sequence/description/
 *
 * algorithms
 * Hard (40.98%)
 * Total Accepted:    200.3K
 * Total Submissions: 484.5K
 * Testcase Example:  '[100,4,200,1,3,2]'
 *
 * Given an unsorted array of integers, find the length of the longest
 * consecutive elements sequence.
 *
 * Your algorithm should run in O(n) complexity.
 *
 * Example:
 *
 *
 * Input: [100, 4, 200, 1, 3, 2]
 * Output: 4
 * Explanation: The longest consecutive elements sequence is [1, 2, 3, 4].
 * Therefore its length is 4.
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  nums = new Set(nums);
  let max = 0;
  let y = 0;
  nums.forEach(x => {
    // 说明x是连续序列的开头元素
    if (!nums.has(x - 1)) {
      y = x + 1;
      while (nums.has(y)) {
        y = y + 1;
      }
      max = Math.max(max, y - x); // y - x 就是从x开始到最后有多少连续的数字
    }
  });
  return max;
};
```

### [129].sum-root-to-leaf-numbers

#### 题目描述

```
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.

```

#### 思路

这是一道非常适合训练递归的题目。虽然题目不难，但是要想一次写正确，并且代码要足够优雅却不是很容易。

这里我们的思路是定一个递归的 helper 函数，用来帮助我们完成递归操作。
递归函数的功能是将它的左右子树相加，注意这里不包括这个节点本身，否则会多加，
我们其实关注的就是叶子节点的值，然后通过层层回溯到 root，返回即可。

整个过程如图所示：

那么数字具体的计算逻辑，如图所示，相信大家通过这个不难发现规律：

#### 关键点解析

- 递归分析

#### 代码

```js
/*
 * @lc app=leetcode id=129 lang=javascript
 *
 * [129] Sum Root to Leaf Numbers
 */
function helper(node, cur) {
  if (node === null) return 0;
  const next = node.val + cur * 10;

  if (node.left === null && node.right === null) return next;

  const l = helper(node.left, next);
  const r = helper(node.right, next);

  return l + r;
}
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
  // tag: `tree` `dfs` `math`
  return helper(root, 0);
};
```

#### 相关题目

- [sum-of-root-to-leaf-binary-numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)

> 这道题和本题太像了，跟一道题没啥区别

### [131].palindrome-partitioning

#### 题目描述

```
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]

```

#### 思路

这是一道求解所有可能性的题目， 这时候可以考虑使用回溯法。 回溯法解题的模板我们已经在很多题目中用过了，
这里就不多说了。大家可以结合其他几道题目加深一下理解。

#### 关键点解析

- 回溯法

#### 代码

```js
/*
 * @lc app=leetcode id=131 lang=javascript
 *
 * [131] Palindrome Partitioning
 */

function isPalindrom(s) {
  let left = 0;
  let right = s.length - 1;

  while (left < right && s[left] === s[right]) {
    left++;
    right--;
  }

  return left >= right;
}
function backtrack(s, list, tempList, start) {
  const sliced = s.slice(start);

  if (isPalindrom(sliced) && tempList.join('').length === s.length) list.push([...tempList]);

  for (let i = 0; i < sliced.length; i++) {
    const sub = sliced.slice(0, i + 1);
    if (isPalindrom(sub)) {
      tempList.push(sub);
    } else {
      continue;
    }
    backtrack(s, list, tempList, start + i + 1);
    tempList.pop();
  }
}
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
  // "aab"
  // ["aa", "b"]
  // ["a", "a", "b"]
  const list = [];
  backtrack(s, list, [], 0);
  return list;
};
```

#### 相关题目

- [39.combination-sum](./39.combination-sum.md)
- [40.combination-sum-ii](./40.combination-sum-ii.md)
- [46.permutations](./46.permutations.md)
- [47.permutations-ii](./47.permutations-ii.md)
- [78.subsets](./78.subsets.md)
- [90.subsets-ii](./90.subsets-ii.md)
- [113.path-sum-ii](./113.path-sum-ii.md)

### [136].single-number

#### 题目描述

```
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
```

#### 思路

根据题目描述，由于加上了时间复杂度必须是 O(n)，并且空间复杂度为 O(1)的条件，因此不能用排序方法，也不能使用 map 数据结构。

我们可以利用二进制异或的性质来完成，将所有数字异或即得到唯一出现的数字。

#### 关键点

1. 异或的性质
   两个数字异或的结果`a^b`是将 a 和 b 的二进制每一位进行运算，得出的数字。 运算的逻辑是
   如果同一位的数字相同则为 0，不同则为 1

2. 异或的规律

- 任何数和本身异或则为`0`

- 任何数和 0 异或是`本身`

3. 很多人只是记得异或的性质和规律，但是缺乏对其本质的理解，导致很难想到这种解法(我本人也没想到)

4. bit 运算

#### 代码

```js
/*
 * @lc app=leetcode id=136 lang=javascript
 *
 * [136] Single Number
 *
 * https://leetcode.com/problems/single-number/description/
 *
 * algorithms
 * Easy (59.13%)
 * Total Accepted:    429.3K
 * Total Submissions: 724.1K
 * Testcase Example:  '[2,2,1]'
 *
 * Given a non-empty array of integers, every element appears twice except for
 * one. Find that single one.
 *
 * Note:
 *
 * Your algorithm should have a linear runtime complexity. Could you implement
 * it without using extra memory?
 *
 * Example 1:
 *
 *
 * Input: [2,2,1]
 * Output: 1
 *
 *
 * Example 2:
 *
 *
 * Input: [4,1,2,1,2]
 * Output: 4
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let ret = 0;
  for (let index = 0; index < nums.length; index++) {
    const element = nums[index];
    ret = ret ^ element;
  }
  return ret;
};
```

#### 延伸

有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。

和上面一样，只是这次不是一个数字，而是两个数字。还是按照上面的思路，我们进行一次全员异或操作，
得到的结果就是那两个只出现一次的不同的数字的异或结果。

我们刚才讲了异或的规律中有一个`任何数和本身异或则为0`， 因此我们的思路是能不能将这两个不同的数字分成两组 A 和 B。
分组需要满足两个条件.

1. 两个独特的的数字分成不同组

2. 相同的数字分成相同组

这样每一组的数据进行异或即可得到那两个数字。

问题的关键点是我们怎么进行分组呢？

由于异或的性质是，同一位相同则为 0，不同则为 1. 我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1.

我们随便取一个， 分组的依据就来了， 就是你取的那一位是 0 分成 1 组，那一位是 1 的分成一组。
这样肯定能保证`2. 相同的数字分成相同组`, 不同的数字会被分成不同组么。 很明显当然可以， 因此我们选择是 1，也就是
说`两个独特的的数字`在那一位一定是不同的，因此两个独特元素一定会被分成不同组。

Done！

### [139].word-break

#### 题目描述

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

#### 思路

这道题是给定一个字典和一个句子，判断该句子是否可以由字典里面的单词组出来，一个单词可以用多次。

暴力的方法是无解的，复杂度极其高。 我们考虑其是否可以拆分为小问题来解决。
对于问题`(s, wordDict)` 我们是否可以用(s', wordDict) 来解决。 其中 s' 是 s 的子序列，
当 s'变成寻常(长度为 0)的时候问题就解决了。 我们状态转移方程变成了这道题的难点。

我们可以建立一个数组 dp, dp[i]代表 字符串 s.substring(0, i) 能否由字典里面的单词组成，
值得注意的是，这里我们无法建立 dp[i] 和 dp[i - 1] 的关系，
我们可以建立的是 dp[i - word.length] 和 dp[i] 的关系。

我们用图来感受一下：

没有明白也没有关系，我们分步骤解读一下：

(以下的图左边都代表 s，右边都是 dict，灰色代表没有处理的字符，绿色代表匹配成功，红色代表匹配失败)

上面分步解释了算法的基本过程，下面我们感性认识下这道题，我把它比喻为
你正在`往一个老式手电筒🔦中装电池`

#### 代码

```js
/*
 * @lc app=leetcode id=139 lang=javascript
 *
 * [139] Word Break
 *
 * https://leetcode.com/problems/word-break/description/
 *
 * algorithms
 * Medium (34.45%)
 * Total Accepted:    317.8K
 * Total Submissions: 913.9K
 * Testcase Example:  '"leetcode"\n["leet","code"]'
 *
 * Given a non-empty string s and a dictionary wordDict containing a list of
 * non-empty words, determine if s can be segmented into a space-separated
 * sequence of one or more dictionary words.
 *
 * Note:
 *
 *
 * The same word in the dictionary may be reused multiple times in the
 * segmentation.
 * You may assume the dictionary does not contain duplicate words.
 *
 *
 * Example 1:
 *
 *
 * Input: s = "leetcode", wordDict = ["leet", "code"]
 * Output: true
 * Explanation: Return true because "leetcode" can be segmented as "leet
 * code".
 *
 *
 * Example 2:
 *
 *
 * Input: s = "applepenapple", wordDict = ["apple", "pen"]
 * Output: true
 * Explanation: Return true because "applepenapple" can be segmented as "apple
 * pen apple".
 * Note that you are allowed to reuse a dictionary word.
 *
 *
 * Example 3:
 *
 *
 * Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
 * Output: false
 *
 *
 */
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  const dp = Array(s.length + 1);
  dp[0] = true;
  for (let i = 0; i < s.length + 1; i++) {
    for (let word of wordDict) {
      if (dp[i - word.length] && word.length <= i) {
        if (s.substring(i - word.length, i) === word) {
          dp[i] = true;
        }
      }
    }
  }

  return dp[s.length] || false;
};
```

### [144].binary-tree-preorder-traversal

#### 题目描述

```
Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
Follow up: Recursive solution is trivial, could you do it iteratively?

```

#### 思路

这道题目是前序遍历，这个和之前的`leetcode 94 号问题 - 中序遍历`完全不一回事。

前序遍历是`根左右`的顺序，注意是`根`开始，那么就很简单。直接先将根节点入栈，然后
看有没有右节点，有则入栈，再看有没有左节点，有则入栈。 然后出栈一个元素，重复即可。

> 其他树的非递归遍历课没这么简单

#### 关键点解析

- 二叉树的基本操作(遍历)
  > 不同的遍历算法差异还是蛮大的
- 如果非递归的话利用栈来简化操作

- 如果数据规模不大的话，建议使用递归

- 递归的问题需要注意两点，一个是终止条件，一个如何缩小规模

1. 终止条件，自然是当前这个元素是 null(链表也是一样)

2. 由于二叉树本身就是一个递归结构， 每次处理一个子树其实就是缩小了规模，
   难点在于如何合并结果，这里的合并结果其实就是`mid.concat(left).concat(right)`,
   mid 是一个具体的节点，left 和 right`递归求出即可`

#### 代码

```js
/*
 * @lc app=leetcode id=144 lang=javascript
 *
 * [144] Binary Tree Preorder Traversal
 *
 * https://leetcode.com/problems/binary-tree-preorder-traversal/description/
 *
 * algorithms
 * Medium (50.36%)
 * Total Accepted:    314K
 * Total Submissions: 621.2K
 * Testcase Example:  '[1,null,2,3]'
 *
 * Given a binary tree, return the preorder traversal of its nodes' values.
 *
 * Example:
 *
 *
 * Input: [1,null,2,3]
 * ⁠  1
 * ⁠   \
 * ⁠    2
 * ⁠   /
 * ⁠  3
 *
 * Output: [1,2,3]
 *
 *
 * Follow up: Recursive solution is trivial, could you do it iteratively?
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
  // 1. Recursive solution

  // if (!root) return [];

  // return [root.val].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));

  // 2. iterative solutuon

  if (!root) return [];
  const ret = [];
  const stack = [root];
  let t = stack.pop();

  while (t) {
    ret.push(t.val);
    if (t.right) {
      stack.push(t.right);
    }
    if (t.left) {
      stack.push(t.left);
    }
    t = stack.pop();
  }

  return ret;
};
```

### [145].binary-tree-postorder-traversal

#### 题目描述

```
Given a binary tree, return the postorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3


return [3,2,1].

Note: Recursive solution is trivial, could you do it iteratively?

```

#### 思路

相比于前序遍历，后续遍历思维上难度要大些，前序遍历是通过一个 stack，首先压入父亲结点，然后弹出父亲结点，并输出它的 value，之后压人其右儿子，左儿子即可。

然而后序遍历结点的访问顺序是：左儿子 -> 右儿子 -> 自己。那么一个结点需要两种情况下才能够输出：
第一，它已经是叶子结点；
第二，它不是叶子结点，但是它的儿子已经输出过。

那么基于此我们只需要记录一下当前输出的结点即可。对于一个新的结点，如果它不是叶子结点，儿子也没有访问，那么就需要将它的右儿子，左儿子压入。
如果它满足输出条件，则输出它，并记录下当前输出结点。输出在 stack 为空时结束。

#### 关键点解析

- 二叉树的基本操作(遍历)
  > 不同的遍历算法差异还是蛮大的
- 如果非递归的话利用栈来简化操作

- 如果数据规模不大的话，建议使用递归

- 递归的问题需要注意两点，一个是终止条件，一个如何缩小规模

1. 终止条件，自然是当前这个元素是 null(链表也是一样)

2. 由于二叉树本身就是一个递归结构， 每次处理一个子树其实就是缩小了规模，
   难点在于如何合并结果，这里的合并结果其实就是`left.concat(right).concat(mid)`,
   mid 是一个具体的节点，left 和 right`递归求出即可`

#### 代码

```js
/*
 * @lc app=leetcode id=145 lang=javascript
 *
 * [145] Binary Tree Postorder Traversal
 *
 * https://leetcode.com/problems/binary-tree-postorder-traversal/description/
 *
 * algorithms
 * Hard (47.06%)
 * Total Accepted:    242.6K
 * Total Submissions: 512.8K
 * Testcase Example:  '[1,null,2,3]'
 *
 * Given a binary tree, return the postorder traversal of its nodes' values.
 *
 * Example:
 *
 *
 * Input: [1,null,2,3]
 * ⁠  1
 * ⁠   \
 * ⁠    2
 * ⁠   /
 * ⁠  3
 *
 * Output: [3,2,1]
 *
 *
 * Follow up: Recursive solution is trivial, could you do it iteratively?
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
  // 1. Recursive solution

  // if (!root) return [];

  // return postorderTraversal(root.left).concat(postorderTraversal(root.right)).concat(root.val);

  // 2. iterative solutuon

  if (!root) return [];
  const ret = [];
  const stack = [root];
  let p = root; // 标识元素，用来判断节点是否应该出栈

  while (stack.length > 0) {
    const top = stack[stack.length - 1];
    if (
      top.left === p ||
      top.right === p || // 子节点已经遍历过了
      (top.left === null && top.right === null) // 叶子元素
    ) {
      p = stack.pop();
      ret.push(p.val);
    } else {
      if (top.right) {
        stack.push(top.right);
      }
      if (top.left) {
        stack.push(top.left);
      }
    }
  }

  return ret;
};
```

### [146].lru-cache

#### 题目描述

```
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

```

#### 思路

由于是保留是最近使用的 N 条数据，这就和队列的特性很符合， 先进入队列的，先出队列。

因此思路就是用一个队列来记录目前缓存的所有 key， 每次 push 都进行判断，如果
超出最大容量限制则进行清除缓存的操作， 具体清除谁就按照刚才说的队列方式进行处理，同时对 key 进行入队操作。

get 的时候，如果缓存中有，则调整队列(具体操作为删除指定元素和入队两个操作)。 缓存中没有则返回-1

#### 关键点解析

- 队列简化操作

- 队列的操作是这道题的灵魂， 很容易少考虑情况

#### 代码

```js
/*
 * @lc app=leetcode id=146 lang=javascript
 *
 * [146] LRU Cache
 *
 * https://leetcode.com/problems/lru-cache/description/
 *
 * algorithms
 * Hard (24.17%)
 * Total Accepted:    272.8K
 * Total Submissions: 1.1M
 * Testcase Example:  '["LRUCache","put","put","get","put","get","put","get","get","get"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]'
 *
 *
 * Design and implement a data structure for Least Recently Used (LRU) cache.
 * It should support the following operations: get and put.
 *
 *
 *
 * get(key) - Get the value (will always be positive) of the key if the key
 * exists in the cache, otherwise return -1.
 * put(key, value) - Set or insert the value if the key is not already present.
 * When the cache reached its capacity, it should invalidate the least recently
 * used item before inserting a new item.
 *
 *
 * Follow up:
 * Could you do both operations in O(1) time complexity?
 *
 * Example:
 *
 * LRUCache cache = new LRUCache( 2 );
 *
 * cache.put(1, 1);
 * cache.put(2, 2);
 * cache.get(1);       // returns 1
 * cache.put(3, 3);    // evicts key 2
 * cache.get(2);       // returns -1 (not found)
 * cache.put(4, 4);    // evicts key 1
 * cache.get(1);       // returns -1 (not found)
 * cache.get(3);       // returns 3
 * cache.get(4);       // returns 4
 *
 *
 */
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.cache = {};
  this.capacity = capacity;
  this.size = 0;
  this.queue = [];
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit !== undefined) {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
    return hit;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  const hit = this.cache[key];

  // update cache
  this.cache[key] = value;

  if (!hit) {
    // invalid cache and resize size;
    if (this.size === this.capacity) {
      // invalid cache
      const key = this.queue.shift();
      this.cache[key] = undefined;
    } else {
      this.size = this.size + 1;
    }
    this.queue.push(key);
  } else {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
  }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [150].evaluate-reverse-polish-notation

#### 题目描述

```
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
```

#### 思路

逆波兰表达式又叫做后缀表达式。在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之间，这种表示法也称为`中缀表示`。

波兰逻辑学家 J.Lukasiewicz 于 1929 年提出了另一种表示表达式的方法，按此方法，每一运算符都置于其运算对象之后，故称为`后缀表示`。

> 逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)_(c+d)转换为 ab+cd+_

#### 关键点

1. 栈的基本用法

2. 如果你用的是 JS 的话，需要注意/ 和 其他很多语言是不一样的

3. 如果你用的是 JS 的话，需要先将字符串转化为数字。否则有很多意想不到的结果

4. 操作符的顺序应该是 先出栈的是第二位，后出栈的是第一位。 这在不符合交换律的操作中很重要， 比如减法和除法。

#### 代码

```js
/*
 * @lc app=leetcode id=150 lang=javascript
 *
 * [150] Evaluate Reverse Polish Notation
 *
 * https://leetcode.com/problems/evaluate-reverse-polish-notation/description/
 *
 * algorithms
 * Medium (31.43%)
 * Total Accepted:    153.3K
 * Total Submissions: 485.8K
 * Testcase Example:  '["2","1","+","3","*"]'
 *
 * Evaluate the value of an arithmetic expression in Reverse Polish Notation.
 *
 * Valid operators are +, -, *, /. Each operand may be an integer or another
 * expression.
 *
 * Note:
 *
 *
 * Division between two integers should truncate toward zero.
 * The given RPN expression is always valid. That means the expression would
 * always evaluate to a result and there won't be any divide by zero
 * operation.
 *
 *
 * Example 1:
 *
 *
 * Input: ["2", "1", "+", "3", "*"]
 * Output: 9
 * Explanation: ((2 + 1) * 3) = 9
 *
 *
 * Example 2:
 *
 *
 * Input: ["4", "13", "5", "/", "+"]
 * Output: 6
 * Explanation: (4 + (13 / 5)) = 6
 *
 *
 * Example 3:
 *
 *
 * Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
 * Output: 22
 * Explanation:
 * ⁠ ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
 * = ((10 * (6 / (12 * -11))) + 17) + 5
 * = ((10 * (6 / -132)) + 17) + 5
 * = ((10 * 0) + 17) + 5
 * = (0 + 17) + 5
 * = 17 + 5
 * = 22
 *
 *
 */
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  // 这种算法的前提是 tokens是有效的，
  // 当然这由算法来保证
  const stack = [];

  for (let index = 0; index < tokens.length; index++) {
    const token = tokens[index];
    // 对于运算数， 我们直接入栈
    if (!Number.isNaN(Number(token))) {
      stack.push(token);
    } else {
      // 遇到操作符，我们直接大胆运算，不用考虑算术优先级
      // 然后将运算结果入栈即可

      // 当然如果题目进一步扩展，允许使用单目等其他运算符，我们的算法需要做微小的调整
      const a = Number(stack.pop());
      const b = Number(stack.pop());
      if (token === '*') {
        stack.push(b * a);
      } else if (token === '/') {
        stack.push((b / a) >> 0);
      } else if (token === '+') {
        stack.push(b + a);
      } else if (token === '-') {
        stack.push(b - a);
      }
    }
  }

  return stack.pop();
};
```

#### 扩展

逆波兰表达式中只改变运算符的顺序，并不会改变操作数的相对顺序，这是一个重要的性质。
另外逆波兰表达式完全不关心操作符的优先级，这在中缀表达式中是做不到的，这很有趣，感兴趣的可以私下查找资料研究下为什么会这样。

### [152].maximum-product-subarray

#### 题目描述

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```

#### 思路

> 这道题目的通过率非常低

这道题目要我们求解连续的 n 个数中乘积最大的积是多少。这里提到了连续，笔者首先
想到的就是滑动窗口，但是这里比较特殊，我们不能仅仅维护一个最大值，因此最小值(比如-20)乘以一个比较小的数(比如-10)
可能就会很大。 因此这种思路并不方便。

首先来暴力求解,我们使用两层循环来枚举所有可能项，这种解法的时间复杂度是 O(n^2), 代码如下：

```js
var maxProduct = function(nums) {
  let max = nums[0];
  let temp = null;
  for (let i = 0; i < nums.length; i++) {
    temp = nums[i];
    max = Math.max(temp, max);
    for (let j = i + 1; j < nums.length; j++) {
      temp *= nums[j];
      max = Math.max(temp, max);
    }
  }

  return max;
};
```

因此我们需要同时记录乘积最大值和乘积最小值，然后比较元素和这两个的乘积，去不断更新最大值。

这种思路的解法由于只需要遍历一次，其时间复杂度是 O(n)，代码见下方代码区。

#### 关键点

- 同时记录乘积最大值和乘积最小值

#### 代码

```js
/*
 * @lc app=leetcode id=152 lang=javascript
 *
 * [152] Maximum Product Subarray
 *
 * https://leetcode.com/problems/maximum-product-subarray/description/
 *
 * algorithms
 * Medium (28.61%)
 * Total Accepted:    202.8K
 * Total Submissions: 700K
 * Testcase Example:  '[2,3,-2,4]'
 *
 * Given an integer array nums, find the contiguous subarray within an array
 * (containing at least one number) which has the largest product.
 *
 * Example 1:
 *
 *
 * Input: [2,3,-2,4]
 * Output: 6
 * Explanation: [2,3] has the largest product 6.
 *
 *
 * Example 2:
 *
 *
 * Input: [-2,0,-1]
 * Output: 0
 * Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  let max = nums[0];
  let min = nums[0];
  let res = nums[0];

  for (let i = 1; i < nums.length; i++) {
    let tmp = min;
    min = Math.min(nums[i], Math.min(max * nums[i], min * nums[i])); // 取最小
    max = Math.max(nums[i], Math.max(max * nums[i], tmp * nums[i])); /// 取最大
    res = Math.max(res, max);
  }
  return res;
};
```

### [155].min-stack

#### 题目描述

```
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.

```

#### 思路

符合直觉的方法是，每次对栈进行修改操作(push 和 pop)的时候更新最小值。 然后 getMin 只需要返回我们计算的最小值即可，
top 也是直接返回栈顶元素即可。 这种做法每次修改栈都需要更新最小值，因此时间复杂度是 O(n).

是否有更高效的算法呢？答案是有的。

我们每次入栈的时候，保存的不再是真正的数字，而是它与当前最小值的差(当前元素没有入栈的时候的最小值)。
这样我们 pop 和 top 的时候拿到栈顶元素再加上**上一个**最小值即可。
另外我们在 push 和 pop 的时候去更新 min，这样 getMin 的时候就简单了，直接返回 min。

> 注意上面加粗的“上一个”，不是“当前的最小值”

经过上面的分析，问题的关键转化为“如果求的上一个最小值”，解决这个的关键点在于利用 min。

pop 或者 top 的时候：

- 如果栈顶元素小于 0，说明栈顶是当前最小的元素，它出栈会对 min 造成影响，我们需要去更新 min。
  上一个最小的是“min - 栈顶元素”,我们需要将上一个最小值更新为当前的最小值

> 因为栈顶元素入栈的时候的通过 `栈顶元素 = 真实值 - 上一个最小的元素` 得到的，
> 而真实值 = min， 因此可以得出`上一个最小的元素 = 真实值 -栈顶元素`

- 如果栈顶元素大于 0，说明它对最小值`没有影响`，上一个最小值就是上上个最小值。

#### 关键点

- 最小栈存储的不应该是真实值，而是真实值和 min 的差值
- top 的时候涉及到对数据的还原，这里千万注意是**上一个**最小值

#### 代码

```js
/*
 * @lc app=leetcode id=155 lang=javascript
 *
 * [155] Min Stack
 */
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = [];
  this.min = Number.MAX_VALUE;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  // update 'min'
  const min = this.min;
  if (x < this.min) {
    this.min = x;
  }
  return this.stack.push(x - min);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const item = this.stack.pop();
  const min = this.min;

  if (item < 0) {
    this.min = min - item;
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const item = this.stack[this.stack.length - 1];
  const min = this.min;

  if (item < 0) {
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.min;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### [167].two-sum-ii-input-array-is-sorted

#### 题目描述

这是 leetcode 头号题目`two sum`的第二个版本，难度简单。

```
Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

Note:

Your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.
Example:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.

```

#### 思路

由于题目没有对空间复杂度有求，用一个 hashmap 存储已经访问过的数字即可。

假如题目空间复杂度有要求，由于数组是有序的，只需要双指针即可。一个 left 指针，一个 right 指针，
如果 left + right 值 大于 target 则 right 左移动， 否则 left 右移，代码比较简单， 不贴了。

> 如果数组无序，需要先排序(从这里也可以看出排序是多么重要的操作)

#### 关键点解析

无

#### 代码

```js
/*
 * @lc app=leetcode id=167 lang=javascript
 *
 * [167] Two Sum II - Input array is sorted
 *
 * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
 *
 * algorithms
 * Easy (49.46%)
 * Total Accepted:    221.8K
 * Total Submissions: 447K
 * Testcase Example:  '[2,7,11,15]\n9'
 *
 * Given an array of integers that is already sorted in ascending order, find
 * two numbers such that they add up to a specific target number.
 *
 * The function twoSum should return indices of the two numbers such that they
 * add up to the target, where index1 must be less than index2.
 *
 * Note:
 *
 *
 * Your returned answers (both index1 and index2) are not zero-based.
 * You may assume that each input would have exactly one solution and you may
 * not use the same element twice.
 *
 *
 * Example:
 *
 *
 * Input: numbers = [2,7,11,15], target = 9
 * Output: [1,2]
 * Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
 *
 */
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
  const visited = {}; // 记录出现的数字， 空间复杂度N

  for (let index = 0; index < numbers.length; index++) {
    const element = numbers[index];
    if (visited[target - element] !== void 0) {
      return [visited[target - element], index + 1];
    }
    visited[element] = index + 1;
  }
  return [];
};
```

### [169].majority-element

#### 题目描述

```
Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

You may assume that the array is non-empty and the majority element always exist in the array.

Example 1:

Input: [3,2,3]
Output: 3
Example 2:

Input: [2,2,1,1,1,2,2]
Output: 2

```

#### 思路

符合直觉的做法是利用额外的空间去记录每个元素出现的次数，并用一个单独的变量记录当前出现次数最多的元素。

但是这种做法空间复杂度较高，有没有可能进行优化呢？ 答案就是用"投票算法"。

投票算法的原理是通过不断消除不同元素直到没有不同元素，剩下的元素就是我们要找的元素。

#### 关键点解析

- 投票算法

#### 代码

```js
/*
 * @lc app=leetcode id=169 lang=javascript
 *
 * [169] Majority Element
 *
 * https://leetcode.com/problems/majority-element/description/
 *
 * algorithms
 * Easy (51.62%)
 * Total Accepted:    365.6K
 * Total Submissions: 702.5K
 * Testcase Example:  '[3,2,3]'
 *
 * Given an array of size n, find the majority element. The majority element is
 * the element that appears more than ⌊ n/2 ⌋ times.
 *
 * You may assume that the array is non-empty and the majority element always
 * exist in the array.
 *
 * Example 1:
 *
 *
 * Input: [3,2,3]
 * Output: 3
 *
 * Example 2:
 *
 *
 * Input: [2,2,1,1,1,2,2]
 * Output: 2
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  let count = 1;
  let majority = nums[0];
  for (let i = 1; i < nums.length; i++) {
    if (count === 0) {
      majority = nums[i];
    }
    if (nums[i] === majority) {
      count++;
    } else {
      count--;
    }
  }
  return majority;
};
```

### [172].factorial-trailing-zeroes

#### 题目描述

```
Given an integer n, return the number of trailing zeroes in n!.

Example 1:

Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.
Example 2:

Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.
Note: Your solution should be in logarithmic time complexity.

```

#### 思路

我们需要求解这 n 个数字相乘的结果末尾有多少个 0，由于题目要求 log 的复杂度，因此暴力求解是不行的。

通过观察，我们发现如果想要结果末尾是 0，必须是分解质因数之后，2 和 5 相乘才行，同时因数分解之后发现 5 的个数远小于 2，
因此我们只需要求解这 n 数字分解质因数之后一共有多少个 5 即可.

如图如果 n 为 30，那么结果应该是图中红色 5 的个数，即 7。

我们的结果并不是直接 f(n) = n / 5, 比如 n 为 30， 25 中是有两个 5 的。
类似，n 为 150，会有 7 个这样的数字，通过观察我们发现规律`f(n) = n/5 + n/5^2 + n/5^3 + n/5^4 + n/5^5+..`

如果可以发现上面的规律，用递归还是循环实现这个算式就看你的了。

#### 关键点解析

- 数论

#### 代码

```js
/*
 * @lc app=leetcode id=172 lang=javascript
 *
 * [172] Factorial Trailing Zeroes
 */
/**
 * @param {number} n
 * @return {number}
 */
var trailingZeroes = function(n) {
  // tag: 数论

  // if (n === 0) return n;

  // 递归： f(n) = n / 5 + f(n / 5)
  // return Math.floor(n / 5)  + trailingZeroes(Math.floor(n / 5));
  let count = 0;
  while (n >= 5) {
    count += Math.floor(n / 5);
    n = Math.floor(n / 5);
  }
  return count;
};
```

### [190].reverse-bits

#### 题目描述

```
Reverse bits of a given 32 bits unsigned integer.



Example 1:

Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
Example 2:

Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.


Note:

Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.

```

#### 思路

这道题是给定一个 32 位的无符号整型，让你按位翻转， 第一位变成最后一位， 第二位变成倒数第二位。。。

那么思路就是`双指针`

> 这个指针可以加引号

- n 从高位开始逐步左， res 从低位(0)开始逐步右移
- 逐步判断，如果该位是 1，就 res + 1 , 如果是该位是 0， 就 res + 0
- 32 位全部遍历完，则遍历结束

#### 关键点解析

1. 可以用任何数字和 1 进行位运算的结果都取决于该数字最后一位的特性简化操作和提高性能

eg :

- n & 1 === 1, 说明 n 的最后一位是 1
- n & 1 === 0, 说明 n 的最后一位是 0

2. 对于 JS，ES 规范在之前很多版本都是没有无符号整形的， 转化为无符号，可以用一个 trick`n >>> 0`

3. 双"指针" 模型

4. bit 运算

#### 代码

```js
/*
 * @lc app=leetcode id=190 lang=javascript
 *
 * [190] Reverse Bits
 *
 * https://leetcode.com/problems/reverse-bits/description/
 *
 * algorithms
 * Easy (30.30%)
 * Total Accepted:    173.7K
 * Total Submissions: 568.2K
 * Testcase Example:  '00000010100101000001111010011100'
 *
 * Reverse bits of a given 32 bits unsigned integer.
 *
 *
 *
 * Example 1:
 *
 *
 * Input: 00000010100101000001111010011100
 * Output: 00111001011110000010100101000000
 * Explanation: The input binary string 00000010100101000001111010011100
 * represents the unsigned integer 43261596, so return 964176192 which its
 * binary representation is 00111001011110000010100101000000.
 *
 *
 * Example 2:
 *
 *
 * Input: 11111111111111111111111111111101
 * Output: 10111111111111111111111111111111
 * Explanation: The input binary string 11111111111111111111111111111101
 * represents the unsigned integer 4294967293, so return 3221225471 which its
 * binary representation is 10101111110010110010011101101001.
 *
 *
 *
 * Note:
 *
 *
 * Note that in some languages such as Java, there is no unsigned integer type.
 * In this case, both input and output will be given as signed integer type and
 * should not affect your implementation, as the internal binary representation
 * of the integer is the same whether it is signed or unsigned.
 * In Java, the compiler represents the signed integers using 2's complement
 * notation. Therefore, in Example 2 above the input represents the signed
 * integer -3 and the output represents the signed integer -1073741825.
 *
 *
 *
 *
 * Follow up:
 *
 * If this function is called many times, how would you optimize it?
 *
 */
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
  let res = 0;
  for (let i = 0; i < 32; i++) {
    res = (res << 1) + (n & 1);
    n = n >>> 1;
  }

  return res >>> 0;
};
```

### [191].number-of-1-bits

#### 题目描述

```
Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight).



Example 1:

Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
Example 2:

Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
Example 3:

Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.


Note:

Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3 above the input represents the signed integer -3.

```

#### 思路

这个题目的大意是： 给定一个无符号的整数， 返回其用二进制表式的时候的 1 的个数。

这里用一个 trick， 可以轻松求出。 就是`n & (n - 1)` 可以`消除` n 最后的一个 1 的原理。

> 为什么能消除最后一个 1， 其实也比较简单，大家自己想一下

这样我们可以不断进行`n = n & (n - 1)`直到 n === 0 ， 说明没有一个 1 了。
这个时候`我们消除了多少1变成一个1都没有了， 就说明n有多少个1了`。

#### 关键点解析

1. `n & (n - 1)` 可以`消除` n 最后的一个 1 的原理 简化操作

2. bit 运算

#### 代码

```js
/*
 * @lc app=leetcode id=191 lang=javascript
 *
 * [191] Number of 1 Bits
 *
 * https://leetcode.com/problems/number-of-1-bits/description/
 *
 * algorithms
 * Easy (42.10%)
 * Total Accepted:    247.4K
 * Total Submissions: 583.3K
 * Testcase Example:  '00000000000000000000000000001011'
 *
 * Write a function that takes an unsigned integer and return the number of '1'
 * bits it has (also known as the Hamming weight).
 *
 *
 *
 * Example 1:
 *
 *
 * Input: 00000000000000000000000000001011
 * Output: 3
 * Explanation: The input binary string 00000000000000000000000000001011 has a
 * total of three '1' bits.
 *
 *
 * Example 2:
 *
 *
 * Input: 00000000000000000000000010000000
 * Output: 1
 * Explanation: The input binary string 00000000000000000000000010000000 has a
 * total of one '1' bit.
 *
 *
 * Example 3:
 *
 *
 * Input: 11111111111111111111111111111101
 * Output: 31
 * Explanation: The input binary string 11111111111111111111111111111101 has a
 * total of thirty one '1' bits.
 *
 *
 *
 * Note:
 *
 *
 * Note that in some languages such as Java, there is no unsigned integer type.
 * In this case, the input will be given as signed integer type and should not
 * affect your implementation, as the internal binary representation of the
 * integer is the same whether it is signed or unsigned.
 * In Java, the compiler represents the signed integers using 2's complement
 * notation. Therefore, in Example 3 above the input represents the signed
 * integer -3.
 *
 *
 *
 *
 * Follow up:
 *
 * If this function is called many times, how would you optimize it?
 *
 */
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  let count = 0;
  while (n !== 0) {
    n = n & (n - 1);
    count++;
  }

  return count;
};
```

#### 扩展

可以使用位操作来达到目的。例如 8 位的整数 21:

### [198].house-robber

#### 题目描述

```
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.

```

#### 思路

这是一道非常典型且简单的动态规划问题，但是在这里我希望通过这个例子，
让大家对动态规划问题有一点认识。

为什么别人的动态规划可以那么写，为什么没有用 dp 数组就搞定了。
比如别人的爬楼梯问题怎么就用 fibnacci 搞定了？为什么？在这里我们就来看下。

思路还是和其他简单的动态规划问题一样，我们本质上在解决`对于第[i] 个房子，我们抢还是不抢。`的问题。

判断的标准就是总价值哪个更大， 那么对于抢的话`就是当前的房子可以抢的价值 + dp[i - 2]`

> i - 1 不能抢，否则会触发警铃

如果不抢的话，就是`dp[i - 1]`.

> 这里的 dp 其实就是`子问题`.

状态转移方程也不难写`dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);`.

上述过程用图来表示的话，是这样的：

我们仔细观察的话，其实我们只需要保证前一个 dp[i - 1] 和 dp[i - 2] 两个变量就好了，
比如我们计算到 i = 6 的时候，即需要计算 dp[6]的时候， 我们需要 dp[5], dp[4]，但是我们
不需要 dp[3], dp[2] ...

因此代码可以简化为：

```js
let a = 0;
let b = 0;

for (let i = 0; i < nums.length; i++) {
  const temp = b;
  b = Math.max(a + nums[i], b);
  a = temp;
}

return b;
```

如上的代码，我们可以将复杂度进行优化，从 O(n)降低到 O(1),
类似的优化在 DP 问题中不在少数。

> 动态规划问题是递归问题查表，避免重复计算，从而节省时间。
> 如果我们对问题加以分析和抽象，有可能对空间上进一步优化

#### 关键点解析

#### 代码

```js
/*
 * @lc app=leetcode id=198 lang=javascript
 *
 * [198] House Robber
 *
 * https://leetcode.com/problems/house-robber/description/
 *
 * algorithms
 * Easy (40.80%)
 * Total Accepted:    312.1K
 * Total Submissions: 762.4K
 * Testcase Example:  '[1,2,3,1]'
 *
 * You are a professional robber planning to rob houses along a street. Each
 * house has a certain amount of money stashed, the only constraint stopping
 * you from robbing each of them is that adjacent houses have security system
 * connected and it will automatically contact the police if two adjacent
 * houses were broken into on the same night.
 *
 * Given a list of non-negative integers representing the amount of money of
 * each house, determine the maximum amount of money you can rob tonight
 * without alerting the police.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,1]
 * Output: 4
 * Explanation: Rob house 1 (money = 1) and then rob house 3 (money =
 * 3).
 * Total amount you can rob = 1 + 3 = 4.
 *
 * Example 2:
 *
 *
 * Input: [2,7,9,3,1]
 * Output: 12
 * Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house
 * 5 (money = 1).
 * Total amount you can rob = 2 + 9 + 1 = 12.
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  // Tag: DP
  const dp = [];
  dp[0] = 0;
  dp[1] = 0;

  for (let i = 2; i < nums.length + 2; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);
  }

  return dp[nums.length + 1];
};
```

### [199].binary-tree-right-side-view

#### 题目描述

```
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

Example:

Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

#### 思路

> 这道题和 leetcode 102 号问题《102.binary-tree-level-order-traversal》很像

这道题可以借助`队列`实现，首先把 root 入队，然后入队一个特殊元素 Null(来表示每层的结束)。

然后就是 while(queue.length), 每次处理一个节点，都将其子节点(在这里是 left 和 right)放到队列中。

然后不断的出队， 如果出队的是 null，则表式这一层已经结束了，我们就继续 push 一个 null。

#### 关键点解析

- 队列

- 队列中用 Null(一个特殊元素)来划分每层

- 树的基本操作- 遍历 - 层次遍历(BFS)

- 二叉树的右视图可以看作是层次遍历每次只取每一层的最右边的元素

#### 代码

```js
/*
 * @lc app=leetcode id=199 lang=javascript
 *
 * [199] Binary Tree Right Side View
 *
 * https://leetcode.com/problems/binary-tree-right-side-view/description/
 *
 * algorithms
 * Medium (46.74%)
 * Total Accepted:    156.1K
 * Total Submissions: 332.3K
 * Testcase Example:  '[1,2,3,null,5,null,4]'
 *
 * Given a binary tree, imagine yourself standing on the right side of it,
 * return the values of the nodes you can see ordered from top to bottom.
 *
 * Example:
 *
 *
 * Input: [1,2,3,null,5,null,4]
 * Output: [1, 3, 4]
 * Explanation:
 *
 * ⁠  1            <---
 * ⁠/   \
 * 2     3         <---
 * ⁠\     \
 * ⁠ 5     4       <---
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
  if (!root) return [];

  const ret = [];
  const queue = [root, null];

  let levelNodes = [];

  while (queue.length > 0) {
    const node = queue.shift();
    if (node !== null) {
      levelNodes.push(node.val);
      if (node.right) {
        queue.push(node.right);
      }
      if (node.left) {
        queue.push(node.left);
      }
    } else {
      // 一层遍历已经结束
      ret.push(levelNodes[0]);
      if (queue.length > 0) {
        queue.push(null);
      }
      levelNodes = [];
    }
  }

  return ret;
};
```

#### 扩展

假如题目变成求二叉树的左视图呢？

很简单我们只需要取 queue 的最后一个元素即可。 或者存的时候反着来也行

> 其实我们没必要存储 levelNodes，而是只存储每一层最右的元素，这样空间复杂度就不是 n 了， 就是 logn 了。

### [112].path-sum

```js
/*
 * @lc app=leetcode id=112 lang=javascript
 *
 * [112] Path Sum
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
  // check
  if (root === null) return false;
  //  if it's leaf:
  if (root.left === null && root.right === null) {
    return root.val === sum;
  }
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
```

### [137].single-number-ii

```js
/*
 * @lc app=leetcode id=137 lang=javascript
 *
 * [137] Single Number II
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  // [1,1,1,2]
  let res = 0;
  // 前提是nums中数字都不大于2^31
  for (let i = 0; i < 32; i++) {
    let cnt = 0;
    let bit = 1 << i;
    for (let j = 0; j < nums.length; j++) {
      if (nums[j] & bit) cnt++;
    }
    if (cnt % 3 != 0) res = res | bit;
  }
  return res;
};
```

### [141].linked-list-cycle

```js
/*
 * @lc app=leetcode id=141 lang=javascript
 *
 * [141] Linked List Cycle
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### [160].intersection-of-two-linked-lists

```js
/*
 * @lc app=leetcode id=160 lang=javascript
 *
 * [160] Intersection of Two Linked Lists
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // 网上精妙的解法没看懂
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

### [189].rotate-array

```js
/*
 * @lc app=leetcode id=189 lang=javascript
 *
 * [189] Rotate Array
 *
 * https://leetcode.com/problems/rotate-array/description/
 *
 * algorithms
 * Easy (29.07%)
 * Total Accepted:    287.3K
 * Total Submissions: 966.9K
 * Testcase Example:  '[1,2,3,4,5,6,7]\n3'
 *
 * Given an array, rotate the array to the right by k steps, where k is
 * non-negative.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,4,5,6,7] and k = 3
 * Output: [5,6,7,1,2,3,4]
 * Explanation:
 * rotate 1 steps to the right: [7,1,2,3,4,5,6]
 * rotate 2 steps to the right: [6,7,1,2,3,4,5]
 * rotate 3 steps to the right: [5,6,7,1,2,3,4]
 *
 *
 * Example 2:
 *
 *
 * Input: [-1,-100,3,99] and k = 2
 * Output: [3,99,-1,-100]
 * Explanation:
 * rotate 1 steps to the right: [99,-1,-100,3]
 * rotate 2 steps to the right: [3,99,-1,-100]
 *
 *
 * Note:
 *
 *
 * Try to come up as many solutions as you can, there are at least 3 different
 * ways to solve this problem.
 * Could you do it in-place with O(1) extra space?
 *
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  // 就像扩容一样操作
  k = k % nums.length;
  const n = nums.length;

  for (let i = nums.length - 1; i >= 0; i--) {
    nums[i + k] = nums[i];
  }

  for (let i = 0; i < k; i++) {
    nums[i] = nums[n + i];
  }
  nums.length = n;
};
```

### [134].Gas Station(加油站)

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/gas-station/
- tag：Array

#### 题目描述

```
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.
```

#### 参考答案

1.暴力求解，时间复杂度 O(n^2)

> 我们可以一次遍历 gas，对于每一个 gas 我们依次遍历后面的 gas，计算 remian，如果 remain 一旦小于 0，就说明不行，我们继续遍历下一个

```js
// bad 时间复杂度0(n^2)
let remain = 0;
const n = gas.length;
for (let i = 0; i < gas.length; i++) {
  remain += gas[i];
  remain -= cost[i];
  let count = 0;
  while (remain >= 0) {
    count++;
    if (coun === n) return i;
    remain += gas[getIndex(i + count, n)];
    remain -= cost[getIndex(i + count, n)];
  }
  remain = 0;
}
retirn - 1;
```

2.比较巧妙的方法，时间复杂度是 O(n)

> 这个方法基于两点：
>
> 2-1:如果站点 i 到达站点 j 走不通,那么从 i 到 j 之间的站点(比如 k)出发一定都走不通。前提 i(以及 i 到 k 之间)不会拖累总体(即 remain >= 0)。
>
> 2-2:如果 cost 总和大于 gas 总和，无论如何也无法走到终点，这个比较好理解。因此假如存在一个站点出发能够到达终点，其实就说明 cost 总和一定小于等于 gas 总和

```js
const n = gas.length;
let total = 0;
let remain = 0;
let start = 0;

for (let i = 0; i < n; i++) {
  total += gas[i];
  total -= cost[i];

  remain += gas[i];
  remain -= cost[i];

  // 如果remain < 0,说明从start到i走不通
  // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
  // 因此我们重新从i + 1开始作为start
  if (remain < 0) {
    remain = 0;
    start = i + 1;
  }
}
// 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

// 如果costu总和大于gas总和，无论如何也无法走到终点
return total >= 0 ? start : -1;
```

### [105].从前序与中序遍历序列构造二叉树

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

* tag：`Tree` `Array`

#### 题目描述

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

#### 参考答案

递归构造二叉树，时间复杂度 O(n)

> 关键在于前序遍历和中序遍历的特性:

- 前序遍历：根节点是首元素
- 中序遍历：根节点左侧的值是其左子树，右侧的值是其右子树
  > 因此，我们首先要得到从前序序列中获取根节点，然后遍历中序序列，找到根节点的位置，以此直到其左子树和右子树的范围。当我们得到其左子树之后，事情就开始重复了，我们仍然需要根据前序序列中找到这颗左子树的根节点，然后再根据中序序列得到这颗左子树根节点的左右子树，右子树同理。因此实际上就是个回溯。

### [134].gas-station

```js
/*
 * @lc app=leetcode id=134 lang=javascript
 *
 * [134] Gas Station
 */

function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad 时间复杂度O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution 时间复杂度O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // 如果remain < 0, 说明从start到i走不通
    // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
    // 因此我们重新从i + 1开始作为start
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

  // 如果cost总和大于gas总和，无论如何也无法走到终点
  return total >= 0 ? start : -1;
};
```

### [130].surrounded-regions

#### 题目描述

```
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
Explanation:

Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.

```

#### 思路

我们需要将所有被 X 包围的 O 变成 X，并且题目明确说了边缘的所有 O 都是不可以变成 X 的。

其实我们观察会发现，我们除了边缘的 O 以及和边缘 O 连通的 O 是不需要变成 X 的，其他都要变成 X。

经过上面的思考，问题转化为连通区域问题。 这里我们需要标记一下`边缘的O以及和边缘O连通的O`。
我们当然可以用额外的空间去存，但是对于这道题目而言，我们完全可以 mutate。这样就空间复杂度会好一点。

整个过程如图所示：

> 我将`边缘的O以及和边缘O连通的O` 标记为了 "A"

#### 关键点解析

- 二维数组 DFS 解题模板
- 转化问题为`连通区域问题`
- 直接 mutate 原数组，节省空间

#### 代码

```js
/*
 * @lc app=leetcode id=130 lang=javascript
 *
 * [130] Surrounded Regions
 */
// 将O以及周边的O转化为A
function mark(board, i, j, rows, cols) {
  if (i < 0 || i > rows - 1 || j < 0 || j > cols - 1 || board[i][j] !== 'O') return;

  board[i][j] = 'A';
  mark(board, i + 1, j, rows, cols);
  mark(board, i - 1, j, rows, cols);
  mark(board, i, j + 1, rows, cols);
  mark(board, i, j - 1, rows, cols);
}
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
  const rows = board.length;
  if (rows === 0) return [];
  const cols = board[0].length;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (i === 0 || i == rows - 1 || j === 0 || j === cols - 1) {
        mark(board, i, j, rows, cols);
      }
    }
  }

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (board[i][j] === 'O') {
        board[i][j] = 'X';
      } else if (board[i][j] === 'A') {
        board[i][j] = 'O';
      }
    }
  }

  return board;
};
```

#### 相关题目

- [200.number-of-islands](./200.number-of-islands.md)

> 解题模板是一样的

### [131].palindrome-partitioning

#### 题目描述

```
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]

```

#### 思路

这是一道求解所有可能性的题目， 这时候可以考虑使用回溯法。 回溯法解题的模板我们已经在很多题目中用过了，
这里就不多说了。大家可以结合其他几道题目加深一下理解。

#### 关键点解析

- 回溯法

#### 代码

```js
/*
 * @lc app=leetcode id=131 lang=javascript
 *
 * [131] Palindrome Partitioning
 */

function isPalindrom(s) {
  let left = 0;
  let right = s.length - 1;

  while (left < right && s[left] === s[right]) {
    left++;
    right--;
  }

  return left >= right;
}
function backtrack(s, list, tempList, start) {
  const sliced = s.slice(start);

  if (isPalindrom(sliced) && tempList.join('').length === s.length) list.push([...tempList]);

  for (let i = 0; i < sliced.length; i++) {
    const sub = sliced.slice(0, i + 1);
    if (isPalindrom(sub)) {
      tempList.push(sub);
    } else {
      continue;
    }
    backtrack(s, list, tempList, start + i + 1);
    tempList.pop();
  }
}
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
  // "aab"
  // ["aa", "b"]
  // ["a", "a", "b"]
  const list = [];
  backtrack(s, list, [], 0);
  return list;
};
```
