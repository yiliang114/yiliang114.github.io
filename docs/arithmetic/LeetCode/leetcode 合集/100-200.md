---
layout: CustomPages
title: LeetCode-合集 4
date: 2020-09-04
aside: false
draft: true
---

### 101.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  return helper(root, root);
};

function helper(l, r) {
  if (l == null && r == null) return true;
  if (l == null || r == null) return false;
  return l.val == r.val && helper(l.left, r.right) && helper(l.right, r.left);
}
```

### 102.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  let ans = [];
  helper(root, ans, 0);
  return ans;
};

function helper(node, ans, i) {
  if (node == null) return;
  if (i == ans.length) ans.push([]);
  ans[i].push(node.val);

  helper(node.left, ans, i + 1);
  helper(node.right, ans, i + 1);
}
```

### 104.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### 105.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  return helper(0, 0, inorder.length - 1, preorder, inorder);
};

function helper(preStart, inStart, inEnd, preorder, inorder) {
  if (preStart > preorder.length - 1 || inStart > inEnd) {
    return null;
  }
  let root = new TreeNode(preorder[preStart]);
  let inIndex = 0;
  for (let i = inStart; i <= inEnd; i++) {
    if (inorder[i] == root.val) {
      inIndex = i;
    }
  }
  root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
  root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
  return root;
}
```

### 108.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
  if (nums.length == 0) return null;
  return helper(nums, 0, nums.length - 1);
};

function helper(nums, lo, hi) {
  if (lo > hi) {
    return null;
  }
  let mid = parseInt((lo + hi + 1) / 2);
  let node = new TreeNode(nums[mid]);

  node.left = helper(nums, lo, mid - 1);
  node.right = helper(nums, mid + 1, hi);
  return node;
}

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

console.log(sortedArrayToBST([-10, -3, 0, 5, 9]));
```

### 116.

```js
/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
  if (root == null || root.left == null) return;
  connectNodes(root.left, root.right);
};

function connectNodes(node1, node2) {
  node1.next = node2;
  if (node1.left != null) {
    connectNodes(node1.left, node1.right);
    connectNodes(node1.right, node2.left);
    connectNodes(node2.left, node2.right);
  }
}
```

### 118.

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
  if (numRows == 0) return [];
  if (numRows == 1) return [[1]];
  if (numRows == 2) return [[1], [1, 1]];
  let ans = [[1], [1, 1]];
  for (let len = 2; len < numRows; len++) {
    let row = [1];
    for (let i = 1; i < ans[len - 1].length; i++) {
      row.push(ans[len - 1][i - 1] + ans[len - 1][i]);
    }
    row.push(1);
    ans.push(row);
  }
  return ans;
};

console.log(generate(5));
```

### 121.

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let maxProfit = 0;
  let minPrice = Number.MAX_SAFE_INTEGER;
  for (let i = 0; i < prices.length; i++) {
    minPrice = Math.min(minPrice, prices[i]);
    maxProfit = Math.max(maxProfit, prices[i] - minPrice);
  }
  return maxProfit;
};
```

### 122.

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let maxProfit = 0;
  let curMin = prices[0];
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > curMin) {
      maxProfit += prices[i] - curMin;
    }
    curMin = prices[i];
  }
  return maxProfit;
};
```

### 124.

```js
let maxValue;

var maxPathSum = function(root) {
  maxValue = Number.MIN_SAFE_INTEGER;
  find(root);
  return maxValue;
};

function find(node) {
  if (node == null) return 0;
  let left = Math.max(0, find(node.left)); // 获取左侧最大和
  let right = Math.max(0, find(node.right)); // 获取右侧最大和
  maxValue = Math.max(maxValue, left + right + node.val); // 获得最大值
  return Math.max(left, right) + node.val; // 返回最大值
}
```

### 125.

```js
var isPalindrome = function(s) {
  s = s.replace(/[^\w]/g, '');
  if (s.length == 0) return true;

  var start = 0,
    end = s.length - 1;
  while (start < end) {
    if (!s[start] || !s[end]) {
      return false;
    }
    if (s[start].toLowerCase() != s[end].toLowerCase()) {
      return false;
    }
    start++;
    end--;
  }
  return true;
};

isPalindrome('A man, a plan, a canal: Panama');
isPalindrome('A man, a plan, a canal: Panama');
```

### 127.-DFS-TLE

```js
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
  MinCount = Number.MAX_VALUE;
  dfs(beginWord, endWord, wordList, 1);
  return MinCount == Number.MAX_VALUE ? 0 : MinCount;
};

let MinCount = Number.MAX_VALUE;

function dfs(beginWord, endWord, wordList, count) {
  if (beginWord == endWord) {
    MinCount = Math.min(MinCount, count);
  }
  let max = Number.MAX_VALUE;
  for (let i = 0; i < wordList.length; i++) {
    if (changeOneChar(beginWord, wordList[i])) {
      let clone = wordList.slice();
      clone.splice(i, 1);
      dfs(wordList[i], endWord, clone, count + 1);
    }
  }
}

function changeOneChar(a, b) {
  let count = 0;
  for (let i = 0; i < a.length; i++) if (a[i] != b[i]) count++;
  return count == 1;
}

console.log(ladderLength('hit', 'cog', ['hot', 'cog', 'dot', 'dog', 'hit', 'lot', 'log']));
```

### 127.

```js
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
  if (!wordList.includes(endWord)) return 0;
  let set = new Set(),
    visited = new Set(),
    len = 1;

  set.add(beginWord);
  visited.add(beginWord);
  while (set.size != 0) {
    let tmp = new Set([...set]);

    for (let w of tmp) {
      visited.add(w);
      set.delete(w);

      if (changeOneChar(w, endWord)) return len + 1;

      for (let word of wordList) {
        if (changeOneChar(w, word) && !visited.has(word)) {
          set.add(word);
        }
      }
    }
    len++;
  }
  return 0;
};

function changeOneChar(a, b) {
  let count = 0;
  for (let i = 0; i < a.length; i++) if (a[i] != b[i]) count++;
  return count == 1;
}

let beginWord = 'hit',
  endWord = 'cog',
  wordList = ['hot', 'dot', 'dog', 'lot', 'log', 'cog'];

ladderLength(beginWord, endWord, wordList);
```

### 128.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  if (nums.length == 0) return 0;
  let count = 0,
    max = 1;
  for (let i = 0, len = nums.length; i < len; i++) {
    let min = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[min]) min = j;
    }
    swap(nums, i, min);
    if (i != 0 && nums[i] == nums[i - 1] + 1) {
      count++;
      max = Math.max(max, count);
    } else if (nums[i] == nums[i - 1]) {
    } else {
      count = 1;
    }
  }
  return max;
};

function swap(nums, a, b) {
  let x = nums[a];
  nums[a] = nums[b];
  nums[b] = x;
}

console.log(longestConsecutive([1, 2, 0, 1]));
```

### 130.

```js
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
  let i, j;
  let row = board.length;
  if (!row) return;
  let col = board[0].length;

  for (i = 0; i < row; i++) {
    check(board, i, 0, row, col);
    if (col > 1) check(board, i, col - 1, row, col);
  }

  for (j = 1; j < col - 1; j++) {
    check(board, 0, j, row, col);
    if (row > 1) check(board, row - 1, j, row, col);
  }

  for (i = 0; i < row; i++) {
    for (j = 0; j < col; j++) {
      if (board[i][j] == 'O') board[i][j] = 'X';
    }
  }
  for (i = 0; i < row; i++) {
    for (j = 0; j < col; j++) {
      if (board[i][j] == '1') board[i][j] = 'O';
    }
  }
};

function check(board, i, j, row, col) {
  if (board[i][j] == 'O') {
    board[i][j] = '1';
    if (i > 1) check(board, i - 1, j, row, col);
    if (j > 1) check(board, i, j - 1, row, col);
    if (i + 1 < row) check(board, i + 1, j, row, col);
    if (j + 1 < col) check(board, i, j + 1, row, col);
  }
}
```

### 131.

```js
let ans = [];
let curList = [];

var partition = function(s) {
  ans = [];
  curList = [];
  backTrack(s, 0);
  return ans;
};

function backTrack(s, l) {
  if (curList.length > 0 && l >= s.length) {
    let r = curList.slice();
    ans.push(r);
  }
  for (let i = l; i < s.length; i++) {
    if (isPalindrome(s, l, i)) {
      if (l == i) curList.push(s[i]);
      else curList.push(s.slice(l, i + 1));
      backTrack(s, i + 1);
      curList.pop();
    }
  }
}

function isPalindrome(s, l, r) {
  if (l == r) return true;
  while (l < r) {
    if (s[l] != s[r]) return false;
    l++;
    r--;
  }
  return true;
}
```

### 136.

```js
var singleNumber = function(nums) {
  var a = 0;
  for (let val of nums) a ^= val;
  return a;
};
```

### 136-Single-Number

```js
// 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

// 说明：

// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

// 示例 1:

// 输入: [2,2,1]
// 输出: 1
// 示例 2:

// 输入: [4,1,2,1,2]
// 输出: 4

// 思路
// 标签：位运算
// 本题根据题意，线性时间复杂度 O(n)O(n)，很容易想到使用 Hash 映射来进行计算，遍历一次后结束得到结果，但是在空间复杂度上会达到 O(n)O(n)，需要使用较多的额外空间
// 既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：

//  1. 一个数和 0 做 XOR 运算等于本身：a^0 = a
//  2. 一个数和其本身做 XOR 运算等于 0：a^a = 0
//  3. XOR 运算满足交换律和结合律：a^b^a = (a^a)^b = 0^b = b

// 故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字
// 时间复杂度：O(n)，空间复杂度：O(1)

// reduce 性能性对好些
// 84 ms	40.2 MB
var singleNumber = function(nums = []) {
  return nums.reduce((ret, n) => ret ^ n, 0);
};

// 88 ms	40.8 MB
var singleNumber1 = function(nums) {
  let ans = 0;
  for (const num of nums) {
    ans ^= num;
  }
  return ans;
};

export default function SingleNumber2(nums = []) {
  for (let i = 0; i < nums.length; i++) {
    if (set.has(nums[i])) {
      set.delete(nums[i]);
    } else {
      set.add(nums[i]);
    }
  }

  const item = Array.from(set)[0];
  set.clear();

  return item;
}

console.log(singleNumber([1, 2, 2]) == 1);
console.log(singleNumber([1, 2, 1]) == 2);
```

### 138.

```js
/**
 * Definition for singly-linked list with a random pointer.
 * function RandomListNode(label) {
 *     this.label = label;
 *     this.next = this.random = null;
 * }
 */

/**
 * @param {RandomListNode} head
 * @return {RandomListNode}
 */
var copyRandomList = function(head) {
  let iter = head,
    next;

  while (iter != null) {
    next = iter.next;

    let copy = new RandomListNode(iter.label);
    iter.next = copy;
    copy.next = next;
    iter = next;
  }

  iter = head;
  while (iter != null) {
    if (iter.random != null) {
      iter.next.random = iter.random.next;
    }
    iter = iter.next.next;
  }

  iter = head;
  let pseudoHead = new RandomListNode(0);
  let copy,
    copyIter = pseudoHead;

  while (iter != null) {
    next = iter.next.next;

    copy = iter.next;
    copyIter.next = copy;
    copyIter = copy;

    iter.next = next;
    iter = next;
  }
  return pseudoHead.next;
};
```

### 139.

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  let dp = new Array(s.length + 1);
  dp.fill(false);
  dp[0] = true;

  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.includes(s.slice(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[s.length];
};
```

### 140.

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  if (canStringBeSegmented(s, wordDict)) {
    return getAllPossibleSegments(s, wordDict, {});
  } else {
    return [];
  }
};
// DFS
function getAllPossibleSegments(s, dict, map) {
  if (s in map) return map[s];
  const result = [];
  if (dict.includes(s)) result.push(s);
  for (let i = 1; i < s.length; i++) {
    const left = s.substring(0, i);
    const right = s.substring(i);
    if (dict.includes(left) && containsSuffix(dict, right)) {
      for (let segment of getAllPossibleSegments(right, dict, map)) {
        result.push(`${left} ${segment}`);
      }
    }
  }
  map[s] = result;
  return result;
}

function containsSuffix(dict, str) {
  for (let i = 0; i < str.length; i++) {
    if (dict.includes(str.substring(i))) return true;
  }
  return false;
}
// 使用 dp 判断能否
function canStringBeSegmented(inputStr, inputDict) {
  const memTable = Array(inputStr.length + 1).fill(false);
  memTable[0] = true;

  for (let i = 1; i <= inputStr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (memTable[j] && inputDict.includes(inputStr.substring(j, i))) {
        memTable[i] = true;
        break;
      }
    }
  }
  return memTable[inputStr.length];
}
```

### 141.

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

### 146.

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.map = {};
  this.set = new Set();
  this.capacity = capacity;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.map[key]) {
    // key already exist, we need to delete the key and add to end
    this.set.delete(key);
    this.set.add(key);
    return this.map[key];
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.map[key]) {
    // remove this key and add back in set, update in hashmap
    this.set.delete(key);
  } else {
    if (this.set.size >= this.capacity) {
      var it = this.set.values();
      var oldKey = it.next().value;
      delete this.map[oldKey];
      this.set.delete(oldKey);
    }
  }
  this.set.add(key);
  this.map[key] = value;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = Object.create(LRUCache).createNew(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### 148.

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
  if (head == null || head.next == null) return head;

  let prev = null,
    slow = head,
    fast = head;
  while (fast != null && fase.next != null) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }

  prev.next = null;

  let l1 = sortList(head);
  let l2 = sortList(slow);

  return merge(l1, l2);
};

function merge(l1, l2) {
  let l = new ListNode(0),
    p = l;

  while (l1 != null && l2 != null) {
    if (l1.val < l2.val) {
      p.next = l1;
      l1 = l1.next;
    } else {
      p.next = l2;
      l2 = l2.next;
    }
    p = p.next;
  }

  if (l1 != null) p.next = l1;

  if (l2 != null) p.next = l2;

  return l.next;
}
```

### 149.

```js
/**
 * Definition for a point.
 * function Point(x, y) {
 *     this.x = x;
 *     this.y = y;
 * }
 */
/**
 * @param {Point[]} points
 * @return {number}
 */
var maxPoints = function(points) {
  if (points.length == 0) return 0;
  let maxLength = 1;
  for (let i = 0; i < points.length; i++) {
    let degs = {};
    let samplePoint = 1;
    for (let j = 0; j < points.length; j++) {
      if (i == j) continue;
      if (points[i].x == points[j].x && points[i].y == points[j].y) {
        samplePoint++;
        continue;
      }
      let deg;
      if (points[j].y == points[i].y) deg = Number.MAX_SAFE_INTEGER;
      else deg = (points[j].x - points[i].x) / (points[j].y - points[i].y);

      if (degs[deg]) degs[deg]++;
      else degs[deg] = 1;
    }
    maxLength = Math.max(maxLength, samplePoint);
    for (let k in degs) {
      maxLength = Math.max(maxLength, degs[k] + samplePoint);
    }
  }
  return maxLength;
};

function Point(x, y) {
  this.x = x;
  this.y = y;
}

const p1 = new Point(0, 0);
const p2 = new Point(1, 1);
const p3 = new Point(0, 0);

console.log(maxPoints([p1, p2, p3]));
```

### 150.

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  let index = 0,
    stack = [];

  while (index < tokens.length) {
    if (tokens[index] == '+' || tokens[index] == '-' || tokens[index] == '*' || tokens[index] == '/') {
      if (index < 2) return new Error();
      let num1 = stack.pop();
      let num2 = stack.pop();
      if (tokens[index] == '+') stack.push(num2 + num1);
      else if (tokens[index] == '-') stack.push(num2 - num1);
      else if (tokens[index] == '*') stack.push(num2 * num1);
      else if (tokens[index] == '/') stack.push(parseInt(num2 / num1));
    } else {
      stack.push(parseInt(tokens[index]));
    }
    index++;
  }
  return stack[0];
};

console.log(evalRPN(['2', '1', '+', '3', '*']));
```

### 152.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  if (nums.length == 0) return 0;
  let ans = nums[0],
    max = nums[0],
    min = nums[0];
  for (let i = 1, len = nums.length; i < len; i++) {
    if (nums[i] < 0) {
      let tmp = max;
      max = min;
      min = tmp;
    }
    max = Math.max(nums[i], max * nums[i]);
    min = Math.min(nums[i], min * nums[i]);

    ans = Math.max(max, ans);
  }
  return ans;
};

console.log(maxProduct([-2, 3, -4]));
```

### 155.

```js
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = [];
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.stack.push(x);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  this.stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  let min = this.stack[0];
  for (let val of this.stack) {
    if (val < min) min = val;
  }
  return min;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = Object.create(MinStack).createNew()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### 160.

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  if (headA == null || headB == null) return null;

  let ALen = getLength(headA),
    BLen = getLength(headB),
    lenDiff = Math.abs(ALen - BLen);

  for (let i = 0; i < lenDiff; i++) {
    if (ALen > BLen) headA = headA.next;
    else headB = headB.next;
  }
  let curLen = Math.min(ALen, BLen);
  for (let i = 0; i < curLen; i++) {
    if (headA == headB) {
      return headA;
    }
    headA = headA.next;
    headB = headB.next;
  }
  return null;
};

function getLength(head) {
  let len = 0;
  while (head) {
    len++;
    head = head.next;
  }
  return len;
}
```

### 162.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] > nums[i + 1]) return i;
  }
  return nums.length - 1;
};
```

### 166.

```js
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
  if (numerator == 0) return '0';

  const res = new Array();

  if ((numerator > 0) ^ (denominator > 0)) {
    res.push('-');
  }
  let num = Math.abs(numerator),
    den = Math.abs(denominator);
  res.push(parseInt(num / den));
  if (num % den == 0) return res.join('');

  res.push('.');
  num %= den;

  let map = new Map();
  while (true) {
    let curNum = parseInt((num * 10) / den);
    num = (num * 10) % den;
    if (map.has(curNum)) {
      const index = map.get(curNum);
      res.splice(index, 0, '(');
      res.push(')');
      break;
    } else if (num == 0) {
      res.push(curNum);
      break;
    } else {
      res.push(curNum);
      map.set(curNum, res.length - 1);
    }
  }
  return res.join('');
};
```

### 168.

```js
/**
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
*/
/**
 * @param {number} n
 * @return {string}
 */

// String.fromCharCode(97)
// 'A'.charCodeAt()

// 100 ms	37.6 MB
var convertToTitle = function(n) {
  var result = '',
    cur;

  //97 is the ASCII code for lower case 'a'. If you want uppercase letters, replace 97 with 65 (uppercase 'A').

  while (n > 0) {
    cur = (n - 1) % 26;
    result = String.fromCharCode(65 + cur) + result;
    n = Math.floor((n - 1) / 26);
  }

  return result;
};

// 84 ms	37.7 MB
var convertToTitle1 = function(n) {
  const map = [
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
  ];
  let result = '',
    val;
  while (n > 0) {
    n--;
    val = n % 26;
    result = map[val] + result;
    n = parseInt(n / 26);
    // console.log('n', n);
  }
  return result;
};

let result;

console.log((result = convertToTitle1(1)), result === 'A');
console.log((result = convertToTitle1(28)), result === 'AB');
console.log((result = convertToTitle1(52)), result === 'AZ');
console.log((result = convertToTitle1(701)), result === 'ZY');
```

### 169.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  const mid = parseInt((nums.length + 1) / 2),
    len = nums.length;
  for (let i = 0; i < mid; i++) {
    let min = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[min]) min = j;
    }
    swap(nums, i, min);
  }
  return nums[mid - 1];
};

function swap(arr, a, b) {
  let x = arr[a];
  arr[a] = arr[b];
  arr[b] = x;
}
```

### 171.

```js
/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
  var ans = 0;
  var len = s.length;
  for (let i = 0; i < len; i++) {
    ans += (s[i].charCodeAt(0) - 64) * Math.pow(26, len - 1 - i);
  }
  return ans;
};
```

### 172.

```js
/**
 * @param {number} n
 * @return {number}
 */
// 尾数中的0怎么来的？
// 先考虑，尾数中的0是怎么来的？

// 在1~9的范围内，选两个数字相乘，只有 2*5=10。所以，一对2和5，贡献一个0。
// 不限制范围的话，一对2的倍数和5的倍数，贡献一个0
// 阶乘中，2的倍数肯定比5的倍数多。所以，只需要考虑5的倍数出现了多少次

// 76 ms	39.2 MB
var trailingZeroes = function(n) {
  let count = 0;
  while (n != 0) {
    let tmp = parseInt(n / 5);
    count += tmp;
    n = tmp;
  }
  return count;
};

var trailingZeroes = function(n) {
  var divider = 5,
    reminder = 0;

  while (divider <= n) {
    reminder += Math.floor(n / divider);
    divider = divider * 5;
  }

  return reminder;
};

// 5! 一个 0 5! = 5! * 1
// 10! = 5! * 2
// 15! = 5! * 3
// 20! = 5! * 4

// 80 ms	39.2 MB
var trailingZeroes = function(n) {
  if (n < 5) {
    return 0;
  } else {
    let k = Math.floor(n / 5);
    return k + trailingZeroes(k);
  }
};
```

### 179.

```js
/**
 * @param {number[]} nums
 * @return {string}
 */
var largestNumber = function(nums) {
  nums = nums.map(item => {
    return item + '';
  });

  nums.sort((a, b) => {
    const sort1 = a + b;
    const sort2 = b + a;
    return parseInt(sort2) - parseInt(sort1);
  });

  if (nums[0] == '0') return '0';
  return nums.join('');
};

console.log(largestNumber([5, 10, 7]));
```

### 189.

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  for (let i = 0; i <= k; i++) {
    nums.unshift(nums.pop());
  }
};
```

### 190.

```js
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
  var t = n.toString(2).split('');
  while (t.length < 32) t.unshift('0');
  return parseInt(t.reverse().join(''), 2);
};

reverseBits(1);
```

### 191.

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  let numArr = n.toString(2).split('');
  let count = 0;
  for (let val of numArr) {
    if (val == '1') {
      count++;
    }
  }
  return count;
};
```

### 198.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let a = 0,
    b = 0;
  for (let i = 0; i < nums.length; i++) {
    if (i % 2 == 0) {
      a = Math.max(b, a + nums[i]);
    } else {
      b = Math.max(a, b + nums[i]);
    }
  }
  return Math.max(a, b);
};
```

### 200.

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  if (grid.length == 0) return 0;
  let count = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] == 1) {
        count++;
        helper(i, j, grid);
      }
    }
  }
  return count;
};

function helper(i, j, grid) {
  grid[i][j] = 'OK';
  if (i > 0 && grid[i - 1][j] == 1)
    // 上
    helper(i - 1, j, grid);
  if (i < grid.length - 1 && grid[i + 1][j] == 1)
    // 下
    helper(i + 1, j, grid);
  if (j > 0 && grid[i][j - 1] == 1)
    // 左
    helper(i, j - 1, grid);
  if (i < grid[0].length + 1 && grid[i][j + 1] == 1)
    // 右
    helper(i, j + 1, grid);
}

numIslands([
  ['1', '0', '1', '1', '1'],
  ['1', '0', '1', '0', '1'],
  ['1', '1', '1', '0', '1'],
]);
```

### 104.二叉树的最大深度

```js
/*
 * @lc app=leetcode.cn id=104 lang=javascript
 *
 * [104] 二叉树的最大深度
 *
 * 给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，
返回它的最大深度 3 。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root === null) return 0;
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

function Tree(arr) {
  const head = new TreeNode(null);
  if (arr.length === 0) return head;
  let cur = head;

  return cur;
}
```

```js
function TreeNode(val: any) {
  this.val = val;
  this.left = this.right = null;
}

export default function MaxDepth(root: TreeNode, count: number = 0): number {
  if (!root) return 0;

  const first = MaxDepth(root.left, count);
  const sec = MaxDepth(root.right, count);

  return Math.max(first, sec) + 1;
}

const t = new TreeNode(1);
const t2 = new TreeNode(2);
const t3 = new TreeNode(3);

//           t1
//         /   \
//       t2     null
//      / \
//   null  t3

t.left = t2.right = t3;

// expect(MaxDepth(t)).to.equal(2);
```

### 110.平衡二叉树

```js
//
// Given a binary tree, determine if it is height-balanced.
//
// For this problem, a height-balanced binary tree is defined as a binary tree
// in which the depth of the two subtrees of every node never differ by more
// than 1.
//
// Time Complexity: O(n)
// Space Complexity: O(n+1)

export function TreeNode(val: any) {
  this.val = val;
  this.right = null;
  this.left = this.right;
}

const isBalancedAux = node => {
  if (!node) return 0;
  const left = isBalancedAux(node.left);
  const right = isBalancedAux(node.right);
  if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1;
  return Math.max(left, right) + 1;
};

/**
 * @param {TreeNode} root
 * @return {boolean}
 */
export default function isBalanced(root) {
  if (!root) return true;
  return isBalancedAux(root) !== -1;
}
```

```js
/*
 * @lc app=leetcode.cn id=110 lang=javascript
 *
 * [110] 平衡二叉树
 * 本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。


 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let result = true; // 默认是平衡二叉树，只要找出左右子树高度大于 1 的就不是
var isBalanced = function(root) {
  if (root === null) return true;
  depthMax(root);
  return result;
};

var depthMax = function(root) {
  if (root) {
    let l = depthMax(root.left),
      r = depthMax(root.right);
    if (Math.abs(l - r) > 1) result = false;
    // +1 表示当前层的深度， 需要累加
    return Math.max(l, r) + 1;
  }
  return 0;
};

// function TreeNode(val) {
//   this.val = val;
//   this.left = this.right = null;
// }

// function Tree(arr) {
//   const t = new TreeNode(null)
//   if (arr.length === 0) return t
//   let index = 0, cur = t
//   cur.val = arr[index++]
//   while (index < arr.length) {
//     cur.left = new TreeNode(index++)
//     cur.right = new TreeNode(index++)
//     cur = cur.left
//   }
//   return t
// }

// const t = new TreeNode(null)
// console.log(isBalanced(t))

// TODO:
// ✘ Wrong Answer
// ✘ 195 / 227 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: false
// ✘ expected_answer: true
// ✘ stdout:

// ✘ Wrong Answer
// ✘ 196 / 227 cases passed(N / A)
// ✘ testcase: '[1]'
// ✘ answer: false
// ✘ expected_answer: true
// ✘ stdout:
```

### 111-Minimum-Depth-of-Binary-Tree

```js
/**
 * https://leetcode.com/problems/minimum-depth-of-binary-tree/description/
 * Difficulty:Easy
 *
 * Given a binary tree, find its minimum depth.
 * The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
 *
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
  if (!root) return 0;

  var left = minDepth(root.left);
  var right = minDepth(root.right);

  return left == 0 || right == 0 ? left + right + 1 : Math.min(left, right) + 1;
};
```

```js
const minDepthAux = (root, depth) => {
  if (!root) return Infinity;
  if (!root.left && !root.right) {
    return depth + 1;
  }
  const left = minDepthAux(root.left, depth + 1);
  const right = minDepthAux(root.right, depth + 1);
  return Math.min(left, right);
};

/**
 * @param {TreeNode} root
 * @return {number}
 */
export default function minDepth(root) {
  if (!root) return 0;
  return minDepthAux(root, 0);
}
```

### 112.path-sum 路径总和

```js
/*
 * @lc app=leetcode.cn id=112 lang=javascript
 *
 * [112] 路径总和
 * 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
  if (root === null) return false;
  if (root.left === null && root.right === null && root.val === sum) return true;
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.right);
};

// Input data:
// [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1]
// 22

// Actual
// ✔ runtime: 112 ms
// ✘ answer: false
// ✔ stdout: ''

// Expected
// ✔ runtime: 40 ms
// ✔ answer: true
// ✔ stdout: ''
```

```js
var hasPathSum = function(root, sum) {
  // check
  if (root === null) return false;
  //  if it's leaf:
  if (root.left === null && root.right === null) {
    return root.val === sum;
  }
  return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
```

### 121-Best-Time-to-Buy-and-Sell-Stock

```js
/**
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
 * Difficulty:Easy
 *
 * Say you have an array for which the ith element is the price of a given stock on day i.
 * If you were only permitted to complete at most one transaction
 * (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
 *
 * Example 1:
 * Input: [7, 1, 5, 3, 6, 4]
 * Output: 5
 * max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
 *
 * Example 2:
 * Input: [7, 6, 4, 3, 1]
 * Output: 0
 * In this case, no transaction is done, i.e. max profit = 0.
 */

/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  if (!prices.length) return 0;
  var min = prices[0];
  var max = 0;
  for (var i = 1; i < prices.length; i++) {
    var tmp = prices[i];
    if (tmp < min) min = tmp;
    else if (tmp - min > max) max = tmp - min;
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
```

### 121.买卖股票的最佳时机

```js
/*
 * @lc app=leetcode.cn id=121 lang=javascript
 *
 * [121] 买卖股票的最佳时机
 */
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  // 直接认为 prices length 大于 2
  let max = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    for (let j = i + 1; j < prices.length; j++) {
      const target = prices[j] - prices[i];
      if (target > max) {
        max = target;
      }
    }
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
console.log(maxProfit([1, 4, 2]));
```

### 134.Gas Station(加油站)

```
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.
```

#### 参考答案

1.暴力求解，时间复杂度 O(n^2)

> 我们可以一次遍历 gas，对于每一个 gas 我们依次遍历后面的 gas，计算 remian，如果 remain 一旦小于 0，就说明不行，我们继续遍历下一个

```js
// bad 时间复杂度0(n^2)
let remain = 0;
const n = gas.length;
for (let i = 0; i < gas.length; i++) {
  remain += gas[i];
  remain -= cost[i];
  let count = 0;
  while (remain >= 0) {
    count++;
    if (coun === n) return i;
    remain += gas[getIndex(i + count, n)];
    remain -= cost[getIndex(i + count, n)];
  }
  remain = 0;
}
retirn - 1;
```

2.比较巧妙的方法，时间复杂度是 O(n)

> 这个方法基于两点：
>
> 2-1:如果站点 i 到达站点 j 走不通,那么从 i 到 j 之间的站点(比如 k)出发一定都走不通。前提 i(以及 i 到 k 之间)不会拖累总体(即 remain >= 0)。
>
> 2-2:如果 cost 总和大于 gas 总和，无论如何也无法走到终点，这个比较好理解。因此假如存在一个站点出发能够到达终点，其实就说明 cost 总和一定小于等于 gas 总和

```js
const n = gas.length;
let total = 0;
let remain = 0;
let start = 0;

for (let i = 0; i < n; i++) {
  total += gas[i];
  total -= cost[i];

  remain += gas[i];
  remain -= cost[i];

  // 如果remain < 0,说明从start到i走不通
  // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
  // 因此我们重新从i + 1开始作为start
  if (remain < 0) {
    remain = 0;
    start = i + 1;
  }
}
// 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

// 如果costu总和大于gas总和，无论如何也无法走到终点
return total >= 0 ? start : -1;
```

```js
/*
 * @lc app=leetcode id=134 lang=javascript
 *
 * [134] Gas Station
 */

function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad 时间复杂度O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution 时间复杂度O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // 如果remain < 0, 说明从start到i走不通
    // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
    // 因此我们重新从i + 1开始作为start
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

  // 如果cost总和大于gas总和，无论如何也无法走到终点
  return total >= 0 ? start : -1;
};
```

### 137.single-number-ii

```js
/*
 * @lc app=leetcode id=137 lang=javascript
 *
 * [137] Single Number II
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99
 */
/**
 * @param {number[]} nums
 * @return {number}
 * O(n) 时间复杂度
 */
var singleNumber = function(nums) {
  // [1,1,1,2]
  let res = 0;
  // 前提是nums中数字都不大于2^31
  for (let i = 0; i < 32; i++) {
    let cnt = 0;
    let bit = 1 << i;
    for (let j = 0; j < nums.length; j++) {
      if (nums[j] & bit) cnt++;
    }
    if (cnt % 3 != 0) res = res | bit;
  }
  return res;
};
```

### 138-Copy-List-with-Random-Pointer

```js
/**
 * https://leetcode.com/problems/copy-list-with-random-pointer/description/
 * Difficulty:Medium
 *
 * A linked list is given such that each node contains an additional random pointer
 * which could point to any node in the list or null.
 *
 * Return a deep copy of the list.
 *
 */

// Definition for singly-linked list with a random pointer.
function RandomListNode(label) {
  this.label = label;
  this.next = this.random = null;
}

/**
 * @param {RandomListNode} head
 * @return {RandomListNode}
 */
var copyRandomList = function(head) {
  print(head);

  var p = head;
  // A->B->C
  // A->A'->B->B'->C->C'
  while (p) {
    var copy = new RandomListNode(p.label + "'");
    copy.next = p.next;
    p.next = copy;
    p = copy.next;
  }

  print(head);

  // 构造 A' B' C'.random
  p = head;
  while (p) {
    p.next.random = p.random ? p.random.next : null;
    p = p.next.next;
  }

  print(head);
  // 构造 copy
  var pp = new RandomListNode(0);
  var copy = pp;
  p = head;
  while (p) {
    pp.next = p.next;
    pp = pp.next;

    p.next = pp.next;
    p = p.next;
  }

  print(head);
  print(copy.next);

  return copy.next;
};

var a = new RandomListNode('A');
var b = new RandomListNode('B');
var c = new RandomListNode('C');

a.next = b;
b.next = c;
a.random = c;
b.random = c;
c.random = a;

function print(h) {
  var ls = [];
  var rs = [];
  while (h) {
    ls.push(h.label);
    rs.push(h.random ? h.random.label : 'nil');
    h = h.next;
  }
  console.log(ls.join('->'));
  console.log(rs.join(' '));
  console.log('-------------');
}

console.log(copyRandomList(a));
```

### 139-Word-Break

```js
/**
 * https://leetcode.com/problems/word-break/description/
 * Difficulty:Medium
 *
 * Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.
 *
 * For example, given
 * s = "leetcode",
 * dict = ["leet", "code"].
 * Return true because "leetcode" can be segmented as "leet code".
 */

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var n = s.length;

  var dp = [true];
  for (var i = 1; i < n + 1; i++) {
    for (var j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) > -1) {
        dp[i] = true;
        break;
      } else {
        dp[i] = false;
      }
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(wordBreak('leetcode', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'e']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'leetco']));
```

### 141.linked-list-cycle

```js
/*
 * @lc app=leetcode id=141 lang=javascript
 *
 * [141] Linked List Cycle
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */

//  快慢指针。 如果有环，快指针一定能追上慢指针
var hasCycle1 = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // 快指针一次移动两个
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};

// 哈希表 Set add has 来查询
// 牺牲了空间换时间
var hasCycle = function(head) {
  const set = new Set();
  let curr = head;
  set.add(curr);
  while (curr) {
    if (set.has(curr.next)) {
      return true;
    }
    set.add(curr.next);
    curr = curr.next;
  }
  return false;
};
```

### 145.二叉树的后序遍历

```js
/*
 * @lc app=leetcode.cn id=145 lang=javascript
 *
 * [145] 二叉树的后序遍历
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根
  while (root || stack.length) {
    if (root) {
      stack.push(root);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};

// 递归
// const res = []
// var postorderTraversal = function (root) {
//   if (root === null) return root
//   postorderTraversal(root.left)
//   postorderTraversal(root.right)
//   res.push(root.val)
//   return res
// };
```

### 151-Reverse-Words-in-a-String

```js
/**
 * https://leetcode.com/problems/reverse-words-in-a-string/description/
 * Difficulty:Medium
 *
 * Given an input string, reverse the string word by word.
 *
 * For example,
 * Given s = "the sky is blue",
 * return "blue is sky the".
 */

/**
 * @param {string} str
 * @returns {string}
 */
var reverseWords = function(str) {
  return str
    .split(' ')
    .filter(w => w)
    .reverse()
    .join(' ');
};
```

### 152-Maximum-Product-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-product-subarray/description/
 * Difficulty:Medium
 *
 * Find the contiguous subarray within an array (containing at least one number)
 * which has the largest product.
 *
 * For example, given the array [2,3,-2,4],
 * the contiguous subarray [2,3] has the largest product = 6.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  var a = nums[0];
  var imin = a;
  var imax = a;
  var max = a;

  for (var i = 1; i < nums.length; i++) {
    var t = nums[i];
    if (t < 0) {
      var tmp = imin;
      imin = imax;
      imax = tmp;
    }
    imax = Math.max(t, t * imax);
    imin = Math.min(t, t * imin);
    max = Math.max(max, imax);
  }

  return max;
};

console.log(maxProduct([-1]));
console.log(maxProduct([1]));
console.log(maxProduct([1, 2, 3, -4]));
console.log(maxProduct([2, 3, -2, 4]));
```

### 153.寻找旋转排序数组中的最小值

```js
/*
 * @lc app=leetcode.cn id=153 lang=javascript
 *
 * [153] 寻找旋转排序数组中的最小值
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
  let l = 0,
    h = nums.length - 1;
  while (l < h) {
    let mid = l + Math.floor((h - l) / 2);
    if (nums[mid] <= nums[h]) {
      h = mid;
    } else {
      l = mid + 1;
    }
  }
  return nums[l];
};

// console.log(findMin([3, 4, 5, 1, 2]))
// console.log(findMin([4, 5, 6, 7, 0, 1, 2]))
```

### 155.最小栈

```js
/*
 * @lc app=leetcode.cn id=155 lang=javascript
 *
 * [155] 最小栈
 */
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.value = [];
  this.minIndex = -1;
  return this;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.value.push(x);
  if (this.minIndex === -1 || this.value[this.minIndex] > x) {
    // 栈顶
    this.minIndex = this.value.length - 1;
  }
  return this.value.length;
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const popValue = this.value.pop();
  this.minIndex = 0;
  for (let i = 0; i < this.value.length; i++) {
    if (this.value[i] < this.value[this.minIndex]) {
      this.minIndex = i;
    }
  }
  return popValue;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const length = this.value.length;
  return this.value[length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.value[this.minIndex];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

const minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
console.log(minStack.getMin());
console.log(minStack.pop());
console.log(minStack.top());
console.log(minStack.getMin());
```

### 160.intersection-of-two-linked-lists

```js
/*
 * @lc app=leetcode id=160 lang=javascript
 *
 * [160] Intersection of Two Linked Lists
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // 网上精妙的解法没看懂
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

### 162-Find-Peak-Element

```js
/**
 * https://leetcode.com/problems/find-peak-element/description/
 * Difficulty:Medium
 *
 * A peak element is an element that is greater than its neighbors.
 * Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
 * The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
 * You may imagine that num[-1] = num[n] = -∞.
 * For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.
 */

/**
 *
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  for (var i = 1; i < nums.length; i++) {
    if (nums[i - 1] > nums[i]) return i - 1;
  }
  return nums.length - 1;
};

// ================================================

/**
 * 二分查找
 *
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  if (nums.length <= 1) return 0;
  var l = 0;
  var h = nums.length - 1;
  while (l < h) {
    var mid = Math.floor((l + h) / 2);
    if (nums[mid] > nums[mid + 1]) h = mid;
    else l = mid + 1;
  }
  return l;
};

// ================================================

console.log(findPeakElement([3, 2, 1]), 0);
console.log(findPeakElement([1, 2, 3, 1]), 2);
console.log(findPeakElement([1, 3, 2]), 1);
```

### 164.最大间距

```js
/*
 * @lc app=leetcode.cn id=164 lang=javascript
 *
 * [164] 最大间距
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap1 = function(nums) {
  const map = {};
  // 用空间牺牲来换时间，一次遍历即可
  for (let i = 0; i < nums.length; i++) {
    map[nums[i]] = true;
  }
  // key number 类型默认会排序输出
  const keys = Object.keys(map);
  let max = 0;
  for (let i = 0; i < keys.length - 1; i++) {
    let tmp = keys[i + 1] - keys[i];
    if (max < tmp) {
      max = tmp;
    }
  }
  return max;
};

var maximumGap = function(nums) {
  let maxGap = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    // 每次应该默认基准值为最小，在剩余部分中尝试找出一个更小的数
    let minIndex = i;
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }
    // 每次循环， a[i] 位都将是未选择出的数据中的最小值
    if (minIndex !== i) {
      [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    }
    // console.log('nums: ', nums)
    if (i > 0) {
      const tmp = nums[i] - nums[i - 1];
      maxGap = tmp > maxGap ? tmp : maxGap;
      // console.log('maxGap  ==== ', maxGap)
    }
  }
  // 倒数第二个与倒数第一个值差
  const tmp = nums[nums.length - 1] - nums[nums.length - 2];
  maxGap = tmp > maxGap ? tmp : maxGap;
  return maxGap;
};

console.log(maximumGap([3, 6, 9, 1]));
console.log(maximumGap([10]));
console.log(maximumGap([1, 10000000]));

// console.log(maximumGap1([3, 6, 9, 1]))
// console.log(maximumGap1([10]))
```

### 167-Two-Sum-II-Input-array-is-sorted

```js
/**
 * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
 * Difficulty:Easy
 *
 * Given an array of integers that is already sorted in ascending order,
 * find two numbers such that they add up to a specific target number.
 * The function twoSum should return indices of the two numbers such that they add up to the target,
 * where index1 must be less than index2.
 *
 * Please note that your returned answers (both index1 and index2) are not zero-based.
 * You may assume that each input would have exactly one solution and you may not use the same element twice.
 *
 * Input: numbers=[2, 7, 11, 15], target=9
 * Output: index1=1, index2=2
 *
 */

/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
  for (var i = 0; i < numbers.length - 1; i++) {
    for (var j = i + 1; j < numbers.length; j++) {
      if (numbers[i] + numbers[j] === target) return [i + 1, j + 1];
    }
  }
};

// ==========================================

/**
 * 双指针
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  var lo = 0;
  var hi = nums.length - 1;

  while (nums[lo] + nums[hi] !== target) {
    if (nums[lo] + nums[hi] > target) hi--;
    else lo++;
  }
  return [lo + 1, hi + 1];
};

console.log(twoSum([2, 7, 11, 15], 9));
```

### 169

```js
// 169. Majority Element

// Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

// You may assume that the array is non-empty and the majority element always exist in the array.

// Example 1:

// Input: [3,2,3]
// Output: 3
// Example 2:

// Input: [2,2,1,1,1,2,2]
// Output: 2

// Time: O(n)
// Sace: O(1)

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function majorityElement(nums) {
  if (!nums.length) return 0;
  let majorityIndex = 0;
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    // If current num === majority number, count++
    if (nums[i] === nums[majorityIndex]) {
      count++;
    } else {
      count--;
    }
    // If count === 0, set to current num
    if (count === 0) {
      majorityIndex = i;
      count = 1;
    }
  }

  return nums[majorityIndex];
}
```

### 169.求众数

```js
/*
 * @lc app=leetcode.cn id=169 lang=javascript
 *
 * [169] 求众数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (nums.length === 1) return nums[0];
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > parseInt(nums.length / 2)) {
        return key;
      }
    }
    // console.log('i', i)
  }
};

// console.log(majorityElement([1]))
// console.log(majorityElement([3, 2, 3]))
// console.log(majorityElement([2, 2, 1, 1, 1, 2, 2]))
```

### 171-Excel-Sheet-Column-Number

```js
/**
 * https://leetcode.com/problems/excel-sheet-column-number/description/
 * Difficulty:Easy
 *
 * Given a column title as appear in an Excel sheet, return its corresponding column number.
 * For example:
 * A -> 1
 * B -> 2
 * C -> 3
 * ...
 * Z -> 26
 * AA -> 27
 * AB -> 28
 */

/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
  var num = 0;
  var aCode = 'A'.charCodeAt(0);
  for (var i = 0; i < s.length; i++) {
    var n = 1 + s.charCodeAt(i) - aCode;
    num = num * 26 + n;
  }
  return num;
};

console.log(titleToNumber('AA'));
```

### 189

```js
// 189. Rotate Array

// Given an array, rotate the array to the right by k steps, where k is non-negative.

// Example 1:

// Input: [1,2,3,4,5,6,7] and k = 3
// Output: [5,6,7,1,2,3,4]
// Explanation:
// rotate 1 steps to the right: [7,1,2,3,4,5,6]
// rotate 2 steps to the right: [6,7,1,2,3,4,5]
// rotate 3 steps to the right: [5,6,7,1,2,3,4]
// Example 2:

// Input: [-1,-100,3,99] and k = 2
// Output: [3,99,-1,-100]
// Explanation:
// rotate 1 steps to the right: [99,-1,-100,3]
// rotate 2 steps to the right: [3,99,-1,-100]
// Note:

// Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
// Could you do it in-place with O(1) extra space?

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */

const reverse = (arr, i, j) => {
  while (i < j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    i++;
    j--;
  }
  return arr;
};

export default function rotate(nums, k) {
  k %= nums.length;
  reverse(nums, 0, nums.length - 1);
  reverse(nums, 0, k - 1);
  return reverse(nums, k, nums.length - 1);
}
```

### 189.rotate-array

```js
/*
 * @lc app=leetcode id=189 lang=javascript
 *
 * [189] Rotate Array
 *
 * https://leetcode.com/problems/rotate-array/description/
 *
 * algorithms
 * Easy (29.07%)
 * Total Accepted:    287.3K
 * Total Submissions: 966.9K
 * Testcase Example:  '[1,2,3,4,5,6,7]\n3'
 *
 * Given an array, rotate the array to the right by k steps, where k is
 * non-negative.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,4,5,6,7] and k = 3
 * Output: [5,6,7,1,2,3,4]
 * Explanation:
 * rotate 1 steps to the right: [7,1,2,3,4,5,6]
 * rotate 2 steps to the right: [6,7,1,2,3,4,5]
 * rotate 3 steps to the right: [5,6,7,1,2,3,4]
 *
 *
 * Example 2:
 *
 *
 * Input: [-1,-100,3,99] and k = 2
 * Output: [3,99,-1,-100]
 * Explanation:
 * rotate 1 steps to the right: [99,-1,-100,3]
 * rotate 2 steps to the right: [3,99,-1,-100]
 *
 *
 * Note:
 *
 *
 * Try to come up as many solutions as you can, there are at least 3 different
 * ways to solve this problem.
 * Could you do it in-place with O(1) extra space?
 *
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  // 就像扩容一样操作
  k = k % nums.length;
  const n = nums.length;

  for (let i = nums.length - 1; i >= 0; i--) {
    nums[i + k] = nums[i];
  }

  for (let i = 0; i < k; i++) {
    nums[i] = nums[n + i];
  }
  nums.length = n;
};
```

### 189.旋转数组

```js
/*
 * @lc app=leetcode.cn id=189 lang=javascript
 *
 * [189] 旋转数组
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  if (nums.length === 0) return [];
  k %= nums.length;

  let last = nums[0];
  for (let i = 0; i < nums.length; i += 4) {
    if (i < k) {
      last = nums[i];
      nums[i] = nums[nums.length - k + i];
    } else {
      last = nums[i];
      nums[i] = nums[i - 3];
    }
  }
  nums[0] = start;

  return nums;
};

console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));
console.log(rotate([-1, -100, 3, 99], 2));
```

### 190-Reverse-Bits

```js
/**
 * https://leetcode.com/problems/reverse-bits/#/description
 * Difficulty:Easy
 *
 * Reverse bits of a given 32 bits unsigned integer.
 *
 * For example, given input 43261596 (represented in binary as 00000010100101000001111010011100),
 *
 * return 964176192 (represented in binary as 00111001011110000010100101000000).
 *
 * 00000010100101000001111010011100
 * 00111001011110000010100101000000
 */

/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
  // reverse binary str
  var str = '';
  var i = 32;
  while (i--) {
    str += n % 2;
    n = Math.floor(n / 2);
  }

  return parseInt(str, 2);
};

console.log(reverseBits(43261596) == 964176192);
```

### 191-Number-of-1-Bits

```js
/**
 *
 * https://leetcode.com/problems/number-of-1-bits/description
 * Difficulty:Easy
 *
 * Write a function that takes an unsigned integer and returns the number of ’1' bits it has
 * (also known as the Hamming weight).
 *
 * For example, the 32-bit integer ’11' has binary representation
 * 00000000000000000000000000001011, so the function should return 3.
 */

/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  var weight = 0;

  while (n > 0) {
    weight += n % 2;
    n = Math.floor(n / 2);
  }
  return weight;
};

console.log(hammingWeight(11) == 3);
console.log(hammingWeight(0) == 0);
console.log(hammingWeight(1) == 1);
```

### 191.位-1-的个数

```js
/*
 * @lc app=leetcode.cn id=191 lang=javascript
 *
 * [191] 位1的个数
 */
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight1 = function(n) {
  let count = 0;
  while (n) {
    // 直接判断二进制最低为的数是不是1
    count += n & 1;
    // 每一步都右移一位
    n >>= 1;
  }
  return count;
};

// TODO: JS 超出值范围
console.log(hammingWeight(00000000000000000000000000001011));
console.log(hammingWeight(00000000000000000000000010000000));
console.log(hammingWeight('11111111111111111111111111111101'));
```

### 198-House-Robber

```js
/**
 * https://leetcode.com/problems/house-robber/description/
 * Difficulty:Easy
 *
 * You are a professional robber planning to rob houses along a street.
 * Each house has a certain amount of money stashed,
 * the only constraint stopping you from robbing each of them is that adjacent houses have security system connected
 * and it will automatically contact the police if two adjacent houses were broken into on the same night.

 Given a list of non-negative integers representing the amount of money of each house,
 determine the maximum amount of money you can rob tonight without alerting the police.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  if (!nums.length) return 0;
  var dp = [0, nums[0]];
  var max = nums[0];
  for (var i = 1; i < nums.length; i++) {
    dp[i + 1] = Math.max(dp[i], dp[i - 1] + nums[i]);
    max = Math.max(dp[i + 1], max);
  }
  return max;
};

console.log(rob([5, 2, 3, 5, 8]));
```

### 198

```js
// 198. House Robber

// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint
// stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police
// if two adjacent houses were broken into on the same night.

// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob
// tonight without alerting the police.

// Explaination:
// https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems

const robAux = (nums, i, map) => {
  if (i >= nums.length) return 0;
  if (map.has(i)) return map.get(i);
  const a = robAux(nums, i + 1, map);
  const b = robAux(nums, i + 2, map);
  const curr = Math.max(a, b + nums[i]);
  map.set(i, curr);
  return curr;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function rob(nums) {
  const map = new Map();
  return robAux(nums, 0, map);
}
```

### Medium/102

```js
// 102. Binary Tree Level Order Traversal

// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

// For example:
// Given binary tree [3,9,20,null,null,15,7],

//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its level order traversal as:

// [
//   [3],
//   [9,20],
//   [15,7]
// ]

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
export default function levelOrder(root) {
  if (!root) return [];
  const queue = [];
  queue.push(root);
  const ans = [];
  const depths = new Map();
  depths.set(root, 0);
  let prev;
  let arr = [];
  while (queue.length) {
    const item = queue.shift();
    const depth = depths.get(item);
    if (!prev || (prev && depths.get(prev) !== depths.get(item))) {
      arr = [];
      ans.push(arr);
    }
    arr.push(item.val);
    if (item.left) {
      depths.set(item.left, depth + 1);
      queue.push(item.left);
    }
    if (item.right) {
      depths.set(item.right, depth + 1);
      queue.push(item.right);
    }
    prev = item;
  }
  return ans;
}
```

### Medium/117

```js
// 117. Populating Next Right Pointers in Each Node II

// Given a binary tree

// struct Node {
//   int val;
//   Node *left;
//   Node *right;
//   Node *next;
// }
// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

// Initially, all next pointers are set to NULL.

/**
 * // Definition for a Node.
 * function Node(val,left,right,next) {
 *    this.val = val;
 *    this.left = left;
 *    this.right = right;
 *    this.next = next;
 * };
 */
/**
 * @param {Node} root
 * @return {Node}
 */
export default function connect(root) {
  // BFS
  if (!root) return root;
  const depth = new Map();
  // For each level of tree, point
  const queue = [];
  queue.push(root);
  depth.set(root, 0);
  let prev;
  while (queue.length) {
    const item = queue.shift();
    const d = depth.get(item);
    if (prev && d === depth.get(prev)) {
      prev.next = item;
    } else if (prev) prev.next = null;
    prev = item;
    if (item.left) {
      queue.push(item.left);
      depth.set(item.left, d + 1);
    }
    if (item.right) {
      queue.push(item.right);
      depth.set(item.right, d + 1);
    }
  }
  return root;
}
```

### Medium/142

```js
// 142. Linked List Cycle II

// Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

// To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

// Note: Do not modify the linked list.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
export default function detectCycle(head) {
  let i = 0;
  const map = new Map();
  if (!head) return null;
  let curr = head;
  while (curr && curr.next) {
    map.set(curr, i);
    curr = curr.next;
    if (map.has(curr)) return curr;
    i++;
  }
  return null;
}
```

### Medium/199

```js
// 199. Binary Tree Right Side View

// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

// Example:

// Input: [1,2,3,null,5,null,4]
// Output: [1, 3, 4]
// Explanation:

//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

const getDepth = (node, depth, map) => {
  if (!node) return;
  map.set(node, depth);
  if (node.left) getDepth(node.left, depth + 1, map);
  if (node.right) getDepth(node.right, depth + 1, map);
};

export default function rightSideView(root) {
  // BFS from right to left
  const queue = [];
  const map = new Map();
  getDepth(root, 0, map);
  const ans = [];
  if (!root) return [];
  const set = new Set();

  queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    if (map.has(item)) {
      if (item.right) queue.push(item.right);
      if (item.left) queue.push(item.left);
      if (!set.has(map.get(item))) {
        ans.push(item.val);
        set.add(map.get(item));
      }
    }
  }
  return ans;
}
```
