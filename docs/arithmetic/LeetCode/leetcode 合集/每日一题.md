---
layout: CustomPages
title: 每日一题
date: 2020-11-21
aside: false
draft: true
---

### 重复数据排序优化

- tag：`Quike Sort`

```
如果一个数组含有大量重复元素，我们应该选择什么样的排序方法，背后的理论依据是什么”？
```

#### 参考答案

取决于数据分布如何

1. 如果数据的总类很少, 而且每个都有大量重复的元素, 那么使用计数排序, 那么这个时间复杂度能够达到 O(N).

```java
public class CountSort {
  public int[] countSort(int[] array) {
    int max = array[0];
    for(int i=1; i<array.length; i++) {
      if(array[i]>max) {
        max = array[i];
      }
    }
    //创建计数数组
    int[] countArray = new int[max+1];
    for(int i=0; i<array.length; i++) {
      countArray[array[i]]++;
    }
    int index = 0;
    //创建返回数组
    int[] sortArray = new int[array.length];
    for(int i=0; i<countArray.length; i++) {
      for(int j=0; j<countArray[i]; j++) {
        sortArray[index++] = i;
      }
    }
    return sortArray;
  }
}
```

2. 如果数据没有明显的规律, 可以考虑快排.  其性能与 pivot 的选择有关. 如果每次 partition 过程中的 pivot 选择能够较好的平分数组, 那么快排的速度能够达到 O(NlogN). 因此再选择 pivot 时候, 可以选择数组中几个中间大小的数字. 此外, 对于重复数量大的数据, 可以选择三路快排来排序. 最后, 因为再数据近乎有序的时候, 插入排序的速度可以达到 O(N), 所以在数据近乎有序的时候, 我们使用插入排序来优化排序过程.

```java
private class QuickSort{

  // 快排转化成为插入排序的阈值
  private static final int INSERTION_SORT_THRESHOLD = 47;

  public void QuickSort(int[] a) {
      if (a.length > 0) {
          quickSort(a, 0, a.length - 1);
      }
  }

  private void swap(int[] arr, int a, int b) {
      int temp = arr[a];
      arr[a] = arr[b];
      arr[b] = temp;
  }

  private int choosePivotMedianOfThree(int[] a, int l, int r) {
    int mid = 0;
    if ((r-l+1) % 2 == 0) {
      mid = l + (r-l+1)/2 - 1;
    } else {
      mid = l + (r-l+1)/2;
    }

    // 只需要找出中位数即可，不需要交换
    if (((a[l]-a[mid]) * (a[l]-a[r])) <= 0) {
      return l;
    } else if (((a[mid]-a[l]) * (a[mid]-a[r])) <= 0) 	{
      return mid;
    } else {
      return r;
    }
  }

  private void quickSort(int[] a, int left, int right) {
      if (right <= left)
          return;

      // 在数据近乎有序的时候, 插入排序的性能近乎于O(N)
      if(right - left <= INSERTION_SORT_THRESHOLD) {
        insertSort(a, left, right)
      }

      /*
      * 工作指针
      * p指向序列左边等于pivot元素的位置
      * q指向序列右边等于Pivot元素的位置
      * i指向从左向右扫面时的元素
      * j指向从右向左扫描时的元素
      */
      int p, q, i, j;
      int pivot;// 锚点
      i = p = left;
      j = q = right - 1;


      /*
      * 每次总是取序列最右边/最优和最中间的元素的大小中间值为锚点
      */
      pivot = choosePivotMedianOfThree(a, left, right);

      //始终将第一个元素作为pivot, 若不是, 则与之交换
      if (pivot != left) {
        swap(a, pivot, left);
      }
      pivot = a[right];

      while (true) {
          /*
          * 工作指针i从右向左不断扫描，找小于或者等于锚点元素的元素
          */
          while (i < right && a[i] <= pivot) {
              /*
              * 找到与锚点元素相等的元素将其交换到p所指示的位置
              */
              if (a[i] == pivot) {
                  swap(a, i, p);
                  p++;
              }
              i++;
          }
          /*
          * 工作指针j从左向右不断扫描，找大于或者等于锚点元素的元素
          */
          while (left <= j && a[j] >= pivot) {
              /*
              * 找到与锚点元素相等的元素将其交换到q所指示的位置
              */
              if (a[j] == pivot) {
                  swap(a, j, q);
                  q--;
              }
              j--;
          }
          /*
          * 如果两个工作指针i j相遇则一趟遍历结束
          */
          if (i >= j)
              break;

          /*
          * 将左边大于pivot的元素与右边小于pivot元素进行交换
          */
          swap(a, i, j);
          i++;
          j--;
      }
      /*
      * 因为工作指针i指向的是当前需要处理元素的下一个元素
      * 故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间
      */
      i--;
      p--;
      while (p >= left) {
          swap(a, i, p);
          i--;
          p--;
      }
      /*
      * 因为工作指针j指向的是当前需要处理元素的上一个元素
      * 故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间
      */
      j++;
      q++;
      while (q <= right) {
          swap(a, j, q);
          j++;
          q++;
      }

      /*
      * 递归遍历左右子序列
      */
      quickSort(a, left, i);
      quickSort(a, j, right);
  }
}
```

### flatten-binary-tree-to-linked-list

- 题目链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
- tag：`tree` `Recursion`

```
Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

#### 参考答案

##### 方法 1 先序遍历

如果仔细观察输入输出的话会发现，其实输出其实就是输入的先序遍历结果而已。
因此一种做法就是我们对其进行先序遍历，

然后将先序遍历的结果构造成没有左子树的二叉树即可

Time complexity : O(n)
Space complexity : O(n)

参考代码

```js
/*
 * @lc app=leetcode id=114 lang=javascript
 *
 * [114] Flatten Binary Tree to Linked List
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function preorderTraversal(root) {
  if (!root) return [];

  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = res[0];

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

##### 方法 2 先序遍历优化(递归遍历和非递归遍历)

算法描述

把一颗二叉树变成单链表 flatten(root)

- 递归遍历把一棵树左子树变成单链表 a
- 递归遍历把一棵树右子树变成单链表 b
- 用链表 a 最后一个元素拼接链表 b(递归子问题)

参考代码

- 递归

```

   void flatten(TreeNode* root) {
       if (root == NULL) return ;

       flatten(root->left);
       flatten(root->right);

       //递归子问题
       TreeNode *tmp = root->right;
       root->right = root->left;
       root->left = NULL;

       while (root->right)
       {
         root = root->right;
       };

        root->right = tmp;
   }
  };
```

- 非递归

```

 void flatten(TreeNode* root) {
     if (root == NULL) {
          return ;
     }
     stack<TreeNode*> result;
     result.push(root);

     while (!result.empty()){
         TreeNode* cur=result.top();
         result.pop();

         if (cur->right)
         {
            result.push(cur->right);//先顺非递归遍历
         }

         if (cur->left)
         {
            result.push(cur->left);//先顺非递归遍历
         }
         //递归子问题
         if (!result.empty())
         {
             cur->right=result.top();
         }
         cur->left=NULL;
     }


```

### Big Countries

- 题目链接：https://leetcode.com/problems/big-countries/
- tag：`sql`

```
There is a table World

+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.

Write a SQL solution to output big countries' name, population and area.

For example, according to the above table, we should output:

+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
```

#### 参考答案

最基本的 sql 语句，没什么好讲的。 如果不会的话，说明对基础语法不熟。

参考代码：

```sql
select name, population, area from World where area > 3000000 or population > 25000000

```

### Nth Highest Salary

- 题目链接：https://leetcode.com/problems/nth-highest-salary/
- tag：`sql`

```
Write a SQL query to get the nth highest salary from the Employee table.

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.

+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
```

#### 参考答案

这是一个简单的考察 sql 基本操作的题目，我们只要 orderby desc 一下然后 limit 选取指定项即可。

需要注意的是 sql 中好像没有 N-1 这样的操作，
因此需要类似这样：

```
DECLARE M INT;
SET M=N-1;

```

参考代码：

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  DECLARE M INT;
  SET M=N-1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT M, 1
  );
END

```

### poker-reveal

- 题目链接：无
- tag：`stack` `queue` `backtrack`

```
手中有 n 张牌
第一张放桌上，第二张挪到手牌最下面，第三张放桌上，第四章挪到手牌最下面，
循环直到所有牌都在桌上
如果桌上牌的顺序是 1 - n
原手牌顺序是什么？

i.e.
如果有 5 张牌，桌上顺序是 1，2，3，4，5
手中顺序是 1，5，2，4，3
手中牌流程是：
1 到桌上 5，2，4，3
5 到牌尾 2，4，3，5，
2 到桌上 4，3，5
4 到牌尾 3，5，4
3 到桌上 5，4
5 到牌尾 4，5
4 到桌上 5
5 到牌尾 5
5 到桌上

```

#### 参考答案

我们可以采取逆推理的方式来完成，假设我们现在桌上的扑克牌已经按照顺序排开了，
我们让时间倒流，一步一步推倒出最初的时候手上的牌即可。
这样的时间复杂度和空间复杂度都是 O(n)

大家可以对比看下 leetcode 950 号问题，这道题目是昨天题目的进阶版本(通用情况)。

这里仅仅列举了 950 问题的参考代码： https://github.com/azl397985856/leetcode/blob/master/daily/answers/950.reveal-cards-in-increasing-order

### my-sqrt

- 题目链接：无
  > leetcode 上有一个相似的[题目](https://leetcode.com/problems/sqrtx/)
- tag：`binary search` `math`

```
要求不用数学库，求 sqrt(2)精确到小数点后 10 位
```

#### 参考答案

1. 二分法

这个解法比较直接，就是普通的二分。
通过每次取中间值进行比较，我们可以舍去一半的结果。时间复杂度 logn

参考代码：

```js
function sqrt(num) {
  if (num < 0) return num;
  let start = 0;
  let end = num;
  let mid = num >> 1;
  const DIGIT_COUNT = 10;
  const PRECISION = Math.pow(0.1, DIGIT_COUNT);
  while (Math.abs(+(num - mid * mid).toFixed(DIGIT_COUNT)) > PRECISION) {
    mid = start + (end - start) / 2.0;
    if (mid * mid < num) {
      start = mid;
    } else {
      end = mid;
    }
  }

  return mid;
}
```

2. 牛顿迭代法

这种方法是牛顿发明的，比较巧妙。
其实上述问题可以转化为 x^2-a = 0，求 x 的值。其实也就是曲线和 y 轴交点的横坐标。
我们可以不断用 f(x)的切线来逼近方程 x^2-a = 0 的根。
根号 a 实际上就是 x^2-a=0 的一个正实根，由于这个函数的导数是 2x。
也就是说，函数上任一点(x,f(x))处的切线斜率是 2x。
那么，x-f(x)/(2x)就是一个比 x 更接近的近似值。代入 f(x)=x^2-a 得到 x-(x^2-a)/(2x)，也就是(x+a/x)/2。

(图片来自 Wikipedia)

参考代码：

```js
function sqrtNewton(n) {
  if (n <= 0) return n;

  let res;
  let last;
  const DIGIT_COUNT = 10;
  const PRECISION = Math.pow(0.1, DIGIT_COUNT);

  res = n;

  while (Math.abs(last - res) > PRECISION) {
    last = res;
    res = (res + n / res) / 2;
  }

  return res;
}
```

### deliver-medicine

- 题目链接：无
- tag：`logic`

```
A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？

```

#### 参考答案

把药放在箱子，用自己的锁把箱子锁上。B 拿到箱子后，再在箱子上加一把自己的锁。箱子运回 A 后，A 取下自己的锁。箱子再运到 B 手中时，B 取下自己的锁，获得药物。

### longest-univalue-path

- 题目链接：https://leetcode.com/problems/longest-univalue-path/
- tag：`recursive` `tree`

```
Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.

The length of path between two nodes is represented by the number of edges between them.



Example 1:

Input:

              5
             / \
            4   5
           / \   \
          1   1   5
Output: 2



Example 2:

Input:

              1
             / \
            4   5
           / \   \
          4   4   5
Output: 2



Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.

```

#### 参考答案

```js
/*
 * @lc app=leetcode id=687 lang=javascript
 *
 * [687] Longest Univalue Path
 */

// 返回经过root的且只能取左右一个节点的路径长度
function helper(node, res) {
  if (node === null) return 0;
  const l = helper(node.left, res);
  const r = helper(node.right, res);
  let lcnt = 0;
  let rcnt = 0;
  if (node.left && node.val === node.left.val) lcnt = lcnt + l + 1;
  if (node.right && node.val === node.right.val) rcnt = rcnt + r + 1;

  res.max = Math.max(res.max, lcnt + rcnt);

  return Math.max(lcnt, rcnt);
}
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function(root) {
  const res = {
    max: 0,
  };
  helper(root, res);
  return res.max;
};
```

### 赛马问题

- 题目链接：无
- tag：`dAc`

```

有25匹马，速度都不同，但每匹马的速度都是定值。现在只有5条赛道，无法计时，即每赛一场最多只能知道5匹马的相对快慢。
问最少赛几场可以找出25匹马中速度最快的前3名？

```

#### 参考答案

七次。

由于每一匹马我们都需要比赛才行，因此至少先比赛 25 / 5 = 5 次，
然后我们可以选择出来每一组的第一名，也就是一共 5 匹马，再进行一次比赛。这个时候跑第一名的一定是总体第一名。

我们来总结一下，这个时候我们已经决出了第一名，并且比赛了 6 次。

让我们来分析一下， 假如第六场比赛从第一名到第五名我们依次给其在第一场比赛的场次进行编队为 A B C D E。

那么 D E 所在的一共 5 + 5 = 10 匹马是没有比赛的必要的， 不可能是前三。

C 中的只有第一名可能是前三，其他四个我们可以直接舍弃。

B 中有可能前三的只有一二名。

A 中的二三名也可能是前三。

那么我们只需要把有可能成为前三的 A 中的 2 个， B 中的一个， 以及 C 中 一个 比一下就好了。五个刚好需要一次。

因此一共需要七次。

我们从分治的角度考虑一下， 也就是说怎么将其抽象为一般问题，就是转化为程序。

将原问题表示为 f， 那么 f(25, 5, 3) 表示 25 匹马，5 个跑道，决出前三。

那么原问题可以转化为：

```
f(25, 5, 3) = 25 / 5 + f(5,5,1) + f(5,5,2)

```

那么如果换成 10 匹马：

```
f(10, 5, 3) = 10 / 5 + f(5,5,1) + f(4,5,2)

```

更为精确的代码我就不写了，大家可以自己思考一下。

- 题目链接：无
- tag：`math`

```

12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。

```

#### 参考答案

3 次。

我们先来分析一下：

由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，
根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。
如此一来的话一次称量就可以将答案的可能性缩减为原来的 1/3，三次就能缩减为 1/27。而总共才有 24 种可能性，所以理论上是完全可以 3 次称出来的。

这个题目解释起来比较费劲，我在网上找了一个现成的图来解释一下：

图中“1+”是指“1 号小球为重”这一可能性。“1-”是指“1 号小球为轻”这一可能性。
一开始一共有 24 种可能性。

4、4 称了之后不管哪种情况(分支)，剩下来的可能性总是 4 种。这是一个完美的三分。

然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支 1 上的第二次称法，即“1、2、6 对 3、4、5”这种称法，天平输出三种结果的可能性是均等的(严格来说是几乎均等)。

这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的 1/3。

### 洗牌算法

#### 信息卡片

- 题目链接：暂无
- tag：`Array` `Probability`

```
假设我们有一个n个元素的数组，要求你实现一个函数，该函数会随机地返回n个元素的排列，要求所有排列出现的概率是一样的。即每一个排列出现的概率都是1/n!.
```

#### 参考答案

思路如下

像洗牌一样，从数组中随机取出一个，放入另一个全新的数组中，但这会涉及到数组删除操作.
在这个基础上转换一下思路把从数组中取出的元素放入原数组中，第一次随机删除时，把它与原数组的倒数第一个交换，第 2 次在剩下的元素中随机删除时，把它与原数组的倒数第 2 个交换，第 n-1 次(最后一次不用换)时便完成了洗牌 时间复杂度为 O(n)

```js
function shuffle(list) {
  for (let i = list.length - 1; i >= 1; i--) {
    const random = (Math.random() * (i + 1)) >> 0;
    const temp = list[i];
    list[i] = list[random];
    list[random] = temp;
  }
}
```

注： 概率证明， 任意一个元素放在倒数第一个位置的概率为 1/n,放到倒数第 2 个的概率为 [(n-1)/n ]_ [1/(n-1)] = 1/n,放在倒数第 k 个位置的概率是[(n-1)/n] _ [(n-2)/(n-1)] _..._ [(n-k+1)/(n-k+2)] _[1/(n-k+1)] = 1/n， 因此每一个元素放在任意位置的概率都为 1/n,所有的排列出现的概率则为 1/n _ 1/(n-1) _.._ 1 = 1/n!

注：在交换时，之所以第一次与第 n 个交换不与第一个交换，是因为与第 n 个交换代码更简洁

### 删除没有头节点的单链表中的指定项

#### 信息卡片

- 题目链接：无(来自编程之美)
- tag：`Linked List`

```
假设有一个没有头指针的单链表，一个指针指向该单链表中间的一个节点(不是第一个，也不是最后一个节点)，
请将该节点从单链表中删除。

```

#### 参考答案

我们可以“移花接木”， 将要删除的节点的后面的节点的值给当前节点，然后删除后面的节点即可。

### 灯泡问题

#### 信息卡片

- 题目链接：无
- tag：`发散思维`

```
房子有三盏灯，屋外有三个开关，分别控制这三盏灯，只有进去房间，才能看到哪一个灯是亮的。
请问如何只进一次房间，就能指明哪一个开关控制哪一个灯？

```

#### 参考答案

这个问题比较发散，下面的答案仅供参考：

1. 首先你应该问这个灯是什么样的灯
2. 如果是电阻比较大的灯，根据焦耳定律，会有相对比较大的发热
   但是发热 Q = I ^ 2 _ R _ t, 因此发热量除了和电阻有关，其实和电流和 t 都有关系，
   如何评估这种差异，寻找到人能感受到的热量差异，需要面试者自己去探索和分析

### 将帅问题

#### 信息卡片

- 题目链接：无(来自编程之美)
- tag：`数据压缩`

#### 参考答案

这是数据压缩问题中的一种。

类似的问题有， 如果将 IP 地址用 4 个字节来表示等等。

这道题的思路，如果我们不考虑用一个字节去存储的话，我们通过观察
坐标，发现“坐标和 3 取余的结果相同的就是同一列”，因此我们可以根据
这个来判断位置是否合法。

我们容易写出类似下面的代码：

```js
for (let i = 0; i < 9; i++) {
  for (let j = 0; j < 9; j++) {
    if (i % 3 !== j % 3) {
      console.log(`${i + 1}, ${j + 1}`);
    }
  }
}
```

可以看出上面的写法用到了两个字节去表示，如何将上面的写法压缩到一个字节呢？

仔细观察我们发现，内存循环和外层循环的长度是一样的，
其实我们内外循环用一个变量表示。

内外循环总共执行了 81 次。 我们定义一个变量为 81.
然后用 i / 9 来表示外层循环的值。 用 i % 9 来表示内层循环的值。

可以看出，i 增加 9 次之后，内存循环会增加 9，外层增加 1，整个过程类似上面。

代码如下：

```js
let i = 81;

while (i-- > 0) {
  if (((i / 9) >> 0) % 3 !== (i % 9) % 3) {
    console.log(`${((i / 9) >> 0) + 1}, ${(i % 9) + 1}`);
  }
}
```

### 桶中取黑白球

#### 信息卡片

- tag：`Math` `位运算`

```
有一个桶，里面有白球，黑球各100个，你必须用以下规则将球取出来：
- 每次从桶里取两个球
- 如果两个球是相同的颜色，那么再放一个黑球
- 如果两个球是不同的颜色，那么再放一个白球。
问：最后一个球是黑球的概率是多少？
```

#### 参考答案

##### [1]. 数学分析原问题

首先我们来仔细读题看看我们有哪些知道的信息：

- 不管什么情况，每次球的总数减 1；
- 两黑：黑球-1，白球 0；
- 两白：黑球+1，白球-2；
- 一黑一白：黑球-1，白球 0；
- 最后两球只要不是一黑一白，最后一球都是黑；

初始状态是 100 个黑球和 100 个白球，从上面三个状态可知道，黑球要么+1 要么-1，而白球要么不变要么-2；在 198 次取球后，我们可知剩余两个球，现在假设剩余的两球为一黑一白，可以证明这是不存在的。

因为白球下降是以 2 的倍数下降，不可能从 100 下降至 1,；故剩余两球肯定不是一黑一白的情况，那么最后一球的情况必然为黑。

##### [2]. 原问题拓展(n 个黑球和 m 个白球)

在 n+m-2 次取球后，剩余两个球。

由于我们知道白球数下降是以 2 的倍数下降，如果 m 为偶数的话，是不可能下降至 1；即同上 1，最后一球必为黑球。如果 m 为奇数的话，最后必然是 k 黑 1 白(k>=1)，显然对于任意的 k，要么剩余全是黑球，要么黑球不断减 1，最后变为 1 黑 1 白。全黑和 1 黑 1 白最后的结果都是剩余一个白球。

得出结论，最后一球结果无关黑球数量(n>=0),仅与白球数量 m 有关。

- 如果白球 m 为奇数，最后一球必然白；
- 如果白球 m 为偶数，最后一球必然黑；

##### [3]. 抽象为数学模型，严格证明

不妨设黑球为 0，白球为 1；

- 两黑：F(0,0) = 0；表示两个黑球生一黑；
- 两白：F(1,1) = 0；表示两个白球生一黑；
- 一黑一白：F(0,1) = 0；表示一个黑球一个白球生一白；

仔细观察就会发现这个函数 F 就是 XOR(异或)；

那么 m 个黑球和 n 个白球，就抽象为 m 个 0 和 n 个 1 作异或的结果；而且我们可知异或满足结合律和交换律(证明略，最简单的证明方法枚举)。

那么问题就很简单，对于任意多 0，异或结果依然是 0，所以对于任意多 1，只需要考虑 1 个数的奇偶性就可判断最后剩余 1 个 1 还是 0 个 1；

结论同 2：

- 1(白球)的个数奇数，最后异或结果为 1；
- 1(白球)的个数偶数，最后异或结果为 0；

### 水壶问题

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/water-and-jug-problem/
- tag：`Math`

```
给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。
```

#### 参考答案

1.数学分析解答

上面的问题是一个特例，我们可以抽象为[leetcode-365-水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)。

```
有两个容量分别为 x升 和 y升 的水壶(壶1，壶2)以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？
```

解题核心思路(x < y，即壶 1 容量小于壶 2，x == y 的情况后面讨论)：

1. 将壶 2 倒满，往壶 1 倒入至满。
2. 若壶 1 满，记录当前壶 2 中新水量。壶 1 倒出，将壶 2 中剩余的继续往壶 1 中倒入；(当壶 1 满，继续此操作，并记录当前壶 2 中新水量 nw， 若此新水量已被记录，则)。
3. 若出现壶 1 不满时(即此时壶 2 必空)，重复操作 1。

开辟一个新数组 nws 记录所有新水量，对任意 nws[i]，可构造的水量为 nws[i]，nws[i]+x，nws[i]+y。

(其实不需要新数组，因为数学上可以证明新水量的值循环周期呈现，故可以使用一个临时变量 cur，当 cur==x 为终止条件)

数学证明新水量 nw 值是循环周期的：
![1111](https://raw.githubusercontent.com/lvguofeng1303/markdownimage/master/daily/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/math%20prove.jpg)

个别特殊情况考虑：

- x == z || y == z; **true**
- x == 0 || x+y < z; **false**
- x+y == z || z == 0; **true**

```
class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        if(x > y) return canMeasureWater(y, x, z);
        if(x == z || y == z) return true;
        if(x == 0 || x+y < z) return false;
        if(x+y == z || z == 0) return true;
        int cur = y - x;
        while(cur != x){
            if(cur == z) return true;
            if(cur > x){
                if(cur + x == z) return true;
                cur = cur - x;
            }
            else{
                if(cur + y == z || cur + x == z) return true;
                cur = y - x + cur;
            }
        }
        return false;
    }
};
```

2.BFS

不仅可以计算是否能获取 z 升水，而且可以获得最少多少操作可获取 z 升水。(缺点，无法通过，因为需要太大的空间，需要申请一个三维数组记录状态)

核心思想就是状态转移问题：

壶 0(x+y)，壶 1(x)，壶 2(y)，壶 0 是本是无限大水池，同理于定义为大小为 x+y 的壶。用 bfs 的思想，使用一个队列记录所有新的状态。

对于任意状态(c，a，b)，状态转移就是：

- 若 c 不为 0，将壶 0 倒水入壶 1 或壶 2；若 a 不为 0，将壶 1 倒水入壶 0 或壶 2；若 b 不为 0，将壶 2 倒水入壶 0 或壶 1；
- 记录每个新状态，并入队，若此状态访问过则不入队。

特殊情况考虑同 1。

```
class Solution {
public:
    struct state{
        int nums[3];
        state(int xy, int x, int y){
            nums[0] = xy;
            nums[1] = x;
            nums[2] = y;
        }
    };

    state pour_water(state cur, int src, int det, int size[]){
        state ans = cur;
        int need_w = size[det] - cur.nums[det];
        if(need_w <= cur.nums[src]){
            ans.nums[det] += need_w;
            ans.nums[src] -= need_w;
        }
        else{
            ans.nums[det] += ans.nums[src];
            ans.nums[src] = 0;
        }
        return ans;
    }

    bool canMeasureWater(int x, int y, int z) {
        if(x > y) return canMeasureWater(y, x, z);  //
        if(x == z || y == z) return true;
        if(x == 0 || x+y < z) return false;
        if(x+y == z || z == 0) return true;
        int visited[x+y+1][x+1][y+1];
        int water_size[3] = {x+y, x, y};
        memset(visited, 0, sizeof(visited));
        state cur(x+y, 0, 0);
        queue<state> q;
        q.push(cur);
        int step = 0;
        while(!q.empty()){
            int size = q.size();
            while(size){
                state temp(0, 0, 0);
                cur = q.front();
                if(cur.nums[1] + cur.nums[2] == z) return true;
                visited[cur.nums[0]][cur.nums[1]][cur.nums[2]] = 1;
                q.pop();
                if(cur.nums[0] != 0){
                    temp = pour_water(cur, 0, 1, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                    temp = pour_water(cur, 0, 2, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                }
                if(cur.nums[1] != 0){
                    temp = pour_water(cur, 1, 2, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                    temp = pour_water(cur, 1, 0, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                }
                if(cur.nums[2] != 0){
                    temp = pour_water(cur, 2, 1, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                    temp = pour_water(cur, 2, 0, water_size);
                    if(visited[temp.nums[0]][temp.nums[1]][temp.nums[2]] != 1)
                        q.push(temp);
                }
                size--;
            }
            step++;
        }
        return false;
    }
};
```

### 版本号比较

#### 信息卡片

- 题目链接：<https://leetcode-cn.com/problems/compare-version-numbers/>
- tag：`String`

```
比较两个版本号 version1 和 version2。
如果 version1 > version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。

你可以假设版本字符串非空，并且只包含数字和 . 字符。

 . 字符不代表小数点，而是用于分隔数字序列。

例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。

你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级(大版本)和第二级(小版本)修订号分别为 3 和 4。其第三级和第四级修订号均为 0。

示例 1:

输入: version1 = "0.1", version2 = "1.1"
输出: -1
示例 2:

输入: version1 = "1.0.1", version2 = "1"
输出: 1
示例 3:

输入: version1 = "7.5.2.4", version2 = "7.5.3"
输出: -1
示例 4：

输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。
示例 5：

输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。

提示：

版本字符串由以点 (.) 分隔的数字字符串组成。这个数字字符串可能有前导零。
版本字符串不以点开始或结束，并且其中不会有两个连续的点。
```

#### 参考答案

##### [1]. 递归解决

其实这个问题其实简化后就是依次比较每一个修订版本大小，所以问题有以下几点：

1. 获取每个修订版本号大小；
2. 处理每个修订版本号前导零问题；
3. 处理不同版本有不同次数修订版本；

问题 1：这个如果对字符串处理比较熟悉的会比较简单，直接遍历循环找到第一个逗号 first_dot(找不到的情况设为-1)，str.substr(0, first_dot)即可。针对第二，第三个逗号，我们用递归的方案回避，这样每次我们都相当于找第一个逗号前的数字。

问题 2：前导零问题更容易解决，在遍历过程中找到第一个非零数 first_no_zero，str.substr(first_no_zero, first_dot - first_no_zero)。当然更简单的方案是定义初值 v1 = 0，每次计算 v1 = v1\*10 + str[i] - 'a'

问题 3：针对不同次数的修订版本，我们可以在字符串末尾填 0 表示。即有一个版本号 first_dot = -1。

代码如下：

```
class Solution {
public:
    int first_num(string str, int& first_dot){
        int v1 = 0;
        first_dot = -1;
        for(int i = 0; i < str.size(); i++){
            if(str[i] == '.'){
                first_dot = i;
                break;
            }
            else
                v1 =  v1 * 10 + (str[i] - '0');
        }
        return v1;
    }

    int compareVersion(string version1, string version2) {
        int v1 = 0, v2 = 0;
        int v1_first_dot, v2_first_dot;
        v1 = first_num(version1, v1_first_dot);
        v2 = first_num(version2, v2_first_dot);
        if(v1 > v2)
        	return 1;
        else if(v1 < v2)
        	return -1;
        else{
            if(v1_first_dot == -1 && v2_first_dot == -1)
             	return 0;
            if(v1_first_dot == -1)
              	version1 = "0";
            else
              	version1 = version1.substr(v1_first_dot+1);
            if(v2_first_dot == -1)
              	version2 = "0";
            else
              	version2 = version2.substr(v2_first_dot+1);
            return compareVersion(version1, version2);
        }
    }
};

```

##### [2]. 数组

解析每个版本号，放入数组，依次比较大小。

```c
int compareVersion(char * version1, char * version2){
    if (version1 == NULL || version2 == NULL) return -1;
    int *val1 = (int *)calloc(1024, sizeof(int));
    int *val2 = (int *)calloc(1024, sizeof(int));
    int len1 = strlen(version1), top1 = 0;
    int len2 = strlen(version2), top2 = 0;
    int i, n;
    for (i = 0, n = 0; i < len1; ++i) {  //解析版本1
        if (version1[i] == '.') {
            val1[top1++] = n;
            n = 0;
        }else n = n*10 + (version1[i] & 0x0f);
    }
    val1[top1++] = n;
    for (i = 0, n = 0; i < len2; ++i) {  //解析版本1
        if (version2[i] == '.') {
            val2[top2++] = n;
            n = 0;
        }else n = n*10 + (version2[i] & 0x0f);
    }
    val2[top2++] = n;
    for (i = 0; i < top1 && i < top2; ++i) {  //比较版本大小
        if      (val1[i] > val2[i]) return 1;
        else if (val1[i] < val2[i]) return -1;
    }
    if (i < top1) {  //由于可能有的版本还没遍历完
        while (i < top1) if (val1[i++]) return 1;  //只要版本后面的数字出现的不是0，就意味着两个版本不一样
    }else{
        while (i < top2) if (val2[i++]) return -1;
    }
    return 0;
}
//作者：ljj666
//链接：https://leetcode-cn.com/problems/compare-version-numbers/solution/cyu-yan-jian-jian-dan-dan-de-ji-xing-dai-ma-jie-37/
//来源：力扣(LeetCode)
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 反转每对括号间的子串

#### 信息卡片

- 题目链接：https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses
- tag：`String` `Backtracking`

```
给出一个字符串 s(仅含有小写英文字母和括号)。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。



示例 1：

输入：s = "(abcd)"
输出："dcba"
示例 2：

输入：s = "(u(love)i)"
输出："iloveu"
示例 3：

输入：s = "(ed(et(oc))el)"
输出："leetcode"
示例 4：

输入：s = "a(bcdefghijkl(mno)p)q"
输出："apmnolkjihgfedcbq"


提示：

0 <= s.length <= 2000
s 中只有小写英文字母和括号
我们确保所有括号都是成对出现的
```

#### 参考答案

###### 思路

1. 对字符串中的字符遍历

2) 括号是有层次性的，所以这里用递归的方式处理内层的字符串，内层处理完成后回溯。返回内层有括号索引的下一个位置，以及括号内反转完成后的字符串。

3. 在 2 的递归过程中，原字符串也需要作为递归方法的参数传递进来

4) 递归方法的负责处理从当前位置开始到遇到对应的有括号之间的字符串，将其反转；若遇到新的左括号，创建临时的 StringBuilder 用于记录递归方法内反转的字符串，进入新的一层递归；递归完成后临时 StringBuilder 被填充并且是反转后的结果，append 到上一层递归的 StringBuilder 中。

5. 递归回溯到最上层时，StringBuilder 即为最终结果。

6) 更多代码细节可以关注下代码注释

###### 代码如下

```java
package com.jinyang.algorithms.string;

/**
 * Created by Zhang.Jinyang&Hardy on 2019/10/17.
 */
public class ReverseParentheses {

  public static void main(String[] args) {

    /**
     * 用例的类型
     * (ab(cd)ef)
     * ab(cd)
     * ab(cd)ef
     * ((ab)c)def
     * abc(d(ef))
     * */
    String s = "ab((cd)ef)";

    StringBuilder builder = new StringBuilder();
    reverseParentheses(s, 0, builder, 0);
    System.out.println(builder.toString());
  }

  /**
   * leetcode  1190
   * 耗时 1ms
   * 内存消耗  34.6M
   * */
  static int reverseParentheses(String s, int index, StringBuilder stringBuilder, int leftCount) {


    //遍历字符串
    while (index < s.length()) {
      /**
       * case 当前字符为'('
       *      leftCount++; 记录已遍历 但未 找到相对应的右括号 的左括号数目；这里每当当前字符为'('，leftCount+1
       *      case: index 为 0，第一个字符为'('
       *            index ++, 继续遍历
       *      case：index 不为0， 不是第一个字符
       *            递归，index++，new stringBuilder(临时存放从当前'('到其相对应的')'里的字符,不包含'('和')'), leftCount
       *            递归后，new stringBuilder已被填充好 从当前'('到其相对应的')'里的字符 反转后的字符串；且返回参数为下一次要访问的字符下标index
       *            leftCount --；因为进入递归后返回时已经将 当前'(' 与其响应的 ')' 内的字符反转，所以左括号数减1
       *            递归前的 stringBuilder append 递归后，已反转的 new stringBuilder
       *            继续遍历.
       * */
      if (s.charAt(index) == '(') {
        leftCount++;
        if (index != 0) {
          StringBuilder sTemp = new StringBuilder();
          index = reverseParentheses(s, index + 1, sTemp, leftCount);
          leftCount--;
          stringBuilder.append(sTemp);
          continue;
        }

        index++;
        continue;
      }

      /**
       * case 当前字符为')'
       *     反转stringBuilder里的字符位置；
       *     index++；
       *     case：当前leftCount >1 那么当前是在递归过程中
       *          return index;//回溯
       *     case: 当前leftCount <=1 当前不是递归
       *          继续遍历;
       * */
      if (s.charAt(index) == ')') {
        stringBuilder.reverse();
        index++;
        if (leftCount > 1) {
          return index;
        } else {
          continue;
        }
      }

      /**当前字符不是'(' 或 ')'
       * 当前stringBuilder append 当前下标对应的字符
       * index++
       * 继续遍历
       * */
      stringBuilder.append(s.charAt(index));
      index++;
    }
    return index;
  }


}


```

### 拼凑硬币

#### 信息卡片

- 题目链接：腾讯真题
- tag：`Bit` `DP`

```
小Q十分富有，拥有非常多的硬币，小Q拥有的硬币是有规律的，对于所有的非负整数K，小Q恰好各有两个面值为2^k的硬币，所有小Q拥有的硬币就是1，1，2，2，4，4，8，8.....小Q有一天去商店购买东西需要支付n元钱，小Q想知道有多少种方案从他拥有的硬币中选取一些拼凑起来恰好是n元(如果两种方案某个面值的硬币选取的个数不一样就考虑为不一样的方案)
```

#### 参考答案

##### [1]. 二进制方案

###### 分析

集合：和为 n 的可选数据集，在本题中就是可选的硬币面值：1，1，2，2，4… 以下统一称为**集合**

1. 由集合中元素的特点可以联想到 **二进制**。如果将集合中的所有元素都用二进制来表示的话：

   1 等于 2 的 0 次方 等于 二进制的 1
   2 等于 2 的 1 次方 等于 二进制的 10
   4 等于 2 的 2 次方 等于 二进制的 100
   ...
   即：
   1=2^0=(1)2; 2=2^1=(10)2; 4 = 2^2 = (100)2;..... .**(等号最后的数都是二进制表示法)**

   集合中的每一个元素都可以表示为 首位为 1 其他位为 0 的二进制数。

2. 集合中元素是成对出现的，那么可以将集合拆分为完全相同的两部分, 每一个数都可以由二进制中指定位置的 1 来表示：

   8 4 2 1 —> 1 1 1 1

   8 4 2 1 —> 1 1 1 1

   那么，若目标数 n 为 11.那么 11 = 1 + 10 = 2 + 9 = 3 + 8 = 4 + 7 = 5 + 6；

   **a.** 以 **1 + 10** 为例 ： 1 的 二进制 1， 10 的二进制为 1010 那么 (11) 就相当于

   取 二进制数 第一位的 1， 第四位的 1 ，第 2 位的 1 [**从右往左**]

   即可组成 十进制的 11。

   **b.** **2 + 9 = (10)2+ (1001)2** ： 取第二位的 1， 第四位的 1， 从第一位的 1 [**从右往左**]

   同理：

   **c.** **3 + 8= (11)2+(1000)2**

   **d.** **4 + 7 = (100)2+(111)2**

   **e.** **5 + 6=(101)2+(110)2**

   > a 和 b ,c 中 其实是同一种方案。可通过**异或运算**进行去重：
   >
   > 比如，这三组方案的异或结果是相同的。1^10 == 2^9 == 3^8 == (1011)2
   >
   > d,e 也是同一种方案

###### 思路

1. 从 i=0 开始**(如果 n=4 那么 0+4 也是一种方案，只不过只选择一个 4 而已)**，i<=(n/2), 每次 i+1 循环开始：循环中将 i^(n-i)的值放到 Set(无重复元素)中
2. **最终**求 Set 的 size 大小。就是最终的方案数。

代码如下：

```
import java.util.HashSet;
import java.util.Set;

public class CoinsOfQy {

  /**测试*/
  public static void main(String[] args) {

    int n = 11;
    int result = coinsOfQy(n);
    System.out.println(result);
  }

  private static int coinsOfQy(int n) {

    Set<Integer> resultSet = new HashSet<>();
    for (int i =0; i<= n/2; i++){
      int r = i^(n-i);
      resultSet.add(r);
    }
    return resultSet.size();
  }
}

```
