---
layout: CustomPages
title: 每日一题
date: 2020-11-21
aside: false
draft: true
---

## 重复数据排序优化

- tag：`Quike Sort`

### 题目描述

```
如果一个数组含有大量重复元素，我们应该选择什么样的排序方法，背后的理论依据是什么”？
```

### 参考答案

取决于数据分布如何

1. 如果数据的总类很少, 而且每个都有大量重复的元素, 那么使用计数排序, 那么这个时间复杂度能够达到 O(N).

```java
public class CountSort {
  public int[] countSort(int[] array) {
    int max = array[0];
    for(int i=1; i<array.length; i++) {
      if(array[i]>max) {
        max = array[i];
      }
    }
    //创建计数数组
    int[] countArray = new int[max+1];
    for(int i=0; i<array.length; i++) {
      countArray[array[i]]++;
    }
    int index = 0;
    //创建返回数组
    int[] sortArray = new int[array.length];
    for(int i=0; i<countArray.length; i++) {
      for(int j=0; j<countArray[i]; j++) {
        sortArray[index++] = i;
      }
    }
    return sortArray;
  }
}
```

2. 如果数据没有明显的规律, 可以考虑快排.  其性能与 pivot 的选择有关. 如果每次 partition 过程中的 pivot 选择能够较好的平分数组, 那么快排的速度能够达到 O(NlogN). 因此再选择 pivot 时候, 可以选择数组中几个中间大小的数字. 此外, 对于重复数量大的数据, 可以选择三路快排来排序. 最后, 因为再数据近乎有序的时候, 插入排序的速度可以达到 O(N), 所以在数据近乎有序的时候, 我们使用插入排序来优化排序过程.

```java
private class QuickSort{

  // 快排转化成为插入排序的阈值
  private static final int INSERTION_SORT_THRESHOLD = 47;

  public void QuickSort(int[] a) {
      if (a.length > 0) {
          quickSort(a, 0, a.length - 1);
      }
  }

  private void swap(int[] arr, int a, int b) {
      int temp = arr[a];
      arr[a] = arr[b];
      arr[b] = temp;
  }

  private int choosePivotMedianOfThree(int[] a, int l, int r) {
    int mid = 0;
    if ((r-l+1) % 2 == 0) {
      mid = l + (r-l+1)/2 - 1;
    } else {
      mid = l + (r-l+1)/2;
    }

    // 只需要找出中位数即可，不需要交换
    if (((a[l]-a[mid]) * (a[l]-a[r])) <= 0) {
      return l;
    } else if (((a[mid]-a[l]) * (a[mid]-a[r])) <= 0) 	{
      return mid;
    } else {
      return r;
    }
  }

  private void quickSort(int[] a, int left, int right) {
      if (right <= left)
          return;

      // 在数据近乎有序的时候, 插入排序的性能近乎于O(N)
      if(right - left <= INSERTION_SORT_THRESHOLD) {
        insertSort(a, left, right)
      }

      /*
      * 工作指针
      * p指向序列左边等于pivot元素的位置
      * q指向序列右边等于Pivot元素的位置
      * i指向从左向右扫面时的元素
      * j指向从右向左扫描时的元素
      */
      int p, q, i, j;
      int pivot;// 锚点
      i = p = left;
      j = q = right - 1;


      /*
      * 每次总是取序列最右边/最优和最中间的元素的大小中间值为锚点
      */
      pivot = choosePivotMedianOfThree(a, left, right);

      //始终将第一个元素作为pivot, 若不是, 则与之交换
      if (pivot != left) {
        swap(a, pivot, left);
      }
      pivot = a[right];

      while (true) {
          /*
          * 工作指针i从右向左不断扫描，找小于或者等于锚点元素的元素
          */
          while (i < right && a[i] <= pivot) {
              /*
              * 找到与锚点元素相等的元素将其交换到p所指示的位置
              */
              if (a[i] == pivot) {
                  swap(a, i, p);
                  p++;
              }
              i++;
          }
          /*
          * 工作指针j从左向右不断扫描，找大于或者等于锚点元素的元素
          */
          while (left <= j && a[j] >= pivot) {
              /*
              * 找到与锚点元素相等的元素将其交换到q所指示的位置
              */
              if (a[j] == pivot) {
                  swap(a, j, q);
                  q--;
              }
              j--;
          }
          /*
          * 如果两个工作指针i j相遇则一趟遍历结束
          */
          if (i >= j)
              break;

          /*
          * 将左边大于pivot的元素与右边小于pivot元素进行交换
          */
          swap(a, i, j);
          i++;
          j--;
      }
      /*
      * 因为工作指针i指向的是当前需要处理元素的下一个元素
      * 故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间
      */
      i--;
      p--;
      while (p >= left) {
          swap(a, i, p);
          i--;
          p--;
      }
      /*
      * 因为工作指针j指向的是当前需要处理元素的上一个元素
      * 故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间
      */
      j++;
      q++;
      while (q <= right) {
          swap(a, j, q);
          j++;
          q++;
      }

      /*
      * 递归遍历左右子序列
      */
      quickSort(a, left, i);
      quickSort(a, j, right);
  }
}
```

## flatten-binary-tree-to-linked-list

- 题目链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
- tag：`tree` `Recursion`

### 题目描述

```
Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

### 参考答案

#### 方法 1 先序遍历

如果仔细观察输入输出的话会发现，其实输出其实就是输入的先序遍历结果而已。
因此一种做法就是我们对其进行先序遍历，

然后将先序遍历的结果构造成没有左子树的二叉树即可

Time complexity : O(n)
Space complexity : O(n)

参考代码

```js
/*
 * @lc app=leetcode id=114 lang=javascript
 *
 * [114] Flatten Binary Tree to Linked List
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
function preorderTraversal(root) {
  if (!root) return [];

  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = res[0];

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

#### 方法 2 先序遍历优化(递归遍历和非递归遍历)

算法描述

把一颗二叉树变成单链表 flatten(root)

- 递归遍历把一棵树左子树变成单链表 a
- 递归遍历把一棵树右子树变成单链表 b
- 用链表 a 最后一个元素拼接链表 b(递归子问题)

参考代码

- 递归

```

   void flatten(TreeNode* root) {
       if (root == NULL) return ;

       flatten(root->left);
       flatten(root->right);

       //递归子问题
       TreeNode *tmp = root->right;
       root->right = root->left;
       root->left = NULL;

       while (root->right)
       {
         root = root->right;
       };

        root->right = tmp;
   }
  };
```

- 非递归

```

 void flatten(TreeNode* root) {
     if (root == NULL) {
          return ;
     }
     stack<TreeNode*> result;
     result.push(root);

     while (!result.empty()){
         TreeNode* cur=result.top();
         result.pop();

         if (cur->right)
         {
            result.push(cur->right);//先顺非递归遍历
         }

         if (cur->left)
         {
            result.push(cur->left);//先顺非递归遍历
         }
         //递归子问题
         if (!result.empty())
         {
             cur->right=result.top();
         }
         cur->left=NULL;
     }


```

## Big Countries

- 题目链接：https://leetcode.com/problems/big-countries/
- tag：`sql`

### 题目描述

```
There is a table World

+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.

Write a SQL solution to output big countries' name, population and area.

For example, according to the above table, we should output:

+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
```

### 参考答案

最基本的 sql 语句，没什么好讲的。 如果不会的话，说明对基础语法不熟。

参考代码：

```sql
select name, population, area from World where area > 3000000 or population > 25000000

```

## Nth Highest Salary

- 题目链接：https://leetcode.com/problems/nth-highest-salary/
- tag：`sql`

### 题目描述

```
Write a SQL query to get the nth highest salary from the Employee table.

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.

+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
```

### 参考答案

这是一个简单的考察 sql 基本操作的题目，我们只要 orderby desc 一下然后 limit 选取指定项即可。

需要注意的是 sql 中好像没有 N-1 这样的操作，
因此需要类似这样：

```
DECLARE M INT;
SET M=N-1;

```

参考代码：

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  DECLARE M INT;
  SET M=N-1;
  RETURN (
      # Write your MySQL query statement below.
      SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT M, 1
  );
END

```

## poker-reveal

- 题目链接：无
- tag：`stack` `queue` `backtrack`

### 题目描述

```
手中有 n 张牌
第一张放桌上，第二张挪到手牌最下面，第三张放桌上，第四章挪到手牌最下面，
循环直到所有牌都在桌上
如果桌上牌的顺序是 1 - n
原手牌顺序是什么？

i.e.
如果有 5 张牌，桌上顺序是 1，2，3，4，5
手中顺序是 1，5，2，4，3
手中牌流程是：
1 到桌上 5，2，4，3
5 到牌尾 2，4，3，5，
2 到桌上 4，3，5
4 到牌尾 3，5，4
3 到桌上 5，4
5 到牌尾 4，5
4 到桌上 5
5 到牌尾 5
5 到桌上

```

### 参考答案

我们可以采取逆推理的方式来完成，假设我们现在桌上的扑克牌已经按照顺序排开了，
我们让时间倒流，一步一步推倒出最初的时候手上的牌即可。
这样的时间复杂度和空间复杂度都是 O(n)

大家可以对比看下 leetcode 950 号问题，这道题目是昨天题目的进阶版本(通用情况)。

这里仅仅列举了 950 问题的参考代码： https://github.com/azl397985856/leetcode/blob/master/daily/answers/950.reveal-cards-in-increasing-order

## my-sqrt

- 题目链接：无
  > leetcode 上有一个相似的[题目](https://leetcode.com/problems/sqrtx/)
- tag：`binary search` `math`

### 题目描述

```
要求不用数学库，求 sqrt(2)精确到小数点后 10 位
```

### 参考答案

1. 二分法

这个解法比较直接，就是普通的二分。
通过每次取中间值进行比较，我们可以舍去一半的结果。时间复杂度 logn

参考代码：

```js
function sqrt(num) {
  if (num < 0) return num;
  let start = 0;
  let end = num;
  let mid = num >> 1;
  const DIGIT_COUNT = 10;
  const PRECISION = Math.pow(0.1, DIGIT_COUNT);
  while (Math.abs(+(num - mid * mid).toFixed(DIGIT_COUNT)) > PRECISION) {
    mid = start + (end - start) / 2.0;
    if (mid * mid < num) {
      start = mid;
    } else {
      end = mid;
    }
  }

  return mid;
}
```

2. 牛顿迭代法

这种方法是牛顿发明的，比较巧妙。
其实上述问题可以转化为 x^2-a = 0，求 x 的值。其实也就是曲线和 y 轴交点的横坐标。
我们可以不断用 f(x)的切线来逼近方程 x^2-a = 0 的根。
根号 a 实际上就是 x^2-a=0 的一个正实根，由于这个函数的导数是 2x。
也就是说，函数上任一点(x,f(x))处的切线斜率是 2x。
那么，x-f(x)/(2x)就是一个比 x 更接近的近似值。代入 f(x)=x^2-a 得到 x-(x^2-a)/(2x)，也就是(x+a/x)/2。

![2019-06-27](../assets/daily/2019-06-27.gif)

(图片来自 Wikipedia)

参考代码：

```js
function sqrtNewton(n) {
  if (n <= 0) return n;

  let res;
  let last;
  const DIGIT_COUNT = 10;
  const PRECISION = Math.pow(0.1, DIGIT_COUNT);

  res = n;

  while (Math.abs(last - res) > PRECISION) {
    last = res;
    res = (res + n / res) / 2;
  }

  return res;
}
```

## deliver-medicine

- 题目链接：无
- tag：`logic`

### 题目描述

```
A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？

```

### 参考答案

把药放在箱子，用自己的锁把箱子锁上。B 拿到箱子后，再在箱子上加一把自己的锁。箱子运回 A 后，A 取下自己的锁。箱子再运到 B 手中时，B 取下自己的锁，获得药物。

## longest-univalue-path

- 题目链接：https://leetcode.com/problems/longest-univalue-path/
- tag：`recursive` `tree`

### 题目描述

```
Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.

The length of path between two nodes is represented by the number of edges between them.



Example 1:

Input:

              5
             / \
            4   5
           / \   \
          1   1   5
Output: 2



Example 2:

Input:

              1
             / \
            4   5
           / \   \
          4   4   5
Output: 2



Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.

```

### 参考答案

```js
/*
 * @lc app=leetcode id=687 lang=javascript
 *
 * [687] Longest Univalue Path
 */

// 返回经过root的且只能取左右一个节点的路径长度
function helper(node, res) {
  if (node === null) return 0;
  const l = helper(node.left, res);
  const r = helper(node.right, res);
  let lcnt = 0;
  let rcnt = 0;
  if (node.left && node.val === node.left.val) lcnt = lcnt + l + 1;
  if (node.right && node.val === node.right.val) rcnt = rcnt + r + 1;

  res.max = Math.max(res.max, lcnt + rcnt);

  return Math.max(lcnt, rcnt);
}
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function(root) {
  const res = {
    max: 0,
  };
  helper(root, res);
  return res.max;
};
```

## 赛马问题

- 题目链接：无
- tag：`dAc`

### 题目描述

```

有25匹马，速度都不同，但每匹马的速度都是定值。现在只有5条赛道，无法计时，即每赛一场最多只能知道5匹马的相对快慢。
问最少赛几场可以找出25匹马中速度最快的前3名？

```

### 参考答案

七次。

由于每一匹马我们都需要比赛才行，因此至少先比赛 25 / 5 = 5 次，
然后我们可以选择出来每一组的第一名，也就是一共 5 匹马，再进行一次比赛。这个时候跑第一名的一定是总体第一名。

我们来总结一下，这个时候我们已经决出了第一名，并且比赛了 6 次。

让我们来分析一下， 假如第六场比赛从第一名到第五名我们依次给其在第一场比赛的场次进行编队为 A B C D E。

那么 D E 所在的一共 5 + 5 = 10 匹马是没有比赛的必要的， 不可能是前三。

C 中的只有第一名可能是前三，其他四个我们可以直接舍弃。

B 中有可能前三的只有一二名。

A 中的二三名也可能是前三。

那么我们只需要把有可能成为前三的 A 中的 2 个， B 中的一个， 以及 C 中 一个 比一下就好了。五个刚好需要一次。

因此一共需要七次。

我们从分治的角度考虑一下， 也就是说怎么将其抽象为一般问题，就是转化为程序。

将原问题表示为 f， 那么 f(25, 5, 3) 表示 25 匹马，5 个跑道，决出前三。

那么原问题可以转化为：

```
f(25, 5, 3) = 25 / 5 + f(5,5,1) + f(5,5,2)

```

那么如果换成 10 匹马：

```
f(10, 5, 3) = 10 / 5 + f(5,5,1) + f(4,5,2)

```

更为精确的代码我就不写了，大家可以自己思考一下。

- 题目链接：无
- tag：`math`

### 题目描述

```

12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。

```

### 参考答案

3 次。

我们先来分析一下：

由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，
根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。
如此一来的话一次称量就可以将答案的可能性缩减为原来的 1/3，三次就能缩减为 1/27。而总共才有 24 种可能性，所以理论上是完全可以 3 次称出来的。

这个题目解释起来比较费劲，我在网上找了一个现成的图来解释一下：

![weight-ball](../assets/daily/weight-ball.jpg)

图中“1+”是指“1 号小球为重”这一可能性。“1-”是指“1 号小球为轻”这一可能性。
一开始一共有 24 种可能性。

4、4 称了之后不管哪种情况(分支)，剩下来的可能性总是 4 种。这是一个完美的三分。

然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支 1 上的第二次称法，即“1、2、6 对 3、4、5”这种称法，天平输出三种结果的可能性是均等的(严格来说是几乎均等)。

这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的 1/3。
