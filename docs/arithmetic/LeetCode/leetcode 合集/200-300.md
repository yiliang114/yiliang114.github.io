---
layout: CustomPages
title: 合集 200-300
date: 2020-09-04
aside: false
draft: true
---

### 202.

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  let slow = n,
    fast = n;

  do {
    slow = digitSquareSum(slow);
    fast = digitSquareSum(fast);
    fast = digitSquareSum(fast);
  } while (slow != fast);

  return slow == 1;
};

function digitSquareSum(n) {
  let numStr = n + '';
  let sum = 0;
  for (let val of numStr) {
    sum += parseInt(val) * parseInt(val);
  }
  return sum;
}

isHappy(19);
```

### 204.

```js
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  let notPrime = new Array(n);
  notPrime.fill(false);
  let count = 0;
  for (let i = 2; i < n; i++) {
    if (!notPrime[i]) {
      count++;
      for (let j = 2; i * j < n; j++) {
        notPrime[i * j] = true;
      }
    }
  }
  return count;
};
```

### 206.

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

### 207.

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
  var courses = new Array(numCourses),
    visited = new Array(numCourses),
    preLen = prerequisites.length,
    flag = true,
    temp;

  visited.fill(false);
  courses.fill(undefined);
  for (let key in courses) {
    courses[key] = [];
  }

  for (let cur in prerequisites) {
    temp = prerequisites[cur];
    courses[temp[0]].push(temp[1]);
  }

  for (let key in courses) {
    if (flag && !visited[key]) {
      visited[key] = true;
      map = new Array(numCourses);
      map.fill(false);
      dfs(key, map);
    }
  }

  return flag;

  function dfs(index, map) {
    if (!flag) return;

    visited[index] = true;

    if (map[index]) {
      flag = false;
      return;
    }

    for (let key in courses[index]) {
      map[index] = true;
      dfs(courses[index][key], map);
      map[index] = false;
    }
  }
};
```

### 208.

```js
/**
 * Initialize your data structure here.
 */
var Trie = function() {
  this.root = {};
};

/**
 * Inserts a word into the trie.
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
  let node = this.root;
  word.split('').forEach(char => {
    if (!node[char]) node[char] = {};
    node = node[char];
  });
  node.isEnd = true;
};

/**
 * Returns if the word is in the trie.
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
  let node = this.root;
  for (let i = 0; i < word.length; i++) {
    const char = word[i];

    if (node[char]) {
      node = node[char];
    } else {
      return false;
    }
  }
  return !!node.isEnd;
};

/**
 * Returns if there is any word in the trie that starts with the given prefix.
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
  let node = this.root;
  for (let i = 0; i < prefix.length; i++) {
    const char = prefix[i];

    if (node[char]) {
      node = node[char];
    } else {
      return false;
    }
  }
  return true;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = Object.create(Trie).createNew()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

const trie = new Trie();
trie.search('a');
```

### 210.

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
  // edge case
  if (!numCourses || numCourses === 0) {
    return [];
  }

  // calculate in-degree and edges
  let inDegree = {}; // 要学习的数量
  let edges = {}; // 学习条件
  for (let i = 0; i < numCourses; i++) {
    inDegree[i] = 0;
    edges[i] = [];
  }
  for (let i = 0; i < prerequisites.length; i++) {
    inDegree[prerequisites[i][0]]++;
    edges[prerequisites[i][1]].push(prerequisites[i][0]);
  }

  // find root(s)
  let queue = [];
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }

  // BFS
  let res = [];
  while (queue.length > 0) {
    let node = queue.shift();
    res.push(node);
    for (let i = 0; i < edges[node].length; i++) {
      let nextNode = edges[node][i];
      inDegree[nextNode]--;
      if (inDegree[nextNode] === 0) {
        queue.push(nextNode);
      }
    }
  }

  // check
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] > 0) {
      return [];
    }
  }

  return res;
};
```

### 212.

LeetCode 第 212 题：给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。

![](http://s0.lgstatic.com/i/image2/M01/90/B0/CgoB5l2ILXyAYLwPAAAO6ajgsHk324.png)

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

说明：你可以假设所有输入都由小写字母 `a-z` 组成。

### 解题思路

这是一道出现较为频繁的难题，题目给出了一个二维的字符矩阵，然后还给出了一个字典，现在要求在这个字符矩阵中找到出现在字典里的单词。

由于字符矩阵的每个点都能作为一个字符串的开头，所以必须得尝试从矩阵中的所有字符出发，上下左右一步步地走，然后去和字典进行匹配，如果发现那些经过的字符能组成字典里的单词，就把它记录下来。

可以借用深度优先的算法来实现(关于深度优先算法，将在第 06 节课深入探讨)，如果你对它不熟悉，可以把它想象成走迷宫。

![](http://s0.lgstatic.com/i/image2/M01/90/CD/CgoB5l2IShaAfIDFAAElACD4d7I232.png)

**字典匹配的解法 1**：每次都循环遍历字典，看看是否存在字典里面，如果把输入的字典变为哈希集合的话，似乎只需要 O(1) 的时间就能完成匹配。

但是，这样并不能进行前缀的对比，即，必须每次都要进行一次全面的深度优先搜索，或者搜索的长度为字典里最长的字符串长度，这样还是不够高效。

**字典匹配的解法 2**：对比字符串的前缀，借助前缀树来重新构建字典。

假如在矩阵里遇到了一个字符”V”，而字典里根本就没有以“V”开头的字符串，则不需要将深度优先搜索进行下去，可以大大地提高搜索效率。

构建好了前缀树之后，每次从矩阵里的某个字符出发进行搜索的时候，同步地对前缀树进行对比，如果发现字符一直能被找到，就继续进行下去，一步一步地匹配，直到在前缀树里发现一个完整的字符串，把它输出即可。

```js
let hasWord = false;

var findWords = function(board, words) {
  var ans = [];
  for (let word of words) {
    for (let j = 0; j < board.length; j++) {
      for (let i = 0; i < board[0].length; i++) {
        if (board[j][i] == word[0]) {
          hasWord = false;
          DFS(word, board, 0, j, i, '');
          if (hasWord) {
            if (!ans.includes(word)) ans.push(word);
          }
        }
      }
    }
  }
  return ans;
};

function DFS(word, board, index, j, i, subStr) {
  if (word[index] == board[j][i]) {
    subStr += board[j][i];
    board[j][i] = '*';
    if (j < board.length - 1) DFS(word, board, index + 1, j + 1, i, subStr);
    if (j > 0) DFS(word, board, index + 1, j - 1, i, subStr);
    if (i < board[0].length - 1) DFS(word, board, index + 1, j, i + 1, subStr);
    if (i > 0) DFS(word, board, index + 1, j, i - 1, subStr);
    board[j][i] = word[index];
  }
  if (index >= word.length || subStr == word) {
    hasWord = true;
  }
}

findWords([['a']], ['a']);
```

### 215.

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  for (let i = 0; i <= k; i++) {
    let max = i;
    for (let j = i; j < nums.length; j++) {
      if (nums[j] > nums[max]) max = j;
    }
    swap(nums, i, max);
  }
  return nums[k - 1];
};

function swap(arr, a, b) {
  let tmp = arr[a];
  arr[a] = arr[b];
  arr[b] = tmp;
}

findKthLargest([3, 2, 1, 5, 6, 4], 2);
```

### 218.

```js
/**
 * @param {number[][]} buildings
 * @return {number[][]}
 */
var getSkyline = function(buildings) {
  const heights = [];
  const result = [];
  for (let item of buildings) {
    heights.push([item[0], -item[2]]);
    heights.push([item[1], item[2]]);
  }
  heights.sort((a, b) => {
    if (a[0] == b[0]) return a[1] - b[1];
    else return a[0] - b[0];
  });
  let maxStack = [0];
  let preHeight = 0;
  for (let h of heights) {
    if (h[1] < 0) {
      maxStack.push(-h[1]);
    } else {
      for (let i = 0; i < maxStack.length; i++) {
        if (maxStack[i] == h[1]) {
          maxStack.splice(i, 1);
          break;
        }
      }
    }
    let curHeight = Math.max(...maxStack);
    if (preHeight != curHeight) {
      result.push([h[0], curHeight]);
      preHeight = curHeight;
    }
  }
  return result;
};

console.log(
  getSkyline([
    [2, 9, 10],
    [3, 7, 15],
    [5, 12, 12],
    [15, 20, 10],
    [19, 24, 8],
  ]),
);
```

### 227.

```js
var calculate = function(s) {
  return s
    .replace(/-/g, '+-')
    .split('+')
    .reduce((sum, s) => sum + mult(s), 0);
};

function mult(s) {
  let ops = '*' + s.replace(/[\d -]+/g, '');
  if (ops.length === 1) return parseInt(s);
  return s.split(/[*\/]/g).reduce((a, b, i) => (ops[i] === '*' ? a * b : (a ^ b) > 0 ? ~~(a / b) : -~~(-a / b)), 1);
}

/**
 * TODO 此题我的方案又 TLE 了
 * 所以先看了看别人的方案，之后重新搞一遍。
 */
```

### 230.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  const leftCount = getNodeLength(root.left);
  if (k < leftCount + 1) {
    return kthSmallest(root.left, k);
  } else if (k > leftCount + 1) {
    return kthSmallest(root.right, k - leftCount - 1);
  }
  return root.val;
};

function getNodeLength(node) {
  if (node == null) return 0;
  return 1 + getNodeLength(node.left) + getNodeLength(node.right);
}

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

const node = new TreeNode(1);
node.right = new TreeNode(2);

kthSmallest(node, 2);
```

### 234.

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  let fast = head,
    slow = head;
  while (fast != null) {
    slow = slow.next;
    fast = fast.next.next;
  }
  slow = reverseList(slow);
  while (slow != null) {
    if (slow.val != head.val) return false;
    slow = slow.next;
    head = head.next;
  }
  return true;
};

var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

### 235.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (root == null || root == p || root == q) return root;
  let left = lowestCommonAncestor(root.left, p, q);
  let right = lowestCommonAncestor(root.right, p, q);
  return left == null ? right : right == null ? left : root;
};
```

### 237.

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
  node.val = node.next.val;
  node.next = node.next.next;
};
```

### 238.

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  const n = nums.length;
  const res = new Array(n);
  res[0] = 1;
  // 每个数字的左边乘积
  for (let i = 1; i < n; i++) {
    // nums = [ 1, 2, 3, 4 ] => res = [ 1, 1, 2, 6 ]
    res[i] = res[i - 1] * nums[i - 1];
  }
  // 每个数字的右边乘积
  let right = 1;
  for (let i = n - 1; i >= 0; i--) {
    // nums = [ 1, 2, 3, 4 ] => res = [ 1, 1, 2, 6 ]
    res[i] *= right; // 6 8 12 24
    right *= nums[i]; // 4 12 24 24
  }
  return res;
};
```

### 239.

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
  if (nums.length == 0) return [];
  const ans = [];

  let firstArr = nums.slice(0, k);
  let max = Math.max(...firstArr);
  ans.push(max);
  for (let i = k; i < nums.length; i++) {
    if (nums[i] > max) {
      max = nums[i];
    } else if (nums[i - k] == max) {
      let arr = nums.slice(i - k + 1, i + 1);
      max = Math.max(...arr);
    }
    ans.push(max);
  }
  return ans;
};

maxSlidingWindow([1, 3, 1, 2, 0, 5], 3);
```

### 240.

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  if (matrix.length == 0) return false;
  let row = 0,
    col = matrix[0].length - 1;
  while (true) {
    if (matrix[row][col] > target && col > 0) {
      col--;
    } else if (matrix[row][col] < target && row < matrix.length - 1) {
      row++;
    } else if (matrix[row][col] == target) {
      return true;
    } else {
      break;
    }
  }
  return false;
};
```

### 242.

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
  const arr = new Array(26);
  arr.fill(0);
  for (let c of s) {
    arr[c.charCodeAt() - 'a'.charCodeAt()]++;
  }
  for (let c of t) {
    arr[c.charCodeAt() - 'a'.charCodeAt()]--;
  }
  for (let item of arr) {
    if (item != 0) return false;
  }
  return true;
};
```

### 268.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
  let num = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0) continue;
    let min = i;
    for (let j = i; j < nums.length; j++) {
      if (nums[j] < nums[min] && nums[j] >= 0) min = j;
    }
    if (nums[min] == num) num++;
    else return num;
    swap(nums, i, min);
  }
  return num;
};

function swap(nums, a, b) {
  let tmp = nums[a];
  nums[a] = nums[b];
  nums[b] = tmp;
}

missingNumber([3, 0, 1]);
```

### 279.

```js
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  let dp = new Array(n + 1);
  dp.fill(Number.MAX_VALUE);
  dp[0] = 0;
  for (let i = 0; i <= n; i++) {
    for (let j = 1; i + j * j <= n; j++) {
      dp[i + j * j] = Math.min(dp[i + j * j], dp[i] + 1);
    }
  }
  return dp[n];
};
```

### 283.

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
  let i = 0;
  len = nums.length;
  while (i < len) {
    if (nums[i] == 0) {
      nums.splice(i, 1);
      nums.push(0);
      len--;
    } else {
      i++;
    }
  }
};
```

### 287.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  let set = new Set();
  for (let num of nums) {
    if (set.has(num)) return num;
    set.add(num);
  }
  return -1;
};
```

### 289.

```js
/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var gameOfLife = function(board) {
  if (board == null || board.length == 0) return;
  let m = board.length,
    n = board[0].length;
  // 计算当前和下一个状态(二进制)
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 获取周围存活细胞数量
      let lives = liveNeighbors(board, m, n, i, j);

      // 在开始阶段，每个下一阶段的二进制都为 0;
      // 所以我们只要关心什么时候下一阶段的二进制值会变为 1。
      if (board[i][j] == 1 && lives >= 2 && lives <= 3) {
        board[i][j] = 3; // 01 -> 11
      }
      if ((board[i][j] = 0 && lives == 3)) {
        board[i][j] = 2; // 00 -> 10
      }
    }
  }
  // 变为第二状态
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      board[i][j] >>= 1;
    }
  }
};

function liveNeighbors(board, m, n, i, j) {
  let lives = 0;
  for (let x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {
    for (let y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {
      lives += board[x][y] & 1;
    }
  }
  lives -= board[i][j] & 1;
  return lives;
}
```

### 295.

```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
  this.arr = [];
};

/**
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
  let index = binarySearch(this.arr, num, 0, this.arr.length);
  this.arr.splice(index, 0, num);
};

function binarySearch(arr, val, lo, hi) {
  if (hi < lo) return lo;
  let mid = lo + parseInt((hi - lo) / 2);
  console.log('范围', lo + '-' + hi);
  console.log('中间值', mid + ':' + arr[mid]);
  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
  if (this.arr.length % 2 == 0) {
    let mid = this.arr.length / 2;
    return (this.arr[mid - 1] + this.arr[mid]) / 2;
  } else {
    let mid = (this.arr.length - 1) / 2;
    return this.arr[mid];
  }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = Object.create(MedianFinder).createNew()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

const mf = new MedianFinder();
mf.addNum(-1);
mf.findMedian();
mf.addNum(-2);
mf.findMedian();
mf.addNum(-3);
mf.findMedian();
mf.addNum(-4);
mf.findMedian();
```

### 297.

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
  if (!root) return '[]';
  var queue = [];
  var ans = [];
  queue.push(root);
  while (queue.length !== 0) {
    var node = queue.shift();
    if (node === null) {
      ans.push(null);
      continue;
    }
    ans.push(node.val);
    if (node.left) queue.push(node.left);
    else queue.push(null);
    if (node.right) queue.push(node.right);
    else queue.push(null);
  }
  ans = sanitize(ans);
  var ansStr = '';
  ansStr += '[';
  for (var i = 0; i < ans.length; i++) {
    if (ans[i] === null) ansStr += 'null' + ',';
    else ansStr += ans[i] + ',';
  }
  ansStr = ansStr.slice(0, -1);
  ansStr += ']';
  return ansStr;
};

function sanitize(ans) {
  var lastcharIndex = -1;
  for (var i = 0; i < ans.length; i++) {
    if (ans[i] !== null) {
      lastcharIndex = i;
    }
  }
  var newArray = [];
  for (var j = 0; j <= lastcharIndex; j++) {
    newArray.push(ans[j]);
  }
  return newArray;
}

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
  if (data.length === 0) return null;
  var values = data.substring(1, data.length - 1).split(',');
  if (!values[0]) {
    return null;
  }
  var val = values.shift();
  var root = new TreeNode(parseInt(val));
  var queue = [];
  queue.push(root);
  while (queue.length !== 0) {
    let node = queue.shift();
    let val = values.shift();
    node.left = !isNaN(parseInt(val)) ? new TreeNode(parseInt(val)) : null;
    val = values.shift();
    node.right = !isNaN(parseInt(val)) ? new TreeNode(parseInt(val)) : null;
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }
  return root;
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */

/**
 * 二叉树的序列化和反序列化
 * 通过BFS来实现
 */
```

### 300.

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  if (nums.length == 0) {
    return 0;
  }
  let dp = new Array(nums.length);
  dp[0] = 1;
  let maxans = 1;
  for (let i = 1; i < dp.length; i++) {
    let maxval = 0;
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        maxval = Math.max(maxval, dp[j]);
      }
    }
    dp[i] = maxval + 1;
    maxans = Math.max(maxans, dp[i]);
  }
  return maxans;
};
```

### 202-Happy-Number

```js
/**
 * https://leetcode.com/problems/happy-number/description/
 * Difficulty:Easy
 *
 * Write an algorithm to determine if a number is "happy".
 * A happy number is a number defined by the following process: Starting with any positive integer,
 * replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),
 * or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.
 *
 * Example: 19 is a happy number
 *
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */

/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  var results = [n];

  while (true) {
    n = squareSumOfDigits(n);
    // console.log(n);
    if (n === 1) return true;
    if (results.indexOf(n) > -1) return false;
    results.push(n);
  }
};

function squareSumOfDigits(n) {
  var sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

console.log(isHappy(1));
console.log(isHappy(19));
```

### 202.happy-number

```js
/*
 * @lc app=leetcode id=202 lang=javascript
 *
 * [202] Happy Number
 *
 * https://leetcode.com/problems/happy-number/description/
 *
 * algorithms
 * Easy (44.36%)
 * Total Accepted:    227.2K
 * Total Submissions: 505.7K
 * Testcase Example:  '19'
 *
 * Write an algorithm to determine if a number is "happy".
 *
 * A happy number is a number defined by the following process: Starting with
 * any positive integer, replace the number by the sum of the squares of its
 * digits, and repeat the process until the number equals 1 (where it will
 * stay), or it loops endlessly in a cycle which does not include 1. Those
 * numbers for which this process ends in 1 are happy numbers.
 *
 * Example:
 *
 *
 * Input: 19
 * Output: true
 * Explanation:
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */
function squareSum(n) {
  let sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

function isHappyWithMapper(n, visited) {
  if (n === 1) return true;
  if (visited[n]) return false;
  visited[n] = true;

  return isHappyWithMapper(squareSum(n), visited);
}
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  const visited = {};

  return isHappyWithMapper(n, visited);
};
```

### 203

```js
// Remove all elements from a linked list of integers that have value val.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
export default function removeElements(head, val) {
  if (head === null) return null;
  let prev = null;
  let curr = head;
  let next = null;
  let hasHead = false;
  while (curr) {
    next = curr.next;
    if (curr.val === val) {
      // delete
      curr = null;
      // join links
      if (prev) prev.next = next;
    } else {
      prev = curr;
      if (!hasHead) {
        head = curr;
        hasHead = true;
      }
    }
    curr = next;
  }
  if (!prev) head = null;
  return head;
}
```

### 204-Count-Primes

```js
/**
 * https://leetcode.com/problems/count-primes/description/
 * Difficulty:Easy
 *
 * Description:
 * Count the number of prime numbers less than a non-negative number, n.
 */

/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  if (n < 3) return 0;
  var cnt = 0;
  var p = new Array(n + 1).fill(1);
  p[1] = 0;
  for (var i = 2; i < n; i++) {
    if (p[i]) {
      cnt++;
      for (var j = i * 2; j <= n; j += i) {
        p[j] = 0;
      }
    }
  }
  // console.log(p);
  return cnt;
};

console.log(countPrimes(3));
console.log(countPrimes(4));
console.log(countPrimes(21));
console.log(countPrimes(27));
console.log(countPrimes(31));
```

### 204.count-primes

```js
/*
 * @lc app=leetcode id=204 lang=javascript
 *
 * [204] Count Primes
 *
 * https://leetcode.com/problems/count-primes/description/
 *
 * algorithms
 * Easy (28.33%)
 * Total Accepted:    229.8K
 * Total Submissions: 798.7K
 * Testcase Example:  '10'
 *
 * Count the number of prime numbers less than a non-negative number, n.
 *
 * Example:
 *
 *
 * Input: 10
 * Output: 4
 * Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
 *
 *
 */
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  // tag: 数论
  // if (n <= 2) return 0;
  // let compositionCount = 0;
  // for(let i = 3; i < n; i++) {
  //     for(let j = i - 1; j > 1 ; j--) {
  //         if (i % j === 0) {
  //             compositionCount++;
  //             break; // 找到一个就可以证明它不是质数了
  //         }
  //     }
  // }
  // return n - compositionCount - 2; // 需要减去1和n这两个数字

  // 上面的方法会超时，因此我们需要进行优化
  // 数学角度来看，如果一个数字可以分解为两个数字相乘(这两个数字不包括0和它本身)，那么它就是合数
  const compositions = []; // compositions[i] 表示i是否是合数
  let count = 0;
  for (let i = 2; i < n; i++) {
    if (!compositions[i]) count++;
    for (let j = 2; i * j < n; j++) {
      compositions[i * j] = true;
    }
  }

  return count;
};
```

### 206.反转链表

```js
/*
 * @lc app=leetcode.cn id=206 lang=javascript
 *
 * [206] 反转链表
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  const l1 = new ListNode(null);
  if (!head) return l1;

  // 收集到数组
  const result = [];
  while (head !== null) {
    result.push(head.val);
    head = head.next;
  }
  // result.push(head.val)

  // 重新创建一个链表
  let cur = l1;

  for (let i = result.length - 1; i >= 0; i--) {
    cur.next = new ListNode(result[i]);
    cur = cur.next;
  }

  return l1.next;
};

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let head = new ListNode(null);
  const guard = head;
  if (arr.length === 0) return guard;
  for (let i = 0; i < arr.length; i++) {
    let temp = new ListNode(arr[i]);
    head.next = temp;
    head = temp;
  }
  return guard.next;
}

function ListNodeToString(listNode) {
  let resp = '';
  let cur = listNode;
  while (cur.next) {
    resp += `${cur.val} -> `;
    cur = cur.next;
  }
  if (cur.val) resp += `${cur.val}`;
  console.log(resp);
}

const l1 = List([1, 2, 3]);
// ListNodeToString(l1)
const l2 = reverseList(l1);
ListNodeToString(l2);

const l3 = List([]);
ListNodeToString(l3);
const l4 = reverseList(l3);
ListNodeToString(l4);

// Wrong Answer
// ✘ 26 / 27 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: [0]
// ✘ expected_answer: []
// ✘ stdout:
```

### 215.数组中的第 k 个最大元素

```js
/*
 * @lc app=leetcode.cn id=215 lang=javascript
 *
 * [215] 数组中的第K个最大元素
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
// 最简单方法。。。
var findKthLargest = function(nums, k) {
  // nums = Array.from(new Set(nums)).sort()
  // 注意如果单纯是 nums.sort() 函数执行的话，会进行字典升序
  nums = nums.sort((a, b) => a - b);
  console.log(nums);
  return nums[nums.length - k];
};

console.log(findKthLargest([3, 2, 1, 5, 6, 4], 2));
console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4));
console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6, 7, 7, 8, 2, 3, 1, 1, 1, 10, 11, 5, 6, 2, 4, 7, 8, 5, 6], 2));
```

### 217-Contains-Duplicate

```js
/**
 * https://leetcode.com/problems/contains-duplicate/description/
 * Difficulty:Easy
 *
 * Given an array of integers, find if the array contains any duplicates.
 * Your function should return true if any value appears at least twice in the array,
 * and it should return false if every element is distinct.
 */

/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  var map = {};
  for (var i = 0; i < nums.length; i++) {
    var n = nums[i];
    if (map[n]) return true;
    map[n] = 1;
  }
  return false;
};
console.log(containsDuplicate([3, 4]));
```

### 217.contains-duplicate

```js
/*
 * @lc app=leetcode id=217 lang=javascript
 *
 * [217] Contains Duplicate
 *
 * https://leetcode.com/problems/contains-duplicate/description/
 *
 * algorithms
 * Easy (50.92%)
 * Total Accepted:    324K
 * Total Submissions: 628.5K
 * Testcase Example:  '[1,2,3,1]'
 *
 * Given an array of integers, find if the array contains any duplicates.
 *
 * Your function should return true if any value appears at least twice in the
 * array, and it should return false if every element is distinct.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,1]
 * Output: true
 *
 * Example 2:
 *
 *
 * Input: [1,2,3,4]
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: [1,1,1,3,3,4,3,2,4,2]
 * Output: true
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  // 1. 暴力两层循环两两比较， 时间复杂度O(n^2) 空间复杂度O(1)

  // 2. 先排序，之后比较前后元素是否一致即可，一层循环即可，如果排序使用的比较排序的话时间复杂度O(nlogn) 空间复杂度O(1)

  // 3. 用hashmap ，时间复杂度O(n) 空间复杂度O(n)
  const visited = {};
  for (let i = 0; i < nums.length; i++) {
    if (visited[nums[i]]) return true;
    visited[nums[i]] = true;
  }
  return false;
};
```

### 226.Invert-Binary-Tree

```js
/**
 * https://leetcode.com/problems/invert-binary-tree/description/
 * Difficulty:Easy
 *
 * Invert a binary tree.
 *      4
 *    /   \
 *   2     7
 *  / \   / \
 * 1   3 6   9
 *
 * to
 *
 *       4
 *     /   \
 *   7     2
 *  / \   / \
 * 9   6 3   1
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
  if (!root) return root;
  if (!root.left && !root.right) return root;
  var left = invertTree(root.right);
  var right = invertTree(root.left);
  root.left = left;
  root.right = right;
  return root;
};

function invertTree1(root) {
  if (!root) return root;
  const { left, right } = root;
  root.left = right;
  root.right = left;
  invertTree1(root.left);
  invertTree1(root.right);
  return root;
}

// console.log(invertTree({
//   val: 4,
//   left: {
//     val: 2,
//     left: {
//       val: 1,
//       left: null,
//       right: null,
//     },
//     right: null
//   },
//   right: null
// }));
```

### 227-Basic-Calculator-II

```js
/**
 * https://leetcode.com/problems/basic-calculator-ii/description/
 * Difficulty:Medium
 *
 * Implement a basic calculator to evaluate a simple expression string.
 * The expression string contains only non-negative integers, +, -, *, / operators and
 * empty spaces . The integer division should truncate toward zero.
 * You may assume that the given expression is always valid.
 *
 * Some examples:
 *
 * "3+2*2" = 7
 * " 3/2 " = 1
 * " 3+5 / 2 " = 5
 *
 * Note: Do not use the eval built-in library function.
 */

/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  var operand = [];
  var operator = [];
  var lastIsNum = false;

  var arr = [];
  for (var i = 0; i < s.length; i++) {
    var ch = s[i];
    if (ch === ' ') continue;

    if (['+', '-', '*', '/'].indexOf(ch) > -1) {
      arr.push(ch);
      lastIsNum = false;
    } else {
      ch = parseInt(ch);
      if (lastIsNum && arr.length) {
        var last = arr.pop();
        arr.push(last * 10 + ch);
      } else {
        arr.push(ch);
      }
      lastIsNum = true;
    }
  }

  // console.log(arr);
  for (var i = 0; i < arr.length; i++) {
    var ch = arr[i];

    if (['+', '-', '*', '/'].indexOf(ch) > -1) {
      operator.push(ch);
      continue;
    }
    if (operator.length) {
      var op = operator.pop();
      if (op === '*' || op === '/') {
        var last = operand.pop();
        if (op === '*') {
          operand.push(last * ch);
        } else {
          operand.push(Math.floor(last / ch));
        }
      } else {
        operator.push(op);
        operand.push(ch);
      }
    } else {
      operand.push(ch);
    }
  }
  // console.log(operand);
  // console.log(operator);

  var i = 1;
  var j = 0;
  var res = operand[0];
  while (i < operand.length && j < operator.length) {
    var a = operand[i++];
    var op = operator[j++];
    // console.log(a, op, b);
    if (op === '+') {
      res = res + a;
    } else {
      res = res - a;
    }
  }

  return res;
};

console.log(calculate('1/1'));
console.log(calculate('1-1+1'));
console.log(calculate('1+1-1'));
console.log(calculate('42'));
console.log(calculate('12*12'));
console.log(calculate('3+2*2'));
console.log(calculate(' 3/2 '));
console.log(calculate(' 3+5 / 2 '));
```

### 227.basic-calculator-ii

```js
/*
 * @lc app=leetcode id=227 lang=javascript
 *
 * [227] Basic Calculator II
 */
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  // "3+2*2"
};
```

### 229.求众数-ii

```js
/*
 * @lc app=leetcode.cn id=229 lang=javascript
 *
 * [229] 求众数 II
 * 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例 1:

输入: [3,2,3]
输出: [3]
示例 2:

输入: [1,1,1,3,3,2,2,2]
输出: [1,2]
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  if (nums.length === 0) return [];
  const result = [],
    targetNum = parseInt(nums.length / 3),
    map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > targetNum) {
        result.push(map[key]);
      }
    }
  }
  return result;
};

// console.log(majorityElement())
```

### 232

```js
/**
 * Initialize your data structure here.
 */
export default class StackQueue {
  constructor() {
    this.tmpStack = [];
    this.stack = [];
  }

  /**
   * Push element x to the back of queue.
   * @param {number} x
   * @return {void}
   */
  push(x) {
    this.stack.push(x);
  }

  /**
   * Removes the element from in front of queue and returns that element.
   * @return {number}
   */
  pop() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      const item = this.stack.pop();
      return item;
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const item = this.stack.pop();
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Get the front element.
   * @return {number}
   */
  peek() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      return this.stack[0];
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const [item] = this.stack;
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Returns whether the queue is empty.
   * @return {boolean}
   */
  empty() {
    return this.stack.length === 0;
  }
}

/**
 * Initialize your data structure here.
 */
class StackQueueFast {
  constructor() {
    this.tmpStack = [];
    this.stack = [];
  }

  /**
   * Push element x to the back of queue.
   * @param {number} x
   * @return {void}
   */
  push(x) {
    this.stack.push(x);
  }

  /**
   * Removes the element from in front of queue and returns that element.
   * @return {number}
   */
  pop() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      const item = this.stack.pop();
      return item;
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const item = this.stack.pop();
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Get the front element.
   * @return {number}
   */
  peek() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      return this.stack[0];
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const [item] = this.stack;
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Returns whether the queue is empty.
   * @return {boolean}
   */
  empty() {
    return this.stack.length === 0;
  }
}
```

### 232.用栈实现队列

```js
/*
 * @lc app=leetcode.cn id=232 lang=javascript
 *
 * [232] 用栈实现队列
 * 使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
示例:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
说明:

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque(双端队列)来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 (例如，一个空的队列不会调用 pop 或者 peek 操作)。
 */
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
  this.stack = [];
  this.length = 0;
};

/**
 * Push element x to the back of queue.
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
  this.stack.push(x);
  this.length++;
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
  if (this.length) {
    this.length--;
    return this.stack.shift();
  }
  return undefined;
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
  if (this.length) return this.stack[0];
  return undefined;
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
  return this.length === 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */

// const queue = new MyQueue();

// queue.push(1);
// queue.push(2);
// console.log(queue.peek()) // 返回 1
// console.log(queue.pop())  // 返回 1
// console.log(queue.empty()) // 返回 false

// ✘ Wrong Answer
// ✘ 12 / 17 cases passed(N / A)
// ✘ testcase: '["MyQueue","push","pop","empty"]\n[[],[1],[],[]]'
// ✘ answer: [null, null, 1, false]
// ✘ expected_answer: [null, null, 1, true]
// ✘ stdout:
```

### 235

```js
// 235. Lowest Common Ancestor of a Binary Search Tree

// Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

// According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

// Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

// Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
// Output: 6
// Explanation: The LCA of nodes 2 and 8 is 6.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */

const dfs = (root, p, q, path, paths) => {
  if (!root) return;
  path.push(root);
  if (root.val === p.val || root.val === q.val) paths.push([...path]);
  if (root.left) dfs(root.left, p, q, [...path], paths);
  if (root.right) dfs(root.right, p, q, [...path], paths);
};

export default function lowestCommonAncestor(root, p, q) {
  const paths = [];
  dfs(root, p, q, [], paths);
  let [a, b] = paths;
  b = new Set(b);
  a = a.reverse();
  for (let i = 0; i < a.length; i++) {
    if (b.has(a[i])) return a[i];
  }
  return -1;
}
```

### 257

```js
// See https://leetcode.com/problems/binary-tree-paths/

const getPaths = (root, paths, parent) => {
  if (root === null) return;
  // Clone
  parent = [...parent];
  // Push node value
  parent.push(root.val);
  if (root.left) getPaths(root.left, paths, parent);
  if (root.right) getPaths(root.right, paths, parent);
  if (!root.left && !root.right) paths.push(parent.join('->'));
};

const binaryTreePaths = function(root) {
  const paths = [];
  const parent = [];
  getPaths(root, paths, parent);
  return paths;
};
```

### 258-Add-Digits

```js
/**
 * https://leetcode.com/problems/add-digits/description/
 * Difficulty:Easy
 *
 * Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
 * For example:
 * Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
 * Follow up:
 * Could you do it without any loop/recursion in O(1) runtime?
 *
 */

/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {
  if (num < 10) return num;
  return addDigits(sum(num));
};

function sum(num) {
  return ('' + num).split('').reduce((a, b) => a + parseInt(b), 0);
}

console.log(addDigits(38));
```

### 263-Ugly-Number

```js
/**
 *
 * https://leetcode.com/problems/ugly-number/#/description
 * Difficulty:Easy
 *
 * Write a program to check whether a given number is an ugly number.
 *
 * Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
 *
 * For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
 *
 * Note that 1 is typically treated as an ugly number.
 */

/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
  if (num <= 0) return false;
  if (num == 1) return true;

  while (num > 1) {
    var old = num;
    if (!(num % 2)) num = num / 2;
    if (!(num % 3)) num = num / 3;
    if (!(num % 5)) num = num / 5;
    if (old === num) return false;
  }
  return true;
};

console.log(isUgly(6) === true);
console.log(isUgly(8) === true);
console.log(isUgly(14) === false);
```

### 287.find-the-duplicate-number

```js
/*
 * @lc app=leetcode id=287 lang=javascript
 *
 * [287] Find the Duplicate Number
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // Input: [1,3,4,2,2]
  // Output: 2
  // TODO: 冒泡、选择、插入是否都可以？ 不需要全部都排序完成之后就可以知道前后的值是否相等啦！
  nums.sort();

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) return nums[i];
  }
};
```

### 287.寻找重复数

```js
/*
 * @lc app=leetcode.cn id=287 lang=javascript
 *
 * [287] 寻找重复数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // 1 - n 下标
  const arr = [];
  for (let i = 0; i < nums.length; i++) {
    if (arr[nums[i]] === undefined) {
      arr[nums[i]] = true;
    } else {
      return nums[i];
    }
  }
};

console.log(findDuplicate([1, 3, 4, 2, 2]));
console.log(findDuplicate([3, 1, 3, 4, 2]));
```

### 292

```js
// You are playing the following Nim Game with your friend: There is a heap of
// stones on the table, each time one of you take turns to remove 1 to 3 stones.
//
// The one who removes the last stone will be the winner. You will take the
// first turn to remove the stones.
//
// Both of you are very clever and have optimal strategies for the game. Write
// a function to determine whether you can win the game given the number of
// stones in the heap.
//
// For example, if there are 4 stones in the heap, then you will never win the
// game: no matter 1, 2, or 3 stones you remove, the last stone will always be
// removed by your friend.
//

export default function CanWinNim(n: number): boolean {
  return (n / 4) % 1 !== 0;
}
```

### 300-Longest-Increasing-Subsequence

```js
/**
 * https://leetcode.com/problems/longest-increasing-subsequence/description/
 * Difficulty:Medium
 * Given an unsorted array of integers, find the length of longest increasing subsequence.
 * For example,
 * Given [10, 9, 2, 5, 3, 7, 101, 18],
 * The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.
 * Your algorithm should run in O(n2) complexity.
 * Follow up: Could you improve it to O(n log n) time complexity?
 *
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  var dp = [];
  for (var i = 0; i < nums.length; i++) {
    dp[i] = 1;

    var max = 0;
    for (var j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        if (dp[j] > max) {
          max = dp[j];
        }
      }
    }
    dp[i] = max + 1;
  }

  return Math.max(...dp);
};

console.log(lengthOfLIS([23, 2, 4, 5, 6]));
```

### 300.longest-increasing-subsequence

```js
/*
 * @lc app=leetcode id=300 lang=javascript
 *
 * [300] Longest Increasing Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  // 时间复杂度O(n^2)
  // if (nums.length === 0) return 0;
  //   const dp = Array(nums.length).fill(1);
  //   let max = 1;
  //   for (let i = 0; i < nums.length; i++) {
  //     for (let j = 0; j < i; j++) {
  //       if (nums[i] > nums[j]) {
  //         dp[i] = Math.max(dp[j] + 1, dp[i]);
  //       }
  //       max = Math.max(max, dp[i]);
  //     }
  //   }
  //   return max;
  // [ 10, 9, 2, 5, 3, 7, 101, 18 ]
  // [ 2, 3, 5, 7, 9, 10, 18, 101 ]
  // 参考： https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation
  // const tails = [];
  // for (let i = 0; i < nums.length; i++) {
  //   let left = 0;
  //   let right = tails.length;
  //   while (left < right) {
  //     const mid = left + (right - left) / 2; // 防止溢出
  //     if (tails[mid] < nums[i]) left = mid + 1;
  //     else right = mid;
  //   }
  //   // 说明nums[i] 比如tails中所有数字都大，我们直接push
  //   if (right === tails.length) tails.push(nums[i]);
  //   else tails[right] = nums[i]; // 否则我们修改tails[right]
  // }
  // return tails.length;
};
```

### Hard/212

```js
const findWordsAux = (board, trie, i, j, char, visited, ans) => {
  if (i < 0 || j < 0 || i >= board.length || j >= board[0].length) return;
  if (visited[i][j] === 1) return;
  if (!trie.has(board[i][j])) return;
  char += board[i][j];
  const child = trie.get(board[i][j]);
  if (child.has('END')) {
    ans.push(char);
  }
  visited[i][j] = 1;
  findWordsAux(board, child, i, j - 1, char, visited, ans);
  findWordsAux(board, child, i, j + 1, char, visited, ans);
  findWordsAux(board, child, i - 1, j, char, visited, ans);
  findWordsAux(board, child, i + 1, j, char, visited, ans);
  visited[i][j] = 0;
};

const createTrie = words => {
  const trie = new Map();
  for (const word of words) {
    let tmp = trie;
    for (const char of Array.from(word)) {
      if (!tmp.has(char)) {
        tmp.set(char, new Map());
      }
      tmp = tmp.get(char);
    }
    tmp.set('END', null);
  }
  return trie;
};

/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
export default function findWords(board, words) {
  // build a trie
  const trie = createTrie(words);
  const ans = [];
  const visited = [];
  for (let i = 0; i < board.length; i++) {
    visited[i] = [];
    for (let j = 0; j < board[i].length; j++) {
      visited[i][j] = 0;
    }
  }
  // Iterate over each position and call recursively
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[i].length; j++) {
      findWordsAux(board, trie, i, j, '', visited, ans);
    }
  }
  return Array.from(new Set(ans));
}
```

### Medium/207

```js
// https://leetcode.com/problems/course-schedule/

// There are a total of n courses you have to take, labeled from 0 to n-1.

// Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

// Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */

const topsort = (numCourses, prereqs) => {
  const sortedOrder = [];
  // construct outdegree
  if (!prereqs.length) return true;

  const indegrees = new Array(numCourses);
  const graph = new Array(numCourses);
  for (let i = 0; i < numCourses; i++) {
    graph[i] = [];
    indegrees[i] = 0;
  }
  for (const pair of prereqs) {
    const [a, b] = pair;
    // add outdegrees
    graph[b].push(a);
    indegrees[a]++;
  }
  // Find vertices with indeg 0
  const queue = [];
  for (let i = 0; i < indegrees.length; i++) {
    if (indegrees[i] === 0) {
      queue.push(i);
    }
  }
  if (queue.length === 0) return false;
  while (queue.length) {
    const v = queue.shift();
    sortedOrder.push(v);
    for (const outgoing of graph[v]) {
      indegrees[outgoing]--;
      if (indegrees[outgoing] === 0) {
        queue.push(outgoing);
      }
    }
  }
  return sortedOrder.length === numCourses;
};

export default function canFinish(numCourses, prerequisites) {
  return topsort(numCourses, prerequisites);
}
```

### Medium/209

```js
// 209. Minimum Size Subarray Sum

// Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

// Example:

// Input: s = 7, nums = [2,3,1,2,4,3]
// Output: 2
// Explanation: the subarray [4,3] has the minimal length under the problem constraint.
// Follow up:
// If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).

/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
export default function minSubArrayLen(s, nums) {
  let result = Number.MAX_SAFE_INTEGER;
  let left = 0;
  let sum = 0;
  for (let i = 0; i < nums.length; i++) {
    if (result === 1) return 1;
    sum += nums[i];
    while (sum >= s) {
      result = Math.min(i - left + 1, result);
      sum -= nums[left];
      left++;
    }
  }
  return result === Number.MAX_SAFE_INTEGER ? 0 : result;
}
```

### Medium/229

```js
// 229. Majority Element II

// Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

// Note: The algorithm should run in linear time and in O(1) space.

// Example 1:

// Input: [3,2,3]
// Output: [3]
// Example 2:

// Input: [1,1,1,3,3,2,2,2]
// Output: [1,2]

/**
 * @param {number[]} nums
 * @return {number[]}
 */
export default function majorityElement(nums) {
  if (!nums.length) return [];
  let count1 = 0;
  let count2 = 0;
  let maj1 = null;
  let maj2 = null;
  // Find the two numbers that occur the most
  for (const num of nums) {
    if (num === maj1) {
      count1++;
    } else if (num === maj2) {
      count2++;
    } else if (count1 === 0) {
      maj1 = num;
      count1 = 1;
    } else if (count2 === 0) {
      maj2 = num;
      count2 = 1;
    } else {
      count1--;
      count2--;
    }
  }
  // Filter any of the two numbers that do not occur more than len / 3 times
  return [maj1, maj2].filter(e => {
    let i = 0;
    for (const num of nums) {
      if (num === e) {
        i++;
      }
    }
    return i > nums.length / 3;
  });
}
```

### Medium/230

```js
// 230. Kth Smallest Element in a BST

// Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

// Note:
// You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

// Example 1:

// Input: root = [3,1,4,null,2], k = 1
//    3
//   / \
//  1   4
//   \
//    2
// Output: 1
// Example 2:

// Input: root = [5,3,6,2,4,null,null,1], k = 3
//        5
//       / \
//      3   6
//     / \
//    2   4
//   /
//  1
// Output: 3
// Follow up:
// What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

const kthSmallestAux = (root, ans) => {
  if (!root) return;
  if (root.left) kthSmallestAux(root.left, ans);
  ans.push(root.val);
  if (root.right) kthSmallestAux(root.right, ans);
};

/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
export default function kthSmallest(root, k) {
  if (!root) return -1;
  const ans = [];
  kthSmallestAux(root, ans);
  return ans[k - 1];
}
```

### Medium/236

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */

const trav = (root, node, path, paths) => {
  if (root === null) return;
  path.push(root);
  if (root.val === node.val) {
    paths.push(path);
    return;
  }
  if (root.left) trav(root.left, node, [...path], paths);
  if (root.right) trav(root.right, node, [...path], paths);
};

export default function lowestCommonAncestor(root, p, q) {
  let set = new Set();
  {
    const paths = [];
    trav(root, p, [], paths);
    if (!paths.length) return -1;
    const [path] = paths;
    if (path) set = new Set(path);
  }
  const paths = [];
  trav(root, q, [], paths);
  if (!paths.length) return -1;
  const [path] = paths;
  for (const item of path) {
    if (set.has(item)) return item;
  }
}
```
