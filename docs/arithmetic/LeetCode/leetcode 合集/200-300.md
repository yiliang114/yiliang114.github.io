---
layout: CustomPages
title: 合集 200-300
date: 2020-09-04
aside: false
draft: true
---

### [202].

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  let slow = n,
    fast = n;

  do {
    slow = digitSquareSum(slow);
    fast = digitSquareSum(fast);
    fast = digitSquareSum(fast);
  } while (slow != fast);

  return slow == 1;
};

function digitSquareSum(n) {
  let numStr = n + '';
  let sum = 0;
  for (let val of numStr) {
    sum += parseInt(val) * parseInt(val);
  }
  return sum;
}

isHappy(19);
```

### [204].

```js
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  let notPrime = new Array(n);
  notPrime.fill(false);
  let count = 0;
  for (let i = 2; i < n; i++) {
    if (!notPrime[i]) {
      count++;
      for (let j = 2; i * j < n; j++) {
        notPrime[i * j] = true;
      }
    }
  }
  return count;
};
```

### [206].反转链表

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

```js
function ReverseList(pHead) {
  // write code here
  let pPre = null,
    pNext = null;
  while (pHead !== null) {
    pNext = pHead.next;
    pHead.next = pPre;
    pPre = pHead;
    pHead = pNext;
  }
  return pPre;
}
```

```js
var reverseList = function(head) {
  const l1 = new ListNode(null);
  if (!head) return l1;

  // 收集到数组
  const result = [];
  while (head !== null) {
    result.push(head.val);
    head = head.next;
  }
  // result.push(head.val)

  // 重新创建一个链表
  let cur = l1;

  for (let i = result.length - 1; i >= 0; i--) {
    cur.next = new ListNode(result[i]);
    cur = cur.next;
  }

  return l[1].next;
};

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let head = new ListNode(null);
  const guard = head;
  if (arr.length === 0) return guard;
  for (let i = 0; i < arr.length; i++) {
    let temp = new ListNode(arr[i]);
    head.next = temp;
    head = temp;
  }
  return guard.next;
}

function ListNodeToString(listNode) {
  let resp = '';
  let cur = listNode;
  while (cur.next) {
    resp += `${cur.val} -> `;
    cur = cur.next;
  }
  if (cur.val) resp += `${cur.val}`;
  console.log(resp);
}

const l1 = List([1, 2, 3]);
// ListNodeToString(l1)
const l2 = reverseList(l1);
ListNodeToString(l2);

const l3 = List([]);
ListNodeToString(l3);
const l4 = reverseList(l3);
ListNodeToString(l4);

// Wrong Answer
// ✘ 26 / 27 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: [0]
// ✘ expected_answer: []
// ✘ stdout:
```

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let cur = head;
  let pre = null;
  let next = null;
  while (cur != null) {
    next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
};
```

### [207].

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
  var courses = new Array(numCourses),
    visited = new Array(numCourses),
    preLen = prerequisites.length,
    flag = true,
    temp;

  visited.fill(false);
  courses.fill(undefined);
  for (let key in courses) {
    courses[key] = [];
  }

  for (let cur in prerequisites) {
    temp = prerequisites[cur];
    courses[temp[0]].push(temp[1]);
  }

  for (let key in courses) {
    if (flag && !visited[key]) {
      visited[key] = true;
      map = new Array(numCourses);
      map.fill(false);
      dfs(key, map);
    }
  }

  return flag;

  function dfs(index, map) {
    if (!flag) return;

    visited[index] = true;

    if (map[index]) {
      flag = false;
      return;
    }

    for (let key in courses[index]) {
      map[index] = true;
      dfs(courses[index][key], map);
      map[index] = false;
    }
  }
};
```

### [208].

```js
/**
 * Initialize your data structure here.
 */
var Trie = function() {
  this.root = {};
};

/**
 * Inserts a word into the trie.
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
  let node = this.root;
  word.split('').forEach(char => {
    if (!node[char]) node[char] = {};
    node = node[char];
  });
  node.isEnd = true;
};

/**
 * Returns if the word is in the trie.
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
  let node = this.root;
  for (let i = 0; i < word.length; i++) {
    const char = word[i];

    if (node[char]) {
      node = node[char];
    } else {
      return false;
    }
  }
  return !!node.isEnd;
};

/**
 * Returns if there is any word in the trie that starts with the given prefix.
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
  let node = this.root;
  for (let i = 0; i < prefix.length; i++) {
    const char = prefix[i];

    if (node[char]) {
      node = node[char];
    } else {
      return false;
    }
  }
  return true;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = Object.create(Trie).createNew()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

const trie = new Trie();
trie.search('a');
```

### [210].

```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
  // edge case
  if (!numCourses || numCourses === 0) {
    return [];
  }

  // calculate in-degree and edges
  let inDegree = {}; // 要学习的数量
  let edges = {}; // 学习条件
  for (let i = 0; i < numCourses; i++) {
    inDegree[i] = 0;
    edges[i] = [];
  }
  for (let i = 0; i < prerequisites.length; i++) {
    inDegree[prerequisites[i][0]]++;
    edges[prerequisites[i][1]].push(prerequisites[i][0]);
  }

  // find root(s)
  let queue = [];
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }

  // BFS
  let res = [];
  while (queue.length > 0) {
    let node = queue.shift();
    res.push(node);
    for (let i = 0; i < edges[node].length; i++) {
      let nextNode = edges[node][i];
      inDegree[nextNode]--;
      if (inDegree[nextNode] === 0) {
        queue.push(nextNode);
      }
    }
  }

  // check
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] > 0) {
      return [];
    }
  }

  return res;
};
```

### [212].

LeetCode 第 212 题：给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。

![](http://s[0].lgstatic.com/i/image2/M01/90/B0/CgoB5l2ILXyAYLwPAAAO6ajgsHk[324].png)

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

说明：你可以假设所有输入都由小写字母 `a-z` 组成。

### 解题思路

这是一道出现较为频繁的难题，题目给出了一个二维的字符矩阵，然后还给出了一个字典，现在要求在这个字符矩阵中找到出现在字典里的单词。

由于字符矩阵的每个点都能作为一个字符串的开头，所以必须得尝试从矩阵中的所有字符出发，上下左右一步步地走，然后去和字典进行匹配，如果发现那些经过的字符能组成字典里的单词，就把它记录下来。

可以借用深度优先的算法来实现(关于深度优先算法，将在第 06 节课深入探讨)，如果你对它不熟悉，可以把它想象成走迷宫。

![](http://s[0].lgstatic.com/i/image2/M01/90/CD/CgoB5l2IShaAfIDFAAElACD4d7I[232].png)

**字典匹配的解法 1**：每次都循环遍历字典，看看是否存在字典里面，如果把输入的字典变为哈希集合的话，似乎只需要 O(1) 的时间就能完成匹配。

但是，这样并不能进行前缀的对比，即，必须每次都要进行一次全面的深度优先搜索，或者搜索的长度为字典里最长的字符串长度，这样还是不够高效。

**字典匹配的解法 2**：对比字符串的前缀，借助前缀树来重新构建字典。

假如在矩阵里遇到了一个字符”V”，而字典里根本就没有以“V”开头的字符串，则不需要将深度优先搜索进行下去，可以大大地提高搜索效率。

构建好了前缀树之后，每次从矩阵里的某个字符出发进行搜索的时候，同步地对前缀树进行对比，如果发现字符一直能被找到，就继续进行下去，一步一步地匹配，直到在前缀树里发现一个完整的字符串，把它输出即可。

```js
let hasWord = false;

var findWords = function(board, words) {
  var ans = [];
  for (let word of words) {
    for (let j = 0; j < board.length; j++) {
      for (let i = 0; i < board[0].length; i++) {
        if (board[j][i] == word[0]) {
          hasWord = false;
          DFS(word, board, 0, j, i, '');
          if (hasWord) {
            if (!ans.includes(word)) ans.push(word);
          }
        }
      }
    }
  }
  return ans;
};

function DFS(word, board, index, j, i, subStr) {
  if (word[index] == board[j][i]) {
    subStr += board[j][i];
    board[j][i] = '*';
    if (j < board.length - 1) DFS(word, board, index + 1, j + 1, i, subStr);
    if (j > 0) DFS(word, board, index + 1, j - 1, i, subStr);
    if (i < board[0].length - 1) DFS(word, board, index + 1, j, i + 1, subStr);
    if (i > 0) DFS(word, board, index + 1, j, i - 1, subStr);
    board[j][i] = word[index];
  }
  if (index >= word.length || subStr == word) {
    hasWord = true;
  }
}

findWords([['a']], ['a']);
```

### [215].

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  for (let i = 0; i <= k; i++) {
    let max = i;
    for (let j = i; j < nums.length; j++) {
      if (nums[j] > nums[max]) max = j;
    }
    swap(nums, i, max);
  }
  return nums[k - 1];
};

function swap(arr, a, b) {
  let tmp = arr[a];
  arr[a] = arr[b];
  arr[b] = tmp;
}

findKthLargest([3, 2, 1, 5, 6, 4], 2);
```

### [218].

```js
/**
 * @param {number[][]} buildings
 * @return {number[][]}
 */
var getSkyline = function(buildings) {
  const heights = [];
  const result = [];
  for (let item of buildings) {
    heights.push([item[0], -item[2]]);
    heights.push([item[1], item[2]]);
  }
  heights.sort((a, b) => {
    if (a[0] == b[0]) return a[1] - b[1];
    else return a[0] - b[0];
  });
  let maxStack = [0];
  let preHeight = 0;
  for (let h of heights) {
    if (h[1] < 0) {
      maxStack.push(-h[1]);
    } else {
      for (let i = 0; i < maxStack.length; i++) {
        if (maxStack[i] == h[1]) {
          maxStack.splice(i, 1);
          break;
        }
      }
    }
    let curHeight = Math.max(...maxStack);
    if (preHeight != curHeight) {
      result.push([h[0], curHeight]);
      preHeight = curHeight;
    }
  }
  return result;
};

console.log(
  getSkyline([
    [2, 9, 10],
    [3, 7, 15],
    [5, 12, 12],
    [15, 20, 10],
    [19, 24, 8],
  ]),
);
```

### [227].

```js
var calculate = function(s) {
  return s
    .replace(/-/g, '+-')
    .split('+')
    .reduce((sum, s) => sum + mult(s), 0);
};

function mult(s) {
  let ops = '*' + s.replace(/[\d -]+/g, '');
  if (ops.length === 1) return parseInt(s);
  return s.split(/[*\/]/g).reduce((a, b, i) => (ops[i] === '*' ? a * b : (a ^ b) > 0 ? ~~(a / b) : -~~(-a / b)), 1);
}

/**
 * TODO 此题我的方案又 TLE 了
 * 所以先看了看别人的方案，之后重新搞一遍。
 */
```

### [230].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  const leftCount = getNodeLength(root.left);
  if (k < leftCount + 1) {
    return kthSmallest(root.left, k);
  } else if (k > leftCount + 1) {
    return kthSmallest(root.right, k - leftCount - 1);
  }
  return root.val;
};

function getNodeLength(node) {
  if (node == null) return 0;
  return 1 + getNodeLength(node.left) + getNodeLength(node.right);
}

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

const node = new TreeNode(1);
node.right = new TreeNode(2);

kthSmallest(node, 2);
```

### [234].

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  let fast = head,
    slow = head;
  while (fast != null) {
    slow = slow.next;
    fast = fast.next.next;
  }
  slow = reverseList(slow);
  while (slow != null) {
    if (slow.val != head.val) return false;
    slow = slow.next;
    head = head.next;
  }
  return true;
};

var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

### [235].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (root == null || root == p || root == q) return root;
  let left = lowestCommonAncestor(root.left, p, q);
  let right = lowestCommonAncestor(root.right, p, q);
  return left == null ? right : right == null ? left : root;
};
```

### [237].

```js
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
  node.val = node.next.val;
  node.next = node.next.next;
};
```

### [238].

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  const n = nums.length;
  const res = new Array(n);
  res[0] = 1;
  // 每个数字的左边乘积
  for (let i = 1; i < n; i++) {
    // nums = [ 1, 2, 3, 4 ] => res = [ 1, 1, 2, 6 ]
    res[i] = res[i - 1] * nums[i - 1];
  }
  // 每个数字的右边乘积
  let right = 1;
  for (let i = n - 1; i >= 0; i--) {
    // nums = [ 1, 2, 3, 4 ] => res = [ 1, 1, 2, 6 ]
    res[i] *= right; // 6 8 12 24
    right *= nums[i]; // 4 12 24 24
  }
  return res;
};
```

### [239].

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
  if (nums.length == 0) return [];
  const ans = [];

  let firstArr = nums.slice(0, k);
  let max = Math.max(...firstArr);
  ans.push(max);
  for (let i = k; i < nums.length; i++) {
    if (nums[i] > max) {
      max = nums[i];
    } else if (nums[i - k] == max) {
      let arr = nums.slice(i - k + 1, i + 1);
      max = Math.max(...arr);
    }
    ans.push(max);
  }
  return ans;
};

maxSlidingWindow([1, 3, 1, 2, 0, 5], 3);
```

### [240].

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  if (matrix.length == 0) return false;
  let row = 0,
    col = matrix[0].length - 1;
  while (true) {
    if (matrix[row][col] > target && col > 0) {
      col--;
    } else if (matrix[row][col] < target && row < matrix.length - 1) {
      row++;
    } else if (matrix[row][col] == target) {
      return true;
    } else {
      break;
    }
  }
  return false;
};
```

### [242].

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
  const arr = new Array(26);
  arr.fill(0);
  for (let c of s) {
    arr[c.charCodeAt() - 'a'.charCodeAt()]++;
  }
  for (let c of t) {
    arr[c.charCodeAt() - 'a'.charCodeAt()]--;
  }
  for (let item of arr) {
    if (item != 0) return false;
  }
  return true;
};
```

### [268].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
  let num = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0) continue;
    let min = i;
    for (let j = i; j < nums.length; j++) {
      if (nums[j] < nums[min] && nums[j] >= 0) min = j;
    }
    if (nums[min] == num) num++;
    else return num;
    swap(nums, i, min);
  }
  return num;
};

function swap(nums, a, b) {
  let tmp = nums[a];
  nums[a] = nums[b];
  nums[b] = tmp;
}

missingNumber([3, 0, 1]);
```

### [279].

```js
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  let dp = new Array(n + 1);
  dp.fill(Number.MAX_VALUE);
  dp[0] = 0;
  for (let i = 0; i <= n; i++) {
    for (let j = 1; i + j * j <= n; j++) {
      dp[i + j * j] = Math.min(dp[i + j * j], dp[i] + 1);
    }
  }
  return dp[n];
};
```

### [283].

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
  let i = 0;
  len = nums.length;
  while (i < len) {
    if (nums[i] == 0) {
      nums.splice(i, 1);
      nums.push(0);
      len--;
    } else {
      i++;
    }
  }
};
```

### [287].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  let set = new Set();
  for (let num of nums) {
    if (set.has(num)) return num;
    set.add(num);
  }
  return -1;
};
```

### [289].

```js
/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var gameOfLife = function(board) {
  if (board == null || board.length == 0) return;
  let m = board.length,
    n = board[0].length;
  // 计算当前和下一个状态(二进制)
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 获取周围存活细胞数量
      let lives = liveNeighbors(board, m, n, i, j);

      // 在开始阶段，每个下一阶段的二进制都为 0;
      // 所以我们只要关心什么时候下一阶段的二进制值会变为 1。
      if (board[i][j] == 1 && lives >= 2 && lives <= 3) {
        board[i][j] = 3; // 01 -> 11
      }
      if ((board[i][j] = 0 && lives == 3)) {
        board[i][j] = 2; // 00 -> 10
      }
    }
  }
  // 变为第二状态
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      board[i][j] >>= 1;
    }
  }
};

function liveNeighbors(board, m, n, i, j) {
  let lives = 0;
  for (let x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {
    for (let y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {
      lives += board[x][y] & 1;
    }
  }
  lives -= board[i][j] & 1;
  return lives;
}
```

### [295].

```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
  this.arr = [];
};

/**
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
  let index = binarySearch(this.arr, num, 0, this.arr.length);
  this.arr.splice(index, 0, num);
};

function binarySearch(arr, val, lo, hi) {
  if (hi < lo) return lo;
  let mid = lo + parseInt((hi - lo) / 2);
  console.log('范围', lo + '-' + hi);
  console.log('中间值', mid + ':' + arr[mid]);
  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
  if (this.arr.length % 2 == 0) {
    let mid = this.arr.length / 2;
    return (this.arr[mid - 1] + this.arr[mid]) / 2;
  } else {
    let mid = (this.arr.length - 1) / 2;
    return this.arr[mid];
  }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = Object.create(MedianFinder).createNew()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */

const mf = new MedianFinder();
mf.addNum(-1);
mf.findMedian();
mf.addNum(-2);
mf.findMedian();
mf.addNum(-3);
mf.findMedian();
mf.addNum(-4);
mf.findMedian();
```

### [297].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
  if (!root) return '[]';
  var queue = [];
  var ans = [];
  queue.push(root);
  while (queue.length !== 0) {
    var node = queue.shift();
    if (node === null) {
      ans.push(null);
      continue;
    }
    ans.push(node.val);
    if (node.left) queue.push(node.left);
    else queue.push(null);
    if (node.right) queue.push(node.right);
    else queue.push(null);
  }
  ans = sanitize(ans);
  var ansStr = '';
  ansStr += '[';
  for (var i = 0; i < ans.length; i++) {
    if (ans[i] === null) ansStr += 'null' + ',';
    else ansStr += ans[i] + ',';
  }
  ansStr = ansStr.slice(0, -1);
  ansStr += ']';
  return ansStr;
};

function sanitize(ans) {
  var lastcharIndex = -1;
  for (var i = 0; i < ans.length; i++) {
    if (ans[i] !== null) {
      lastcharIndex = i;
    }
  }
  var newArray = [];
  for (var j = 0; j <= lastcharIndex; j++) {
    newArray.push(ans[j]);
  }
  return newArray;
}

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
  if (data.length === 0) return null;
  var values = data.substring(1, data.length - 1).split(',');
  if (!values[0]) {
    return null;
  }
  var val = values.shift();
  var root = new TreeNode(parseInt(val));
  var queue = [];
  queue.push(root);
  while (queue.length !== 0) {
    let node = queue.shift();
    let val = values.shift();
    node.left = !isNaN(parseInt(val)) ? new TreeNode(parseInt(val)) : null;
    val = values.shift();
    node.right = !isNaN(parseInt(val)) ? new TreeNode(parseInt(val)) : null;
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }
  return root;
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */

/**
 * 二叉树的序列化和反序列化
 * 通过BFS来实现
 */
```

### [300].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  if (nums.length == 0) {
    return 0;
  }
  let dp = new Array(nums.length);
  dp[0] = 1;
  let maxans = 1;
  for (let i = 1; i < dp.length; i++) {
    let maxval = 0;
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        maxval = Math.max(maxval, dp[j]);
      }
    }
    dp[i] = maxval + 1;
    maxans = Math.max(maxans, dp[i]);
  }
  return maxans;
};
```

### 202-Happy-Number

```js
/**
 * https://leetcode.com/problems/happy-number/description/
 * Difficulty:Easy
 *
 * Write an algorithm to determine if a number is "happy".
 * A happy number is a number defined by the following process: Starting with any positive integer,
 * replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),
 * or it loops endlessly in a cycle which does not include [1]. Those numbers for which this process ends in 1 are happy numbers.
 *
 * Example: 19 is a happy number
 *
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */

/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  var results = [n];

  while (true) {
    n = squareSumOfDigits(n);
    // console.log(n);
    if (n === 1) return true;
    if (results.indexOf(n) > -1) return false;
    results.push(n);
  }
};

function squareSumOfDigits(n) {
  var sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

console.log(isHappy(1));
console.log(isHappy(19));
```

### [202].happy-number

```js
/*
 * @lc app=leetcode id=202 lang=javascript
 *
 * [202] Happy Number
 *
 * https://leetcode.com/problems/happy-number/description/
 *
 * algorithms
 * Easy ([44].36%)
 * Total Accepted:    [227].2K
 * Total Submissions: [505].7K
 * Testcase Example:  '19'
 *
 * Write an algorithm to determine if a number is "happy".
 *
 * A happy number is a number defined by the following process: Starting with
 * any positive integer, replace the number by the sum of the squares of its
 * digits, and repeat the process until the number equals 1 (where it will
 * stay), or it loops endlessly in a cycle which does not include [1]. Those
 * numbers for which this process ends in 1 are happy numbers.
 *
 * Example:
 *
 *
 * Input: 19
 * Output: true
 * Explanation:
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */
function squareSum(n) {
  let sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

function isHappyWithMapper(n, visited) {
  if (n === 1) return true;
  if (visited[n]) return false;
  visited[n] = true;

  return isHappyWithMapper(squareSum(n), visited);
}
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  const visited = {};

  return isHappyWithMapper(n, visited);
};
```

### 203

```js
// Remove all elements from a linked list of integers that have value val.

/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
export default function removeElements(head, val) {
  if (head === null) return null;
  let prev = null;
  let curr = head;
  let next = null;
  let hasHead = false;
  while (curr) {
    next = curr.next;
    if (curr.val === val) {
      // delete
      curr = null;
      // join links
      if (prev) prev.next = next;
    } else {
      prev = curr;
      if (!hasHead) {
        head = curr;
        hasHead = true;
      }
    }
    curr = next;
  }
  if (!prev) head = null;
  return head;
}
```

### 204-Count-Primes

```js
/**
 * https://leetcode.com/problems/count-primes/description/
 * Difficulty:Easy
 *
 * Description:
 * Count the number of prime numbers less than a non-negative number, n.
 */

/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  if (n < 3) return 0;
  var cnt = 0;
  var p = new Array(n + 1).fill(1);
  p[1] = 0;
  for (var i = 2; i < n; i++) {
    if (p[i]) {
      cnt++;
      for (var j = i * 2; j <= n; j += i) {
        p[j] = 0;
      }
    }
  }
  // console.log(p);
  return cnt;
};

console.log(countPrimes(3));
console.log(countPrimes(4));
console.log(countPrimes(21));
console.log(countPrimes(27));
console.log(countPrimes(31));
```

### [204].count-primes

```js
/*
 * @lc app=leetcode id=204 lang=javascript
 *
 * [204] Count Primes
 *
 * https://leetcode.com/problems/count-primes/description/
 *
 * algorithms
 * Easy ([28].33%)
 * Total Accepted:    [229].8K
 * Total Submissions: [798].7K
 * Testcase Example:  '10'
 *
 * Count the number of prime numbers less than a non-negative number, n.
 *
 * Example:
 *
 *
 * Input: 10
 * Output: 4
 * Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, [7].
 *
 *
 */
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  // tag: 数论
  // if (n <= 2) return 0;
  // let compositionCount = 0;
  // for(let i = 3; i < n; i++) {
  //     for(let j = i - 1; j > 1 ; j--) {
  //         if (i % j === 0) {
  //             compositionCount++;
  //             break; // 找到一个就可以证明它不是质数了
  //         }
  //     }
  // }
  // return n - compositionCount - 2; // 需要减去1和n这两个数字

  // 上面的方法会超时，因此我们需要进行优化
  // 数学角度来看，如果一个数字可以分解为两个数字相乘(这两个数字不包括0和它本身)，那么它就是合数
  const compositions = []; // compositions[i] 表示i是否是合数
  let count = 0;
  for (let i = 2; i < n; i++) {
    if (!compositions[i]) count++;
    for (let j = 2; i * j < n; j++) {
      compositions[i * j] = true;
    }
  }

  return count;
};
```

### [215].数组中的第 k 个最大元素

```js
/*
 * @lc app=leetcode.cn id=215 lang=javascript
 *
 * [215] 数组中的第K个最大元素
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
// 最简单方法。。。
var findKthLargest = function(nums, k) {
  // nums = Array.from(new Set(nums)).sort()
  // 注意如果单纯是 nums.sort() 函数执行的话，会进行字典升序
  nums = nums.sort((a, b) => a - b);
  console.log(nums);
  return nums[nums.length - k];
};

console.log(findKthLargest([3, 2, 1, 5, 6, 4], 2));
console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4));
console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6, 7, 7, 8, 2, 3, 1, 1, 1, 10, 11, 5, 6, 2, 4, 7, 8, 5, 6], 2));
```

### 217-Contains-Duplicate

```js
/**
 * https://leetcode.com/problems/contains-duplicate/description/
 * Difficulty:Easy
 *
 * Given an array of integers, find if the array contains any duplicates.
 * Your function should return true if any value appears at least twice in the array,
 * and it should return false if every element is distinct.
 */

/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  var map = {};
  for (var i = 0; i < nums.length; i++) {
    var n = nums[i];
    if (map[n]) return true;
    map[n] = 1;
  }
  return false;
};
console.log(containsDuplicate([3, 4]));
```

### [217].contains-duplicate

```js
/*
 * @lc app=leetcode id=217 lang=javascript
 *
 * [217] Contains Duplicate
 *
 * https://leetcode.com/problems/contains-duplicate/description/
 *
 * algorithms
 * Easy ([50].92%)
 * Total Accepted:    324K
 * Total Submissions: [628].5K
 * Testcase Example:  '[1,2,3,1]'
 *
 * Given an array of integers, find if the array contains any duplicates.
 *
 * Your function should return true if any value appears at least twice in the
 * array, and it should return false if every element is distinct.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,1]
 * Output: true
 *
 * Example 2:
 *
 *
 * Input: [1,2,3,4]
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: [1,1,1,3,3,4,3,2,4,2]
 * Output: true
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  // [1]. 暴力两层循环两两比较， 时间复杂度O(n^2) 空间复杂度O(1)

  // [2]. 先排序，之后比较前后元素是否一致即可，一层循环即可，如果排序使用的比较排序的话时间复杂度O(nlogn) 空间复杂度O(1)

  // [3]. 用hashmap ，时间复杂度O(n) 空间复杂度O(n)
  const visited = {};
  for (let i = 0; i < nums.length; i++) {
    if (visited[nums[i]]) return true;
    visited[nums[i]] = true;
  }
  return false;
};
```

### [226].Invert-Binary-Tree

```js
/**
 * https://leetcode.com/problems/invert-binary-tree/description/
 * Difficulty:Easy
 *
 * Invert a binary tree.
 *      4
 *    /   \
 *   2     7
 *  / \   / \
 * 1   3 6   9
 *
 * to
 *
 *       4
 *     /   \
 *   7     2
 *  / \   / \
 * 9   6 3   1
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
  if (!root) return root;
  if (!root.left && !root.right) return root;
  var left = invertTree(root.right);
  var right = invertTree(root.left);
  root.left = left;
  root.right = right;
  return root;
};

function invertTree1(root) {
  if (!root) return root;
  const { left, right } = root;
  root.left = right;
  root.right = left;
  invertTree1(root.left);
  invertTree1(root.right);
  return root;
}

// console.log(invertTree({
//   val: 4,
//   left: {
//     val: 2,
//     left: {
//       val: 1,
//       left: null,
//       right: null,
//     },
//     right: null
//   },
//   right: null
// }));
```

### 227-Basic-Calculator-II

```js
/**
 * https://leetcode.com/problems/basic-calculator-ii/description/
 * Difficulty:Medium
 *
 * Implement a basic calculator to evaluate a simple expression string.
 * The expression string contains only non-negative integers, +, -, *, / operators and
 * empty spaces . The integer division should truncate toward zero.
 * You may assume that the given expression is always valid.
 *
 * Some examples:
 *
 * "3+2*2" = 7
 * " 3/2 " = 1
 * " 3+5 / 2 " = 5
 *
 * Note: Do not use the eval built-in library function.
 */

/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  var operand = [];
  var operator = [];
  var lastIsNum = false;

  var arr = [];
  for (var i = 0; i < s.length; i++) {
    var ch = s[i];
    if (ch === ' ') continue;

    if (['+', '-', '*', '/'].indexOf(ch) > -1) {
      arr.push(ch);
      lastIsNum = false;
    } else {
      ch = parseInt(ch);
      if (lastIsNum && arr.length) {
        var last = arr.pop();
        arr.push(last * 10 + ch);
      } else {
        arr.push(ch);
      }
      lastIsNum = true;
    }
  }

  // console.log(arr);
  for (var i = 0; i < arr.length; i++) {
    var ch = arr[i];

    if (['+', '-', '*', '/'].indexOf(ch) > -1) {
      operator.push(ch);
      continue;
    }
    if (operator.length) {
      var op = operator.pop();
      if (op === '*' || op === '/') {
        var last = operand.pop();
        if (op === '*') {
          operand.push(last * ch);
        } else {
          operand.push(Math.floor(last / ch));
        }
      } else {
        operator.push(op);
        operand.push(ch);
      }
    } else {
      operand.push(ch);
    }
  }
  // console.log(operand);
  // console.log(operator);

  var i = 1;
  var j = 0;
  var res = operand[0];
  while (i < operand.length && j < operator.length) {
    var a = operand[i++];
    var op = operator[j++];
    // console.log(a, op, b);
    if (op === '+') {
      res = res + a;
    } else {
      res = res - a;
    }
  }

  return res;
};

console.log(calculate('1/1'));
console.log(calculate('1-1+1'));
console.log(calculate('1+1-1'));
console.log(calculate('42'));
console.log(calculate('12*12'));
console.log(calculate('3+2*2'));
console.log(calculate(' 3/2 '));
console.log(calculate(' 3+5 / 2 '));
```

### [227].basic-calculator-ii

```js
/*
 * @lc app=leetcode id=227 lang=javascript
 *
 * [227] Basic Calculator II
 */
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
  // "3+2*2"
};
```

### [229].求众数-ii

```js
/*
 * @lc app=leetcode.cn id=229 lang=javascript
 *
 * [229] 求众数 II
 * 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例 1:

输入: [3,2,3]
输出: [3]
示例 2:

输入: [1,1,1,3,3,2,2,2]
输出: [1,2]
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  if (nums.length === 0) return [];
  const result = [],
    targetNum = parseInt(nums.length / 3),
    map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > targetNum) {
        result.push(map[key]);
      }
    }
  }
  return result;
};

// console.log(majorityElement())
```

### 232

```js
/**
 * Initialize your data structure here.
 */
export default class StackQueue {
  constructor() {
    this.tmpStack = [];
    this.stack = [];
  }

  /**
   * Push element x to the back of queue.
   * @param {number} x
   * @return {void}
   */
  push(x) {
    this.stack.push(x);
  }

  /**
   * Removes the element from in front of queue and returns that element.
   * @return {number}
   */
  pop() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      const item = this.stack.pop();
      return item;
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const item = this.stack.pop();
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Get the front element.
   * @return {number}
   */
  peek() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      return this.stack[0];
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const [item] = this.stack;
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Returns whether the queue is empty.
   * @return {boolean}
   */
  empty() {
    return this.stack.length === 0;
  }
}

/**
 * Initialize your data structure here.
 */
class StackQueueFast {
  constructor() {
    this.tmpStack = [];
    this.stack = [];
  }

  /**
   * Push element x to the back of queue.
   * @param {number} x
   * @return {void}
   */
  push(x) {
    this.stack.push(x);
  }

  /**
   * Removes the element from in front of queue and returns that element.
   * @return {number}
   */
  pop() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      const item = this.stack.pop();
      return item;
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const item = this.stack.pop();
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Get the front element.
   * @return {number}
   */
  peek() {
    if (this.stack.length === 0) return -1;
    if (this.stack.length === 1) {
      return this.stack[0];
    }
    while (this.stack.length !== 1) {
      const a = this.stack.pop();
      this.tmpStack.push(a);
    }
    const [item] = this.stack;
    while (this.tmpStack.length !== 0) {
      const a = this.tmpStack.pop();
      this.stack.push(a);
    }
    return item;
  }

  /**
   * Returns whether the queue is empty.
   * @return {boolean}
   */
  empty() {
    return this.stack.length === 0;
  }
}
```

### [232].用栈实现队列

```js
/*
 * @lc app=leetcode.cn id=232 lang=javascript
 *
 * [232] 用栈实现队列
 * 使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
示例:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
说明:

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque(双端队列)来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 (例如，一个空的队列不会调用 pop 或者 peek 操作)。
 */
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
  this.stack = [];
  this.length = 0;
};

/**
 * Push element x to the back of queue.
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
  this.stack.push(x);
  this.length++;
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
  if (this.length) {
    this.length--;
    return this.stack.shift();
  }
  return undefined;
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
  if (this.length) return this.stack[0];
  return undefined;
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
  return this.length === 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */

// const queue = new MyQueue();

// queue.push(1);
// queue.push(2);
// console.log(queue.peek()) // 返回 1
// console.log(queue.pop())  // 返回 1
// console.log(queue.empty()) // 返回 false

// ✘ Wrong Answer
// ✘ 12 / 17 cases passed(N / A)
// ✘ testcase: '["MyQueue","push","pop","empty"]\n[[],[1],[],[]]'
// ✘ answer: [null, null, 1, false]
// ✘ expected_answer: [null, null, 1, true]
// ✘ stdout:
```

### 235

```js
// [235]. Lowest Common Ancestor of a Binary Search Tree

// Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

// According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

// Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

// Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
// Output: 6
// Explanation: The LCA of nodes 2 and 8 is [6].

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */

const dfs = (root, p, q, path, paths) => {
  if (!root) return;
  path.push(root);
  if (root.val === p.val || root.val === q.val) paths.push([...path]);
  if (root.left) dfs(root.left, p, q, [...path], paths);
  if (root.right) dfs(root.right, p, q, [...path], paths);
};

export default function lowestCommonAncestor(root, p, q) {
  const paths = [];
  dfs(root, p, q, [], paths);
  let [a, b] = paths;
  b = new Set(b);
  a = a.reverse();
  for (let i = 0; i < a.length; i++) {
    if (b.has(a[i])) return a[i];
  }
  return -1;
}
```

### 257

```js
// See https://leetcode.com/problems/binary-tree-paths/

const getPaths = (root, paths, parent) => {
  if (root === null) return;
  // Clone
  parent = [...parent];
  // Push node value
  parent.push(root.val);
  if (root.left) getPaths(root.left, paths, parent);
  if (root.right) getPaths(root.right, paths, parent);
  if (!root.left && !root.right) paths.push(parent.join('->'));
};

const binaryTreePaths = function(root) {
  const paths = [];
  const parent = [];
  getPaths(root, paths, parent);
  return paths;
};
```

### 258-Add-Digits

```js
/**
 * https://leetcode.com/problems/add-digits/description/
 * Difficulty:Easy
 *
 * Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
 * For example:
 * Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = [2]. Since 2 has only one digit, return it.
 * Follow up:
 * Could you do it without any loop/recursion in O(1) runtime?
 *
 */

/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {
  if (num < 10) return num;
  return addDigits(sum(num));
};

function sum(num) {
  return ('' + num).split('').reduce((a, b) => a + parseInt(b), 0);
}

console.log(addDigits(38));
```

### 263-Ugly-Number

```js
/**
 *
 * https://leetcode.com/problems/ugly-number/#/description
 * Difficulty:Easy
 *
 * Write a program to check whether a given number is an ugly number.
 *
 * Ugly numbers are positive numbers whose prime factors only include 2, 3, [5].
 *
 * For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor [7].
 *
 * Note that 1 is typically treated as an ugly number.
 */

/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
  if (num <= 0) return false;
  if (num == 1) return true;

  while (num > 1) {
    var old = num;
    if (!(num % 2)) num = num / 2;
    if (!(num % 3)) num = num / 3;
    if (!(num % 5)) num = num / 5;
    if (old === num) return false;
  }
  return true;
};

console.log(isUgly(6) === true);
console.log(isUgly(8) === true);
console.log(isUgly(14) === false);
```

### [287].find-the-duplicate-number

```js
/*
 * @lc app=leetcode id=287 lang=javascript
 *
 * [287] Find the Duplicate Number
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // Input: [1,3,4,2,2]
  // Output: 2
  // TODO: 冒泡、选择、插入是否都可以？ 不需要全部都排序完成之后就可以知道前后的值是否相等啦！
  nums.sort();

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) return nums[i];
  }
};
```

### [287].寻找重复数

```js
/*
 * @lc app=leetcode.cn id=287 lang=javascript
 *
 * [287] 寻找重复数
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // 1 - n 下标
  const arr = [];
  for (let i = 0; i < nums.length; i++) {
    if (arr[nums[i]] === undefined) {
      arr[nums[i]] = true;
    } else {
      return nums[i];
    }
  }
};

console.log(findDuplicate([1, 3, 4, 2, 2]));
console.log(findDuplicate([3, 1, 3, 4, 2]));
```

### 292

```js
// You are playing the following Nim Game with your friend: There is a heap of
// stones on the table, each time one of you take turns to remove 1 to 3 stones.
//
// The one who removes the last stone will be the winner. You will take the
// first turn to remove the stones.
//
// Both of you are very clever and have optimal strategies for the game. Write
// a function to determine whether you can win the game given the number of
// stones in the heap.
//
// For example, if there are 4 stones in the heap, then you will never win the
// game: no matter 1, 2, or 3 stones you remove, the last stone will always be
// removed by your friend.
//

export default function CanWinNim(n: number): boolean {
  return (n / 4) % 1 !== 0;
}
```

### 300-Longest-Increasing-Subsequence

```js
/**
 * https://leetcode.com/problems/longest-increasing-subsequence/description/
 * Difficulty:Medium
 * Given an unsorted array of integers, find the length of longest increasing subsequence.
 * For example,
 * Given [10, 9, 2, 5, 3, 7, 101, 18],
 * The longest increasing subsequence is [2, 3, 7, 101], therefore the length is [4]. Note that there may be more than one LIS combination, it is only necessary for you to return the length.
 * Your algorithm should run in O(n2) complexity.
 * Follow up: Could you improve it to O(n log n) time complexity?
 *
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  var dp = [];
  for (var i = 0; i < nums.length; i++) {
    dp[i] = 1;

    var max = 0;
    for (var j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        if (dp[j] > max) {
          max = dp[j];
        }
      }
    }
    dp[i] = max + 1;
  }

  return Math.max(...dp);
};

console.log(lengthOfLIS([23, 2, 4, 5, 6]));
```

### [300].longest-increasing-subsequence

```js
/*
 * @lc app=leetcode id=300 lang=javascript
 *
 * [300] Longest Increasing Subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  // 时间复杂度O(n^2)
  // if (nums.length === 0) return 0;
  //   const dp = Array(nums.length).fill(1);
  //   let max = 1;
  //   for (let i = 0; i < nums.length; i++) {
  //     for (let j = 0; j < i; j++) {
  //       if (nums[i] > nums[j]) {
  //         dp[i] = Math.max(dp[j] + 1, dp[i]);
  //       }
  //       max = Math.max(max, dp[i]);
  //     }
  //   }
  //   return max;
  // [ 10, 9, 2, 5, 3, 7, 101, 18 ]
  // [ 2, 3, 5, 7, 9, 10, 18, 101 ]
  // 参考： https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation
  // const tails = [];
  // for (let i = 0; i < nums.length; i++) {
  //   let left = 0;
  //   let right = tails.length;
  //   while (left < right) {
  //     const mid = left + (right - left) / 2; // 防止溢出
  //     if (tails[mid] < nums[i]) left = mid + 1;
  //     else right = mid;
  //   }
  //   // 说明nums[i] 比如tails中所有数字都大，我们直接push
  //   if (right === tails.length) tails.push(nums[i]);
  //   else tails[right] = nums[i]; // 否则我们修改tails[right]
  // }
  // return tails.length;
};
```

### Hard/212

```js
const findWordsAux = (board, trie, i, j, char, visited, ans) => {
  if (i < 0 || j < 0 || i >= board.length || j >= board[0].length) return;
  if (visited[i][j] === 1) return;
  if (!trie.has(board[i][j])) return;
  char += board[i][j];
  const child = trie.get(board[i][j]);
  if (child.has('END')) {
    ans.push(char);
  }
  visited[i][j] = 1;
  findWordsAux(board, child, i, j - 1, char, visited, ans);
  findWordsAux(board, child, i, j + 1, char, visited, ans);
  findWordsAux(board, child, i - 1, j, char, visited, ans);
  findWordsAux(board, child, i + 1, j, char, visited, ans);
  visited[i][j] = 0;
};

const createTrie = words => {
  const trie = new Map();
  for (const word of words) {
    let tmp = trie;
    for (const char of Array.from(word)) {
      if (!tmp.has(char)) {
        tmp.set(char, new Map());
      }
      tmp = tmp.get(char);
    }
    tmp.set('END', null);
  }
  return trie;
};

/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
export default function findWords(board, words) {
  // build a trie
  const trie = createTrie(words);
  const ans = [];
  const visited = [];
  for (let i = 0; i < board.length; i++) {
    visited[i] = [];
    for (let j = 0; j < board[i].length; j++) {
      visited[i][j] = 0;
    }
  }
  // Iterate over each position and call recursively
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[i].length; j++) {
      findWordsAux(board, trie, i, j, '', visited, ans);
    }
  }
  return Array.from(new Set(ans));
}
```

### Medium/207

```js
// https://leetcode.com/problems/course-schedule/

// There are a total of n courses you have to take, labeled from 0 to n-[1].

// Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

// Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */

const topsort = (numCourses, prereqs) => {
  const sortedOrder = [];
  // construct outdegree
  if (!prereqs.length) return true;

  const indegrees = new Array(numCourses);
  const graph = new Array(numCourses);
  for (let i = 0; i < numCourses; i++) {
    graph[i] = [];
    indegrees[i] = 0;
  }
  for (const pair of prereqs) {
    const [a, b] = pair;
    // add outdegrees
    graph[b].push(a);
    indegrees[a]++;
  }
  // Find vertices with indeg 0
  const queue = [];
  for (let i = 0; i < indegrees.length; i++) {
    if (indegrees[i] === 0) {
      queue.push(i);
    }
  }
  if (queue.length === 0) return false;
  while (queue.length) {
    const v = queue.shift();
    sortedOrder.push(v);
    for (const outgoing of graph[v]) {
      indegrees[outgoing]--;
      if (indegrees[outgoing] === 0) {
        queue.push(outgoing);
      }
    }
  }
  return sortedOrder.length === numCourses;
};

export default function canFinish(numCourses, prerequisites) {
  return topsort(numCourses, prerequisites);
}
```

### Medium/209

```js
// [209]. Minimum Size Subarray Sum

// Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

// Example:

// Input: s = 7, nums = [2,3,1,2,4,3]
// Output: 2
// Explanation: the subarray [4,3] has the minimal length under the problem constraint.
// Follow up:
// If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).

/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
export default function minSubArrayLen(s, nums) {
  let result = Number.MAX_SAFE_INTEGER;
  let left = 0;
  let sum = 0;
  for (let i = 0; i < nums.length; i++) {
    if (result === 1) return 1;
    sum += nums[i];
    while (sum >= s) {
      result = Math.min(i - left + 1, result);
      sum -= nums[left];
      left++;
    }
  }
  return result === Number.MAX_SAFE_INTEGER ? 0 : result;
}
```

### Medium/229

```js
// [229]. Majority Element II

// Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

// Note: The algorithm should run in linear time and in O(1) space.

// Example 1:

// Input: [3,2,3]
// Output: [3]
// Example 2:

// Input: [1,1,1,3,3,2,2,2]
// Output: [1,2]

/**
 * @param {number[]} nums
 * @return {number[]}
 */
export default function majorityElement(nums) {
  if (!nums.length) return [];
  let count1 = 0;
  let count2 = 0;
  let maj1 = null;
  let maj2 = null;
  // Find the two numbers that occur the most
  for (const num of nums) {
    if (num === maj1) {
      count1++;
    } else if (num === maj2) {
      count2++;
    } else if (count1 === 0) {
      maj1 = num;
      count1 = 1;
    } else if (count2 === 0) {
      maj2 = num;
      count2 = 1;
    } else {
      count1--;
      count2--;
    }
  }
  // Filter any of the two numbers that do not occur more than len / 3 times
  return [maj1, maj2].filter(e => {
    let i = 0;
    for (const num of nums) {
      if (num === e) {
        i++;
      }
    }
    return i > nums.length / 3;
  });
}
```

### Medium/230

```js
// [230]. Kth Smallest Element in a BST

// Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

// Note:
// You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

// Example 1:

// Input: root = [3,1,4,null,2], k = 1
//    3
//   / \
//  1   4
//   \
//    2
// Output: 1
// Example 2:

// Input: root = [5,3,6,2,4,null,null,1], k = 3
//        5
//       / \
//      3   6
//     / \
//    2   4
//   /
//  1
// Output: 3
// Follow up:
// What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

const kthSmallestAux = (root, ans) => {
  if (!root) return;
  if (root.left) kthSmallestAux(root.left, ans);
  ans.push(root.val);
  if (root.right) kthSmallestAux(root.right, ans);
};

/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
export default function kthSmallest(root, k) {
  if (!root) return -1;
  const ans = [];
  kthSmallestAux(root, ans);
  return ans[k - 1];
}
```

### Medium/236

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */

const trav = (root, node, path, paths) => {
  if (root === null) return;
  path.push(root);
  if (root.val === node.val) {
    paths.push(path);
    return;
  }
  if (root.left) trav(root.left, node, [...path], paths);
  if (root.right) trav(root.right, node, [...path], paths);
};

export default function lowestCommonAncestor(root, p, q) {
  let set = new Set();
  {
    const paths = [];
    trav(root, p, [], paths);
    if (!paths.length) return -1;
    const [path] = paths;
    if (path) set = new Set(path);
  }
  const paths = [];
  trav(root, q, [], paths);
  if (!paths.length) return -1;
  const [path] = paths;
  for (const item of path) {
    if (set.has(item)) return item;
  }
}
```

### [201].bitwise-and-of-numbers-range

#### 题目地址

https://leetcode.com/problems/bitwise-and-of-numbers-range/description/

#### 题目描述

```
Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

Example 1:

Input: [5,7]
Output: 4
Example 2:

Input: [0,1]
Output: 0

```

#### 思路

一个显而易见的解法是， 从 m 到 n 依次进行`求与`的操作。

```js
let res = m;
for (let i = m + 1; i <= n; i++) {
  res = res & i;
}
return res;
```

但是， 如果你把这个 solution 提交的话，很显然不会通过， 会超时。

我们依旧还是用 trick 来简化操作。 我们利用的性质是， n 个连续数字求与的时候，前 m 位都是 1.

举题目给的例子：[5,7] 共 5， 6，7 三个数字， 用二进制表示 101, 110,111,
这三个数字特点是第一位都是 1，后面几位求与一定是 0.

再来一个明显的例子：[20, 24], 共 20， 21， 22， 23，24 五个数字，二进制表示就是

```
0001 0100
0001 0101
0001 0110
0001 0111
0001 1000
```

这五个数字特点是第四位都是 1，后面几位求与一定是 0.

因此我们的思路就是， 求出这个数字区间的数字前多少位都是 1 了，那么他们求与的结果一定是前几位数字，然后后面都是 0.

#### 关键点解析

- n 个连续数字求与的时候，前 m 位都是 1

- 可以用递归实现， 个人认为比较难想到

- bit 运算

代码：

```js
n > m ? rangeBitwiseAnd(m / 2, n / 2) << 1 : m;
```

> 每次问题规模缩小一半， 这是二分法吗？

#### 代码

```js
/*
 * @lc app=leetcode id=201 lang=javascript
 *
 * [201] Bitwise AND of Numbers Range
 *
 * https://leetcode.com/problems/bitwise-and-of-numbers-range/description/
 *
 * algorithms
 * Medium (35.58%)
 * Total Accepted:    78.9K
 * Total Submissions: 221.3K
 * Testcase Example:  '5\n7'
 *
 * Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND
 * of all numbers in this range, inclusive.
 *
 * Example 1:
 *
 *
 * Input: [5,7]
 * Output: 4
 *
 *
 * Example 2:
 *
 *
 * Input: [0,1]
 * Output: 0
 */
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var rangeBitwiseAnd = function(m, n) {
  let count = 0;
  while (m !== n) {
    m = m >> 1;
    n = n >> 1;
    count++;
  }

  return n << count;
};
```

### [203].remove-linked-list-elements

#### 题目地址

https://leetcode.com/problems/remove-linked-list-elements/description/

#### 题目描述

```
Remove all elements from a linked list of integers that have value val.

Example:

Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5

```

#### 思路

这个一个链表基本操作的题目，思路就不多说了。

#### 关键点解析

- 链表的基本操作(删除指定节点)
- 虚拟节点 dummy 简化操作

> 其实设置 dummy 节点就是为了处理特殊位置(头节点)，这这道题就是如果头节点是给定的需要删除的节点呢？
> 为了保证代码逻辑的一致性，即不需要为头节点特殊定制逻辑，才采用的虚拟节点。

- 如果连续两个节点都是要删除的节点，这个情况容易被忽略。
  eg:

```js
// 只有下个节点不是要删除的节点才更新current
if (!next || next.val !== val) {
  current = next;
}
```

#### 代码

```js
/*
 * @lc app=leetcode id=203 lang=javascript
 *
 * [203] Remove Linked List Elements
 *
 * https://leetcode.com/problems/remove-linked-list-elements/description/
 *
 * algorithms
 * Easy (35.32%)
 * Total Accepted:    211.9K
 * Total Submissions: 598.6K
 * Testcase Example:  '[1,2,6,3,4,5,6]\n6'
 *
 * Remove all elements from a linked list of integers that have value val.
 *
 * Example:
 *
 *
 * Input:  1->2->6->3->4->5->6, val = 6
 * Output: 1->2->3->4->5
 *
 *
 */

/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
  const dummy = {
    next: head,
  };
  let current = dummy;

  while (current && current.next) {
    let next = current.next;
    if (next.val === val) {
      current.next = next.next;
      next = next.next;
    }

    if (!next || next.val !== val) {
      current = next;
    }
  }

  return dummy.next;
};
```

### [206].reverse-linked-list

Reverse a singly linked list.

Example:

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
Follow up:

A linked list can be reversed either iteratively or recursively. Could you implement both?

#### 思路

这个就是常规操作了，使用一个变量记录前驱 pre，一个变量记录后继 next.

不断更新`current.next = pre` 就好了

#### 关键点解析

需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题

- 链表的基本操作(交换)
- 虚拟节点 dummy 简化操作
- 注意更新 current 和 pre 的位置， 否则有可能出现溢出

#### 代码

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (!head || !head.next) return head;

  let cur = head;
  let pre = null;

  while (cur) {
    const next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }

  return pre;
};
```

```js
var reverseList = function(head) {
  // 判断下变量边界问题
  if (!head || !head.next) return head;
  // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null
  let pre = null;
  let current = head;
  let next;
  // 判断当前节点是否为空
  // 不为空就先获取当前节点的下一节点
  // 然后把当前节点的 next 设为上一个节点
  // 然后把 current 设为下一个节点，pre 设为当前节点
  while (current) {
    next = current.next;
    current.next = pre;
    pre = current;
    current = next;
  }
  return pre;
};
```

#### 拓展

通过单链表的定义可以得知，单链表也是递归结构，因此，也可以使用递归的方式来进行 reverse 操作。

> 由于单链表是线性的，使用递归方式将导致栈的使用也是线性的，当链表长度达到一定程度时，递归会导致爆栈，因此，现实中并不推荐使用递归方式来操作链表。

##### 描述

1. 除第一个节点外，递归将链表 reverse
2. 将第一个节点添加到已 reverse 的链表之后

> 这里需要注意的是，每次需要保存已经 reverse 的链表的头节点和尾节点

### [208].implement-trie-prefix-tree

#### 题目地址

https://leetcode.com/problems/implement-trie-prefix-tree/description/

#### 题目描述

```
Implement a trie with insert, search, and startsWith methods.

Example:

Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");
trie.search("app");     // returns true
Note:

You may assume that all inputs are consist of lowercase letters a-z.
All inputs are guaranteed to be non-empty strings.

```

#### 思路

这是一道很直接的题目，上来就让你实现`前缀树(字典树)`。这算是基础数据结构中的
知识了，不清楚什么是字典树的可以查阅相关资料。

我们看到题目给出的使用方法`new Trie`, `insert`,`search`和`startWith`.

为了区分`search`和`startWith`我们需要增加一个标示来区分当前节点是否是某个单词的结尾。
因此节点的数据结构应该是:

```js
function TrieNode(val) {
  this.val = val; // 当前的字母
  this.children = []; // 题目要求字典仅有a-z，那么其长度最大为26(26个字母)
  this.isWord = false;
}
```

每次 insert 我们其实都是从根节点出发，一个一个找到我们需要添加的节点，修改 children 的值.

我们应该修改哪一个 child 呢？ 我们需要一个函数来计算索引

```js
function computeIndex(c) {
  return c.charCodeAt(0) - 'a'.charCodeAt(0);
}
```

其实不管 insert， search 和 startWith 的逻辑都是差不多的，都是从 root 出发，
找到我们需要操作的 child， 然后进行相应操作(添加，修改，返回)。

#### 关键点解析

- 前缀树

- 核心逻辑

```js
 const c = word[i];
 const current = computeIndex(c)
if (!ws.children[current]) {
    ws.children[current] = new TrieNode(c);
  }
  ws = ws.children[current]; // 深度递增
}

```

#### 代码

```js
/*
 * @lc app=leetcode id=208 lang=javascript
 *
 * [208] Implement Trie (Prefix Tree)
 *
 * https://leetcode.com/problems/implement-trie-prefix-tree/description/
 *
 * algorithms
 * Medium (36.93%)
 * Total Accepted:    172K
 * Total Submissions: 455.5K
 * Testcase Example:  '["Trie","insert","search","search","startsWith","insert","search"]\n[[],["apple"],["apple"],["app"],["app"],["app"],["app"]]'
 *
 * Implement a trie with insert, search, and startsWith methods.
 *
 * Example:
 *
 *
 * Trie trie = new Trie();
 *
 * trie.insert("apple");
 * trie.search("apple");   // returns true
 * trie.search("app");     // returns false
 * trie.startsWith("app"); // returns true
 * trie.insert("app");
 * trie.search("app");     // returns true
 *
 *
 * Note:
 *
 *
 * You may assume that all inputs are consist of lowercase letters a-z.
 * All inputs are guaranteed to be non-empty strings.
 *
 *
 */
function TrieNode(val) {
  this.val = val;
  this.children = [];
  this.isWord = false;
}

function computeIndex(c) {
  return c.charCodeAt(0) - 'a'.charCodeAt(0);
}
/**
 * Initialize your data structure here.
 */
var Trie = function() {
  this.root = new TrieNode(null);
};

/**
 * Inserts a word into the trie.
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
  let ws = this.root;
  for (let i = 0; i < word.length; i++) {
    const c = word[i];
    const current = computeIndex(c);
    if (!ws.children[current]) {
      ws.children[current] = new TrieNode(c);
    }
    ws = ws.children[current];
  }
  ws.isWord = true;
};

/**
 * Returns if the word is in the trie.
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
  let ws = this.root;
  for (let i = 0; i < word.length; i++) {
    const c = word[i];
    const current = computeIndex(c);
    if (!ws.children[current]) return false;
    ws = ws.children[current];
  }
  return ws.isWord;
};

/**
 * Returns if there is any word in the trie that starts with the given prefix.
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
  let ws = this.root;
  for (let i = 0; i < prefix.length; i++) {
    const c = prefix[i];
    const current = computeIndex(c);
    if (!ws.children[current]) return false;
    ws = ws.children[current];
  }
  return true;
};

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */
```

### [209].minimum-size-subarray-sum

#### 题目地址

https://leetcode.com/problems/minimum-size-subarray-sum/description/

#### 题目描述

```
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

Example:

Input: s = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: the subarray [4,3] has the minimal length under the problem constraint.
Follow up:
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).

```

#### 思路

用滑动窗口来记录序列， 每当滑动窗口中的 sum 超过 s， 就去更新最小值，并根据先进先出的原则更新滑动窗口，直至 sum 刚好小于 s

> 这道题目和 leetcode 3 号题目有点像，都可以用滑动窗口的思路来解决

#### 关键点

- 滑动窗口简化操作(滑窗口适合用于求解这种要求`连续`的题目)

#### 代码

```js
/*
 * @lc app=leetcode id=209 lang=javascript
 *
 * [209] Minimum Size Subarray Sum
 *
 * https://leetcode.com/problems/minimum-size-subarray-sum/description/
 *
 * algorithms
 * Medium (34.31%)
 * Total Accepted:    166.9K
 * Total Submissions: 484.9K
 * Testcase Example:  '7\n[2,3,1,2,4,3]'
 *
 * Given an array of n positive integers and a positive integer s, find the
 * minimal length of a contiguous subarray of which the sum ≥ s. If there isn't
 * one, return 0 instead.
 *
 * Example:
 *
 *
 * Input: s = 7, nums = [2,3,1,2,4,3]
 * Output: 2
 * Explanation: the subarray [4,3] has the minimal length under the problem
 * constraint.
 *
 * Follow up:
 *
 * If you have figured out the O(n) solution, try coding another solution of
 * which the time complexity is O(n log n).
 *
 */
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
  if (nums.length === 0) return 0;
  const slideWindow = [];
  let acc = 0;
  let min = null;

  for (let i = 0; i < nums.length + 1; i++) {
    const num = nums[i];

    while (acc >= s) {
      if (min === null || slideWindow.length < min) {
        min = slideWindow.length;
      }
      acc = acc - slideWindow.shift();
    }

    slideWindow.push(num);

    acc = slideWindow.reduce((a, b) => a + b, 0);
  }

  return min || 0;
};
```

#### 扩展

如果题目要求是 sum = s, 而不是 sum >= s 呢？

eg:

```js
var minSubArrayLen = function(s, nums) {
  if (nums.length === 0) return 0;
  const slideWindow = [];
  let acc = 0;
  let min = null;

  for (let i = 0; i < nums.length + 1; i++) {
    const num = nums[i];

    while (acc > s) {
      acc = acc - slideWindow.shift();
    }
    if (acc === s) {
      if (min === null || slideWindow.length < min) {
        min = slideWindow.length;
      }
      slideWindow.shift();
    }

    slideWindow.push(num);

    acc = slideWindow.reduce((a, b) => a + b, 0);
  }

  return min || 0;
};
```

### [211].add-and-search-word-data-structure-design

#### 题目地址(211. 添加与搜索单词 - 数据结构设计)

https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/description/

#### 题目描述

```
设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)
search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。

示例:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
说明:

你可以假设所有单词都是由小写字母 a-z 组成的。

```

#### 思路

我们首先不考虑字符"."的情况。这种情况比较简单，我们 addWord 直接添加到数组尾部，search 则线性查找即可。

接下来我们考虑特殊字符“.”，其实也不难，只不过 search 的时候，判断如果是“.”, 我们认为匹配到了，继续往后匹配即可。

上面的代码复杂度会比较高，我们考虑优化。如果你熟悉前缀树的话，应该注意到这可以使用前缀树来进行优化。前缀树优化之后每次查找复杂度是$O(h)$, 其中 h 是前缀树深度，也就是最长的字符串长度。

关于前缀树，LeetCode 有很多题目。有的是直接考察，让你实现一个前缀树，有的是间接考察，比如本题。前缀树代码见下方，大家之后可以直接当成前缀树的解题模板使用。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb5dmstsxxj30mz0gqmzh.jpg)

由于我们这道题需要考虑特殊字符"."，因此我们需要对标准前缀树做一点改造，insert 不做改变，我们只需要改变 search 即可，代码(Python 3)：

```python
def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        curr = self.Trie
        for i, w in enumerate(word):
            if w == '.':
                wizards = []
                for k in curr.keys():
                    if k == '#':
                        continue
                    wizards.append(self.search(word[:i] + k + word[i + 1:]))
                return any(wizards)
            if w not in curr:
                return False
            curr = curr[w]
        return "#" in curr
```

标准的前缀树搜索我也贴一下代码，大家可以对比一下：

```python
def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        curr = self.Trie
        for w in word:
            if w not in curr:
                return False
            curr = curr[w]
        return "#" in curr
```

#### 关键点

- 前缀树(也叫字典树)，英文名 Trie(读作 tree 或者 try)

#### 代码

- 语言支持：Python3

Python3 Code：

关于 Trie 的代码:

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.Trie = {}

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        curr = self.Trie
        for w in word:
            if w not in curr:
                curr[w] = {}
            curr = curr[w]
        curr['#'] = 1

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        curr = self.Trie
        for i, w in enumerate(word):
            if w == '.':
                wizards = []
                for k in curr.keys():
                    if k == '#':
                        continue
                    wizards.append(self.search(word[:i] + k + word[i + 1:]))
                return any(wizards)
            if w not in curr:
                return False
            curr = curr[w]
        return "#" in curr
```

主逻辑代码：

```python
class WordDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie = Trie()

    def addWord(self, word: str) -> None:
        """
        Adds a word into the data structure.
        """
        self.trie.insert(word)

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        """
        return self.trie.search(word)


### Your WordDictionary object will be instantiated and called as such:
### obj = WordDictionary()
### obj.addWord(word)
### param_2 = obj.search(word)
```

#### 相关题目

- [208.implement-trie-prefix-tree](./208.implement-trie-prefix-tree.md)
- [212.word-search-ii](./212.word-search-ii.md)
- [472.concatenated-words](./problems/472.concatenated-words.md)

### [212].word-search-ii

#### 题目地址(212. 单词搜索 II)

https://leetcode-cn.com/problems/word-search-ii/description/

#### 题目描述

```
给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

示例:

输入:
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

输出: ["eat","oath"]
说明:
你可以假设所有输入都由小写字母 a-z 组成。

提示:

你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？
如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie(前缀树)。

```

#### 思路

我们需要对矩阵中每一项都进行深度优先遍历(DFS)。 递归的终点是

1. 超出边界
2. 递归路径上组成的单词不在 words 的前缀。

比如题目示例：words = ["oath","pea","eat","rain"]，那么对于 oa，oat 满足条件，因为他们都是 oath 的前缀，但是 oaa 就不满足条件。

为了防止环的出现，我们需要记录访问过的节点。而返回结果是需要去重的。出于简单考虑，我们使用集合(set)，最后返回的时候重新转化为 list。

刚才我提到了一个关键词“前缀”，我们考虑使用前缀树来优化。使得复杂度降低为$O(h)$, 其中 h 是前缀树深度，也就是最长的字符串长度。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gb5dmstsxxj30mz0gqmzh.jpg)

#### 关键点

- 前缀树(也叫字典树)，英文名 Trie(读作 tree 或者 try)
- DFS
- hashmap 结合 dfs 记录访问过的元素的时候，注意结束之后需要将 hashmap 的值重置。(下方代码的`del seen[(i, j)]`)

#### 代码

- 语言支持：Python3

Python3 Code：

关于 Trie 的代码:

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.Trie = {}

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        curr = self.Trie
        for w in word:
            if w not in curr:
                curr[w] = {}
            curr = curr[w]
        curr['#'] = 1

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """

        curr = self.Trie
        for w in prefix:
            if w not in curr:
                return False
            curr = curr[w]
        return True
```

主逻辑代码：

```python
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        m = len(board)
        if m == 0:
            return []
        n = len(board[0])
        trie = Trie()
        seen = None
        res = set()
        for word in words:
            trie.insert(word)

        def dfs(s, i, j):
            if (i, j) in seen or i < 0 or i >= m or j < 0 or j >= n or not trie.startsWith(s):
                return
            s += board[i][j]
            seen[(i, j)] = True

            if s in words:
                res.add(s)
            dfs(s, i + 1, j)
            dfs(s, i - 1, j)
            dfs(s, i, j + 1)
            dfs(s, i, j - 1)

            del seen[(i, j)]

        for i in range(m):
            for j in range(n):
                seen = dict()
                dfs("", i, j)
        return list(res)
```

#### 相关题目

- [208.implement-trie-prefix-tree](./208.implement-trie-prefix-tree.md)
- [211.add-and-search-word-data-structure-design](./211.add-and-search-word-data-structure-design.md)
- [472.concatenated-words](./problems/472.concatenated-words.md)

### [215].kth-largest-element-in-an-array

#### 题目地址

https://leetcode.com/problems/kth-largest-element-in-an-array/

#### 题目描述

```
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

Input: [3,2,1,5,6,4] and k = 2
Output: 5
Example 2:

Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
Note:
You may assume k is always valid, 1 ≤ k ≤ array's length.
```

#### 思路

这道题要求在一个无序的数组中，返回第 K 大的数。根据时间复杂度不同，这题有 3 种不同的解法。

###### 解法一 (排序)

很直观的解法就是给数组排序，这样求解第`K`大的数，就等于是从小到大排好序的数组的第`(n-K)`小的数 (n 是数组的长度)。

例如：

```
[3,2,1,5,6,4], k = 2
1. 数组排序：
 [1,2,3,4,5,6]，
2. 找第(n-k)小的数
 n-k=4, nums[4]=5 (第2大的数)
```

_时间复杂度:_ `O(nlogn) - n 是数组长度。`

###### 解法二 - 小顶堆(Heap)

可以维护一个大小为`K`的小顶堆，堆顶是最小元素，当堆的`size > K` 的时候，删除堆顶元素.
扫描一遍数组，最后堆顶就是第`K`大的元素。 直接返回。

例如：

_时间复杂度_：`O(n * logk) , n is array length`
_空间复杂度_：`O(k)`

跟排序相比，以空间换时间。

###### 解法三 - Quick Select

Quick Select 类似快排，选取 pivot，把小于 pivot 的元素都移到 pivot 之前，这样 pivot 所在位置就是第 pivot index 小的元素。
但是不需要完全给数组排序，只要找到当前 pivot 的位置是否是在第(n-k)小的位置，如果是，找到第 k 大的数直接返回。

具体步骤：

```
1. 在数组区间随机取`pivot index = left + random[right-left]`.
2. 根据pivot 做 partition，在数组区间，把小于pivot的数都移到pivot左边。
3. 得到pivot的位置 index，`compare(index, (n-k))`.
    a. index == n-k -> 找到第`k`大元素，直接返回结果。
    b. index < n-k -> 说明在`index`右边，继续找数组区间`[index+1, right]`
    c. index > n-k -> 那么第`k`大数在`index`左边，继续查找数组区间`[left, index-1]`.

例子，【3,2,3,1,2,4,5,5,6]， k = 4

如下图：
```

_时间复杂度_：

- 平均是：`O(n)`
- 最坏的情况是：`O(n * n)`

#### 关键点分析

1. 直接排序很简单
2. 堆(Heap)主要是要维护一个 K 大小的小顶堆，扫描一遍数组，最后堆顶元素即是所求。
3. Quick Select, 关键是是取 pivot，对数组区间做 partition，比较 pivot 的位置，类似二分，取 pivot 左边或右边继续递归查找。

#### 代码(Java code)

_解法一 - 排序_

```java
class KthLargestElementSort {
 public int findKthlargest2(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
  }
}
```

_解法二 - Heap (PriorityQueue)_

```java
class KthLargestElementHeap {
  public int findKthLargest(int[] nums, int k) {
      PriorityQueue<Integer> pq = new PriorityQueue<>();
      for (int num : nums) {
        pq.offer(num);
        if (pq.size() > k) {
          pq.poll();
        }
      }
      return pq.poll();
  }
}
```

_解法三 - Quick Select_

```java
class KthLargestElementQuickSelect {
    static Random random = new Random();
    public int findKthLargest3(int[] nums, int k) {
      int len = nums.length;
      return select(nums, 0, len - 1, len - k);
    }

    private int select(int[] nums, int left, int right, int k) {
      if (left == right) return nums[left];
      // random select pivotIndex between left and right
      int pivotIndex = left + random.nextInt(right - left);
      // do partition, move smaller than pivot number into pivot left
      int pos = partition(nums, left, right, pivotIndex);
      if (pos == k) {
        return nums[pos];
      } else if (pos > k) {
        return select(nums, left, pos - 1, k);
      } else {
        return select(nums, pos + 1, right, k);
      }
    }

    private int partition(int[] nums, int left, int right, int pivotIndex) {
      int pivot = nums[pivotIndex];
      // move pivot to end
      swap(nums, right, pivotIndex);
      int pos = left;
      // move smaller num to pivot left
      for (int i = left; i <= right; i++) {
        if (nums[i] < pivot) {
          swap(nums, pos++, i);
        }
      }
      // move pivot to original place
      swap(nums, right, pos);
      return pos;
    }

    private void swap(int[] nums, int i, int j) {
      int tmp = nums[i];
      nums[i] = nums[j];
      nums[j] = tmp;
    }
}
```

### [219].contains-duplicate-ii

#### 题目地址

https://leetcode.com/problems/contains-duplicate-ii/description/

#### 题目描述

```
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false

```

#### 思路

由于题目没有对空间复杂度有求，用一个 hashmap 存储已经访问过的数字即可,
每次访问都会看 hashmap 中是否有这个元素，有的话拿出索引进行比对，是否满足条件(相隔不大于 k)，如果满足返回 true 即可。

#### 关键点解析

无

#### 代码

```js
/*
 * @lc app=leetcode id=219 lang=javascript
 *
 * [219] Contains Duplicate II
 *
 * https://leetcode.com/problems/contains-duplicate-ii/description/
 *
 * algorithms
 * Easy (34.75%)
 * Total Accepted:    187.3K
 * Total Submissions: 537.5K
 * Testcase Example:  '[1,2,3,1]\n3'
 *
 * Given an array of integers and an integer k, find out whether there are two
 * distinct indices i and j in the array such that nums[i] = nums[j] and the
 * absolute difference between i and j is at most k.
 *
 *
 * Example 1:
 *
 *
 * Input: nums = [1,2,3,1], k = 3
 * Output: true
 *
 *
 *
 * Example 2:
 *
 *
 * Input: nums = [1,0,1,1], k = 1
 * Output: true
 *
 *
 *
 * Example 3:
 *
 *
 * Input: nums = [1,2,3,1,2,3], k = 2
 * Output: false
 *
 *
 *
 *
 *
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
  const visited = {};
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    if (visited[num] !== undefined && i - visited[num] <= k) {
      return true;
    }
    visited[num] = i;
  }
  return false;
};
```

### [226].invert-binary-tree

#### 题目地址

https://leetcode.com/problems/invert-binary-tree/description/

#### 题目描述

```
Invert a binary tree.

Example:

Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
Trivia:
This problem was inspired by this original tweet by Max Howell:

Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.
```

#### 思路

遍历树(随便怎么遍历)，然后将左右子树交换位置。

#### 关键点解析

- 递归简化操作
- 如果树很高，建议使用栈来代替递归
- 这道题目对顺序没要求的，因此队列数组操作都是一样的，无任何区别

#### 代码

```js
/*
 * @lc app=leetcode id=226 lang=javascript
 *
 * [226] Invert Binary Tree
 *
 * https://leetcode.com/problems/invert-binary-tree/description/
 *
 * algorithms
 * Easy (57.14%)
 * Total Accepted:    311K
 * Total Submissions: 540.6K
 * Testcase Example:  '[4,2,7,1,3,6,9]'
 *
 * Invert a binary tree.
 *
 * Example:
 *
 * Input:
 *
 *
 * ⁠    4
 * ⁠  /   \
 * ⁠ 2     7
 * ⁠/ \   / \
 * 1   3 6   9
 *
 * Output:
 *
 *
 * ⁠    4
 * ⁠  /   \
 * ⁠ 7     2
 * ⁠/ \   / \
 * 9   6 3   1
 *
 * Trivia:
 * This problem was inspired by this original tweet by Max Howell:
 *
 * Google: 90% of our engineers use the software you wrote (Homebrew), but you
 * can’t invert a binary tree on a whiteboard so f*** off.
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
  if (!root) return root;
  // 递归
  //   const left = root.left;
  //   const right = root.right;
  //   root.right = invertTree(left);
  //   root.left = invertTree(right);
  // 我们用stack来模拟递归
  // 本质上递归是利用了执行栈，执行栈也是一种栈
  // 其实这里使用队列也是一样的，因为这里顺序不重要

  const stack = [root];
  let current = null;
  while ((current = stack.shift())) {
    const left = current.left;
    const right = current.right;
    current.right = left;
    current.left = right;
    if (left) {
      stack.push(left);
    }
    if (right) {
      stack.push(right);
    }
  }
  return root;
};
```

### [230].kth-smallest-element-in-a-bst

#### 题目地址

https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/

#### 题目描述

```
Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note:
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

Example 1:

Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1
Example 2:

Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
Follow up:
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

```

#### 思路

由于‘中序遍历一个二叉查找树(BST)的结果是一个有序数组’ ，因此我们只需要在遍历到第 k 个，返回当前元素即可。
中序遍历相关思路请查看[binary-tree-traversal](../thinkings/binary-tree-traversal.md)

#### 关键点解析

- 中序遍历

#### 代码

```js
/*
 * @lc app=leetcode id=230 lang=javascript
 *
 * [230] Kth Smallest Element in a BST
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
  const stack = [root];
  let cur = root;
  let i = 0;

  function insertAllLefts(cur) {
    while (cur && cur.left) {
      const l = cur.left;
      stack.push(l);
      cur = l;
    }
  }
  insertAllLefts(cur);

  while ((cur = stack.pop())) {
    i++;
    if (i === k) return cur.val;
    const r = cur.right;

    if (r) {
      stack.push(r);
      insertAllLefts(r);
    }
  }

  return -1;
};
```

#### 扩展

这道题有一个 follow up：

`What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?`

大家可以思考一下。

### [232].implement-queue-using-stacks

#### 题目地址

https://leetcode.com/problems/implement-queue-using-stacks/description/

#### 题目描述

```
Implement the following operations of a queue using stacks.

push(x) -- Push element x to the back of queue.
pop() -- Removes the element from in front of queue.
peek() -- Get the front element.
empty() -- Return whether the queue is empty.
Example:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // returns 1
queue.pop();   // returns 1
queue.empty(); // returns false
Notes:

You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).
```

#### 思路

这道题目是让我们用栈来模拟实现队列。 我们直到栈和队列都是一种受限的数据结构。
栈的特点是只能在一端进行所有操作，队列的特点是只能在一端入队，另一端出队。

在这里我们可以借助另外一个栈，也就是说用两个栈来实现队列的效果。这种做法的时间复杂度和空间复杂度都是 O(n)。

由于栈只能操作一端，因此我们 peek 或者 pop 的时候也只去操作顶部元素，要达到目的
我们需要在 push 的时候将队头的元素放到栈顶即可。

因此我们只需要在 push 的时候，用一下辅助栈即可。
具体做法是先将栈清空并依次放到另一个辅助栈中，辅助栈中的元素再次放回栈中，最后将新的元素 push 进去即可。

比如我们现在栈中已经是 1，2，3，4 了。 我们现在要 push 一个 5.

push 之前是这样的：

然后我们将栈中的元素转移到辅助栈：

最后将新的元素添加到栈顶。

整个过程是这样的：

#### 关键点解析

- 在 push 的时候利用辅助栈(双栈)

#### 代码

```js
/*
 * @lc app=leetcode id=232 lang=javascript
 *
 * [232] Implement Queue using Stacks
 */
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
  // tag: queue stack array
  this.stack = [];
  this.helperStack = [];
};

/**
 * Push element x to the back of queue.
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
  let cur = null;
  while ((cur = this.stack.pop())) {
    this.helperStack.push(cur);
  }
  this.helperStack.push(x);

  while ((cur = this.helperStack.pop())) {
    this.stack.push(cur);
  }
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
  return this.stack.pop();
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
  return this.stack[this.stack.length - 1];
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
  return this.stack.length === 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

#### 扩展

- 类似的题目有用队列实现栈，思路是完全一样的，大家有兴趣可以试一下。
- 栈混洗也是借助另外一个栈来完成的，从这点来看，两者有相似之处。

### [236].lowest-common-ancestor-of-a-binary-tree

#### 题目地址

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/

#### 题目描述

```
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]

```

```
Example 1:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
Example 2:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.


Note:

All of the nodes' values will be unique.
p and q are different and both values will exist in the binary tree.
```

#### 思路

这道题目是求解二叉树中，两个给定节点的最近的公共祖先。是一道非常经典的二叉树题目。

我们之前说过树是一种递归的数据结构，因此使用递归方法解决二叉树问题从写法上来看是最简单的，这道题目也不例外。

用递归的思路去思考树是一种非常重要的能力。

如果大家这样去思考的话，问题就会得到简化，我们的目标就是分别在左右子树进行查找 p 和 q。 如果 p 没有在左子树，那么它一定在右子树(题目限定 p 一定在树中)，
反之亦然。

对于具体的代码而言就是，我们假设这个树就一个结构，然后尝试去解决，然后在适当地方去递归自身即可。 如下图所示：

我们来看下核心代码：

```js
// 如果我们找到了p，直接进行返回，那如果下面就是q呢？ 其实这没有影响，但是还是要多考虑一下
if (!root || root === p || root === q) return root;
const left = lowestCommonAncestor(root.left, p, q); // 去左边找，我们期望返回找到的节点
const right = lowestCommonAncestor(root.right, p, q); // 去右边找，我们期望返回找到的节点
if (!left) return right; // 左子树找不到，返回右子树
if (!right) return left; // 右子树找不到，返回左子树
return root; // 左右子树分别有一个，则返回root
```

> 如果没有明白的话，请多花时间消化一下

#### 关键点解析

- 用递归的思路去思考树

#### 代码

```js
/*
 * @lc app=leetcode id=236 lang=javascript
 *
 * [236] Lowest Common Ancestor of a Binary Tree
 *
 * https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
 *
 * algorithms
 * Medium (35.63%)
 * Total Accepted:    267.3K
 * Total Submissions: 729.2K
 * Testcase Example:  '[3,5,1,6,2,0,8,null,null,7,4]\n5\n1'
 *
 * Given a binary tree, find the lowest common ancestor (LCA) of two given
 * nodes in the tree.
 *
 * According to the definition of LCA on Wikipedia: “The lowest common ancestor
 * is defined between two nodes p and q as the lowest node in T that has both p
 * and q as descendants (where we allow a node to be a descendant of itself).”
 *
 * Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]
 *
 *
 *
 * Example 1:
 *
 *
 * Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
 * Output: 3
 * Explanation: The LCA of nodes 5 and 1 is 3.
 *
 *
 * Example 2:
 *
 *
 * Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
 * Output: 5
 * Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant
 * of itself according to the LCA definition.
 *
 *
 *
 *
 * Note:
 *
 *
 * All of the nodes' values will be unique.
 * p and q are different and both values will exist in the binary tree.
 *
 *
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  if (!root || root === p || root === q) return root;
  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);
  if (!left) return right; // 左子树找不到，返回右子树
  if (!right) return left; // 右子树找不到，返回左子树
  return root; // 左右子树分别有一个，则返回root
};
```

#### 扩展

如果递归的结束条件改为`if (!root || root.left === p || root.right === q) return root;` 代表的是什么意思，对结果有什么样的影响？

### [238].product-of-array-except-self

#### 题目地址

https://leetcode.com/problems/product-of-array-except-self/description/

#### 题目描述

```
Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:

Input:  [1,2,3,4]
Output: [24,12,8,6]
Note: Please solve it without division and in O(n).

Follow up:
Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)


```

#### 思路

这道题的意思是给定一个数组，返回一个新的数组，这个数组每一项都是其他项的乘积。
符合直觉的思路是两层循环，时间复杂度是 O(n),但是题目要求`Please solve it without division and in O(n)`。

因此我们需要换一种思路，由于输出的每一项都需要用到别的元素，因此一次遍历是绝对不行的。
考虑我们先进行一次遍历， 然后维护一个数组，第 i 项代表前 i 个元素(不包括 i)的乘积。
然后我们反向遍历一次，然后维护另一个数组，同样是第 i 项代表前 i 个元素(不包括 i)的乘积。

有意思的是第一个数组和第二个数组的反转(reverse)做乘法(有点像向量运算)就是我们想要的运算。

其实我们进一步观察，我们不需要真的创建第二个数组(第二个数组只是做中间运算使用)，而是直接修改第一个数组即可。

#### 关键点解析

- 两次遍历， 一次正向，一次反向。
- 维护一个数组，第 i 项代表前 i 个元素(不包括 i)的乘积

#### 代码

```js
/*
 * @lc app=leetcode id=238 lang=javascript
 *
 * [238] Product of Array Except Self
 *
 * https://leetcode.com/problems/product-of-array-except-self/description/
 *
 * algorithms
 * Medium (53.97%)
 * Total Accepted:    246.5K
 * Total Submissions: 451.4K
 * Testcase Example:  '[1,2,3,4]'
 *
 * Given an array nums of n integers where n > 1,  return an array output such
 * that output[i] is equal to the product of all the elements of nums except
 * nums[i].
 *
 * Example:
 *
 *
 * Input:  [1,2,3,4]
 * Output: [24,12,8,6]
 *
 *
 * Note: Please solve it without division and in O(n).
 *
 * Follow up:
 * Could you solve it with constant space complexity? (The output array does
 * not count as extra space for the purpose of space complexity analysis.)
 *
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  const ret = [];

  for (let i = 0, temp = 1; i < nums.length; i++) {
    ret[i] = temp;
    temp *= nums[i];
  }
  // 此时ret[i]存放的是前i个元素相乘的结果(不包含第i个)

  // 如果没有上面的循环的话，
  // ret经过下面的循环会变成ret[i]存放的是后i个元素相乘的结果(不包含第i个)

  // 我们的目标是ret[i]存放的所有数字相乘的结果(不包含第i个)

  // 因此我们只需要对于上述的循环产生的ret[i]基础上运算即可
  for (let i = nums.length - 1, temp = 1; i >= 0; i--) {
    ret[i] *= temp;
    temp *= nums[i];
  }
  return ret;
};
```

### [239].sliding-window-maximum

#### 题目地址

https://leetcode.com/problems/sliding-window-maximum/description/

#### 题目描述

```
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.

Example:

Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7]
Explanation:

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Note:
You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array.

Follow up:
Could you solve it in linear time?
```

#### 思路

符合直觉的想法是直接遍历 nums, 然后然后用一个变量 slideWindow 去承载 k 个元素，
然后对 slideWindow 求最大值，这是可以的，时间复杂度是 O(n \* k).代码如下：

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
  // bad 时间复杂度O(n * k)
  if (nums.length === 0 || k === 0) return [];
  let slideWindow = [];
  const ret = [];
  for (let i = 0; i < nums.length - k + 1; i++) {
    for (let j = 0; j < k; j++) {
      slideWindow.push(nums[i + j]);
    }
    ret.push(Math.max(...slideWindow));
    slideWindow = [];
  }
  return ret;
};
```

但是如果真的是这样，这道题也不会是 hard 吧？这道题有一个 follow up，要求你用线性的时间去完成。
我们可以用双端队列来完成，思路是用一个双端队列来保存`接下来的滑动窗口可能成为最大值的数`。具体做法：

- 入队列

- 移除失效元素，失效元素有两种

1. 一种是已经超出窗口范围了，比如我遍历到第 4 个元素，k = 3，那么 i = 0 的元素就不应该出现在双端队列中了
   具体就是`索引大于 i - k + 1的元素都应该被清除`

2. 小于当前元素都没有利用价值了，具体就是`从后往前遍历(双端队列是一个递减队列)双端队列，如果小于当前元素就出队列`

如果你仔细观察的话，发现双端队列其实是一个递减的一个队列。因此队首的元素一定是最大的。用图来表示就是：

#### 关键点解析

- 双端队列简化时间复杂度

- 滑动窗口

#### 代码

```js
/*
 * @lc app=leetcode id=239 lang=javascript
 *
 * [239] Sliding Window Maximum
 *
 * https://leetcode.com/problems/sliding-window-maximum/description/
 *
 * algorithms
 * Hard (37.22%)
 * Total Accepted:    150.8K
 * Total Submissions: 399.5K
 * Testcase Example:  '[1,3,-1,-3,5,3,6,7]\n3'
 *
 * Given an array nums, there is a sliding window of size k which is moving
 * from the very left of the array to the very right. You can only see the k
 * numbers in the window. Each time the sliding window moves right by one
 * position. Return the max sliding window.
 *
 * Example:
 *
 *
 * Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
 * Output: [3,3,5,5,6,7]
 * Explanation:
 *
 * Window position                Max
 * ---------------               -----
 * [1  3  -1] -3  5  3  6  7       3
 * ⁠1 [3  -1  -3] 5  3  6  7       3
 * ⁠1  3 [-1  -3  5] 3  6  7       5
 * ⁠1  3  -1 [-3  5  3] 6  7       5
 * ⁠1  3  -1  -3 [5  3  6] 7       6
 * ⁠1  3  -1  -3  5 [3  6  7]      7
 *
 *
 * Note:
 * You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty
 * array.
 *
 * Follow up:
 * Could you solve it in linear time?
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
  // 双端队列优化时间复杂度, 时间复杂度O(n)
  const deque = []; // 存放在接下来的滑动窗口可能成为最大值的数
  const ret = [];
  for (let i = 0; i < nums.length; i++) {
    // 清空失效元素
    while (deque[0] < i - k + 1) {
      deque.shift();
    }

    while (nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    deque.push(i);

    if (i >= k - 1) {
      ret.push(nums[deque[0]]);
    }
  }
  return ret;
};
```

#### 扩展

##### 为什么用双端队列

因为删除无效元素的时候，会清除队首的元素(索引太小了
)或者队尾(元素太小了)的元素。 因此需要同时对队首和队尾进行操作，使用双端队列是一种合乎情理的做法。

### [240].search-a-2-d-matrix-ii

#### 题目地址

https://leetcode.com/problems/search-a-2d-matrix-ii/description/

#### 题目描述

```
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
Example:

Consider the following matrix:

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.

Given target = 20, return false.

```

#### 思路

符合直觉的做法是两层循环遍历，时间复杂度是 O(m \* n),
有没有时间复杂度更好的做法呢？ 答案是有，那就是充分运用矩阵的特性(横向纵向都递增)，
我们可以从角落(左下或者右上)开始遍历，这样时间复杂度是 O(m + n).

其中蓝色代表我们选择的起点元素， 红色代表目标元素。

#### 关键点解析

- 从角落开始遍历，利用递增的特性简化时间复杂度

#### 代码

```js
/*
 * @lc app=leetcode id=240 lang=javascript
 *
 * [240] Search a 2D Matrix II
 *
 * https://leetcode.com/problems/search-a-2d-matrix-ii/description/
 *
 * algorithms
 * Medium (40.30%)
 * Total Accepted:    170K
 * Total Submissions: 419.1K
 * Testcase Example:  '[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]\n5'
 *
 * Write an efficient algorithm that searches for a value in an m x n matrix.
 * This matrix has the following properties:
 *
 *
 * Integers in each row are sorted in ascending from left to right.
 * Integers in each column are sorted in ascending from top to bottom.
 *
 *
 * Example:
 *
 * Consider the following matrix:
 *
 *
 * [
 * ⁠ [1,   4,  7, 11, 15],
 * ⁠ [2,   5,  8, 12, 19],
 * ⁠ [3,   6,  9, 16, 22],
 * ⁠ [10, 13, 14, 17, 24],
 * ⁠ [18, 21, 23, 26, 30]
 * ]
 *
 *
 * Given target = 5, return true.
 *
 * Given target = 20, return false.
 *
 */
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
  if (!matrix || matrix.length === 0) return 0;

  let colIndex = 0;
  let rowIndex = matrix.length - 1;
  while (rowIndex > 0 && target < matrix[rowIndex][colIndex]) {
    rowIndex--;
  }

  while (colIndex < matrix[0].length) {
    if (target === matrix[rowIndex][colIndex]) return true;
    if (target > matrix[rowIndex][colIndex]) {
      colIndex++;
    } else if (rowIndex > 0) {
      rowIndex--;
    } else {
      return false;
    }
  }

  return false;
};
```

### [263].ugly-number

#### 题目地址

https://leetcode.com/problems/ugly-number/description/

#### 题目描述

```
Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example 1:

Input: 6
Output: true
Explanation: 6 = 2 × 3
Example 2:

Input: 8
Output: true
Explanation: 8 = 2 × 2 × 2
Example 3:

Input: 14
Output: false
Explanation: 14 is not ugly since it includes another prime factor 7.
Note:

1 is typically treated as an ugly number.
Input is within the 32-bit signed integer range: [−231,  231 − 1].

```

#### 思路

题目要求给定一个数字，判断是否为“丑陋数”(ugly number), 丑陋数是指只包含质因子 2, 3, 5 的正整数。

根据定义，我们将给定数字除以 2、3、5(顺序无所谓)，直到无法整除。
如果得到 1，说明是所有因子都是 2 或 3 或 5，如果不是 1，则不是丑陋数。

这就好像我们判断一个数字是否为 n(n 为大于 1 的正整数)的幂次方一样，我们只需要
不断除以 n，直到无法整除，如果得到 1，那么就是 n 的幂次方。 这道题的不同在于
它不再是某一个数字的幂次方，而是三个数字(2，3，5)，不过解题思路还是一样的。

转化为代码可以是：

```js
while (num % 2 === 0) num = num / 2;
while (num % 3 === 0) num = num / 3;
while (num % 5 === 0) num = num / 5;

return num === 1;
```

> 我下方给出的代码是用了递归实现，只是给大家看下不同的写法而已。

#### 关键点

- 数论
- 因数分解

#### 代码

```js
/*
 * @lc app=leetcode id=263 lang=javascript
 *
 * [263] Ugly Number
 */
/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
  // TAG: 数论
  if (num <= 0) return false;
  if (num === 1) return true;

  const list = [2, 3, 5];

  if (list.includes(num)) return true;

  for (let i of list) {
    if (num % i === 0) return isUgly(Math.floor(num / i));
  }
  return false;
};
```

### [279].perfect-squares

#### 题目地址

https://leetcode.com/problems/perfect-squares/description/

#### 题目描述

```
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.

```

#### 思路

直接递归处理即可，但是这种暴力的解法很容易超时。如果你把递归的过程化成一棵树的话(其实就是递归树)，
可以看出中间有很多重复的计算。

如果能将重复的计算缓存下来，说不定能够解决时间复杂度太高的问题。

> 递归对内存的要求也很高， 如果数字非常大，也会面临爆栈的风险，将递归转化为循环可以解决。

递归 + 缓存的方式代码如下：

```js
const mapper = {};

function d(n, level) {
  if (n === 0) return level;

  let i = 1;
  const arr = [];

  while (n - i * i >= 0) {
    const hit = mapper[n - i * i];
    if (hit) {
      arr.push(hit + level);
    } else {
      const depth = d(n - i * i, level + 1) - level;
      mapper[n - i * i] = depth;
      arr.push(depth + level);
    }
    i++;
  }

  return Math.min(...arr);
}
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  return d(n, 0);
};
```

如果使用 DP，其实本质上和递归 + 缓存 差不多。

DP 的代码见代码区。

#### 关键点解析

- 如果用递归 + 缓存， 缓存的设计很重要
  我的做法是 key 就是 n，value 是以 n 为起点，到达底端的深度。
  下次取出缓存的时候用当前的 level + 存的深度 就是我们想要的 level.

- 使用动态规划的核心点还是选和不选的问题

```js
for (let i = 1; i <= n; i++) {
  for (let j = 1; j * j <= i; j++) {
    // 不选(dp[i]) 还是  选(dp[i - j * j])
    dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
  }
}
```

#### 代码

```js
/*
 * @lc app=leetcode id=279 lang=javascript
 *
 * [279] Perfect Squares
 *
 * https://leetcode.com/problems/perfect-squares/description/
 *
 * algorithms
 * Medium (40.98%)
 * Total Accepted:    168.2K
 * Total Submissions: 408.5K
 * Testcase Example:  '12'
 *
 * Given a positive integer n, find the least number of perfect square numbers
 * (for example, 1, 4, 9, 16, ...) which sum to n.
 *
 * Example 1:
 *
 *
 * Input: n = 12
 * Output: 3
 * Explanation: 12 = 4 + 4 + 4.
 *
 * Example 2:
 *
 *
 * Input: n = 13
 * Output: 2
 * Explanation: 13 = 4 + 9.
 */
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
  if (n <= 0) {
    return 0;
  }

  const dp = Array(n + 1).fill(Number.MAX_VALUE);
  dp[0] = 0;
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j * j <= i; j++) {
      // 不选(dp[i]) 还是  选(dp[i - j * j])
      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
    }
  }

  return dp[n];
};
```

### [295].find-median-from-data-stream

#### 题目地址

https://leetcode.com/problems/find-median-from-data-stream/description/

#### 题目描述

```
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

For example,
[2,3,4], the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:

void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.


Example:

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2


Follow up:

If all integer numbers from the stream are between 0 and 100, how would you optimize it?
If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?

```

#### 思路

这道题目是求动态数据的中位数，在 leetcode 难度为`hard`. 如果这道题是求静态数据的中位数，我们用数组去存储，
空间复杂度 O(1), 时间复杂度 O(1)

> 空间复杂度指的是除了存储数据之外额外开辟的用于计算等任务的内存空间

代码也比较简单

```js
function findMedian(a) {
  return a.length % 2 === 0 ? (a[a.length >> 1] + a[a.length >> (1 + 1)]) / 2 : a[a.length >> 1];
}
```

但是题目要求是动态数据， 那么是否可以每次添加数据的时候，都去排一次序呢？
假如我们每次插入都用`快速排序`进行排序的话，那么时间复杂度是 O(nlogn) + O(1)

> O(nlogn) 是排序的时间复杂度 O(1)是查询中位数的时间复杂度

如果你用这种思路进行的话， 恐怕 leetcode 会超时。

那么如何优化呢？ 答案是使用堆， Java， C++等语言都有`优先级队列`中这种数据结构，
优先级队列本质上就是一个堆。 关于堆和优先级队列的关系，我会放在《数据结构和算法》部分讲解。这里不赘述

如果借助堆这种数据结构， 就可以轻易实现了。

具体的做法是，建立两个堆，这两个堆需要满足:

1. 大顶堆元素都比小顶堆小(由于堆的特点其实只要比较堆顶即可)
2. 大顶堆元素不小于小顶堆，且最多比小顶堆多一个元素

满足上面两个条件的话，如果想要找到中位数，就比较简单了

- 如果两个堆数量相等(本质是总数为偶数), 就两个堆顶元素的平均数
- 如果两个堆数量不相等(本质是总数为奇数)， 就取大顶堆的堆顶元素

比如对于[1,2,3] 求中位数：

再比如对于[1,2,3, 4] 求中位数：

#### 关键点解析

- 用两个堆(一个大顶堆，一个小顶堆)来简化时间复杂度
- 用优先级队列简化操作

> JavaScript 不像 Java， C++等语言都有`优先级队列`中这种数据结构， 因此大家可以使用社区的实现
> 个人认为没有非要纠结于优先级队列怎么实现， 至少这道题不是考这个的
> 优先级队列的实现个人认为已经超过了这道题想考察的范畴

#### 代码

如果不使用现成的`优先级队列`这种数据结构，代码可能是这样的：

```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
  this.maxHeap = [];
  this.minHeap = [];
};

function minHeapify() {
  this.minHeap.unshift(null);
  const a = this.minHeap;

  // 为了方便大家理解，这里选用了粗暴的实现
  // 时间复杂度为O(n)
  // 其实可以降到O(logn)， 具体细节我不想在这里讲解和实现
  for (let i = a.length - 1; i >> 1 > 0; i--) {
    // 自下往上堆化
    if (a[i] < a[i >> 1]) {
      // 如果子元素更小，则交换位置
      const temp = a[i];
      this.minHeap[i] = a[i >> 1];
      this.minHeap[i >> 1] = temp;
    }
  }
  this.minHeap.shift(null);
}

function maxHeapify() {
  this.maxHeap.unshift(null);
  const a = this.maxHeap;

  // 为了方便大家理解，这里选用了粗暴的实现
  // 时间复杂度为O(n)
  // 其实可以降到O(logn)， 具体细节我不想在这里讲解和实现
  for (let i = a.length - 1; i >> 1 > 0; i--) {
    // 自下往上堆化
    if (a[i] > a[i >> 1]) {
      // 如果子元素更大，则交换位置
      const temp = a[i];
      this.maxHeap[i] = a[i >> 1];
      this.maxHeap[i >> 1] = temp;
    }
  }
  this.maxHeap.shift(null);
}

/**
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
  // 为了大家容易理解，这部分代码写的比较冗余

  // 插入
  if (num >= (this.minHeap[0] || Number.MIN_VALUE)) {
    this.minHeap.push(num);
  } else {
    this.maxHeap.push(num);
  }
  // 调整两个堆的节点数量平衡
  // 使得大顶堆的数量最多大于小顶堆一个， 且一定不小于小顶堆数量
  if (this.maxHeap.length > this.minHeap.length + 1) {
    // 大顶堆的堆顶元素移动到小顶堆
    this.minHeap.push(this.maxHeap.shift());
  }

  if (this.minHeap.length > this.maxHeap.length) {
    // 小顶堆的堆顶元素移动到大顶堆
    this.maxHeap.push(this.minHeap.shift());
  }

  // 调整堆顶元素
  if (this.maxHeap[0] > this.minHeap[0]) {
    const temp = this.maxHeap[0];
    this.maxHeap[0] = this.minHeap[0];
    this.minHeap[0] = temp;
  }

  // 堆化
  maxHeapify.call(this);
  minHeapify.call(this);
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
  if ((this.maxHeap.length + this.minHeap.length) % 2 === 0) {
    return (this.minHeap[0] + this.maxHeap[0]) / 2;
  } else {
    return this.maxHeap[0];
  }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
```

其中`minHeapify` 和 `maxHeapify` 的过程都有一个 hack 操作，就是：

```js
this.heap.unshift(null);
// ....
this.heap.shift(null);
```

其实就是为了存储的数据从 1 开始，这样方便计算。 即对于下标为 i 的元素， `i >> 1` 一定是父节点的下标。

> 这是因为我用满二叉树来存储的堆

这个实现比较繁琐，下面介绍一种优雅的方式，假设 JS 和 Java 和 C++等语言一样有`PriorityQueue`这种数据结构，那么我们实现就比较简单了。

代码：

> 关于 PriorityQueue 的实现，感兴趣的可以看下 https://github.com/janogonzalez/priorityqueuejs

```js
/*
 * @lc app=leetcode id=295 lang=javascript
 *
 * [295] Find Median from Data Stream
 *
 * https://leetcode.com/problems/find-median-from-data-stream/description/
 *
 * algorithms
 * Hard (35.08%)
 * Total Accepted:    101.2K
 * Total Submissions: 282.4K
 * Testcase Example:  '["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]\n[[],[1],[2],[],[3],[]]'
 *
 * Median is the middle value in an ordered integer list. If the size of the
 * list is even, there is no middle value. So the median is the mean of the two
 * middle value.
 * For example,
 *
 * [2,3,4], the median is 3
 *
 * [2,3], the median is (2 + 3) / 2 = 2.5
 *
 * Design a data structure that supports the following two operations:
 *
 *
 * void addNum(int num) - Add a integer number from the data stream to the data
 * structure.
 * double findMedian() - Return the median of all elements so far.
 *
 *
 *
 *
 * Example:
 *
 *
 * addNum(1)
 * addNum(2)
 * findMedian() -> 1.5
 * addNum(3)
 * findMedian() -> 2
 *
 *
 *
 *
 * Follow up:
 *
 *
 * If all integer numbers from the stream are between 0 and 100, how would you
 * optimize it?
 * If 99% of all integer numbers from the stream are between 0 and 100, how
 * would you optimize it?
 *
 *
 */
/**
 * initialize your data structure here.
 */
var MedianFinder = function() {
  this.maxHeap = new PriorityQueue((a, b) => a - b);
  this.minHeap = new PriorityQueue((a, b) => b - a);
};

/**
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
  // 我们的目标就是建立两个堆，一个大顶堆，一个小顶堆
  // 结合中位数的特点
  // 这两个堆需要满足:
  // 1. 大顶堆元素都比小顶堆小(由于堆的特点其实只要比较堆顶即可)
  // 2. 大顶堆元素不小于小顶堆，且最多比小顶堆多一个元素

  // 满足上面两个条件的话，如果想要找到中位数，就比较简单了
  // 如果两个堆数量相等(本质是总数为偶数), 就两个堆顶元素的平均数
  // 如果两个堆数量不相等(本质是总数为奇数)， 就取大顶堆的堆顶元素

  // 问题如果保证满足上述两个特点

  // 1. 保证第一点
  this.maxHeap.enq(num);
  // 由于小顶堆的所有数都来自大顶堆的堆顶元素(最大值)
  // 因此可以保证第一点
  this.minHeap.enq(this.maxHeap.deq());

  // 2. 保证第二点
  if (this.maxHeap.size() < this.minHeap.size()) {
    this.maxHeap.enq(this.minHeap.deq());
  }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
  if (this.maxHeap.size() == this.minHeap.size()) return (this.maxHeap.peek() + this.minHeap.peek()) / 2.0;
  else return this.maxHeap.peek();
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */
```

### [202].happy-number

```js
/*
 * @lc app=leetcode id=202 lang=javascript
 *
 * [202] Happy Number
 *
 * https://leetcode.com/problems/happy-number/description/
 *
 * algorithms
 * Easy (44.36%)
 * Total Accepted:    227.2K
 * Total Submissions: 505.7K
 * Testcase Example:  '19'
 *
 * Write an algorithm to determine if a number is "happy".
 *
 * A happy number is a number defined by the following process: Starting with
 * any positive integer, replace the number by the sum of the squares of its
 * digits, and repeat the process until the number equals 1 (where it will
 * stay), or it loops endlessly in a cycle which does not include 1. Those
 * numbers for which this process ends in 1 are happy numbers.
 *
 * Example:
 *
 *
 * Input: 19
 * Output: true
 * Explanation:
 * 1^2 + 9^2 = 82
 * 8^2 + 2^2 = 68
 * 6^2 + 8^2 = 100
 * 1^2 + 0^2 + 0^2 = 1
 *
 */
function squareSum(n) {
  let sum = 0,
    tmp;
  while (n) {
    tmp = n % 10;
    sum += tmp * tmp;
    n = Math.floor(n / 10);
  }
  return sum;
}

function isHappyWithMapper(n, visited) {
  if (n === 1) return true;
  if (visited[n]) return false;
  visited[n] = true;

  return isHappyWithMapper(squareSum(n), visited);
}
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  const visited = {};

  return isHappyWithMapper(n, visited);
};
```

### [204].count-primes

```js
/*
 * @lc app=leetcode id=204 lang=javascript
 *
 * [204] Count Primes
 *
 * https://leetcode.com/problems/count-primes/description/
 *
 * algorithms
 * Easy (28.33%)
 * Total Accepted:    229.8K
 * Total Submissions: 798.7K
 * Testcase Example:  '10'
 *
 * Count the number of prime numbers less than a non-negative number, n.
 *
 * Example:
 *
 *
 * Input: 10
 * Output: 4
 * Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
 *
 *
 */
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  // tag: 数论
  // if (n <= 2) return 0;
  // let compositionCount = 0;
  // for(let i = 3; i < n; i++) {
  //     for(let j = i - 1; j > 1 ; j--) {
  //         if (i % j === 0) {
  //             compositionCount++;
  //             break; // 找到一个就可以证明它不是质数了
  //         }
  //     }
  // }
  // return n - compositionCount - 2; // 需要减去1和n这两个数字

  // 上面的方法会超时，因此我们需要进行优化
  // 数学角度来看，如果一个数字可以分解为两个数字相乘(这两个数字不包括0和它本身)，那么它就是合数
  const compositions = []; // compositions[i] 表示i是否是合数
  let count = 0;
  for (let i = 2; i < n; i++) {
    if (!compositions[i]) count++;
    for (let j = 2; i * j < n; j++) {
      compositions[i * j] = true;
    }
  }

  return count;
};
```

### [217].contains-duplicate

```js
/*
 * @lc app=leetcode id=217 lang=javascript
 *
 * [217] Contains Duplicate
 *
 * https://leetcode.com/problems/contains-duplicate/description/
 *
 * algorithms
 * Easy (50.92%)
 * Total Accepted:    324K
 * Total Submissions: 628.5K
 * Testcase Example:  '[1,2,3,1]'
 *
 * Given an array of integers, find if the array contains any duplicates.
 *
 * Your function should return true if any value appears at least twice in the
 * array, and it should return false if every element is distinct.
 *
 * Example 1:
 *
 *
 * Input: [1,2,3,1]
 * Output: true
 *
 * Example 2:
 *
 *
 * Input: [1,2,3,4]
 * Output: false
 *
 * Example 3:
 *
 *
 * Input: [1,1,1,3,3,4,3,2,4,2]
 * Output: true
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
  // 1. 暴力两层循环两两比较， 时间复杂度O(n^2) 空间复杂度O(1)

  // 2. 先排序，之后比较前后元素是否一致即可，一层循环即可，如果排序使用的比较排序的话时间复杂度O(nlogn) 空间复杂度O(1)

  // 3. 用hashmap ，时间复杂度O(n) 空间复杂度O(n)
  const visited = {};
  for (let i = 0; i < nums.length; i++) {
    if (visited[nums[i]]) return true;
    visited[nums[i]] = true;
  }
  return false;
};
```

### [278].first-bad-version

```js
/*
 * @lc app=leetcode id=278 lang=javascript
 *
 * [278] First Bad Version
 */
/**
 * Definition for isBadVersion()
 *
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function(isBadVersion) {
  /**
   * @param {integer} n Total versions
   * @return {integer} The first bad version
   */
  return function(n) {
    let start = 0;
    let end = n;
    while (start <= end) {
      if (start === end) return start;
      const mid = start + ((end - start) >> 1);
      if (isBadVersion(mid)) {
        end = mid;
      } else {
        start = mid + 1;
      }
    }
  };
};
```

### [287].find-the-duplicate-number

```js
/*
 * @lc app=leetcode id=287 lang=javascript
 *
 * [287] Find the Duplicate Number
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function(nums) {
  // Input: [1,3,4,2,2]
  // Output: 2
  nums.sort();

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === nums[i + 1]) return nums[i];
  }
};
```

### [221].maximal-square

#### 题目地址

https://leetcode.com/problems/maximal-square/

#### 题目描述

```
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

Example:

Input:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
```

#### 思路

符合直觉的做法是暴力求解处所有的正方形，逐一计算面积，然后记录最大的。这种时间复杂度很高。

我们考虑使用动态规划，我们使用 dp[i][j]表示以 matrix[i][j]为右下角的顶点的可以组成的最大正方形的边长。
那么我们只需要计算所有的 i，j 组合，然后求出最大值即可。

我们来看下 dp[i][j] 怎么推导。 首先我们要看 matrix[i][j], 如果 matrix[i][j]等于 0，那么就不用看了，直接等于 0。
如果 matrix[i][j]等于 1，那么我们将 matrix[[i][j]分别往上和往左进行延伸，直到碰到一个 0 为止。

如图 dp[3][3] 的计算。 matrix[3][3]等于 1，我们分别往上和往左进行延伸，直到碰到一个 0 为止，上面长度为 1，左边为 3。
dp[2][2]等于 1(之前已经计算好了)，那么其实这里的瓶颈在于三者的最小值, 即`Min(1, 1, 3)`, 也就是`1`。 那么 dp[3][3] 就等于
`Min(1, 1, 3) + 1`。

dp[i - 1][j - 1]我们直接拿到，关键是`往上和往左进行延伸`, 最直观的做法是我们内层加一个循环去做就好了。
但是我们仔细观察一下，其实我们根本不需要这样算。 我们可以直接用 dp[i - 1][j]和 dp[i][j -1]。
具体就是`Min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1`。

事实上，这道题还有空间复杂度 O(N)的解法，其中 N 指的是列数。
大家可以去这个[leetcode 讨论](https://leetcode.com/problems/maximal-square/discuss/61803/C%2B%2B-space-optimized-DP)看一下。

#### 关键点解析

- DP
- 递归公式可以利用 dp[i - 1][j]和 dp[i][j -1]的计算结果，而不用重新计算
- 空间复杂度可以降低到 O(n), n 为列数

#### 代码

```js
/*
 * @lc app=leetcode id=221 lang=javascript
 *
 * [221] Maximal Square
 */
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
  if (matrix.length === 0) return 0;
  const dp = [];
  const rows = matrix.length;
  const cols = matrix[0].length;
  let max = Number.MIN_VALUE;

  for (let i = 0; i < rows + 1; i++) {
    if (i === 0) {
      dp[i] = Array(cols + 1).fill(0);
    } else {
      dp[i] = [0];
    }
  }

  for (let i = 1; i < rows + 1; i++) {
    for (let j = 1; j < cols + 1; j++) {
      if (matrix[i - 1][j - 1] === '1') {
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
        max = Math.max(max, dp[i][j]);
      } else {
        dp[i][j] = 0;
      }
    }
  }

  return max * max;
};
```

### [229].majority-element-ii

#### 题目地址

https://leetcode.com/problems/majority-element-ii/description/

#### 题目描述

```
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

Note: The algorithm should run in linear time and in O(1) space.

Example 1:

Input: [3,2,3]
Output: [3]
Example 2:

Input: [1,1,1,3,3,2,2,2]
Output: [1,2]
```

#### 思路

这道题目和[169.majority-element](./169.majority-element.md) 很像。

我们仍然可以采取同样的方法 - “摩尔投票法”， 具体的思路可以参考上面的题目。

但是这里有一个不同的是这里的众数不再是超过`1 / 2`,而是超过`1 / 3`。
题目也说明了，超过三分之一的有可能有多个(实际上就是 0，1，2 三种可能)。

因此我们不能只用一个 counter 来解决了。 我们的思路是同时使用两个 counter，其他思路和上一道题目一样。

最后需要注意的是两个 counter 不一定都满足条件，这两个 counter 只是出现次数最多的两个数字。
有可能不满足出现次数大于 1/3， 因此最后我们需要进行过滤筛选。

这里画了一个图，大家可以感受一下：

#### 关键点解析

- 摩尔投票法
- 两个 counter
- 最后得到的只是出现次数最多的两个数字，有可能不满足出现次数大于 1/3

#### 代码

JavaScript 代码：

```js
/*
 * @lc app=leetcode id=229 lang=javascript
 *
 * [229] Majority Element II
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
  const res = [];
  const len = nums.length;
  let n1 = null,
    n2 = null,
    cnt1 = 0,
    cnt2 = 0;

  for (let i = 0; i < len; i++) {
    if (n1 === nums[i]) {
      cnt1++;
    } else if (n2 === nums[i]) {
      cnt2++;
    } else if (cnt1 === 0) {
      n1 = nums[i];
      cnt1++;
    } else if (cnt2 === 0) {
      n2 = nums[i];
      cnt2++;
    } else {
      cnt1--;
      cnt2--;
    }
  }

  cnt1 = 0;
  cnt2 = 0;

  for (let i = 0; i < len; i++) {
    if (n1 === nums[i]) {
      cnt1++;
    } else if (n2 === nums[i]) {
      cnt2++;
    }
  }

  if (cnt1 > (len / 3) >>> 0) {
    res.push(n1);
  }
  if (cnt2 > (len / 3) >>> 0) {
    res.push(n2);
  }

  return res;
};
```

Java 代码：

```java
/*
 * @lc app=leetcode id=229 lang=java
 *
 * [229] Majority Element II
 */
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> res = new ArrayList<Integer>();
        if (nums == null || nums.length == 0)
            return res;
        int n1 = nums[0], n2 = nums[0], cnt1 = 0, cnt2 = 0, len = nums.length;
        for (int i = 0; i < len; i++) {
            if (nums[i] == n1)
                cnt1++;
            else if (nums[i] == n2)
                cnt2++;
            else if (cnt1 == 0) {
                n1 = nums[i];
                cnt1 = 1;
            } else if (cnt2 == 0) {
                n2 = nums[i];
                cnt2 = 1;
            } else {
                cnt1--;
                cnt2--;
            }
        }
        cnt1 = 0;
        cnt2 = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] == n1)
                cnt1++;
            else if (nums[i] == n2)
                cnt2++;
        }
        if (cnt1 > len / 3)
            res.add(n1);
        if (cnt2 > len / 3 && n1 != n2)
            res.add(n2);
        return res;
    }
}

```
