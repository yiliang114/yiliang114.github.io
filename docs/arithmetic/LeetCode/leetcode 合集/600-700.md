---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### 605.种花问题

```js
/*
 * @lc app=leetcode.cn id=605 lang=javascript
 *
 * [605] 种花问题
 */
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
  if (n <= 0) return true;
  for (let i = 0; i < flowerbed.length; i++) {
    if (flowerbed[i] === 0) {
      if (
        (i === 0 && (flowerbed[i + 1] === 0 || i + 1 === flowerbed.length)) ||
        (i === flowerbed.length - 1 && flowerbed[i - 1] === 0) ||
        (flowerbed[i - 1] === 0 && flowerbed[i + 1] === 0)
      ) {
        flowerbed[i] = 1;
        n--;
        // 当前位置种了花之后，下一个直接跳过，没必要再验证了
        i++;
      }
    }

    if (n === 0) break;
  }
  return n === 0;
};

// 94% 39%
console.log(canPlaceFlowers([1, 0, 0, 0, 1], 1));
console.log(canPlaceFlowers([1, 0, 0, 0, 1], 2));
console.log(canPlaceFlowers([1, 0, 0, 0, 0, 0, 1], 2));
console.log(canPlaceFlowers([0], 1));
```

### 621.任务调度器

```js
/*
 * @lc app=leetcode.cn id=621 lang=javascript
 *
 * [621] 任务调度器
 */
/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
// 多的任务优先处理，少的任务插缝处理
var leastInterval = function(tasks, n) {
  // map
  const queue = [],
    map = {};
};
```

### 622.设计循环队列

```js
/*
 * @lc app=leetcode.cn id=622 lang=javascript
 *
 * [622] 设计循环队列
 */
/**
 * Initialize your data structure here. Set the size of the queue to be k.
 * @param {number} k
 */
// ✔ Accepted
// ✔ 52 / 52 cases passed(144 ms)
// ✔ Your runtime beats 93.52 % of javascript submissions
// ✔ Your memory usage beats 50 % of javascript submissions(41.7 MB)
var MyCircularQueue = function(k) {
  this.val = [];
  this.maxLength = k;
  this.length = 0;
};

/**
 * Insert an element into the circular queue. Return true if the operation is successful.
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function(value) {
  const { maxLength, length, val } = this;
  if (maxLength - length > 0) {
    val.push(value);
    this.length++;
    return true;
  }
  return false;
};

/**
 * Delete an element from the circular queue. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function() {
  const { maxLength, length, val } = this;
  if (length > 0) {
    val.shift();
    this.length--;
    return true;
  }
  return false;
};

/**
 * Get the front item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Front = function() {
  const { val, length } = this;
  if (length) {
    return val[0];
  }
  return -1;
};

/**
 * Get the last item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function() {
  const { val, length } = this;
  if (length) {
    return val[length - 1];
  }
  return -1;
};

/**
 * Checks whether the circular queue is empty or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function() {
  return this.length === 0;
};

/**
 * Checks whether the circular queue is full or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function() {
  const { maxLength, length } = this;
  return maxLength === length;
};

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * var obj = new MyCircularQueue(k)
 * var param_1 = obj.enQueue(value)
 * var param_2 = obj.deQueue()
 * var param_3 = obj.Front()
 * var param_4 = obj.Rear()
 * var param_5 = obj.isEmpty()
 * var param_6 = obj.isFull()
 */

// const circularQueue = new MyCircularQueue(3); // 设置长度为 3

// console.log(circularQueue.enQueue(1));  // 返回 true
// console.log(circularQueue.enQueue(2));  // 返回 true
// console.log(circularQueue.enQueue(3));  // 返回 true
// console.log(circularQueue.enQueue(4));  // 返回 false，队列已满
// console.log(circularQueue.Rear());  // 返回 3
// console.log(circularQueue.isFull());  // 返回 true
// console.log(circularQueue.deQueue());  // 返回 true
// console.log(circularQueue.enQueue(4));  // 返回 true
// console.log(circularQueue.Rear());
```

### 633.sum-of-square-numbers

```js
/*
 * @lc app=leetcode id=633 lang=javascript
 *
 * [633] Sum of Square Numbers
 * 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。

示例1:

输入: 5
输出: True
解释: 1 * 1 + 2 * 2 = 5


示例2:

输入: 3
输出: False
 */
/**
 * @param {number} c
 * @return {boolean}
 */
var judgeSquareSum = function(c) {
  let start = 0;
  let end = Math.floor(Math.sqrt(c));

  while (start <= end) {
    const powSum = start * start + end * end;
    if (powSum < c) {
      start++;
    } else if (powSum > c) {
      end--;
    } else {
      return true;
    }
  }
  return false;
};

console.log(judgeSquareSum(5));
console.log(judgeSquareSum(3));
```

### 646-Maximum-Length-of-Pair-Chain

```js
/**
 * https://leetcode.com/problems/maximum-length-of-pair-chain/description/
 * Difficulty:Medium
 *
 * You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.
 * Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.
 * Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.
 * Example 1:
 * Input: [[1,2], [2,3], [3,4]]
 * Output: 2
 * Explanation: The longest chain is [1,2] -> [3,4]
 */

/**
 *
 * IN ANY ORDER!
 * SORT FIRST!
 *
 * @param {number[][]} pairs
 * @return {number}
 */
var findLongestChain = function(pairs) {
  var n = pairs.length;
  if (!n) return 0;

  pairs = pairs.sort((a, b) => {
    var diff = a[1] - b[1];
    if (diff > 0) return 1;
    else if (diff === 0) return 0;
    return -1;
  });
  // console.log(pairs);

  var dp = [];
  dp[0] = 1;
  var max = 1;
  for (var i = 1; i < n; i++) {
    var now = pairs[i];
    dp[i] = 1;
    for (var j = 0; j < i; j++) {
      var last = pairs[j];
      if (last[1] < now[0]) {
        dp[i] = Math.max(dp[j] + 1, dp[i]);
      }
    }
  }
  console.log(dp);
  return Math.max(...dp);
};

// console.log(findLongestChain([]));
// console.log(findLongestChain([[1, 2], [2, 3], [3, 4]]));
// console.log(findLongestChain([[1, 2], [3, 4], [5, 46], [1, 2]]));
console.log(
  findLongestChain([
    [3, 4],
    [2, 3],
    [1, 2],
  ]),
);
```

### 647-Palindromic-Substrings

```js
/**
 * https://leetcode.com/problems/palindromic-substrings/description/
 * Difficulty:Medium
 *
 *
 * Given a string, your task is to count how many palindromic substrings in this string.
 *
 * The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
 *
 * Example 1:
 *  Input: "abc"
 *  Output: 3
 *  Explanation: Three palindromic strings: "a", "b", "c".
 *
 * Example 2:
 *  Input: "aaa"
 *  Output: 6
 *  Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
 *
 * Note:
 *  The input string length won't exceed 1000.
 */

/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
  var dp = [];
  var n = s.length;
  for (var i = 0; i < n; i++) {
    dp.push(new Array(n).fill(false));
    // dp[i][i] = 1;
  }
  var cnt = 0;
  for (var i = n - 1; i >= 0; i--) {
    for (var j = i; j < n; j++) {
      if (i === j) dp[i][j] = true;
      else {
        dp[i][j] = s[i] === s[j] ? i + 1 >= j - 1 || dp[i + 1][j - 1] : 0;
      }
      if (dp[i][j]) cnt++;
    }
  }
  // console.log(dp);

  return cnt;
};

// console.log(countSubstrings('abc'));
console.log(countSubstrings('aaaaa'));
```

### 654-Maximum-Binary-Tree

```js
/**
 * https://leetcode.com/problems/maximum-binary-tree/description/
 * Difficulty:Medium
 *
 * Given an integer array with no duplicates.
 * A maximum tree building on this array is defined as follow:
 *
 * The root is the maximum number in the array.
 * The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.
 * The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.
 * Construct the maximum tree by the given array and output the root node of this tree.
 *
 * Example 1:
 * Input: [3,2,1,6,0,5]
 * Output: return the tree root node representing the following tree:
 *     6
 *   /   \
 *  3     5
 *  \    /
 *  2   0
 *   \
 *   1
 * Note:
 * The size of the given array will be in the range [1,1000].
 */

//Definition for a binary tree node.
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
  return helper(nums, 0, nums.length);
};

function helper(nums, s, e) {
  if (e <= s) return null;
  if (s + 1 === e) return new TreeNode(nums[s]);
  else {
    var maxIndex = findMaxIndex(nums, s, e);
    var root = new TreeNode(nums[maxIndex]);
    root.left = helper(nums, s, maxIndex);
    root.right = helper(nums, maxIndex + 1, e);
    return root;
  }
}

function findMaxIndex(nums, s, e) {
  var maxIndex = 0;
  var max = Number.NEGATIVE_INFINITY;
  for (var i = s; i < e; i++) {
    if (nums[i] > max) {
      max = nums[i];
      maxIndex = i;
    }
  }
  return maxIndex;
}

console.log(constructMaximumBinaryTree([3, 2, 1, 6, 0, 5]));
```

### 657-Judge-Route-Circle

```js
/**
 * https://leetcode.com/problems/judge-route-circle/description/
 * Difficulty:Easy
 *
 * Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.
 * The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.
 *
 * Example 1:
 * Input: "UD"
 * Output: true
 *
 * Example 2:
 * Input: "LL"
 * Output: false
 */

/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
  let v = 0;
  let h = 0;
  for (let i = 0; i < moves.length; i++) {
    switch (moves[i]) {
      case 'U':
        v++;
        break;
      case 'D':
        v--;
        break;
      case 'L':
        h--;
        break;
      case 'R':
        h++;
    }
  }
  return v === 0 && h === 0;
};
console.log(judgeCircle('UD'));
console.log(judgeCircle('LL'));
console.log(judgeCircle('UDLLRR'));
```

### 673-Number-of-Longest-Increasing-Subsequence

```js
/**
 * https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/
 * Difficulty:Medium
 *
 * Given an unsorted array of integers, find the number of longest increasing subsequence.
 *
 * Example 1:
 * Input: [1,3,5,4,7]
 * Output: 2
 * Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].
 *
 * Example 2:
 * Input: [2,2,2,2,2]
 * Output: 5
 * Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.
 *
 * Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findNumberOfLIS = function(nums) {
  if (!nums.length) return 0;
  var dp = [];
  var longest = 0;
  for (var i = 0; i < nums.length; i++) {
    var max = 0;
    var count = 0;
    for (var j = 0; j < i; j++) {
      if (nums[j] < nums[i] && dp[j][0] > max) {
        max = dp[j][0];
      }
    }

    for (var j = 0; j < i; j++) {
      if (dp[j][0] === max && nums[j] < nums[i]) {
        count += dp[j][1];
      }
    }

    dp[i] = [max + 1, count ? count : 1];
    longest = Math.max(longest, max + 1);
  }

  return dp.filter(t => t[0] === longest).reduce((a, b) => a + b[1], 0);
};

// console.log(findNumberOfLIS([1, 3, 5, 4, 7]));

console.log(findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]));

// console.log(findNumberOfLIS([1, 3, 5, 4]));
// console.log(findNumberOfLIS([2, 2]));
// console.log(findNumberOfLIS([2]));
// console.log(findNumberOfLIS([2, 2, 2]));
```

### 693-Binary-Number-with-Alternating-Bits

```js
/**
 * https://leetcode.com/problems/binary-number-with-alternating-bits/description/
 * Difficulty:Easy
 *
 * Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.
 *
 * Example 1:
 * Input: 5
 * Output: True
 * Explanation:
 * The binary representation of 5 is: 101
 *
 * Example 2:
 * Input: 7
 * Output: False
 * Explanation:
 * The binary representation of 7 is: 111.
 *
 * Example 3:
 * Input: 11
 * Output: False
 * Explanation:
 * The binary representation of 11 is: 1011.
 *
 * Example 4:
 * Input: 10
 * Output: True
 * Explanation:
 * The binary representation of 10 is: 1010.
 */

/**
 * @param {number} n
 * @return {boolean}
 */
var hasAlternatingBits = function(n) {
  var last = n % 2;
  n = Math.floor(n / 2);

  while (n > 0) {
    var r = n % 2;
    n = Math.floor(n / 2);
    // console.log(last);
    if (r === last) return false;
    last = r;
  }
  return true;
};

console.log(hasAlternatingBits(3));
console.log(hasAlternatingBits(5));
console.log(hasAlternatingBits(7));
console.log(hasAlternatingBits(11));
console.log(hasAlternatingBits(10));
```

### 695-Max-Area-of-Island

```js
/**
 * https://leetcode.com/problems/max-area-of-island/description/
 *
 * Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
 * Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)
 *
 * Example 1:
 * [[0,0,1,0,0,0,0,1,0,0,0,0,0],
 * [0,0,0,0,0,0,0,1,1,1,0,0,0],
 * [0,1,1,0,1,0,0,0,0,0,0,0,0],
 * [0,1,0,0,1,1,0,0,1,0,1,0,0],
 * [0,1,0,0,1,1,0,0,1,1,1,0,0],
 * [0,0,0,0,0,0,0,0,0,0,1,0,0],
 * [0,0,0,0,0,0,0,1,1,1,0,0,0],
 * [0,0,0,0,0,0,0,1,1,0,0,0,0]]
 * Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.
 *
 * Example 2:
 * [[0,0,0,0,0,0,0,0]]
 * Given the above grid, return 0.
 *
 * Note: The length of each dimension in the given grid does not exceed 50.
 *
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxAreaOfIsland = function(grid) {
  var dp = [];
  var m = grid.length;
  if (!m) return 0;
  var n = grid[0].length;
  if (!n) return 0;
  while (dp.push(new Array(n).fill(0)) < m);
  var max = 0;
  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      max = Math.max(dfs(grid, dp, i, j), max);
    }
  }

  // console.log(dp);

  return max;
};

function dfs(grid, dp, i, j) {
  var m = grid.length;
  var n = grid[0].length;

  if (i < 0 || i > m - 1) return 0;
  if (j < 0 || j > n - 1) return 0;
  // console.log(i, j, grid[i][j]);
  if (grid[i][j] === 0) dp[i][j] = -1;
  if (dp[i][j] === 0) {
    dp[i][j] = -1;
    dp[i][j] =
      1 + dfs(grid, dp, i, j - 1) + dfs(grid, dp, i + 1, j) + dfs(grid, dp, i, j + 1) + dfs(grid, dp, i - 1, j);
    return dp[i][j];
  }
  return 0;
}

console.log(
  maxAreaOfIsland([
    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
  ]),
);

console.log(
  maxAreaOfIsland([
    [1, 1, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 0, 1, 1],
  ]),
);
console.log(maxAreaOfIsland([[0, 0, 1, 0, 0, 1, 1, 0]]));
```
