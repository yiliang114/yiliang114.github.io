---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

### [605].种花问题

```js
/*
 * @lc app=leetcode.cn id=605 lang=javascript
 *
 * [605] 种花问题
 */
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
  if (n <= 0) return true;
  for (let i = 0; i < flowerbed.length; i++) {
    if (flowerbed[i] === 0) {
      if (
        (i === 0 && (flowerbed[i + 1] === 0 || i + 1 === flowerbed.length)) ||
        (i === flowerbed.length - 1 && flowerbed[i - 1] === 0) ||
        (flowerbed[i - 1] === 0 && flowerbed[i + 1] === 0)
      ) {
        flowerbed[i] = 1;
        n--;
        // 当前位置种了花之后，下一个直接跳过，没必要再验证了
        i++;
      }
    }

    if (n === 0) break;
  }
  return n === 0;
};

// 94% 39%
console.log(canPlaceFlowers([1, 0, 0, 0, 1], 1));
console.log(canPlaceFlowers([1, 0, 0, 0, 1], 2));
console.log(canPlaceFlowers([1, 0, 0, 0, 0, 0, 1], 2));
console.log(canPlaceFlowers([0], 1));
```

### [621].任务调度器

```js
/*
 * @lc app=leetcode.cn id=621 lang=javascript
 *
 * [621] 任务调度器
 */
/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
// 多的任务优先处理，少的任务插缝处理
var leastInterval = function(tasks, n) {
  // map
  const queue = [],
    map = {};
};
```

### [622].设计循环队列

```js
/*
 * @lc app=leetcode.cn id=622 lang=javascript
 *
 * [622] 设计循环队列
 */
/**
 * Initialize your data structure here. Set the size of the queue to be k.
 * @param {number} k
 */
// ✔ Accepted
// ✔ 52 / 52 cases passed(144 ms)
// ✔ Your runtime beats [93].52 % of javascript submissions
// ✔ Your memory usage beats 50 % of javascript submissions(41.7 MB)
var MyCircularQueue = function(k) {
  this.val = [];
  this.maxLength = k;
  this.length = 0;
};

/**
 * Insert an element into the circular queue. Return true if the operation is successful.
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function(value) {
  const { maxLength, length, val } = this;
  if (maxLength - length > 0) {
    val.push(value);
    this.length++;
    return true;
  }
  return false;
};

/**
 * Delete an element from the circular queue. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function() {
  const { maxLength, length, val } = this;
  if (length > 0) {
    val.shift();
    this.length--;
    return true;
  }
  return false;
};

/**
 * Get the front item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Front = function() {
  const { val, length } = this;
  if (length) {
    return val[0];
  }
  return -1;
};

/**
 * Get the last item from the queue.
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function() {
  const { val, length } = this;
  if (length) {
    return val[length - 1];
  }
  return -1;
};

/**
 * Checks whether the circular queue is empty or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function() {
  return this.length === 0;
};

/**
 * Checks whether the circular queue is full or not.
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function() {
  const { maxLength, length } = this;
  return maxLength === length;
};

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * var obj = new MyCircularQueue(k)
 * var param_1 = obj.enQueue(value)
 * var param_2 = obj.deQueue()
 * var param_3 = obj.Front()
 * var param_4 = obj.Rear()
 * var param_5 = obj.isEmpty()
 * var param_6 = obj.isFull()
 */

// const circularQueue = new MyCircularQueue(3); // 设置长度为 3

// console.log(circularQueue.enQueue(1));  // 返回 true
// console.log(circularQueue.enQueue(2));  // 返回 true
// console.log(circularQueue.enQueue(3));  // 返回 true
// console.log(circularQueue.enQueue(4));  // 返回 false，队列已满
// console.log(circularQueue.Rear());  // 返回 3
// console.log(circularQueue.isFull());  // 返回 true
// console.log(circularQueue.deQueue());  // 返回 true
// console.log(circularQueue.enQueue(4));  // 返回 true
// console.log(circularQueue.Rear());
```

### [633].sum-of-square-numbers

```js
/*
 * @lc app=leetcode id=633 lang=javascript
 *
 * [633] Sum of Square Numbers
 * 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。

示例1:

输入: 5
输出: True
解释: 1 * 1 + 2 * 2 = 5


示例2:

输入: 3
输出: False
 */
/**
 * @param {number} c
 * @return {boolean}
 */
var judgeSquareSum = function(c) {
  let start = 0;
  let end = Math.floor(Math.sqrt(c));

  while (start <= end) {
    const powSum = start * start + end * end;
    if (powSum < c) {
      start++;
    } else if (powSum > c) {
      end--;
    } else {
      return true;
    }
  }
  return false;
};

console.log(judgeSquareSum(5));
console.log(judgeSquareSum(3));
```

### 646-Maximum-Length-of-Pair-Chain

```js
/**
 * https://leetcode.com/problems/maximum-length-of-pair-chain/description/
 * Difficulty:Medium
 *
 * You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.
 * Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.
 * Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.
 * Example 1:
 * Input: [[1,2], [2,3], [3,4]]
 * Output: 2
 * Explanation: The longest chain is [1,2] -> [3,4]
 */

/**
 *
 * IN ANY ORDER!
 * SORT FIRST!
 *
 * @param {number[][]} pairs
 * @return {number}
 */
var findLongestChain = function(pairs) {
  var n = pairs.length;
  if (!n) return 0;

  pairs = pairs.sort((a, b) => {
    var diff = a[1] - b[1];
    if (diff > 0) return 1;
    else if (diff === 0) return 0;
    return -1;
  });
  // console.log(pairs);

  var dp = [];
  dp[0] = 1;
  var max = 1;
  for (var i = 1; i < n; i++) {
    var now = pairs[i];
    dp[i] = 1;
    for (var j = 0; j < i; j++) {
      var last = pairs[j];
      if (last[1] < now[0]) {
        dp[i] = Math.max(dp[j] + 1, dp[i]);
      }
    }
  }
  console.log(dp);
  return Math.max(...dp);
};

// console.log(findLongestChain([]));
// console.log(findLongestChain([[1, 2], [2, 3], [3, 4]]));
// console.log(findLongestChain([[1, 2], [3, 4], [5, 46], [1, 2]]));
console.log(
  findLongestChain([
    [3, 4],
    [2, 3],
    [1, 2],
  ]),
);
```

### 647-Palindromic-Substrings

```js
/**
 * https://leetcode.com/problems/palindromic-substrings/description/
 * Difficulty:Medium
 *
 *
 * Given a string, your task is to count how many palindromic substrings in this string.
 *
 * The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
 *
 * Example 1:
 *  Input: "abc"
 *  Output: 3
 *  Explanation: Three palindromic strings: "a", "b", "c".
 *
 * Example 2:
 *  Input: "aaa"
 *  Output: 6
 *  Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
 *
 * Note:
 *  The input string length won't exceed [1000].
 */

/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
  var dp = [];
  var n = s.length;
  for (var i = 0; i < n; i++) {
    dp.push(new Array(n).fill(false));
    // dp[i][i] = 1;
  }
  var cnt = 0;
  for (var i = n - 1; i >= 0; i--) {
    for (var j = i; j < n; j++) {
      if (i === j) dp[i][j] = true;
      else {
        dp[i][j] = s[i] === s[j] ? i + 1 >= j - 1 || dp[i + 1][j - 1] : 0;
      }
      if (dp[i][j]) cnt++;
    }
  }
  // console.log(dp);

  return cnt;
};

// console.log(countSubstrings('abc'));
console.log(countSubstrings('aaaaa'));
```

### 654-Maximum-Binary-Tree

```js
/**
 * https://leetcode.com/problems/maximum-binary-tree/description/
 * Difficulty:Medium
 *
 * Given an integer array with no duplicates.
 * A maximum tree building on this array is defined as follow:
 *
 * The root is the maximum number in the array.
 * The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.
 * The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.
 * Construct the maximum tree by the given array and output the root node of this tree.
 *
 * Example 1:
 * Input: [3,2,1,6,0,5]
 * Output: return the tree root node representing the following tree:
 *     6
 *   /   \
 *  3     5
 *  \    /
 *  2   0
 *   \
 *   1
 * Note:
 * The size of the given array will be in the range [1,1000].
 */

//Definition for a binary tree node.
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
  return helper(nums, 0, nums.length);
};

function helper(nums, s, e) {
  if (e <= s) return null;
  if (s + 1 === e) return new TreeNode(nums[s]);
  else {
    var maxIndex = findMaxIndex(nums, s, e);
    var root = new TreeNode(nums[maxIndex]);
    root.left = helper(nums, s, maxIndex);
    root.right = helper(nums, maxIndex + 1, e);
    return root;
  }
}

function findMaxIndex(nums, s, e) {
  var maxIndex = 0;
  var max = Number.NEGATIVE_INFINITY;
  for (var i = s; i < e; i++) {
    if (nums[i] > max) {
      max = nums[i];
      maxIndex = i;
    }
  }
  return maxIndex;
}

console.log(constructMaximumBinaryTree([3, 2, 1, 6, 0, 5]));
```

### 657-Judge-Route-Circle

```js
/**
 * https://leetcode.com/problems/judge-route-circle/description/
 * Difficulty:Easy
 *
 * Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.
 * The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.
 *
 * Example 1:
 * Input: "UD"
 * Output: true
 *
 * Example 2:
 * Input: "LL"
 * Output: false
 */

/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
  let v = 0;
  let h = 0;
  for (let i = 0; i < moves.length; i++) {
    switch (moves[i]) {
      case 'U':
        v++;
        break;
      case 'D':
        v--;
        break;
      case 'L':
        h--;
        break;
      case 'R':
        h++;
    }
  }
  return v === 0 && h === 0;
};
console.log(judgeCircle('UD'));
console.log(judgeCircle('LL'));
console.log(judgeCircle('UDLLRR'));
```

### 673-Number-of-Longest-Increasing-Subsequence

```js
/**
 * https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/
 * Difficulty:Medium
 *
 * Given an unsorted array of integers, find the number of longest increasing subsequence.
 *
 * Example 1:
 * Input: [1,3,5,4,7]
 * Output: 2
 * Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].
 *
 * Example 2:
 * Input: [2,2,2,2,2]
 * Output: 5
 * Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output [5].
 *
 * Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.
 *
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
var findNumberOfLIS = function(nums) {
  if (!nums.length) return 0;
  var dp = [];
  var longest = 0;
  for (var i = 0; i < nums.length; i++) {
    var max = 0;
    var count = 0;
    for (var j = 0; j < i; j++) {
      if (nums[j] < nums[i] && dp[j][0] > max) {
        max = dp[j][0];
      }
    }

    for (var j = 0; j < i; j++) {
      if (dp[j][0] === max && nums[j] < nums[i]) {
        count += dp[j][1];
      }
    }

    dp[i] = [max + 1, count ? count : 1];
    longest = Math.max(longest, max + 1);
  }

  return dp.filter(t => t[0] === longest).reduce((a, b) => a + b[1], 0);
};

// console.log(findNumberOfLIS([1, 3, 5, 4, 7]));

console.log(findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]));

// console.log(findNumberOfLIS([1, 3, 5, 4]));
// console.log(findNumberOfLIS([2, 2]));
// console.log(findNumberOfLIS([2]));
// console.log(findNumberOfLIS([2, 2, 2]));
```

### 693-Binary-Number-with-Alternating-Bits

```js
/**
 * https://leetcode.com/problems/binary-number-with-alternating-bits/description/
 * Difficulty:Easy
 *
 * Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.
 *
 * Example 1:
 * Input: 5
 * Output: True
 * Explanation:
 * The binary representation of 5 is: 101
 *
 * Example 2:
 * Input: 7
 * Output: False
 * Explanation:
 * The binary representation of 7 is: [111].
 *
 * Example 3:
 * Input: 11
 * Output: False
 * Explanation:
 * The binary representation of 11 is: [1011].
 *
 * Example 4:
 * Input: 10
 * Output: True
 * Explanation:
 * The binary representation of 10 is: [1010].
 */

/**
 * @param {number} n
 * @return {boolean}
 */
var hasAlternatingBits = function(n) {
  var last = n % 2;
  n = Math.floor(n / 2);

  while (n > 0) {
    var r = n % 2;
    n = Math.floor(n / 2);
    // console.log(last);
    if (r === last) return false;
    last = r;
  }
  return true;
};

console.log(hasAlternatingBits(3));
console.log(hasAlternatingBits(5));
console.log(hasAlternatingBits(7));
console.log(hasAlternatingBits(11));
console.log(hasAlternatingBits(10));
```

### 695-Max-Area-of-Island

```js
/**
 * https://leetcode.com/problems/max-area-of-island/description/
 *
 * Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
 * Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is [0].)
 *
 * Example 1:
 * [[0,0,1,0,0,0,0,1,0,0,0,0,0],
 * [0,0,0,0,0,0,0,1,1,1,0,0,0],
 * [0,1,1,0,1,0,0,0,0,0,0,0,0],
 * [0,1,0,0,1,1,0,0,1,0,1,0,0],
 * [0,1,0,0,1,1,0,0,1,1,1,0,0],
 * [0,0,0,0,0,0,0,0,0,0,1,0,0],
 * [0,0,0,0,0,0,0,1,1,1,0,0,0],
 * [0,0,0,0,0,0,0,1,1,0,0,0,0]]
 * Given the above grid, return [6]. Note the answer is not 11, because the island must be connected 4-directionally.
 *
 * Example 2:
 * [[0,0,0,0,0,0,0,0]]
 * Given the above grid, return [0].
 *
 * Note: The length of each dimension in the given grid does not exceed [50].
 *
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxAreaOfIsland = function(grid) {
  var dp = [];
  var m = grid.length;
  if (!m) return 0;
  var n = grid[0].length;
  if (!n) return 0;
  while (dp.push(new Array(n).fill(0)) < m);
  var max = 0;
  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      max = Math.max(dfs(grid, dp, i, j), max);
    }
  }

  // console.log(dp);

  return max;
};

function dfs(grid, dp, i, j) {
  var m = grid.length;
  var n = grid[0].length;

  if (i < 0 || i > m - 1) return 0;
  if (j < 0 || j > n - 1) return 0;
  // console.log(i, j, grid[i][j]);
  if (grid[i][j] === 0) dp[i][j] = -1;
  if (dp[i][j] === 0) {
    dp[i][j] = -1;
    dp[i][j] =
      1 + dfs(grid, dp, i, j - 1) + dfs(grid, dp, i + 1, j) + dfs(grid, dp, i, j + 1) + dfs(grid, dp, i - 1, j);
    return dp[i][j];
  }
  return 0;
}

console.log(
  maxAreaOfIsland([
    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
  ]),
);

console.log(
  maxAreaOfIsland([
    [1, 1, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 1, 1],
    [0, 0, 0, 1, 1],
  ]),
);
console.log(maxAreaOfIsland([[0, 0, 1, 0, 0, 1, 1, 0]]));
```

### [609].find-duplicate-file-in-system

#### 题目地址

https://leetcode.com/problems/find-duplicate-file-in-system/description/

#### 题目描述

```
Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.

A group of duplicate files consists of at least two files that have exactly the same content.

A single directory info string in the input list has the following format:

"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"

It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.

The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:

"directory_path/file_name.txt"

Example 1:

Input:
["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]
Output:
[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]


Note:

No order is required for the final output.
You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].
The number of files given is in the range of [1,20000].
You may assume no files or directories share the same name in the same directory.
You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.


Follow-up beyond contest:

1. Imagine you are given a real file system, how will you search files? DFS or BFS?

2. If the file content is very large (GB level), how will you modify your solution?

3. If you can only read the file by 1kb each time, how will you modify your solution?

4. What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?

5. How to make sure the duplicated files you find are not false positive?

```

#### 思路

思路就是 hashtable 去存储，key 为文件内容，value 为 fullfilename，
遍历一遍去填充 hashtable， 最后将 hashtable 中的值打印出来即可。

> 当且仅当有重复内容，我们才打印，因此我们需要过滤一下， 类似 filter(q => q.length >= 2)

#### 关键点解析

- hashtable

#### 代码

```js
/*
 * @lc app=leetcode id=609 lang=javascript
 *
 * [609] Find Duplicate File in System
 *
 * https://leetcode.com/problems/find-duplicate-file-in-system/description/
 *
 * algorithms
 * Medium (54.21%)
 * Total Accepted:    24.1K
 * Total Submissions: 44.2K
 * Testcase Example:  '["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]'
 *
 * Given a list of directory info including directory path, and all the files
 * with contents in this directory, you need to find out all the groups of
 * duplicate files in the file system in terms of their paths.
 *
 * A group of duplicate files consists of at least two files that have exactly
 * the same content.
 *
 * A single directory info string in the input list has the following format:
 *
 * "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ...
 * fn.txt(fn_content)"
 *
 * It means there are n files (f1.txt, f2.txt ... fn.txt with content
 * f1_content, f2_content ... fn_content, respectively) in directory
 * root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the
 * directory is just the root directory.
 *
 * The output is a list of group of duplicate file paths. For each group, it
 * contains all the file paths of the files that have the same content. A file
 * path is a string that has the following format:
 *
 * "directory_path/file_name.txt"
 *
 * Example 1:
 *
 *
 * Input:
 * ["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d
 * 4.txt(efgh)", "root 4.txt(efgh)"]
 * Output:
 *
 * [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]
 *
 *
 *
 *
 * Note:
 *
 *
 * No order is required for the final output.
 * You may assume the directory name, file name and file content only has
 * letters and digits, and the length of file content is in the range of
 * [1,50].
 * The number of files given is in the range of [1,20000].
 * You may assume no files or directories share the same name in the same
 * directory.
 * You may assume each given directory info represents a unique directory.
 * Directory path and file info are separated by a single blank space.
 *
 *
 *
 * Follow-up beyond contest:
 *
 *
 * Imagine you are given a real file system, how will you search files? DFS or
 * BFS?
 * If the file content is very large (GB level), how will you modify your
 * solution?
 * If you can only read the file by 1kb each time, how will you modify your
 * solution?
 * What is the time complexity of your modified solution? What is the most
 * time-consuming part and memory consuming part of it? How to optimize?
 * How to make sure the duplicated files you find are not false positive?
 *
 *
 */
/**
 * @param {string[]} paths
 * @return {string[][]}
 */
var findDuplicate = function(paths) {
  const hashmap = {};

  for (let path of paths) {
    const [folder, ...files] = path.split(' ');
    for (let file of files) {
      const lpi = file.indexOf('(');
      const rpi = file.lastIndexOf(')');
      const filename = file.slice(0, lpi);
      const content = file.slice(lpi, rpi);
      const fullname = `${folder}/${filename}`;
      if (!hashmap[content]) hashmap[content] = [];
      hashmap[content].push(fullname);
    }
  }

  return Object.values(hashmap).filter(q => q.length >= 2);
};
```

#### 扩展

leetcode 官方给的扩展我觉得就很有意思，虽然很`老套`, 这里还是列一下好了，大家可以作为思考题来思考一下。

1. Imagine you are given a real file system, how will you search files? DFS or BFS?

2. If the file content is very large (GB level), how will you modify your solution?

3. If you can only read the file by 1kb each time, how will you modify your solution?

4. What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?

5. How to make sure the duplicated files you find are not false positive?

### [647].palindromic-substrings

```js
/*
 * @lc app=leetcode id=647 lang=javascript
 *
 * [647] Palindromic Substrings
 */

function isPalindromic(s) {
  let start = 0;
  let end = s.length - 1;

  while (start < end && s[start] === s[end]) {
    start++;
    end--;
  }

  return start >= end;
}

/**
 *
 * @param {对称点1} i
 * @param {对称点2} j
 * @param {原始字符串} s
 * @return {以i，j为对称点的字符串s有多少回文串} count
 */
function extendPalindromic(i, j, s) {
  const n = s.length;
  let count = 0;
  let start = i;
  let end = j;
  while (s[start] === s[end] && start >= 0 && end < n) {
    start--;
    end++;
    count++;
  }

  return count;
}
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function(s) {
  // "aaa"
  // "abc"
  // // 暴力法，空间复杂度O(1) 时间复杂度O(n^3)
  // let count = s.length;

  // for(let i = 0; i < s.length - 1; i++) {
  //     for(let j = i + 1; j < s.length; j++) {
  //         if (isPalindromic(s.substring(i, j + 1))) {
  //             count++;
  //         }
  //     }
  // }

  // return count;

  // 中心扩展法(运用回文的对称性)
  // 时间复杂度O(n^2) 空间复杂度O(1)
  const n = s.length;
  let count = 0;

  for (let i = 0; i < n; i++) {
    // 以 字符s[i]为对称点，一共有多少回文字串
    count += extendPalindromic(i, i, s);
    // 以 字符s[i]和s[i+1]为对称点，一共有多少回文字串
    count += extendPalindromic(i, i + 1, s);
  }

  return count;
};
```

### [687].longest-univalue-path

```js
/*
 * @lc app=leetcode id=687 lang=javascript
 *
 * [687] Longest Univalue Path
 */

// 返回经过root的且只能取左右一个节点的路径长度
function helper(node, res) {
  if (node === null) return 0;
  const l = helper(node.left, res);
  const r = helper(node.right, res);
  let lcnt = 0;
  let rcnt = 0;
  if (node.left && node.val === node.left.val) lcnt = lcnt + l + 1;
  if (node.right && node.val === node.right.val) rcnt = rcnt + r + 1;

  res.max = Math.max(res.max, lcnt + rcnt);

  return Math.max(lcnt, rcnt);
}
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function(root) {
  const res = {
    max: 0,
  };
  helper(root, res);
  return res.max;
};
```

### [633].sum-of-square-numbers

```js
/*
 * @lc app=leetcode id=633 lang=javascript
 *
 * [633] Sum of Square Numbers
 */
/**
 * @param {number} c
 * @return {boolean}
 */
var judgeSquareSum = function(c) {
  let start = 0;
  let end = Math.floor(Math.sqrt(c));

  while (start <= end) {
    const res = Math.pow(start, 2) + Math.pow(end, 2);
    if (res < c) {
      start++;
    } else if (res > c) {
      end--;
    } else {
      return true;
    }
  }
  return false;
};
```

### [680].valid-palindrome-ii

```js
/*
 * @lc app=leetcode id=680 lang=javascript
 *
 * [680] Valid Palindrome II
 */
function isPalindrome(s, pos) {
  // deeee
  let start = 0;
  let end = s.length - 1;

  while (start <= end) {
    if (start === pos) {
      start++;
      continue;
    } else if (end === pos) {
      end--;
      continue;
    }
    if (s[start] !== s[end]) return false;
    start++;
    end--;
  }
  return true;
}
/**
 * @param {string} s
 * @return {boolean}
 */
var validPalindrome = function(s) {
  // 时间复杂度O(n^2)
  let start = 0;
  let end = s.length - 1;
  for (let i = 0; i < s.length; i++) {
    if (s[start] !== s[end]) {
      return isPalindrome(s, start) || isPalindrome(s, end);
    }
    start++;
    end--;
  }
  return true;
};
```
