---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

# SF/leetcode/js/coding-easy/isPrime.js

```js
/// solution

function isPrime(n) {
  if (n < 2) {
    return false;
  }
  for (let i = 2; i < Math.ceil(Math.sqrt(n)) + 1; i++) {
    if (n % i === 0 && i !== n) {
      return false;
    }
  }
  return true;
}

/// tests

import { test } from 'ava';

test(t => t.is(isPrime(0), false));
test(t => t.is(isPrime(1), false));
test(t => t.is(isPrime(2), true));
test(t => t.is(isPrime(9), false));
test(t => t.is(isPrime(17), true));
test(t => t.is(isPrime(25), false));
test(t => t.is(isPrime(73), true));
test(t => t.is(isPrime(10000000000000), false));
```

# SF/leetcode/js/coding-easy/isSorted.js

```js
/// solution

function isSorted(array) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    let next = array[i + 1];
    if (next && current > next) {
      // exit as soon as we know the array isn't sorted
      return false;
    }
  }
  return true;
}

/// tests

import { test } from 'ava';

test(t => t.is(isSorted([]), true));
test(t => t.is(isSorted([-Infinity, -5, 0, 3, 9]), true));
test(t => t.is(isSorted([3, 9, -3, 10]), false));
```

# SF/leetcode/js/coding-easy/missing.js

```js
/// solution

function missing(array) {
  // sum the array, and keep track of the maximum number in it
  let max = array[0];
  let sum = 0;
  array.forEach(number => {
    sum += number;
    if (number > max) {
      max = number;
    }
  });

  // the maximum tells us how long the array should be.
  // we plug it into the formula to sum a series to see
  // what we should expect the sum to be.
  let expectedSum = (max * (max + 1)) / 2;
  let difference = expectedSum - sum;

  if (difference > 0) {
    return difference;
  } else {
    return undefined;
  }
}

/// tests

import { test } from 'ava';

test(t => t.is(missing([]), undefined));
test(t => t.is(missing([1, 4, 3]), 2));
test(t => t.is(missing([2, 3, 4]), 1));
test(t => t.is(missing([5, 1, 4, 2]), 3));
test(t => t.is(missing([1, 2, 3, 4]), undefined));
```

# SF/leetcode/js/coding-easy/reduce.js

```js
/// solution

function reduce(array, fn, value) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    value = fn(value, current, i, array);
  }
  return value;
}

/// tests

import { test } from 'ava';

test(t =>
  t.is(
    reduce([1, 2, 3, 4], (a, b) => a + b, 0),
    10,
  ),
);
```

# SF/leetcode/js/coding-easy/reverse.js

```js
/**
 * Note: This solution aims for clarity, but does not give correct results when given unicode characters
 * from the supplementary planes (including Chinese characters, emojis, etc.). See discussion here:
 * https://github.com/bcherny/frontend-interview-questions/issues/6.
 */

/// solution

function reverse(string) {
  let index = string.length - 1;
  let result = '';
  while (index > -1) {
    result += string[index];
    index--;
  }
  return result;
}

/// tests

import { test } from 'ava';

test(t => t.is(reverse(''), ''));
test(t => t.is(reverse('abcdef'), 'fedcba'));
```

# SF/leetcode/js/coding-harder/BinarySearchTree.js

```js
class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  // O(n), where n is # nodes
  get(value) {
    let node = this.root;
    while (node != null) {
      if (value === node.value) return node.value;
      else if (value < node.value) node = node.left;
      else node = node.right;
    }
    return null;
  }

  // O(n), where n is # nodes
  has(value) {
    return this.get(value) !== null;
  }

  // O(n), where n is # nodes
  add(...values) {
    function _add(value, node) {
      if (node === null) return new Node(value);
      if (value < node.value) {
        node.left = _add(value, node.left);
      } else if (value > node.value) {
        node.right = _add(value, node.right);
      } else {
        node.value = value;
      }
      return node;
    }
    for (let value of values) {
      this.root = _add(value, this.root);
    }
  }

  // O(n), where n is # nodes
  size() {
    let _size = node => (node === null ? 0 : 1 + _size(node.left) + _size(node.right));
    return _size(this.root);
  }

  // Hibbard deletion
  remove(value) {
    function _remove(value, node) {
      if (node === null) return null;
      if (value < node.value) node.left = _remove(value, node.left);
      else if (value > node.value) node.right = _remove(value, node.right);
      else {
        if (node.right === null) return node.left;
        if (node.left === null) return node.right;

        let t = node;
        node = min(t.right);
        node.right = removeMin(t.right);
        node.left = t.left;
      }
      return node;
    }

    function removeMin(node) {
      if (node.left === null) return node.right;
      node.left = removeMin(node.left);
      return node;
    }

    function min(node) {
      let curr = node;
      while (curr.left !== null) curr = curr.left;
      return curr;
    }

    this.root = _remove(value, this.root);
  }
}

class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

/// tests

import { test } from 'ava';

test('BinarySearchTree', t => {
  let tree = new BinarySearchTree();
  tree.add(1, 2, 3, 4);
  tree.add(5);
  t.is(tree.has(2), true);
  t.is(tree.has(5), true);
  tree.remove(3);
  t.is(tree.size(), 4);
});

test('BinarySearchTree#get', t => {
  let tree = new BinarySearchTree();
  t.is(tree.get(42), null);
  tree.add(42, 43);
  t.is(tree.get(42), 42);
  t.is(tree.get(43), 43);
  t.is(tree.get(44), null);
});
```

# SF/leetcode/js/coding-harder/HashMap.js

```js
/// solution

class HashMap {
  constructor() {
    this.data = [];
  }
  get(key) {
    let index = hash(key);
    let slot = this.data[index];
    if (!slot) {
      return undefined;
    }
    for (let [k, v] of slot) {
      if (key === k) {
        return v;
      }
    }
  }
  set(key, value) {
    let index = hash(key);

    if (!this.data[index]) {
      this.data[index] = [];
    }

    let slot = this.data[index];
    let indexInSlot = 0;

    // find available index in the given slot, or overwrite the given key
    // if a value is already defined for it.
    while (slot[indexInSlot]) {
      if (slot[indexInSlot][0] === key) {
        break;
      }
      indexInSlot++;
    }

    slot[indexInSlot] = [key, value];
  }
}

// hash function (provided)
function hash(string) {
  return string.split('').reduce((a, b) => (a << 5) + a + b.charCodeAt(0), 5381);
}

/// tests

import { test } from 'ava';

test('HashMap', t => {
  let map = new HashMap();
  map.set('abc', 123);
  map.set('foo', 'bar');
  map.set('foo', 'baz');
  t.is(map.get('abc'), 123);
  t.is(map.get('foo'), 'baz');
  t.is(map.get('def'), undefined);
});
```

# SF/leetcode/js/coding-harder/LinkedList.js

```js
/// solution

/**
 * LinkedList has 2 members, head and tail:
 * - head is a value
 * - tail is either another LinkedList, or null
 */
export class LinkedList {
  constructor(head, ...tail) {
    this.head = head;
    this.tail = tail.length ? new LinkedList(...tail) : null;
  }
  add(item) {
    if (this.tail) {
      this.tail.add(item);
    } else {
      this.tail = new LinkedList(item);
    }
  }
  has(item) {
    if (this.head === item) {
      return true;
    }
    if (this.tail === null) {
      return false;
    }
    return this.tail.has(item);
  }
}

// tests

import test from 'ava';

test('LinkedList', t => {
  let list = new LinkedList(1, 2, 3);
  list.add(4);
  list.add(5);
  t.is(list.has(1), true);
  t.is(list.has(4), true);
  t.is(list.has(6), false);
});
```

# SF/leetcode/js/coding-harder/TreeTraversal.js

```js
class BinarySearchTree {
  constructor(...nodes) {
    this.root = null;
    for (let node of nodes) {
      this.put(node.key, node.value);
    }
  }

  put(key, value) {
    function _put(node, key, value) {
      if (node === null) return new Node(key, value);
      else if (key < node.key) {
        node.left = _put(node.left, key, value);
      } else if (key > node.key) {
        node.right = _put(node.right, key, value);
      } else {
        node.value = value;
      }
      return node;
    }
    this.root = _put(this.root, key, value);
  }

  get(key) {
    let x = this.root;
    while (x !== null) {
      if (key < x.key) x = x.left;
      // traverse left
      else if (key > x.key) x = x.right;
      // traverse right
      else return x.value; // found it!
    }
    return x;
  }

  delete(key) {
    function _delete(node, key) {
      if (node === null) return;
      if (key < node.key) {
        node.left = _delete(node.left, key);
      } else if (key > node.key) {
        node.right = _delete(node.right, key);
      } else {
        // node.key === key
        if (node.right === null) return node.left;
        if (node.left === null) return node.right;

        let t = node;
        node = min(t.right);
        node.right = removeMin(t.right);
        node.left = t.left;
      }
      return node;
    }

    function removeMin(node) {
      if (node.left === null) return node.right;
      node.left = removeMin(node.left);
      return node;
    }

    function min(node) {
      let x = node;
      while (x.left !== null) x = x.left;
      return x;
    }

    this.root = _delete(this.root, key);
  }

  contains(key) {
    return this.get(key) !== null;
  }

  isEmpty() {
    return this.root === null;
  }

  size() {
    function _size(node) {
      return node === null ? 0 : 1 + _size(node.left) + _size(node.right);
    }
    return _size(this.root);
  }

  inorder(fn) {
    function _inorder(node) {
      if (node === null) return;
      _inorder(node.left);
      fn(node);
      _inorder(node.right);
    }
    _inorder(this.root);
  }

  preorder(fn) {
    function _preorder(node) {
      if (node === null) return;
      fn(node);
      _preorder(node.left);
      _preorder(node.right);
    }
    _preorder(this.root);
  }

  postorder(fn) {
    function _postorder(node) {
      if (node === null) return;
      _postorder(node.left);
      _postorder(node.right);
      fn(node);
    }
    _postorder(this.root);
  }

  bfs(fn) {
    if (this.root === null) return;
    let queue = new Queue();
    queue.enqueue(this.root);
    while (!queue.isEmpty()) {
      let node = queue.dequeue();
      fn(node);
      if (node.left !== null) queue.enqueue(node.left);
      if (node.right !== null) queue.enqueue(node.right);
    }
  }
}

class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class Queue {
  constructor(...items) {
    this.data = [];
    for (let item of items) {
      this.enqueue(item);
    }
  }

  enqueue(item) {
    this.data.unshift(item);
  }
  dequeue() {
    return this.data.pop();
  }
  isEmpty() {
    return this.data.length === 0;
  }
}

import { test } from 'ava';
test('BinarySearchTree#put', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.get('c'), 42);
  bst.put('c', 44);
  t.is(bst.get('c'), 44);
});

test('BinarySearchTree#get', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.get('a'), 100);
  t.is(bst.get('c'), 42);
  t.is(bst.get('d'), 22);
});

test('BinarySearchTree#delete', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.get('a'), 100);
  t.is(bst.get('c'), 42);
  t.is(bst.get('d'), 22);

  bst.delete('a');
  bst.delete('d');
  t.is(bst.get('d'), null);
  t.is(bst.get('a'), null);
  t.is(bst.get('c'), 42);
});

test('BinarySearchTree#size', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.size(), 3);
  bst.delete('d');
  bst.delete('a');
  t.is(bst.size(), 1);
});

test('BinarySearchTree#inorder', t => {
  let bst = new BinarySearchTree(
    { key: 'c', value: 42 },
    { key: 'a', value: 100 },
    { key: 'd', value: 22 },
    { key: 'e', value: 42 },
    { key: 'b', value: 100 },
  );

  let values = [];
  bst.inorder(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['a', 'b', 'c', 'd', 'e']);
});

test('BinarySearchTree#preorder', t => {
  let bst = new BinarySearchTree(
    { key: 'c', value: 42 },
    { key: 'a', value: 100 },
    { key: 'd', value: 22 },
    { key: 'e', value: 42 },
    { key: 'b', value: 100 },
  );

  let values = [];
  bst.preorder(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['c', 'a', 'b', 'd', 'e']);
});

test('BinarySearchTree#postorder', t => {
  let bst = new BinarySearchTree(
    { key: 'f', value: 42 },
    { key: 'b', value: 100 },
    { key: 'g', value: 22 },
    { key: 'a', value: 42 },
    { key: 'd', value: 100 },
    { key: 'i', value: 100 },
    { key: 'c', value: 100 },
    { key: 'e', value: 100 },
    { key: 'h', value: 100 },
  );

  let values = [];
  bst.postorder(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['a', 'c', 'e', 'd', 'b', 'h', 'i', 'g', 'f']);
});

test('BinarySearchTree#bfs', t => {
  let bst = new BinarySearchTree(
    { key: 'f', value: 42 },
    { key: 'b', value: 100 },
    { key: 'g', value: 22 },
    { key: 'a', value: 42 },
    { key: 'd', value: 100 },
    { key: 'i', value: 100 },
    { key: 'c', value: 100 },
    { key: 'e', value: 100 },
    { key: 'h', value: 100 },
  );

  let values = [];
  bst.bfs(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['f', 'b', 'g', 'a', 'd', 'i', 'c', 'e', 'h']);
});
```

# SF/leetcode/js/coding-harder/debounce.js

```js
/// solution

function debounce(fn, delay = 0) {
  // keep track of the last call to the debounced function
  let last = {
    time: null,
    timerId: null,
  };

  // return a debounced version of fn
  return () => {
    let time = Date.now();

    // if the debounced function was called again before the delay elapsed,
    // cancel the timer (started in the previous call) that would have called
    // fn, and start a new timer.
    if (last.time && time - last.time < delay) {
      clearTimeout(last.timerId);
    }

    // start a timer to call fn after the given delay
    last = {
      time,
      timerId: setTimeout(fn, delay),
    };
  };
}

/// tests

import { test } from 'ava';

test.cb(t => {
  t.plan(1);
  let count = 0;
  let a = () => {
    count++;
    t.is(count, 1);
    t.end();
  };
  let b = debounce(a, 100);
  b();
  b();
  b();
});
```

# SF/leetcode/js/coding-harder/permute.js

```js
/// solution

function permute(string) {
  return permuteArray(string.split(''));
}

function permuteArray(array) {
  switch (array.length) {
    case 0:
      return [];
    case 1:
      return array;
    default:
      return flatten(array.map(a => permuteArray(without(array, a)).map(b => a.concat(b))));
  }
}

function flatten(array) {
  return array.reduce((a, b) => a.concat(b), []);
}

function without(array, a) {
  const bs = array.slice(0);
  bs.splice(array.indexOf(a), 1);
  return bs;
}

/// tests

import { test } from 'ava';

test(t => t.deepEqual(permute(''), []));
test(t => t.deepEqual(permute('abc'), ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']));
```

# SF/leetcode/js/coding-intermediate/assignDeep.js

```js
/// solution

function assignDeep(target, ...sources) {
  for (let source of sources) {
    for (let key in source) {
      if (isObject(source[key])) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        assignDeep(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}

function isObject(a) {
  return typeof a === 'object' && a !== null;
}

/// tests

import { test } from 'ava';

test(t => t.deepEqual(assignDeep({ a: 1 }, {}), { a: 1 }));
test(t => t.deepEqual(assignDeep({ a: 1 }, { a: 2 }), { a: 2 }));
test(t => t.deepEqual(assignDeep({ a: 1 }, { a: { b: 2 } }), { a: { b: 2 } }));
test(t =>
  t.deepEqual(assignDeep({ a: { b: { c: 1 } } }, { a: { b: { d: 2 } }, e: 3 }), { a: { b: { c: 1, d: 2 } }, e: 3 }),
);
```

# SF/leetcode/js/coding-intermediate/fib2.js

```js
/**
 * We memoize the fib function to avoid an exponential number of repeated computations.
 */

/// solution

let fib2 = memoize(n => {
  switch (n) {
    case 0:
      return 0;
    case 1:
      return 1;
    default:
      return fib2(n - 1) + fib2(n - 2);
  }
});

function memoize(fn) {
  let cache = new Map();
  return _ => {
    if (!cache.has(_)) {
      cache.set(_, fn(_));
    }
    return cache.get(_);
  };
}

/// tests

import { test } from 'ava';

test(t => t.is(fib2(0), 0));
test(t => t.is(fib2(1), 1));
test(t => t.is(fib2(10), 55));
test(t => t.is(fib2(50), 12586269025));
```

# SF/leetcode/js/coding-intermediate/includes.js

```js
/**
 * We use a binary search to quickly search the given sorted array for the given number.
 */

/// solution

function includes(array, number) {
  let index = binarySearch(array, number, 0, array.length - 1);
  return index !== undefined;
}

function binarySearch(array, number, leftIndex, rightIndex) {
  let midIndex = Math.floor((rightIndex + leftIndex) / 2);
  let current = array[midIndex];
  if (rightIndex < leftIndex) {
    return undefined;
  }
  if (number === current) {
    return midIndex;
  }
  if (number < current) {
    return binarySearch(array, number, leftIndex, midIndex - 1);
  }
  return binarySearch(array, number, midIndex + 1, rightIndex);
}

/// tests

import { test } from 'ava';

test(t => t.is(includes([1, 3, 8, 10], 8), true));
test(t => t.is(includes([1, 3, 8, 8, 15], 15), true));
test(t => t.is(includes([1, 3, 8, 10, 15], 9), false));
```

# SF/leetcode/js/coding-intermediate/intersection.js

```js
/// solution

function intersection(left, right) {
  // first build an object from the left array,
  // because checking if an object has a certain key
  // is cheap (it takes O(1) time).
  //
  // if we didn't use this object, we'd have to check
  // if result contains current on every turn of the
  // loop, which would take up to O(N * log(N)) time.
  let seen = left.reduce((seen, item) => {
    seen[item] = true;
    return seen;
  }, {});

  return right.reduce((result, current) => {
    if (current in seen) {
      return result.concat(current);
    }
    seen[current] = true;
    return result;
  }, []);
}

/// tests

import { test } from 'ava';

test(t => t.deepEqual(intersection([1, 5, 4, 2], [8, 91, 4, 1, 3]), [4, 1]));
test(t => t.deepEqual(intersection([1, 5, 4, 2], [7, 12]), []));
```

# SF/leetcode/js/coding-intermediate/isBalanced2.js

```js
/// solution

function isBalanced2(string) {
  let stack = new Stack();
  for (let letter of string) {
    switch (letter) {
      case '{':
      case '[':
      case '(':
        stack.push(letter);
        break;
      case '}':
      case ']':
      case ')':
        if (pairOf(stack.peek()) === letter) {
          stack.pop();
        } else {
          return false;
        }
    }
  }
  return stack.size() === 0;
}

let pairs = {
  '(': ')',
  '[': ']',
  '{': '}',
};
function pairOf(letter) {
  return pairs[letter];
}

class Stack {
  constructor() {
    this.items = [];
  }
  peek() {
    return this.items[this.size() - 1];
  }
  push(item) {
    this.items.push(item);
  }
  pop() {
    return this.items.pop();
  }
  size() {
    return this.items.length;
  }
}

/// tests

import { test } from 'ava';

test(t => t.is(isBalanced2('(foo { bar (baz) [boo] })'), true));
test(t => t.is(isBalanced2('foo { bar { baz }'), false));
test(t => t.is(isBalanced2('foo { (bar [baz] } )'), false));
```

# SF/leetcode/js/coding-intermediate/reduceAsync.js

```js
/// solution

let reduceAsync = async (array, fn, value) => {
  for (let a of array) {
    value = fn(value, await a());
  }
  return value;
};

/// tests

import { test } from 'ava';

test(async t => {
  let a = () => Promise.resolve('a');
  let b = () => Promise.resolve('b');
  let c = () => new Promise(resolve => setTimeout(() => resolve('c'), 100));

  t.deepEqual(await reduceAsync([a, b, c], (acc, value) => [...acc, value], []), ['a', 'b', 'c']);
  t.deepEqual(await reduceAsync([a, c, b], (acc, value) => [...acc, value], ['d']), ['d', 'a', 'c', 'b']);
});
```

# SF/leetcode/js/coding-intermediate/seq.js

```js
/// solution

let reduceAsync = async (array, fn, value) => {
  for (let a of array) {
    value = fn(value, await a());
  }
  return value;
};

let seq = array => reduceAsync(array, (acc, value) => [...acc, value], []);

/// tests

import { test } from 'ava';

test(async t => {
  let a = () => Promise.resolve('a');
  let b = () => Promise.resolve('b');
  let c = () => Promise.resolve('c');

  t.deepEqual(await seq([a, b, c]), ['a', 'b', 'c']);
  t.deepEqual(await seq([a, c, b]), ['a', 'c', 'b']);
});
```

# SF/leetcode/js/coding-intermediate/sort.js

```js
/**
 * This is an implementation of the mergesort algorithm.
 * There are other O(N * log(N)) sort algorithms, but
 * this is probably the simplest.
 */

/// solution

function sort(array) {
  if (array.length < 2) {
    return array;
  }

  let mid = Math.floor(array.length / 2);
  let left = array.slice(0, mid);
  let right = array.slice(mid);

  return merge(sort(left), sort(right));
}

function merge(left, right) {
  let result = [];
  let indexLeft = 0;
  let indexRight = 0;

  while (indexLeft < left.length && indexRight < right.length) {
    result.push(left[indexLeft] < right[indexRight] ? left[indexLeft++] : right[indexRight++]);
  }

  return result.concat(left.slice(indexLeft)).concat(right.slice(indexRight));
}

/// tests

import { test } from 'ava';

test(t => t.deepEqual(sort([]), []));
test(t => t.deepEqual(sort([-4, 1, Infinity, 3, 3, 0]), [-4, 0, 1, 3, 3, Infinity]));
```

# SF/leetcode/js/coding-intermediate/uniq.js

```js
/// solution

function uniq(array) {
  // keep track of already seen numbers in an object,
  // because checking if an object has a certain key
  // is cheap (it takes O(1) time).
  //
  // if we didn't use this object, we'd have to check
  // if result contains current on every turn of the
  // loop, which would take up to O(N * log(N)) time.
  let seen = {};

  return array.reduce((result, current) => {
    if (current in seen) {
      return result;
    }
    seen[current] = true;
    return result.concat(current);
  }, []);
}

/// tests

import { test } from 'ava';

test(t => t.deepEqual(uniq([]), []));
test(t => t.deepEqual(uniq([1, 4, 2, 2, 3, 4, 8]), [1, 4, 2, 3, 8]));
```

# SF/leetcode/js/other/array.js

```js
/**
 * 数组、字符串的子集位置查询
 * @param       : <Array>||<String> target,目标字符串
 * @param       : <Array>||<String> tool,子串
 * @return      : <Number> 返回子串在目标中的位置，目标中找不到子串则返回-1
 * @description : 数组、字符串的子集位置查询；可转成字符串用正则匹配，
 */
function indexOfArray(target, tool) {
  for (var i = 0, targetLen = target.length; i < targetLen; i++) {
    for (var j = 0, toolLen = tool.length; j < toolLen; j++) {
      if (target[i + j] !== tool[j]) {
        break; // j++是在循环体结束后自增，使用break则在自增前就跳出循环了
      }
    }
    if (j === toolLen) {
      return i;
    }
  }
  return -1;
}
function indexOfArrayTest() {
  console.log('indexOfArray test: ', indexOfArray('abcdedfg', 'e'));
}

/**
 * 根据筛选条件从目标数组中返回符合条件的子集
 * @param       : <Array> target 要筛选的数据(数组)
 * @param       : <Object> tool  筛选条件(对象)
 * @return      : 返回符合条件的子集数组，否则返回空数组
 * @description : 数组、字符串的子集位置查询；可用filter高阶函数代替循环
 */
function arrayFilter(target, tool) {
  var result = [];
  for (var i = 0, len = target.length; i < len; i++) {
    var keep = true;
    for (var key in tool) {
      if (typeof target[i][key] === 'undefined' || target[i][key] !== tool[key]) {
        keep = false;
        break;
      }
    }
    if (keep) {
      result.push(target[i]);
    }
  }
  return result;
}
function arrayFilterTest() {
  var target = [
    { name: 'Jack', age: 18, sex: 'f' },
    { name: 'Jack', age: 20 },
    { name: 'Mike', age: 25 },
  ];
  console.log('\narrayFilter test: \n', arrayFilter(target, { age: 20 }));
  console.log('\narrayFilter test: \n', arrayFilter(target, { num: 10 }));
  console.log('\narrayFilter test: \n', arrayFilter(target, {}));
}

/**
 * 数组去重
 * @param       : <Array> target 要去重的数组
 * @description : 数组去重；可用es6 set、正则、sort等实现
 */
function arrayUnique(target) {
  // 纯数组硬比较方式，这里要注意是否需要空对象{}的去重，暂不处理
  // var result = [target[0]];
  // for (var i = 1, targetLen = target.length; i < targetLen; i++) {
  //   for (var j = 0, resultLen = result.length; j < resultLen; j++) {
  //     if (result[j] === target[i]) {
  //       break;    // j++是在循环体结束后自增，使用break则在自增前就跳出循环了
  //     }
  //   }
  //   if (j === resultLen) {
  //     result.push(target[i]);
  //   }
  // }

  // 对于去重这种无序的集合，可使用js对象的哈希特性来提高效率，但无法直接区分数字、字符，统一转为字符了
  // Note: 数据量少的情况下，哈希算法本身的复杂度就超过了循环对比，所以性能上反而更差
  var result = [target[0]];
  var temp = Object.create(null);
  temp[target[0]] = {};
  temp[target[0]][typeof target[0]] = 1;
  // 要区分数字、字符、布尔值、null等类型，必须保存 temp[target[i]][(typeof target[i])] 作为标志
  for (var i = 1, targetLen = target.length; i < targetLen; i++) {
    if (typeof temp[target[i]] === 'undefined' || !temp[target[i]].hasOwnProperty(typeof target[i])) {
      result.push(target[i]);
      temp[target[i]] = {};
      temp[target[i]][typeof target[i]] = 1;
    }
  }
  return result;
}
function arrayUniqueTest() {
  // var target = [1, 2, 3, 3, '3', '3', 'length', '__proto__', 'prototype', true, false, true, {}, {}, null, null];
  var target = [
    1,
    2,
    3,
    3,
    '3',
    '3',
    '__proto__',
    '__proto__',
    '__proto__',
    'prototype',
    'prototype',
    true,
    false,
    true,
    {},
    {},
    null,
    null,
  ];
  // var target = [1, '1', true, 'true'];
  console.log('\narrayUnique test:\n', arrayUnique(target));
}

/**
 * 合并两个有序数组
 * @param       : <Array> arrA 要合并的有序数组
 * @param       : <Array> arrB 要合并的有序数组
 * @description : 将两个已经排序的数组合并成一个数组;
 */
function mergeSortedArray(arrA, arrB) {
  var result = [];
  var i = 0,
    j = 0,
    targetLen = arrA.length,
    toolLen = arrB.length;
  while (i < targetLen && j < toolLen) {
    if (arrA[i] < arrB[j]) {
      result.push(arrA[i++]);
    } else {
      result.push(arrB[j++]);
    }
  }
  while (i < targetLen) {
    result.push(arrA[i++]);
  }
  while (j < toolLen) {
    result.push(arrB[j++]);
  }
  return result;
}
function mergeSortedArrayTest() {
  var target = [1, 5, 11, 18, 25, 40, 100, 120];
  var tool = [3, 6, 11, 30, 31, 80, 90, 97];
  console.log('\ncombineArray test:\n', mergeSortedArray(target, tool));
}

/**
 * 数组最长无重复子串查找
 * @param       : <Array> target 要查找的数组
 * @description : 查找没有重复的最长子串，若使用哈希表判断重复的话，就要重新定位，可以将哈希的value=数组元素当前序号
 */
function longestSubArray(target) {
  var lastStart, lastLen, maxStart, maxLen;
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;

  for (var i = 1, len = target.length; i < len; i++) {
    var noRepeat = true;
    for (var j = lastStart; j < lastStart + lastLen; j++) {
      if (target[i] === target[j]) {
        noRepeat = false;
        if (maxLen < lastLen) {
          maxLen = lastLen;
          maxStart = lastStart;
        }
        i = lastStart = i - (lastStart + lastLen - j) + 1;
        lastLen = 1;
        break;
      }
    }
    if (noRepeat) {
      lastLen++;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
// 哈希版本，js实现起来简单、在数据量大的情况下会有优势
function longestSubArrayHash(target) {
  var lastStart,
    lastLen,
    maxStart,
    maxLen,
    last = {};
  lastStart = maxStart = 0;
  lastLen = maxLen = 1;
  last[target[lastStart]] = lastStart;

  for (var i = 1, len = target.length; i < len; i++) {
    if (typeof last[target[i]] === 'undefined') {
      lastLen++;
      last[target[i]] = i;
    } else {
      if (maxLen < lastLen) {
        maxLen = lastLen;
        maxStart = lastStart;
      }
      i = lastStart = last[target[i]] + 1;
      last = {};
      last[target[lastStart]] = lastStart;
      lastLen = 1;
    }
  }
  if (maxLen < lastLen) {
    maxLen = lastLen;
    maxStart = lastStart;
  }
  return target.slice(maxStart, maxLen + maxStart);
}
function longestSubArrayTest() {
  var target = [1, 2, 3, 4, 3, 6, 8, 9, 10, 14, 15, 8, 9];
  console.log('\nlongestSubArray test:\n', longestSubArray(target));
  console.log('\nlongestSubArrayHash test:\n', longestSubArrayHash(target));
}

/**
 * 数组重复次数最多的子串查找
 * @param       : <Array> target 要查找的数组
 * @description : 查重，输出重复次数最多的元素及其重复次数。
 */
function countSubArray(target) {
  var sub = {};
  var max = {
    num: 1,
    index: 0,
  };
  for (var i = 0, len = target.length; i < len; i++) {
    if (!sub.hasOwnProperty(target[i])) {
      sub[target[i]] = {
        num: 1,
        index: i,
      };
    } else {
      var current = sub[target[i]];
      current.num++;
      if (max.num < current.num) {
        max.num = current.num;
        max.index = current.index;
      }
    }
  }
  return {
    element: target[max.index],
    index: max.index,
    count: max.num,
  };
}
function countSubArrayTest() {
  var target = [2, 2, 2, 4, 4, 11, 11, 5, 15, 11, 17, 11, 80, 11];
  var target1 = ['qwe', 'as', 'dsfw', 'as', 'kou', 'lpi', 'as', 'jei', 'as'];
  console.log('\ncountSubArrayTest test:\n', countSubArray(target1));
}

/**
 * 查询字符串第一个不重复字母
 * @param       : <Array> target 要查找的数组
 * @description : 查询给定字符串“abcba”，处理得到第一个不重复字母，c
 */
function queryFirstUniqueItem(target) {
  var items = {};
  var last = [];
  for (var i = 0, l = target.length; i < l; i++) {
    var item = target[i];
    if (!items.hasOwnProperty(item)) {
      last.push(i);
      items[item] = i;
    } else {
      var index = last.indexOf(items[item]);
      if (index >= 0) {
        last.splice(index, 1);
      }
    }
  }
  var ret = '';
  if (last.length) {
    ret = target[last[0]];
  }
  return ret;
}
function queryFirstUniqueItemTest() {
  var a = 'abdcbadegceg';
  var ret = queryFirstUniqueItem(a);
  console.log('ret: ', ret);
  console.log('ret: ', !ret);
}

// 给一个数组如：[[“a”,”b”,”c”],[“d”,”e”],…..]得到[ad,ae,bd,be,cd,ce]
function mapConcat(target) {
  var res = target.reduce(function(pre, next) {
    var ret = [];
    pre.forEach(function(preItem) {
      next.forEach(function(nextItem) {
        if (preItem !== nextItem) {
          // 去掉aa这种情况
          ret.push(preItem + nextItem);
        }
      });
    });
    return ret;
  });
  return res;
}
function mapConcatTest() {
  // var target = [['a', 'b', 'c'], ['d', 'e'], ['f', 'g', 'h'], ['j', 'm']];
  var target = [
    ['a', 'b', 'c'],
    ['a', 'b'],
  ];
  console.log('\nmapConcatTest:\n', mapConcat(target));
}
// mapConcatTest();

// 求整数数组的最大子串和，如 [-23, 17, -7, 11, -2, 1, -34] 的最大子串和是21，对应子串是 [17, -7, 11]
function maxSeqSum(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const len = arr.length;
  let maxSum = arr[0];
  let seqSum = arr[0];
  for (let i = 1; i < len; i++) {
    if (seqSum <= 0) {
      seqSum = arr[i];
    } else {
      seqSum += arr[i];
    }
    if (seqSum > maxSum) {
      maxSum = seqSum;
    }
  }
  return maxSum;
}
function maxSeqSumTest() {
  console.log(maxSeqSum([-23, 17, -7, 11, -2, 1, -34]));
  console.log(maxSeqSum([1, -2, 3, 10, -4, 7, 2, -5]));
  console.log(maxSeqSum([-1]));
}
// maxSeqSumTest();
```

# SF/leetcode/js/other/chain.js

```js
/**
 * @authors     : qieguo
 * @date        : 2016/11/29
 * @version     : 1.0
 * @description : js模拟链表
 */

'use strict';
function Chain(key, value) {
  this.next = null;
  this.key = key;
  this.value = value;
  this.length = 1;
}

// 插入元素
Chain.prototype.insertAfter = function(pos, key, value) {
  var currentObj = this;
  var addObj = {
    key: key,
    value: value,
  };

  // 循环
  while (currentObj.key !== pos) {
    currentObj = currentObj.next;
  }

  // 找到元素
  addObj.next = currentObj.next;
  currentObj.next = addObj;
  this.length++;
  return this;
};

// 删除元素
Chain.prototype.delele = function(key) {
  var last = null;
  var currentObj = this;
  // 循环
  while (currentObj.key !== key) {
    last = currentObj;
    currentObj = currentObj.next;
  }
  // 找到元素
  last.next = currentObj.next;
  this.length--;
  return this;
};

// 查找元素
Chain.prototype.find = function(key) {
  var currentObj = this;
  // 循环
  while (currentObj.key !== key) {
    currentObj = currentObj.next;
  }
  // 找到元素
  return currentObj.value;
};

Chain.prototype.forEach = function(fn) {
  var currentObj = this;
  // 循环
  while (currentObj.next !== null) {
    fn({ key: currentObj.key, value: currentObj.value });
    currentObj = currentObj.next;
  }
  fn({ key: currentObj.key, value: currentObj.value });
};

function test() {
  var chain = new Chain('header', 'head value');
  chain.insertAfter('header', 'second', 'next to header');
  chain.insertAfter('second', '3rd', '3rd value');
  chain.insertAfter('3rd', '4th', '4th value');
  chain.insertAfter('4th', '5th', '5th value');
  console.log('add to end', JSON.stringify(chain));

  chain.insertAfter('3rd', 'add4th', 'add 4th value');
  console.log('insert between', JSON.stringify(chain));

  chain.delele('3rd');
  console.log('delete 3rd', JSON.stringify(chain));

  var temp = chain.delele('add4th').find('5th');
  console.log('5th: ', temp);

  console.log('chain.length', chain.length);

  chain.forEach(function(obj) {
    console.log(obj);
  });
}

test();
```

# SF/leetcode/js/other/event.js

```js
/**
 * @authors     : qieguo
 * @date        : 2016/12/09
 * @version     : 1.0
 * @description : 一个简单的观察者模式事件系统实现
 */

const Noop = () => {};

class EventEmitter {
  constructor() {
    this.events = [];
  }

  on(event, handler = Noop) {
    if (typeof this.events[event] === 'undefined') {
      this.events[event] = [handler];
    } else {
      this.events[event].push(handler);
    }
  }

  once(event, handler = Noop) {
    const once = `once_${event}`;
    if (typeof this.events[once] === 'undefined') {
      this.events[once] = [handler];
    } else {
      this.events[once].push(handler);
    }
  }

  emit(event, args) {
    const once = `once_${event}`;
    if (typeof this.events[once] !== 'undefined') {
      this.events[once].forEach(handler => {
        handler(args);
      });
      delete this.events[`once_${event}`];
    }
    if (typeof this.events[event] !== 'undefined') {
      this.events[event].forEach(handler => {
        handler(args);
      });
    }
  }

  off(event, handler) {
    if (typeof this.events[event] !== 'undefined') {
      if (!!handler) {
        const index = this.events[event].indexOf(handler);
        this.events[event].splice(index, 1);
      } else {
        delete this.events[event];
      }
    }
  }
}

function test() {
  const eh = new EventEmitter();

  const firstHd = str => {
    console.log('first greet: ', str);
  };

  eh.on('greet', firstHd);

  eh.on('greet', str => {
    console.log('second greet: ', str);
  });

  eh.on('bye', name => {
    console.log(name + ', goodbye!');
  });

  eh.once('break', str => {
    console.log(`once break: ${str}`);
  });
  eh.on('break', str => {
    console.log(`on break: ${str}`);
  });

  console.log('======  start  ======');
  eh.emit('greet', 'Green');
  eh.emit('bye', 'Mark');
  eh.emit('break', 'Jack');
  eh.emit('break', 'Tony');

  console.log('======  removeListener  ======');
  eh.off('bye');
  eh.emit('bye', 'Mark');

  eh.off('greet', firstHd);
  eh.emit('greet', 'Green');
}

test();
```

# SF/leetcode/js/other/others.js

```js
/**
 * @authors     : qieguo
 * @date        : 2017/3/6 0006
 * @description :
 */

// 节流throttle，多次触发但只执行一部分，(恒时间间距执行)
function throttle(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    if (!timer) {
      timer = setTimeout(function() {
        timer = null;
        method.apply(ctx, args);
      }, threshold);
    }
  };
}

// 防抖debounce, 多次触发但只执行一次，(时间差大于阈值才执行)
function debounce(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    timer && clearTimeout(timer);
    timer = setTimeout(function() {
      method.apply(ctx, args);
    }, threshold);
  };
}

// 轮循函数
// usage: wait(fn.bind(ctx, ...args), 10000);
function wait(fn, timeout, tick) {
  timeout = timeout || 5000;
  tick = tick || 250;
  var timeoutTimer = null;
  var execTimer = null;

  return new Promise(function(resolve, reject) {
    timeoutTimer = setTimeout(function() {
      clearTimeout(execTimer);
      reject(new Error('polling fail because timeout'));
    }, timeout);

    tickHandler(fn);

    function tickHandler(fn) {
      var ret = fn();
      if (!ret) {
        execTimer = setTimeout(function() {
          tickHandler(fn);
        }, tick);
      } else {
        clearTimeout(timeoutTimer);
        resolve();
      }
    }
  });
}

var n = 1;
wait(
  function() {
    console.log(n++);
    return n > 10;
  },
  2000,
  300,
)
  .then(function() {
    console.log('===== end ====');
  })
  .catch(function(err) {
    console.error('error', err);
  });
```

# SF/leetcode/js/other/recursive.js

```js
/**
 * @authors     : qieguo
 * @date        : 2017/1/2 0002
 * @version     : 1.0
 * @description : 一些递归算法
 */

'use strict';

/**
 * 阶梯问题
 * 假设一个楼梯有 N 阶台阶，人每次最多可以跨 M 阶，求总共的爬楼梯方案数。
 * 例如楼梯总共有3个台阶，人每次最多跨2个台阶，也就是说人每次可以走1个，也可以走2个，但最多不会超过2个，那么楼梯总共有这么几种走法：
 * 111，12，21
 */

var methods = [];
function countSteps(steps, max, method) {
  method = method || '';
  if (steps === 0) {
    methods.push(method);
    return method;
  }
  if (steps < max) {
    countSteps(steps, steps, method);
  } else {
    for (var i = 1; i <= max; i++) {
      countSteps(steps - i, max, method + String(i));
    }
  }
}

countSteps(4, 3);
console.log('methods', methods);

/**
 * 链式函数
 * 编写阶乘函数 fn，使得 fn(2)(3) = 6，fn(2)(3)(4) = 24
 * 这里用到递归、函数柯里化、valueOf几个点，注意()运算符是从左到右执行的
 */
function mul(x) {
  const fn = y => mul(x * y); // 返回一个函数，函数参数里面做乘法运算
  fn.valueOf = () => x; // 改写valueOf，在链式运算最后一步输出结果
  return fn;
}

/**
 * 汉诺塔问题
 * 编写函数输出汉诺塔移动轨迹，move(n, a, b, c)，n为盘子数量，a为源头，b为中转柱子，c为目标柱子
 */
function move(n, a, b, c) {
  if (n === 1) {
    console.log(`${a} --> ${c}`);
  } else {
    move(n - 1, a, c, b);
    move(1, a, b, c);
    move(n - 1, b, a, c);
  }
}

// move(5, 'A', 'B', 'C');
```

# SF/leetcode/js/other/stack_queue.js

```js
/**
 * @authors     : qieguo
 * @date        : 2016/11/29
 * @version     : 1.0
 * @description : js模拟链表
 */

'use strict';

function pairTest(str) {
  var open = {
    '<': '>',
    '{': '}',
    '(': ')',
  };
  var close = {
    '>': '<',
    '}': '{',
    ')': '(',
  };
  var stack = [];
  var result = [];
  for (var i = 0, len = str.length; i < len; i++) {
    if (open[str[i]]) {
      stack.push({ index: i, value: str[i] });
    }
    if (close[str[i]]) {
      if (close[str[i]] === stack[stack.length - 1].value) {
        var temp = stack.pop();
        result.push(str.slice(temp.index + 1, i));
      } else {
        throw new Error('匹配出错！');
      }
    }
  }
  return result;
}

console.log(pairTest('sdf<asdsdfeesf{sdfefi{esadf{aefw}sdfw}sd}>'));

/**
 * 异步操作池
 * @param {Array<Promise>} tasks
 * @param {Number} limit 最大并发数，默认为1表示串行
 * 两种错误处理：1、其中一个任务出错就停止所有；2、执行完所有任务后收集所有错误
 */
function asyncPoolByThunk(tasks, limit = 1, cb = () => {}, options = {}) {
  const stopImmediate = options.stopImmediate;
  let index = limit - 1;
  let errs = [];

  function next(err) {
    if (err) {
      errs.push(err);
      if (stopImmediate) {
        cb(errs);
        return;
      }
    }
    if (index > tasks.length) {
      cb(errs);
      return;
    }
    const current = tasks[++index];
    if (typeof current === 'function') {
      if (stopImmediate && errs.length > 0) {
        return;
      }
      current(next);
    }
  }

  for (let k = 0; k < limit; k++) {
    tasks[k](next);
  }
}

function asyncFn(params) {
  return function(next) {
    setTimeout(() => {
      console.log('async', params);
      next(params === '4' ? '5555' : null);
    }, 1000);
  };
}
asyncPoolByThunk(
  '123456789'.split('').map(el => asyncFn(el)),
  3,
  function(errs) {
    console.log('errs', errs);
  },
  { stopImmediate: true },
);
```

# SF/leetcode/js/other/tree.js

```js
/**
 * @authors     : qieguo
 * @date        : 2017/1/2
 * @version     : 1.0
 * @description : 树相关算法(二叉树、二叉查找数、堆)
 */

'use strict';

function BinaryRearchTree(arr) {
  function init() {
    if (!Array.isArray(arr)) {
      console.error(arr + ' is not a Array');
      return false;
    }
  }
}

/**
 * 堆排序
 * 应用：用尺寸为n的最小堆(最大堆)来筛选大数据集里面最大(小)的n个数
 * 流程：
 * 1)先使用数据集里面的前n条数据来构造最小堆
 * 2)遍历数据集，将每个数据与堆顶元素比较，若小于堆顶则抛弃，否则替换掉堆顶
 * 3)调整替换后的堆，继续2)
 *
 * 用有序数组+2分查找也是类似的，不过效率低一些。
 */
```
