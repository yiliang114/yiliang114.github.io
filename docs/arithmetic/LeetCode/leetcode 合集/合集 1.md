---
layout: CustomPages
title: LeetCode-合集 1
date: 2020-09-04
aside: false
draft: true
---

# SF/leetcode/js/coding-easy/missing.js

```js
function missing(array) {
  // sum the array, and keep track of the maximum number in it
  let max = array[0];
  let sum = 0;
  array.forEach(number => {
    sum += number;
    if (number > max) {
      max = number;
    }
  });

  // the maximum tells us how long the array should be.
  // we plug it into the formula to sum a series to see
  // what we should expect the sum to be.
  let expectedSum = (max * (max + 1)) / 2;
  let difference = expectedSum - sum;

  if (difference > 0) {
    return difference;
  } else {
    return undefined;
  }
}

/// tests

import { test } from 'ava';

test(t => t.is(missing([]), undefined));
test(t => t.is(missing([1, 4, 3]), 2));
test(t => t.is(missing([2, 3, 4]), 1));
test(t => t.is(missing([5, 1, 4, 2]), 3));
test(t => t.is(missing([1, 2, 3, 4]), undefined));
```

# SF/leetcode/js/coding-harder/BinarySearchTree.js

```js
class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  // O(n), where n is # nodes
  get(value) {
    let node = this.root;
    while (node != null) {
      if (value === node.value) return node.value;
      else if (value < node.value) node = node.left;
      else node = node.right;
    }
    return null;
  }

  // O(n), where n is # nodes
  has(value) {
    return this.get(value) !== null;
  }

  // O(n), where n is # nodes
  add(...values) {
    function _add(value, node) {
      if (node === null) return new Node(value);
      if (value < node.value) {
        node.left = _add(value, node.left);
      } else if (value > node.value) {
        node.right = _add(value, node.right);
      } else {
        node.value = value;
      }
      return node;
    }
    for (let value of values) {
      this.root = _add(value, this.root);
    }
  }

  // O(n), where n is # nodes
  size() {
    let _size = node => (node === null ? 0 : 1 + _size(node.left) + _size(node.right));
    return _size(this.root);
  }

  // Hibbard deletion
  remove(value) {
    function _remove(value, node) {
      if (node === null) return null;
      if (value < node.value) node.left = _remove(value, node.left);
      else if (value > node.value) node.right = _remove(value, node.right);
      else {
        if (node.right === null) return node.left;
        if (node.left === null) return node.right;

        let t = node;
        node = min(t.right);
        node.right = removeMin(t.right);
        node.left = t.left;
      }
      return node;
    }

    function removeMin(node) {
      if (node.left === null) return node.right;
      node.left = removeMin(node.left);
      return node;
    }

    function min(node) {
      let curr = node;
      while (curr.left !== null) curr = curr.left;
      return curr;
    }

    this.root = _remove(value, this.root);
  }
}

class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

/// tests

import { test } from 'ava';

test('BinarySearchTree', t => {
  let tree = new BinarySearchTree();
  tree.add(1, 2, 3, 4);
  tree.add(5);
  t.is(tree.has(2), true);
  t.is(tree.has(5), true);
  tree.remove(3);
  t.is(tree.size(), 4);
});

test('BinarySearchTree#get', t => {
  let tree = new BinarySearchTree();
  t.is(tree.get(42), null);
  tree.add(42, 43);
  t.is(tree.get(42), 42);
  t.is(tree.get(43), 43);
  t.is(tree.get(44), null);
});
```

# SF/leetcode/js/coding-harder/HashMap.js

```js
class HashMap {
  constructor() {
    this.data = [];
  }
  get(key) {
    let index = hash(key);
    let slot = this.data[index];
    if (!slot) {
      return undefined;
    }
    for (let [k, v] of slot) {
      if (key === k) {
        return v;
      }
    }
  }
  set(key, value) {
    let index = hash(key);

    if (!this.data[index]) {
      this.data[index] = [];
    }

    let slot = this.data[index];
    let indexInSlot = 0;

    // find available index in the given slot, or overwrite the given key
    // if a value is already defined for it.
    while (slot[indexInSlot]) {
      if (slot[indexInSlot][0] === key) {
        break;
      }
      indexInSlot++;
    }

    slot[indexInSlot] = [key, value];
  }
}

// hash function (provided)
function hash(string) {
  return string.split('').reduce((a, b) => (a << 5) + a + b.charCodeAt(0), 5381);
}

/// tests

import { test } from 'ava';

test('HashMap', t => {
  let map = new HashMap();
  map.set('abc', 123);
  map.set('foo', 'bar');
  map.set('foo', 'baz');
  t.is(map.get('abc'), 123);
  t.is(map.get('foo'), 'baz');
  t.is(map.get('def'), undefined);
});
```

# SF/leetcode/js/coding-harder/LinkedList.js

```js
/**
 * LinkedList has 2 members, head and tail:
 * - head is a value
 * - tail is either another LinkedList, or null
 */
export class LinkedList {
  constructor(head, ...tail) {
    this.head = head;
    this.tail = tail.length ? new LinkedList(...tail) : null;
  }
  add(item) {
    if (this.tail) {
      this.tail.add(item);
    } else {
      this.tail = new LinkedList(item);
    }
  }
  has(item) {
    if (this.head === item) {
      return true;
    }
    if (this.tail === null) {
      return false;
    }
    return this.tail.has(item);
  }
}

// tests

import test from 'ava';

test('LinkedList', t => {
  let list = new LinkedList(1, 2, 3);
  list.add(4);
  list.add(5);
  t.is(list.has(1), true);
  t.is(list.has(4), true);
  t.is(list.has(6), false);
});
```

# SF/leetcode/js/coding-harder/TreeTraversal.js

```js
class BinarySearchTree {
  constructor(...nodes) {
    this.root = null;
    for (let node of nodes) {
      this.put(node.key, node.value);
    }
  }

  put(key, value) {
    function _put(node, key, value) {
      if (node === null) return new Node(key, value);
      else if (key < node.key) {
        node.left = _put(node.left, key, value);
      } else if (key > node.key) {
        node.right = _put(node.right, key, value);
      } else {
        node.value = value;
      }
      return node;
    }
    this.root = _put(this.root, key, value);
  }

  get(key) {
    let x = this.root;
    while (x !== null) {
      if (key < x.key) x = x.left;
      // traverse left
      else if (key > x.key) x = x.right;
      // traverse right
      else return x.value; // found it!
    }
    return x;
  }

  delete(key) {
    function _delete(node, key) {
      if (node === null) return;
      if (key < node.key) {
        node.left = _delete(node.left, key);
      } else if (key > node.key) {
        node.right = _delete(node.right, key);
      } else {
        // node.key === key
        if (node.right === null) return node.left;
        if (node.left === null) return node.right;

        let t = node;
        node = min(t.right);
        node.right = removeMin(t.right);
        node.left = t.left;
      }
      return node;
    }

    function removeMin(node) {
      if (node.left === null) return node.right;
      node.left = removeMin(node.left);
      return node;
    }

    function min(node) {
      let x = node;
      while (x.left !== null) x = x.left;
      return x;
    }

    this.root = _delete(this.root, key);
  }

  contains(key) {
    return this.get(key) !== null;
  }

  isEmpty() {
    return this.root === null;
  }

  size() {
    function _size(node) {
      return node === null ? 0 : 1 + _size(node.left) + _size(node.right);
    }
    return _size(this.root);
  }

  inorder(fn) {
    function _inorder(node) {
      if (node === null) return;
      _inorder(node.left);
      fn(node);
      _inorder(node.right);
    }
    _inorder(this.root);
  }

  preorder(fn) {
    function _preorder(node) {
      if (node === null) return;
      fn(node);
      _preorder(node.left);
      _preorder(node.right);
    }
    _preorder(this.root);
  }

  postorder(fn) {
    function _postorder(node) {
      if (node === null) return;
      _postorder(node.left);
      _postorder(node.right);
      fn(node);
    }
    _postorder(this.root);
  }

  bfs(fn) {
    if (this.root === null) return;
    let queue = new Queue();
    queue.enqueue(this.root);
    while (!queue.isEmpty()) {
      let node = queue.dequeue();
      fn(node);
      if (node.left !== null) queue.enqueue(node.left);
      if (node.right !== null) queue.enqueue(node.right);
    }
  }
}

class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class Queue {
  constructor(...items) {
    this.data = [];
    for (let item of items) {
      this.enqueue(item);
    }
  }

  enqueue(item) {
    this.data.unshift(item);
  }
  dequeue() {
    return this.data.pop();
  }
  isEmpty() {
    return this.data.length === 0;
  }
}

import { test } from 'ava';
test('BinarySearchTree#put', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.get('c'), 42);
  bst.put('c', 44);
  t.is(bst.get('c'), 44);
});

test('BinarySearchTree#get', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.get('a'), 100);
  t.is(bst.get('c'), 42);
  t.is(bst.get('d'), 22);
});

test('BinarySearchTree#delete', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.get('a'), 100);
  t.is(bst.get('c'), 42);
  t.is(bst.get('d'), 22);

  bst.delete('a');
  bst.delete('d');
  t.is(bst.get('d'), null);
  t.is(bst.get('a'), null);
  t.is(bst.get('c'), 42);
});

test('BinarySearchTree#size', t => {
  let bst = new BinarySearchTree({ key: 'c', value: 42 }, { key: 'a', value: 100 }, { key: 'd', value: 22 });
  t.is(bst.size(), 3);
  bst.delete('d');
  bst.delete('a');
  t.is(bst.size(), 1);
});

test('BinarySearchTree#inorder', t => {
  let bst = new BinarySearchTree(
    { key: 'c', value: 42 },
    { key: 'a', value: 100 },
    { key: 'd', value: 22 },
    { key: 'e', value: 42 },
    { key: 'b', value: 100 },
  );

  let values = [];
  bst.inorder(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['a', 'b', 'c', 'd', 'e']);
});

test('BinarySearchTree#preorder', t => {
  let bst = new BinarySearchTree(
    { key: 'c', value: 42 },
    { key: 'a', value: 100 },
    { key: 'd', value: 22 },
    { key: 'e', value: 42 },
    { key: 'b', value: 100 },
  );

  let values = [];
  bst.preorder(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['c', 'a', 'b', 'd', 'e']);
});

test('BinarySearchTree#postorder', t => {
  let bst = new BinarySearchTree(
    { key: 'f', value: 42 },
    { key: 'b', value: 100 },
    { key: 'g', value: 22 },
    { key: 'a', value: 42 },
    { key: 'd', value: 100 },
    { key: 'i', value: 100 },
    { key: 'c', value: 100 },
    { key: 'e', value: 100 },
    { key: 'h', value: 100 },
  );

  let values = [];
  bst.postorder(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['a', 'c', 'e', 'd', 'b', 'h', 'i', 'g', 'f']);
});

test('BinarySearchTree#bfs', t => {
  let bst = new BinarySearchTree(
    { key: 'f', value: 42 },
    { key: 'b', value: 100 },
    { key: 'g', value: 22 },
    { key: 'a', value: 42 },
    { key: 'd', value: 100 },
    { key: 'i', value: 100 },
    { key: 'c', value: 100 },
    { key: 'e', value: 100 },
    { key: 'h', value: 100 },
  );

  let values = [];
  bst.bfs(n => {
    values.push(n.key);
  });
  t.deepEqual(values, ['f', 'b', 'g', 'a', 'd', 'i', 'c', 'e', 'h']);
});
```

# SF/leetcode/js/other/stack_queue.js

```js
function pairTest(str) {
  var open = {
    '<': '>',
    '{': '}',
    '(': ')',
  };
  var close = {
    '>': '<',
    '}': '{',
    ')': '(',
  };
  var stack = [];
  var result = [];
  for (var i = 0, len = str.length; i < len; i++) {
    if (open[str[i]]) {
      stack.push({ index: i, value: str[i] });
    }
    if (close[str[i]]) {
      if (close[str[i]] === stack[stack.length - 1].value) {
        var temp = stack.pop();
        result.push(str.slice(temp.index + 1, i));
      } else {
        throw new Error('匹配出错！');
      }
    }
  }
  return result;
}

console.log(pairTest('sdf<asdsdfeesf{sdfefi{esadf{aefw}sdfw}sd}>'));

/**
 * 异步操作池
 * @param {Array<Promise>} tasks
 * @param {Number} limit 最大并发数，默认为1表示串行
 * 两种错误处理：1、其中一个任务出错就停止所有；2、执行完所有任务后收集所有错误
 */
function asyncPoolByThunk(tasks, limit = 1, cb = () => {}, options = {}) {
  const stopImmediate = options.stopImmediate;
  let index = limit - 1;
  let errs = [];

  function next(err) {
    if (err) {
      errs.push(err);
      if (stopImmediate) {
        cb(errs);
        return;
      }
    }
    if (index > tasks.length) {
      cb(errs);
      return;
    }
    const current = tasks[++index];
    if (typeof current === 'function') {
      if (stopImmediate && errs.length > 0) {
        return;
      }
      current(next);
    }
  }

  for (let k = 0; k < limit; k++) {
    tasks[k](next);
  }
}

function asyncFn(params) {
  return function(next) {
    setTimeout(() => {
      console.log('async', params);
      next(params === '4' ? '5555' : null);
    }, 1000);
  };
}
asyncPoolByThunk(
  '123456789'.split('').map(el => asyncFn(el)),
  3,
  function(errs) {
    console.log('errs', errs);
  },
  { stopImmediate: true },
);
```
