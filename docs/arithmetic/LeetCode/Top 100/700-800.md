---
layout: CustomPages
title: LeetCode-合集 700-800
date: 2020-09-04
aside: false
draft: true
---

### [739].daily-temperatures

```js
/*
 * @lc app=leetcode id=739 lang=javascript
 *
 * [739] Daily Temperatures
 */
/**
 * @param {number[]} T
 * @return {number[]}
 */
var dailyTemperatures = function(T) {
  // // 暴力  时间复杂度O(n^2), 空间复杂度O(1)
  // const res = [];
  // for(let i = 0; i < T.length; i++) {
  //     res[i] = 0;
  //     for(let j = i; j < T.length; j++) {
  //         if (T[j] > T[i]) {
  //             res[i] = j - i;
  //             break;
  //         }
  //     }
  // }

  // return res;

  // 递增栈/递减栈
  // 这里我们需要用到递减栈
  // 时间复杂度O(n), 空间复杂度O(n)
  // 典型的空间换时间
  const stack = [];
  const res = [];

  for (let i = 0; i < T.length; i++) {
    res[i] = 0;
    while (stack.length !== 0 && T[i] > T[stack[stack.length - 1]]) {
      const peek = stack.pop();
      res[peek] = i - peek;
    }
    stack.push(i);
  }

  return res;
};
```

### [739].Daily Temperatures

#### 信息卡片

- 题目链接：https://leetcode.com/problems/daily-temperatures/
- tag：`Array` `Stack`

```
Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.

For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].

Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].
```

#### 参考答案

暴力，双层 for 循环。`效率很低`

1. 外层是‘当天’T[i]，内层是‘当天’之后 T[j]；
2. 多少天之后比‘当天’温度高就是 j-i；

时间复杂度 O(n^2), 空间复杂度 O(1)

参考 JavaScript 代码：

```js
/**
 * @param {number[]} T
 * @return {number[]}
 * 双层for循环
 */
var dailyTemperatures = function(T) {
  let result = [];
  for (let i = 0; i < T.length; i++) {
    result[i] = 0;
    for (let j = i + 1; j < T.length; j++) {
      if (T[i] < T[j]) {
        result[i] = j - i;
        break;
      }
    }
  }
  return result;
};
```

使用栈,单调递减栈

1. for 循环遍历数组，栈存 T 的下标 i，返回结果数组 result；
2. 拿栈顶元素 peek 与 i 比较，T[peek] >= T[i]则将 i 入栈，T[peek] < T[i]则栈顶值(原数组下标)位置的天数就是 result[peek] = i - peek；
3. 栈顶元素出栈；
4. 重复 2，3 两步；

时间复杂度 O(n), 空间复杂度 O(n)

参考 JavaScript 代码：

```js
/**
 * @param {number[]} T
 * @return {number[]}
 * 递减栈；
 */
var dailyTemperatures = function(T) {
  let stack = [];
  let result = [];
  for (let i = 0; i < T.length; i++) {
    result[i] = 0;
    while (stack.length > 0 && T[stack[stack.length - 1]] < T[i]) {
      let peek = stack.pop();
      result[peek] = i - peek;
    }
    stack.push(i);
  }
  return result;
};
```
