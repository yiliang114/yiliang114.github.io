---
layout: CustomPages
title: LeetCode-合集 0-100
date: 2020-09-04
aside: false
draft: true
---

### [1].两数之和 twoSum DONE

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

```js
// 80 ms	39.8 MB
var twoSum = function(nums = [], target) {
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    if (map[target - nums[i]] !== undefined) {
      return [map[target - nums[i]], i];
    }
    map[nums[i]] = i;
  }
};
```

```js
// 76 ms	39.8 MB
var twoSum = function(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i];
    }
    map.set(nums[i], i);
  }
};
```

事实证明，{} 与 Map 的存取速度差不多

### [2].两数相加 addTwoNumbers

给出两个非空的`链表`用来表示两个非负的整数。其中，它们各自的位数是按照**逆序**的方式存储的，并且它们的每个节点只能存储一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

#### 思路

设立一个表示进位的变量 carried，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上 carried 后的值作为一个新节点到新链表后面。

#### 代码

```js
var addTwoNumbers = function(l1, l2) {
  var carried = 0; // 用于进位
  const head = new ListNode();
  const noop = {
    val: 0,
    next: null,
  };
  let currentL1 = l1;
  let currentL2 = l2;
  let currentNode = head; // 返回的链表的当前 node
  let newNode; // 声明在外面节省内存
  let previousNode; // 记录前一个节点，便于删除最后一个节点

  while (currentL1 || currentL2) {
    newNode = new ListNode(0);

    currentNode.val = ((currentL1 || noop).val + (currentL2 || noop).val + carried) % 10;

    currentNode.next = newNode;
    previousNode = currentNode;
    currentNode = newNode;

    if ((currentL1 || noop).val + (currentL2 || noop).val + carried >= 10) {
      carried = 1;
    } else {
      carried = 0;
    }

    currentL1 = (currentL1 || noop).next;
    currentL2 = (currentL2 || noop).next;
  }

  if (carried) {
    // 还有位没进呢
    previousNode.next = new ListNode(carried);
  } else {
    previousNode.next = null;
  }

  return head;
};
```

```js
export default function addTwoNumbers(l1, l2) {
  let carry = false; // 进位
  // TODO:
  let ans;
  let prev;
  while (l1 || l2 || carry) {
    const val1 = (l1 && l1.val) || 0;
    const val2 = (l2 && l2.val) || 0;
    let sum = val1 + val2;
    if (carry) sum++;
    // 大于 9 需要进位
    carry = sum > 9;
    // 余数
    const mod = sum % 10;
    if (ans) {
      prev.next = new ListNode(mod);
      prev = prev.next;
    } else {
      ans = new ListNode(mod);
      prev = ans;
    }
    // 递归
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }
  return ans;
}
```

```js
var addTwoNumbers = function(l1, l2) {
  let HEAD = new ListNode(0);
  let cur = HEAD;
  let p = l1,
    q = l2;
  let carry = 0;
  while (q !== null || p !== null) {
    let x = q === null ? 0 : q.val;
    let y = p === null ? 0 : p.val;
    let sum = carry + x + y;
    carry = Math.floor(sum / 10);
    let val = sum % 10;
    cur.next = new ListNode(val);
    cur = cur.next;
    if (q !== null) {
      q = q.next;
    }
    if (p !== null) {
      p = p.next;
    }
  }
  if (carry) {
    cur.next = new ListNode(carry);
  }
  return HEAD.next;
};
```

```js
function List(arr) {
  let head = new ListNode();
  const guard = head;
  if (arr.length === 0) return guard;
  for (let i = 0; i < arr.length; i++) {
    let temp = new ListNode(arr[i]);
    head.next = temp;
    head = temp;
  }
  return guard.next;
}

function ListNodeToString(listNode) {
  let resp = '';
  let cur = listNode;
  while (cur.next) {
    resp += `${cur.val} -> `;
    cur = cur.next;
  }
  resp += `${cur.val}`;
  console.log(resp);
}

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  var c = 0;
  var ret = new ListNode(0);
  var curr = ret;

  while (l1 || l2) {
    var a = l1 ? l1.val : 0;
    var b = l2 ? l2.val : 0;
    var sum = a + b + c;
    // 商作为向前进的值
    c = Math.floor(sum / 10);
    // 当前位数的节点
    curr.next = new ListNode(sum % 10);
    if (l1) {
      l1 = l1.next;
    }
    if (l2) {
      l2 = l2.next;
    }
    curr = curr.next;
  }
  // 最后需要创建的一位
  if (c) {
    curr.next = new ListNode(c);
  }

  return ret.next;
};

const l1 = List([2, 4, 3]);
const l2 = List([5, 6, 4]);
const l3 = addTwoNumbers(l1, l2);
ListNodeToString(l3);
```

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  let head = new ListNode(0);
  let cur = head;
  let curry = 0;

  while (true) {
    let sum = curry;
    sum += l1 ? l1.val : 0;
    sum += l2 ? l2.val : 0;
    cur.val = sum % 10;
    curry = parseInt(sum / 10);
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
    if (l1 != null || l2 != null) {
      cur.next = new ListNode(0);
      cur = cur.next;
    } else {
      break;
    }
  }
  if (curry != 0) {
    cur.next = new ListNode(0);
    cur = cur.next;
    cur.val = curry;
  }
  return head;
};

var l1 = new ListNode(1);
l1.next = new ListNode(8);

var l2 = new ListNode(0);

console.log(addTwoNumbers(l1, l2));
```

### [3].无重复字符的最长子串

#### 思路

用一个 hashmap 来建立字符和其出现位置之间的映射。维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。

1. 如果当前遍历到的字符从未出现过，那么直接扩大右边界；
2. 如果当前遍历到的字符出现过，则缩小窗口(左边索引向右移动)，然后继续观察当前遍历到的字符；
3. 重复 1,2 ，直到左边索引无法再移动；
4. 维护一个结果 res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。

#### 关键点

1. 用一个 mapper 记录出现过并且没有被删除的字符
2. 用一个滑动窗口记录当前 index 开始的最大的不重复的字符序列
3. 用 res 去记录目前位置最大的长度，每次滑动窗口更新就去决定是否需要更新 res

```js
var lengthOfLongestSubstring = function(s) {
  const mapper = {}; // 记录已经出现过的 charactor
  let res = 0;
  let slidingWindow = [];

  for (let c of s) {
    if (mapper[c]) {
      // 已经出现过了, 则删除
      const delIndex = slidingWindow.findIndex(_c => _c === c);

      for (let i = 0; i < delIndex; i++) {
        mapper[slidingWindow[i]] = false;
      }

      slidingWindow = slidingWindow.slice(delIndex + 1).concat(c);
    } else {
      // 新字符.
      // push 函数执行之后返回数组的长度
      if (slidingWindow.push(c) > res) {
        // 记录滑动窗口的长度
        res = slidingWindow.length;
      }
    }
    mapper[c] = true;
  }
  return res;
};
```

```js
// done
var lengthOfLongestSubstring = function(s) {
  let start = 0,
    longestLength = 0;
  const map = {};
  for (let i = 0; i < s.length; i++) {
    const val = s[i];
    // = 的情况是用于连续两个相同的字符串
    if (val in map && map[val] >= start) {
      start = i + 1;
      map[val] = i;
    } else {
      map[val] = i;
      longestLength = Math.max(longestLength, i + 1 - start);
    }
  }
  console.log('map', map);

  return longestLength;
};

console.log('lengthOfLongestSubstring', lengthOfLongestSubstring('abcabcbb'));
```

```js
var lengthOfLongestSubstring = function(s) {
  let res = '';
  let l = 0;
  for (let i = 0; i < s.length; i++) {
    if (res.includes(s[i])) {
      res = res.slice(res.indexOf(s[i]) + 1);
    }
    res += s[i];
    l = Math.max(res.length, l);
  }
  return l;
};
```

```js
var lengthOfLongestSubstring = function(s) {
  var len = s.length,
    max = 0,
    chars = new Set(),
    leftBound = 0,
    ch,
    i;

  for (i = 0; i < len; i++) {
    ch = s.charAt(i);

    if (chars.has(ch)) {
      // find the repeating character
      while (leftBound < i && s.charAt(leftBound) !== ch) {
        chars.delete(s.charAt(leftBound));
        leftBound++;
      }

      leftBound++;
    } else {
      chars.add(ch);
      max = Math.max(max, i - leftBound + 1);
    }
  }

  return max;
};
```

```js
var lengthOfLongestSubstring = function(s) {
  var max = 0;
  var i = 0;
  var j = 0;
  var n = s.length;
  var map = {};

  while (i < n && j < n) {
    if (map[s[j]] === undefined) {
      map[s[j]] = 1;
      j++;
      max = Math.max(max, j - i);
    } else {
      delete map[s[i]];
      i++;
    }
  }

  return max;
};

// console.log(lengthOfLongestSubstring('c'), 1);
// console.log(lengthOfLongestSubstring(''), 0);
// console.log(lengthOfLongestSubstring('abcabcbb'), 3);
// console.log(lengthOfLongestSubstring('bbbbb'), 1);
// console.log(lengthOfLongestSubstring('pwwkew'), 3);
// console.log(lengthOfLongestSubstring('xhhyccrcbdczkvzeeubynglxfdedshtpobqsdhufkzgwuhaabdzrlkosnuxibrxssnkxuhcggkecshdvkcmymdqbxolbfjtzyfw'), 14);

var lengthOfLongestSubstring1 = function(s) {
  if (!s) return 0;
  let map = {};
  let sLen = s.length,
    max = 0,
    tempMax = 0;

  for (let i = 0; i < sLen; i++) {
    const char = s[i];
    if (!map[char]) {
      map[char] = true;
      tempMax++;
    } else {
      map = {};
      map[char] = true;
      tempMax = 1;
    }
    if (tempMax > max) {
      max = tempMax;
    }
  }

  return max;
};

console.log(lengthOfLongestSubstring1(''), 0);
console.log(lengthOfLongestSubstring1('c'), 1);
console.log(lengthOfLongestSubstring1('abcabcbb'), 3);
console.log(lengthOfLongestSubstring1('bbbbb'), 1);
console.log(lengthOfLongestSubstring1('pwwkew'), 3);
console.log(
  lengthOfLongestSubstring1(
    'xhhyccrcbdczkvzeeubynglxfdedshtpobqsdhufkzgwuhaabdzrlkosnuxibrxssnkxuhcggkecshdvkcmymdqbxolbfjtzyfw',
  ),
  14,
);
```

### [4].寻找两个有序数组的中位数 median-of-two-sorted-arrays

寻找两个有序数组的中位数

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)) 。
你可以假设 nums1 和 nums2 不会同时为空。

示例 1:
nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0

示例 2:
nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3) / 2 = 2.5

#### 实现思路

先排除空数组的情况
数组从小到大排序
取小数组的中间值
取大数组的索引 = 总中间值-小数组中间值
循环直到符合条件
如果都不符合条件，那么说明中间值在两个数组的左边或者右边

```js
//  TODO: 二分查找
//  24% 16%
var findMedianSortedArrays = function(nums1, nums2) {
  // 合并数组
  let nums = [...nums1, ...nums2];

  // 排序(有时间复杂度要求，那应该是要快排或者归并排序了)
  nums = nums.sort((a, b) => a - b);

  // 计算中位数
  const length = nums.length;
  return length % 2 === 0 ? (nums[length / 2] + nums[length / 2 - 1]) / 2 : nums[parseInt(length / 2)];
};

const swap = (arr, i, j) => {
  [arr[i], arr[j]] = [arr[j], arr[i]];
};
```

```js
// 竟然可以用这种方式。。。
function findKth(nums1, nums2, k) {
  if (nums1.length === 0) return nums2[k - 1];
  if (nums2.length === 0) return nums1[k - 1];
  if (k == 1) return Math.min(nums1[0], nums2[0]);
  let i = Math.min(k >> 1, nums1.length);
  let j = Math.min(k >> 1, nums2.length);
  if (nums1[i - 1] > nums2[j - 1]) {
    return findKth(nums1, nums2.slice(j), k - j);
  }

  return findKth(nums1.slice(i), nums2, k - i);
}

var findMedianSortedArrays = function(nums1, nums2) {
  // 1
  // 2 3 4 5
  const m = nums1.length,
    n = nums2.length;
  return (findKth(nums1, nums2, (m + n + 1) >> 1) + findKth(nums1, nums2, (m + n + 2) >> 1)) / 2.0;
};
```

```js
function kth(arr1, s1, n1, arr2, s2, n2, k) {
  // console.log(arr1, s1, n1, arr2, s2, n2, k);
  // console.log('-----------');
  if (k < 1 || k > n1 + n2) return -1;

  if (n1 > n2) {
    return kth(arr2, s2, n2, arr1, s1, n1, k);
  }

  if (n1 === 0) {
    return arr2[s2 + k - 1];
  }

  if (k === 1) {
    return arr1[s1] < arr2[s2] ? arr1[s1] : arr2[s2];
  }

  var newK = k >> 1;

  if (n1 < newK) {
    newK = n1;
  }

  if (arr1[s1 + newK - 1] < arr2[s2 + newK - 1]) {
    return kth(arr1, s1 + newK, n1 - newK, arr2, s2, n2, k - newK);
  } else {
    return kth(arr1, s1, n1, arr2, s2 + newK, n2 - newK, k - newK);
  }
}

// var arr1 = [2, 3, 6, 7, 9];
// var arr2 = [1, 4, 8, 10];
// console.log([...arr1, ...arr2].sort(function (a, b) {
//     if (a > b) return 1;
//     if (a < b) return -1;
//     return 0;
// }));
//
// console.log('=======');
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 1), 1);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 2), 2);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 3), 3);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 4), 4);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 5), 6);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 6), 7);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 7), 8);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 8), 9);
// console.log(kth(arr1, 0, 5, arr2, 0, 4, 9), 10);

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  var n1 = nums1.length;
  var n2 = nums2.length;

  var mid = Math.floor((n1 + n2) / 2);
  if ((n1 + n2) % 2 === 0) {
    return (kth(nums1, 0, n1, nums2, 0, n2, mid) + kth(nums1, 0, n1, nums2, 0, n2, mid + 1)) / 2;
  } else {
    return kth(nums1, 0, n1, nums2, 0, n2, mid + 1);
  }
};

console.log(findMedianSortedArrays([1, 3, 4], [2, 5]));
console.log(findMedianSortedArrays([1, 3, 4], [2, 5, 6]));
```

```js
var findMedianSortedArrays = function(nums1, nums2) {
  if (nums1.length == 0 || nums2.length == 0) {
    if ((nums1.length + nums2.length) % 2 == 1) {
      const index = parseInt((nums1.length + nums2.length) / 2);
      return nums2.length == 0 ? nums1[index] : nums2[index];
    } else {
      let nums = nums2.length == 0 ? nums1 : nums2;
      const index = nums.length / 2;
      return (nums[index - 1] + nums[index]) / 2;
    }
  }

  if (nums1.length > nums2.length) {
    swap(nums1, nums2);
  }
  const M = nums1.length,
    N = nums2.length;
  let min = 0,
    max = M,
    half = parseInt((M + N + 1) / 2); // 连个数组合并的中间值
  while (min <= max) {
    let i = parseInt((min + max) / 2); // nums1 的索引值
    let j = half - i; // num2 的索引值
    if (i < max && nums2[j - 1] > nums1[i]) {
      min++;
    } else if (i > min && nums1[i - 1] > nums2[j]) {
      max--;
    } else {
      let maxLeft = 0;
      if (i == 0) {
        maxLeft = nums2[j - 1];
      } else if (j == 0) {
        maxLeft = nums1[i - 1];
      } else {
        maxLeft = Math.max(nums1[i - 1], nums2[j - 1]);
      }
      if ((M + N) % 2 == 1) {
        return maxLeft;
      }
      let minRight = 0;
      if (i == M) {
        minRight = nums2[j];
      } else if (j == N) {
        minRight = nums1[i];
      } else {
        minRight = Math.min(nums1[i], nums2[j]);
      }
      return (maxLeft + minRight) / 2;
    }
  }
  return 0;
};

function swap(a, b) {
  let tmp = a;
  a = b;
  b = tmp;
}

const nums1 = [4, 5];
const nums2 = [1, 2, 3];
findMedianSortedArrays(nums1, nums2);
```

### [5].最长回文子串 longest-palindromic-substring

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"

#### 思路

解决这类问题的核心思想就是两个字 “延伸”（extend），具体来说

- 如果一个字符串是回文串，那么在它左右分别加上一个相同的字符，那么它一定还是一个回文串
- 如果一个字符串不是回文串，或者在回文串左右分别加不同的字符，得到的一定不是回文串

事实上，上面的分析已经建立了大问题和小问题之间的关联，
基于此，我们可以建立动态规划模型。

我们可以用 `dp[i][j]` 表示 s 中从 i 到 j(包括 i 和 j)是否可以形成回文，状态转移方程只是将上面的描述转化为代码即可：

```js
// 左右分别加 1
if (s[i] === s[j] && dp[i + 1][j - 1]) {
  dp[i][j] = true;
}
```

base case 就是一个字符(轴对称点是本身)，或者两个字符(轴对称点是介于两者之间的虚拟点)。

#### 代码

```js
// done
var longestPalindrome = function(s) {
  if (!s || s.length === 0) return '';
  let res = s[0];
  const dp = [];

  // 倒着遍历简化操作， 这么做的原因是 dp[i][..] 依赖于 dp[i + 1][..]
  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = [];
    for (let j = i; j < s.length; j++) {
      // 同一位字符串 必然 true
      if (j - i === 0) dp[i][j] = true;
      // special case 1: 相邻两位字符串相同，或者 ABA 形式的字符串都是回文串
      else if (j - i < 3 && s[i] === s[j]) dp[i][j] = true;
      // special case 2
      else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        // state transition
        dp[i][j] = true;
      }

      if (dp[i][j] && j - i + 1 > res.length) {
        // update res
        res = s.slice(i, j + 1);
      }
    }
  }
  return res;
};
```

```js
// 滑动窗口思想 ？
var longestPalindrome = function(str) {
  const n = str.length;
  if (n < 2) return str;
  let s = 0,
    e = 0;
  // 表示子串是否是回文串
  let dp = [0];
  for (let j = 0; j < n; ++j) {
    for (let i = 0; i < j; ++i) {
      if (!(dp[i] = dp[i + 1] || str[i] != str[j]) && e - s <= j - i) {
        (s = i)((e = j));
      }
    }
  }
  return str.substr(s, e - s + 1);
};
```

```js
var longestPalindrome = function(s) {
  var len = s.length,
    isPal = [],
    max = 1,
    start = 0,
    end = 0,
    i,
    j;

  for (i = 0; i < len; i++) {
    isPal.push(new Array(len));
    isPal[i][i] = true;
  }

  for (i = len - 1; i >= 0; i--) {
    for (j = i + 1; j < len; j++) {
      if (s.charAt(i) === s.charAt(j) && (j === i + 1 || isPal[i + 1][j - 1])) {
        isPal[i][j] = true;

        if (j - i + 1 > max) {
          start = i;
          end = j;
          max = j - i + 1;
        }
      }
    }
  }

  return s.substring(start, end + 1);
};
```

用 `dp[i][j]` 表示子串 i 到 j 是否是回文，使用动态规划求解：

```js
var longestPalindromeSubstring = function(s) {
  var n = s.length;
  var res = '';
  var dp = [];
  // 默认全赋值 -1
  while (dp.push(new Array(n).fill(-1)) < n);
  console.log(dp);

  // 反过来循环，是因为 dp[i][j] 依赖 dp[i + 1][j]
  for (var i = n - 1; i >= 0; i--) {
    for (var j = i; j < n; j++) {
      // j - i < 3 也就是说只考虑，3 次循环 ??
      dp[i][j] = s[i] === s[j] && (j - i < 3 || dp[i + 1][j - 1]);
      if (dp[i][j] === undefined) {
        console.log(i, j, s[i], s[j], dp[i + 1][j - 1]);
      }
      // 如果是回文，才进行截取
      if (dp[i][j]) {
        var tmp = s.substring(i, j + 1);
        if (tmp.length > res.length) res = tmp;
      }
    }
  }
  return res;
};

console.log('longestPalindromeSubstring', longestPalindromeSubstring('babad'));
console.log('longestPalindromeSubstring', longestPalindromeSubstring(''));
console.log('longestPalindromeSubstring', longestPalindromeSubstring('a'));
console.log('longestPalindromeSubstring', longestPalindromeSubstring('aabbbbbb'));
```

### [10].正则表达式匹配 Regular-Expression-Matching

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  let dp = [];
  for (let i = 0; i <= s.length; i++) {
    let child = [];
    for (let j = 0; j <= p.length; j++) {
      child.push(false);
    }
    dp.push(child);
  }
  dp[s.length][p.length] = true;

  for (let i = s.length; i >= 0; i--) {
    for (let j = p.length - 1; j >= 0; j--) {
      let first_match = i < s.length && (p[j] == s[i] || p[j] == '.');
      if (j + 1 < p.length && p[j + 1] == '*') {
        dp[i][j] = dp[i][j + 2] || (first_match && dp[i + 1][j]);
      } else {
        dp[i][j] = first_match && dp[i + 1][j + 1];
      }
    }
  }
  console.log(dp);
  return dp[0][0];
};

console.log(isMatch('aab', 'c*a*b'));

/**
先设定右下角为 false

[
    true, false, true, false, false, false,
    true, false, true, false, false, false,
    true, false, true, false, true, false,
    false, false, false, false, false, true
]
 */
```

### [11].盛最多水的容器 Container-With-Most-Water

#### 思路

符合直觉的解法是，我们可以对两两进行求解，计算可以承载的水量。 然后不断更新最大值，最后返回最大值即可。
这种解法，需要两层循环，时间复杂度是 O(n^2)

eg:

```js
// 这个解法比较暴力，效率比较低
// 时间复杂度是O(n^2)
let max = 0;
for (let i = 0; i < height.length; i++) {
  for (let j = i + 1; j < height.length; j++) {
    const currentArea = Math.abs(i - j) * Math.min(height[i], height[j]);
    if (currentArea > max) {
      max = currentArea;
    }
  }
}
return max;
```

> 这种符合直觉的解法有点像冒泡排序， 大家可以稍微类比一下

那么有没有更加优的解法呢？我们来换个角度来思考这个问题，上述的解法是通过两两组合，这无疑是完备的，
那我门是否可以先计算长度为 n 的面积，然后计算长度为 n-1 的面积，... 计算长度为 1 的面积。 这样去不断更新最大值呢？
很显然这种解法也是完备的，但是似乎时间复杂度还是 O(n ^ 2), 不要着急。

考虑一下，如果我们计算 n-1 长度的面积的时候,是直接直接排除一半的结果的。

如图：

比如我们计算 n 面积的时候，假如左侧的线段高度比右侧的高度低，那么我们通过左移右指针来将长度缩短为 n-1 的做法是没有意义的，
因为`新的形成的面积变成了(n-1) * heightOfLeft 这个面积一定比刚才的长度为n的面积nn * heightOfLeft 小`

也就是说最大面积`一定是当前的面积或者通过移动短的线段得到`。

#### 关键点解析

- 双指针优化时间复杂度

#### 代码

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  if (!height || height.length <= 1) return 0;

  // 双指针来进行优化
  // 时间复杂度是O(n)
  let leftPos = 0;
  let rightPos = height.length - 1;
  let max = 0;
  while (leftPos < rightPos) {
    const currentArea = Math.abs(leftPos - rightPos) * Math.min(height[leftPos], height[rightPos]);
    if (currentArea > max) {
      max = currentArea;
    }
    // 更新小的
    if (height[leftPos] < height[rightPos]) {
      leftPos++;
    } else {
      // 如果相等就随便了
      rightPos--;
    }
  }

  return max;
};
```

```js
var maxArea = function(height) {
  var len = height.length,
    left = 0,
    right = len - 1,
    max = 0;

  while (left < right) {
    max = Math.max(max, (right - left) * Math.min(height[left], height[right]));

    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return max;
};
```

```js
/**
 * @param {number[]} height
 * @return {number}
 */
export default function maxArea(height) {
  let width = height.length - 1;
  let lo = 0;
  let hi = height.length - 1;
  let max = 0;
  while (lo < hi) {
    const loVal = height[lo];
    const hiVal = height[hi];
    max = Math.max(max, width * Math.min(hiVal, loVal));
    if (loVal < hiVal) {
      lo++;
    } else {
      hi--;
    }
    width--;
  }
  return max;
}
```

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  let maxArea = 0;
  let left = 0,
    right = height.length - 1;
  while (left < right) {
    maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return maxArea;
};

const arr = [3, 4, 6, 2, 8, 4, 3, 1, 3, 4, 4];
console.log(maxArea(arr));
```

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var dp = [0];
  var max = 0;
  for (var i = 1; i < height.length; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      var v = (i - j) * Math.min(height[i], height[j]);
      dp[i] = Math.max(dp[i], v);
    }
    max = Math.max(max, dp[i]);
  }
  // console.log(dp, max);
  return max;
};

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var i = 0;
  var j = height.length - 1;
  var max = 0;
  while (i < j) {
    max = Math.max(max, Math.min(height[i], height[j]) * (j - i));
    if (height[i] < height[j]) i++;
    else j--;
  }
  return max;
};

console.log(maxArea([3, 5, 1, 9]));
```

### [14].最长公共前缀 Longest-Common-Prefix

```js
var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  if (strs.length === 1) return strs[0];
  const first = strs[0];
  for (let i = 0; i < first.length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[j][i] !== strs[0][i]) return strs[0].slice(0, i);
    }
  }
  return first;
};

console.log(longestCommonPrefix(['flower', 'flow', 'flight']));
console.log(longestCommonPrefix(['dog', 'racecar', 'car']));
console.log(longestCommonPrefix(['c', 'c']));
```

```js
var longestCommonPrefix = function(strs) {
  if (!strs.length || !strs[0].length) return '';
  let res = '';
  for (let i = 0; i < strs[0].length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[0][i] !== strs[j][i]) {
        return res;
      }
    }
    res += strs[0][i];
  }
  return res;
};
```

```js
export default function detectCycle(head) {
  let i = 0;
  const map = new Map();
  if (!head) return null;
  let curr = head;
  while (curr && curr.next) {
    map.set(curr, i);
    curr = curr.next;
    if (map.has(curr)) return curr;
    i++;
  }
  return null;
}
```

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
  let ans = strs.length > 0 ? strs[0] : '';
  for (let i = 1; i < strs.length; i++) {
    if (!strs[i].startsWith(ans)) {
      for (let j = 0; j < ans.length; j++) {
        if (ans[j] != strs[i][j]) {
          ans = ans.slice(0, j);
        }
      }
    }
  }
  return ans;
};
```

### [15].三数之和 3Sum

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：

```js
[
  [-1, 0, 1],
  [-1, -1, 2],
];
```

#### 思路

我们采用`分治`的思想. 想要找出三个数相加等于 0，我们可以数组依次遍历，
每一项 a[i]我们都认为它是最终能够用组成 0 中的一个数字，那么我们的目标就是找到
剩下的元素(除 a[i])`两个`相加等于-a[i].

通过上面的思路，我们的问题转化为了`给定一个数组，找出其中两个相加等于给定值`，
这个问题是比较简单的， 我们只需要对数组进行排序，然后双指针解决即可。 加上我们需要外层遍历依次数组，因此总的时间复杂度应该是 O(N^2)。

思路如图所示：

> 在这里之所以要排序解决是因为， 我们算法的瓶颈在这里不在于排序，而在于 O(N^2)，如果我们瓶颈是排序，就可以考虑别的方式了

> 如果找某一个特定元素，一个指针就够了。如果是找两个元素满足一定关系(比如求和等于特定值)，需要双指针，
> 当然前提是数组有序。

#### 关键点解析

- 排序之后，用双指针
- 分治

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  if (nums.length < 3) return [];
  const list = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    // skip duplicated result without set
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let left = i;
    let right = nums.length - 1;

    // for each index i
    // we want to find the triplet [i, left, right] which sum to 0
    while (left < right) {
      // skip i === left or i === right, in that case, the index i will be used twice
      if (left === i) {
        left++;
      } else if (right === i) {
        right--;
      } else if (nums[left] + nums[right] + nums[i] === 0) {
        list.push([nums[left], nums[right], nums[i]]);
        // skip duplicated result without set
        while (nums[left] === nums[left + 1]) {
          left++;
        }
        left++;
        // skip duplicated result without set
        while (nums[right] === nums[right - 1]) {
          right--;
        }
        right--;
        continue;
      } else if (nums[left] + nums[right] + nums[i] > 0) {
        right--;
      } else {
        left++;
      }
    }
  }
  return list;
};
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const sum = nums[i] + nums[j];
      const bs = binarySearch(nums, -sum, 0, nums.length - 1);
      if (bs != null && bs != i && bs != j) {
        let mArr = [nums[i], nums[j], nums[bs]].sort(function(a, b) {
          return a - b;
        });
        if (!has(ans, mArr)) {
          ans.push(mArr);
        }
      }
    }
  }
  return ans;
};

function binarySearch(arr, val, lo, hi) {
  if (lo > hi) return null;
  let mid = lo + parseInt((hi - lo) / 2);
  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

function has(arr, target) {
  for (let cur of arr) {
    let isEqual = true;
    for (let i = 0; i < target.length; i++) {
      if (cur[i] != target[i]) {
        isEqual = false;
      }
    }
    if (isEqual) return true;
  }
  return false;
}

// console.log(threeSum([-1, 0, 1, 2, -1, -4]))

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum2 = function(nums) {
  nums.sort(function(a, b) {
    return a - b;
  });
  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) {
      continue;
    }
    let j = i + 1,
      k = nums.length - 1;
    let target = -nums[i];
    while (j < k) {
      if (nums[j] + nums[k] == target) {
        ans.push([nums[i], nums[j], nums[k]]);
        j++;
        k--;
        while (j < k && nums[j] == nums[j - 1]) j++;
        while (j < k && nums[k] == nums[k + 1]) k--;
      } else if (nums[j] + nums[k] > target) {
        k--;
      } else {
        j++;
      }
    }
  }
  return ans;
};

console.log(threeSum2([-2, 0, 0, 2, 2]));
```

```js
var threeSum = function(nums) {
  nums.sort(function(a, b) {
    if (a > b) return 1;
    if (a === b) return 0;
    if (a < b) return -1;
  });
  // console.log(nums);
  var ret = [];
  for (var i = 0; i < nums.length - 2; i++) {
    var a = nums[i];
    if (i === 0 || (i > 0 && nums[i] !== nums[i - 1])) {
      var j = i + 1;
      var k = nums.length - 1;
      while (j < k) {
        var b = nums[j];
        var c = nums[k];

        var sum = a + b + c;

        // console.log(a, b, c, '=', sum);
        if (sum > 0) k--;
        else if (sum === 0) {
          ret.push([a, b, c]);
          while (j < k && nums[j] === nums[++j]);
          while (j < k && nums[k] === nums[--k]);
          // j++;
          // k--;
        } else j++;
      }
    }
  }
  return ret;
};

console.log(threeSum([-2, 0, 0, 2, 2]));
console.log(threeSum([-1, 0, 1, 2, -1, -4]));
// console.log(threeSum([0, 0, 0, 0]));
// console.log(threeSum([1, -1, -1, 0]));
```

```js
var threeSum = function(nums) {
  // 转化成两数之和
  const result = [];
  for (let i = 0; i < nums.length - 2; i++) {
    const target = -nums[i];
    const res = twoSum(nums, target) || [];

    res.forEach(element => {
      if (element && !element.includes(i)) {
        result.push([nums[i], nums[element[0]], nums[element[1]]]);
      }
    });
  }
  // 返回结果之前先去重，比如 [0,1] 和 [1, 0]
  const cached1 = {};
  const temp = result.filter(res => {
    const key = JSON.stringify(res.sort());
    if (!cached1[key]) {
      cached1[key] = true;
      return true;
    }
  });
  return temp;
};

var twoSum = function(nums, target) {
  if (nums && nums.length < 2) return;
  let result = [];
  for (let i = 0; i < nums.length; i++) {
    const val = target - nums[i];
    const index = nums.indexOf(val);
    if (i !== index && index !== -1) {
      result.push([i, index]);
    }
  }
  // 返回结果之前先去重，比如 [0,1] 和 [1, 0]
  const cached = {};
  const temp = result.filter(res => {
    const key = JSON.stringify(res.sort());
    if (!cached[key]) {
      cached[key] = true;
      return true;
    }
  });
  return temp;
};

// let nums = [-1, 0, 1, 2, -1, -4]
// console.log(threeSum(nums))
// nums = [-1, 0, 1, 2, -1, -4]
// console.log(threeSum(nums))

nums = [0, 0, 0];
console.log(threeSum(nums));
//  [[-1,-1,2],[-1,0,1]]
```

### [17].电话号码的字母组合 DONE

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

```js
// 执行用时 98.90% 内存消耗 44.83%

function gen(digits = [], result = [], map) {
  if (!digits) return [];
  if (digits.length === 1) return map[digits];
  const [first, ...rest] = digits;
  result = gen(rest, result, map);
  return map[first]
    .map(digit => {
      return result.map(dig => `${digit}${dig}`);
    })
    .flat(Infinity);
}

// 执行用时 87.% 内存消耗 80%
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  const map = {
    '2': ['a', 'b', 'c'],
    '3': ['d', 'e', 'f'],
    '4': ['g', 'h', 'i'],
    '5': ['j', 'k', 'l'],
    '6': ['m', 'n', 'o'],
    '7': ['p', 'q', 'r', 's'],
    '8': ['t', 'u', 'v'],
    '9': ['w', 'x', 'y', 'z'],
  };
  return gen(digits, [], map);
};

console.log(letterCombinations('23'));
console.log(letterCombinations('234'));
```

### [19].Remove-Nth-Node-From-End-of-List

```js
/**
 * https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/
 * Difficulty:Medium
 *
 * Given a linked list, remove the nth node from the end of list and return its head.
 *
 * For example,
 *  Given linked list: 1->2->3->4->5, and n = [2].
 *  After removing the second node from the end, the linked list becomes 1->2->3->[5].
 *
 * Note:
 *  Given n will always be valid.
 *  Try to do this in one pass.
 *
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  if (!head) return head;
  var len = 0;
  var tail = head;
  while (tail) {
    tail = tail.next;
    len++;
  }
  if (len === n) {
    return head.next;
  }

  len = len - n - 1;
  tail = head;
  while (len) {
    tail = tail.next;
    len--;
  }
  tail.next = tail.next.next;
  return head;
};

var a = new ListNode(1);
var b = new ListNode(2);
var c = new ListNode(3);
var d = new ListNode(4);
// var e = new ListNode(5);
a.next = b;
b.next = c;
c.next = d;
// d.next = e;

console.log(removeNthFromEnd(a, 2));
```

#### 思路

双指针，指针 A 先移动 n 次， 指针 B 再开始移动。当 A 到达 null 的时候， 指针 b 的位置正好是倒数 n

我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。

设置虚拟节点 dummyHead 指向 head

设定双指针 p 和 q，初始都指向虚拟节点 dummyHead

移动 q，直到 p 与 q 之间相隔的元素个数为 n

同时移动 p 与 q，直到 q 指向的为 NULL

将 p 的下一个节点指向下下个节点

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

1. 链表这种数据结构的特点和使用

2. 使用双指针

3. 使用一个 dummyHead 简化操作

#### 代码

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let i = -1;
  const noop = {
    next: null,
  };

  const dummyHead = new ListNode(); // 增加一个dummyHead 简化操作
  dummyHead.next = head;

  let currentP1 = dummyHead;
  let currentP2 = dummyHead;

  while (currentP1) {
    if (i === n) {
      currentP2 = currentP2.next;
    }

    if (i !== n) {
      i++;
    }

    currentP1 = currentP1.next;
  }

  currentP2.next = ((currentP2 || noop).next || noop).next;

  return dummyHead.next;
};
```

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let dummy = new ListNode(0);
  dummy.next = head;
  let first = dummy;
  let second = dummy;
  for (let i = 1; i <= n + 1; i++) {
    first = first.next;
  }
  while (first != null) {
    first = first.next;
    second = second.next;
  }
  second.next = second.next.next;
  return dummy.next;
};

// if (head.next == null) return null
// let fast = head.next, slow = head
// let i = 1
// while (i < n) {
//     if (fast.next) {
//         fast = fast.next
//     }
//     i++
// }
// if (fast.next) {
//     if (fast.next.next) fast.next = fast.next.next
//     else fast.next = null
// }
// return head
```

### [20].有效的括号 validParentheses DONE

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true

#### 思路

使用栈, 遍历输入字符串, 如果当前字符为左半边括号时，则将其压入栈中, 如果遇到右半边括号时，分类讨论：

1. 如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环
2. 若此时栈为空，则直接返回 false
3. 若不为对应的左半边括号，反之返回 false

#### 代码

```js
var isValid = function(s) {
  let valid = true;
  const stack = [];
  const mapper = {
    '{': '}',
    '[': ']',
    '(': ')',
  };

  for (let i in s) {
    const v = s[i];
    if (['(', '[', '{'].indexOf(v) > -1) {
      stack.push(v);
    } else {
      const peak = stack.pop();
      if (v !== mapper[peak]) {
        return false;
      }
    }
  }

  if (stack.length > 0) return false;

  return valid;
};
```

```js
// 最高赞
var isValid = function(s) {
  var st = [];
  for (var l of s)
    if ((i = '({[]})'.indexOf(l)) > -1)
      if (st[st.length - 1] + i === 5)
        // 相加为 5 则意味着匹配上了。 另 length-- 操作直接删除了顶部元素
        st.length--;
      else st.push(i);
  return st.length === 0;
};
```

```js
console.log(isValid('()[]{}'));
console.log(isValid('[()][]{}'));
console.log(isValid('(])'));
```

### [21].合并两个有序链表 merge-two-sorted-lists

Merge two sorted linked lists and return it as a new list. The new list should be
made by splicing together the nodes of the first two lists.

Example:
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
export default function mergeTwoLists(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;
  let head = l1.val < l2.val ? l1 : l2;
  const first = head;
  let other = l1.val < l2.val ? l2 : l1;

  while (head && other) {
    if (!head.next) {
      head.next = other;
      break;
    } else if (head.next.val <= other.val) {
      head = head.next;
    } else {
      const dummy = head.next;
      head.next = other;
      other = dummy;
      head = head.next;
    }
  }

  return first;
}
```

```js
// l1 l2 只是两个引用
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  // 需要 return 的是头节点的引用， current 指针会移动
  const dummy = current;

  // 需要循环到两个链表节点都为空
  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  // dummy 是一个空的头节点，还是需要反馈开头的第一个节点
  return dummy.next;
};

var newMergeTwoLists = function(l1, l2) {
  if (l1 === null) return l2;
  if (l2 === null) return l1;
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

let l1 = List([1, 2, 4]);
ListToString.call(l1);

let l2 = List([1, 3, 4]);
ListToString.call(l2);

const mergeTwoLists1 = (l1, l2) => {
  let current = new ListNode();
  const guard = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return guard.next;
    }
    if (!l2) {
      current.next = l1;
      return guard.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    // 移动节点
    current = current.next;
  }
  return guard.next;
};

let l3 = mergeTwoLists1(l1, l2);
ListToString.call(l3);
```

```js
/*
 * @lc app=leetcode.cn id=21 lang=javascript
 *
 * [21] 合并两个有序链表
 * 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
 * 输入：1->2->4, 1->3->4
 * 输出：1->1->2->3->4->4
 */

/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  const bool = l1.val <= l2.val,
    l3 = new ListNode(bool ? l1.val : l2.val),
    current = l3;
  if (bool) {
    l1 = l1.next;
  } else {
    l2 = l2.next;
  }
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      current.next = l1;
      current = current.next;
      l1 = l1.next;
    } else {
      current.next = l2;
      current = current.next;
      l2 = l1.next;
    }
  }

  if (l1) {
  }

  return current;
};

function List(arr) {
  let current = new ListNode();
  const guard = current;
  for (let i = 0; i < arr.length; i++) {
    current.next = new ListNode(arr[i]);
  }

  return guard.next;
}

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let current = new ListNode(),
    dummy = current;
  for (let i = 0; i < arr.length; i++) {
    const temp = new ListNode(arr[i]);
    current.next = temp;
    current = current.next;
  }
  return dummy.next;
}

function ListToString() {
  let resp = '';
  let current = this;
  while (current.next) {
    resp += current.val + '->';
    current = current.next;
  }
  resp += current.val;
  console.log('toString: ', resp);
}

const l1 = List([1, 1, 2]),
  l2 = List([1, 1, 2, 3, 3]);
ListToString.call(l1);
ListToString.call(l2);
```

```js
/**
 * https://leetcode.com/problems/merge-two-sorted-lists/description/
 * Difficulty:Easy
 *
 * Merge two sorted linked lists and return it as a new list.
 * The new list should be made by splicing together the nodes of the first two lists.
 *
 * Example:
 * Input: 1->2->4, 1->3->4
 * Output: 1->1->2->3->4->4
 */

// Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 *
 * non-recursion
 *
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;

  var n = new ListNode(0);
  var t = n;

  while (l1 && l2) {
    if (l1.val <= l2.val) {
      n.next = l1;
      l1 = l1.next;
    } else {
      n.next = l2;
      l2 = l2.next;
    }
    n = n.next;
  }
  if (l1) n.next = l1;
  if (l2) n.next = l2;

  return t.next;
};

/**
 *
 * recursion
 *
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;

  if (l1.val <= l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;

  //   if (l1 === null) return l2;
  //   if (l2 === null) return l1;
  //   if (l1.val < l2.val) {
  //     l1.next = mergeTwoLists(l1.next, l2);
  //     return l1;
  //   } else {
  //     l2.next = mergeTwoLists(l1, l2.next);
  //     return l2;
  //   }
};
```

### [22].Generate-Parentheses

```js
/**
 * https://leetcode.com/problems/generate-parentheses/description/
 * Difficulty:Medium
 *
 * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
 * For example, given n = 3, a solution set is:
 * [
 *   "((()))",
 *   "(()())",
 *   "(())()",
 *   "()(())",
 *   "()()()"
 * ]
 */

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  var ans = [];
  helper(ans, '', 0, 0, n);
  return ans;
};

function helper(ans, str, left, right, n) {
  if (right === n) ans.push(str);
  if (left < n) {
    helper(ans, str + '(', left + 1, right, n);
  }
  if (right < left) {
    helper(ans, str + ')', left, right + 1, n);
  }
}

console.log(generateParenthesis(3));
```

```js
let result = [];

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  dfs(n, 1, 1, '(');
  return result;
};

function dfs(n, sum, used, s) {
  if (s.length == 2 * n) {
    result.push(s);
    return;
  }
  if (sum == 0) {
    dfs(n, sum + 1, used + 1, s + '(');
  } else if (sum == n || used == n) {
    dfs(n, sum - 1, used, s + ')');
  } else {
    dfs(n, sum + 1, used + 1, s + '(');
    dfs(n, sum - 1, used, s + ')');
  }
}

generateParenthesis(3);
```

### [23].merge-k-sorted-lists

```
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```

#### 思路

这道题目是合并 k 个已排序的链表，号称 leetcode 目前`最难`的链表题。 和
他们有两点区别：

1. 这道题的数据结构是链表，那道是数组。这个其实不复杂，毕竟都是线性的数据结构。

2. 这道题需要合并 k 个元素，那道则只需要合并两个。这个是两题的关键差别，也是这道题难度为`hard`的原因。

因此我们可以看出，这道题目是`88.merge-sorted-array`的进阶版本。其实思路也有点像，我们来具体分析下第二条。
如果你熟悉合并排序的话，你会发现它就是`合并排序的一部分`。

具体我们可以来看一个动画

(动画来自 https://zhuanlan.zhihu.com/p/61796021)

#### 关键点解析

- 分治
- 合并排序(merge sort)

#### 代码

```js
/*
 * @lc app=leetcode id=23 lang=javascript
 *
 * [23] Merge k Sorted Lists
 *
 * https://leetcode.com/problems/merge-k-sorted-lists/description/
 *
 * algorithms
 * Hard (33.14%)
 * Total Accepted:    373.7K
 * Total Submissions: 1.1M
 * Testcase Example:  '[[1,4,5],[1,3,4],[2,6]]'
 *
 * Merge k sorted linked lists and return it as one sorted list. Analyze and
 * describe its complexity.
 *
 * Example:
 *
 *
 * Input:
 * [
 * 1->4->5,
 * 1->3->4,
 * 2->6
 * ]
 * Output: 1->1->2->3->4->4->5->6
 *
 *
 */
function mergeTwoLists(l1, l2) {
  const dummyHead = {};
  let current = dummyHead;
  // l1: 1 -> 3 -> 5
  // l2: 2 -> 4 -> 6
  while (l1 !== null && l2 !== null) {
    if (l1.val < l2.val) {
      current.next = l1; // 把小的添加到结果链表
      current = current.next; // 移动结果链表的指针
      l1 = l1.next; // 移动小的那个链表的指针
    } else {
      current.next = l2;
      current = current.next;
      l2 = l2.next;
    }
  }

  if (l1 === null) {
    current.next = l2;
  } else {
    current.next = l1;
  }
  return dummyHead.next;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  // 图参考： https://zhuanlan.zhihu.com/p/61796021
  if (lists.length === 0) return null;
  if (lists.length === 1) return lists[0];
  if (lists.length === 2) {
    return mergeTwoLists(lists[0], lists[1]);
  }

  const mid = lists.length >> 1;
  const l1 = [];
  for (let i = 0; i < mid; i++) {
    l1[i] = lists[i];
  }

  const l2 = [];
  for (let i = mid, j = 0; i < lists.length; i++, j++) {
    l2[j] = lists[i];
  }

  return mergeTwoLists(mergeKLists(l1), mergeKLists(l2));
};
```

```js
/**
 * https://leetcode.com/problems/merge-k-sorted-lists/description/
 * Difficulty:Hard
 *
 * Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
 */

//Definition for singly-linked list.
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  return lists.reduce((a, b) => merge2lists(a, b), null);
};

function merge2lists(a, b) {
  if (!a && !b) return null;
  if (!a) return b;
  if (!b) return a;
  var h;
  if (a.val < b.val) {
    h = a;
    a = a.next;
  } else {
    h = b;
    b = b.next;
  }
  var t = h;

  while (a && b) {
    if (a.val < b.val) {
      t.next = a;
      t = t.next;
      a = a.next;
    } else {
      t.next = b;
      t = t.next;
      b = b.next;
    }
  }
  if (a) t.next = a;
  if (b) t.next = b;
  return h;
}

var a = {
  val: 1,
  next: {
    val: 4,
    next: {
      val: 7,
      next: null,
    },
  },
};
var b = {
  val: 2,
  next: {
    val: 8,
    next: {
      val: 9,
      next: null,
    },
  },
};

var c = {
  val: 3,
  next: {
    val: 10,
    next: null,
  },
};

// console.log(merge2lists(a, b));
console.log(mergeKLists([a, b, c]));
```

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}

/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  return partion(lists, 0, list.length - 1);
};

function partion(lists, s, e) {
  // 开始 == 结束，说明合并完成。
  if (s == e) return lists[s];
  if (s < e) {
    // 分一半计算
    let q = parseInt((s + e) / 2);
    // 前半部分
    let l1 = partion(lists, s, q);
    // 后半部分
    let l2 = partion(lists, q + 1, e);
    // 合并两个链表
    return merge(l1, l2);
  } else return null;
}

function mergeTwoLists(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

### [30].串联所有单词的子串

```js
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  const result = [];
  // [1]. 算出子串
  const sub = getSubStr(words);
  console.log(sub);
  for (let i = 0; i < sub.length; i++) {
    const index = s.indexOf(sub[i]);
    if (index !== -1) {
      result.push(index);
    }
  }
  return result;
};

function getSubStr(arr) {
  if (arr.length < 2) return arr;
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const sub = getSubStr(arr.slice(1));
    for (let j = 0; j < sub.length; j++) {
      if (i !== j) {
        result.push(`${arr[i]}${sub[j]}`);
      }
    }
  }
  return result;
}

console.log(findSubstring('barfoothefoobarman', ['foo', 'bar']));
console.log(findSubstring('wordgoodgoodgoodbestword', ['word', 'good', 'best', 'word']));
```

### [31].next-permutation

```
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```

#### 思路

符合直觉的方法是我们按顺序求出所有的排列，如果当前排列等于 nums，那么我直接取下一个
但是这种做法不符合 constant space 要求(题目要求直接修改原数组),时间复杂度也太高，为 O(n!),肯定不是合适的解。

这种题目比较抽象，写几个例子通常会帮助理解问题的规律。我找了几个例子，其中蓝色背景表示的是当前数字找下一个更大排列的时候`需要改变的元素`.

我们不难发现，蓝色的数字都是从后往前第一个不递增的元素，并且我们的下一个更大的排列
只需要改变蓝色的以及之后部分即可，前面的不需要变。

那么怎么改变蓝色的以及后面部分呢？为了使增量最小，
由于前面我们观察发现，其实剩下的元素从左到右是递减的，而我们想要变成递增的，我们只需要不断交换首尾元素即可。

另外我们也可以以回溯的角度来思考这个问题，让我们先回溯一次：

这个时候可以选择的元素只有 2，我们无法组成更大的排列，我们继续回溯，直到如图：

我们发现我们可以交换 4 或者 2 实现变大的效果，但是要保证变大的幅度最小(下一个更大)，
我们需要选择最小的，由于之前我们发现后面是从左到右递减的，显然就是交换最右面大于 1 的。

之后就是不断交换使之幅度最小：

#### 关键点解析

- 写几个例子通常会帮助理解问题的规律
- 在有序数组中首尾指针不断交换位置即可实现 reverse
- 找到从右边起`第一个大于nums[i]的`，并将其和 nums[i]进行交换

#### 代码

```js
function reverseRange(A, i, j) {
  while (i < j) {
    const temp = A[i];
    A[i] = A[j];
    A[j] = temp;
    i++;
    j--;
  }
}
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  // 时间复杂度O(n) 空间复杂度O(1)
  if (nums == null || nums.length <= 1) return;

  let i = nums.length - 2;
  // 从后往前找到第一个降序的,相当于找到了我们的回溯点
  while (i > -1 && nums[i + 1] <= nums[i]) i--;

  // 如果找了就swap
  if (i > -1) {
    let j = nums.length - 1;
    // 找到从右边起第一个大于nums[i]的，并将其和nums[i]进行交换
    // 因为如果交换的数字比nums[i]还要小肯定不符合题意
    while (nums[j] <= nums[i]) j--;
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }

  // 最后我们只需要将剩下的元素从左到右，依次填入当前最小的元素就可以保证是大于当前排列的最小值了
  // [i + 1, A.length -1]的元素进行反转

  reverseRange(nums, i + 1, nums.length - 1);
};
```

```js
var nextPermutation = function(nums) {
  if (nums.length < 2) return;
  var peak = nums.length - 1;
  for (var i = peak - 1; nums[i] >= nums[peak]; peak = i--);

  if (peak !== 0) {
    var swapIndex = findSwap(nums, peak, nums.length - 1, peak - 1);
    if (swapIndex !== -1) {
      swap(nums, peak - 1, swapIndex);
    }
  }

  reverse(nums, peak, nums.length - 1);
};

function findSwap(nums, s, e, target) {
  for (var i = e; i >= s; i--) {
    if (nums[i] > nums[target]) return i;
  }
  return -1;
}

function swap(nums, s, e) {
  var t = nums[s];
  nums[s] = nums[e];
  nums[e] = t;
}
function reverse(nums, s, e) {
  // var len = e - s;
  for (var i = 0; i < Math.ceil((e - s) / 2); i++) {
    swap(nums, s + i, e - i);
  }
  // return nums;
}

// console.log(reverse([1, 2, 3, 4, 5], 0, 4));
// console.log(reverse([1, 2, 3, 4, 5], 3, 4));
// console.log(reverse([1, 2, 3, 4, 5], 2, 3));
// console.log(reverse([1, 2, 3, 4, 5], 1, 1));
// console.log(reverse([1, 2, 3, 4, 5], 1, 4));

// var nums = [1, 2, 5, 4, 3];
// console.log(nums);
// nextPermutation(nums);
// console.log(nums);
//
console.log('====');

var nums = [2, 3, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [1, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [3, 2, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);
```

```js
function findMinHeightTrees(n, edges) {
  if (n === 2) return edges[0];
  const adj = new Array(n);
  for (let i = 0; i < n; i++) {
    adj[i] = new Set();
  }
  for (const edge of edges) {
    const [a, b] = edge;
    adj[a].add(b);
    adj[b].add(a);
  }
  const ans = new Set();
  for (let i = 0; i < n; i++) {
    ans.add(i);
  }
  // Find leaves and add them to queue
  const queue = [];
  const a = [];
  for (let i = 0; i < n; i++) {
    if (adj[i].size === 1) {
      a.push(i);
    }
  }
  queue.push(a);

  // While set has more than two nodes, remove them
  while (queue.length) {
    const nodes = queue.shift();
    const b = [];
    for (const node of nodes) {
      ans.delete(node);
      // delete the edges from the current node to other nodes
      for (const child of adj[node]) {
        adj[child].delete(node);
        adj[node].delete(child);
        if (adj[child].size === 1) {
          b.push(child);
        }
      }
    }
    if (ans.size < 3) break;
    if (b.length) queue.push(b);
  }

  return Array.from(ans);
}
```

### [32].longest-valid-parentheses

```
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

#### 思路(动态规划)

所有的动态规划问题, 首先需要解决的就是如何寻找合适的子问题.
该题需要我们找到最长的有效括号对, 我们首先想到的就是定义**dp[i]为前 i 个字符串的最长有效括号对长度**, 但是随后我们会发现, 这样的定义, 我们无法找到 dp[i]和 dp[i-1]的任何关系.
所以, 我们需要重新找一个新的定义: 定义**dp[i]为以第 i 个字符结尾的最长有效括号对长度**. 然后, 我们通过下面这个例子找一下 dp[i]和 dp[i-1]之间的关系.

从上面的例子我们可以观察出一下几点结论(**描述中 i 为图中的 dp 数组的下标, 对应 s 的下标应为 i-1, 第 i 个字符的 i 从 1 开始**).

1. base case: 空字符串的最长有效括号对长度肯定为 0, 即: dp[0] = 0;
2. s 的第**1**个字符结尾的最长有效括号对长度为 0, s 的第**2**个字符结尾的最长有效括号对长度也为 0, 这个时候我们可以得出结论: 最长有效括号对不可能以'('结尾, 即: dp[1] = d[2] = 0;
3. 当 i 等于 3 时, 我们可以看出 dp[2]=0, dp[3]=2, 因为第 2 个字符(**s[1]**)和第 3 个字符(**s[2]**)是配对的;
   当 i 等于 4 时, 我们可以看出 dp[3]=2, dp[4]=4, 因为我们配对的是第 1 个字符(**s[0]**)和第 4 个字符(**s[3]**);
   因此, 我们可以得出结论: 如果第**i**个字符和第<strong>i-1-dp[i-1]</strong>个字符是配对的, 则 dp[i] = dp[i-1] + 2, 其中: i-1-dp[i-1] >= 1, 因为第 0 个字符没有任何意义;
4. 根据第 3 条规则来计算的话, 我们发现 dp[5]=0, dp[6]=2, 但是显然, dp[6]应该为 6 才对, 但是我们发现可以将"(())"和"()"进行拼接, 即: dp[i] += dp[i-dp[i]], 即: dp[6] = 2 + dp[6-2] = 2 + dp[4] = 6

根据以上规则, 我们求解 dp 数组的结果为: [0, 0, 0, 2, 4, 0, 6, 0], 其中最长有效括号对的长度为 6. 以下为图解:

#### 关键点解析

1. 第 3 点特征, 需要检查的字符是 s[i-1]和 s[i-2-dp[i-1]], 根据定义可知: i-1 >= dp[i-1], 但是 i-2 不一定大于 dp[i-1], 因此, 需要检查越界;
2. 第 4 点特征最容易遗漏, 还有就是不需要检查越界, 因为根据定义可知: i >= dp[i], 所以 dp[i-dp[i]]的边界情况是 dp[0];

```js
/**
 * https://leetcode.com/problems/longest-valid-parentheses/description/
 * Difficulty:Hard
 *
 * Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.
 * For "(()", the longest valid parentheses substring is "()", which has length = [2].
 * Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = [4].
 */

/**
 * 使用栈解决
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  var stack = [];
  for (var i = 0; i < s.length; i++) {
    if (s[i] === '(') stack.push(i);
    else {
      if (stack.length && s[stack[stack.length - 1]] === '(') stack.length--;
      else stack.push(i);
    }
  }

  if (!stack.length) return s.length;
  var longest = 0;
  var end = s.length;
  var start = 0;
  while (stack.length) {
    start = stack[stack.length - 1];
    stack.length--;
    longest = Math.max(longest, end - start - 1);
    end = start;
  }
  longest = Math.max(longest, end);
  return longest;
};

console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('())'), 2);
console.log(longestValidParentheses('(()'), 2);
console.log(longestValidParentheses('))()())((())))'), 6);
console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('('), 0);
console.log(longestValidParentheses(')()()))()()())'), 6);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('(()'), 2);
```

### [33].Search-in-Rotated-Sorted-Array

```
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

```

#### 思路

这是一个我在网上看到的前端头条技术终面的一个算法题。

题目要求时间复杂度为 logn，因此基本就是二分法了。 这道题目不是直接的有序数组，不然就是 easy 了。

首先要知道，我们随便选择一个点，将数组分为前后两部分，其中一部分一定是有序的。

具体步骤：

- 我们可以先找出 mid，然后根据 mid 来判断，mid 是在有序的部分还是无序的部分

假如 mid 小于 start，则 mid 一定在右边有序部分。
假如 mid 大于等于 start， 则 mid 一定在左边有序部分。

> 注意等号的考虑

- 然后我们继续判断 target 在哪一部分， 我们就可以舍弃另一部分了

我们只需要比较 target 和有序部分的边界关系就行了。 比如 mid 在右侧有序部分，即[mid, end]
那么我们只需要判断 target >= mid && target <= end 就能知道 target 在右侧有序部分，我们就
可以舍弃左边部分了(start = mid + 1)， 反之亦然。

我们以([6,7,8,1,2,3,4,5], 4)为例讲解一下：

#### 关键点解析

- 二分法
- 找出有序区间，然后根据 target 是否在有序区间舍弃一半元素

#### 代码

```js
/*
 * @lc app=leetcode id=33 lang=javascript
 *
 * [33] Search in Rotated Sorted Array
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  // 时间复杂度：O(logn)
  // 空间复杂度：O(1)
  // [6,7,8,1,2,3,4,5]
  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === target) return mid;

    // [start, mid]有序

    // ️⚠️注意这里的等号
    if (nums[mid] >= nums[start]) {
      //target 在 [start, mid] 之间

      // 其实target不可能等于nums[mid]， 但是为了对称，我还是加上了等号
      if (target >= nums[start] && target <= nums[mid]) {
        end = mid - 1;
      } else {
        //target 不在 [start, mid] 之间
        start = mid + 1;
      }
    } else {
      // [mid, end]有序

      // target 在 [mid, end] 之间
      if (target >= nums[mid] && target <= nums[end]) {
        start = mid + 1;
      } else {
        // target 不在 [mid, end] 之间
        end = mid - 1;
      }
    }
  }

  return -1;
};
```

```js
/**
 * https://leetcode.com/problems/search-in-rotated-sorted-array/description/
 * Difficulty:Medium
 *
 * Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
 * (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
 * You are given a target value to search. If found in the array return its index, otherwise return -[1].
 * You may assume no duplicate exists in the array.
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  var lo = 0;
  var hi = nums.length - 1;
  while (lo < hi) {
    var mid = Math.floor((lo + hi) / 2);
    if (nums[mid] < nums[hi]) hi = mid;
    else lo = mid + 1;
  }
  var i = lo;

  lo = target < nums[0] ? i : 0;
  hi = target <= nums[nums.length - 1] ? nums.length - 1 : i;

  // console.log(nums, lo, hi);
  while (lo <= hi) {
    mid = Math.floor((lo + hi) / 2);
    // console.log(lo, mid, hi)
    if (nums[mid] < target) lo = mid + 1;
    else if (nums[mid] === target) return mid;
    else hi = mid - 1;
  }

  return -1;
};

console.log(search([], 5));
console.log(search([1], 0));
console.log(search([4, 5, 6, 7, 0, 1, 2], 2));
console.log(search([3, 1], 1));
```

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const binSearch = (nums, target, n, m) => {
  if (n === m || m < n) {
    return nums[n] === target ? n : -1;
  }
  const mid = Math.floor((n + m) / 2);
  if (target === nums[mid]) return mid;
  // console.log(n, m, mid)
  if (target > nums[mid]) {
    return binSearch(nums, target, mid + 1, m);
  }
  return binSearch(nums, target, n, mid - 1);
};

export default function search(nums, target) {
  if (nums.length === 0) return -1;
  if (nums.length === 1) return nums[0] === target ? 0 : -1;

  let low = 0;
  let high = nums.length - 1;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (nums[mid] > nums[high]) low += 1;
    else high = mid;
  }

  const minIndex = low;
  const maxIndex = low - 1;

  if (nums[0] < nums[nums.length - 1]) {
    return binSearch(nums, target, 0, nums.length - 1);
  }

  if (target > nums[0]) {
    return binSearch(nums, target, 1, maxIndex);
  }
  if (target < nums[0]) {
    return binSearch(nums, target, minIndex, nums.length - 1);
  }
  return 0;
}
```

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == target) {
      return i;
    }
  }
  return -1;
};
```

### [34].在排序数组中查找元素的第一个和最后一个位置 find-first-and-last-position-of-element-in-sorted-array

```js
/*
 * @lc app=leetcode id=34 lang=javascript
 *
 * [34] Find First and Last Position of Element in Sorted Array
 * 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
 * 你的算法时间复杂度必须是 O(log n) 级别。
 * 如果数组中不存在目标值，返回 [-1, -1]。
 * 示例 1:
 * 输入: nums = [5,7,7,8,8,10], target = 8
 * 输出: [3,4]
 * 示例 2:
 * 输入: nums = [5,7,7,8,8,10], target = 6
 * 输出: [-1,-1]
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 题目要求时间复杂度为O(logn)因此很自然想到二分法
  let start = 0;
  let end = nums.length - 1;
  while (start <= end) {
    // >> 1 除以 2 取整； << 1 乘 2
    const mid = start + ((end - start) >> 1);

    if (nums[mid] === target) {
      let left = 0;
      let right = 0;

      while (nums[mid - left] === target) {
        left++;
      }
      while (nums[mid + right] === target) {
        right++;
      }
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return [-1, -1];
};
```

```js
/*
 * @lc app=leetcode.cn id=34 lang=javascript
 *
 * [34] 在排序数组中查找元素的第一个和最后一个位置
 * 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
 * 你的算法时间复杂度必须是 O(log n) 级别。
 * 如果数组中不存在目标值，返回 [-1, -1]。
 */
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  // 升序， 并且对时间复杂度有要求是 O(logn) 只能是 二分搜索
  let start = 0,
    end = nums.length - 1,
    mid;
  // 需要给 = ，处理 length === 1 的情况
  while (start <= end) {
    mid = start + ((end - start) >> 1);
    let left = (right = 0);
    if (nums[mid] === target) {
      while (nums[mid - left] === target) left++;
      while (nums[mid + right] === target) right++;
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else if (nums[mid] < target) {
      start = mid + 1;
    }
  }

  return [-1, -1];
};

console.log(searchRange([5, 7, 7, 8, 8, 10], 8));
console.log(searchRange([1], 1));
```

```js
var searchRange = function(nums, target) {
  var i = 0;
  var j = nums.length - 1;
  var ret = [-1, -1];
  while (i < j) {
    var mid = Math.floor((i + j) / 2);
    // console.log(i, mid, j);
    if (nums[mid] < target) i = mid + 1;
    else j = mid;
  }
  if (nums[i] !== target) return ret;
  ret[0] = i;
  j = nums.length - 1;
  while (i < j) {
    mid = Math.ceil((i + j) / 2);
    // console.log(i, mid, j);
    if (nums[mid] > target) j = mid - 1;
    else i = mid;
  }
  ret[1] = j;
  return ret;
};

console.log(searchRange([5, 7, 7, 8, 8, 10], 8));
```

```js
// 34. Find First and Last Position of Element in Sorted Array

// Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

// Your algorithm's runtime complexity must be in the order of O(log n).

// If the target is not found in the array, return [-1, -1].

// Input: nums = [5,7,7,8,8,10], target = 8
// Output: [3,4]

// Input: nums = [5,7,7,8,8,10], target = 6
// Output: [-1,-1]

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

const binSearch = (nums, lo, hi, target, left) => {
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (left) {
      if (nums[lo] === target) return lo;
      if (hi - lo === 1) return hi;
      if (nums[mid] < target) lo = mid;
      else hi = mid;
    } else {
      if (nums[hi] === target) return hi;
      if (hi - lo === 1) return lo;
      if (nums[mid] > target) hi = mid;
      else lo = mid;
    }
  }
};

export default function searchRange(nums, target) {
  if (nums.length === 0) return [-1, -1];
  // bin search for target.
  let lo = 0;
  let hi = nums.length - 1;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    if (nums[mid] < target) lo = mid + 1;
    else hi = mid;
  }
  if (nums[lo] !== target) return [-1, -1];

  // if left and right not equal to target, we are done
  if (nums[lo - 1] !== target && nums[lo + 1] !== target) return [lo, lo];

  if (nums.length === 2) return [0, 1];

  // if left of target not equal to target, find left
  const left = nums[hi - 1] === target ? binSearch(nums, 0, lo, target, true) : hi;

  // if right of target not equal to target, find right
  const right = nums[lo + 1] === target ? binSearch(nums, hi, nums.length - 1, target, false) : lo;

  return [left, right];
}
```

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function(nums, target) {
  let targetIndex = binarySearch(nums, target, 0, nums.length - 1);
  if (targetIndex == -1) return [-1, -1];
  let l = targetIndex,
    r = targetIndex;
  while (l > 0 && nums[l - 1] == target) {
    l--;
  }
  while (r < nums.length - 1 && nums[r + 1] == target) {
    r++;
  }
  return [l, r];
};

function binarySearch(arr, val, lo, hi) {
  if (hi < lo) return -1;
  let mid = lo + parseInt((hi - lo) / 2);

  if (val < arr[mid]) {
    return binarySearch(arr, val, lo, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, hi);
  } else {
    return mid;
  }
}

let nums = [5, 7, 7, 8, 8, 10],
  target = 9;
searchRange(nums, target);
```

```js
var searchRange = function(nums, target) {
  // 题目要求时间复杂度为O(logn)因此很自然想到二分法
  let start = 0;
  let end = nums.length - 1;
  while (start <= end) {
    const mid = start + ((end - start) >> 1);

    if (nums[mid] === target) {
      let left = 0;
      let right = 0;

      while (nums[mid - left] === target) {
        left++;
      }
      while (nums[mid + right] === target) {
        right++;
      }
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return [-1, -1];
};
```

### [39].combination-sum

```
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]

```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=39 lang=javascript
 *
 * [39] Combination Sum
 *
 * https://leetcode.com/problems/combination-sum/description/
 *
 * algorithms
 * Medium (46.89%)
 * Total Accepted:    326.7K
 * Total Submissions: 684.2K
 * Testcase Example:  '[2,3,6,7]\n7'
 *
 * Given a set of candidate numbers (candidates) (without duplicates) and a
 * target number (target), find all unique combinations in candidates where the
 * candidate numbers sums to target.
 *
 * The same repeated number may be chosen from candidates unlimited number of
 * times.
 *
 * Note:
 *
 *
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 *
 *
 * Example 1:
 *
 *
 * Input: candidates = [2,3,6,7], target = 7,
 * A solution set is:
 * [
 * ⁠ [7],
 * ⁠ [2,2,3]
 * ]
 *
 *
 * Example 2:
 *
 *
 * Input: candidates = [2,3,5], target = 8,
 * A solution set is:
 * [
 * [2,2,2,2],
 * [2,3,3],
 * [3,5]
 * ]
 *
 */

function backtrack(list, tempList, nums, remain, start) {
  if (remain < 0) return;
  else if (remain === 0) return list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, remain - nums[i], i); // 数字可以重复使用， i + 1代表不可以重复利用
    tempList.pop();
  }
}
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  const list = [];
  backtrack(
    list,
    [],
    candidates.sort((a, b) => a - b),
    target,
    0,
  );
  return list;
};
```

```js
/**
 * https://leetcode.com/problems/combination-sum/description/
 * Difficulty:Medium
 *
 * Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
 * The same repeated number may be chosen from C unlimited number of times.
 * Note:
 * All numbers (including target) will be positive integers.
 * The solution set must not contain duplicate combinations.
 * For example, given candidate set [2, 3, 6, 7] and target 7,
 * A solution set is:
 * [
 *  [7],
 *  [2, 2, 3]
 * ]
 */

/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  var res = [];
  var temp = [];
  helper(res, temp, candidates, target, 0);
  return res;
};

function helper(res, temp, candidates, target, start) {
  if (target === 0) {
    res.push([...temp]);
    return;
  }

  for (var i = start; i < candidates.length; i++) {
    if (candidates[i] <= target) {
      temp.push(candidates[i]);
      helper(res, temp, candidates, target - candidates[i], i);
      temp.length -= 1;
    }
  }
}

console.log(combinationSum([1, 2, 3, 5, 6, 7], 7));
console.log(combinationSum([7, 2, 3, 5, 6, 1], 7));
```

### [42].trapping-rain-water

```
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.


The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!


```

```
Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

```

#### 思路

这是一道雨水收集的问题， 难度为`hard`. 如图所示，让我们求下过雨之后最多可以积攒多少的水。

如果采用暴力求解的话，思路应该是 height 数组依次求和，然后相加。

伪代码:

```js
for (let i = 0; i < height.length; i++) {
  area += (h[i] - height[i]) * 1; // h为下雨之后的水位
}
```

如上图那么 h 为 [1, 1, 2, 2, ,2 ,2, ,3, 2, 2, 2, 1]

问题转化为求 h，那么 h[i]又等于`左右两侧柱子的最大值中的较小值`，即
`h[i] = Math.min(左边柱子最大值, 右边柱子最大值)`

问题的关键在于求解`左边柱子最大值`和`右边柱子最大值`,
我们其实可以用两个数组来表示`leftMax`, `rightMax`，
以 leftMax 为例，leftMax[i]代表 i 的左侧柱子的最大值，因此我们维护两个数组即可。

#### 关键点解析

- 建模 `h[i] = Math.min(左边柱子最大值, 右边柱子最大值)`(h 为下雨之后的水位)

#### 代码

```js
/*
 * @lc app=leetcode id=42 lang=javascript
 *
 * [42] Trapping Rain Water
 *
 * https://leetcode.com/problems/trapping-rain-water/description/
 *
 * algorithms
 * Hard (42.06%)
 * Total Accepted:    278.1K
 * Total Submissions: 651.6K
 * Testcase Example:  '[0,1,0,2,1,0,1,3,2,1,2,1]'
 *
 * Given n non-negative integers representing an elevation map where the width
 * of each bar is 1, compute how much water it is able to trap after raining.
 *
 *
 * The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].
 * In this case, 6 units of rain water (blue section) are being trapped. Thanks
 * Marcos for contributing this image!
 *
 * Example:
 *
 *
 * Input: [0,1,0,2,1,0,1,3,2,1,2,1]
 * Output: 6
 *
 */
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  let max = 0;
  let volumn = 0;
  const leftMax = [];
  const rightMax = [];

  for (let i = 0; i < height.length; i++) {
    leftMax[i] = max = Math.max(height[i], max);
  }

  max = 0;

  for (let i = height.length - 1; i >= 0; i--) {
    rightMax[i] = max = Math.max(height[i], max);
  }

  for (let i = 0; i < height.length; i++) {
    volumn = volumn + Math.min(leftMax[i], rightMax[i]) - height[i];
  }

  return volumn;
};
```

### [46].permutations

```
Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

```

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。

这种题目其实有一个通用的解法，就是回溯法。
网上也有大神给出了这种回溯法解题的
[通用写法](<https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)>)，这里的所有的解法使用通用方法解答。
除了这道题目还有很多其他题目可以用这种通用解法，具体的题目见后方相关题目部分。

我们先来看下通用解法的解题思路，我画了一张图：

通用写法的具体代码见下方代码区。

#### 关键点解析

- 回溯法
- backtrack 解题公式

#### 代码

```js
/*
 * @lc app=leetcode id=46 lang=javascript
 *
 * [46] Permutations
 *
 * https://leetcode.com/problems/permutations/description/
 *
 * algorithms
 * Medium (53.60%)
 * Total Accepted:    344.6K
 * Total Submissions: 642.9K
 * Testcase Example:  '[1,2,3]'
 *
 * Given a collection of distinct integers, return all possible permutations.
 *
 * Example:
 *
 *
 * Input: [1,2,3]
 * Output:
 * [
 * ⁠ [1,2,3],
 * ⁠ [1,3,2],
 * ⁠ [2,1,3],
 * ⁠ [2,3,1],
 * ⁠ [3,1,2],
 * ⁠ [3,2,1]
 * ]
 *
 *
 */
function backtrack(list, tempList, nums) {
  if (tempList.length === nums.length) return list.push([...tempList]);
  for (let i = 0; i < nums.length; i++) {
    if (tempList.includes(nums[i])) continue;
    tempList.push(nums[i]);
    backtrack(list, tempList, nums);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const list = [];
  backtrack(list, [], nums);
  return list;
};
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  result = [];
  nums.sort(function(a, b) {
    return a - b;
  });
  find(nums, []);
  return result;
};

let result = [];

function find(nums, templateList) {
  if (nums.length == 0) {
    result.push(templateList.slice());
  }
  for (let i = 0; i < nums.length; i++) {
    templateList.push(nums[i]);
    let copy = nums.slice();
    copy.splice(i, 1);
    find(copy, templateList);
    templateList.pop();
  }
}

permute([1, 2, 3]);
```

```js
/**
 * https://leetcode.com/problems/permutations/description/
 * Difficulty:Medium
 *
 * Given a collection of distinct numbers, return all possible permutations.
 * For example,
 * [1,2,3] have the following permutations:
 * [
 *  [1,2,3],
 *  [1,3,2],
 *  [2,1,3],
 *  [2,3,1],
 *  [3,1,2],
 *  [3,2,1]
 * ]
 */

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  if (!nums.length) return [];
  var res = [[]];
  for (var i = 0; i < nums.length; i++) {
    var len = res.length;
    for (var j = 0; j < len; j++) {
      var oldArr = res.shift();
      for (var k = 0; k <= oldArr.length; k++) {
        var newArr = oldArr.slice();
        newArr.splice(k, 0, nums[i]);
        res.push(newArr);
      }
    }
  }
  return res;
};
console.log(permute([1, 2, 3]));
```

### [48].rotate-image

```
You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

```

#### 思路

这道题目让我们 in-place，也就说空间复杂度要求 O(1)，如果没有这个限制的话，很简单。

通过观察发现，我们只需要将第 i 行变成第 n - i - 1 列， 因此我们只需要保存一个原有矩阵，然后按照这个规律一个个更新即可。

代码：

```js
var rotate = function(matrix) {
  // 时间复杂度O(n^2) 空间复杂度O(n)
  const oMatrix = JSON.parse(JSON.stringify(matrix)); // clone
  const n = oMatrix.length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      matrix[j][n - i - 1] = oMatrix[i][j];
    }
  }
};
```

如果要求空间复杂度是 O(1)的话，我们可以用一个 temp 记录即可，这个时候就不能逐个遍历了。
比如遍历到 1 的时候，我们把 1 存到 temp，然后更新 1 的值为 7。 1 被换到了 3 的位置，我们再将 3 存到 temp，依次类推。
但是这种解法写起来比较麻烦，这里我就不写了。

事实上有一个更加巧妙的做法，我们可以巧妙地利用对称轴旋转达到我们的目的，如图，我们先进行一次以对角线为轴的翻转，然后
再进行一次以水平轴心线为轴的翻转即可。

这种做法的时间复杂度是 O(n^2) ，空间复杂度是 O(1)

#### 关键点解析

- 矩阵旋转操作

#### 代码

```js
/*
 * @lc app=leetcode id=48 lang=javascript
 *
 * [48] Rotate Image
 */
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  // 时间复杂度O(n^2) 空间复杂度O(1)

  // 做法： 先沿着对角线翻转，然后沿着水平线翻转
  const n = matrix.length;
  function swap(arr, [i, j], [m, n]) {
    const temp = arr[i][j];
    arr[i][j] = arr[m][n];
    arr[m][n] = temp;
  }
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i; j++) {
      swap(matrix, [i, j], [n - j - 1, n - i - 1]);
    }
  }

  for (let i = 0; i < n / 2; i++) {
    for (let j = 0; j < n; j++) {
      swap(matrix, [i, j], [n - i - 1, j]);
    }
  }
};
```

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  matrix.reverse();
  for (let i = 0; i < matrix.length; i++) {
    for (let j = i + 1; j < matrix[0].length; j++) {
      let tmp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = tmp;
    }
  }
};

rotate([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);
```

### [49].group-anagrams

```
Given an array of strings, group anagrams together.

Example:

Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
```

#### 思路

一个简单的解法就是遍历数组，然后对每一项都进行排序，然后将其添加到 hashTable 中，最后输出 hashTable 中保存的值即可。

这种做法空间复杂度 O(n)， 假设排序算法用的快排，那么时间复杂度为 O(n \* klogk), n 为数组长度，k 为字符串的平均长度

代码：

```js
var groupAnagrams = function(strs) {
  const hashTable = {};

  function sort(str) {
    return str
      .split('')
      .sort()
      .join('');
  }

  // 这个方法需要排序，因此不是很优，但是很直观，容易想到
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    const key = sort(str);
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

下面我们介绍另外一种方法，我们建立一个 26 长度的 counts 数组(如果区分大小写，我们可以建立 52 个，如果支持其他字符依次类推)。
然后我们给每一个字符一个固定的数组下标，然后我们只需要更新每个字符出现的次数。 最后形成的 counts 数组如果一致，则说明他们可以通过
交换顺序得到。这种算法空间复杂度 O(n), 时间复杂度 O(n \* k), n 为数组长度，k 为字符串的平均长度.

#### 关键点解析

- 桶排序

#### 代码

```js
/*
 * @lc app=leetcode id=49 lang=javascript
 *
 * [49] Group Anagrams
 */
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  // 类似桶排序

  let counts = [];
  const hashTable = {};
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    counts = Array(26).fill(0);
    for (let j = 0; j < str.length; j++) {
      counts[str[j].charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }
    const key = counts.join('');
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  const a = 'a'.charCodeAt();
  let map = new Map();
  for (let i = 0; i < strs.length; i++) {
    let charArr = createArr();
    for (let j = 0; j < strs[i].length; j++) charArr[strs[i].charCodeAt(j) - a]++;
    let key = charArr.join('');
    if (map.has(key)) {
      map.get(key).push(strs[i]);
    } else {
      map.set(key, [strs[i]]);
    }
  }
  const ans = [];
  for (let value of map.values()) {
    ans.push(value);
  }
  return ans;
};

function createArr() {
  let i = 0;
  let arr = [];
  while (i < 26) {
    arr.push(0);
    i++;
  }
  return arr;
}

groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']);
```

### [51].N 皇后 N-Queens

```js
/**
 * https://leetcode.com/problems/n-queens/description/
 * Difficulty:Hard
 *
 * The n-queens puzzle is the problem of placing n queens on an n×n chessboard
 * such that no two queens attack each other.
 *
 * Given an integer n, return all distinct solutions to the n-queens puzzle.
 * Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.
 *
 * For example,
 * There exist two distinct solutions to the 4-queens puzzle:
 * [
 *  [".Q..",  // Solution 1
 *   "...Q",
 *   "Q...",
 *   "..Q."],
 *
 *  ["..Q.",  // Solution 2
 *   "Q...",
 *   "...Q",
 *   ".Q.."]
 * ]
 * 2,1 3,2
 */

/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
  var ret = [];
  var board = [];
  for (var i = 0; i < n; i++) {
    board.push(new Array(n).fill('.'));
  }
  helper(board, 0, ret);
  return ret;
};

function helper(board, col, ret) {
  if (col === board.length) {
    ret.push(construct(board));
  } else {
    for (var i = 0; i < board.length; i++) {
      if (check(board, i, col)) {
        board[i][col] = 'Q';
        helper(board, col + 1, ret);
        board[i][col] = '.';
      }
    }
  }
}

function check(board, x, y) {
  for (var i = 0; i < board.length; i++) {
    for (var j = 0; j < y; j++) {
      if (board[i][j] === 'Q' && (i === x || i + j === x + y || i + y === j + x)) return false;
    }
  }
  return true;
}
function construct(board) {
  return board.map(arr => arr.join(''));
}
console.log(solveNQueens(4));
```

### [53].最大子序和 Maximum-Subarray

```
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
```

#### 思路

这道题求解连续最大子序列和，以下从时间复杂度角度分析不同的解题思路。

###### 解法一 - 暴力解 (暴力出奇迹， 噢耶！)

一般情况下，先从暴力解分析，然后再进行一步步的优化。

**原始暴力解：**(超时)

求子序列和，那么我们要知道子序列的首尾位置，然后计算首尾之间的序列和。用 2 个 for 循环可以枚举所有子序列的首尾位置。
然后用一个 for 循环求解序列和。这里时间复杂度太高，`O(n^3)`.

###### 复杂度分析

- _时间复杂度：_ `O(n^3) - n 是数组长度`
- _空间复杂度：_ `O(1)`

###### 解法二 - 前缀和 + 暴力解

**优化暴力解：** (震惊，居然 AC 了)

在暴力解的基础上，用前缀和我们可以优化到暴力解`O(n^2)`, 这里以空间换时间。
这里可以使用原数组表示`prefixSum`, 省空间。

求序列和可以用前缀和(`prefixSum`) 来优化，给定子序列的首尾位置`(l, r),`
那么序列和 `subarraySum=prefixSum[r] - prefixSum[l - 1];`
用一个全局变量`maxSum`, 比较每次求解的子序列和，`maxSum = max(maxSum, subarraySum)`.

###### 复杂度分析

- _时间复杂度：_ `O(n^2) - n 是数组长度`
- _空间复杂度：_ `O(n) - prefixSum 数组空间为n`

> 如果用更改原数组表示前缀和数组，空间复杂度降为`O(1)`

但是时间复杂度还是太高，还能不能更优化。答案是可以，前缀和还可以优化到`O(n)`.

###### 解法三 - 优化前缀和 - from [**@lucifer**](https://github.com/azl397985856)

我们定义函数`S(i)` ，它的功能是计算以 `0(包括 0)`开始加到 `i(包括 i)`的值。

那么 `S(j) - S(i - 1)` 就等于 从 `i` 开始(包括 i)加到 `j`(包括 j)的值。

我们进一步分析，实际上我们只需要遍历一次计算出所有的 `S(i)`, 其中 `i = 0,1,2....,n-1。`
然后我们再减去之前的`S(k)`,其中 `k = 0，1，i - 1`，中的最小值即可。 因此我们需要
用一个变量来维护这个最小值，还需要一个变量维护最大值。

###### 复杂度分析

- _时间复杂度：_ `O(n) - n 是数组长度`
- _空间复杂度：_ `O(1)`

###### 解法四 - [分治法](https://www.wikiwand.com/zh-hans/%E5%88%86%E6%B2%BB%E6%B3%95)

我们把数组`nums`以中间位置(`m`)分为左(`left`)右(`right`)两部分. 那么有，
`left = nums[0]...nums[m - 1]` 和 `right = nums[m + 1]...nums[n-1]`

最大子序列和的位置有以下三种情况：

1. 考虑中间元素`nums[m]`, 跨越左右两部分，这里从中间元素开始，往左求出后缀最大，往右求出前缀最大, 保持连续性。
2. 不考虑中间元素，最大子序列和出现在左半部分，递归求解左边部分最大子序列和
3. 不考虑中间元素，最大子序列和出现在右半部分，递归求解右边部分最大子序列和

分别求出三种情况下最大子序列和，三者中最大值即为最大子序列和。

举例说明，如下图：

###### 复杂度分析

- _时间复杂度：_ `O(nlogn) - n 是数组长度`
- _空间复杂度：_ `O(logn)` - 因为调用栈的深度最多是 logn。

###### 解法五 - [动态规划](https://www.wikiwand.com/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

动态规划的难点在于找到状态转移方程，

`dp[i] - 表示到当前位置 i 的最大子序列和`

状态转移方程为：
`dp[i] = max(dp[i - 1] + nums[i], nums[i])`

初始化：`dp[0] = nums[0]`

从状态转移方程中，我们只关注前一个状态的值，所以不需要开一个数组记录位置所有子序列和，只需要两个变量，

`currMaxSum - 累计最大和到当前位置i`

`maxSum - 全局最大子序列和`:

- `currMaxSum = max(currMaxSum + nums[i], nums[i])`
- `maxSum = max(currMaxSum, maxSum)`

如图：

###### 复杂度分析

- _时间复杂度:_ `O(n) - n 是数组长度`
- _空间复杂度:_ `O(1)`

#### 关键点分析

1. 暴力解，列举所有组合子序列首尾位置的组合，求解最大的子序列和, 优化可以预先处理，得到前缀和
2. 分治法，每次从中间位置把数组分为左右中三部分， 分别求出左右中(这里中是包括中间元素的子序列)最大和。对左右分别深度递归，三者中最大值即为当前最大子序列和。
3. 动态规划，找到状态转移方程，求到当前位置最大和。

#### 代码

###### 解法二 - 前缀和 + 暴力

```js
function LSS(list) {
  const len = list.length;
  let max = -Number.MAX_VALUE;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum = 0;
    for (let j = i; j < len; j++) {
      sum += list[j];
      if (sum > max) {
        max = sum;
      }
    }
  }

  return max;
}
```

###### 解法三 - 优化前缀和

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  let min = 0;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum += list[i];
    if (sum - min > max) max = sum - min;
    if (sum < min) {
      min = sum;
    }
  }

  return max;
}
```

###### 解法四 - 分治法

```js
function helper(list, m, n) {
  if (m === n) return list[m];
  let sum = 0;
  let lmax = -Number.MAX_VALUE;
  let rmax = -Number.MAX_VALUE;
  const mid = ((n - m) >> 1) + m;
  const l = helper(list, m, mid);
  const r = helper(list, mid + 1, n);
  for (let i = mid; i >= m; i--) {
    sum += list[i];
    if (sum > lmax) lmax = sum;
  }

  sum = 0;

  for (let i = mid + 1; i <= n; i++) {
    sum += list[i];
    if (sum > rmax) rmax = sum;
  }

  return Math.max(l, r, lmax + rmax);
}

function LSS(list) {
  return helper(list, 0, list.length - 1);
}
```

###### 解法五 - 动态规划

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  for (let i = 1; i < len; i++) {
    list[i] = Math.max(0, list[i - 1]) + list[i];
    if (list[i] > max) max = list[i];
  }

  return max;
}
```

```js
/*
 * @lc app=leetcode.cn id=53 lang=javascript
 *
 * [53] 最大子序和
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
// 典型的动态规划 dp[i] = max(dp[i-1] + num[i], dp[i-2])
var maxSubArray = function(nums) {
  if (nums.length < 2) return nums.length === 0 ? 0 : nums[0];
  let max = nums[0];
  for (let i = 1; i < nums.length; i++) {
    // 跟 nums[i] 比较的话， nums[i] 更大表示选取当前值，否则就不选
    // sums[i] = Math.max(sums[i - 1] + nums[i], nums[i])
    // 或者换一种想法就是，判断前一次的结果是否大于 0
    // 大于的话加上当前位置的值，就是最长序列
    // 否则的话，加上前面的和只会更小，也就是只取当前位置为一个新数组
    nums[i] = nums[i] + Math.max(nums[i - 1], 0);
    if (nums[i] > max) {
      max = nums[i];
    }
  }
  return max;
};

console.log(maxSubArray([-2, 1, -3, 4]));
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

```js
/**
 * https://leetcode.com/problems/maximum-subarray/description/
 * Difficulty:Easy
 *
 * Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
 *
 * For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
 * the contiguous subarray [4,-1,2,1] has the largest sum = [6].
 */

/**
 *
 * https://discuss.leetcode.com/topic/6413/dp-solution-some-thoughts
 *
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  var dp = [];
  var max = (dp[0] = nums[0]);

  for (var i = 1; i < nums.length; i++) {
    dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
    max = Math.max(dp[i], max);
  }

  return max;
};

/**
 * https://discuss.leetcode.com/topic/500/accepted-o-n-solution-in-java/11
 * @param nums
 * @returns {*}
 */
var maxSubArray = function(nums) {
  var max = nums[0];
  var sum = nums[0];

  for (var i = 1; i < nums.length; i++) {
    sum = sum > 0 ? sum + nums[i] : nums[i];
    max = Math.max(sum, max);
  }
  return max;
};

console.log(maxSubArray([1, 1, 1]) == 3);
console.log(maxSubArray([-1, -1, -1]) == -1);
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6);
console.log(maxSubArray([-2, -1]) == -1);
console.log(maxSubArray([-1]) == -1);
console.log(maxSubArray([-1, 0]) == 0);
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let count = nums[0],
    maxCount = nums[0];
  for (let i = 1; i < nums.length; i++) {
    count = Math.max(count + nums[i], nums[i]);
    maxCount = Math.max(maxCount, count);
  }
  return maxCount;
};

console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

#### 相似题

- [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)
- [Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)

### [55].jump-game

```
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.

```

#### 思路

这道题目是一道典型的`回溯`类型题目。
思路就是用一个变量记录当前能够到达的最大的索引，我们逐个遍历数组中的元素去更新这个索引。
变量完成判断这个索引是否大于数组下表即可。

#### 关键点解析

- 建模 (记录和更新当前位置能够到达的最大的索引即可)

#### 代码

```js
/*
 * @lc app=leetcode id=55 lang=javascript
 *
 * [55] Jump Game
 *
 * https://leetcode.com/problems/jump-game/description/
 *
 * algorithms
 * Medium (31.38%)
 * Total Accepted:    252.4K
 * Total Submissions: 797.2K
 * Testcase Example:  '[2,3,1,1,4]'
 *
 * Given an array of non-negative integers, you are initially positioned at the
 * first index of the array.
 *
 * Each element in the array represents your maximum jump length at that
 * position.
 *
 * Determine if you are able to reach the last index.
 *
 * Example 1:
 *
 *
 * Input: [2,3,1,1,4]
 * Output: true
 * Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last
 * index.
 *
 *
 * Example 2:
 *
 *
 * Input: [3,2,1,0,4]
 * Output: false
 * Explanation: You will always arrive at index 3 no matter what. Its
 * maximum
 * jump length is 0, which makes it impossible to reach the last index.
 *
 *
 */
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let max = 0; // 能够走到的数组下标

  for (let i = 0; i < nums.length; i++) {
    if (max < i) return false; // 当前这一步都走不到，后面更走不到了
    max = Math.max(nums[i] + i, max);
  }

  return max >= nums.length - 1;
};
```

### [56].合并区间 merge-intervals

```
Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

```

#### 思路

- 先对数组进行排序，排序的依据就是每一项的第一个元素的大小。
- 然后我们对数组进行遍历，遍历的时候两两运算(具体运算逻辑见下)
- 判断是否相交，如果不相交，则跳过
- 如果相交，则合并两项

#### 关键点解析

- 对数组进行排序简化操作
- 如果不排序，需要借助一些 hack,这里不介绍了

#### 代码

```js
/*
 * @lc app=leetcode id=56 lang=javascript
 *
 * [56] Merge Intervals
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */

function intersected(a, b) {
  if (a[0] > b[1] || a[1] < b[0]) return false;
  return true;
}

function mergeTwo(a, b) {
  return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];
}
var merge = function(intervals) {
  // 这种算法需要先排序
  intervals.sort((a, b) => a[0] - b[0]);
  for (let i = 0; i < intervals.length - 1; i++) {
    const cur = intervals[i];
    const next = intervals[i + 1];

    if (intersected(cur, next)) {
      intervals[i] = undefined;
      intervals[i + 1] = mergeTwo(cur, next);
    }
  }
  return intervals.filter(q => q);
};
```

```js
/*
 * @lc app=leetcode.cn id=56 lang=javascript
 *
 * [56] 合并区间
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
// 两个区间若能合并，则第一个区间的右端点一定不小于第二个区间的左端点。所以先把区间集合按照左端点从小到大进行排序，接着从第一个区间开始遍历，对每个区间执行如下操作：

// [1]. 首先保存该区间的左端点start和右端点end
// [2]. 从该区间的下一个区间开始，依次比较此区间的左端点与上一个区间的右端点，若满足合并条件则记录新合并区间的右端点。注意右端点取当前区间与之前区间右端点的较大值
// [3]. 若当前区间不再满足合并条件或者遍历到了集合末尾，就构建新合并区间，其中左端点为初始区间的左端点，右端点为当前所有合并区间右端点的最大值，然后将其加入到结果集合中，接着合并下一个区间
var merge = function(intervals) {
  if (intervals.length < 2) return intervals;
  intervals = intervals.sort((a, b) => a[0] - b[0]);
  let left = intervals[0][0],
    right = intervals[0][1];

  for (let i = 1; i < intervals.length; i++) {}
};
```

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let i = nums.length - 2,
    len = nums.length - 1;
  while (i > 0) {
    if (nums[i] >= len - i) {
      len = i;
    }
    i--;
  }
  return nums[0] >= len;
};

/**
 * 从后往前找更佳
 */
```

```js
/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {Interval[]}
 */
var merge = function(intervals) {
  if (intervals.length == 0) return [];
  intervals.sort((a, b) => {
    return a.start - b.start;
  });

  let ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    if (intervals[i].end >= intervals[i + 1].start) {
      intervals[i + 1].start = Math.min(intervals[i].start, intervals[i + 1].start);
      intervals[i + 1].end = Math.max(intervals[i].end, intervals[i + 1].end);
    } else {
      ans.push(intervals[i]);
    }
  }
  ans.push(intervals[intervals.length - 1]);
  return ans;
};
```

```js
// 56. Merge Intervals

// Given a collection of intervals, merge all overlapping intervals.

// Example 1:

// Input: [[1,3],[2,6],[8,10],[15,18]]
// Output: [[1,6],[8,10],[15,18]]
// Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
// Example 2:

// Input: [[1,4],[4,5]]
// Output: [[1,5]]
// Explanation: Intervals [1,4] and [4,5] are considered overlapping.

/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
export default function merge(intervals) {
  if (intervals.length === 0) return [];
  if (intervals.length === 1) return intervals;
  intervals = intervals.sort((a, b) => {
    if (a[0] !== b[0]) return a[0] - b[0];
    return a[1] - b[1];
  });
  let start = intervals[0][0];
  let end = intervals[0][1];
  const ans = [];
  for (let i = 0; i < intervals.length - 1; i++) {
    const left = intervals[i];
    const right = intervals[i + 1];
    if (right[0] <= end && right[1] >= end) {
      end = right[1]; // then overlap
    } else if (right[0] > end) {
      ans.push([start, end]);
      start = right[0];
      end = right[1];
    }
    if (i === intervals.length - 2) ans.push([start, end]);
  }
  return ans;
}
```

### [62].unique-paths

```

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
```

```
Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
```

#### 思路

这是一道典型的适合使用动态规划解决的题目，它和爬楼梯等都属于动态规划中最简单的题目，
因此也经常会被用于面试之中。

读完题目你就能想到动态规划的话，建立模型并解决恐怕不是难事。其实我们很容易看出，由于机器人只能右移动和下移动，
因此第[i, j]个格子的总数应该等于[i - 1, j] + [i, j -1]， 因为第[i,j]个格子一定是从左边或者上面移动过来的。

代码大概是：

```js
const dp = [];
for (let i = 0; i < m + 1; i++) {
  dp[i] = [];
  dp[i][0] = 0;
}
for (let i = 0; i < n + 1; i++) {
  dp[0][i] = 0;
}
for (let i = 1; i < m + 1; i++) {
  for (let j = 1; j < n + 1; j++) {
    dp[i][j] = j === 1 ? 1 : dp[i - 1][j] + dp[i][j - 1]; // 转移方程
  }
}

return dp[m][n];
```

由于 dp[i][j] 只依赖于左边的元素和上面的元素，因此空间复杂度可以进一步优化， 优化到 O(n).

具体代码请查看代码区。

#### 关键点

- 空间复杂度可以进一步优化到 O(n), 这会是一个考点
- 基本动态规划问题

#### 代码

```js
/*
 * @lc app=leetcode id=62 lang=javascript
 *
 * [62] Unique Paths
 *
 * https://leetcode.com/problems/unique-paths/description/
 *
 * algorithms
 * Medium (46.53%)
 * Total Accepted:    277K
 * Total Submissions: 587.7K
 * Testcase Example:  '3\n2'
 *
 * A robot is located at the top-left corner of a m x n grid (marked 'Start' in
 * the diagram below).
 *
 * The robot can only move either down or right at any point in time. The robot
 * is trying to reach the bottom-right corner of the grid (marked 'Finish' in
 * the diagram below).
 *
 * How many possible unique paths are there?
 *
 *
 * Above is a 7 x 3 grid. How many possible unique paths are there?
 *
 * Note: m and n will be at most 100.
 *
 * Example 1:
 *
 *
 * Input: m = 3, n = 2
 * Output: 3
 * Explanation:
 * From the top-left corner, there are a total of 3 ways to reach the
 * bottom-right corner:
 * 1. Right -> Right -> Down
 * 2. Right -> Down -> Right
 * 3. Down -> Right -> Right
 *
 *
 * Example 2:
 *
 *
 * Input: m = 7, n = 3
 * Output: 28
 *
 *   START
 */
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const dp = Array(n).fill(1);

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[j] = dp[j] + dp[j - 1];
    }
  }

  return dp[n - 1];
};
```

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const pos = new Array(m);
  for (let i = 0; i < m; i++) {
    pos[i] = new Array(n);
  }
  for (let i = 0; i < n; i++) {
    pos[0][i] = 1;
  }
  for (let i = 0; i < m; i++) {
    pos[i][0] = 1;
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      pos[i][j] = pos[i - 1][j] + pos[i][j - 1];
    }
  }
  return pos[m - 1][n - 1];
};

uniquePaths(3, 7);

/**
0  1  1  1  1  1  1
1  2  3  4  5  6  7
1  3  6  10 15 21 28
 */
```

```js
/**
 * https://leetcode.com/problems/unique-paths/
 * Difficulty:Medium
 *
 * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
 * The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
 * How many possible unique paths are there?
 * Note: m and n will be at most [100].
 *
 */

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  var arr = [];
  for (var i = 0; i < m; i++) {
    for (var j = 0; j < n; j++) {
      if (i === 0 && j === 0) arr[0] = 1;
      else {
        var left = j - 1 < 0 ? 0 : arr[i * n + j - 1];
        var top = i - 1 < 0 ? 0 : arr[(i - 1) * n + j];
        arr[i * n + j] = left + top;
      }
    }
  }
  return arr[arr.length - 1];
};

console.log(uniquePaths(2, 2));
```

### [64].最小路径和 Minimum-Path-Sum

```js
/**
 * https://leetcode.com/problems/minimum-path-sum/description/
 * Difficulty:Medium
 *
 * Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
 * Note: You can only move either down or right at any point in time.
 * Example 1:
 * [
 *  [1,3,1],
 *  [1,5,1],
 *  [4,2,1]
 * ]
 * Given the above grid map, return [7]. Because the path 1→3→1→1→1 minimizes the sum.
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
  var m = grid.length;
  var n = grid[0].length;
  var dp = [];
  while (dp.push(new Array(n + 1).fill(Number.MAX_VALUE)) <= m);
  dp[0][1] = 0;
  dp[1][0] = 0;

  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      dp[i][j] = grid[i - 1][j - 1] + Math.min(dp[i][j - 1], dp[i - 1][j]);
    }
  }

  return dp[m][n];
};

console.log(
  minPathSum([
    [1, 2],
    [1, 1],
  ]),
);
```

```js
// Given a m x n grid filled with non-negative numbers, find a path from top left to bottom
// right which minimizes the sum of all numbers along its path.

// Note: You can only move either down or right at any point in time.

// Input:
// [
//   [1,3,1],
//   [1,5,1],
//   [4,2,1]
// ]
// Output: 7
// Explanation: Because the path 1→3→1→1→1 minimizes the sum.

// Observations:
// This is a DP problem. The shortest path of location i, j is the Min of down or right

/**
 * @param {number[][]} grid
 * @return {number}
 */

const traverse = (grid, i, j, dpTable) => {
  if (i === grid.length - 1 && j === grid[0].length - 1) return grid[i][j];
  if (i < 0 || j < 0 || i === grid.length || j === grid[0].length) return Infinity;
  if (dpTable[i][j]) return dpTable[i][j];
  const min = Math.min(traverse(grid, i + 1, j, dpTable), traverse(grid, i, j + 1, dpTable));
  const res = grid[i][j] + min;
  dpTable[i][j] = res;
  return res;
};

export default function minPathSum(grid) {
  const dpTable = new Array(grid.length);
  for (let i = 0; i < grid.length; i++) {
    dpTable[i] = [];
  }
  return traverse(grid, 0, 0, dpTable);
}
```

```js
/*
 * @lc app=leetcode.cn id=64 lang=javascript
 *
 * [64] 最小路径和
 */
/**
 * @param {number[][]} grid
 * @return {number}
 */
// 这是最基础的动态规划题目。 不过是二维的。
// dp[i][j]代表从(0, 0)走到(i, j)的最小路径和则
// dp[0][i]来自第一行的累加
// dp[i][0]来自第一列的累加
// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + c[i][j]
// (来自当前位置的走法无非向下或向右，选两者中代价最小的)
var minPathSum = function(grid) {
  const row = grid.length;
  const line = grid[0].length;
  const dp = [];
  dp[0] = [grid[0][0]];
  for (let i = 1; i < row; i++) {
    if (dp[i] === undefined) {
      dp[i] = [];
    }
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }
  for (let j = 1; j < line; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }
  for (let i = 1; i < row; i++) {
    for (let j = 1; j < line; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  // console.log(dp)
  return dp[row - 1][line - 1];
};

console.log(
  minPathSum([
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
  ]),
);

console.log(
  minPathSum([
    [0, 1],
    [1, 0],
  ]),
);
```

### [66].加一

```js
/*
 * @lc app=leetcode.cn id=66 lang=javascript
 *
 * [66] 加一
 */

// 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

// 你可以假设除了整数 0 之外，这个整数不会以零开头。

// 示例 1:

// 输入: [1, 2, 3]
// 输出: [1, 2, 4]
// 解释: 输入数组表示数字 123。
// 示例 2:

// 输入: [4, 3, 2, 1]
// 输出: [4, 3, 2, 2]
// 解释: 输入数组表示数字 4321。

/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  let shouldAddOne = true;
  for (let i = digits.length - 1; i >= 0; i--) {
    if (shouldAddOne) {
      if (digits[i] === 9) {
        digits[i] = 0;
        shouldAddOne = true;
      } else {
        digits[i] += 1;
        shouldAddOne = false;
      }
    }
  }
  if (shouldAddOne) {
    digits.unshift(1);
  }

  return digits;
};

[[1, 2, 3], [4, 3, 2, 1], [9]].forEach(elm => {
  console.log(plusOne(elm));
});
```

### [67].二进制求和

```js
// Given two binary strings, return their sum (also a binary string).

// The input strings are both non-empty and contains only characters 1 or [0].

// Example 1:

// Input: a = "11", b = "1"
// Output: "100"
// Example 2:

// Input: a = "110", b = "111"
// Output: "1101"

// 二进制求和
// 给定两个二进制字符串，返回他们的和(用二进制表示)。

// 输入为非空字符串且只包含数字 1 和 0。

// 示例 1:

// 输入: a = "11", b = "1"
// 输出: "100"
// 示例 2:

// 输入: a = "110", b = "111"
// 输出: "1101"

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
export default function addBinary(a, b) {
  let i = a.length - 1;
  let j = b.length - 1;
  const ans = [];
  let carry = 0;
  while (j >= 0 || i >= 0 || carry) {
    let sum = carry;
    if (i >= 0) {
      sum += parseInt(a[i], 10);
      i--;
    }
    if (j >= 0) {
      sum += parseInt(b[j], 10);
      j--;
    }
    carry = sum > 1 ? 1 : 0;
    ans.push(sum % 2);
  }
  return ans.reverse().join('');
}
```

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary1 = function(a, b) {
  let c = 0;
  let aLen = a.length;
  let bLen = b.length;
  let ans = '';
  for (var i = 0; i < Math.max(aLen, bLen); i++) {
    var ai = i < aLen ? parseInt(a[aLen - i - 1]) : 0;
    var bi = i < bLen ? parseInt(b[bLen - i - 1]) : 0;

    var sum = ai + bi + c;
    // console.log(ai, bi, c);
    if (sum < 2) {
      ans = sum + ans;
      c = 0;
    } else {
      ans = sum - 2 + ans;
      c = 1;
    }
  }
  if (c) {
    ans = 1 + ans;
  }

  return ans;
};

console.log(addBinary1('111', '1'));
```

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */

function getLastChar(str) {
  if (str) {
    return str[str.length - 1];
  }
  return 0;
}

function advance(str) {
  if (str) {
    return str.slice(0, -1);
  }
}
var addBinary = function(a, b) {
  let result = [],
    carry = 0; // 进位
  while (a || b || carry) {
    let valueA = parseInt(getLastChar(a)),
      valueB = parseInt(getLastChar(b));

    const needCarry = valueA + valueB + carry > 1;

    result.push(needCarry ? valueA + valueB + carry - 2 : valueA + valueB + carry);

    a = advance(a);
    b = advance(b);

    carry = needCarry ? 1 : 0;
  }

  return result.reverse().join('');
};

console.log(addBinary('111', '1'));
console.log(addBinary('1', '1'));
```

### [69].x 的平方根

实现  int sqrt(int x)  函数。计算并返回  x  的平方根，其中  x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

```js
var mySqrt = function(x) {
  let left = 1,
    right = x,
    mid;

  while (left <= right) {
    mid = Math.floor((left + right) / 2);

    if (mid * mid > x) {
      right = mid - 1;
    } else if (mid * mid < x) {
      left = mid + 1;
    } else return mid;
  }

  return right;
};
```

```js
const mySqrt = function(x) {
  if (x === 1) return 1;
  let min = 0;
  let max = parseInt(x / 2);
  let mid = parseInt((max + min) / 2);
  let ans;
  while (!ans) {
    // ** 是求幂计算
    if (mid ** 2 === x) {
      return mid;
    }
    if (mid ** 2 < x) {
      min = mid + 1;
    } else {
      max = mid - 1;
    }
    if (min === max) return min;
    if (min + 1 === max && min ** 2 < x && max ** 2 > x) return min;
    if (mid === parseInt((max + min) / 2)) return mid;
    mid = parseInt((max + min) / 2);
  }
  return ans;
};
```

### [70].爬楼梯 Climbing-Stairs

斐波那契数列 n 往后推了 1 项.

```js
var climbStairs = function(n) {
  let dp = new Array(n);
  dp[0] = 1;
  dp[1] = 2;
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n - 1];
};
```

### [75].sort-colors

Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:

Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Follow up:

A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
Could you come up with a one-pass algorithm using only constant space?

#### 思路

其实就是排序，而且没有要求稳定性，就是用啥排序算法都行。
题目并没有给出数据规模，因此我默认数据量不大，直接选择了冒泡排序

#### 关键点解析

冒泡排序的时间复杂度是 N 平方，无法优化，但是可以进一步优化常数项，
比如循环的起止条件。 由于每一次遍历都会将最后一位“就位”，因此内层循环的截止条件就可以是
`nums.length - i`， 而不是 `nums.length`, 可以省一半的时间。

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
  function swap(nums, i, j) {
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = 0; j < nums.length - i; j++) {
      if (nums[j] < nums[j - 1]) {
        swap(nums, j - 1, j);
      }
    }
  }
};
```

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
export default function sortColors(nums) {
  const counts = new Array(3);
  for (const item of nums) {
    counts[item] = counts[item] === undefined ? 1 : counts[item] + 1;
  }
  let index = 0;
  for (let i = 0; i < counts.length; i++) {
    for (let j = 0; j < counts[i]; j++) {
      nums[index] = i;
      index++;
    }
  }
  return nums;
}
```

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
  sort(nums, 0, nums.length - 1);
};

function sort(arr, lo, hi) {
  if (hi <= lo) return;
  let lt = lo,
    i = lo + 1,
    gt = hi;
  let v = arr[lo];
  while (i <= gt) {
    if (arr[i] < v) swap(arr, lt++, i++);
    else if (arr[i] > v) swap(arr, i, gt--);
    else i++;
  }
  sort(arr, lo, lt - 1);
  sort(arr, gt + 1, hi);
}

function swap(arr, a, b) {
  let x = arr[a];
  arr[a] = arr[b];
  arr[b] = x;
}

/**
 * 三向字符串快速排序
 */
```

### [76].

```js
function minWindow(s, t) {
  var ans = '';

  // [1]. process hashmap
  var map = {};
  t.split('').forEach(ch => (map[ch] = (map[ch] || 0) + 1));
  var count = Object.keys(map).length;

  // [2]. traverse s to find boundaries
  // both l & r are inclusive
  var l = 0;
  var r = -1;

  while (r < s.length) {
    if (count === 0) {
      // good condition
      // l~r contains t

      // update ans
      if (!ans || r - l + 1 < ans.length) {
        ans = s.slice(l, r + 1);
      }

      // get rid of curr ch and then move l
      if (map[s[l]] !== undefined) {
        map[s[l]]++;
      }
      if (map[s[l]] > 0) {
        count++;
      }
      l++;
    } else {
      // bad condition
      // l~r doesn't contain t

      // move r and add new ch
      r++;
      if (map[s[r]] !== undefined) {
        map[s[r]]--;
      }
      if (map[s[r]] === 0) {
        count--;
      }
    }
  }
  return ans;
}
```

### [78].子集

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  if (nums.length === 0) return [];
  const length = nums.length;
  const result = [];
};

function select(n, nums = []) {
  if (n === 0) return [];

  for (let i = 0; i < nums.length; i++) {}
}
```

```js
// 78. Subsets

// Given a set of distinct integers, nums, return all possible subsets (the power set).

// Note: The solution set must not contain duplicate subsets.

// Example:

// Input: nums = [1,2,3]
// Output:
// [
//   [3],
//   [1],
//   [2],
//   [1,2,3],
//   [1,3],
//   [2,3],
//   [1,2],
//   []
// ]
const subsetsAux = (nums, prev, start, res) => {
  if (start === nums.length || start === prev.length) {
    res.push(prev);
    return res;
  }
  const remove = [];
  for (let i = 0; i < prev.length; i++) {
    if (start === i) {
      continue;
    }
    remove.push(prev[i]);
  }
  subsetsAux(nums, [...prev], start + 1, res);
  subsetsAux(nums, [...remove], start, res);
  return res;
};

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
export default function subsets(nums) {
  const res = [];
  return subsetsAux(nums, [...nums], 0, res);
}
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  let list = [];
  nums.sort();
  backtrack(list, new Array(), nums, 0);
  return list;
};

function backtrack(list, tempList, nums, start) {
  list.push(tempList.slice());
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}

subsets([1, 2, 3]);

/**
 *
 * 1
 * 1 2
 * 1 2 3
 * 1 3
 * 2
 * 2 3
 * 3
 */
```

### [79].word-search

```
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

#### 思路

在 2D 表中搜索是否有满足给定单词的字符组合，要求所有字符都是相邻的(方向不限). 题中也没有要求字符的起始和结束位置。

在起始位置不确定的情况下，扫描二维数组，找到字符跟给定单词的第一个字符相同的，四个方向(上，下，左，右)分别 DFS 搜索，
如果任意方向满足条件，则返回结果。不满足，回溯，重新搜索。

举例说明：如图二维数组，单词："SEE"

```
1. 扫描二维数组，找到board[1,0] = word[0]，匹配单词首字母。
2. 做DFS(上，下，左，右 四个方向)

如下图：
```

起始位置(1，0)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1，0)为已经访问过，board[1][0] = '*'
2. 上(0，0)字符为 'A' 不匹配,
3. 下(2，0)字符为 'A'，不匹配,
4. 左(-1，0)超越边界，不匹配,
5. 右(1，1)字符 'F'，不匹配

如下图：
```

由于从起始位置 DFS 都不满足条件，所以

```
1. 回溯，标记起始位置(1，0)为未访问。board[1][0] = 'S'.
2. 然后继续扫描二维数组，找到下一个起始位置(1，3)

如下图：
```

起始位置(1，3)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1, 3)为已经访问过，board[1][3] = '*'
2. 上(0，3)字符为 'E', 匹配, 继续DFS搜索(参考位置为(0，3)位置DFS搜索步骤描述)
3. 下(2，3)字符为 'E'，匹配, #2匹配，先进行#2 DFS搜索，由于#2 DFS搜索没有找到与单词匹配，继续DFS搜索(参考位置为(2，3)DFS搜索步骤描述)
4. 左(1，2)字符为 'C'，不匹配,
5. 右(1，4)超越边界，不匹配

如下图：
```

位置(0，3)满足条件，继续 DFS，判断相邻的字符是否匹配单词下一个字符 `E`

```
1. 标记当前字符(0，3)为已经访问过，board[0][3] = '*'
2. 上 (-1，3)超越边界，不匹配
3. 下(1，3)已经访问过，
4. 左(0，2)字符为 'C'，不匹配
5. 右(1，4)超越边界，不匹配

如下图
```

从位置(0，3)DFS 不满足条件，继续位置(2，3)DFS 搜索

```
1. 回溯，标记起始位置(0，3)为未访问。board[0][3] = 'E'.
2. 回到满足条件的位置(2，3)，继续DFS搜索，判断相邻的字符是否匹配单词下一个字符 'E'
3. 上 (1，3)已访问过
4. 下(3，3)超越边界，不匹配
5. 左(2，2)字符为 'E'，匹配
6. 右(2，4)超越边界，不匹配

如下图：
```

单词匹配完成，满足条件，返回 `True`.

###### 复杂度分析

- _时间复杂度：_ `O(m*n) - m 是二维数组行数， n 是二维数组列数`
- _空间复杂度：_ `O(1) - 这里在原数组中标记当前访问过，没有用到额外空间`

> **注意**：如果用 Set 或者是 boolean[][]来标记字符位置是否已经访问过，需要额外的空间 `O(m*n)`.

#### 关键点分析

- 遍历二维数组的每一个点，找到起始点相同的字符，做 DFS
- DFS 过程中，要记录已经访问过的节点，防止重复遍历，这里(Java Code 中)用 `*` 表示当前已经访问过，也可以用 Set 或者是 boolean[][]数组记录访问过的节点位置。
- 是否匹配当前单词中的字符，不符合回溯，这里记得把当前 `*` 重新设为当前字符。如果用 Set 或者是 boolean[][]数组，记得把当前位置重设为没有访问过。

#### 代码

```js
/*
 * @lc app=leetcode id=79 lang=javascript
 *
 * [79] Word Search
 */
function DFS(board, row, col, rows, cols, word, cur) {
  // 边界检查
  if (row >= rows || row < 0) return false;
  if (col >= cols || col < 0) return false;

  const item = board[row][col];

  if (item !== word[cur]) return false;

  if (cur + 1 === word.length) return true;

  // 如果你用hashmap记录访问的字母， 那么你需要每次backtrack的时候手动清除hashmap，并且需要额外的空间
  // 这里我们使用一个little trick

  board[row][col] = null;

  // 上下左右
  const res =
    DFS(board, row + 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row - 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row, col - 1, rows, cols, word, cur + 1) ||
    DFS(board, row, col + 1, rows, cols, word, cur + 1);

  board[row][col] = item;

  return res;
}
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  if (word.length === 0) return true;
  if (board.length === 0) return false;

  const rows = board.length;
  const cols = board[0].length;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const hit = DFS(board, i, j, rows, cols, word, 0);
      if (hit) return true;
    }
  }
  return false;
};
```

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  for (let y = 0; y < board.length; y++) {
    for (let x = 0; x < board[0].length; x++) {
      if (find(board, word, y, x, 0)) return true;
    }
  }
  return false;
};

function find(board, word, y, x, d) {
  if (d == word.length) return true;
  if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false;
  if (board[y][x] != word[d]) return false;
  let tmp = board[y][x];
  board[y][x] = '*';
  let exist =
    find(board, word, y, x + 1, d + 1) ||
    find(board, word, y, x - 1, d + 1) ||
    find(board, word, y + 1, x, d + 1) ||
    find(board, word, y - 1, x, d + 1);
  board[y][x] = tmp;
  return exist;
}

exist(
  [
    ['C', 'A', 'A'],
    ['A', 'A', 'A'],
    ['B', 'C', 'D'],
  ],
  'AAB',
);

//     // board 二维数组，word 查找的单词
//     public boolean exist(char[][] board, String word) {
//     char[] w = word.toCharArray();// 转为字符数组
//     for (int y = 0; y < board.length; y++) {
//         for (int x = 0; x < board[y].length; x++) {
//             // 遍历二维数组去求是否存在
//             if (exist(board, y, x, w, 0)) return true;
//         }
//     }
//     return false;
// }

//     // board 二位数组，第 x 列 第 y 行，查找的单词字符数组，i 是单词字符数组索引值
//     private boolean exist(char[][] board, int y, int x, char[] word, int i) {
//     if (i == word.length) return true; // 完全匹配，返回 true
//     if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false; // x、y超出矩阵边界，返回 false
//     if (board[y][x] != word[i]) return false; // 字符不匹配，返回 false
//     board[y][x] ^= 256; // 按位异或，先将当前字符转为另外的字符，避免获取重复数值
//     boolean exist = exist(board, y, x + 1, word, i + 1)
//         || exist(board, y, x - 1, word, i + 1)
//         || exist(board, y + 1, x, word, i + 1)
//         || exist(board, y - 1, x, word, i + 1);
//     board[y][x] ^= 256; // 恢复当前值
//     return exist;
// }
```

### [84].largest-rectangle-in-histogram

```js
/*
 * @lc app=leetcode id=84 lang=javascript
 *
 * [84] Largest Rectangle in Histogram
 */
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  // 木桶原理
  // 暴力求解法 时间复杂度O(n^2) 空间复杂度O(1)
  // if (heights.length === 1) return heights[0];
  // let min = null;
  // let max = 0;
  // for (let i = 0; i < heights.length; i++) {
  //   min = heights[i];
  //   for (let j = i; j < heights.length; j++) {
  //     min = Math.min(min, heights[j]);
  //     max = Math.max((j - i + 1) * min, max);
  //   }
  // }
  // return max;
  // 上面的暴力求解，其实可以做一个小优化，就是通过取局部最大值来减少一部分重复计算，但是时间复杂度还是O(n^2)
  // 关键点： [1]. 单调栈(Monotone Stack),线性复杂度,因为所有元素只会进入栈一次，并且出栈后再也不会进栈了 [2].如果用暴力求解的话，你要会找出所有组合的方法(大部分题目都是两两组合，如果是任意组合的情况，暴力的话复杂度是2^n，
  // 这种情况，暴力求解通常不不取，需要考虑别的思路)
  // 当前题目就是两两组合 ，时间复杂度是O(n^2)，在可以接受的范围
  // 社区中流行的一种解法: 单调栈,  在这里我们需要使用单调递增栈
  // 时间复杂度O(n) 空间复杂度O(n)
  // const ascStack = [];
  // let max = 0;
  // heights.push(0); // hack, 为了使最后一个柱子也参与运算
  // for (let i = 0; i < heights.length; i++) {
  //   let p = i;
  //   while (
  //     ascStack.length > 0 &&
  //     heights[i] < heights[ascStack[ascStack.length - 1]]
  //   ) {
  //     // 由于是递增栈， height[p]一定是最小的，一定是短板
  //     p = ascStack.pop();
  //     max = Math.max(max, heights[p] * (ascStack.length === 0 ? i : i - p));
  //   }
  //   ascStack.push(i);
  // }
  // return max;
  // 相关题目： 雨水收集
  // 直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高
};
```

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  let maxArea = 0;
  for (let i = 0; i < heights.length; i++) {
    let l = i,
      r = i,
      height = heights[i];
    while (l > 0) {
      if (heights[l - 1] >= height) {
        l--;
      } else {
        break;
      }
    }
    while (r < heights.length - 1) {
      if (heights[r + 1] >= height) {
        r++;
      } else {
        break;
      }
    }
    maxArea = Math.max(maxArea, (r - l + 1) * height);
  }
  return maxArea;
};

largestRectangleArea([2, 1, 5, 6, 2, 3]);
```

### [85].Maximal-Rectangle

```js
/**
 * https://leetcode.com/problems/maximal-rectangle/description/
 * Difficulty:Hard
 * Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
 * For example, given the following matrix:
 *
 * 1 0 1 0 0
 * 1 0 1 1 1
 * 1 1 1 1 1
 * 1 0 0 1 0
 *
 * Return [6].
 *
 */

/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
  var m = matrix.length;
  if (!m) return 0;
  var n = matrix[0].length;
  if (!n) return 0;

  var dp = [];
  while (dp.push(new Array(n + 1).fill([0, 0])) <= m);
  var max = 0;
  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      if (matrix[i - 1][j - 1] != 0) {
        dp[i][j] = [1, 1];
        var top = dp[i - 1][j];
        var left = dp[i][j - 1];
        if (top[0] * top[1] === 0) {
          dp[i][j] = [1, left[1] + 1];
        } else if (left[0] * left[1] === 0) {
          dp[i][j] = [top[0] + 1, 1];
        } else {
          var x1 = top[0] + 1;
          var y1 = Math.min(top[1], left[1] + 1);
          var p1 = x1 * y1;

          var x2 = Math.min(left[0], top[0] + 1);
          var y2 = left[1] + 1;
          var p2 = x2 * y2;

          if (p1 >= p2) {
            dp[i][j] = [x1, y1];
          } else {
            dp[i][j] = [x2, y2];
          }
        }

        max = Math.max(max, dp[i][j][0] * dp[i][j][1]);
      }
    }
  }

  // for (var i = 0; i < matrix.length; i++) {
  //     console.log(matrix[i].split(''));
  // }
  // console.log('======================');
  //
  // for (var i = 1; i < dp.length; i++) {
  //     console.log(dp[i].slice(1).join(' | '));
  // }

  return max;
};

// console.log(maximalRectangle([
//     [1, 0, 1, 0, 0],
//     [1, 0, 1, 1, 1],
//     [1, 1, 1, 1, 1],
//     [1, 0, 0, 1, 0],
// ]));

// console.log(maximalRectangle(
//     ["1100", "1111", "11111", "1010"]
// ));

console.log(maximalRectangle(['10', '110', '11', '10']));
```

### [94].二叉树的中序遍历 binary-tree-inorder-traversal

```
Given a binary tree, return the inorder traversal of its nodes' values. (中序遍历)

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?
```

#### 思路

递归的方式相对简单，非递归的方式借助栈这种数据结构实现起来会相对轻松。

如果采用非递归，可以用栈(Stack)的思路来处理问题。

中序遍历的顺序为左-根-右，具体算法为：

- 从根节点开始，先将根节点压入栈

- 然后再将其所有左子结点压入栈，取出栈顶节点，保存节点值

- 再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中， 重复上步骤

(图片来自： https://github.com/MisterBooo/LeetCodeAnimation)

#### 关键点解析

- 二叉树的基本操作(遍历)
  > 不同的遍历算法差异还是蛮大的
- 如果非递归的话利用栈来简化操作

- 如果数据规模不大的话，建议使用递归

- 递归的问题需要注意两点，一个是终止条件，一个如何缩小规模

1. 终止条件，自然是当前这个元素是 null(链表也是一样)

2. 由于二叉树本身就是一个递归结构， 每次处理一个子树其实就是缩小了规模，
   难点在于如何合并结果，这里的合并结果其实就是`left.concat(mid).concat(right)`,
   mid 是一个具体的节点，left 和 right`递归求出即可`

#### 代码

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
  if (!root) return [];
  const stack = [root];
  const ret = [];
  let left = root.left;

  let item = null; // stack 中弹出的当前项

  while (left) {
    stack.push(left);
    left = left.left;
  }

  while ((item = stack.pop())) {
    ret.push(item.val);
    let t = item.right;

    while (t) {
      stack.push(t);
      t = t.left;
    }
  }

  return ret;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
// 中序： 左 -> 中 -> 右
// 前序： 中 -> 左 -> 右
// 后序： 左 -> 右 -> 中
// 迭代
var inorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根
  while (root || stack.length) {
    if (root) {
      stack.push(root);
      root = root.left;
    } else {
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};

// 递归
const res = [];
var inorderTraversal1 = function(root) {
  inorderTraversal1(root.left);
  res.push(root);
  inorderTraversal1(root.right);
  return res;
};
```

```js
let ans = [];

var inorderTraversal = function(root) {
  ans = [];
  helper(root);
  return ans;
};

function helper(node) {
  if (node == null) return;
  if (node.left) helper(node.left);
  ans.push(node.val);
  if (node.right) helper(node.right);
}
```

### [96].Unique-Binary-Search-Trees

```js
/**
 * https://leetcode.com/problems/unique-binary-search-trees/description/
 * Difficulty:Medium
 *
 * Given n, how many structurally unique BST's (binary search trees) that store values [1]...n?
 * For example,
 * Given n = 3, there are a total of 5 unique BST's.
 *
 *   1         3     3      2      1
 *    \       /     /      / \      \
 *    3      2     1      1   3      2
 *   /      /       \                 \
 *  2      1         2                 3
 *
 */

/**
 * G(n): the number of unique BST for a sequence of length n.
 * F(i, n), 1 <= i <= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.
 *
 * G(n) = F(1, n) + F(2, n) + ... + F(n, n).
 * G(0)=1, G(1)=[1].
 *
 * F(i, n) = G(i-1) * G(n-i)    1 <= i <= n
 * G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)
 *
 *
 *
 */

/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  var dp = [1, 1];

  for (var i = 2; i <= n; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      dp[i] += dp[j] * dp[i - j - 1];
    }
  }
  return dp[n];
};

console.log(numTrees(1));
console.log(numTrees(2));
console.log(numTrees(3));
```

### [98].validate-binary-search-tree

```js
// Given a binary tree, determine if it is a valid binary search tree (BST).

// Assume a BST is defined as follows:

// The left subtree of a node contains only nodes with keys less than the node's key.
// The right subtree of a node contains only nodes with keys greater than the node's key.
// Both the left and right subtrees must also be binary search trees.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

const binSearch = (tree, val) => {
  if (tree === null) return false;
  if (tree.val === val) return true;
  return val > tree.val ? binSearch(tree.right, val) : binSearch(tree.left, val);
};

const traverseAndValidate = (root, tree) => {
  if (tree === null || root === null) return true;
  if (!binSearch(root, tree.val)) return false;
  return traverseAndValidate(root, tree.left) && traverseAndValidate(root, tree.right);
};

export default function isValidBST(root) {
  const values = [];
  // BFS
  const queue = [];
  if (root) queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    values.push(item.val);
    if (item.left) queue.push(item.left);
    if (item.right) queue.push(item.right);
  }
  // Validate if BST has duplicates (BST does not allow duplicates)
  const set = new Set(values);
  if (set.size !== values.length) return false;
  return traverseAndValidate(root, root);
}
```

```js
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let isValid = true;

var isValidBST = function(root) {
  if (root == null) return true;
  helper(root);
  return isValid;
};

function helper(node) {
  if (node == null) return;
  if (node.left != null) {
    if (node.left.val > node.val) {
      isValid = false;
      return;
    }
    helper(node.left);
  }
  if (node.right != null) {
    if (node.right.val < node.val) {
      isValid = false;
      return;
    }
    helper(node.right);
  }
}

const tree = new TreeNode(0);
console.log(isValidBST(tree));

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  return validate(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
};

const validate = (node, min, max) => {
  if (!node) {
    return true;
  }

  if (node.val < min || node.val > max) {
    return false;
  }

  return validate(node.left, min, node.val - 1) && validate(node.right, node.val + 1, max);
};
```
