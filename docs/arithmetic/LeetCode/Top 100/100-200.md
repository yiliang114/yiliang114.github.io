---
layout: CustomPages
title: LeetCode-åˆé›† 100-200
date: 2020.09.04
aside: false
draft: true
---

### [101].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  return helper(root, root);
};

function helper(l, r) {
  if (l == null && r == null) return true;
  if (l == null || r == null) return false;
  return l.val == r.val && helper(l.left, r.right) && helper(l.right, r.left);
}
```

### [102].binary-tree-level-order-traversal

```
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

#### æ€è·¯

è¿™é“é¢˜å¯ä»¥å€ŸåŠ©`é˜Ÿåˆ—`å®ç°ï¼Œé¦–å…ˆæŠŠ root å…¥é˜Ÿï¼Œç„¶åå…¥é˜Ÿä¸€ä¸ªç‰¹æ®Šå…ƒç´  Null(æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸ)ã€‚

ç„¶åå°±æ˜¯ while(queue.length), æ¯æ¬¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å­èŠ‚ç‚¹(åœ¨è¿™é‡Œæ˜¯ left å’Œ right)æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚

ç„¶åä¸æ–­çš„å‡ºé˜Ÿï¼Œ å¦‚æœå‡ºé˜Ÿçš„æ˜¯ nullï¼Œåˆ™è¡¨å¼è¿™ä¸€å±‚å·²ç»ç»“æŸäº†ï¼Œæˆ‘ä»¬å°±ç»§ç»­ push ä¸€ä¸ª nullã€‚

å¦‚æœä¸å…¥é˜Ÿç‰¹æ®Šå…ƒç´  Null æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸï¼Œåˆ™åœ¨ while å¾ªç¯å¼€å§‹æ—¶ä¿å­˜å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ï¼Œä»¥ä¿è¯æ¯æ¬¡åªéå†ä¸€å±‚(å‚è€ƒä¸‹é¢çš„ C++ Code)ã€‚

> å¦‚æœé‡‡ç”¨é€’å½’æ–¹å¼ï¼Œåˆ™éœ€è¦å°†å½“å‰èŠ‚ç‚¹ï¼Œå½“å‰æ‰€åœ¨çš„ level ä»¥åŠç»“æœæ•°ç»„ä¼ é€’ç»™é€’å½’å‡½æ•°ã€‚åœ¨é€’å½’å‡½æ•°ä¸­ï¼Œå–å‡ºèŠ‚ç‚¹çš„å€¼ï¼Œæ·»åŠ åˆ° level å‚æ•°å¯¹åº”ç»“æœæ•°ç»„å…ƒç´ ä¸­(å‚è€ƒä¸‹é¢çš„ C++ Code)ã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

- æ³¨æ„å¡å…¥ null çš„æ—¶å€™ï¼Œåˆ¤æ–­ä¸€ä¸‹å½“å‰é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œä¸ç„¶ä¼šæ— é™å¾ªç¯

#### ä»£ç 

```js
// [102]. Binary Tree Level Order Traversal

// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

// For example:
// Given binary tree [3,9,20,null,null,15,7],

//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its level order traversal as:

// [
//   [3],
//   [9,20],
//   [15,7]
// ]

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
export default function levelOrder(root) {
  if (!root) return [];
  const queue = [];
  queue.push(root);
  const ans = [];
  const depths = new Map();
  depths.set(root, 0);
  let prev;
  let arr = [];
  while (queue.length) {
    const item = queue.shift();
    const depth = depths.get(item);
    if (!prev || (prev && depths.get(prev) !== depths.get(item))) {
      arr = [];
      ans.push(arr);
    }
    arr.push(item.val);
    if (item.left) {
      depths.set(item.left, depth + 1);
      queue.push(item.left);
    }
    if (item.right) {
      depths.set(item.right, depth + 1);
      queue.push(item.right);
    }
    prev = item;
  }
  return ans;
}
```

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  if (!root) return [];
  const items = []; // å­˜æ”¾æ‰€æœ‰èŠ‚ç‚¹
  const queue = [root, null]; // null ç®€åŒ–æ“ä½œ
  let levelNodes = []; // å­˜æ”¾æ¯ä¸€å±‚çš„èŠ‚ç‚¹

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      // ä¸€å±‚å·²ç»éå†å®Œäº†
      items.push(levelNodes);
      levelNodes = [];
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  let ans = [];
  helper(root, ans, 0);
  return ans;
};

function helper(node, ans, i) {
  if (node == null) return;
  if (i == ans.length) ans.push([]);
  ans[i].push(node.val);

  helper(node.left, ans, i + 1);
  helper(node.right, ans, i + 1);
}
```

### [103].binary-tree-zigzag-level-order-traversal

å’Œ leetcode 102 åŸºæœ¬æ˜¯ä¸€æ ·çš„ï¼Œæ€è·¯æ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚

```
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```

#### æ€è·¯

è¿™é“é¢˜å¯ä»¥å€ŸåŠ©`é˜Ÿåˆ—`å®ç°ï¼Œé¦–å…ˆæŠŠ root å…¥é˜Ÿï¼Œç„¶åå…¥é˜Ÿä¸€ä¸ªç‰¹æ®Šå…ƒç´  Null(æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸ)ã€‚

ç„¶åå°±æ˜¯ while(queue.length), æ¯æ¬¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å­èŠ‚ç‚¹(åœ¨è¿™é‡Œæ˜¯ left å’Œ right)æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚

ç„¶åä¸æ–­çš„å‡ºé˜Ÿï¼Œ å¦‚æœå‡ºé˜Ÿçš„æ˜¯ nullï¼Œåˆ™è¡¨å¼è¿™ä¸€å±‚å·²ç»ç»“æŸäº†ï¼Œæˆ‘ä»¬å°±ç»§ç»­ push ä¸€ä¸ª nullã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

#### ä»£ç 

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  if (!root) return [];
  const items = [];
  let isOdd = true;
  let levelNodes = [];

  const queue = [root, null];

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      if (!isOdd) {
        levelNodes = levelNodes.reverse();
      }
      items.push(levelNodes);
      levelNodes = [];
      isOdd = !isOdd;
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

### [104].äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

### [105].ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

#### å‚è€ƒç­”æ¡ˆ

é€’å½’æ„é€ äºŒå‰æ ‘ï¼Œæ—¶é—´å¤æ‚åº¦ O(n)

> å…³é”®åœ¨äºå‰åºéå†å’Œä¸­åºéå†çš„ç‰¹æ€§:

- å‰åºéå†ï¼šæ ¹èŠ‚ç‚¹æ˜¯é¦–å…ƒç´ 
- ä¸­åºéå†ï¼šæ ¹èŠ‚ç‚¹å·¦ä¾§çš„å€¼æ˜¯å…¶å·¦å­æ ‘ï¼Œå³ä¾§çš„å€¼æ˜¯å…¶å³å­æ ‘
  > å› æ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆè¦å¾—åˆ°ä»å‰åºåºåˆ—ä¸­è·å–æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†ä¸­åºåºåˆ—ï¼Œæ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®ï¼Œä»¥æ­¤ç›´åˆ°å…¶å·¦å­æ ‘å’Œå³å­æ ‘çš„èŒƒå›´ã€‚å½“æˆ‘ä»¬å¾—åˆ°å…¶å·¦å­æ ‘ä¹‹åï¼Œäº‹æƒ…å°±å¼€å§‹é‡å¤äº†ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦æ ¹æ®å‰åºåºåˆ—ä¸­æ‰¾åˆ°è¿™é¢—å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œç„¶åå†æ ¹æ®ä¸­åºåºåˆ—å¾—åˆ°è¿™é¢—å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼Œå³å­æ ‘åŒç†ã€‚å› æ­¤å®é™…ä¸Šå°±æ˜¯ä¸ªå›æº¯ã€‚

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  return helper(0, 0, inorder.length - 1, preorder, inorder);
};

function helper(preStart, inStart, inEnd, preorder, inorder) {
  if (preStart > preorder.length - 1 || inStart > inEnd) {
    return null;
  }
  let root = new TreeNode(preorder[preStart]);
  let inIndex = 0;
  for (let i = inStart; i <= inEnd; i++) {
    if (inorder[i] == root.val) {
      inIndex = i;
    }
  }
  root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
  root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
  return root;
}
```

### [110].å¹³è¡¡äºŒå‰æ ‘ Balanced Binary Tree DONE

```js
function maxDepth(root) {
  if (root == null) return 0;
  const l = maxDepth(root.left);
  const r = maxDepth(root.right);
  if (l === false || r === false) return false;
  // å¹³è¡¡äºŒå‰æ ‘æ˜¯ å·¦å³æ ‘çš„æ·±åº¦å·®å°äº 1 ï¼Ÿ
  if (Math.abs(l - r) > 1) return false;
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
  if (root === null) return true;
  return !!maxDepth(root);
};
```

### [104].maximum-depth-of-binary-tree

```
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.

```

#### æ€è·¯

ç”±äºæ ‘æ˜¯ä¸€ç§é€’å½’çš„æ•°æ®ç»“æ„ï¼Œå› æ­¤ç”¨é€’å½’å»è§£å†³çš„æ—¶å€™å¾€å¾€éå¸¸å®¹æ˜“ï¼Œè¿™é“é¢˜æ°å·§ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œ
ç”¨é€’å½’å®ç°çš„ä»£ç å¦‚ä¸‹ï¼š

```js
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

å¦‚æœä½¿ç”¨è¿­ä»£å‘¢ï¼Ÿ æˆ‘ä»¬é¦–å…ˆåº”è¯¥æƒ³åˆ°çš„æ˜¯æ ‘çš„å„ç§éå†ï¼Œç”±äºæˆ‘ä»¬æ±‚çš„æ˜¯æ·±åº¦ï¼Œå› æ­¤
ä½¿ç”¨å±‚æ¬¡éå†(BFS)æ˜¯éå¸¸åˆé€‚çš„ã€‚ æˆ‘ä»¬åªéœ€è¦è®°å½•æœ‰å¤šå°‘å±‚å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚ï¼Œæˆ–è€…åœ¨å¯¹æ¯å±‚è¿›è¡Œè¿­ä»£ä¹‹å‰ä¿å­˜å½“å‰é˜Ÿåˆ—å…ƒç´ çš„ä¸ªæ•°(å³å½“å‰å±‚æ‰€å«å…ƒç´ ä¸ªæ•°)

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

#### ä»£ç 

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;

  // å±‚æ¬¡éå† BFS
  let cur = root;
  const queue = [root, null];
  let depth = 1;

  while ((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      // æ³¨æ„âš ï¸ï¼š ä¸å¤„ç†ä¼šæ— é™å¾ªç¯ï¼Œè¿›è€Œå †æ ˆæº¢å‡º
      if (queue.length === 0) return depth;
      depth++;
      queue.push(null);
      continue;
    }
    const l = cur.left;
    const r = cur.right;

    if (l) queue.push(l);
    if (r) queue.push(r);
  }

  return depth;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root === null) return 0;
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

function Tree(arr) {
  const head = new TreeNode(null);
  if (arr.length === 0) return head;
  let cur = head;

  return cur;
}
```

```js
function TreeNode(val: any) {
  this.val = val;
  this.left = this.right = null;
}

export default function MaxDepth(root: TreeNode, count: number = 0): number {
  if (!root) return 0;

  const first = MaxDepth(root.left, count);
  const sec = MaxDepth(root.right, count);

  return Math.max(first, sec) + 1;
}

const t = new TreeNode(1);
const t2 = new TreeNode(2);
const t3 = new TreeNode(3);

//           t1
//         /   \
//       t2     null
//      / \
//   null  t3

t.left = t2.right = t3;

// expect(MaxDepth(t)).to.equal(2);
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### [114].flatten-binary-tree-to-linked-list

```js
function preorderTraversal(root) {
  if (!root) return [];

  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = null;

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

### [121].ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  // ç›´æ¥è®¤ä¸º prices length å¤§äº 2
  let max = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    for (let j = i + 1; j < prices.length; j++) {
      const target = prices[j] - prices[i];
      if (target > max) {
        max = target;
      }
    }
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
console.log(maxProfit([1, 4, 2]));
```

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let maxProfit = 0;
  let minPrice = Number.MAX_SAFE_INTEGER;
  for (let i = 0; i < prices.length; i++) {
    minPrice = Math.min(minPrice, prices[i]);
    maxProfit = Math.max(maxProfit, prices[i] - minPrice);
  }
  return maxProfit;
};
```

### [121].best-time-to-buy-and-sell-stock

```
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

#### æ€è·¯

ç”±äºæˆ‘ä»¬æ˜¯æƒ³è·å–åˆ°æœ€å¤§çš„åˆ©æ¶¦ï¼Œæˆ‘ä»¬çš„ç­–ç•¥åº”è¯¥æ˜¯ä½ç‚¹ä¹°å…¥ï¼Œé«˜ç‚¹å–å‡ºã€‚

ç”±äºé¢˜ç›®å¯¹äºäº¤æ˜“æ¬¡æ•°æœ‰é™åˆ¶ï¼Œåªèƒ½äº¤æ˜“ä¸€æ¬¡ï¼Œå› æ­¤é—®é¢˜çš„æœ¬è´¨å…¶å®å°±æ˜¯æ±‚æ³¢å³°æµªè°·çš„å·®å€¼çš„æœ€å¤§å€¼ã€‚

ç”¨å›¾è¡¨ç¤ºçš„è¯å°±æ˜¯è¿™æ ·ï¼š

#### å…³é”®ç‚¹è§£æ

- è¿™ç±»é¢˜åªè¦ä½ åœ¨å¿ƒä¸­(æˆ–è€…åˆ«çš„åœ°æ–¹)ç”»å‡ºä¸Šé¢è¿™ç§å›¾å°±å¾ˆå®¹æ˜“è§£å†³

#### ä»£ç 

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let min = prices[0];
  let profit = 0;
  // 7 1 5 3 6 4
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = Math.max(profit, prices[i] - min);
    } else {
      min = Math.min(min, prices[i]);
    }
  }

  return profit;
};
```

Python Code:

```python
### åº”ç”¨Kadane's algorithms
class Solution:
    def maxProfit(self, prices: 'List[int]') -> int:
        """
        step by step
        """
        ### error case
        if len(prices) < 1:
            return 0

        ### caluate the daily gains, break into a subarray problem
        gains = [prices[i]-prices[i-1] for i in range(1, len(prices))]

        loc_max = global_max = 0 #not gains[0] in case of negative
        for i in range(len(gains)):
            loc_max = max(loc_max + gains[i], gains[i])
            if loc_max > global_max:
                global_max = loc_max
"""
Runtime: 48 ms, faster than 34.50% of Python3 online submissions for Best Time to Buy and Sell Stock.
Memory Usage: 14.1 MB, less than 10.26% of Python3 online submissions for Best Time to Buy and Sell Stock.
"""
```

### [124].binary-tree-maximum-path-sum

```
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

#### æ€è·¯

è¿™é“é¢˜ç›®çš„ path è®©æˆ‘è¯¯è§£äº†ï¼Œç„¶åæµªè´¹äº†å¾ˆå¤šæ—¶é—´æ¥è§£è¿™é“é¢˜
æˆ‘è§‰å¾— leetcode ç»™çš„ demo å¤ªå°‘äº†ï¼Œä¸è¶³ä»¥è®©æˆ‘ç†è§£ path çš„æ¦‚å¿µ
å› æ­¤æˆ‘è¿™é‡Œè‡ªå·±ç”»äº†ä¸€ä¸ªå›¾ï¼Œæ¥è¡¥å……ä¸€ä¸‹ï¼Œå¸®åŠ©å¤§å®¶ç†è§£ path çš„æ¦‚å¿µï¼Œä¸è¦åƒæˆ‘ä¸€æ ·ç†è§£é”™å•¦ã€‚

é¦–å…ˆæ˜¯å®˜ç½‘ç»™çš„ä¸¤ä¸ªä¾‹å­ï¼š

æ¥ç€æ˜¯æˆ‘è‡ªå·±ç”»çš„ä¸€ä¸ªä¾‹å­ï¼š

å¤§å®¶å¯ä»¥ç»“åˆä¸Šé¢çš„ demo æ¥ç»§ç»­ç†è§£ä¸€ä¸‹ pathï¼Œ é™¤éä½ ç†è§£äº† pathï¼Œå¦åˆ™ä¸è¦å¾€ä¸‹çœ‹ã€‚

æ ‘çš„é¢˜ç›®ï¼ŒåŸºæœ¬éƒ½æ˜¯è€ƒå¯Ÿé€’å½’æ€æƒ³çš„ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦æ€è€ƒå¦‚ä½•å»å®šä¹‰æˆ‘ä»¬çš„é€’å½’å‡½æ•°ï¼Œ
åœ¨è¿™é‡Œæˆ‘å®šä¹‰äº†ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯ï¼Œ`è¿”å›ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„MathPath`
ä½†æ˜¯æœ‰ä¸¤ä¸ªæ¡ä»¶:

1.  ç¬¬ä¸€æ˜¯è·ŸèŠ‚ç‚¹å¿…é¡»é€‰æ‹©
2.  ç¬¬äºŒæ˜¯å·¦å³å­æ ‘åªèƒ½é€‰æ‹©ä¸€ä¸ª

ä¸ºä»€ä¹ˆè¦æœ‰è¿™ä¸¤ä¸ªæ¡ä»¶?

æˆ‘çš„æƒ³æ³•æ˜¯åŸé—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºï¼š

ä»¥æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åˆ†åˆ«æ±‚å‡º max pathï¼Œæœ€åè®¡ç®—æœ€å¤§å€¼,å› æ­¤ç¬¬ä¸€ä¸ªæ¡ä»¶éœ€è¦æ»¡è¶³.

å¯¹äºç¬¬äºŒä¸ªï¼Œç”±äºé€’å½’å‡½æ•°å­èŠ‚ç‚¹çš„è¿”å›å€¼ä¼šè¢«çˆ¶èŠ‚ç‚¹ä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬å¦‚æœä¸¤ä¸ªå­©å­éƒ½é€‰æ‹©äº†
å°±ä¸ç¬¦åˆ max path çš„å®šä¹‰äº†ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘æ²¡æœ‰ç†è§£é¢˜æ„ï¼Œç»•äº†å¾ˆå¤§å¼¯å­çš„åŸå› ã€‚

å› æ­¤æˆ‘çš„åšæ³•å°±æ˜¯ä¸æ–­è°ƒç”¨é€’å½’å‡½æ•°ï¼Œç„¶ååœ¨è°ƒç”¨è¿‡ç¨‹ä¸­ä¸æ–­è®¡ç®—å’Œæ›´æ–° maxï¼Œæœ€ååœ¨ä¸»å‡½æ•°ä¸­å°† max è¿”å›å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- é€’å½’
- ç†è§£é¢˜ç›®ä¸­çš„ path å®šä¹‰

#### ä»£ç 

```js
function helper(node, payload) {
  if (node === null) return 0;

  const l = helper(node.left, payload);
  const r = helper(node.right, payload);

  payload.max = Math.max(node.val + Math.max(0, l) + Math.max(0, r), payload.max);

  return node.val + Math.max(l, r, 0);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
  if (root === null) return 0;
  const payload = {
    max: root.val,
  };
  helper(root, payload);
  return payload.max;
};
```

### [124].

```js
let maxValue;

var maxPathSum = function(root) {
  maxValue = Number.MIN_SAFE_INTEGER;
  find(root);
  return maxValue;
};

function find(node) {
  if (node == null) return 0;
  let left = Math.max(0, find(node.left)); // è·å–å·¦ä¾§æœ€å¤§å’Œ
  let right = Math.max(0, find(node.right)); // è·å–å³ä¾§æœ€å¤§å’Œ
  maxValue = Math.max(maxValue, left + right + node.val); // è·å¾—æœ€å¤§å€¼
  return Math.max(left, right) + node.val; // è¿”å›æœ€å¤§å€¼
}
```

### [128].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  if (nums.length == 0) return 0;
  let count = 0,
    max = 1;
  for (let i = 0, len = nums.length; i < len; i++) {
    let min = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[min]) min = j;
    }
    swap(nums, i, min);
    if (i != 0 && nums[i] == nums[i - 1] + 1) {
      count++;
      max = Math.max(max, count);
    } else if (nums[i] == nums[i - 1]) {
    } else {
      count = 1;
    }
  }
  return max;
};

function swap(nums, a, b) {
  let x = nums[a];
  nums[a] = nums[b];
  nums[b] = x;
}

console.log(longestConsecutive([1, 2, 0, 1]));
```

### [128].longest-consecutive-sequence

```
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Accepted
200,786
Submissions
485,346

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“æœ€æœ€é•¿è¿ç»­æ•°å­—åºåˆ—é•¿åº¦çš„é¢˜ç›®ï¼Œ å®˜ç½‘ç»™å‡ºçš„éš¾åº¦æ˜¯`hard`.

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯å…ˆæ’åºï¼Œç„¶åç”¨ä¸€ä¸ªå˜é‡è®°å½•æœ€å¤§å€¼ï¼Œéå†å»æ›´æ–°æœ€å¤§å€¼å³å¯ï¼Œ

ä»£ç ï¼š

```js
if (nums.length === 0) return 0;
let count = 1;
let maxCount = 1;
// è¿™é‡Œå…¶å®å¯ä»¥ä¸éœ€è¦æ’åºï¼Œè¿™ä¹ˆåšåªä¸è¿‡æ˜¯ä¸ºäº†æ–¹ä¾¿ç†è§£
nums = [...new Set(nums)].sort((a, b) => a - b);
for (let i = 0; i < nums.length - 1; i++) {
  if (nums[i + 1] - nums[i] === 1) {
    count++;
  } else {
    if (count > maxCount) {
      maxCount = count;
    }
    count = 1;
  }
}
return Math.max(count, maxCount);
```

ä½†æ˜¯éœ€è¦æ’åºæ—¶é—´å¤æ‚åº¦ä¼šä¸Šå‡ï¼Œé¢˜ç›®è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n),
é‚£ä¹ˆæˆ‘ä»¬å…¶å®å¯ä»¥ä¸ç”¨æ’åºå»è§£å†³çš„ã€‚

æ€è·¯å°±æ˜¯å°†ä¹‹å‰â€æ’åºä¹‹åï¼Œé€šè¿‡æ¯”è¾ƒå‰åå…ƒç´ æ˜¯å¦ç›¸å·® 1 æ¥åˆ¤æ–­æ˜¯å¦è¿ç»­â€œçš„æ€è·¯æ”¹ä¸º
ä¸æ’åºè€Œæ˜¯`ç›´æ¥éå†ï¼Œç„¶ååœ¨å†…éƒ¨å¾ªç¯é‡Œé¢æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `ï¼Œä½†æ˜¯é©¬ä¸Šæœ‰ä¸€ä¸ª
é—®é¢˜ï¼Œå†…éƒ¨æˆ‘ä»¬`æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `çš„è¿‡ç¨‹å¦‚æœä½¿ç”¨æ•°ç»„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n),
é‚£ä¹ˆæ€»ä½“çš„å¤æ‚åº¦å°±æ˜¯ O(n^2)ï¼Œå®Œå…¨ä¸å¯ä»¥æ¥å—ã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿ

æˆ‘ä»¬æ¢ä¸ªæ€è·¯ï¼Œç”¨ç©ºé—´æ¥æ¢æ—¶é—´ã€‚æ¯”å¦‚ç”¨ç±»ä¼¼äº hashmap è¿™æ ·çš„æ•°æ®ç»“æ„ä¼˜åŒ–æŸ¥è¯¢éƒ¨åˆ†ï¼Œå°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ° O(1), ä»£ç è§åé¢`ä»£ç éƒ¨åˆ†`

#### å…³é”®ç‚¹è§£æ

- ç©ºé—´æ¢æ—¶é—´

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  nums = new Set(nums);
  let max = 0;
  let y = 0;
  nums.forEach(x => {
    // è¯´æ˜xæ˜¯è¿ç»­åºåˆ—çš„å¼€å¤´å…ƒç´ 
    if (!nums.has(x - 1)) {
      y = x + 1;
      while (nums.has(y)) {
        y = y + 1;
      }
      max = Math.max(max, y - x); // y - x å°±æ˜¯ä»xå¼€å§‹åˆ°æœ€åæœ‰å¤šå°‘è¿ç»­çš„æ•°å­—
    }
  });
  return max;
};
```

### [134].gas-station

```js
function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad æ—¶é—´å¤æ‚åº¦O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution æ—¶é—´å¤æ‚åº¦O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // å¦‚æœremain < 0, è¯´æ˜ä»startåˆ°ièµ°ä¸é€š
    // å¹¶ä¸”ä»startåˆ°ièµ°ä¸é€šï¼Œé‚£ä¹ˆæ‰€æœ‰çš„solutionä¸­åŒ…å«startåˆ°içš„è‚¯å®šéƒ½èµ°ä¸é€š
    // å› æ­¤æˆ‘ä»¬é‡æ–°ä»i + 1å¼€å§‹ä½œä¸ºstart
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // äº‹å®ä¸Šï¼Œæˆ‘ä»¬éå†ä¸€éï¼Œä¹Ÿå°±ç¡®å®šäº†æ¯ä¸€ä¸ªå…ƒç´ ä½œä¸ºstartæ˜¯å¦å¯ä»¥èµ°å®Œä¸€åœˆ

  // å¦‚æœcostæ€»å’Œå¤§äºgasæ€»å’Œï¼Œæ— è®ºå¦‚ä½•ä¹Ÿæ— æ³•èµ°åˆ°ç»ˆç‚¹
  return total >= 0 ? start : -1;
};
```

### [136].Single-Number

```js
var singleNumber = function(nums) {
  var a = 0;
  for (let val of nums) a ^= val;
  return a;
};
```

```js
// ç»™å®šä¸€ä¸ªéç©ºæ•´æ•°æ•°ç»„ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚

// è¯´æ˜ï¼š

// ä½ çš„ç®—æ³•åº”è¯¥å…·æœ‰çº¿æ€§æ—¶é—´å¤æ‚åº¦ã€‚ ä½ å¯ä»¥ä¸ä½¿ç”¨é¢å¤–ç©ºé—´æ¥å®ç°å—ï¼Ÿ

// ç¤ºä¾‹ 1:

// è¾“å…¥: [2,2,1]
// è¾“å‡º: 1
// ç¤ºä¾‹Â 2:

// è¾“å…¥: [4,1,2,1,2]
// è¾“å‡º: 4

// æ€è·¯
// æ ‡ç­¾ï¼šä½è¿ç®—
// æœ¬é¢˜æ ¹æ®é¢˜æ„ï¼Œçº¿æ€§æ—¶é—´å¤æ‚åº¦ O(n)O(n)ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ä½¿ç”¨ Hash æ˜ å°„æ¥è¿›è¡Œè®¡ç®—ï¼Œéå†ä¸€æ¬¡åç»“æŸå¾—åˆ°ç»“æœï¼Œä½†æ˜¯åœ¨ç©ºé—´å¤æ‚åº¦ä¸Šä¼šè¾¾åˆ° O(n)O(n)ï¼Œéœ€è¦ä½¿ç”¨è¾ƒå¤šçš„é¢å¤–ç©ºé—´
// æ—¢æ»¡è¶³æ—¶é—´å¤æ‚åº¦åˆæ»¡è¶³ç©ºé—´å¤æ‚åº¦ï¼Œå°±è¦æåˆ°ä½è¿ç®—ä¸­çš„å¼‚æˆ–è¿ç®— XORï¼Œä¸»è¦å› ä¸ºå¼‚æˆ–è¿ç®—æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š

//  [1]. ä¸€ä¸ªæ•°å’Œ 0 åš XOR è¿ç®—ç­‰äºæœ¬èº«ï¼ša^0 = a
//  [2]. ä¸€ä¸ªæ•°å’Œå…¶æœ¬èº«åš XOR è¿ç®—ç­‰äº 0ï¼ša^a = 0
//  [3]. XOR è¿ç®—æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼ša^b^a = (a^a)^b = 0^b = b

// æ•…è€Œåœ¨ä»¥ä¸Šçš„åŸºç¡€æ¡ä»¶ä¸Šï¼Œå°†æ‰€æœ‰æ•°å­—æŒ‰ç…§é¡ºåºåšæŠ‘æˆ–è¿ç®—ï¼Œæœ€åå‰©ä¸‹çš„ç»“æœå³ä¸ºå”¯ä¸€çš„æ•°å­—
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)

// reduce æ€§èƒ½æ€§å¯¹å¥½äº›
// 84 ms	40.2 MB
var singleNumber = function(nums = []) {
  return nums.reduce((ret, n) => ret ^ n, 0);
};

// 88 ms	40.8 MB
var singleNumber1 = function(nums) {
  let ans = 0;
  for (const num of nums) {
    ans ^= num;
  }
  return ans;
};

export default function SingleNumber2(nums = []) {
  for (let i = 0; i < nums.length; i++) {
    if (set.has(nums[i])) {
      set.delete(nums[i]);
    } else {
      set.add(nums[i]);
    }
  }

  const item = Array.from(set)[0];
  set.clear();

  return item;
}

console.log(singleNumber([1, 2, 2]) == 1);
console.log(singleNumber([1, 2, 1]) == 2);
```

### [136].single-number

```
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
```

#### æ€è·¯

æ ¹æ®é¢˜ç›®æè¿°ï¼Œç”±äºåŠ ä¸Šäº†æ—¶é—´å¤æ‚åº¦å¿…é¡»æ˜¯ O(n)ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦ä¸º O(1)çš„æ¡ä»¶ï¼Œå› æ­¤ä¸èƒ½ç”¨æ’åºæ–¹æ³•ï¼Œä¹Ÿä¸èƒ½ä½¿ç”¨ map æ•°æ®ç»“æ„ã€‚

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨äºŒè¿›åˆ¶å¼‚æˆ–çš„æ€§è´¨æ¥å®Œæˆï¼Œå°†æ‰€æœ‰æ•°å­—å¼‚æˆ–å³å¾—åˆ°å”¯ä¸€å‡ºç°çš„æ•°å­—ã€‚

#### å…³é”®ç‚¹

1. å¼‚æˆ–çš„æ€§è´¨
   ä¸¤ä¸ªæ•°å­—å¼‚æˆ–çš„ç»“æœ`a^b`æ˜¯å°† a å’Œ b çš„äºŒè¿›åˆ¶æ¯ä¸€ä½è¿›è¡Œè¿ç®—ï¼Œå¾—å‡ºçš„æ•°å­—ã€‚ è¿ç®—çš„é€»è¾‘æ˜¯
   å¦‚æœåŒä¸€ä½çš„æ•°å­—ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1

2. å¼‚æˆ–çš„è§„å¾‹

- ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º`0`

- ä»»ä½•æ•°å’Œ 0 å¼‚æˆ–æ˜¯`æœ¬èº«`

3. å¾ˆå¤šäººåªæ˜¯è®°å¾—å¼‚æˆ–çš„æ€§è´¨å’Œè§„å¾‹ï¼Œä½†æ˜¯ç¼ºä¹å¯¹å…¶æœ¬è´¨çš„ç†è§£ï¼Œå¯¼è‡´å¾ˆéš¾æƒ³åˆ°è¿™ç§è§£æ³•(æˆ‘æœ¬äººä¹Ÿæ²¡æƒ³åˆ°)

4. bit è¿ç®—

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let ret = 0;
  for (let index = 0; index < nums.length; index++) {
    const element = nums[index];
    ret = ret ^ element;
  }
  return ret;
};
```

#### å»¶ä¼¸

æœ‰ä¸€ä¸ª n ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œé™¤äº†ä¸¤ä¸ªæ•°åªå‡ºç°ä¸€æ¬¡å¤–ï¼Œå…¶ä½™å…ƒç´ éƒ½å‡ºç°ä¸¤æ¬¡ï¼Œè®©ä½ æ‰¾å‡ºè¿™ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°åˆ†åˆ«æ˜¯å‡ ï¼Œè¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n) ä¸”å†å¼€è¾Ÿçš„å†…å­˜ç©ºé—´å›ºå®š(ä¸ n æ— å…³)ã€‚

å’Œä¸Šé¢ä¸€æ ·ï¼Œåªæ˜¯è¿™æ¬¡ä¸æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä¸¤ä¸ªæ•°å­—ã€‚è¿˜æ˜¯æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œæˆ‘ä»¬è¿›è¡Œä¸€æ¬¡å…¨å‘˜å¼‚æˆ–æ“ä½œï¼Œ
å¾—åˆ°çš„ç»“æœå°±æ˜¯é‚£ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„ä¸åŒçš„æ•°å­—çš„å¼‚æˆ–ç»“æœã€‚

æˆ‘ä»¬åˆšæ‰è®²äº†å¼‚æˆ–çš„è§„å¾‹ä¸­æœ‰ä¸€ä¸ª`ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º0`ï¼Œ å› æ­¤æˆ‘ä»¬çš„æ€è·¯æ˜¯èƒ½ä¸èƒ½å°†è¿™ä¸¤ä¸ªä¸åŒçš„æ•°å­—åˆ†æˆä¸¤ç»„ A å’Œ Bã€‚
åˆ†ç»„éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶.

1. ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—åˆ†æˆä¸åŒç»„

2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„

è¿™æ ·æ¯ä¸€ç»„çš„æ•°æ®è¿›è¡Œå¼‚æˆ–å³å¯å¾—åˆ°é‚£ä¸¤ä¸ªæ•°å­—ã€‚

é—®é¢˜çš„å…³é”®ç‚¹æ˜¯æˆ‘ä»¬æ€ä¹ˆè¿›è¡Œåˆ†ç»„å‘¢ï¼Ÿ

ç”±äºå¼‚æˆ–çš„æ€§è´¨æ˜¯ï¼ŒåŒä¸€ä½ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1. æˆ‘ä»¬å°†æ‰€æœ‰æ•°å­—å¼‚æˆ–çš„ç»“æœä¸€å®šä¸æ˜¯ 0ï¼Œä¹Ÿå°±æ˜¯è¯´è‡³å°‘æœ‰ä¸€ä½æ˜¯ 1.

æˆ‘ä»¬éšä¾¿å–ä¸€ä¸ªï¼Œ åˆ†ç»„çš„ä¾æ®å°±æ¥äº†ï¼Œ å°±æ˜¯ä½ å–çš„é‚£ä¸€ä½æ˜¯ 0 åˆ†æˆ 1 ç»„ï¼Œé‚£ä¸€ä½æ˜¯ 1 çš„åˆ†æˆä¸€ç»„ã€‚
è¿™æ ·è‚¯å®šèƒ½ä¿è¯`2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„`, ä¸åŒçš„æ•°å­—ä¼šè¢«åˆ†æˆä¸åŒç»„ä¹ˆã€‚ å¾ˆæ˜æ˜¾å½“ç„¶å¯ä»¥ï¼Œ å› æ­¤æˆ‘ä»¬é€‰æ‹©æ˜¯ 1ï¼Œä¹Ÿå°±æ˜¯
è¯´`ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—`åœ¨é‚£ä¸€ä½ä¸€å®šæ˜¯ä¸åŒçš„ï¼Œå› æ­¤ä¸¤ä¸ªç‹¬ç‰¹å…ƒç´ ä¸€å®šä¼šè¢«åˆ†æˆä¸åŒç»„ã€‚

Doneï¼

### [139].word-break

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

#### æ€è·¯

è¿™é“é¢˜æ˜¯ç»™å®šä¸€ä¸ªå­—å…¸å’Œä¸€ä¸ªå¥å­ï¼Œåˆ¤æ–­è¯¥å¥å­æ˜¯å¦å¯ä»¥ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„å‡ºæ¥ï¼Œä¸€ä¸ªå•è¯å¯ä»¥ç”¨å¤šæ¬¡ã€‚

æš´åŠ›çš„æ–¹æ³•æ˜¯æ— è§£çš„ï¼Œå¤æ‚åº¦æå…¶é«˜ã€‚ æˆ‘ä»¬è€ƒè™‘å…¶æ˜¯å¦å¯ä»¥æ‹†åˆ†ä¸ºå°é—®é¢˜æ¥è§£å†³ã€‚
å¯¹äºé—®é¢˜`(s, wordDict)` æˆ‘ä»¬æ˜¯å¦å¯ä»¥ç”¨(s', wordDict) æ¥è§£å†³ã€‚ å…¶ä¸­ s' æ˜¯ s çš„å­åºåˆ—ï¼Œ
å½“ s'å˜æˆå¯»å¸¸(é•¿åº¦ä¸º 0)çš„æ—¶å€™é—®é¢˜å°±è§£å†³äº†ã€‚ æˆ‘ä»¬çŠ¶æ€è½¬ç§»æ–¹ç¨‹å˜æˆäº†è¿™é“é¢˜çš„éš¾ç‚¹ã€‚

æˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ªæ•°ç»„ dp, dp[i]ä»£è¡¨ å­—ç¬¦ä¸² s.substring(0, i) èƒ½å¦ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„æˆï¼Œ
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæˆ‘ä»¬æ— æ³•å»ºç«‹ dp[i] å’Œ dp[i - 1] çš„å…³ç³»ï¼Œ
æˆ‘ä»¬å¯ä»¥å»ºç«‹çš„æ˜¯ dp[i - word.length] å’Œ dp[i] çš„å…³ç³»ã€‚

æˆ‘ä»¬ç”¨å›¾æ¥æ„Ÿå—ä¸€ä¸‹ï¼š

æ²¡æœ‰æ˜ç™½ä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬åˆ†æ­¥éª¤è§£è¯»ä¸€ä¸‹ï¼š

(ä»¥ä¸‹çš„å›¾å·¦è¾¹éƒ½ä»£è¡¨ sï¼Œå³è¾¹éƒ½æ˜¯ dictï¼Œç°è‰²ä»£è¡¨æ²¡æœ‰å¤„ç†çš„å­—ç¬¦ï¼Œç»¿è‰²ä»£è¡¨åŒ¹é…æˆåŠŸï¼Œçº¢è‰²ä»£è¡¨åŒ¹é…å¤±è´¥)

ä¸Šé¢åˆ†æ­¥è§£é‡Šäº†ç®—æ³•çš„åŸºæœ¬è¿‡ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬æ„Ÿæ€§è®¤è¯†ä¸‹è¿™é“é¢˜ï¼Œæˆ‘æŠŠå®ƒæ¯”å–»ä¸º
ä½ æ­£åœ¨`å¾€ä¸€ä¸ªè€å¼æ‰‹ç”µç­’ğŸ”¦ä¸­è£…ç”µæ± `

#### ä»£ç 

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  const dp = Array(s.length + 1);
  dp[0] = true;
  for (let i = 0; i < s.length + 1; i++) {
    for (let word of wordDict) {
      if (dp[i - word.length] && word.length <= i) {
        if (s.substring(i - word.length, i) === word) {
          dp[i] = true;
        }
      }
    }
  }

  return dp[s.length] || false;
};
```

### [139].Word-Break

```js
/**
 * https://leetcode.com/problems/word-break/description/
 * Difficulty:Medium
 *
 * Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.
 *
 * For example, given
 * s = "leetcode",
 * dict = ["leet", "code"].
 * Return true because "leetcode" can be segmented as "leet code".
 */

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var n = s.length;

  var dp = [true];
  for (var i = 1; i < n + 1; i++) {
    for (var j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) > -1) {
        dp[i] = true;
        break;
      } else {
        dp[i] = false;
      }
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(wordBreak('leetcode', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'e']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'leetco']));
```

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  let dp = new Array(s.length + 1);
  dp.fill(false);
  dp[0] = true;

  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.includes(s.slice(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[s.length];
};
```

### [140].

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  if (canStringBeSegmented(s, wordDict)) {
    return getAllPossibleSegments(s, wordDict, {});
  } else {
    return [];
  }
};
// DFS
function getAllPossibleSegments(s, dict, map) {
  if (s in map) return map[s];
  const result = [];
  if (dict.includes(s)) result.push(s);
  for (let i = 1; i < s.length; i++) {
    const left = s.substring(0, i);
    const right = s.substring(i);
    if (dict.includes(left) && containsSuffix(dict, right)) {
      for (let segment of getAllPossibleSegments(right, dict, map)) {
        result.push(`${left} ${segment}`);
      }
    }
  }
  map[s] = result;
  return result;
}

function containsSuffix(dict, str) {
  for (let i = 0; i < str.length; i++) {
    if (dict.includes(str.substring(i))) return true;
  }
  return false;
}
// ä½¿ç”¨ dp åˆ¤æ–­èƒ½å¦
function canStringBeSegmented(inputStr, inputDict) {
  const memTable = Array(inputStr.length + 1).fill(false);
  memTable[0] = true;

  for (let i = 1; i <= inputStr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (memTable[j] && inputDict.includes(inputStr.substring(j, i))) {
        memTable[i] = true;
        break;
      }
    }
  }
  return memTable[inputStr.length];
}
```

### [141].

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

### [141].linked-list-cycle

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */

//  å¿«æ…¢æŒ‡é’ˆã€‚ å¦‚æœæœ‰ç¯ï¼Œå¿«æŒ‡é’ˆä¸€å®šèƒ½è¿½ä¸Šæ…¢æŒ‡é’ˆ
var hasCycle1 = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // å¿«æŒ‡é’ˆä¸€æ¬¡ç§»åŠ¨ä¸¤ä¸ª
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};

// å“ˆå¸Œè¡¨ Set add has æ¥æŸ¥è¯¢
// ç‰ºç‰²äº†ç©ºé—´æ¢æ—¶é—´
var hasCycle = function(head) {
  const set = new Set();
  let curr = head;
  set.add(curr);
  while (curr) {
    if (set.has(curr.next)) {
      return true;
    }
    set.add(curr.next);
    curr = curr.next;
  }
  return false;
};
```

```js
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### [146].

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.map = {};
  this.set = new Set();
  this.capacity = capacity;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.map[key]) {
    // key already exist, we need to delete the key and add to end
    this.set.delete(key);
    this.set.add(key);
    return this.map[key];
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.map[key]) {
    // remove this key and add back in set, update in hashmap
    this.set.delete(key);
  } else {
    if (this.set.size >= this.capacity) {
      var it = this.set.values();
      var oldKey = it.next().value;
      delete this.map[oldKey];
      this.set.delete(oldKey);
    }
  }
  this.set.add(key);
  this.map[key] = value;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = Object.create(LRUCache).createNew(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [146].lru-cache

```
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

```

#### æ€è·¯

ç”±äºæ˜¯ä¿ç•™æ˜¯æœ€è¿‘ä½¿ç”¨çš„ N æ¡æ•°æ®ï¼Œè¿™å°±å’Œé˜Ÿåˆ—çš„ç‰¹æ€§å¾ˆç¬¦åˆï¼Œ å…ˆè¿›å…¥é˜Ÿåˆ—çš„ï¼Œå…ˆå‡ºé˜Ÿåˆ—ã€‚

å› æ­¤æ€è·¯å°±æ˜¯ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥è®°å½•ç›®å‰ç¼“å­˜çš„æ‰€æœ‰ keyï¼Œ æ¯æ¬¡ push éƒ½è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœ
è¶…å‡ºæœ€å¤§å®¹é‡é™åˆ¶åˆ™è¿›è¡Œæ¸…é™¤ç¼“å­˜çš„æ“ä½œï¼Œ å…·ä½“æ¸…é™¤è°å°±æŒ‰ç…§åˆšæ‰è¯´çš„é˜Ÿåˆ—æ–¹å¼è¿›è¡Œå¤„ç†ï¼ŒåŒæ—¶å¯¹ key è¿›è¡Œå…¥é˜Ÿæ“ä½œã€‚

get çš„æ—¶å€™ï¼Œå¦‚æœç¼“å­˜ä¸­æœ‰ï¼Œåˆ™è°ƒæ•´é˜Ÿåˆ—(å…·ä½“æ“ä½œä¸ºåˆ é™¤æŒ‡å®šå…ƒç´ å’Œå…¥é˜Ÿä¸¤ä¸ªæ“ä½œ)ã€‚ ç¼“å­˜ä¸­æ²¡æœ‰åˆ™è¿”å›-1

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—ç®€åŒ–æ“ä½œ

- é˜Ÿåˆ—çš„æ“ä½œæ˜¯è¿™é“é¢˜çš„çµé­‚ï¼Œ å¾ˆå®¹æ˜“å°‘è€ƒè™‘æƒ…å†µ

#### ä»£ç 

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.cache = {};
  this.capacity = capacity;
  this.size = 0;
  this.queue = [];
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit !== undefined) {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
    return hit;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  const hit = this.cache[key];

  // update cache
  this.cache[key] = value;

  if (!hit) {
    // invalid cache and resize size;
    if (this.size === this.capacity) {
      // invalid cache
      const key = this.queue.shift();
      this.cache[key] = undefined;
    } else {
      this.size = this.size + 1;
    }
    this.queue.push(key);
  } else {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
  }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [148].

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
  if (head == null || head.next == null) return head;

  let prev = null,
    slow = head,
    fast = head;
  while (fast != null && fase.next != null) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }

  prev.next = null;

  let l1 = sortList(head);
  let l2 = sortList(slow);

  return merge(l1, l2);
};

function merge(l1, l2) {
  let l = new ListNode(0),
    p = l;

  while (l1 != null && l2 != null) {
    if (l1.val < l2.val) {
      p.next = l1;
      l1 = l1.next;
    } else {
      p.next = l2;
      l2 = l2.next;
    }
    p = p.next;
  }

  if (l1 != null) p.next = l1;

  if (l2 != null) p.next = l2;

  return l.next;
}
```

### [150].evaluate-reverse-polish-notation

```
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
```

#### æ€è·¯

é€†æ³¢å…°è¡¨è¾¾å¼åˆå«åšåç¼€è¡¨è¾¾å¼ã€‚åœ¨é€šå¸¸çš„è¡¨è¾¾å¼ä¸­ï¼ŒäºŒå…ƒè¿ç®—ç¬¦æ€»æ˜¯ç½®äºä¸ä¹‹ç›¸å…³çš„ä¸¤ä¸ªè¿ç®—å¯¹è±¡ä¹‹é—´ï¼Œè¿™ç§è¡¨ç¤ºæ³•ä¹Ÿç§°ä¸º`ä¸­ç¼€è¡¨ç¤º`ã€‚

æ³¢å…°é€»è¾‘å­¦å®¶ J.Lukasiewicz äº 1929 å¹´æå‡ºäº†å¦ä¸€ç§è¡¨ç¤ºè¡¨è¾¾å¼çš„æ–¹æ³•ï¼ŒæŒ‰æ­¤æ–¹æ³•ï¼Œæ¯ä¸€è¿ç®—ç¬¦éƒ½ç½®äºå…¶è¿ç®—å¯¹è±¡ä¹‹åï¼Œæ•…ç§°ä¸º`åç¼€è¡¨ç¤º`ã€‚

> é€†æ³¢å…°è¡¨è¾¾å¼æ˜¯ä¸€ç§ååˆ†æœ‰ç”¨çš„è¡¨è¾¾å¼ï¼Œå®ƒå°†å¤æ‚è¡¨è¾¾å¼è½¬æ¢ä¸ºå¯ä»¥ä¾é ç®€å•çš„æ“ä½œå¾—åˆ°è®¡ç®—ç»“æœçš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚(a+b)_(c+d)è½¬æ¢ä¸º ab+cd+_

#### å…³é”®ç‚¹

1. æ ˆçš„åŸºæœ¬ç”¨æ³•

2. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦æ³¨æ„/ å’Œ å…¶ä»–å¾ˆå¤šè¯­è¨€æ˜¯ä¸ä¸€æ ·çš„

3. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦å…ˆå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—ã€‚å¦åˆ™æœ‰å¾ˆå¤šæ„æƒ³ä¸åˆ°çš„ç»“æœ

4. æ“ä½œç¬¦çš„é¡ºåºåº”è¯¥æ˜¯ å…ˆå‡ºæ ˆçš„æ˜¯ç¬¬äºŒä½ï¼Œåå‡ºæ ˆçš„æ˜¯ç¬¬ä¸€ä½ã€‚ è¿™åœ¨ä¸ç¬¦åˆäº¤æ¢å¾‹çš„æ“ä½œä¸­å¾ˆé‡è¦ï¼Œ æ¯”å¦‚å‡æ³•å’Œé™¤æ³•ã€‚

#### ä»£ç 

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  // è¿™ç§ç®—æ³•çš„å‰ææ˜¯ tokensæ˜¯æœ‰æ•ˆçš„ï¼Œ
  // å½“ç„¶è¿™ç”±ç®—æ³•æ¥ä¿è¯
  const stack = [];

  for (let index = 0; index < tokens.length; index++) {
    const token = tokens[index];
    // å¯¹äºè¿ç®—æ•°ï¼Œ æˆ‘ä»¬ç›´æ¥å…¥æ ˆ
    if (!Number.isNaN(Number(token))) {
      stack.push(token);
    } else {
      // é‡åˆ°æ“ä½œç¬¦ï¼Œæˆ‘ä»¬ç›´æ¥å¤§èƒ†è¿ç®—ï¼Œä¸ç”¨è€ƒè™‘ç®—æœ¯ä¼˜å…ˆçº§
      // ç„¶åå°†è¿ç®—ç»“æœå…¥æ ˆå³å¯

      // å½“ç„¶å¦‚æœé¢˜ç›®è¿›ä¸€æ­¥æ‰©å±•ï¼Œå…è®¸ä½¿ç”¨å•ç›®ç­‰å…¶ä»–è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬çš„ç®—æ³•éœ€è¦åšå¾®å°çš„è°ƒæ•´
      const a = Number(stack.pop());
      const b = Number(stack.pop());
      if (token === '*') {
        stack.push(b * a);
      } else if (token === '/') {
        stack.push((b / a) >> 0);
      } else if (token === '+') {
        stack.push(b + a);
      } else if (token === '-') {
        stack.push(b - a);
      }
    }
  }

  return stack.pop();
};
```

#### æ‰©å±•

é€†æ³¢å…°è¡¨è¾¾å¼ä¸­åªæ”¹å˜è¿ç®—ç¬¦çš„é¡ºåºï¼Œå¹¶ä¸ä¼šæ”¹å˜æ“ä½œæ•°çš„ç›¸å¯¹é¡ºåºï¼Œè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ€§è´¨ã€‚
å¦å¤–é€†æ³¢å…°è¡¨è¾¾å¼å®Œå…¨ä¸å…³å¿ƒæ“ä½œç¬¦çš„ä¼˜å…ˆçº§ï¼Œè¿™åœ¨ä¸­ç¼€è¡¨è¾¾å¼ä¸­æ˜¯åšä¸åˆ°çš„ï¼Œè¿™å¾ˆæœ‰è¶£ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥ç§ä¸‹æŸ¥æ‰¾èµ„æ–™ç ”ç©¶ä¸‹ä¸ºä»€ä¹ˆä¼šè¿™æ ·ã€‚

### [152].maximum-product-subarray

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```

#### æ€è·¯

> è¿™é“é¢˜ç›®çš„é€šè¿‡ç‡éå¸¸ä½

è¿™é“é¢˜ç›®è¦æˆ‘ä»¬æ±‚è§£è¿ç»­çš„ n ä¸ªæ•°ä¸­ä¹˜ç§¯æœ€å¤§çš„ç§¯æ˜¯å¤šå°‘ã€‚è¿™é‡Œæåˆ°äº†è¿ç»­ï¼Œç¬”è€…é¦–å…ˆ
æƒ³åˆ°çš„å°±æ˜¯æ»‘åŠ¨çª—å£ï¼Œä½†æ˜¯è¿™é‡Œæ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬ä¸èƒ½ä»…ä»…ç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼ï¼Œå› æ­¤æœ€å°å€¼(æ¯”å¦‚-20)ä¹˜ä»¥ä¸€ä¸ªæ¯”è¾ƒå°çš„æ•°(æ¯”å¦‚-10)
å¯èƒ½å°±ä¼šå¾ˆå¤§ã€‚ å› æ­¤è¿™ç§æ€è·¯å¹¶ä¸æ–¹ä¾¿ã€‚

é¦–å…ˆæ¥æš´åŠ›æ±‚è§£,æˆ‘ä»¬ä½¿ç”¨ä¸¤å±‚å¾ªç¯æ¥æšä¸¾æ‰€æœ‰å¯èƒ½é¡¹ï¼Œè¿™ç§è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2), ä»£ç å¦‚ä¸‹ï¼š

```js
var maxProduct = function(nums) {
  let max = nums[0];
  let temp = null;
  for (let i = 0; i < nums.length; i++) {
    temp = nums[i];
    max = Math.max(temp, max);
    for (let j = i + 1; j < nums.length; j++) {
      temp *= nums[j];
      max = Math.max(temp, max);
    }
  }

  return max;
};
```

å› æ­¤æˆ‘ä»¬éœ€è¦åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼ï¼Œç„¶åæ¯”è¾ƒå…ƒç´ å’Œè¿™ä¸¤ä¸ªçš„ä¹˜ç§¯ï¼Œå»ä¸æ–­æ›´æ–°æœ€å¤§å€¼ã€‚

è¿™ç§æ€è·¯çš„è§£æ³•ç”±äºåªéœ€è¦éå†ä¸€æ¬¡ï¼Œå…¶æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹

- åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  let max = nums[0];
  let min = nums[0];
  let res = nums[0];

  for (let i = 1; i < nums.length; i++) {
    let tmp = min;
    min = Math.min(nums[i], Math.min(max * nums[i], min * nums[i])); // å–æœ€å°
    max = Math.max(nums[i], Math.max(max * nums[i], tmp * nums[i])); /// å–æœ€å¤§
    res = Math.max(res, max);
  }
  return res;
};
```

### [152].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  if (nums.length == 0) return 0;
  let ans = nums[0],
    max = nums[0],
    min = nums[0];
  for (let i = 1, len = nums.length; i < len; i++) {
    if (nums[i] < 0) {
      let tmp = max;
      max = min;
      min = tmp;
    }
    max = Math.max(nums[i], max * nums[i]);
    min = Math.min(nums[i], min * nums[i]);

    ans = Math.max(max, ans);
  }
  return ans;
};

console.log(maxProduct([-2, 3, -4]));
```

### [152].Maximum-Product-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-product-subarray/description/
 * Difficulty:Medium
 *
 * Find the contiguous subarray within an array (containing at least one number)
 * which has the largest product.
 *
 * For example, given the array [2,3,-2,4],
 * the contiguous subarray [2,3] has the largest product = [6].
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  var a = nums[0];
  var imin = a;
  var imax = a;
  var max = a;

  for (var i = 1; i < nums.length; i++) {
    var t = nums[i];
    if (t < 0) {
      var tmp = imin;
      imin = imax;
      imax = tmp;
    }
    imax = Math.max(t, t * imax);
    imin = Math.min(t, t * imin);
    max = Math.max(max, imax);
  }

  return max;
};

console.log(maxProduct([-1]));
console.log(maxProduct([1]));
console.log(maxProduct([1, 2, 3, -4]));
console.log(maxProduct([2, 3, -2, 4]));
```

### [155].æœ€å°æ ˆ min-stack

```
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„æ–¹æ³•æ˜¯ï¼Œæ¯æ¬¡å¯¹æ ˆè¿›è¡Œä¿®æ”¹æ“ä½œ(push å’Œ pop)çš„æ—¶å€™æ›´æ–°æœ€å°å€¼ã€‚ ç„¶å getMin åªéœ€è¦è¿”å›æˆ‘ä»¬è®¡ç®—çš„æœ€å°å€¼å³å¯ï¼Œ
top ä¹Ÿæ˜¯ç›´æ¥è¿”å›æ ˆé¡¶å…ƒç´ å³å¯ã€‚ è¿™ç§åšæ³•æ¯æ¬¡ä¿®æ”¹æ ˆéƒ½éœ€è¦æ›´æ–°æœ€å°å€¼ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦æ˜¯ O(n).

æ˜¯å¦æœ‰æ›´é«˜æ•ˆçš„ç®—æ³•å‘¢ï¼Ÿç­”æ¡ˆæ˜¯æœ‰çš„ã€‚

æˆ‘ä»¬æ¯æ¬¡å…¥æ ˆçš„æ—¶å€™ï¼Œä¿å­˜çš„ä¸å†æ˜¯çœŸæ­£çš„æ•°å­—ï¼Œè€Œæ˜¯å®ƒä¸å½“å‰æœ€å°å€¼çš„å·®(å½“å‰å…ƒç´ æ²¡æœ‰å…¥æ ˆçš„æ—¶å€™çš„æœ€å°å€¼)ã€‚
è¿™æ ·æˆ‘ä»¬ pop å’Œ top çš„æ—¶å€™æ‹¿åˆ°æ ˆé¡¶å…ƒç´ å†åŠ ä¸Š**ä¸Šä¸€ä¸ª**æœ€å°å€¼å³å¯ã€‚
å¦å¤–æˆ‘ä»¬åœ¨ push å’Œ pop çš„æ—¶å€™å»æ›´æ–° minï¼Œè¿™æ · getMin çš„æ—¶å€™å°±ç®€å•äº†ï¼Œç›´æ¥è¿”å› minã€‚

> æ³¨æ„ä¸Šé¢åŠ ç²—çš„â€œä¸Šä¸€ä¸ªâ€ï¼Œä¸æ˜¯â€œå½“å‰çš„æœ€å°å€¼â€

ç»è¿‡ä¸Šé¢çš„åˆ†æï¼Œé—®é¢˜çš„å…³é”®è½¬åŒ–ä¸ºâ€œå¦‚æœæ±‚çš„ä¸Šä¸€ä¸ªæœ€å°å€¼â€ï¼Œè§£å†³è¿™ä¸ªçš„å…³é”®ç‚¹åœ¨äºåˆ©ç”¨ minã€‚

pop æˆ–è€… top çš„æ—¶å€™ï¼š

- å¦‚æœæ ˆé¡¶å…ƒç´ å°äº 0ï¼Œè¯´æ˜æ ˆé¡¶æ˜¯å½“å‰æœ€å°çš„å…ƒç´ ï¼Œå®ƒå‡ºæ ˆä¼šå¯¹ min é€ æˆå½±å“ï¼Œæˆ‘ä»¬éœ€è¦å»æ›´æ–° minã€‚
  ä¸Šä¸€ä¸ªæœ€å°çš„æ˜¯â€œmin - æ ˆé¡¶å…ƒç´ â€,æˆ‘ä»¬éœ€è¦å°†ä¸Šä¸€ä¸ªæœ€å°å€¼æ›´æ–°ä¸ºå½“å‰çš„æœ€å°å€¼

> å› ä¸ºæ ˆé¡¶å…ƒç´ å…¥æ ˆçš„æ—¶å€™çš„é€šè¿‡ `æ ˆé¡¶å…ƒç´  = çœŸå®å€¼ - ä¸Šä¸€ä¸ªæœ€å°çš„å…ƒç´ ` å¾—åˆ°çš„ï¼Œ
> è€ŒçœŸå®å€¼ = minï¼Œ å› æ­¤å¯ä»¥å¾—å‡º`ä¸Šä¸€ä¸ªæœ€å°çš„å…ƒç´  = çœŸå®å€¼ -æ ˆé¡¶å…ƒç´ `

- å¦‚æœæ ˆé¡¶å…ƒç´ å¤§äº 0ï¼Œè¯´æ˜å®ƒå¯¹æœ€å°å€¼`æ²¡æœ‰å½±å“`ï¼Œä¸Šä¸€ä¸ªæœ€å°å€¼å°±æ˜¯ä¸Šä¸Šä¸ªæœ€å°å€¼ã€‚

#### å…³é”®ç‚¹

- æœ€å°æ ˆå­˜å‚¨çš„ä¸åº”è¯¥æ˜¯çœŸå®å€¼ï¼Œè€Œæ˜¯çœŸå®å€¼å’Œ min çš„å·®å€¼
- top çš„æ—¶å€™æ¶‰åŠåˆ°å¯¹æ•°æ®çš„è¿˜åŸï¼Œè¿™é‡Œåƒä¸‡æ³¨æ„æ˜¯**ä¸Šä¸€ä¸ª**æœ€å°å€¼

#### ä»£ç 

```js
var MinStack = function() {
  this.stack = [];
  this.min = Number.MAX_VALUE;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  // update 'min'
  const min = this.min;
  if (x < this.min) {
    this.min = x;
  }
  return this.stack.push(x - min);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const item = this.stack.pop();
  const min = this.min;

  if (item < 0) {
    this.min = min - item;
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const item = this.stack[this.stack.length - 1];
  const min = this.min;

  if (item < 0) {
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.min;
};
```

```js
var MinStack = function() {
  this.value = [];
  this.minIndex = -1;
  return this;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.value.push(x);
  if (this.minIndex === -1 || this.value[this.minIndex] > x) {
    // æ ˆé¡¶
    this.minIndex = this.value.length - 1;
  }
  return this.value.length;
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const popValue = this.value.pop();
  this.minIndex = 0;
  for (let i = 0; i < this.value.length; i++) {
    if (this.value[i] < this.value[this.minIndex]) {
      this.minIndex = i;
    }
  }
  return popValue;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const length = this.value.length;
  return this.value[length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.value[this.minIndex];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

const minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
console.log(minStack.getMin());
console.log(minStack.pop());
console.log(minStack.top());
console.log(minStack.getMin());
```

```js
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = [];
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.stack.push(x);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  this.stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  let min = this.stack[0];
  for (let val of this.stack) {
    if (val < min) min = val;
  }
  return min;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = Object.create(MinStack).createNew()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### [160].intersection-of-two-linked-lists

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // ç½‘ä¸Šç²¾å¦™çš„è§£æ³•æ²¡çœ‹æ‡‚
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  if (headA == null || headB == null) return null;

  let ALen = getLength(headA),
    BLen = getLength(headB),
    lenDiff = Math.abs(ALen - BLen);

  for (let i = 0; i < lenDiff; i++) {
    if (ALen > BLen) headA = headA.next;
    else headB = headB.next;
  }
  let curLen = Math.min(ALen, BLen);
  for (let i = 0; i < curLen; i++) {
    if (headA == headB) {
      return headA;
    }
    headA = headA.next;
    headB = headB.next;
  }
  return null;
};

function getLength(head) {
  let len = 0;
  while (head) {
    len++;
    head = head.next;
  }
  return len;
}
```

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // ç½‘ä¸Šç²¾å¦™çš„è§£æ³•æ²¡çœ‹æ‡‚
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

### [169].æ±‚ä¼—æ•°

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (nums.length === 1) return nums[0];
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > parseInt(nums.length / 2)) {
        return key;
      }
    }
    // console.log('i', i)
  }
};

// console.log(majorityElement([1]))
// console.log(majorityElement([3, 2, 3]))
// console.log(majorityElement([2, 2, 1, 1, 1, 2, 2]))
```

```js
// [169]. Majority Element

// Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times.

// You may assume that the array is non-empty and the majority element always exist in the array.

// Example 1:

// Input: [3,2,3]
// Output: 3
// Example 2:

// Input: [2,2,1,1,1,2,2]
// Output: 2

// Time: O(n)
// Sace: O(1)

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function majorityElement(nums) {
  if (!nums.length) return 0;
  let majorityIndex = 0;
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    // If current num === majority number, count++
    if (nums[i] === nums[majorityIndex]) {
      count++;
    } else {
      count--;
    }
    // If count === 0, set to current num
    if (count === 0) {
      majorityIndex = i;
      count = 1;
    }
  }

  return nums[majorityIndex];
}
```

```js
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
  if (numerator == 0) return '0';

  const res = new Array();

  if ((numerator > 0) ^ (denominator > 0)) {
    res.push('-');
  }
  let num = Math.abs(numerator),
    den = Math.abs(denominator);
  res.push(parseInt(num / den));
  if (num % den == 0) return res.join('');

  res.push('.');
  num %= den;

  let map = new Map();
  while (true) {
    let curNum = parseInt((num * 10) / den);
    num = (num * 10) % den;
    if (map.has(curNum)) {
      const index = map.get(curNum);
      res.splice(index, 0, '(');
      res.push(')');
      break;
    } else if (num == 0) {
      res.push(curNum);
      break;
    } else {
      res.push(curNum);
      map.set(curNum, res.length - 1);
    }
  }
  return res.join('');
};
```

### [198].house-robber

```
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.

```

#### æ€è·¯

è¿™æ˜¯ä¸€é“éå¸¸å…¸å‹ä¸”ç®€å•çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œä½†æ˜¯åœ¨è¿™é‡Œæˆ‘å¸Œæœ›é€šè¿‡è¿™ä¸ªä¾‹å­ï¼Œ
è®©å¤§å®¶å¯¹åŠ¨æ€è§„åˆ’é—®é¢˜æœ‰ä¸€ç‚¹è®¤è¯†ã€‚

ä¸ºä»€ä¹ˆåˆ«äººçš„åŠ¨æ€è§„åˆ’å¯ä»¥é‚£ä¹ˆå†™ï¼Œä¸ºä»€ä¹ˆæ²¡æœ‰ç”¨ dp æ•°ç»„å°±æå®šäº†ã€‚
æ¯”å¦‚åˆ«äººçš„çˆ¬æ¥¼æ¢¯é—®é¢˜æ€ä¹ˆå°±ç”¨ fibnacci æå®šäº†ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿåœ¨è¿™é‡Œæˆ‘ä»¬å°±æ¥çœ‹ä¸‹ã€‚

æ€è·¯è¿˜æ˜¯å’Œå…¶ä»–ç®€å•çš„åŠ¨æ€è§„åˆ’é—®é¢˜ä¸€æ ·ï¼Œæˆ‘ä»¬æœ¬è´¨ä¸Šåœ¨è§£å†³`å¯¹äºç¬¬[i] ä¸ªæˆ¿å­ï¼Œæˆ‘ä»¬æŠ¢è¿˜æ˜¯ä¸æŠ¢ã€‚`çš„é—®é¢˜ã€‚

åˆ¤æ–­çš„æ ‡å‡†å°±æ˜¯æ€»ä»·å€¼å“ªä¸ªæ›´å¤§ï¼Œ é‚£ä¹ˆå¯¹äºæŠ¢çš„è¯`å°±æ˜¯å½“å‰çš„æˆ¿å­å¯ä»¥æŠ¢çš„ä»·å€¼ + dp[i - 2]`

> i - 1 ä¸èƒ½æŠ¢ï¼Œå¦åˆ™ä¼šè§¦å‘è­¦é“ƒ

å¦‚æœä¸æŠ¢çš„è¯ï¼Œå°±æ˜¯`dp[i - 1]`.

> è¿™é‡Œçš„ dp å…¶å®å°±æ˜¯`å­é—®é¢˜`.

çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿä¸éš¾å†™`dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);`.

ä¸Šè¿°è¿‡ç¨‹ç”¨å›¾æ¥è¡¨ç¤ºçš„è¯ï¼Œæ˜¯è¿™æ ·çš„ï¼š

æˆ‘ä»¬ä»”ç»†è§‚å¯Ÿçš„è¯ï¼Œå…¶å®æˆ‘ä»¬åªéœ€è¦ä¿è¯å‰ä¸€ä¸ª dp[i - 1] å’Œ dp[i - 2] ä¸¤ä¸ªå˜é‡å°±å¥½äº†ï¼Œ
æ¯”å¦‚æˆ‘ä»¬è®¡ç®—åˆ° i = 6 çš„æ—¶å€™ï¼Œå³éœ€è¦è®¡ç®— dp[6]çš„æ—¶å€™ï¼Œ æˆ‘ä»¬éœ€è¦ dp[5], dp[4]ï¼Œä½†æ˜¯æˆ‘ä»¬
ä¸éœ€è¦ dp[3], dp[2] ...

å› æ­¤ä»£ç å¯ä»¥ç®€åŒ–ä¸ºï¼š

```js
let a = 0;
let b = 0;

for (let i = 0; i < nums.length; i++) {
  const temp = b;
  b = Math.max(a + nums[i], b);
  a = temp;
}

return b;
```

å¦‚ä¸Šçš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¤æ‚åº¦è¿›è¡Œä¼˜åŒ–ï¼Œä» O(n)é™ä½åˆ° O(1),
ç±»ä¼¼çš„ä¼˜åŒ–åœ¨ DP é—®é¢˜ä¸­ä¸åœ¨å°‘æ•°ã€‚

> åŠ¨æ€è§„åˆ’é—®é¢˜æ˜¯é€’å½’é—®é¢˜æŸ¥è¡¨ï¼Œé¿å…é‡å¤è®¡ç®—ï¼Œä»è€ŒèŠ‚çœæ—¶é—´ã€‚
> å¦‚æœæˆ‘ä»¬å¯¹é—®é¢˜åŠ ä»¥åˆ†æå’ŒæŠ½è±¡ï¼Œæœ‰å¯èƒ½å¯¹ç©ºé—´ä¸Šè¿›ä¸€æ­¥ä¼˜åŒ–

#### å…³é”®ç‚¹è§£æ

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  // Tag: DP
  const dp = [];
  dp[0] = 0;
  dp[1] = 0;

  for (let i = 2; i < nums.length + 2; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);
  }

  return dp[nums.length + 1];
};
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let a = 0,
    b = 0;
  for (let i = 0; i < nums.length; i++) {
    if (i % 2 == 0) {
      a = Math.max(b, a + nums[i]);
    } else {
      b = Math.max(a, b + nums[i]);
    }
  }
  return Math.max(a, b);
};
```

```js
/**
 * https://leetcode.com/problems/house-robber/description/
 * Difficulty:Easy
 *
 * You are a professional robber planning to rob houses along a street.
 * Each house has a certain amount of money stashed,
 * the only constraint stopping you from robbing each of them is that adjacent houses have security system connected
 * and it will automatically contact the police if two adjacent houses were broken into on the same night.

 Given a list of non-negative integers representing the amount of money of each house,
 determine the maximum amount of money you can rob tonight without alerting the police.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  if (!nums.length) return 0;
  var dp = [0, nums[0]];
  var max = nums[0];
  for (var i = 1; i < nums.length; i++) {
    dp[i + 1] = Math.max(dp[i], dp[i - 1] + nums[i]);
    max = Math.max(dp[i + 1], max);
  }
  return max;
};

console.log(rob([5, 2, 3, 5, 8]));
```

```js
// [198]. House Robber

// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint
// stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police
// if two adjacent houses were broken into on the same night.

// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob
// tonight without alerting the police.

// Explaination:
// https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems

const robAux = (nums, i, map) => {
  if (i >= nums.length) return 0;
  if (map.has(i)) return map.get(i);
  const a = robAux(nums, i + 1, map);
  const b = robAux(nums, i + 2, map);
  const curr = Math.max(a, b + nums[i]);
  map.set(i, curr);
  return curr;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function rob(nums) {
  const map = new Map();
  return robAux(nums, 0, map);
}
```

### [199]. Binary Tree Right Side View

```js
// [199]. Binary Tree Right Side View

// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

// Example:

// Input: [1,2,3,null,5,null,4]
// Output: [1, 3, 4]
// Explanation:

//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

const getDepth = (node, depth, map) => {
  if (!node) return;
  map.set(node, depth);
  if (node.left) getDepth(node.left, depth + 1, map);
  if (node.right) getDepth(node.right, depth + 1, map);
};

export default function rightSideView(root) {
  // BFS from right to left
  const queue = [];
  const map = new Map();
  getDepth(root, 0, map);
  const ans = [];
  if (!root) return [];
  const set = new Set();

  queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    if (map.has(item)) {
      if (item.right) queue.push(item.right);
      if (item.left) queue.push(item.left);
      if (!set.has(map.get(item))) {
        ans.push(item.val);
        set.add(map.get(item));
      }
    }
  }
  return ans;
}
```

### [200].

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  if (grid.length == 0) return 0;
  let count = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] == 1) {
        count++;
        helper(i, j, grid);
      }
    }
  }
  return count;
};

function helper(i, j, grid) {
  grid[i][j] = 'OK';
  if (i > 0 && grid[i - 1][j] == 1)
    // ä¸Š
    helper(i - 1, j, grid);
  if (i < grid.length - 1 && grid[i + 1][j] == 1)
    // ä¸‹
    helper(i + 1, j, grid);
  if (j > 0 && grid[i][j - 1] == 1)
    // å·¦
    helper(i, j - 1, grid);
  if (i < grid[0].length + 1 && grid[i][j + 1] == 1)
    // å³
    helper(i, j + 1, grid);
}

numIslands([
  ['1', '0', '1', '1', '1'],
  ['1', '0', '1', '0', '1'],
  ['1', '1', '1', '0', '1'],
]);
```
