---
layout: CustomPages
title: LeetCode-合集 100-200
date: 2020.09.04
aside: false
draft: true
---

### [101].

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  return helper(root, root);
};

function helper(l, r) {
  if (l == null && r == null) return true;
  if (l == null || r == null) return false;
  return l.val == r.val && helper(l.left, r.right) && helper(l.right, r.left);
}
```

### [102].binary-tree-level-order-traversal

```
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

#### 思路

这道题可以借助`队列`实现，首先把 root 入队，然后入队一个特殊元素 Null(来表示每层的结束)。

然后就是 while(queue.length), 每次处理一个节点，都将其子节点(在这里是 left 和 right)放到队列中。

然后不断的出队， 如果出队的是 null，则表式这一层已经结束了，我们就继续 push 一个 null。

如果不入队特殊元素 Null 来表示每层的结束，则在 while 循环开始时保存当前队列的长度，以保证每次只遍历一层(参考下面的 C++ Code)。

> 如果采用递归方式，则需要将当前节点，当前所在的 level 以及结果数组传递给递归函数。在递归函数中，取出节点的值，添加到 level 参数对应结果数组元素中(参考下面的 C++ Code)。

#### 关键点解析

- 队列

- 队列中用 Null(一个特殊元素)来划分每层

- 树的基本操作- 遍历 - 层次遍历(BFS)

- 注意塞入 null 的时候，判断一下当前队列是否为空，不然会无限循环

#### 代码

```js
// [102]. Binary Tree Level Order Traversal

// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

// For example:
// Given binary tree [3,9,20,null,null,15,7],

//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its level order traversal as:

// [
//   [3],
//   [9,20],
//   [15,7]
// ]

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
export default function levelOrder(root) {
  if (!root) return [];
  const queue = [];
  queue.push(root);
  const ans = [];
  const depths = new Map();
  depths.set(root, 0);
  let prev;
  let arr = [];
  while (queue.length) {
    const item = queue.shift();
    const depth = depths.get(item);
    if (!prev || (prev && depths.get(prev) !== depths.get(item))) {
      arr = [];
      ans.push(arr);
    }
    arr.push(item.val);
    if (item.left) {
      depths.set(item.left, depth + 1);
      queue.push(item.left);
    }
    if (item.right) {
      depths.set(item.right, depth + 1);
      queue.push(item.right);
    }
    prev = item;
  }
  return ans;
}
```

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  if (!root) return [];
  const items = []; // 存放所有节点
  const queue = [root, null]; // null 简化操作
  let levelNodes = []; // 存放每一层的节点

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      // 一层已经遍历完了
      items.push(levelNodes);
      levelNodes = [];
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  let ans = [];
  helper(root, ans, 0);
  return ans;
};

function helper(node, ans, i) {
  if (node == null) return;
  if (i == ans.length) ans.push([]);
  ans[i].push(node.val);

  helper(node.left, ans, i + 1);
  helper(node.right, ans, i + 1);
}
```

### [103].binary-tree-zigzag-level-order-traversal

和 leetcode 102 基本是一样的，思路是完全一样的。

```
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```

#### 思路

这道题可以借助`队列`实现，首先把 root 入队，然后入队一个特殊元素 Null(来表示每层的结束)。

然后就是 while(queue.length), 每次处理一个节点，都将其子节点(在这里是 left 和 right)放到队列中。

然后不断的出队， 如果出队的是 null，则表式这一层已经结束了，我们就继续 push 一个 null。

#### 关键点解析

- 队列

- 队列中用 Null(一个特殊元素)来划分每层

- 树的基本操作- 遍历 - 层次遍历(BFS)

#### 代码

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  if (!root) return [];
  const items = [];
  let isOdd = true;
  let levelNodes = [];

  const queue = [root, null];

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      if (!isOdd) {
        levelNodes = levelNodes.reverse();
      }
      items.push(levelNodes);
      levelNodes = [];
      isOdd = !isOdd;
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

### [104].二叉树的最大深度

### [105].从前序与中序遍历序列构造二叉树

#### 参考答案

递归构造二叉树，时间复杂度 O(n)

> 关键在于前序遍历和中序遍历的特性:

- 前序遍历：根节点是首元素
- 中序遍历：根节点左侧的值是其左子树，右侧的值是其右子树
  > 因此，我们首先要得到从前序序列中获取根节点，然后遍历中序序列，找到根节点的位置，以此直到其左子树和右子树的范围。当我们得到其左子树之后，事情就开始重复了，我们仍然需要根据前序序列中找到这颗左子树的根节点，然后再根据中序序列得到这颗左子树根节点的左右子树，右子树同理。因此实际上就是个回溯。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  return helper(0, 0, inorder.length - 1, preorder, inorder);
};

function helper(preStart, inStart, inEnd, preorder, inorder) {
  if (preStart > preorder.length - 1 || inStart > inEnd) {
    return null;
  }
  let root = new TreeNode(preorder[preStart]);
  let inIndex = 0;
  for (let i = inStart; i <= inEnd; i++) {
    if (inorder[i] == root.val) {
      inIndex = i;
    }
  }
  root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
  root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
  return root;
}
```

### [110].平衡二叉树 Balanced Binary Tree DONE

```js
function maxDepth(root) {
  if (root == null) return 0;
  const l = maxDepth(root.left);
  const r = maxDepth(root.right);
  if (l === false || r === false) return false;
  // 平衡二叉树是 左右树的深度差小于 1 ？
  if (Math.abs(l - r) > 1) return false;
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
  if (root === null) return true;
  return !!maxDepth(root);
};
```

### [104].maximum-depth-of-binary-tree

```
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.

```

#### 思路

由于树是一种递归的数据结构，因此用递归去解决的时候往往非常容易，这道题恰巧也是如此，
用递归实现的代码如下：

```js
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

如果使用迭代呢？ 我们首先应该想到的是树的各种遍历，由于我们求的是深度，因此
使用层次遍历(BFS)是非常合适的。 我们只需要记录有多少层即可。

#### 关键点解析

- 队列

- 队列中用 Null(一个特殊元素)来划分每层，或者在对每层进行迭代之前保存当前队列元素的个数(即当前层所含元素个数)

- 树的基本操作- 遍历 - 层次遍历(BFS)

#### 代码

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;

  // 层次遍历 BFS
  let cur = root;
  const queue = [root, null];
  let depth = 1;

  while ((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      // 注意⚠️： 不处理会无限循环，进而堆栈溢出
      if (queue.length === 0) return depth;
      depth++;
      queue.push(null);
      continue;
    }
    const l = cur.left;
    const r = cur.right;

    if (l) queue.push(l);
    if (r) queue.push(r);
  }

  return depth;
};
```

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root === null) return 0;
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};

function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}

function Tree(arr) {
  const head = new TreeNode(null);
  if (arr.length === 0) return head;
  let cur = head;

  return cur;
}
```

```js
function TreeNode(val: any) {
  this.val = val;
  this.left = this.right = null;
}

export default function MaxDepth(root: TreeNode, count: number = 0): number {
  if (!root) return 0;

  const first = MaxDepth(root.left, count);
  const sec = MaxDepth(root.right, count);

  return Math.max(first, sec) + 1;
}

const t = new TreeNode(1);
const t2 = new TreeNode(2);
const t3 = new TreeNode(3);

//           t1
//         /   \
//       t2     null
//      / \
//   null  t3

t.left = t2.right = t3;

// expect(MaxDepth(t)).to.equal(2);
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### [114].flatten-binary-tree-to-linked-list

```js
function preorderTraversal(root) {
  if (!root) return [];

  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = null;

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

### [121].买卖股票的最佳时机

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  // 直接认为 prices length 大于 2
  let max = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    for (let j = i + 1; j < prices.length; j++) {
      const target = prices[j] - prices[i];
      if (target > max) {
        max = target;
      }
    }
  }
  return max;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
console.log(maxProfit([1, 4, 2]));
```

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let maxProfit = 0;
  let minPrice = Number.MAX_SAFE_INTEGER;
  for (let i = 0; i < prices.length; i++) {
    minPrice = Math.min(minPrice, prices[i]);
    maxProfit = Math.max(maxProfit, prices[i] - minPrice);
  }
  return maxProfit;
};
```

### [121].best-time-to-buy-and-sell-stock

```
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```

#### 思路

由于我们是想获取到最大的利润，我们的策略应该是低点买入，高点卖出。

由于题目对于交易次数有限制，只能交易一次，因此问题的本质其实就是求波峰浪谷的差值的最大值。

用图表示的话就是这样：

#### 关键点解析

- 这类题只要你在心中(或者别的地方)画出上面这种图就很容易解决

#### 代码

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let min = prices[0];
  let profit = 0;
  // 7 1 5 3 6 4
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = Math.max(profit, prices[i] - min);
    } else {
      min = Math.min(min, prices[i]);
    }
  }

  return profit;
};
```

Python Code:

```python
### 应用Kadane's algorithms
class Solution:
    def maxProfit(self, prices: 'List[int]') -> int:
        """
        step by step
        """
        ### error case
        if len(prices) < 1:
            return 0

        ### caluate the daily gains, break into a subarray problem
        gains = [prices[i]-prices[i-1] for i in range(1, len(prices))]

        loc_max = global_max = 0 #not gains[0] in case of negative
        for i in range(len(gains)):
            loc_max = max(loc_max + gains[i], gains[i])
            if loc_max > global_max:
                global_max = loc_max
"""
Runtime: 48 ms, faster than 34.50% of Python3 online submissions for Best Time to Buy and Sell Stock.
Memory Usage: 14.1 MB, less than 10.26% of Python3 online submissions for Best Time to Buy and Sell Stock.
"""
```

### [124].binary-tree-maximum-path-sum

```
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

#### 思路

这道题目的 path 让我误解了，然后浪费了很多时间来解这道题
我觉得 leetcode 给的 demo 太少了，不足以让我理解 path 的概念
因此我这里自己画了一个图，来补充一下，帮助大家理解 path 的概念，不要像我一样理解错啦。

首先是官网给的两个例子：

接着是我自己画的一个例子：

大家可以结合上面的 demo 来继续理解一下 path， 除非你理解了 path，否则不要往下看。

树的题目，基本都是考察递归思想的。因此我们需要思考如何去定义我们的递归函数，
在这里我定义了一个递归函数，它的功能是，`返回以当前节点为根节点的MathPath`
但是有两个条件:

1.  第一是跟节点必须选择
2.  第二是左右子树只能选择一个

为什么要有这两个条件?

我的想法是原问题可以转化为：

以每一个节点为根节点，我们分别求出 max path，最后计算最大值,因此第一个条件需要满足.

对于第二个，由于递归函数子节点的返回值会被父节点使用，因此我们如果两个孩子都选择了
就不符合 max path 的定义了，这也是我没有理解题意，绕了很大弯子的原因。

因此我的做法就是不断调用递归函数，然后在调用过程中不断计算和更新 max，最后在主函数中将 max 返回即可。

#### 关键点解析

- 递归
- 理解题目中的 path 定义

#### 代码

```js
function helper(node, payload) {
  if (node === null) return 0;

  const l = helper(node.left, payload);
  const r = helper(node.right, payload);

  payload.max = Math.max(node.val + Math.max(0, l) + Math.max(0, r), payload.max);

  return node.val + Math.max(l, r, 0);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
  if (root === null) return 0;
  const payload = {
    max: root.val,
  };
  helper(root, payload);
  return payload.max;
};
```

### [124].

```js
let maxValue;

var maxPathSum = function(root) {
  maxValue = Number.MIN_SAFE_INTEGER;
  find(root);
  return maxValue;
};

function find(node) {
  if (node == null) return 0;
  let left = Math.max(0, find(node.left)); // 获取左侧最大和
  let right = Math.max(0, find(node.right)); // 获取右侧最大和
  maxValue = Math.max(maxValue, left + right + node.val); // 获得最大值
  return Math.max(left, right) + node.val; // 返回最大值
}
```

### [128].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  if (nums.length == 0) return 0;
  let count = 0,
    max = 1;
  for (let i = 0, len = nums.length; i < len; i++) {
    let min = i;
    for (let j = i + 1; j < len; j++) {
      if (nums[j] < nums[min]) min = j;
    }
    swap(nums, i, min);
    if (i != 0 && nums[i] == nums[i - 1] + 1) {
      count++;
      max = Math.max(max, count);
    } else if (nums[i] == nums[i - 1]) {
    } else {
      count = 1;
    }
  }
  return max;
};

function swap(nums, a, b) {
  let x = nums[a];
  nums[a] = nums[b];
  nums[b] = x;
}

console.log(longestConsecutive([1, 2, 0, 1]));
```

### [128].longest-consecutive-sequence

```
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Accepted
200,786
Submissions
485,346

```

#### 思路

这是一道最最长连续数字序列长度的题目， 官网给出的难度是`hard`.

符合直觉的做法是先排序，然后用一个变量记录最大值，遍历去更新最大值即可，

代码：

```js
if (nums.length === 0) return 0;
let count = 1;
let maxCount = 1;
// 这里其实可以不需要排序，这么做只不过是为了方便理解
nums = [...new Set(nums)].sort((a, b) => a - b);
for (let i = 0; i < nums.length - 1; i++) {
  if (nums[i + 1] - nums[i] === 1) {
    count++;
  } else {
    if (count > maxCount) {
      maxCount = count;
    }
    count = 1;
  }
}
return Math.max(count, maxCount);
```

但是需要排序时间复杂度会上升，题目要求时间复杂度为 O(n),
那么我们其实可以不用排序去解决的。

思路就是将之前”排序之后，通过比较前后元素是否相差 1 来判断是否连续“的思路改为
不排序而是`直接遍历，然后在内部循环里面查找是否存在当前值的邻居元素`，但是马上有一个
问题，内部我们`查找是否存在当前值的邻居元素`的过程如果使用数组时间复杂度是 O(n),
那么总体的复杂度就是 O(n^2)，完全不可以接受。怎么办呢？

我们换个思路，用空间来换时间。比如用类似于 hashmap 这样的数据结构优化查询部分，将时间复杂度降低到 O(1), 代码见后面`代码部分`

#### 关键点解析

- 空间换时间

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  nums = new Set(nums);
  let max = 0;
  let y = 0;
  nums.forEach(x => {
    // 说明x是连续序列的开头元素
    if (!nums.has(x - 1)) {
      y = x + 1;
      while (nums.has(y)) {
        y = y + 1;
      }
      max = Math.max(max, y - x); // y - x 就是从x开始到最后有多少连续的数字
    }
  });
  return max;
};
```

### [134].gas-station

```js
function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad 时间复杂度O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution 时间复杂度O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // 如果remain < 0, 说明从start到i走不通
    // 并且从start到i走不通，那么所有的solution中包含start到i的肯定都走不通
    // 因此我们重新从i + 1开始作为start
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // 事实上，我们遍历一遍，也就确定了每一个元素作为start是否可以走完一圈

  // 如果cost总和大于gas总和，无论如何也无法走到终点
  return total >= 0 ? start : -1;
};
```

### [136].Single-Number

```js
var singleNumber = function(nums) {
  var a = 0;
  for (let val of nums) a ^= val;
  return a;
};
```

```js
// 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

// 说明：

// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

// 示例 1:

// 输入: [2,2,1]
// 输出: 1
// 示例 2:

// 输入: [4,1,2,1,2]
// 输出: 4

// 思路
// 标签：位运算
// 本题根据题意，线性时间复杂度 O(n)O(n)，很容易想到使用 Hash 映射来进行计算，遍历一次后结束得到结果，但是在空间复杂度上会达到 O(n)O(n)，需要使用较多的额外空间
// 既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：

//  [1]. 一个数和 0 做 XOR 运算等于本身：a^0 = a
//  [2]. 一个数和其本身做 XOR 运算等于 0：a^a = 0
//  [3]. XOR 运算满足交换律和结合律：a^b^a = (a^a)^b = 0^b = b

// 故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字
// 时间复杂度：O(n)，空间复杂度：O(1)

// reduce 性能性对好些
// 84 ms	40.2 MB
var singleNumber = function(nums = []) {
  return nums.reduce((ret, n) => ret ^ n, 0);
};

// 88 ms	40.8 MB
var singleNumber1 = function(nums) {
  let ans = 0;
  for (const num of nums) {
    ans ^= num;
  }
  return ans;
};

export default function SingleNumber2(nums = []) {
  for (let i = 0; i < nums.length; i++) {
    if (set.has(nums[i])) {
      set.delete(nums[i]);
    } else {
      set.add(nums[i]);
    }
  }

  const item = Array.from(set)[0];
  set.clear();

  return item;
}

console.log(singleNumber([1, 2, 2]) == 1);
console.log(singleNumber([1, 2, 1]) == 2);
```

### [136].single-number

```
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
```

#### 思路

根据题目描述，由于加上了时间复杂度必须是 O(n)，并且空间复杂度为 O(1)的条件，因此不能用排序方法，也不能使用 map 数据结构。

我们可以利用二进制异或的性质来完成，将所有数字异或即得到唯一出现的数字。

#### 关键点

1. 异或的性质
   两个数字异或的结果`a^b`是将 a 和 b 的二进制每一位进行运算，得出的数字。 运算的逻辑是
   如果同一位的数字相同则为 0，不同则为 1

2. 异或的规律

- 任何数和本身异或则为`0`

- 任何数和 0 异或是`本身`

3. 很多人只是记得异或的性质和规律，但是缺乏对其本质的理解，导致很难想到这种解法(我本人也没想到)

4. bit 运算

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let ret = 0;
  for (let index = 0; index < nums.length; index++) {
    const element = nums[index];
    ret = ret ^ element;
  }
  return ret;
};
```

#### 延伸

有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。

和上面一样，只是这次不是一个数字，而是两个数字。还是按照上面的思路，我们进行一次全员异或操作，
得到的结果就是那两个只出现一次的不同的数字的异或结果。

我们刚才讲了异或的规律中有一个`任何数和本身异或则为0`， 因此我们的思路是能不能将这两个不同的数字分成两组 A 和 B。
分组需要满足两个条件.

1. 两个独特的的数字分成不同组

2. 相同的数字分成相同组

这样每一组的数据进行异或即可得到那两个数字。

问题的关键点是我们怎么进行分组呢？

由于异或的性质是，同一位相同则为 0，不同则为 1. 我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1.

我们随便取一个， 分组的依据就来了， 就是你取的那一位是 0 分成 1 组，那一位是 1 的分成一组。
这样肯定能保证`2. 相同的数字分成相同组`, 不同的数字会被分成不同组么。 很明显当然可以， 因此我们选择是 1，也就是
说`两个独特的的数字`在那一位一定是不同的，因此两个独特元素一定会被分成不同组。

Done！

### [139].word-break

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

#### 思路

这道题是给定一个字典和一个句子，判断该句子是否可以由字典里面的单词组出来，一个单词可以用多次。

暴力的方法是无解的，复杂度极其高。 我们考虑其是否可以拆分为小问题来解决。
对于问题`(s, wordDict)` 我们是否可以用(s', wordDict) 来解决。 其中 s' 是 s 的子序列，
当 s'变成寻常(长度为 0)的时候问题就解决了。 我们状态转移方程变成了这道题的难点。

我们可以建立一个数组 dp, dp[i]代表 字符串 s.substring(0, i) 能否由字典里面的单词组成，
值得注意的是，这里我们无法建立 dp[i] 和 dp[i - 1] 的关系，
我们可以建立的是 dp[i - word.length] 和 dp[i] 的关系。

我们用图来感受一下：

没有明白也没有关系，我们分步骤解读一下：

(以下的图左边都代表 s，右边都是 dict，灰色代表没有处理的字符，绿色代表匹配成功，红色代表匹配失败)

上面分步解释了算法的基本过程，下面我们感性认识下这道题，我把它比喻为
你正在`往一个老式手电筒🔦中装电池`

#### 代码

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  const dp = Array(s.length + 1);
  dp[0] = true;
  for (let i = 0; i < s.length + 1; i++) {
    for (let word of wordDict) {
      if (dp[i - word.length] && word.length <= i) {
        if (s.substring(i - word.length, i) === word) {
          dp[i] = true;
        }
      }
    }
  }

  return dp[s.length] || false;
};
```

### [139].Word-Break

```js
/**
 * https://leetcode.com/problems/word-break/description/
 * Difficulty:Medium
 *
 * Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.
 *
 * For example, given
 * s = "leetcode",
 * dict = ["leet", "code"].
 * Return true because "leetcode" can be segmented as "leet code".
 */

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var n = s.length;

  var dp = [true];
  for (var i = 1; i < n + 1; i++) {
    for (var j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) > -1) {
        dp[i] = true;
        break;
      } else {
        dp[i] = false;
      }
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(wordBreak('leetcode', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'e']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'leetco']));
```

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  let dp = new Array(s.length + 1);
  dp.fill(false);
  dp[0] = true;

  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.includes(s.slice(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[s.length];
};
```

### [140].

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  if (canStringBeSegmented(s, wordDict)) {
    return getAllPossibleSegments(s, wordDict, {});
  } else {
    return [];
  }
};
// DFS
function getAllPossibleSegments(s, dict, map) {
  if (s in map) return map[s];
  const result = [];
  if (dict.includes(s)) result.push(s);
  for (let i = 1; i < s.length; i++) {
    const left = s.substring(0, i);
    const right = s.substring(i);
    if (dict.includes(left) && containsSuffix(dict, right)) {
      for (let segment of getAllPossibleSegments(right, dict, map)) {
        result.push(`${left} ${segment}`);
      }
    }
  }
  map[s] = result;
  return result;
}

function containsSuffix(dict, str) {
  for (let i = 0; i < str.length; i++) {
    if (dict.includes(str.substring(i))) return true;
  }
  return false;
}
// 使用 dp 判断能否
function canStringBeSegmented(inputStr, inputDict) {
  const memTable = Array(inputStr.length + 1).fill(false);
  memTable[0] = true;

  for (let i = 1; i <= inputStr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (memTable[j] && inputDict.includes(inputStr.substring(j, i))) {
        memTable[i] = true;
        break;
      }
    }
  }
  return memTable[inputStr.length];
}
```

### [141].

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

### [141].linked-list-cycle

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */

//  快慢指针。 如果有环，快指针一定能追上慢指针
var hasCycle1 = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // 快指针一次移动两个
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};

// 哈希表 Set add has 来查询
// 牺牲了空间换时间
var hasCycle = function(head) {
  const set = new Set();
  let curr = head;
  set.add(curr);
  while (curr) {
    if (set.has(curr.next)) {
      return true;
    }
    set.add(curr.next);
    curr = curr.next;
  }
  return false;
};
```

```js
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### [146].

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.map = {};
  this.set = new Set();
  this.capacity = capacity;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.map[key]) {
    // key already exist, we need to delete the key and add to end
    this.set.delete(key);
    this.set.add(key);
    return this.map[key];
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.map[key]) {
    // remove this key and add back in set, update in hashmap
    this.set.delete(key);
  } else {
    if (this.set.size >= this.capacity) {
      var it = this.set.values();
      var oldKey = it.next().value;
      delete this.map[oldKey];
      this.set.delete(oldKey);
    }
  }
  this.set.add(key);
  this.map[key] = value;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = Object.create(LRUCache).createNew(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [146].lru-cache

```
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

```

#### 思路

由于是保留是最近使用的 N 条数据，这就和队列的特性很符合， 先进入队列的，先出队列。

因此思路就是用一个队列来记录目前缓存的所有 key， 每次 push 都进行判断，如果
超出最大容量限制则进行清除缓存的操作， 具体清除谁就按照刚才说的队列方式进行处理，同时对 key 进行入队操作。

get 的时候，如果缓存中有，则调整队列(具体操作为删除指定元素和入队两个操作)。 缓存中没有则返回-1

#### 关键点解析

- 队列简化操作

- 队列的操作是这道题的灵魂， 很容易少考虑情况

#### 代码

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.cache = {};
  this.capacity = capacity;
  this.size = 0;
  this.queue = [];
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit !== undefined) {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
    return hit;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  const hit = this.cache[key];

  // update cache
  this.cache[key] = value;

  if (!hit) {
    // invalid cache and resize size;
    if (this.size === this.capacity) {
      // invalid cache
      const key = this.queue.shift();
      this.cache[key] = undefined;
    } else {
      this.size = this.size + 1;
    }
    this.queue.push(key);
  } else {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
  }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [148].

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
  if (head == null || head.next == null) return head;

  let prev = null,
    slow = head,
    fast = head;
  while (fast != null && fase.next != null) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }

  prev.next = null;

  let l1 = sortList(head);
  let l2 = sortList(slow);

  return merge(l1, l2);
};

function merge(l1, l2) {
  let l = new ListNode(0),
    p = l;

  while (l1 != null && l2 != null) {
    if (l1.val < l2.val) {
      p.next = l1;
      l1 = l1.next;
    } else {
      p.next = l2;
      l2 = l2.next;
    }
    p = p.next;
  }

  if (l1 != null) p.next = l1;

  if (l2 != null) p.next = l2;

  return l.next;
}
```

### [150].evaluate-reverse-polish-notation

```
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
```

#### 思路

逆波兰表达式又叫做后缀表达式。在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之间，这种表示法也称为`中缀表示`。

波兰逻辑学家 J.Lukasiewicz 于 1929 年提出了另一种表示表达式的方法，按此方法，每一运算符都置于其运算对象之后，故称为`后缀表示`。

> 逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)_(c+d)转换为 ab+cd+_

#### 关键点

1. 栈的基本用法

2. 如果你用的是 JS 的话，需要注意/ 和 其他很多语言是不一样的

3. 如果你用的是 JS 的话，需要先将字符串转化为数字。否则有很多意想不到的结果

4. 操作符的顺序应该是 先出栈的是第二位，后出栈的是第一位。 这在不符合交换律的操作中很重要， 比如减法和除法。

#### 代码

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  // 这种算法的前提是 tokens是有效的，
  // 当然这由算法来保证
  const stack = [];

  for (let index = 0; index < tokens.length; index++) {
    const token = tokens[index];
    // 对于运算数， 我们直接入栈
    if (!Number.isNaN(Number(token))) {
      stack.push(token);
    } else {
      // 遇到操作符，我们直接大胆运算，不用考虑算术优先级
      // 然后将运算结果入栈即可

      // 当然如果题目进一步扩展，允许使用单目等其他运算符，我们的算法需要做微小的调整
      const a = Number(stack.pop());
      const b = Number(stack.pop());
      if (token === '*') {
        stack.push(b * a);
      } else if (token === '/') {
        stack.push((b / a) >> 0);
      } else if (token === '+') {
        stack.push(b + a);
      } else if (token === '-') {
        stack.push(b - a);
      }
    }
  }

  return stack.pop();
};
```

#### 扩展

逆波兰表达式中只改变运算符的顺序，并不会改变操作数的相对顺序，这是一个重要的性质。
另外逆波兰表达式完全不关心操作符的优先级，这在中缀表达式中是做不到的，这很有趣，感兴趣的可以私下查找资料研究下为什么会这样。

### [152].maximum-product-subarray

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```

#### 思路

> 这道题目的通过率非常低

这道题目要我们求解连续的 n 个数中乘积最大的积是多少。这里提到了连续，笔者首先
想到的就是滑动窗口，但是这里比较特殊，我们不能仅仅维护一个最大值，因此最小值(比如-20)乘以一个比较小的数(比如-10)
可能就会很大。 因此这种思路并不方便。

首先来暴力求解,我们使用两层循环来枚举所有可能项，这种解法的时间复杂度是 O(n^2), 代码如下：

```js
var maxProduct = function(nums) {
  let max = nums[0];
  let temp = null;
  for (let i = 0; i < nums.length; i++) {
    temp = nums[i];
    max = Math.max(temp, max);
    for (let j = i + 1; j < nums.length; j++) {
      temp *= nums[j];
      max = Math.max(temp, max);
    }
  }

  return max;
};
```

因此我们需要同时记录乘积最大值和乘积最小值，然后比较元素和这两个的乘积，去不断更新最大值。

这种思路的解法由于只需要遍历一次，其时间复杂度是 O(n)，代码见下方代码区。

#### 关键点

- 同时记录乘积最大值和乘积最小值

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  let max = nums[0];
  let min = nums[0];
  let res = nums[0];

  for (let i = 1; i < nums.length; i++) {
    let tmp = min;
    min = Math.min(nums[i], Math.min(max * nums[i], min * nums[i])); // 取最小
    max = Math.max(nums[i], Math.max(max * nums[i], tmp * nums[i])); /// 取最大
    res = Math.max(res, max);
  }
  return res;
};
```

### [152].

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  if (nums.length == 0) return 0;
  let ans = nums[0],
    max = nums[0],
    min = nums[0];
  for (let i = 1, len = nums.length; i < len; i++) {
    if (nums[i] < 0) {
      let tmp = max;
      max = min;
      min = tmp;
    }
    max = Math.max(nums[i], max * nums[i]);
    min = Math.min(nums[i], min * nums[i]);

    ans = Math.max(max, ans);
  }
  return ans;
};

console.log(maxProduct([-2, 3, -4]));
```

### [152].Maximum-Product-Subarray

```js
/**
 * https://leetcode.com/problems/maximum-product-subarray/description/
 * Difficulty:Medium
 *
 * Find the contiguous subarray within an array (containing at least one number)
 * which has the largest product.
 *
 * For example, given the array [2,3,-2,4],
 * the contiguous subarray [2,3] has the largest product = [6].
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  var a = nums[0];
  var imin = a;
  var imax = a;
  var max = a;

  for (var i = 1; i < nums.length; i++) {
    var t = nums[i];
    if (t < 0) {
      var tmp = imin;
      imin = imax;
      imax = tmp;
    }
    imax = Math.max(t, t * imax);
    imin = Math.min(t, t * imin);
    max = Math.max(max, imax);
  }

  return max;
};

console.log(maxProduct([-1]));
console.log(maxProduct([1]));
console.log(maxProduct([1, 2, 3, -4]));
console.log(maxProduct([2, 3, -2, 4]));
```

### [155].最小栈 min-stack

```
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.

```

#### 思路

符合直觉的方法是，每次对栈进行修改操作(push 和 pop)的时候更新最小值。 然后 getMin 只需要返回我们计算的最小值即可，
top 也是直接返回栈顶元素即可。 这种做法每次修改栈都需要更新最小值，因此时间复杂度是 O(n).

是否有更高效的算法呢？答案是有的。

我们每次入栈的时候，保存的不再是真正的数字，而是它与当前最小值的差(当前元素没有入栈的时候的最小值)。
这样我们 pop 和 top 的时候拿到栈顶元素再加上**上一个**最小值即可。
另外我们在 push 和 pop 的时候去更新 min，这样 getMin 的时候就简单了，直接返回 min。

> 注意上面加粗的“上一个”，不是“当前的最小值”

经过上面的分析，问题的关键转化为“如果求的上一个最小值”，解决这个的关键点在于利用 min。

pop 或者 top 的时候：

- 如果栈顶元素小于 0，说明栈顶是当前最小的元素，它出栈会对 min 造成影响，我们需要去更新 min。
  上一个最小的是“min - 栈顶元素”,我们需要将上一个最小值更新为当前的最小值

> 因为栈顶元素入栈的时候的通过 `栈顶元素 = 真实值 - 上一个最小的元素` 得到的，
> 而真实值 = min， 因此可以得出`上一个最小的元素 = 真实值 -栈顶元素`

- 如果栈顶元素大于 0，说明它对最小值`没有影响`，上一个最小值就是上上个最小值。

#### 关键点

- 最小栈存储的不应该是真实值，而是真实值和 min 的差值
- top 的时候涉及到对数据的还原，这里千万注意是**上一个**最小值

#### 代码

```js
var MinStack = function() {
  this.stack = [];
  this.min = Number.MAX_VALUE;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  // update 'min'
  const min = this.min;
  if (x < this.min) {
    this.min = x;
  }
  return this.stack.push(x - min);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const item = this.stack.pop();
  const min = this.min;

  if (item < 0) {
    this.min = min - item;
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const item = this.stack[this.stack.length - 1];
  const min = this.min;

  if (item < 0) {
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.min;
};
```

```js
var MinStack = function() {
  this.value = [];
  this.minIndex = -1;
  return this;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.value.push(x);
  if (this.minIndex === -1 || this.value[this.minIndex] > x) {
    // 栈顶
    this.minIndex = this.value.length - 1;
  }
  return this.value.length;
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const popValue = this.value.pop();
  this.minIndex = 0;
  for (let i = 0; i < this.value.length; i++) {
    if (this.value[i] < this.value[this.minIndex]) {
      this.minIndex = i;
    }
  }
  return popValue;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const length = this.value.length;
  return this.value[length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.value[this.minIndex];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

const minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
console.log(minStack.getMin());
console.log(minStack.pop());
console.log(minStack.top());
console.log(minStack.getMin());
```

```js
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = [];
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.stack.push(x);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  this.stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  let min = this.stack[0];
  for (let val of this.stack) {
    if (val < min) min = val;
  }
  return min;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = Object.create(MinStack).createNew()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### [160].intersection-of-two-linked-lists

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // 网上精妙的解法没看懂
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  if (headA == null || headB == null) return null;

  let ALen = getLength(headA),
    BLen = getLength(headB),
    lenDiff = Math.abs(ALen - BLen);

  for (let i = 0; i < lenDiff; i++) {
    if (ALen > BLen) headA = headA.next;
    else headB = headB.next;
  }
  let curLen = Math.min(ALen, BLen);
  for (let i = 0; i < curLen; i++) {
    if (headA == headB) {
      return headA;
    }
    headA = headA.next;
    headB = headB.next;
  }
  return null;
};

function getLength(head) {
  let len = 0;
  while (head) {
    len++;
    head = head.next;
  }
  return len;
}
```

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  // 网上精妙的解法没看懂
  // see : https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49789/My-accepted-simple-and-shortest-C%2B%2B-code-with-comments-explaining-the-algorithm.-Any-comments-or-improvements
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

### [169].求众数

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (nums.length === 1) return nums[0];
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > parseInt(nums.length / 2)) {
        return key;
      }
    }
    // console.log('i', i)
  }
};

// console.log(majorityElement([1]))
// console.log(majorityElement([3, 2, 3]))
// console.log(majorityElement([2, 2, 1, 1, 1, 2, 2]))
```

```js
// [169]. Majority Element

// Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

// You may assume that the array is non-empty and the majority element always exist in the array.

// Example 1:

// Input: [3,2,3]
// Output: 3
// Example 2:

// Input: [2,2,1,1,1,2,2]
// Output: 2

// Time: O(n)
// Sace: O(1)

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function majorityElement(nums) {
  if (!nums.length) return 0;
  let majorityIndex = 0;
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    // If current num === majority number, count++
    if (nums[i] === nums[majorityIndex]) {
      count++;
    } else {
      count--;
    }
    // If count === 0, set to current num
    if (count === 0) {
      majorityIndex = i;
      count = 1;
    }
  }

  return nums[majorityIndex];
}
```

```js
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
  if (numerator == 0) return '0';

  const res = new Array();

  if ((numerator > 0) ^ (denominator > 0)) {
    res.push('-');
  }
  let num = Math.abs(numerator),
    den = Math.abs(denominator);
  res.push(parseInt(num / den));
  if (num % den == 0) return res.join('');

  res.push('.');
  num %= den;

  let map = new Map();
  while (true) {
    let curNum = parseInt((num * 10) / den);
    num = (num * 10) % den;
    if (map.has(curNum)) {
      const index = map.get(curNum);
      res.splice(index, 0, '(');
      res.push(')');
      break;
    } else if (num == 0) {
      res.push(curNum);
      break;
    } else {
      res.push(curNum);
      map.set(curNum, res.length - 1);
    }
  }
  return res.join('');
};
```

### [198].house-robber

```
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.

```

#### 思路

这是一道非常典型且简单的动态规划问题，但是在这里我希望通过这个例子，
让大家对动态规划问题有一点认识。

为什么别人的动态规划可以那么写，为什么没有用 dp 数组就搞定了。
比如别人的爬楼梯问题怎么就用 fibnacci 搞定了？为什么？在这里我们就来看下。

思路还是和其他简单的动态规划问题一样，我们本质上在解决`对于第[i] 个房子，我们抢还是不抢。`的问题。

判断的标准就是总价值哪个更大， 那么对于抢的话`就是当前的房子可以抢的价值 + dp[i - 2]`

> i - 1 不能抢，否则会触发警铃

如果不抢的话，就是`dp[i - 1]`.

> 这里的 dp 其实就是`子问题`.

状态转移方程也不难写`dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);`.

上述过程用图来表示的话，是这样的：

我们仔细观察的话，其实我们只需要保证前一个 dp[i - 1] 和 dp[i - 2] 两个变量就好了，
比如我们计算到 i = 6 的时候，即需要计算 dp[6]的时候， 我们需要 dp[5], dp[4]，但是我们
不需要 dp[3], dp[2] ...

因此代码可以简化为：

```js
let a = 0;
let b = 0;

for (let i = 0; i < nums.length; i++) {
  const temp = b;
  b = Math.max(a + nums[i], b);
  a = temp;
}

return b;
```

如上的代码，我们可以将复杂度进行优化，从 O(n)降低到 O(1),
类似的优化在 DP 问题中不在少数。

> 动态规划问题是递归问题查表，避免重复计算，从而节省时间。
> 如果我们对问题加以分析和抽象，有可能对空间上进一步优化

#### 关键点解析

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  // Tag: DP
  const dp = [];
  dp[0] = 0;
  dp[1] = 0;

  for (let i = 2; i < nums.length + 2; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);
  }

  return dp[nums.length + 1];
};
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let a = 0,
    b = 0;
  for (let i = 0; i < nums.length; i++) {
    if (i % 2 == 0) {
      a = Math.max(b, a + nums[i]);
    } else {
      b = Math.max(a, b + nums[i]);
    }
  }
  return Math.max(a, b);
};
```

```js
/**
 * https://leetcode.com/problems/house-robber/description/
 * Difficulty:Easy
 *
 * You are a professional robber planning to rob houses along a street.
 * Each house has a certain amount of money stashed,
 * the only constraint stopping you from robbing each of them is that adjacent houses have security system connected
 * and it will automatically contact the police if two adjacent houses were broken into on the same night.

 Given a list of non-negative integers representing the amount of money of each house,
 determine the maximum amount of money you can rob tonight without alerting the police.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  if (!nums.length) return 0;
  var dp = [0, nums[0]];
  var max = nums[0];
  for (var i = 1; i < nums.length; i++) {
    dp[i + 1] = Math.max(dp[i], dp[i - 1] + nums[i]);
    max = Math.max(dp[i + 1], max);
  }
  return max;
};

console.log(rob([5, 2, 3, 5, 8]));
```

```js
// [198]. House Robber

// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint
// stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police
// if two adjacent houses were broken into on the same night.

// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob
// tonight without alerting the police.

// Explaination:
// https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems

const robAux = (nums, i, map) => {
  if (i >= nums.length) return 0;
  if (map.has(i)) return map.get(i);
  const a = robAux(nums, i + 1, map);
  const b = robAux(nums, i + 2, map);
  const curr = Math.max(a, b + nums[i]);
  map.set(i, curr);
  return curr;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function rob(nums) {
  const map = new Map();
  return robAux(nums, 0, map);
}
```

### [199]. Binary Tree Right Side View

```js
// [199]. Binary Tree Right Side View

// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

// Example:

// Input: [1,2,3,null,5,null,4]
// Output: [1, 3, 4]
// Explanation:

//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

const getDepth = (node, depth, map) => {
  if (!node) return;
  map.set(node, depth);
  if (node.left) getDepth(node.left, depth + 1, map);
  if (node.right) getDepth(node.right, depth + 1, map);
};

export default function rightSideView(root) {
  // BFS from right to left
  const queue = [];
  const map = new Map();
  getDepth(root, 0, map);
  const ans = [];
  if (!root) return [];
  const set = new Set();

  queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    if (map.has(item)) {
      if (item.right) queue.push(item.right);
      if (item.left) queue.push(item.left);
      if (!set.has(map.get(item))) {
        ans.push(item.val);
        set.add(map.get(item));
      }
    }
  }
  return ans;
}
```

### [200].

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  if (grid.length == 0) return 0;
  let count = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] == 1) {
        count++;
        helper(i, j, grid);
      }
    }
  }
  return count;
};

function helper(i, j, grid) {
  grid[i][j] = 'OK';
  if (i > 0 && grid[i - 1][j] == 1)
    // 上
    helper(i - 1, j, grid);
  if (i < grid.length - 1 && grid[i + 1][j] == 1)
    // 下
    helper(i + 1, j, grid);
  if (j > 0 && grid[i][j - 1] == 1)
    // 左
    helper(i, j - 1, grid);
  if (i < grid[0].length + 1 && grid[i][j + 1] == 1)
    // 右
    helper(i, j + 1, grid);
}

numIslands([
  ['1', '0', '1', '1', '1'],
  ['1', '0', '1', '0', '1'],
  ['1', '1', '1', '0', '1'],
]);
```
