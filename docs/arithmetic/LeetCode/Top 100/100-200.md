---
layout: CustomPages
title: LeetCode-åˆé›† 100-200
date: 2020.09.04
aside: false
draft: true
---

### [101].å¯¹ç§°äºŒå‰æ ‘ DONE

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ `[1,2,2,3,4,4,3]` æ˜¯å¯¹ç§°çš„ã€‚

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

ä½†æ˜¯ä¸‹é¢è¿™ä¸ª `[1,2,2,null,3,null,3]` åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

```
    1
   / \
  2   2
   \   \
   3    3
```

è¿›é˜¶ï¼šä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ

```js
/**
 * é€’å½’
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  if (!root) return true;
  return helper(root.left, root.right);
};

function helper(a, b) {
  if (!a && !b) return true;
  if (!a || !b || a.val !== b.val) return false;
  // å¯¹ç§°ã€‚ å·¦æ ‘çš„å·¦æ ‘ä¸å³æ ‘çš„å³æ ‘æ¯”è¾ƒï¼› å·¦æ ‘çš„å³æ ‘ä¸å³æ ‘çš„å·¦æ ‘æ¯”è¾ƒ
  return helper(a.left, b.right) && helper(a.right, b.left);
}
```

```js
// è¿­ä»£
var isSymmetric = function(root) {
  var q = [root, root],
    n,
    m;
  while (q.length) {
    // ä¸€æ¬¡æ‹¿å‡ºä¸¤ä¸ªèŠ‚ç‚¹ï¼Œåˆ¤æ–­æ˜¯å¯¹ç§°çš„ã€‚
    n = q.shift();
    m = q.shift();
    if (!m && !n) continue;
    if (!m || !n || m.val !== n.val) return false;
    // å·¦å³ç›¸æ¯”è¾ƒ
    q.push(n.left, m.right, n.right, m.left);
  }
  return true;
};
```

### [102].ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘(äºŒå‰æ ‘çš„å±‚åºéå†) binary-tree-level-order-traversal DONE

> å‰‘æŒ‡ Offer 32 - II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

ç¤ºä¾‹ï¼š
äºŒå‰æ ‘ï¼š`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

è¿”å›å…¶å±‚åºéå†ç»“æœï¼š

```
[
  [3],
  [9,20],
  [15,7]
]
```

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  const res = [];
  function traversal(root, depth) {
    if (root !== null) {
      if (!res[depth]) {
        res[depth] = [];
      }
      traversal(root.left, depth + 1);
      res[depth].push(root.val);
      traversal(root.right, depth + 1);
    }
  }
  traversal(root, 0);
  return res;
};
```

### [103].binary-tree-zigzag-level-order-traversal

å’Œ leetcode 102 åŸºæœ¬æ˜¯ä¸€æ ·çš„ï¼Œæ€è·¯æ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚

```
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```

#### ä»£ç 

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  if (!root) return [];
  const items = [];
  let isOdd = true;
  let levelNodes = [];

  const queue = [root, null];

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      if (!isOdd) {
        levelNodes = levelNodes.reverse();
      }
      items.push(levelNodes);
      levelNodes = [];
      isOdd = !isOdd;
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

### [104].äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ Maximum Depth of Binary Tree

```js
/**
 * é€’å½’
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

```js
var maxDepth = function(root) {
  let res = 0;
  function traversal(root, depth) {
    if (root !== null) {
      if (depth > res) {
        res = depth;
      }
      if (root.left) {
        traversal(root.left, depth + 1);
      }
      if (root.right) {
        traversal(root.right, depth + 1);
      }
    }
  }
  traversal(root, 1);
  return res;
};
```

#### è¿­ä»£

ä½¿ç”¨å±‚æ¬¡éå†(BFS)æ˜¯éå¸¸åˆé€‚çš„ã€‚

- é˜Ÿåˆ—
- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚ï¼Œæˆ–è€…åœ¨å¯¹æ¯å±‚è¿›è¡Œè¿­ä»£ä¹‹å‰ä¿å­˜å½“å‰é˜Ÿåˆ—å…ƒç´ çš„ä¸ªæ•°(å³å½“å‰å±‚æ‰€å«å…ƒç´ ä¸ªæ•°)
- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

```js
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;

  // å±‚æ¬¡éå† BFS
  let cur = root;
  const queue = [root, null];
  let depth = 1;

  while ((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      // æ³¨æ„ï¼š ä¸å¤„ç†ä¼šæ— é™å¾ªç¯ï¼Œè¿›è€Œå †æ ˆæº¢å‡º
      if (queue.length === 0) return depth;
      depth++;
      queue.push(null);
      continue;
    }
    const l = cur.left;
    const r = cur.right;

    if (l) queue.push(l);
    if (r) queue.push(r);
  }

  return depth;
};
```

### [105].ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

> å‰‘æŒ‡ offer 7 é‡å»ºäºŒå‰æ ‘

```js
/**
 * æ ¹æ®å‰åºéå†å’Œä¸­åºéå†é‡æ„äºŒå‰æ ‘
 * @param {Array} preorder
 * @param {Array} inorder
 * @return {Node}
 */
var buildTree = function(preorder, inorder) {
  if (!preorder.length || !inorder.length) return null;
  // å‰åºçš„ç¬¬ä¸€ä¸ªå€¼ä¸ºæ ¹èŠ‚ç‚¹
  const headValue = preorder[0];
  // å‰åºç¬¬ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿæ˜¯ä¸­åºå·¦å³å­æ ‘çš„åˆ†å‰²ç‚¹
  // é€šè¿‡å˜é‡ index å¯ä»¥ç¡®å®šåœ¨ å‰åºéå† / ä¸­åºéå†ä¸­ ç¡®å®š å·¦ / å³å­æ ‘çš„é•¿åº¦
  const index = inorder.findIndex(val => val === headValue);
  if (index === -1) return null;

  // é€’å½’å·¦å³å­æ ‘çš„å‰åºã€ä¸­åº
  const left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));
  const right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));
  return new TreeNode(headValue, left, right);
};
```

### [110].å¹³è¡¡äºŒå‰æ ‘ Balanced Binary Tree DONE

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
  if (root === null) return true;
  return !!maxDepth(root);
};

function maxDepth(root) {
  if (root == null) return 0;
  const l = maxDepth(root.left);
  const r = maxDepth(root.right);
  if (l === false || r === false) return false;
  // å¹³è¡¡æ ‘å·¦å³å­æ ‘é«˜åº¦å·®éƒ½å°äºç­‰äº 1
  if (Math.abs(l - r) > 1) return false;
  return 1 + Math.max(l, r);
}
```

### [114].äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨ flatten-binary-tree-to-linked-list

```js
function preorderTraversal(root) {
  if (!root) return [];
  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = null;

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  const helper = root => {
    if (!root) {
      return;
    }
    helper(root.right);
    helper(root.left);
    root.right = prev;
    root.left = null;
    prev = root;
  };
  let prev = null;
  helper(root);
};
```

### [121].ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº DONE

ç›¸å½“äºæ‰¾ä¸€ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼ä¸æœ€å°å€¼çš„å·®å€¼ã€‚

é¢˜ç›®æè¿°ï¼šä¸€æ¬¡è‚¡ç¥¨äº¤æ˜“åŒ…å«ä¹°å…¥å’Œå–å‡ºï¼Œåªè¿›è¡Œä¸€æ¬¡äº¤æ˜“ï¼Œæ±‚æœ€å¤§æ”¶ç›Šã€‚

åªè¦è®°å½•å‰é¢çš„æœ€å°ä»·æ ¼ï¼Œå°†è¿™ä¸ªæœ€å°ä»·æ ¼ä½œä¸ºä¹°å…¥ä»·æ ¼ï¼Œç„¶åå°†å½“å‰çš„ä»·æ ¼ä½œä¸ºå”®å‡ºä»·æ ¼ï¼ŒæŸ¥çœ‹å½“å‰æ”¶ç›Šæ˜¯ä¸æ˜¯æœ€å¤§æ”¶ç›Šã€‚

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let min = prices[0];
  let profit = 0;
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = Math.max(profit, prices[i] - min);
    } else {
      min = Math.min(min, prices[i]);
    }
  }
  return profit;
};
```

### [124].binary-tree-maximum-path-sum

```
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

#### å…³é”®ç‚¹è§£æ

- é€’å½’
- ç†è§£é¢˜ç›®ä¸­çš„ path å®šä¹‰

#### ä»£ç 

```js
function helper(node, payload) {
  if (node === null) return 0;

  const l = helper(node.left, payload);
  const r = helper(node.right, payload);

  payload.max = Math.max(node.val + Math.max(0, l) + Math.max(0, r), payload.max);

  return node.val + Math.max(l, r, 0);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
  if (root === null) return 0;
  const payload = {
    max: root.val,
  };
  helper(root, payload);
  return payload.max;
};
```

```js
let maxValue;

var maxPathSum = function(root) {
  maxValue = Number.MIN_SAFE_INTEGER;
  find(root);
  return maxValue;
};

function find(node) {
  if (node == null) return 0;
  let left = Math.max(0, find(node.left)); // è·å–å·¦ä¾§æœ€å¤§å’Œ
  let right = Math.max(0, find(node.right)); // è·å–å³ä¾§æœ€å¤§å’Œ
  maxValue = Math.max(maxValue, left + right + node.val); // è·å¾—æœ€å¤§å€¼
  return Math.max(left, right) + node.val; // è¿”å›æœ€å¤§å€¼
}
```

### [128].æœ€é•¿è¿ç»­åºåˆ— longest-consecutive-sequence DONE

```html
Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
```

è¦æ±‚ä»¥ O(N) çš„æ—¶é—´å¤æ‚åº¦æ±‚è§£ã€‚

#### æ€è·¯

è¿™æ˜¯ä¸€é“æœ€æœ€é•¿è¿ç»­æ•°å­—åºåˆ—é•¿åº¦çš„é¢˜ç›®ï¼Œ å®˜ç½‘ç»™å‡ºçš„éš¾åº¦æ˜¯`hard`.

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯å…ˆæ’åºï¼Œç„¶åç”¨ä¸€ä¸ªå˜é‡è®°å½•æœ€å¤§å€¼ï¼Œéå†å»æ›´æ–°æœ€å¤§å€¼å³å¯ï¼Œ

```js
if (nums.length === 0) return 0;
let count = 1;
let maxCount = 1;
// è¿™é‡Œå…¶å®å¯ä»¥ä¸éœ€è¦æ’åºï¼Œè¿™ä¹ˆåšåªä¸è¿‡æ˜¯ä¸ºäº†æ–¹ä¾¿ç†è§£
nums = [...new Set(nums)].sort((a, b) => a - b);
for (let i = 0; i < nums.length - 1; i++) {
  if (nums[i + 1] - nums[i] === 1) {
    count++;
  } else {
    if (count > maxCount) {
      maxCount = count;
    }
    count = 1;
  }
}
return Math.max(count, maxCount);
```

ä½†æ˜¯éœ€è¦æ’åºæ—¶é—´å¤æ‚åº¦ä¼šä¸Šå‡ï¼Œé¢˜ç›®è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n),
é‚£ä¹ˆæˆ‘ä»¬å…¶å®å¯ä»¥ä¸ç”¨æ’åºå»è§£å†³çš„ã€‚

æ€è·¯å°±æ˜¯å°†ä¹‹å‰â€æ’åºä¹‹åï¼Œé€šè¿‡æ¯”è¾ƒå‰åå…ƒç´ æ˜¯å¦ç›¸å·® 1 æ¥åˆ¤æ–­æ˜¯å¦è¿ç»­â€œçš„æ€è·¯æ”¹ä¸ºä¸æ’åºè€Œæ˜¯`ç›´æ¥éå†ï¼Œç„¶ååœ¨å†…éƒ¨å¾ªç¯é‡Œé¢æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `ï¼Œä½†æ˜¯é©¬ä¸Šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå†…éƒ¨æˆ‘ä»¬`æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `çš„è¿‡ç¨‹å¦‚æœä½¿ç”¨æ•°ç»„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n),é‚£ä¹ˆæ€»ä½“çš„å¤æ‚åº¦å°±æ˜¯ O(n^2)ï¼Œå®Œå…¨ä¸å¯ä»¥æ¥å—ã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿ

æˆ‘ä»¬æ¢ä¸ªæ€è·¯ï¼Œç”¨ç©ºé—´æ¥æ¢æ—¶é—´ã€‚æ¯”å¦‚ç”¨ç±»ä¼¼äº hashmap è¿™æ ·çš„æ•°æ®ç»“æ„ä¼˜åŒ–æŸ¥è¯¢éƒ¨åˆ†ï¼Œå°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ° O(1).

å…³é”®ç‚¹å°±æ˜¯ç©ºé—´æ¢æ—¶é—´ã€‚

#### ä»£ç 

```js
var longestConsecutive = function(nums) {
  // ç›´æ¥å°†æ•°ç»„è½¬åŒ–ä¸ºä¸€ä¸ª Set hashmap ç»“æ„
  nums = new Set(nums);
  let max = 0;
  let y = 0;
  nums.forEach(x => {
    // è¯´æ˜ x æ˜¯è¿ç»­åºåˆ—çš„å¼€å¤´å…ƒç´ .  ä¸å« x - 1 æ˜¯ä¸ºäº†é¿å…é‡å¤è®¡ç®—
    if (!nums.has(x - 1)) {
      y = x + 1;
      while (nums.has(y)) {
        y = y + 1;
      }
      max = Math.max(max, y - x); // y - x å°±æ˜¯ä» x å¼€å§‹åˆ°æœ€åæœ‰å¤šå°‘è¿ç»­çš„æ•°å­—
    }
  });
  return max;
};
```

### [134].gas-station

```js
function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad æ—¶é—´å¤æ‚åº¦O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution æ—¶é—´å¤æ‚åº¦O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // å¦‚æœremain < 0, è¯´æ˜ä»startåˆ°ièµ°ä¸é€š
    // å¹¶ä¸”ä»startåˆ°ièµ°ä¸é€šï¼Œé‚£ä¹ˆæ‰€æœ‰çš„solutionä¸­åŒ…å«startåˆ°içš„è‚¯å®šéƒ½èµ°ä¸é€š
    // å› æ­¤æˆ‘ä»¬é‡æ–°ä»i + 1å¼€å§‹ä½œä¸ºstart
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // äº‹å®ä¸Šï¼Œæˆ‘ä»¬éå†ä¸€éï¼Œä¹Ÿå°±ç¡®å®šäº†æ¯ä¸€ä¸ªå…ƒç´ ä½œä¸ºstartæ˜¯å¦å¯ä»¥èµ°å®Œä¸€åœˆ

  // å¦‚æœcostæ€»å’Œå¤§äºgasæ€»å’Œï¼Œæ— è®ºå¦‚ä½•ä¹Ÿæ— æ³•èµ°åˆ°ç»ˆç‚¹
  return total >= 0 ? start : -1;
};
```

### [136].single-number

```
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
```

#### æ€è·¯

æ ¹æ®é¢˜ç›®æè¿°ï¼Œç”±äºåŠ ä¸Šäº†æ—¶é—´å¤æ‚åº¦å¿…é¡»æ˜¯ O(n)ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦ä¸º O(1)çš„æ¡ä»¶ï¼Œå› æ­¤ä¸èƒ½ç”¨æ’åºæ–¹æ³•ï¼Œä¹Ÿä¸èƒ½ä½¿ç”¨ map æ•°æ®ç»“æ„ã€‚

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨äºŒè¿›åˆ¶å¼‚æˆ–çš„æ€§è´¨æ¥å®Œæˆï¼Œå°†æ‰€æœ‰æ•°å­—å¼‚æˆ–å³å¾—åˆ°å”¯ä¸€å‡ºç°çš„æ•°å­—ã€‚

#### å…³é”®ç‚¹

1. å¼‚æˆ–çš„æ€§è´¨
   ä¸¤ä¸ªæ•°å­—å¼‚æˆ–çš„ç»“æœ`a^b`æ˜¯å°† a å’Œ b çš„äºŒè¿›åˆ¶æ¯ä¸€ä½è¿›è¡Œè¿ç®—ï¼Œå¾—å‡ºçš„æ•°å­—ã€‚ è¿ç®—çš„é€»è¾‘æ˜¯
   å¦‚æœåŒä¸€ä½çš„æ•°å­—ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1

2. å¼‚æˆ–çš„è§„å¾‹

- ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º`0`

- ä»»ä½•æ•°å’Œ 0 å¼‚æˆ–æ˜¯`æœ¬èº«`

3. å¾ˆå¤šäººåªæ˜¯è®°å¾—å¼‚æˆ–çš„æ€§è´¨å’Œè§„å¾‹ï¼Œä½†æ˜¯ç¼ºä¹å¯¹å…¶æœ¬è´¨çš„ç†è§£ï¼Œå¯¼è‡´å¾ˆéš¾æƒ³åˆ°è¿™ç§è§£æ³•(æˆ‘æœ¬äººä¹Ÿæ²¡æƒ³åˆ°)

4. bit è¿ç®—

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let ret = 0;
  for (let index = 0; index < nums.length; index++) {
    const element = nums[index];
    ret = ret ^ element;
  }
  return ret;
};
```

```js
var singleNumber = function(nums) {
  var a = 0;
  for (let val of nums) a ^= val;
  return a;
};
```

```js
// ç»™å®šä¸€ä¸ªéç©ºæ•´æ•°æ•°ç»„ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚

// è¯´æ˜ï¼š

// ä½ çš„ç®—æ³•åº”è¯¥å…·æœ‰çº¿æ€§æ—¶é—´å¤æ‚åº¦ã€‚ ä½ å¯ä»¥ä¸ä½¿ç”¨é¢å¤–ç©ºé—´æ¥å®ç°å—ï¼Ÿ

// ç¤ºä¾‹ 1:

// è¾“å…¥: [2,2,1]
// è¾“å‡º: 1
// ç¤ºä¾‹Â 2:

// è¾“å…¥: [4,1,2,1,2]
// è¾“å‡º: 4

// æ€è·¯
// æ ‡ç­¾ï¼šä½è¿ç®—
// æœ¬é¢˜æ ¹æ®é¢˜æ„ï¼Œçº¿æ€§æ—¶é—´å¤æ‚åº¦ O(n)O(n)ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ä½¿ç”¨ Hash æ˜ å°„æ¥è¿›è¡Œè®¡ç®—ï¼Œéå†ä¸€æ¬¡åç»“æŸå¾—åˆ°ç»“æœï¼Œä½†æ˜¯åœ¨ç©ºé—´å¤æ‚åº¦ä¸Šä¼šè¾¾åˆ° O(n)O(n)ï¼Œéœ€è¦ä½¿ç”¨è¾ƒå¤šçš„é¢å¤–ç©ºé—´
// æ—¢æ»¡è¶³æ—¶é—´å¤æ‚åº¦åˆæ»¡è¶³ç©ºé—´å¤æ‚åº¦ï¼Œå°±è¦æåˆ°ä½è¿ç®—ä¸­çš„å¼‚æˆ–è¿ç®— XORï¼Œä¸»è¦å› ä¸ºå¼‚æˆ–è¿ç®—æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š

//  [1]. ä¸€ä¸ªæ•°å’Œ 0 åš XOR è¿ç®—ç­‰äºæœ¬èº«ï¼ša^0 = a
//  [2]. ä¸€ä¸ªæ•°å’Œå…¶æœ¬èº«åš XOR è¿ç®—ç­‰äº 0ï¼ša^a = 0
//  [3]. XOR è¿ç®—æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼ša^b^a = (a^a)^b = 0^b = b

// æ•…è€Œåœ¨ä»¥ä¸Šçš„åŸºç¡€æ¡ä»¶ä¸Šï¼Œå°†æ‰€æœ‰æ•°å­—æŒ‰ç…§é¡ºåºåšæŠ‘æˆ–è¿ç®—ï¼Œæœ€åå‰©ä¸‹çš„ç»“æœå³ä¸ºå”¯ä¸€çš„æ•°å­—
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)

// reduce æ€§èƒ½æ€§å¯¹å¥½äº›
// 84 ms	40.2 MB
var singleNumber = function(nums = []) {
  return nums.reduce((ret, n) => ret ^ n, 0);
};

// 88 ms	40.8 MB
var singleNumber1 = function(nums) {
  let ans = 0;
  for (const num of nums) {
    ans ^= num;
  }
  return ans;
};

export default function SingleNumber2(nums = []) {
  for (let i = 0; i < nums.length; i++) {
    if (set.has(nums[i])) {
      set.delete(nums[i]);
    } else {
      set.add(nums[i]);
    }
  }

  const item = Array.from(set)[0];
  set.clear();

  return item;
}

console.log(singleNumber([1, 2, 2]) == 1);
console.log(singleNumber([1, 2, 1]) == 2);
```

#### å»¶ä¼¸

æœ‰ä¸€ä¸ª n ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œé™¤äº†ä¸¤ä¸ªæ•°åªå‡ºç°ä¸€æ¬¡å¤–ï¼Œå…¶ä½™å…ƒç´ éƒ½å‡ºç°ä¸¤æ¬¡ï¼Œè®©ä½ æ‰¾å‡ºè¿™ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°åˆ†åˆ«æ˜¯å‡ ï¼Œè¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n) ä¸”å†å¼€è¾Ÿçš„å†…å­˜ç©ºé—´å›ºå®š(ä¸ n æ— å…³)ã€‚

å’Œä¸Šé¢ä¸€æ ·ï¼Œåªæ˜¯è¿™æ¬¡ä¸æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä¸¤ä¸ªæ•°å­—ã€‚è¿˜æ˜¯æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œæˆ‘ä»¬è¿›è¡Œä¸€æ¬¡å…¨å‘˜å¼‚æˆ–æ“ä½œï¼Œ
å¾—åˆ°çš„ç»“æœå°±æ˜¯é‚£ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„ä¸åŒçš„æ•°å­—çš„å¼‚æˆ–ç»“æœã€‚

æˆ‘ä»¬åˆšæ‰è®²äº†å¼‚æˆ–çš„è§„å¾‹ä¸­æœ‰ä¸€ä¸ª`ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º0`ï¼Œ å› æ­¤æˆ‘ä»¬çš„æ€è·¯æ˜¯èƒ½ä¸èƒ½å°†è¿™ä¸¤ä¸ªä¸åŒçš„æ•°å­—åˆ†æˆä¸¤ç»„ A å’Œ Bã€‚
åˆ†ç»„éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶.

1. ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—åˆ†æˆä¸åŒç»„

2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„

è¿™æ ·æ¯ä¸€ç»„çš„æ•°æ®è¿›è¡Œå¼‚æˆ–å³å¯å¾—åˆ°é‚£ä¸¤ä¸ªæ•°å­—ã€‚

é—®é¢˜çš„å…³é”®ç‚¹æ˜¯æˆ‘ä»¬æ€ä¹ˆè¿›è¡Œåˆ†ç»„å‘¢ï¼Ÿ

ç”±äºå¼‚æˆ–çš„æ€§è´¨æ˜¯ï¼ŒåŒä¸€ä½ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1. æˆ‘ä»¬å°†æ‰€æœ‰æ•°å­—å¼‚æˆ–çš„ç»“æœä¸€å®šä¸æ˜¯ 0ï¼Œä¹Ÿå°±æ˜¯è¯´è‡³å°‘æœ‰ä¸€ä½æ˜¯ 1.

æˆ‘ä»¬éšä¾¿å–ä¸€ä¸ªï¼Œ åˆ†ç»„çš„ä¾æ®å°±æ¥äº†ï¼Œ å°±æ˜¯ä½ å–çš„é‚£ä¸€ä½æ˜¯ 0 åˆ†æˆ 1 ç»„ï¼Œé‚£ä¸€ä½æ˜¯ 1 çš„åˆ†æˆä¸€ç»„ã€‚
è¿™æ ·è‚¯å®šèƒ½ä¿è¯`2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„`, ä¸åŒçš„æ•°å­—ä¼šè¢«åˆ†æˆä¸åŒç»„ä¹ˆã€‚ å¾ˆæ˜æ˜¾å½“ç„¶å¯ä»¥ï¼Œ å› æ­¤æˆ‘ä»¬é€‰æ‹©æ˜¯ 1ï¼Œä¹Ÿå°±æ˜¯
è¯´`ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—`åœ¨é‚£ä¸€ä½ä¸€å®šæ˜¯ä¸åŒçš„ï¼Œå› æ­¤ä¸¤ä¸ªç‹¬ç‰¹å…ƒç´ ä¸€å®šä¼šè¢«åˆ†æˆä¸åŒç»„ã€‚

Doneï¼

### [139].å•è¯æ‹†åˆ† word-break

ç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² s å’Œä¸€ä¸ªåŒ…å«éç©ºå•è¯çš„åˆ—è¡¨ wordDictï¼Œåˆ¤å®š Â s æ˜¯å¦å¯ä»¥è¢«ç©ºæ ¼æ‹†åˆ†ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªåœ¨å­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚

è¯´æ˜ï¼š

æ‹†åˆ†æ—¶å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
ä½ å¯ä»¥å‡è®¾å­—å…¸ä¸­æ²¡æœ‰é‡å¤çš„å•è¯ã€‚

```
ç¤ºä¾‹ 1ï¼š

è¾“å…¥: s = "leetcode", wordDict = ["leet", "code"]
è¾“å‡º: true
è§£é‡Š: è¿”å› true å› ä¸º "leetcode" å¯ä»¥è¢«æ‹†åˆ†æˆ "leet code"ã€‚
ç¤ºä¾‹ 2ï¼š

è¾“å…¥: s = "applepenapple", wordDict = ["apple", "pen"]
è¾“å‡º: true
è§£é‡Š: è¿”å› true å› ä¸º "applepenapple" å¯ä»¥è¢«æ‹†åˆ†æˆ "apple pen apple"ã€‚
Â     æ³¨æ„ä½ å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
ç¤ºä¾‹ 3ï¼š

è¾“å…¥: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
è¾“å‡º: false
```

#### æ€è·¯

è¿™é“é¢˜æ˜¯ç»™å®šä¸€ä¸ªå­—å…¸å’Œä¸€ä¸ªå¥å­ï¼Œåˆ¤æ–­è¯¥å¥å­æ˜¯å¦å¯ä»¥ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„å‡ºæ¥ï¼Œä¸€ä¸ªå•è¯å¯ä»¥ç”¨å¤šæ¬¡ã€‚

æš´åŠ›çš„æ–¹æ³•æ˜¯æ— è§£çš„ï¼Œå¤æ‚åº¦æå…¶é«˜ã€‚ æˆ‘ä»¬è€ƒè™‘å…¶æ˜¯å¦å¯ä»¥æ‹†åˆ†ä¸ºå°é—®é¢˜æ¥è§£å†³ã€‚
å¯¹äºé—®é¢˜`(s, wordDict)` æˆ‘ä»¬æ˜¯å¦å¯ä»¥ç”¨(s', wordDict) æ¥è§£å†³ã€‚ å…¶ä¸­ s' æ˜¯ s çš„å­åºåˆ—ï¼Œ
å½“ s'å˜æˆå¯»å¸¸(é•¿åº¦ä¸º 0)çš„æ—¶å€™é—®é¢˜å°±è§£å†³äº†ã€‚ æˆ‘ä»¬çŠ¶æ€è½¬ç§»æ–¹ç¨‹å˜æˆäº†è¿™é“é¢˜çš„éš¾ç‚¹ã€‚

æˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ªæ•°ç»„ dp, dp[i]ä»£è¡¨ å­—ç¬¦ä¸² s.substring(0, i) èƒ½å¦ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„æˆï¼Œ
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæˆ‘ä»¬æ— æ³•å»ºç«‹ dp[i] å’Œ dp[i - 1] çš„å…³ç³»ï¼Œ
æˆ‘ä»¬å¯ä»¥å»ºç«‹çš„æ˜¯ dp[i - word.length] å’Œ dp[i] çš„å…³ç³»ã€‚

æˆ‘ä»¬ç”¨å›¾æ¥æ„Ÿå—ä¸€ä¸‹ï¼š

æ²¡æœ‰æ˜ç™½ä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬åˆ†æ­¥éª¤è§£è¯»ä¸€ä¸‹ï¼š

(ä»¥ä¸‹çš„å›¾å·¦è¾¹éƒ½ä»£è¡¨ sï¼Œå³è¾¹éƒ½æ˜¯ dictï¼Œç°è‰²ä»£è¡¨æ²¡æœ‰å¤„ç†çš„å­—ç¬¦ï¼Œç»¿è‰²ä»£è¡¨åŒ¹é…æˆåŠŸï¼Œçº¢è‰²ä»£è¡¨åŒ¹é…å¤±è´¥)

ä¸Šé¢åˆ†æ­¥è§£é‡Šäº†ç®—æ³•çš„åŸºæœ¬è¿‡ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬æ„Ÿæ€§è®¤è¯†ä¸‹è¿™é“é¢˜ï¼Œæˆ‘æŠŠå®ƒæ¯”å–»ä¸º
ä½ æ­£åœ¨`å¾€ä¸€ä¸ªè€å¼æ‰‹ç”µç­’ğŸ”¦ä¸­è£…ç”µæ± `

#### ä»£ç 

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  const dp = Array(s.length + 1);
  dp[0] = true;
  for (let i = 0; i < s.length + 1; i++) {
    for (let word of wordDict) {
      if (dp[i - word.length] && word.length <= i) {
        if (s.substring(i - word.length, i) === word) {
          dp[i] = true;
        }
      }
    }
  }

  return dp[s.length] || false;
};
```

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var n = s.length;

  var dp = [true];
  for (var i = 1; i < n + 1; i++) {
    for (var j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) > -1) {
        dp[i] = true;
        break;
      } else {
        dp[i] = false;
      }
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(wordBreak('leetcode', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'e']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'leetco']));
```

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  let dp = new Array(s.length + 1);
  dp.fill(false);
  dp[0] = true;

  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.includes(s.slice(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[s.length];
};
```

### [140].

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  if (canStringBeSegmented(s, wordDict)) {
    return getAllPossibleSegments(s, wordDict, {});
  } else {
    return [];
  }
};
// DFS
function getAllPossibleSegments(s, dict, map) {
  if (s in map) return map[s];
  const result = [];
  if (dict.includes(s)) result.push(s);
  for (let i = 1; i < s.length; i++) {
    const left = s.substring(0, i);
    const right = s.substring(i);
    if (dict.includes(left) && containsSuffix(dict, right)) {
      for (let segment of getAllPossibleSegments(right, dict, map)) {
        result.push(`${left} ${segment}`);
      }
    }
  }
  map[s] = result;
  return result;
}

function containsSuffix(dict, str) {
  for (let i = 0; i < str.length; i++) {
    if (dict.includes(str.substring(i))) return true;
  }
  return false;
}
// ä½¿ç”¨ dp åˆ¤æ–­èƒ½å¦
function canStringBeSegmented(inputStr, inputDict) {
  const memTable = Array(inputStr.length + 1).fill(false);
  memTable[0] = true;

  for (let i = 1; i <= inputStr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (memTable[j] && inputDict.includes(inputStr.substring(j, i))) {
        memTable[i] = true;
        break;
      }
    }
  }
  return memTable[inputStr.length];
}
```

### [141].åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯ linked-list-cycle DONE

[link](https://leetcode-cn.com/problems/linked-list-cycle)

ä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå­˜åœ¨ç¯ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šç›¸é‡ã€‚

```js
/**
 * å“ˆå¸Œè¡¨ Set add has æ¥æŸ¥è¯¢
 * ç‰ºç‰²äº†ç©ºé—´æ¢æ—¶é—´
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  // åœæ­¢æ¡ä»¶ï¼š 1. Set åˆ¤æ–­å‡ºæœ‰ç¯ 2. æ— ç¯ï¼Œæ­£å¸¸ç»“æŸ
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

```js
/**
 * å¿«æ…¢æŒ‡é’ˆã€‚ å¦‚æœæœ‰ç¯ï¼Œå¿«æŒ‡é’ˆä¸€å®šèƒ½è¿½ä¸Šæ…¢æŒ‡é’ˆ
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // å¿«æŒ‡é’ˆä¸€æ¬¡ç§»åŠ¨ä¸¤ä¸ª
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### [142].ç¯å½¢é“¾è¡¨ II

### [144]. éé€’å½’å®ç°äºŒå‰æ ‘çš„å‰åºéå† Binary Tree Preorder Traversal (Medium)DONE

```js
function preorderTraversal(root) {
  if (!root) return null;
  const ret = [];
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    ret.push(node.val);
    // å…ˆå³åå·¦ï¼Œä¿è¯å·¦å­æ ‘å…ˆéå†
    stack.push(node.right);
    stack.push(node.left);
  }
  return ret;
}
```

### [145]. éé€’å½’å®ç°äºŒå‰æ ‘çš„ååºéå† Binary Tree Postorder Traversal (Medium) DONE

å‰åºéå†ä¸º root -> left -> rightï¼Œååºéå†ä¸º left -> right -> rootã€‚å¯ä»¥ä¿®æ”¹å‰åºéå†æˆä¸º root -> right -> leftï¼Œé‚£ä¹ˆè¿™ä¸ªé¡ºåºå°±å’Œååºéå†æ­£å¥½ç›¸åã€‚

```js
function postOrderTraversal(root) {
  if (!root) return null;
  const ret = [];
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    if (node == null) continue;
    ret.push(node.val);
    stack.push(node.left);
    stack.push(node.right);
  }
  return ret.reverse();
}
```

### [146].lru-cache

```
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

```

#### æ€è·¯

ç”±äºæ˜¯ä¿ç•™æ˜¯æœ€è¿‘ä½¿ç”¨çš„ N æ¡æ•°æ®ï¼Œè¿™å°±å’Œé˜Ÿåˆ—çš„ç‰¹æ€§å¾ˆç¬¦åˆï¼Œ å…ˆè¿›å…¥é˜Ÿåˆ—çš„ï¼Œå…ˆå‡ºé˜Ÿåˆ—ã€‚

å› æ­¤æ€è·¯å°±æ˜¯ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥è®°å½•ç›®å‰ç¼“å­˜çš„æ‰€æœ‰ keyï¼Œ æ¯æ¬¡ push éƒ½è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœ
è¶…å‡ºæœ€å¤§å®¹é‡é™åˆ¶åˆ™è¿›è¡Œæ¸…é™¤ç¼“å­˜çš„æ“ä½œï¼Œ å…·ä½“æ¸…é™¤è°å°±æŒ‰ç…§åˆšæ‰è¯´çš„é˜Ÿåˆ—æ–¹å¼è¿›è¡Œå¤„ç†ï¼ŒåŒæ—¶å¯¹ key è¿›è¡Œå…¥é˜Ÿæ“ä½œã€‚

get çš„æ—¶å€™ï¼Œå¦‚æœç¼“å­˜ä¸­æœ‰ï¼Œåˆ™è°ƒæ•´é˜Ÿåˆ—(å…·ä½“æ“ä½œä¸ºåˆ é™¤æŒ‡å®šå…ƒç´ å’Œå…¥é˜Ÿä¸¤ä¸ªæ“ä½œ)ã€‚ ç¼“å­˜ä¸­æ²¡æœ‰åˆ™è¿”å›-1

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—ç®€åŒ–æ“ä½œ

- é˜Ÿåˆ—çš„æ“ä½œæ˜¯è¿™é“é¢˜çš„çµé­‚ï¼Œ å¾ˆå®¹æ˜“å°‘è€ƒè™‘æƒ…å†µ

#### ä»£ç 

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.cache = {};
  this.capacity = capacity;
  this.size = 0;
  this.queue = [];
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit !== undefined) {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
    return hit;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  const hit = this.cache[key];

  // update cache
  this.cache[key] = value;

  if (!hit) {
    // invalid cache and resize size;
    if (this.size === this.capacity) {
      // invalid cache
      const key = this.queue.shift();
      this.cache[key] = undefined;
    } else {
      this.size = this.size + 1;
    }
    this.queue.push(key);
  } else {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
  }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.map = {};
  this.set = new Set();
  this.capacity = capacity;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.map[key]) {
    // key already exist, we need to delete the key and add to end
    this.set.delete(key);
    this.set.add(key);
    return this.map[key];
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.map[key]) {
    // remove this key and add back in set, update in hashmap
    this.set.delete(key);
  } else {
    if (this.set.size >= this.capacity) {
      var it = this.set.values();
      var oldKey = it.next().value;
      delete this.map[oldKey];
      this.set.delete(oldKey);
    }
  }
  this.set.add(key);
  this.map[key] = value;
};
```

### [150].evaluate-reverse-polish-notation

```
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
```

#### æ€è·¯

é€†æ³¢å…°è¡¨è¾¾å¼åˆå«åšåç¼€è¡¨è¾¾å¼ã€‚åœ¨é€šå¸¸çš„è¡¨è¾¾å¼ä¸­ï¼ŒäºŒå…ƒè¿ç®—ç¬¦æ€»æ˜¯ç½®äºä¸ä¹‹ç›¸å…³çš„ä¸¤ä¸ªè¿ç®—å¯¹è±¡ä¹‹é—´ï¼Œè¿™ç§è¡¨ç¤ºæ³•ä¹Ÿç§°ä¸º`ä¸­ç¼€è¡¨ç¤º`ã€‚

æ³¢å…°é€»è¾‘å­¦å®¶ J.Lukasiewicz äº 1929 å¹´æå‡ºäº†å¦ä¸€ç§è¡¨ç¤ºè¡¨è¾¾å¼çš„æ–¹æ³•ï¼ŒæŒ‰æ­¤æ–¹æ³•ï¼Œæ¯ä¸€è¿ç®—ç¬¦éƒ½ç½®äºå…¶è¿ç®—å¯¹è±¡ä¹‹åï¼Œæ•…ç§°ä¸º`åç¼€è¡¨ç¤º`ã€‚

> é€†æ³¢å…°è¡¨è¾¾å¼æ˜¯ä¸€ç§ååˆ†æœ‰ç”¨çš„è¡¨è¾¾å¼ï¼Œå®ƒå°†å¤æ‚è¡¨è¾¾å¼è½¬æ¢ä¸ºå¯ä»¥ä¾é ç®€å•çš„æ“ä½œå¾—åˆ°è®¡ç®—ç»“æœçš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚(a+b)_(c+d)è½¬æ¢ä¸º ab+cd+_

#### å…³é”®ç‚¹

1. æ ˆçš„åŸºæœ¬ç”¨æ³•

2. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦æ³¨æ„/ å’Œ å…¶ä»–å¾ˆå¤šè¯­è¨€æ˜¯ä¸ä¸€æ ·çš„

3. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦å…ˆå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—ã€‚å¦åˆ™æœ‰å¾ˆå¤šæ„æƒ³ä¸åˆ°çš„ç»“æœ

4. æ“ä½œç¬¦çš„é¡ºåºåº”è¯¥æ˜¯ å…ˆå‡ºæ ˆçš„æ˜¯ç¬¬äºŒä½ï¼Œåå‡ºæ ˆçš„æ˜¯ç¬¬ä¸€ä½ã€‚ è¿™åœ¨ä¸ç¬¦åˆäº¤æ¢å¾‹çš„æ“ä½œä¸­å¾ˆé‡è¦ï¼Œ æ¯”å¦‚å‡æ³•å’Œé™¤æ³•ã€‚

#### ä»£ç 

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  // è¿™ç§ç®—æ³•çš„å‰ææ˜¯ tokensæ˜¯æœ‰æ•ˆçš„ï¼Œ
  // å½“ç„¶è¿™ç”±ç®—æ³•æ¥ä¿è¯
  const stack = [];

  for (let index = 0; index < tokens.length; index++) {
    const token = tokens[index];
    // å¯¹äºè¿ç®—æ•°ï¼Œ æˆ‘ä»¬ç›´æ¥å…¥æ ˆ
    if (!Number.isNaN(Number(token))) {
      stack.push(token);
    } else {
      // é‡åˆ°æ“ä½œç¬¦ï¼Œæˆ‘ä»¬ç›´æ¥å¤§èƒ†è¿ç®—ï¼Œä¸ç”¨è€ƒè™‘ç®—æœ¯ä¼˜å…ˆçº§
      // ç„¶åå°†è¿ç®—ç»“æœå…¥æ ˆå³å¯

      // å½“ç„¶å¦‚æœé¢˜ç›®è¿›ä¸€æ­¥æ‰©å±•ï¼Œå…è®¸ä½¿ç”¨å•ç›®ç­‰å…¶ä»–è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬çš„ç®—æ³•éœ€è¦åšå¾®å°çš„è°ƒæ•´
      const a = Number(stack.pop());
      const b = Number(stack.pop());
      if (token === '*') {
        stack.push(b * a);
      } else if (token === '/') {
        stack.push((b / a) >> 0);
      } else if (token === '+') {
        stack.push(b + a);
      } else if (token === '-') {
        stack.push(b - a);
      }
    }
  }

  return stack.pop();
};
```

#### æ‰©å±•

é€†æ³¢å…°è¡¨è¾¾å¼ä¸­åªæ”¹å˜è¿ç®—ç¬¦çš„é¡ºåºï¼Œå¹¶ä¸ä¼šæ”¹å˜æ“ä½œæ•°çš„ç›¸å¯¹é¡ºåºï¼Œè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ€§è´¨ã€‚
å¦å¤–é€†æ³¢å…°è¡¨è¾¾å¼å®Œå…¨ä¸å…³å¿ƒæ“ä½œç¬¦çš„ä¼˜å…ˆçº§ï¼Œè¿™åœ¨ä¸­ç¼€è¡¨è¾¾å¼ä¸­æ˜¯åšä¸åˆ°çš„ï¼Œè¿™å¾ˆæœ‰è¶£ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥ç§ä¸‹æŸ¥æ‰¾èµ„æ–™ç ”ç©¶ä¸‹ä¸ºä»€ä¹ˆä¼šè¿™æ ·ã€‚

### [152].maximum-product-subarray

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```

#### æ€è·¯

> è¿™é“é¢˜ç›®çš„é€šè¿‡ç‡éå¸¸ä½

è¿™é“é¢˜ç›®è¦æˆ‘ä»¬æ±‚è§£è¿ç»­çš„ n ä¸ªæ•°ä¸­ä¹˜ç§¯æœ€å¤§çš„ç§¯æ˜¯å¤šå°‘ã€‚è¿™é‡Œæåˆ°äº†è¿ç»­ï¼Œç¬”è€…é¦–å…ˆ
æƒ³åˆ°çš„å°±æ˜¯æ»‘åŠ¨çª—å£ï¼Œä½†æ˜¯è¿™é‡Œæ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬ä¸èƒ½ä»…ä»…ç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼ï¼Œå› æ­¤æœ€å°å€¼(æ¯”å¦‚-20)ä¹˜ä»¥ä¸€ä¸ªæ¯”è¾ƒå°çš„æ•°(æ¯”å¦‚-10)
å¯èƒ½å°±ä¼šå¾ˆå¤§ã€‚ å› æ­¤è¿™ç§æ€è·¯å¹¶ä¸æ–¹ä¾¿ã€‚

é¦–å…ˆæ¥æš´åŠ›æ±‚è§£,æˆ‘ä»¬ä½¿ç”¨ä¸¤å±‚å¾ªç¯æ¥æšä¸¾æ‰€æœ‰å¯èƒ½é¡¹ï¼Œè¿™ç§è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2), ä»£ç å¦‚ä¸‹ï¼š

```js
var maxProduct = function(nums) {
  let max = nums[0];
  let temp = null;
  for (let i = 0; i < nums.length; i++) {
    temp = nums[i];
    max = Math.max(temp, max);
    for (let j = i + 1; j < nums.length; j++) {
      temp *= nums[j];
      max = Math.max(temp, max);
    }
  }

  return max;
};
```

å› æ­¤æˆ‘ä»¬éœ€è¦åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼ï¼Œç„¶åæ¯”è¾ƒå…ƒç´ å’Œè¿™ä¸¤ä¸ªçš„ä¹˜ç§¯ï¼Œå»ä¸æ–­æ›´æ–°æœ€å¤§å€¼ã€‚

è¿™ç§æ€è·¯çš„è§£æ³•ç”±äºåªéœ€è¦éå†ä¸€æ¬¡ï¼Œå…¶æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹

- åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  let max = nums[0];
  let min = nums[0];
  let res = nums[0];

  for (let i = 1; i < nums.length; i++) {
    let tmp = min;
    min = Math.min(nums[i], Math.min(max * nums[i], min * nums[i])); // å–æœ€å°
    max = Math.max(nums[i], Math.max(max * nums[i], tmp * nums[i])); /// å–æœ€å¤§
    res = Math.max(res, max);
  }
  return res;
};
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  if (nums.length == 0) return 0;
  let ans = nums[0],
    max = nums[0],
    min = nums[0];
  for (let i = 1, len = nums.length; i < len; i++) {
    if (nums[i] < 0) {
      let tmp = max;
      max = min;
      min = tmp;
    }
    max = Math.max(nums[i], max * nums[i]);
    min = Math.min(nums[i], min * nums[i]);

    ans = Math.max(max, ans);
  }
  return ans;
};

console.log(maxProduct([-2, 3, -4]));
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  var a = nums[0];
  var imin = a;
  var imax = a;
  var max = a;

  for (var i = 1; i < nums.length; i++) {
    var t = nums[i];
    if (t < 0) {
      var tmp = imin;
      imin = imax;
      imax = tmp;
    }
    imax = Math.max(t, t * imax);
    imin = Math.min(t, t * imin);
    max = Math.max(max, imax);
  }

  return max;
};

console.log(maxProduct([-1]));
console.log(maxProduct([1]));
console.log(maxProduct([1, 2, 3, -4]));
console.log(maxProduct([2, 3, -2, 4]));
```

### [155].æœ€å°æ ˆ min-stack

#### å…³é”®ç‚¹

- æœ€å°æ ˆå­˜å‚¨çš„ä¸åº”è¯¥æ˜¯çœŸå®å€¼ï¼Œè€Œæ˜¯çœŸå®å€¼å’Œ min çš„å·®å€¼
- top çš„æ—¶å€™æ¶‰åŠåˆ°å¯¹æ•°æ®çš„è¿˜åŸï¼Œè¿™é‡Œåƒä¸‡æ³¨æ„æ˜¯**ä¸Šä¸€ä¸ª**æœ€å°å€¼

#### ä»£ç 

```js
var MinStack = function() {
  this.stack = [];
  // å­˜å‚¨æœ€å°å€¼ï¼Œ å¯ä»¥ç›´æ¥å¼¹å‡ºï¼Œè€Œä¸ç”¨ä¿®æ”¹å¤šæ¬¡
  this.min = Number.MAX_VALUE;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  // update 'min'
  const min = this.min;
  if (x < this.min) {
    this.min = x;
  }
  return this.stack.push(x - min);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const item = this.stack.pop();
  const min = this.min;

  if (item < 0) {
    this.min = min - item;
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const item = this.stack[this.stack.length - 1];
  const min = this.min;

  if (item < 0) {
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.min;
};
```

### [169].æ±‚ä¼—æ•°

```
Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times.

You may assume that the array is non-empty and the majority element always exist in the array.

Example 1:
Input: [3,2,3]
Output: 3
Example 2:
Input: [2,2,1,1,1,2,2]
Output: 2
Time: O(n)
Sace: O(1)
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (nums.length === 1) return nums[0];
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > parseInt(nums.length / 2)) {
        return key;
      }
    }
    // console.log('i', i)
  }
};
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
export default function majorityElement(nums) {
  if (!nums.length) return 0;
  let majorityIndex = 0;
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    // If current num === majority number, count++
    if (nums[i] === nums[majorityIndex]) {
      count++;
    } else {
      count--;
    }
    // If count === 0, set to current num
    if (count === 0) {
      majorityIndex = i;
      count = 1;
    }
  }

  return nums[majorityIndex];
}
```

```js
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
  if (numerator == 0) return '0';

  const res = new Array();

  if ((numerator > 0) ^ (denominator > 0)) {
    res.push('-');
  }
  let num = Math.abs(numerator),
    den = Math.abs(denominator);
  res.push(parseInt(num / den));
  if (num % den == 0) return res.join('');

  res.push('.');
  num %= den;

  let map = new Map();
  while (true) {
    let curNum = parseInt((num * 10) / den);
    num = (num * 10) % den;
    if (map.has(curNum)) {
      const index = map.get(curNum);
      res.splice(index, 0, '(');
      res.push(')');
      break;
    } else if (num == 0) {
      res.push(curNum);
      break;
    } else {
      res.push(curNum);
      map.set(curNum, res.length - 1);
    }
  }
  return res.join('');
};
```

### [198].å¼ºç›—æŠ¢åŠ« house-robber

é¢˜ç›®æè¿°ï¼šæŠ¢åŠ«ä¸€æ’ä½æˆ·ï¼Œä½†æ˜¯ä¸èƒ½æŠ¢é‚»è¿‘çš„ä½æˆ·ï¼Œæ±‚æœ€å¤§æŠ¢åŠ«é‡ã€‚

#### æ€è·¯

æœ¬è´¨ä¸Šåœ¨è§£å†³ `å¯¹äºç¬¬[i] ä¸ªæˆ¿å­ï¼Œæˆ‘ä»¬æŠ¢è¿˜æ˜¯ä¸æŠ¢ã€‚` çš„é—®é¢˜ã€‚

å®šä¹‰ dp æ•°ç»„ç”¨æ¥å­˜å‚¨æœ€å¤§çš„æŠ¢åŠ«é‡ï¼Œå…¶ä¸­ `dp[i]` è¡¨ç¤ºæŠ¢åˆ°ç¬¬ i ä¸ªä½æˆ·æ—¶çš„æœ€å¤§æŠ¢åŠ«é‡ã€‚ç”±äºä¸èƒ½æŠ¢åŠ«é‚»è¿‘ä½æˆ·ï¼Œå¦‚æœæŠ¢åŠ«äº†ç¬¬ `i - 1` ä¸ªä½æˆ·ï¼Œé‚£ä¹ˆå°±ä¸èƒ½å†æŠ¢åŠ«ç¬¬ i ä¸ªä½æˆ·.

åˆ¤æ–­çš„æ ‡å‡†å°±æ˜¯æ€»ä»·å€¼å“ªä¸ªæ›´å¤§ï¼Œ é‚£ä¹ˆå¯¹äºæŠ¢çš„è¯ `å°±æ˜¯å½“å‰çš„æˆ¿å­å¯ä»¥æŠ¢çš„ä»·å€¼ + dp[i - 2]`

> i - 1 ä¸èƒ½æŠ¢ï¼Œå¦åˆ™ä¼šè§¦å‘è­¦é“ƒ

å¦‚æœä¸æŠ¢çš„è¯ï¼Œå°±æ˜¯`dp[i - 1]`.

> è¿™é‡Œçš„ dp å…¶å®å°±æ˜¯`å­é—®é¢˜`.

çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿä¸éš¾å†™`dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);`.

ä»”ç»†è§‚å¯Ÿçš„è¯ï¼Œåªéœ€è¦ä¿è¯å‰ä¸€ä¸ª dp[i - 1] å’Œ dp[i - 2] ä¸¤ä¸ªå˜é‡å°±å¥½äº†ï¼Œæ¯”å¦‚æˆ‘ä»¬è®¡ç®—åˆ° i = 6 çš„æ—¶å€™ï¼Œå³éœ€è¦è®¡ç®— dp[6]çš„æ—¶å€™ï¼Œ æˆ‘ä»¬éœ€è¦ dp[5], dp[4]ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸éœ€è¦ dp[3], dp[2] ...

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  const dp = [];
  dp[0] = 0;
  dp[1] = 0;

  for (let i = 2; i < nums.length + 2; i++) {
    // dp[i] è¡¨ç¤ºæŠ¢ i ä¹‹å‰ç§¯ç´¯çš„æ‰€æœ‰å’Œã€‚ éœ€è¦æ¯”è¾ƒ
    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);
  }

  // ç»“æœéœ€è¦å¾€åæ¨ä¸¤æ ¼ã€‚
  return dp[nums.length + 1];
  // [1, 2, 2]
  // [0, 0, 1, 2, 3]
};
```

```js
// æ¯”ä¸Šé¢çš„æ›´å¥½ç†è§£ä¸€äº›
// å…³è”çš„æ˜¯ 3 ä¸ªå€¼ï¼Œ i, i - 1, i - 2
function rob(nums = []) {
  // åˆ†åˆ«è¡¨ç¤ºå¾€å‰æ¨ä¸¤æ ¼çš„ç§¯ç´¯è´¢å¯Œå€¼ã€‚
  let pre2 = 0,
    pre1 = 0;
  for (let i = 0; i < nums.length; i++) {
    let cur = Math.max(pre2 + nums[i], pre1);
    pre2 = pre1;
    pre1 = cur;
  }
  return pre1;
}
```

### [199]. Binary Tree Right Side View

```js
// [199]. Binary Tree Right Side View

// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

// Example:

// Input: [1,2,3,null,5,null,4]
// Output: [1, 3, 4]
// Explanation:

//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

const getDepth = (node, depth, map) => {
  if (!node) return;
  map.set(node, depth);
  if (node.left) getDepth(node.left, depth + 1, map);
  if (node.right) getDepth(node.right, depth + 1, map);
};

export default function rightSideView(root) {
  // BFS from right to left
  const queue = [];
  const map = new Map();
  getDepth(root, 0, map);
  const ans = [];
  if (!root) return [];
  const set = new Set();

  queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    if (map.has(item)) {
      if (item.right) queue.push(item.right);
      if (item.left) queue.push(item.left);
      if (!set.has(map.get(item))) {
        ans.push(item.val);
        set.add(map.get(item));
      }
    }
  }
  return ans;
}
```

### [200].å²›å±¿æ•°é‡

ç»™ä½ ä¸€ä¸ªç”± Â '1'ï¼ˆé™†åœ°ï¼‰å’Œ '0'ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚

å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚

æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼š

```
grid = [
  ['1', '1', '1', '1', '0'],
  ['1', '1', '0', '1', '0'],
  ['1', '1', '0', '0', '0'],
  ['0', '0', '0', '0', '0'],
];
```

è¾“å‡ºï¼š1
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼š

```
grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]

```

è¾“å‡ºï¼š3

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  if (grid.length == 0) return 0;
  let count = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] == 1) {
        count++;
        helper(i, j, grid);
      }
    }
  }
  return count;
};

function helper(i, j, grid) {
  grid[i][j] = 'OK';
  if (i > 0 && grid[i - 1][j] == 1)
    // ä¸Š
    helper(i - 1, j, grid);
  if (i < grid.length - 1 && grid[i + 1][j] == 1)
    // ä¸‹
    helper(i + 1, j, grid);
  if (j > 0 && grid[i][j - 1] == 1)
    // å·¦
    helper(i, j - 1, grid);
  if (i < grid[0].length + 1 && grid[i][j + 1] == 1)
    // å³
    helper(i, j + 1, grid);
}

numIslands([
  ['1', '0', '1', '1', '1'],
  ['1', '0', '1', '0', '1'],
  ['1', '1', '1', '0', '1'],
]);
```
