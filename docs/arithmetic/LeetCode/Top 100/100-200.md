---
layout: CustomPages
title: LeetCode-åˆé›† 100-200
date: 2020.09.04
aside: false
draft: true
---

### [101].

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  return helper(root, root);
};

function helper(l, r) {
  if (l == null && r == null) return true;
  if (l == null || r == null) return false;
  return l.val == r.val && helper(l.left, r.right) && helper(l.right, r.left);
}
```

### [102].binary-tree-level-order-traversal

```
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

#### æ€è·¯

è¿™é“é¢˜å¯ä»¥å€ŸåŠ©`é˜Ÿåˆ—`å®ç°ï¼Œé¦–å…ˆæŠŠ root å…¥é˜Ÿï¼Œç„¶åå…¥é˜Ÿä¸€ä¸ªç‰¹æ®Šå…ƒç´  Null(æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸ)ã€‚

ç„¶åå°±æ˜¯ while(queue.length), æ¯æ¬¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å­èŠ‚ç‚¹(åœ¨è¿™é‡Œæ˜¯ left å’Œ right)æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚

ç„¶åä¸æ–­çš„å‡ºé˜Ÿï¼Œ å¦‚æœå‡ºé˜Ÿçš„æ˜¯ nullï¼Œåˆ™è¡¨å¼è¿™ä¸€å±‚å·²ç»ç»“æŸäº†ï¼Œæˆ‘ä»¬å°±ç»§ç»­ push ä¸€ä¸ª nullã€‚

å¦‚æœä¸å…¥é˜Ÿç‰¹æ®Šå…ƒç´  Null æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸï¼Œåˆ™åœ¨ while å¾ªç¯å¼€å§‹æ—¶ä¿å­˜å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ï¼Œä»¥ä¿è¯æ¯æ¬¡åªéå†ä¸€å±‚(å‚è€ƒä¸‹é¢çš„ C++ Code)ã€‚

> å¦‚æœé‡‡ç”¨é€’å½’æ–¹å¼ï¼Œåˆ™éœ€è¦å°†å½“å‰èŠ‚ç‚¹ï¼Œå½“å‰æ‰€åœ¨çš„ level ä»¥åŠç»“æœæ•°ç»„ä¼ é€’ç»™é€’å½’å‡½æ•°ã€‚åœ¨é€’å½’å‡½æ•°ä¸­ï¼Œå–å‡ºèŠ‚ç‚¹çš„å€¼ï¼Œæ·»åŠ åˆ° level å‚æ•°å¯¹åº”ç»“æœæ•°ç»„å…ƒç´ ä¸­(å‚è€ƒä¸‹é¢çš„ C++ Code)ã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

- æ³¨æ„å¡å…¥ null çš„æ—¶å€™ï¼Œåˆ¤æ–­ä¸€ä¸‹å½“å‰é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œä¸ç„¶ä¼šæ— é™å¾ªç¯

#### ä»£ç 

```js
// [102]. Binary Tree Level Order Traversal

// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

// For example:
// Given binary tree [3,9,20,null,null,15,7],

//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its level order traversal as:

// [
//   [3],
//   [9,20],
//   [15,7]
// ]

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
export default function levelOrder(root) {
  if (!root) return [];
  const queue = [];
  queue.push(root);
  const ans = [];
  const depths = new Map();
  depths.set(root, 0);
  let prev;
  let arr = [];
  while (queue.length) {
    const item = queue.shift();
    const depth = depths.get(item);
    if (!prev || (prev && depths.get(prev) !== depths.get(item))) {
      arr = [];
      ans.push(arr);
    }
    arr.push(item.val);
    if (item.left) {
      depths.set(item.left, depth + 1);
      queue.push(item.left);
    }
    if (item.right) {
      depths.set(item.right, depth + 1);
      queue.push(item.right);
    }
    prev = item;
  }
  return ans;
}
```

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  if (!root) return [];
  const items = []; // å­˜æ”¾æ‰€æœ‰èŠ‚ç‚¹
  const queue = [root, null]; // null ç®€åŒ–æ“ä½œ
  let levelNodes = []; // å­˜æ”¾æ¯ä¸€å±‚çš„èŠ‚ç‚¹

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      // ä¸€å±‚å·²ç»éå†å®Œäº†
      items.push(levelNodes);
      levelNodes = [];
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  let ans = [];
  helper(root, ans, 0);
  return ans;
};

function helper(node, ans, i) {
  if (node == null) return;
  if (i == ans.length) ans.push([]);
  ans[i].push(node.val);

  helper(node.left, ans, i + 1);
  helper(node.right, ans, i + 1);
}
```

### [103].binary-tree-zigzag-level-order-traversal

å’Œ leetcode 102 åŸºæœ¬æ˜¯ä¸€æ ·çš„ï¼Œæ€è·¯æ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚

```
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```

#### æ€è·¯

è¿™é“é¢˜å¯ä»¥å€ŸåŠ©`é˜Ÿåˆ—`å®ç°ï¼Œé¦–å…ˆæŠŠ root å…¥é˜Ÿï¼Œç„¶åå…¥é˜Ÿä¸€ä¸ªç‰¹æ®Šå…ƒç´  Null(æ¥è¡¨ç¤ºæ¯å±‚çš„ç»“æŸ)ã€‚

ç„¶åå°±æ˜¯ while(queue.length), æ¯æ¬¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å­èŠ‚ç‚¹(åœ¨è¿™é‡Œæ˜¯ left å’Œ right)æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚

ç„¶åä¸æ–­çš„å‡ºé˜Ÿï¼Œ å¦‚æœå‡ºé˜Ÿçš„æ˜¯ nullï¼Œåˆ™è¡¨å¼è¿™ä¸€å±‚å·²ç»ç»“æŸäº†ï¼Œæˆ‘ä»¬å°±ç»§ç»­ push ä¸€ä¸ª nullã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

#### ä»£ç 

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
  if (!root) return [];
  const items = [];
  let isOdd = true;
  let levelNodes = [];

  const queue = [root, null];

  while (queue.length > 0) {
    const t = queue.shift();

    if (t) {
      levelNodes.push(t.val);
      if (t.left) {
        queue.push(t.left);
      }
      if (t.right) {
        queue.push(t.right);
      }
    } else {
      if (!isOdd) {
        levelNodes = levelNodes.reverse();
      }
      items.push(levelNodes);
      levelNodes = [];
      isOdd = !isOdd;
      if (queue.length > 0) {
        queue.push(null);
      }
    }
  }

  return items;
};
```

### [104].äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ Maximum Depth of Binary Tree

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7

```

return its depth = 3.

#### æ€è·¯

ç”±äºæ ‘æ˜¯ä¸€ç§é€’å½’çš„æ•°æ®ç»“æ„ï¼Œå› æ­¤ç”¨é€’å½’å»è§£å†³çš„æ—¶å€™å¾€å¾€éå¸¸å®¹æ˜“

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

å¦‚æœä½¿ç”¨è¿­ä»£å‘¢ï¼Ÿ æˆ‘ä»¬é¦–å…ˆåº”è¯¥æƒ³åˆ°çš„æ˜¯æ ‘çš„å„ç§éå†ï¼Œç”±äºæˆ‘ä»¬æ±‚çš„æ˜¯æ·±åº¦ï¼Œå› æ­¤
ä½¿ç”¨å±‚æ¬¡éå†(BFS)æ˜¯éå¸¸åˆé€‚çš„ã€‚ æˆ‘ä»¬åªéœ€è¦è®°å½•æœ‰å¤šå°‘å±‚å³å¯ã€‚

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—

- é˜Ÿåˆ—ä¸­ç”¨ Null(ä¸€ä¸ªç‰¹æ®Šå…ƒç´ )æ¥åˆ’åˆ†æ¯å±‚ï¼Œæˆ–è€…åœ¨å¯¹æ¯å±‚è¿›è¡Œè¿­ä»£ä¹‹å‰ä¿å­˜å½“å‰é˜Ÿåˆ—å…ƒç´ çš„ä¸ªæ•°(å³å½“å‰å±‚æ‰€å«å…ƒç´ ä¸ªæ•°)

- æ ‘çš„åŸºæœ¬æ“ä½œ- éå† - å±‚æ¬¡éå†(BFS)

#### ä»£ç 

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) return 0;
  if (!root.left && !root.right) return 1;

  // å±‚æ¬¡éå† BFS
  let cur = root;
  const queue = [root, null];
  let depth = 1;

  while ((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      // æ³¨æ„âš ï¸ï¼š ä¸å¤„ç†ä¼šæ— é™å¾ªç¯ï¼Œè¿›è€Œå †æ ˆæº¢å‡º
      if (queue.length === 0) return depth;
      depth++;
      queue.push(null);
      continue;
    }
    const l = cur.left;
    const r = cur.right;

    if (l) queue.push(l);
    if (r) queue.push(r);
  }

  return depth;
};
```

### [105].ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

#### å‚è€ƒç­”æ¡ˆ

é€’å½’æ„é€ äºŒå‰æ ‘ï¼Œæ—¶é—´å¤æ‚åº¦ O(n)

> å…³é”®åœ¨äºå‰åºéå†å’Œä¸­åºéå†çš„ç‰¹æ€§:

- å‰åºéå†ï¼šæ ¹èŠ‚ç‚¹æ˜¯é¦–å…ƒç´ 
- ä¸­åºéå†ï¼šæ ¹èŠ‚ç‚¹å·¦ä¾§çš„å€¼æ˜¯å…¶å·¦å­æ ‘ï¼Œå³ä¾§çš„å€¼æ˜¯å…¶å³å­æ ‘
  > å› æ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆè¦å¾—åˆ°ä»å‰åºåºåˆ—ä¸­è·å–æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†ä¸­åºåºåˆ—ï¼Œæ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®ï¼Œä»¥æ­¤ç›´åˆ°å…¶å·¦å­æ ‘å’Œå³å­æ ‘çš„èŒƒå›´ã€‚å½“æˆ‘ä»¬å¾—åˆ°å…¶å·¦å­æ ‘ä¹‹åï¼Œäº‹æƒ…å°±å¼€å§‹é‡å¤äº†ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦æ ¹æ®å‰åºåºåˆ—ä¸­æ‰¾åˆ°è¿™é¢—å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œç„¶åå†æ ¹æ®ä¸­åºåºåˆ—å¾—åˆ°è¿™é¢—å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼Œå³å­æ ‘åŒç†ã€‚å› æ­¤å®é™…ä¸Šå°±æ˜¯ä¸ªå›æº¯ã€‚

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  return helper(0, 0, inorder.length - 1, preorder, inorder);
};

function helper(preStart, inStart, inEnd, preorder, inorder) {
  if (preStart > preorder.length - 1 || inStart > inEnd) {
    return null;
  }
  let root = new TreeNode(preorder[preStart]);
  let inIndex = 0;
  for (let i = inStart; i <= inEnd; i++) {
    if (inorder[i] == root.val) {
      inIndex = i;
    }
  }
  root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
  root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
  return root;
}
```

### [110].å¹³è¡¡äºŒå‰æ ‘ Balanced Binary Tree DONE

```html
3 / \ 9 20 / \ 15 7
```

```js
function maxDepth(root) {
  if (root == null) return 0;
  const l = maxDepth(root.left);
  const r = maxDepth(root.right);
  if (l === false || r === false) return false;
  // å¹³è¡¡äºŒå‰æ ‘æ˜¯ å·¦å³æ ‘çš„æ·±åº¦å·®å°äº 1 ï¼Ÿ
  // å¹³è¡¡æ ‘å·¦å³å­æ ‘é«˜åº¦å·®éƒ½å°äºç­‰äº 1
  if (Math.abs(l - r) > 1) return false;
  return 1 + Math.max(l, r);
}
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
  if (root === null) return true;
  return !!maxDepth(root);
};
```

### [114].flatten-binary-tree-to-linked-list

```js
function preorderTraversal(root) {
  if (!root) return [];

  return [root].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));
}
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return root;
  const res = preorderTraversal(root);

  let curPos = 0;
  let curNode = null;

  while ((curNode = res[curPos])) {
    curNode.left = null;
    curNode.right = res[++curPos];
  }
};
```

### [121].ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº DONE

ç›¸å½“äºæ‰¾ä¸€ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼ä¸æœ€å°å€¼çš„å·®å€¼ã€‚

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let min = prices[0];
  let profit = 0;
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = Math.max(profit, prices[i] - min);
    } else {
      min = Math.min(min, prices[i]);
    }
  }
  return profit;
};

console.log(maxProfit([7, 1, 5, 3, 6, 4]));
console.log(maxProfit([7, 6, 4, 3, 1]));
console.log(maxProfit([1, 4, 2]));
```

### [124].binary-tree-maximum-path-sum

```
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

#### å…³é”®ç‚¹è§£æ

- é€’å½’
- ç†è§£é¢˜ç›®ä¸­çš„ path å®šä¹‰

#### ä»£ç 

```js
function helper(node, payload) {
  if (node === null) return 0;

  const l = helper(node.left, payload);
  const r = helper(node.right, payload);

  payload.max = Math.max(node.val + Math.max(0, l) + Math.max(0, r), payload.max);

  return node.val + Math.max(l, r, 0);
}
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
  if (root === null) return 0;
  const payload = {
    max: root.val,
  };
  helper(root, payload);
  return payload.max;
};
```

### [124].

```js
let maxValue;

var maxPathSum = function(root) {
  maxValue = Number.MIN_SAFE_INTEGER;
  find(root);
  return maxValue;
};

function find(node) {
  if (node == null) return 0;
  let left = Math.max(0, find(node.left)); // è·å–å·¦ä¾§æœ€å¤§å’Œ
  let right = Math.max(0, find(node.right)); // è·å–å³ä¾§æœ€å¤§å’Œ
  maxValue = Math.max(maxValue, left + right + node.val); // è·å¾—æœ€å¤§å€¼
  return Math.max(left, right) + node.val; // è¿”å›æœ€å¤§å€¼
}
```

### [128].æœ€é•¿è¿ç»­åºåˆ— longest-consecutive-sequence DONE

```html
Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
```

è¦æ±‚ä»¥ O(N) çš„æ—¶é—´å¤æ‚åº¦æ±‚è§£ã€‚

#### æ€è·¯

è¿™æ˜¯ä¸€é“æœ€æœ€é•¿è¿ç»­æ•°å­—åºåˆ—é•¿åº¦çš„é¢˜ç›®ï¼Œ å®˜ç½‘ç»™å‡ºçš„éš¾åº¦æ˜¯`hard`.

ç¬¦åˆç›´è§‰çš„åšæ³•æ˜¯å…ˆæ’åºï¼Œç„¶åç”¨ä¸€ä¸ªå˜é‡è®°å½•æœ€å¤§å€¼ï¼Œéå†å»æ›´æ–°æœ€å¤§å€¼å³å¯ï¼Œ

```js
if (nums.length === 0) return 0;
let count = 1;
let maxCount = 1;
// è¿™é‡Œå…¶å®å¯ä»¥ä¸éœ€è¦æ’åºï¼Œè¿™ä¹ˆåšåªä¸è¿‡æ˜¯ä¸ºäº†æ–¹ä¾¿ç†è§£
nums = [...new Set(nums)].sort((a, b) => a - b);
for (let i = 0; i < nums.length - 1; i++) {
  if (nums[i + 1] - nums[i] === 1) {
    count++;
  } else {
    if (count > maxCount) {
      maxCount = count;
    }
    count = 1;
  }
}
return Math.max(count, maxCount);
```

ä½†æ˜¯éœ€è¦æ’åºæ—¶é—´å¤æ‚åº¦ä¼šä¸Šå‡ï¼Œé¢˜ç›®è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n),
é‚£ä¹ˆæˆ‘ä»¬å…¶å®å¯ä»¥ä¸ç”¨æ’åºå»è§£å†³çš„ã€‚

æ€è·¯å°±æ˜¯å°†ä¹‹å‰â€æ’åºä¹‹åï¼Œé€šè¿‡æ¯”è¾ƒå‰åå…ƒç´ æ˜¯å¦ç›¸å·® 1 æ¥åˆ¤æ–­æ˜¯å¦è¿ç»­â€œçš„æ€è·¯æ”¹ä¸ºä¸æ’åºè€Œæ˜¯`ç›´æ¥éå†ï¼Œç„¶ååœ¨å†…éƒ¨å¾ªç¯é‡Œé¢æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `ï¼Œä½†æ˜¯é©¬ä¸Šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå†…éƒ¨æˆ‘ä»¬`æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å½“å‰å€¼çš„é‚»å±…å…ƒç´ `çš„è¿‡ç¨‹å¦‚æœä½¿ç”¨æ•°ç»„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n),é‚£ä¹ˆæ€»ä½“çš„å¤æ‚åº¦å°±æ˜¯ O(n^2)ï¼Œå®Œå…¨ä¸å¯ä»¥æ¥å—ã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿ

æˆ‘ä»¬æ¢ä¸ªæ€è·¯ï¼Œç”¨ç©ºé—´æ¥æ¢æ—¶é—´ã€‚æ¯”å¦‚ç”¨ç±»ä¼¼äº hashmap è¿™æ ·çš„æ•°æ®ç»“æ„ä¼˜åŒ–æŸ¥è¯¢éƒ¨åˆ†ï¼Œå°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ° O(1).

å…³é”®ç‚¹å°±æ˜¯ç©ºé—´æ¢æ—¶é—´ã€‚

#### ä»£ç 

```js
var longestConsecutive = function(nums) {
  // ç›´æ¥å°†æ•°ç»„è½¬åŒ–ä¸ºä¸€ä¸ª Set hashmap ç»“æ„
  nums = new Set(nums);
  let max = 0;
  let y = 0;
  nums.forEach(x => {
    // è¯´æ˜ x æ˜¯è¿ç»­åºåˆ—çš„å¼€å¤´å…ƒç´ .  ä¸å« x - 1 æ˜¯ä¸ºäº†é¿å…é‡å¤è®¡ç®—
    if (!nums.has(x - 1)) {
      y = x + 1;
      while (nums.has(y)) {
        y = y + 1;
      }
      max = Math.max(max, y - x); // y - x å°±æ˜¯ä» x å¼€å§‹åˆ°æœ€åæœ‰å¤šå°‘è¿ç»­çš„æ•°å­—
    }
  });
  return max;
};
```

### [134].gas-station

```js
function getIndex(index, n) {
  if (index > n - 1) {
    return index - n;
  }
  return index;
}
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
  // bad æ—¶é—´å¤æ‚åº¦O(n^2)
  //   let remain = 0;
  //   const n = gas.length;
  //   for (let i = 0; i < gas.length; i++) {
  //     remain += gas[i];
  //     remain -= cost[i];
  //     let count = 0;
  //     while (remain >= 0) {
  //       count++;
  //       if (count === n) return i;
  //       remain += gas[getIndex(i + count, n)];
  //       remain -= cost[getIndex(i + count, n)];
  //     }
  //     remain = 0;
  //   }
  //   return -1;
  // better solution æ—¶é—´å¤æ‚åº¦O(n)

  const n = gas.length;
  let total = 0;
  let remain = 0;
  let start = 0;

  for (let i = 0; i < n; i++) {
    total += gas[i];
    total -= cost[i];

    remain += gas[i];
    remain -= cost[i];

    // å¦‚æœremain < 0, è¯´æ˜ä»startåˆ°ièµ°ä¸é€š
    // å¹¶ä¸”ä»startåˆ°ièµ°ä¸é€šï¼Œé‚£ä¹ˆæ‰€æœ‰çš„solutionä¸­åŒ…å«startåˆ°içš„è‚¯å®šéƒ½èµ°ä¸é€š
    // å› æ­¤æˆ‘ä»¬é‡æ–°ä»i + 1å¼€å§‹ä½œä¸ºstart
    if (remain < 0) {
      remain = 0;
      start = i + 1;
    }
  }
  // äº‹å®ä¸Šï¼Œæˆ‘ä»¬éå†ä¸€éï¼Œä¹Ÿå°±ç¡®å®šäº†æ¯ä¸€ä¸ªå…ƒç´ ä½œä¸ºstartæ˜¯å¦å¯ä»¥èµ°å®Œä¸€åœˆ

  // å¦‚æœcostæ€»å’Œå¤§äºgasæ€»å’Œï¼Œæ— è®ºå¦‚ä½•ä¹Ÿæ— æ³•èµ°åˆ°ç»ˆç‚¹
  return total >= 0 ? start : -1;
};
```

### [136].Single-Number

```js
var singleNumber = function(nums) {
  var a = 0;
  for (let val of nums) a ^= val;
  return a;
};
```

```js
// ç»™å®šä¸€ä¸ªéç©ºæ•´æ•°æ•°ç»„ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚

// è¯´æ˜ï¼š

// ä½ çš„ç®—æ³•åº”è¯¥å…·æœ‰çº¿æ€§æ—¶é—´å¤æ‚åº¦ã€‚ ä½ å¯ä»¥ä¸ä½¿ç”¨é¢å¤–ç©ºé—´æ¥å®ç°å—ï¼Ÿ

// ç¤ºä¾‹ 1:

// è¾“å…¥: [2,2,1]
// è¾“å‡º: 1
// ç¤ºä¾‹Â 2:

// è¾“å…¥: [4,1,2,1,2]
// è¾“å‡º: 4

// æ€è·¯
// æ ‡ç­¾ï¼šä½è¿ç®—
// æœ¬é¢˜æ ¹æ®é¢˜æ„ï¼Œçº¿æ€§æ—¶é—´å¤æ‚åº¦ O(n)O(n)ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ä½¿ç”¨ Hash æ˜ å°„æ¥è¿›è¡Œè®¡ç®—ï¼Œéå†ä¸€æ¬¡åç»“æŸå¾—åˆ°ç»“æœï¼Œä½†æ˜¯åœ¨ç©ºé—´å¤æ‚åº¦ä¸Šä¼šè¾¾åˆ° O(n)O(n)ï¼Œéœ€è¦ä½¿ç”¨è¾ƒå¤šçš„é¢å¤–ç©ºé—´
// æ—¢æ»¡è¶³æ—¶é—´å¤æ‚åº¦åˆæ»¡è¶³ç©ºé—´å¤æ‚åº¦ï¼Œå°±è¦æåˆ°ä½è¿ç®—ä¸­çš„å¼‚æˆ–è¿ç®— XORï¼Œä¸»è¦å› ä¸ºå¼‚æˆ–è¿ç®—æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š

//  [1]. ä¸€ä¸ªæ•°å’Œ 0 åš XOR è¿ç®—ç­‰äºæœ¬èº«ï¼ša^0 = a
//  [2]. ä¸€ä¸ªæ•°å’Œå…¶æœ¬èº«åš XOR è¿ç®—ç­‰äº 0ï¼ša^a = 0
//  [3]. XOR è¿ç®—æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼ša^b^a = (a^a)^b = 0^b = b

// æ•…è€Œåœ¨ä»¥ä¸Šçš„åŸºç¡€æ¡ä»¶ä¸Šï¼Œå°†æ‰€æœ‰æ•°å­—æŒ‰ç…§é¡ºåºåšæŠ‘æˆ–è¿ç®—ï¼Œæœ€åå‰©ä¸‹çš„ç»“æœå³ä¸ºå”¯ä¸€çš„æ•°å­—
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)

// reduce æ€§èƒ½æ€§å¯¹å¥½äº›
// 84 ms	40.2 MB
var singleNumber = function(nums = []) {
  return nums.reduce((ret, n) => ret ^ n, 0);
};

// 88 ms	40.8 MB
var singleNumber1 = function(nums) {
  let ans = 0;
  for (const num of nums) {
    ans ^= num;
  }
  return ans;
};

export default function SingleNumber2(nums = []) {
  for (let i = 0; i < nums.length; i++) {
    if (set.has(nums[i])) {
      set.delete(nums[i]);
    } else {
      set.add(nums[i]);
    }
  }

  const item = Array.from(set)[0];
  set.clear();

  return item;
}

console.log(singleNumber([1, 2, 2]) == 1);
console.log(singleNumber([1, 2, 1]) == 2);
```

### [136].single-number

```
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
```

#### æ€è·¯

æ ¹æ®é¢˜ç›®æè¿°ï¼Œç”±äºåŠ ä¸Šäº†æ—¶é—´å¤æ‚åº¦å¿…é¡»æ˜¯ O(n)ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦ä¸º O(1)çš„æ¡ä»¶ï¼Œå› æ­¤ä¸èƒ½ç”¨æ’åºæ–¹æ³•ï¼Œä¹Ÿä¸èƒ½ä½¿ç”¨ map æ•°æ®ç»“æ„ã€‚

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨äºŒè¿›åˆ¶å¼‚æˆ–çš„æ€§è´¨æ¥å®Œæˆï¼Œå°†æ‰€æœ‰æ•°å­—å¼‚æˆ–å³å¾—åˆ°å”¯ä¸€å‡ºç°çš„æ•°å­—ã€‚

#### å…³é”®ç‚¹

1. å¼‚æˆ–çš„æ€§è´¨
   ä¸¤ä¸ªæ•°å­—å¼‚æˆ–çš„ç»“æœ`a^b`æ˜¯å°† a å’Œ b çš„äºŒè¿›åˆ¶æ¯ä¸€ä½è¿›è¡Œè¿ç®—ï¼Œå¾—å‡ºçš„æ•°å­—ã€‚ è¿ç®—çš„é€»è¾‘æ˜¯
   å¦‚æœåŒä¸€ä½çš„æ•°å­—ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1

2. å¼‚æˆ–çš„è§„å¾‹

- ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º`0`

- ä»»ä½•æ•°å’Œ 0 å¼‚æˆ–æ˜¯`æœ¬èº«`

3. å¾ˆå¤šäººåªæ˜¯è®°å¾—å¼‚æˆ–çš„æ€§è´¨å’Œè§„å¾‹ï¼Œä½†æ˜¯ç¼ºä¹å¯¹å…¶æœ¬è´¨çš„ç†è§£ï¼Œå¯¼è‡´å¾ˆéš¾æƒ³åˆ°è¿™ç§è§£æ³•(æˆ‘æœ¬äººä¹Ÿæ²¡æƒ³åˆ°)

4. bit è¿ç®—

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  let ret = 0;
  for (let index = 0; index < nums.length; index++) {
    const element = nums[index];
    ret = ret ^ element;
  }
  return ret;
};
```

#### å»¶ä¼¸

æœ‰ä¸€ä¸ª n ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œé™¤äº†ä¸¤ä¸ªæ•°åªå‡ºç°ä¸€æ¬¡å¤–ï¼Œå…¶ä½™å…ƒç´ éƒ½å‡ºç°ä¸¤æ¬¡ï¼Œè®©ä½ æ‰¾å‡ºè¿™ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°åˆ†åˆ«æ˜¯å‡ ï¼Œè¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(n) ä¸”å†å¼€è¾Ÿçš„å†…å­˜ç©ºé—´å›ºå®š(ä¸ n æ— å…³)ã€‚

å’Œä¸Šé¢ä¸€æ ·ï¼Œåªæ˜¯è¿™æ¬¡ä¸æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä¸¤ä¸ªæ•°å­—ã€‚è¿˜æ˜¯æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œæˆ‘ä»¬è¿›è¡Œä¸€æ¬¡å…¨å‘˜å¼‚æˆ–æ“ä½œï¼Œ
å¾—åˆ°çš„ç»“æœå°±æ˜¯é‚£ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„ä¸åŒçš„æ•°å­—çš„å¼‚æˆ–ç»“æœã€‚

æˆ‘ä»¬åˆšæ‰è®²äº†å¼‚æˆ–çš„è§„å¾‹ä¸­æœ‰ä¸€ä¸ª`ä»»ä½•æ•°å’Œæœ¬èº«å¼‚æˆ–åˆ™ä¸º0`ï¼Œ å› æ­¤æˆ‘ä»¬çš„æ€è·¯æ˜¯èƒ½ä¸èƒ½å°†è¿™ä¸¤ä¸ªä¸åŒçš„æ•°å­—åˆ†æˆä¸¤ç»„ A å’Œ Bã€‚
åˆ†ç»„éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶.

1. ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—åˆ†æˆä¸åŒç»„

2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„

è¿™æ ·æ¯ä¸€ç»„çš„æ•°æ®è¿›è¡Œå¼‚æˆ–å³å¯å¾—åˆ°é‚£ä¸¤ä¸ªæ•°å­—ã€‚

é—®é¢˜çš„å…³é”®ç‚¹æ˜¯æˆ‘ä»¬æ€ä¹ˆè¿›è¡Œåˆ†ç»„å‘¢ï¼Ÿ

ç”±äºå¼‚æˆ–çš„æ€§è´¨æ˜¯ï¼ŒåŒä¸€ä½ç›¸åŒåˆ™ä¸º 0ï¼Œä¸åŒåˆ™ä¸º 1. æˆ‘ä»¬å°†æ‰€æœ‰æ•°å­—å¼‚æˆ–çš„ç»“æœä¸€å®šä¸æ˜¯ 0ï¼Œä¹Ÿå°±æ˜¯è¯´è‡³å°‘æœ‰ä¸€ä½æ˜¯ 1.

æˆ‘ä»¬éšä¾¿å–ä¸€ä¸ªï¼Œ åˆ†ç»„çš„ä¾æ®å°±æ¥äº†ï¼Œ å°±æ˜¯ä½ å–çš„é‚£ä¸€ä½æ˜¯ 0 åˆ†æˆ 1 ç»„ï¼Œé‚£ä¸€ä½æ˜¯ 1 çš„åˆ†æˆä¸€ç»„ã€‚
è¿™æ ·è‚¯å®šèƒ½ä¿è¯`2. ç›¸åŒçš„æ•°å­—åˆ†æˆç›¸åŒç»„`, ä¸åŒçš„æ•°å­—ä¼šè¢«åˆ†æˆä¸åŒç»„ä¹ˆã€‚ å¾ˆæ˜æ˜¾å½“ç„¶å¯ä»¥ï¼Œ å› æ­¤æˆ‘ä»¬é€‰æ‹©æ˜¯ 1ï¼Œä¹Ÿå°±æ˜¯
è¯´`ä¸¤ä¸ªç‹¬ç‰¹çš„çš„æ•°å­—`åœ¨é‚£ä¸€ä½ä¸€å®šæ˜¯ä¸åŒçš„ï¼Œå› æ­¤ä¸¤ä¸ªç‹¬ç‰¹å…ƒç´ ä¸€å®šä¼šè¢«åˆ†æˆä¸åŒç»„ã€‚

Doneï¼

### [139].word-break

```
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false

```

#### æ€è·¯

è¿™é“é¢˜æ˜¯ç»™å®šä¸€ä¸ªå­—å…¸å’Œä¸€ä¸ªå¥å­ï¼Œåˆ¤æ–­è¯¥å¥å­æ˜¯å¦å¯ä»¥ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„å‡ºæ¥ï¼Œä¸€ä¸ªå•è¯å¯ä»¥ç”¨å¤šæ¬¡ã€‚

æš´åŠ›çš„æ–¹æ³•æ˜¯æ— è§£çš„ï¼Œå¤æ‚åº¦æå…¶é«˜ã€‚ æˆ‘ä»¬è€ƒè™‘å…¶æ˜¯å¦å¯ä»¥æ‹†åˆ†ä¸ºå°é—®é¢˜æ¥è§£å†³ã€‚
å¯¹äºé—®é¢˜`(s, wordDict)` æˆ‘ä»¬æ˜¯å¦å¯ä»¥ç”¨(s', wordDict) æ¥è§£å†³ã€‚ å…¶ä¸­ s' æ˜¯ s çš„å­åºåˆ—ï¼Œ
å½“ s'å˜æˆå¯»å¸¸(é•¿åº¦ä¸º 0)çš„æ—¶å€™é—®é¢˜å°±è§£å†³äº†ã€‚ æˆ‘ä»¬çŠ¶æ€è½¬ç§»æ–¹ç¨‹å˜æˆäº†è¿™é“é¢˜çš„éš¾ç‚¹ã€‚

æˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ªæ•°ç»„ dp, dp[i]ä»£è¡¨ å­—ç¬¦ä¸² s.substring(0, i) èƒ½å¦ç”±å­—å…¸é‡Œé¢çš„å•è¯ç»„æˆï¼Œ
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæˆ‘ä»¬æ— æ³•å»ºç«‹ dp[i] å’Œ dp[i - 1] çš„å…³ç³»ï¼Œ
æˆ‘ä»¬å¯ä»¥å»ºç«‹çš„æ˜¯ dp[i - word.length] å’Œ dp[i] çš„å…³ç³»ã€‚

æˆ‘ä»¬ç”¨å›¾æ¥æ„Ÿå—ä¸€ä¸‹ï¼š

æ²¡æœ‰æ˜ç™½ä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬åˆ†æ­¥éª¤è§£è¯»ä¸€ä¸‹ï¼š

(ä»¥ä¸‹çš„å›¾å·¦è¾¹éƒ½ä»£è¡¨ sï¼Œå³è¾¹éƒ½æ˜¯ dictï¼Œç°è‰²ä»£è¡¨æ²¡æœ‰å¤„ç†çš„å­—ç¬¦ï¼Œç»¿è‰²ä»£è¡¨åŒ¹é…æˆåŠŸï¼Œçº¢è‰²ä»£è¡¨åŒ¹é…å¤±è´¥)

ä¸Šé¢åˆ†æ­¥è§£é‡Šäº†ç®—æ³•çš„åŸºæœ¬è¿‡ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬æ„Ÿæ€§è®¤è¯†ä¸‹è¿™é“é¢˜ï¼Œæˆ‘æŠŠå®ƒæ¯”å–»ä¸º
ä½ æ­£åœ¨`å¾€ä¸€ä¸ªè€å¼æ‰‹ç”µç­’ğŸ”¦ä¸­è£…ç”µæ± `

#### ä»£ç 

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  const dp = Array(s.length + 1);
  dp[0] = true;
  for (let i = 0; i < s.length + 1; i++) {
    for (let word of wordDict) {
      if (dp[i - word.length] && word.length <= i) {
        if (s.substring(i - word.length, i) === word) {
          dp[i] = true;
        }
      }
    }
  }

  return dp[s.length] || false;
};
```

### [139].Word-Break

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  var n = s.length;

  var dp = [true];
  for (var i = 1; i < n + 1; i++) {
    for (var j = 0; j < i; j++) {
      if (dp[j] && wordDict.indexOf(s.substring(j, i)) > -1) {
        dp[i] = true;
        break;
      } else {
        dp[i] = false;
      }
    }
  }
  // console.log(dp);
  return dp[n];
};

console.log(wordBreak('leetcode', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('', ['lee', 'leet', 'cod', 'code']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'e']));
console.log(wordBreak('lee', ['l', 'leet', 'cod', 'code', 'leetco']));
```

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
  let dp = new Array(s.length + 1);
  dp.fill(false);
  dp[0] = true;

  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      if (dp[j] && wordDict.includes(s.slice(j, i))) {
        dp[i] = true;
        break;
      }
    }
  }
  return dp[s.length];
};
```

### [140].

```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
  if (canStringBeSegmented(s, wordDict)) {
    return getAllPossibleSegments(s, wordDict, {});
  } else {
    return [];
  }
};
// DFS
function getAllPossibleSegments(s, dict, map) {
  if (s in map) return map[s];
  const result = [];
  if (dict.includes(s)) result.push(s);
  for (let i = 1; i < s.length; i++) {
    const left = s.substring(0, i);
    const right = s.substring(i);
    if (dict.includes(left) && containsSuffix(dict, right)) {
      for (let segment of getAllPossibleSegments(right, dict, map)) {
        result.push(`${left} ${segment}`);
      }
    }
  }
  map[s] = result;
  return result;
}

function containsSuffix(dict, str) {
  for (let i = 0; i < str.length; i++) {
    if (dict.includes(str.substring(i))) return true;
  }
  return false;
}
// ä½¿ç”¨ dp åˆ¤æ–­èƒ½å¦
function canStringBeSegmented(inputStr, inputDict) {
  const memTable = Array(inputStr.length + 1).fill(false);
  memTable[0] = true;

  for (let i = 1; i <= inputStr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (memTable[j] && inputDict.includes(inputStr.substring(j, i))) {
        memTable[i] = true;
        break;
      }
    }
  }
  return memTable[inputStr.length];
}
```

### [141].åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯ linked-list-cycle DONE

[link](https://leetcode-cn.com/problems/linked-list-cycle)

ä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå­˜åœ¨ç¯ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šç›¸é‡ã€‚

```js
/**
 * å“ˆå¸Œè¡¨ Set add has æ¥æŸ¥è¯¢
 * ç‰ºç‰²äº†ç©ºé—´æ¢æ—¶é—´
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  // åœæ­¢æ¡ä»¶ï¼š 1. Set åˆ¤æ–­å‡ºæœ‰ç¯ 2. æ— ç¯ï¼Œæ­£å¸¸ç»“æŸ
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */

//  å¿«æ…¢æŒ‡é’ˆã€‚ å¦‚æœæœ‰ç¯ï¼Œå¿«æŒ‡é’ˆä¸€å®šèƒ½è¿½ä¸Šæ…¢æŒ‡é’ˆ
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // å¿«æŒ‡é’ˆä¸€æ¬¡ç§»åŠ¨ä¸¤ä¸ª
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### [146].

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.map = {};
  this.set = new Set();
  this.capacity = capacity;
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.map[key]) {
    // key already exist, we need to delete the key and add to end
    this.set.delete(key);
    this.set.add(key);
    return this.map[key];
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if (this.map[key]) {
    // remove this key and add back in set, update in hashmap
    this.set.delete(key);
  } else {
    if (this.set.size >= this.capacity) {
      var it = this.set.values();
      var oldKey = it.next().value;
      delete this.map[oldKey];
      this.set.delete(oldKey);
    }
  }
  this.set.add(key);
  this.map[key] = value;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = Object.create(LRUCache).createNew(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [146].lru-cache

```
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

```

#### æ€è·¯

ç”±äºæ˜¯ä¿ç•™æ˜¯æœ€è¿‘ä½¿ç”¨çš„ N æ¡æ•°æ®ï¼Œè¿™å°±å’Œé˜Ÿåˆ—çš„ç‰¹æ€§å¾ˆç¬¦åˆï¼Œ å…ˆè¿›å…¥é˜Ÿåˆ—çš„ï¼Œå…ˆå‡ºé˜Ÿåˆ—ã€‚

å› æ­¤æ€è·¯å°±æ˜¯ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥è®°å½•ç›®å‰ç¼“å­˜çš„æ‰€æœ‰ keyï¼Œ æ¯æ¬¡ push éƒ½è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœ
è¶…å‡ºæœ€å¤§å®¹é‡é™åˆ¶åˆ™è¿›è¡Œæ¸…é™¤ç¼“å­˜çš„æ“ä½œï¼Œ å…·ä½“æ¸…é™¤è°å°±æŒ‰ç…§åˆšæ‰è¯´çš„é˜Ÿåˆ—æ–¹å¼è¿›è¡Œå¤„ç†ï¼ŒåŒæ—¶å¯¹ key è¿›è¡Œå…¥é˜Ÿæ“ä½œã€‚

get çš„æ—¶å€™ï¼Œå¦‚æœç¼“å­˜ä¸­æœ‰ï¼Œåˆ™è°ƒæ•´é˜Ÿåˆ—(å…·ä½“æ“ä½œä¸ºåˆ é™¤æŒ‡å®šå…ƒç´ å’Œå…¥é˜Ÿä¸¤ä¸ªæ“ä½œ)ã€‚ ç¼“å­˜ä¸­æ²¡æœ‰åˆ™è¿”å›-1

#### å…³é”®ç‚¹è§£æ

- é˜Ÿåˆ—ç®€åŒ–æ“ä½œ

- é˜Ÿåˆ—çš„æ“ä½œæ˜¯è¿™é“é¢˜çš„çµé­‚ï¼Œ å¾ˆå®¹æ˜“å°‘è€ƒè™‘æƒ…å†µ

#### ä»£ç 

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.cache = {};
  this.capacity = capacity;
  this.size = 0;
  this.queue = [];
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  const hit = this.cache[key];

  if (hit !== undefined) {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
    return hit;
  }
  return -1;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  const hit = this.cache[key];

  // update cache
  this.cache[key] = value;

  if (!hit) {
    // invalid cache and resize size;
    if (this.size === this.capacity) {
      // invalid cache
      const key = this.queue.shift();
      this.cache[key] = undefined;
    } else {
      this.size = this.size + 1;
    }
    this.queue.push(key);
  } else {
    this.queue = this.queue.filter(q => q !== key);
    this.queue.push(key);
  }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

### [148].æ’åºé“¾è¡¨

ç»™ä½ é“¾è¡¨çš„å¤´ç»“ç‚¹ Â headÂ ï¼Œè¯·å°†å…¶æŒ‰ å‡åº æ’åˆ—å¹¶è¿”å› æ’åºåçš„é“¾è¡¨ ã€‚

è¿›é˜¶ï¼š

ä½ å¯ä»¥åœ¨ Â O(nÂ logÂ n) æ—¶é—´å¤æ‚åº¦å’Œå¸¸æ•°çº§ç©ºé—´å¤æ‚åº¦ä¸‹ï¼Œå¯¹é“¾è¡¨è¿›è¡Œæ’åºå—ï¼Ÿ

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
  if (head == null || head.next == null) return head;

  let prev = null,
    slow = head,
    fast = head;

  while (fast != null && fast.next != null) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }

  prev.next = null;

  let l1 = sortList(head);
  let l2 = sortList(slow);

  return merge(l1, l2);
};

function merge(l1, l2) {
  let l = new ListNode(0),
    p = l;

  while (l1 != null && l2 != null) {
    if (l1.val < l2.val) {
      p.next = l1;
      l1 = l1.next;
    } else {
      p.next = l2;
      l2 = l2.next;
    }
    p = p.next;
  }

  if (l1 != null) p.next = l1;
  if (l2 != null) p.next = l2;

  return l.next;
}
```

### [150].evaluate-reverse-polish-notation

```
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
```

#### æ€è·¯

é€†æ³¢å…°è¡¨è¾¾å¼åˆå«åšåç¼€è¡¨è¾¾å¼ã€‚åœ¨é€šå¸¸çš„è¡¨è¾¾å¼ä¸­ï¼ŒäºŒå…ƒè¿ç®—ç¬¦æ€»æ˜¯ç½®äºä¸ä¹‹ç›¸å…³çš„ä¸¤ä¸ªè¿ç®—å¯¹è±¡ä¹‹é—´ï¼Œè¿™ç§è¡¨ç¤ºæ³•ä¹Ÿç§°ä¸º`ä¸­ç¼€è¡¨ç¤º`ã€‚

æ³¢å…°é€»è¾‘å­¦å®¶ J.Lukasiewicz äº 1929 å¹´æå‡ºäº†å¦ä¸€ç§è¡¨ç¤ºè¡¨è¾¾å¼çš„æ–¹æ³•ï¼ŒæŒ‰æ­¤æ–¹æ³•ï¼Œæ¯ä¸€è¿ç®—ç¬¦éƒ½ç½®äºå…¶è¿ç®—å¯¹è±¡ä¹‹åï¼Œæ•…ç§°ä¸º`åç¼€è¡¨ç¤º`ã€‚

> é€†æ³¢å…°è¡¨è¾¾å¼æ˜¯ä¸€ç§ååˆ†æœ‰ç”¨çš„è¡¨è¾¾å¼ï¼Œå®ƒå°†å¤æ‚è¡¨è¾¾å¼è½¬æ¢ä¸ºå¯ä»¥ä¾é ç®€å•çš„æ“ä½œå¾—åˆ°è®¡ç®—ç»“æœçš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚(a+b)_(c+d)è½¬æ¢ä¸º ab+cd+_

#### å…³é”®ç‚¹

1. æ ˆçš„åŸºæœ¬ç”¨æ³•

2. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦æ³¨æ„/ å’Œ å…¶ä»–å¾ˆå¤šè¯­è¨€æ˜¯ä¸ä¸€æ ·çš„

3. å¦‚æœä½ ç”¨çš„æ˜¯ JS çš„è¯ï¼Œéœ€è¦å…ˆå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•°å­—ã€‚å¦åˆ™æœ‰å¾ˆå¤šæ„æƒ³ä¸åˆ°çš„ç»“æœ

4. æ“ä½œç¬¦çš„é¡ºåºåº”è¯¥æ˜¯ å…ˆå‡ºæ ˆçš„æ˜¯ç¬¬äºŒä½ï¼Œåå‡ºæ ˆçš„æ˜¯ç¬¬ä¸€ä½ã€‚ è¿™åœ¨ä¸ç¬¦åˆäº¤æ¢å¾‹çš„æ“ä½œä¸­å¾ˆé‡è¦ï¼Œ æ¯”å¦‚å‡æ³•å’Œé™¤æ³•ã€‚

#### ä»£ç 

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  // è¿™ç§ç®—æ³•çš„å‰ææ˜¯ tokensæ˜¯æœ‰æ•ˆçš„ï¼Œ
  // å½“ç„¶è¿™ç”±ç®—æ³•æ¥ä¿è¯
  const stack = [];

  for (let index = 0; index < tokens.length; index++) {
    const token = tokens[index];
    // å¯¹äºè¿ç®—æ•°ï¼Œ æˆ‘ä»¬ç›´æ¥å…¥æ ˆ
    if (!Number.isNaN(Number(token))) {
      stack.push(token);
    } else {
      // é‡åˆ°æ“ä½œç¬¦ï¼Œæˆ‘ä»¬ç›´æ¥å¤§èƒ†è¿ç®—ï¼Œä¸ç”¨è€ƒè™‘ç®—æœ¯ä¼˜å…ˆçº§
      // ç„¶åå°†è¿ç®—ç»“æœå…¥æ ˆå³å¯

      // å½“ç„¶å¦‚æœé¢˜ç›®è¿›ä¸€æ­¥æ‰©å±•ï¼Œå…è®¸ä½¿ç”¨å•ç›®ç­‰å…¶ä»–è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬çš„ç®—æ³•éœ€è¦åšå¾®å°çš„è°ƒæ•´
      const a = Number(stack.pop());
      const b = Number(stack.pop());
      if (token === '*') {
        stack.push(b * a);
      } else if (token === '/') {
        stack.push((b / a) >> 0);
      } else if (token === '+') {
        stack.push(b + a);
      } else if (token === '-') {
        stack.push(b - a);
      }
    }
  }

  return stack.pop();
};
```

#### æ‰©å±•

é€†æ³¢å…°è¡¨è¾¾å¼ä¸­åªæ”¹å˜è¿ç®—ç¬¦çš„é¡ºåºï¼Œå¹¶ä¸ä¼šæ”¹å˜æ“ä½œæ•°çš„ç›¸å¯¹é¡ºåºï¼Œè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ€§è´¨ã€‚
å¦å¤–é€†æ³¢å…°è¡¨è¾¾å¼å®Œå…¨ä¸å…³å¿ƒæ“ä½œç¬¦çš„ä¼˜å…ˆçº§ï¼Œè¿™åœ¨ä¸­ç¼€è¡¨è¾¾å¼ä¸­æ˜¯åšä¸åˆ°çš„ï¼Œè¿™å¾ˆæœ‰è¶£ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥ç§ä¸‹æŸ¥æ‰¾èµ„æ–™ç ”ç©¶ä¸‹ä¸ºä»€ä¹ˆä¼šè¿™æ ·ã€‚

### [152].maximum-product-subarray

```
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```

#### æ€è·¯

> è¿™é“é¢˜ç›®çš„é€šè¿‡ç‡éå¸¸ä½

è¿™é“é¢˜ç›®è¦æˆ‘ä»¬æ±‚è§£è¿ç»­çš„ n ä¸ªæ•°ä¸­ä¹˜ç§¯æœ€å¤§çš„ç§¯æ˜¯å¤šå°‘ã€‚è¿™é‡Œæåˆ°äº†è¿ç»­ï¼Œç¬”è€…é¦–å…ˆ
æƒ³åˆ°çš„å°±æ˜¯æ»‘åŠ¨çª—å£ï¼Œä½†æ˜¯è¿™é‡Œæ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬ä¸èƒ½ä»…ä»…ç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼ï¼Œå› æ­¤æœ€å°å€¼(æ¯”å¦‚-20)ä¹˜ä»¥ä¸€ä¸ªæ¯”è¾ƒå°çš„æ•°(æ¯”å¦‚-10)
å¯èƒ½å°±ä¼šå¾ˆå¤§ã€‚ å› æ­¤è¿™ç§æ€è·¯å¹¶ä¸æ–¹ä¾¿ã€‚

é¦–å…ˆæ¥æš´åŠ›æ±‚è§£,æˆ‘ä»¬ä½¿ç”¨ä¸¤å±‚å¾ªç¯æ¥æšä¸¾æ‰€æœ‰å¯èƒ½é¡¹ï¼Œè¿™ç§è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2), ä»£ç å¦‚ä¸‹ï¼š

```js
var maxProduct = function(nums) {
  let max = nums[0];
  let temp = null;
  for (let i = 0; i < nums.length; i++) {
    temp = nums[i];
    max = Math.max(temp, max);
    for (let j = i + 1; j < nums.length; j++) {
      temp *= nums[j];
      max = Math.max(temp, max);
    }
  }

  return max;
};
```

å› æ­¤æˆ‘ä»¬éœ€è¦åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼ï¼Œç„¶åæ¯”è¾ƒå…ƒç´ å’Œè¿™ä¸¤ä¸ªçš„ä¹˜ç§¯ï¼Œå»ä¸æ–­æ›´æ–°æœ€å¤§å€¼ã€‚

è¿™ç§æ€è·¯çš„è§£æ³•ç”±äºåªéœ€è¦éå†ä¸€æ¬¡ï¼Œå…¶æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œä»£ç è§ä¸‹æ–¹ä»£ç åŒºã€‚

#### å…³é”®ç‚¹

- åŒæ—¶è®°å½•ä¹˜ç§¯æœ€å¤§å€¼å’Œä¹˜ç§¯æœ€å°å€¼

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  let max = nums[0];
  let min = nums[0];
  let res = nums[0];

  for (let i = 1; i < nums.length; i++) {
    let tmp = min;
    min = Math.min(nums[i], Math.min(max * nums[i], min * nums[i])); // å–æœ€å°
    max = Math.max(nums[i], Math.max(max * nums[i], tmp * nums[i])); /// å–æœ€å¤§
    res = Math.max(res, max);
  }
  return res;
};
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  if (nums.length == 0) return 0;
  let ans = nums[0],
    max = nums[0],
    min = nums[0];
  for (let i = 1, len = nums.length; i < len; i++) {
    if (nums[i] < 0) {
      let tmp = max;
      max = min;
      min = tmp;
    }
    max = Math.max(nums[i], max * nums[i]);
    min = Math.min(nums[i], min * nums[i]);

    ans = Math.max(max, ans);
  }
  return ans;
};

console.log(maxProduct([-2, 3, -4]));
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
  var a = nums[0];
  var imin = a;
  var imax = a;
  var max = a;

  for (var i = 1; i < nums.length; i++) {
    var t = nums[i];
    if (t < 0) {
      var tmp = imin;
      imin = imax;
      imax = tmp;
    }
    imax = Math.max(t, t * imax);
    imin = Math.min(t, t * imin);
    max = Math.max(max, imax);
  }

  return max;
};

console.log(maxProduct([-1]));
console.log(maxProduct([1]));
console.log(maxProduct([1, 2, 3, -4]));
console.log(maxProduct([2, 3, -2, 4]));
```

### [155].æœ€å°æ ˆ min-stack

```
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.

```

#### æ€è·¯

ç¬¦åˆç›´è§‰çš„æ–¹æ³•æ˜¯ï¼Œæ¯æ¬¡å¯¹æ ˆè¿›è¡Œä¿®æ”¹æ“ä½œ(push å’Œ pop)çš„æ—¶å€™æ›´æ–°æœ€å°å€¼ã€‚ ç„¶å getMin åªéœ€è¦è¿”å›æˆ‘ä»¬è®¡ç®—çš„æœ€å°å€¼å³å¯ï¼Œ
top ä¹Ÿæ˜¯ç›´æ¥è¿”å›æ ˆé¡¶å…ƒç´ å³å¯ã€‚ è¿™ç§åšæ³•æ¯æ¬¡ä¿®æ”¹æ ˆéƒ½éœ€è¦æ›´æ–°æœ€å°å€¼ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦æ˜¯ O(n).

æ˜¯å¦æœ‰æ›´é«˜æ•ˆçš„ç®—æ³•å‘¢ï¼Ÿç­”æ¡ˆæ˜¯æœ‰çš„ã€‚

æˆ‘ä»¬æ¯æ¬¡å…¥æ ˆçš„æ—¶å€™ï¼Œä¿å­˜çš„ä¸å†æ˜¯çœŸæ­£çš„æ•°å­—ï¼Œè€Œæ˜¯å®ƒä¸å½“å‰æœ€å°å€¼çš„å·®(å½“å‰å…ƒç´ æ²¡æœ‰å…¥æ ˆçš„æ—¶å€™çš„æœ€å°å€¼)ã€‚
è¿™æ ·æˆ‘ä»¬ pop å’Œ top çš„æ—¶å€™æ‹¿åˆ°æ ˆé¡¶å…ƒç´ å†åŠ ä¸Š**ä¸Šä¸€ä¸ª**æœ€å°å€¼å³å¯ã€‚
å¦å¤–æˆ‘ä»¬åœ¨ push å’Œ pop çš„æ—¶å€™å»æ›´æ–° minï¼Œè¿™æ · getMin çš„æ—¶å€™å°±ç®€å•äº†ï¼Œç›´æ¥è¿”å› minã€‚

> æ³¨æ„ä¸Šé¢åŠ ç²—çš„â€œä¸Šä¸€ä¸ªâ€ï¼Œä¸æ˜¯â€œå½“å‰çš„æœ€å°å€¼â€

ç»è¿‡ä¸Šé¢çš„åˆ†æï¼Œé—®é¢˜çš„å…³é”®è½¬åŒ–ä¸ºâ€œå¦‚æœæ±‚çš„ä¸Šä¸€ä¸ªæœ€å°å€¼â€ï¼Œè§£å†³è¿™ä¸ªçš„å…³é”®ç‚¹åœ¨äºåˆ©ç”¨ minã€‚

pop æˆ–è€… top çš„æ—¶å€™ï¼š

- å¦‚æœæ ˆé¡¶å…ƒç´ å°äº 0ï¼Œè¯´æ˜æ ˆé¡¶æ˜¯å½“å‰æœ€å°çš„å…ƒç´ ï¼Œå®ƒå‡ºæ ˆä¼šå¯¹ min é€ æˆå½±å“ï¼Œæˆ‘ä»¬éœ€è¦å»æ›´æ–° minã€‚
  ä¸Šä¸€ä¸ªæœ€å°çš„æ˜¯â€œmin - æ ˆé¡¶å…ƒç´ â€,æˆ‘ä»¬éœ€è¦å°†ä¸Šä¸€ä¸ªæœ€å°å€¼æ›´æ–°ä¸ºå½“å‰çš„æœ€å°å€¼

> å› ä¸ºæ ˆé¡¶å…ƒç´ å…¥æ ˆçš„æ—¶å€™çš„é€šè¿‡ `æ ˆé¡¶å…ƒç´  = çœŸå®å€¼ - ä¸Šä¸€ä¸ªæœ€å°çš„å…ƒç´ ` å¾—åˆ°çš„ï¼Œ
> è€ŒçœŸå®å€¼ = minï¼Œ å› æ­¤å¯ä»¥å¾—å‡º`ä¸Šä¸€ä¸ªæœ€å°çš„å…ƒç´  = çœŸå®å€¼ -æ ˆé¡¶å…ƒç´ `

- å¦‚æœæ ˆé¡¶å…ƒç´ å¤§äº 0ï¼Œè¯´æ˜å®ƒå¯¹æœ€å°å€¼`æ²¡æœ‰å½±å“`ï¼Œä¸Šä¸€ä¸ªæœ€å°å€¼å°±æ˜¯ä¸Šä¸Šä¸ªæœ€å°å€¼ã€‚

#### å…³é”®ç‚¹

- æœ€å°æ ˆå­˜å‚¨çš„ä¸åº”è¯¥æ˜¯çœŸå®å€¼ï¼Œè€Œæ˜¯çœŸå®å€¼å’Œ min çš„å·®å€¼
- top çš„æ—¶å€™æ¶‰åŠåˆ°å¯¹æ•°æ®çš„è¿˜åŸï¼Œè¿™é‡Œåƒä¸‡æ³¨æ„æ˜¯**ä¸Šä¸€ä¸ª**æœ€å°å€¼

#### ä»£ç 

```js
var MinStack = function() {
  this.stack = [];
  this.min = Number.MAX_VALUE;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  // update 'min'
  const min = this.min;
  if (x < this.min) {
    this.min = x;
  }
  return this.stack.push(x - min);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const item = this.stack.pop();
  const min = this.min;

  if (item < 0) {
    this.min = min - item;
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const item = this.stack[this.stack.length - 1];
  const min = this.min;

  if (item < 0) {
    return min;
  }
  return item + min;
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.min;
};
```

```js
var MinStack = function() {
  this.value = [];
  this.minIndex = -1;
  return this;
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.value.push(x);
  if (this.minIndex === -1 || this.value[this.minIndex] > x) {
    // æ ˆé¡¶
    this.minIndex = this.value.length - 1;
  }
  return this.value.length;
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  const popValue = this.value.pop();
  this.minIndex = 0;
  for (let i = 0; i < this.value.length; i++) {
    if (this.value[i] < this.value[this.minIndex]) {
      this.minIndex = i;
    }
  }
  return popValue;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  const length = this.value.length;
  return this.value[length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return this.value[this.minIndex];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */

const minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
console.log(minStack.getMin());
console.log(minStack.pop());
console.log(minStack.top());
console.log(minStack.getMin());
```

```js
/**
 * initialize your data structure here.
 */
var MinStack = function() {
  this.stack = [];
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.stack.push(x);
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  this.stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  let min = this.stack[0];
  for (let val of this.stack) {
    if (val < min) min = val;
  }
  return min;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = Object.create(MinStack).createNew()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

### [160].æ‰¾å‡ºä¸¤ä¸ªé“¾è¡¨çš„äº¤ç‚¹ intersection-of-two-linked-lists

[link](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

æ‰¾åˆ°ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚

æ³¨æ„ï¼š

1. å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null.
1. åœ¨è¿”å›ç»“æœåï¼Œä¸¤ä¸ªé“¾è¡¨ä»é¡»ä¿æŒåŸæœ‰çš„ç»“æ„ã€‚
1. å¯å‡å®šæ•´ä¸ªé“¾è¡¨ç»“æ„ä¸­æ²¡æœ‰å¾ªç¯ã€‚
1. ç¨‹åºå°½é‡æ»¡è¶³ O(n) æ—¶é—´å¤æ‚åº¦ï¼Œä¸”ä»…ç”¨ O(1) å†…å­˜ã€‚

#### æ€è·¯

è®¾ A çš„é•¿åº¦ä¸º a + cï¼ŒB çš„é•¿åº¦ä¸º b + cï¼Œå…¶ä¸­ c ä¸ºå°¾éƒ¨å…¬å…±éƒ¨åˆ†é•¿åº¦ï¼Œå¯çŸ¥ a + c + b = b + c + aã€‚

å½“è®¿é—® A é“¾è¡¨çš„æŒ‡é’ˆè®¿é—®åˆ°é“¾è¡¨å°¾éƒ¨æ—¶ï¼Œä»¤å®ƒä»é“¾è¡¨ B çš„å¤´éƒ¨å¼€å§‹è®¿é—®é“¾è¡¨ Bï¼›åŒæ ·åœ°ï¼Œå½“è®¿é—® B é“¾è¡¨çš„æŒ‡é’ˆè®¿é—®åˆ°é“¾è¡¨å°¾éƒ¨æ—¶ï¼Œä»¤å®ƒä»é“¾è¡¨ A çš„å¤´éƒ¨å¼€å§‹è®¿é—®é“¾è¡¨ Aã€‚è¿™æ ·å°±èƒ½æ§åˆ¶è®¿é—® A å’Œ B ä¸¤ä¸ªé“¾è¡¨çš„æŒ‡é’ˆèƒ½åŒæ—¶è®¿é—®åˆ°äº¤ç‚¹ã€‚

å¦‚æœä¸å­˜åœ¨äº¤ç‚¹ï¼Œé‚£ä¹ˆ a + b = b + aï¼Œä»¥ä¸‹å®ç°ä»£ç ä¸­ l1 å’Œ l2 ä¼šåŒæ—¶ä¸º nullï¼Œä»è€Œé€€å‡ºå¾ªç¯ã€‚

TODO:
å¦‚æœåªæ˜¯åˆ¤æ–­æ˜¯å¦å­˜åœ¨äº¤ç‚¹ï¼Œé‚£ä¹ˆå°±æ˜¯å¦ä¸€ä¸ªé—®é¢˜ï¼Œå³ [ç¼–ç¨‹ä¹‹ç¾ 3.6]() çš„é—®é¢˜ã€‚æœ‰ä¸¤ç§è§£æ³•ï¼š

- æŠŠç¬¬ä¸€ä¸ªé“¾è¡¨çš„ç»“å°¾è¿æ¥åˆ°ç¬¬äºŒä¸ªé“¾è¡¨çš„å¼€å¤´ï¼Œçœ‹ç¬¬äºŒä¸ªé“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯ï¼›
- æˆ–è€…ç›´æ¥æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸åŒã€‚

#### Code

```js
var getIntersectionNode = function(l1, l2) {
  let head1 = l1,
    head2 = l2;
  while (head1 !== head2) {
    head1 = head1 === null ? l2 : head1.next;
    head2 = head2 === null ? l1 : head2.next;
  }
  return head1 ? head1.val : null;
};
```

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  // å…ˆç›´æ¥å‘å‰ç§»åŠ¨å·®è·çš„æ ¼æ•°
  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

### [169].æ±‚ä¼—æ•°

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (nums.length === 1) return nums[0];
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    const key = nums[i];
    if (map[key] === undefined) {
      map[key] = 1;
    } else {
      map[key]++;
      if (map[key] > parseInt(nums.length / 2)) {
        return key;
      }
    }
    // console.log('i', i)
  }
};

// console.log(majorityElement([1]))
// console.log(majorityElement([3, 2, 3]))
// console.log(majorityElement([2, 2, 1, 1, 1, 2, 2]))
```

```js
// [169]. Majority Element

// Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times.

// You may assume that the array is non-empty and the majority element always exist in the array.

// Example 1:

// Input: [3,2,3]
// Output: 3
// Example 2:

// Input: [2,2,1,1,1,2,2]
// Output: 2

// Time: O(n)
// Sace: O(1)

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function majorityElement(nums) {
  if (!nums.length) return 0;
  let majorityIndex = 0;
  let count = 1;

  for (let i = 1; i < nums.length; i++) {
    // If current num === majority number, count++
    if (nums[i] === nums[majorityIndex]) {
      count++;
    } else {
      count--;
    }
    // If count === 0, set to current num
    if (count === 0) {
      majorityIndex = i;
      count = 1;
    }
  }

  return nums[majorityIndex];
}
```

```js
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
  if (numerator == 0) return '0';

  const res = new Array();

  if ((numerator > 0) ^ (denominator > 0)) {
    res.push('-');
  }
  let num = Math.abs(numerator),
    den = Math.abs(denominator);
  res.push(parseInt(num / den));
  if (num % den == 0) return res.join('');

  res.push('.');
  num %= den;

  let map = new Map();
  while (true) {
    let curNum = parseInt((num * 10) / den);
    num = (num * 10) % den;
    if (map.has(curNum)) {
      const index = map.get(curNum);
      res.splice(index, 0, '(');
      res.push(')');
      break;
    } else if (num == 0) {
      res.push(curNum);
      break;
    } else {
      res.push(curNum);
      map.set(curNum, res.length - 1);
    }
  }
  return res.join('');
};
```

### [198].å¼ºç›—æŠ¢åŠ« house-robber

é¢˜ç›®æè¿°ï¼šæŠ¢åŠ«ä¸€æ’ä½æˆ·ï¼Œä½†æ˜¯ä¸èƒ½æŠ¢é‚»è¿‘çš„ä½æˆ·ï¼Œæ±‚æœ€å¤§æŠ¢åŠ«é‡ã€‚

#### æ€è·¯

æ€è·¯è¿˜æ˜¯å’Œå…¶ä»–ç®€å•çš„åŠ¨æ€è§„åˆ’é—®é¢˜ä¸€æ ·ï¼Œæˆ‘ä»¬æœ¬è´¨ä¸Šåœ¨è§£å†³`å¯¹äºç¬¬[i] ä¸ªæˆ¿å­ï¼Œæˆ‘ä»¬æŠ¢è¿˜æ˜¯ä¸æŠ¢ã€‚`çš„é—®é¢˜ã€‚

åˆ¤æ–­çš„æ ‡å‡†å°±æ˜¯æ€»ä»·å€¼å“ªä¸ªæ›´å¤§ï¼Œ é‚£ä¹ˆå¯¹äºæŠ¢çš„è¯`å°±æ˜¯å½“å‰çš„æˆ¿å­å¯ä»¥æŠ¢çš„ä»·å€¼ + dp[i - 2]`

> i - 1 ä¸èƒ½æŠ¢ï¼Œå¦åˆ™ä¼šè§¦å‘è­¦é“ƒ

å¦‚æœä¸æŠ¢çš„è¯ï¼Œå°±æ˜¯`dp[i - 1]`.

> è¿™é‡Œçš„ dp å…¶å®å°±æ˜¯`å­é—®é¢˜`.

çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿä¸éš¾å†™`dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);`.

ä¸Šè¿°è¿‡ç¨‹ç”¨å›¾æ¥è¡¨ç¤ºçš„è¯ï¼Œæ˜¯è¿™æ ·çš„ï¼š

æˆ‘ä»¬ä»”ç»†è§‚å¯Ÿçš„è¯ï¼Œå…¶å®æˆ‘ä»¬åªéœ€è¦ä¿è¯å‰ä¸€ä¸ª dp[i - 1] å’Œ dp[i - 2] ä¸¤ä¸ªå˜é‡å°±å¥½äº†ï¼Œ
æ¯”å¦‚æˆ‘ä»¬è®¡ç®—åˆ° i = 6 çš„æ—¶å€™ï¼Œå³éœ€è¦è®¡ç®— dp[6]çš„æ—¶å€™ï¼Œ æˆ‘ä»¬éœ€è¦ dp[5], dp[4]ï¼Œä½†æ˜¯æˆ‘ä»¬
ä¸éœ€è¦ dp[3], dp[2] ...

å› æ­¤ä»£ç å¯ä»¥ç®€åŒ–ä¸ºï¼š

```js
let a = 0;
let b = 0;

for (let i = 0; i < nums.length; i++) {
  const temp = b;
  b = Math.max(a + nums[i], b);
  a = temp;
}

return b;
```

å¦‚ä¸Šçš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¤æ‚åº¦è¿›è¡Œä¼˜åŒ–ï¼Œä» O(n)é™ä½åˆ° O(1),
ç±»ä¼¼çš„ä¼˜åŒ–åœ¨ DP é—®é¢˜ä¸­ä¸åœ¨å°‘æ•°ã€‚

> åŠ¨æ€è§„åˆ’é—®é¢˜æ˜¯é€’å½’é—®é¢˜æŸ¥è¡¨ï¼Œé¿å…é‡å¤è®¡ç®—ï¼Œä»è€ŒèŠ‚çœæ—¶é—´ã€‚
> å¦‚æœæˆ‘ä»¬å¯¹é—®é¢˜åŠ ä»¥åˆ†æå’ŒæŠ½è±¡ï¼Œæœ‰å¯èƒ½å¯¹ç©ºé—´ä¸Šè¿›ä¸€æ­¥ä¼˜åŒ–

å®šä¹‰ dp æ•°ç»„ç”¨æ¥å­˜å‚¨æœ€å¤§çš„æŠ¢åŠ«é‡ï¼Œå…¶ä¸­ `dp[i]` è¡¨ç¤ºæŠ¢åˆ°ç¬¬ i ä¸ªä½æˆ·æ—¶çš„æœ€å¤§æŠ¢åŠ«é‡ã€‚ç”±äºä¸èƒ½æŠ¢åŠ«é‚»è¿‘ä½æˆ·ï¼Œå¦‚æœæŠ¢åŠ«äº†ç¬¬ `i - 1` ä¸ªä½æˆ·ï¼Œé‚£ä¹ˆå°±ä¸èƒ½å†æŠ¢åŠ«ç¬¬ i ä¸ªä½æˆ·.

#### å…³é”®ç‚¹è§£æ

#### ä»£ç 

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  // Tag: DP
  const dp = [];
  dp[0] = 0;
  dp[1] = 0;

  for (let i = 2; i < nums.length + 2; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);
  }

  return dp[nums.length + 1];
};
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  let a = 0,
    b = 0;
  for (let i = 0; i < nums.length; i++) {
    if (i % 2 == 0) {
      a = Math.max(b, a + nums[i]);
    } else {
      b = Math.max(a, b + nums[i]);
    }
  }
  return Math.max(a, b);
};
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
  if (!nums.length) return 0;
  var dp = [0, nums[0]];
  var max = nums[0];
  for (var i = 1; i < nums.length; i++) {
    dp[i + 1] = Math.max(dp[i], dp[i - 1] + nums[i]);
    max = Math.max(dp[i + 1], max);
  }
  return max;
};

console.log(rob([5, 2, 3, 5, 8]));
```

```js
const robAux = (nums, i, map) => {
  if (i >= nums.length) return 0;
  if (map.has(i)) return map.get(i);
  const a = robAux(nums, i + 1, map);
  const b = robAux(nums, i + 2, map);
  const curr = Math.max(a, b + nums[i]);
  map.set(i, curr);
  return curr;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
export default function rob(nums) {
  const map = new Map();
  return robAux(nums, 0, map);
}
```

### [199]. Binary Tree Right Side View

```js
// [199]. Binary Tree Right Side View

// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

// Example:

// Input: [1,2,3,null,5,null,4]
// Output: [1, 3, 4]
// Explanation:

//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

const getDepth = (node, depth, map) => {
  if (!node) return;
  map.set(node, depth);
  if (node.left) getDepth(node.left, depth + 1, map);
  if (node.right) getDepth(node.right, depth + 1, map);
};

export default function rightSideView(root) {
  // BFS from right to left
  const queue = [];
  const map = new Map();
  getDepth(root, 0, map);
  const ans = [];
  if (!root) return [];
  const set = new Set();

  queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    if (map.has(item)) {
      if (item.right) queue.push(item.right);
      if (item.left) queue.push(item.left);
      if (!set.has(map.get(item))) {
        ans.push(item.val);
        set.add(map.get(item));
      }
    }
  }
  return ans;
}
```

### [200].

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  if (grid.length == 0) return 0;
  let count = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] == 1) {
        count++;
        helper(i, j, grid);
      }
    }
  }
  return count;
};

function helper(i, j, grid) {
  grid[i][j] = 'OK';
  if (i > 0 && grid[i - 1][j] == 1)
    // ä¸Š
    helper(i - 1, j, grid);
  if (i < grid.length - 1 && grid[i + 1][j] == 1)
    // ä¸‹
    helper(i + 1, j, grid);
  if (j > 0 && grid[i][j - 1] == 1)
    // å·¦
    helper(i, j - 1, grid);
  if (i < grid[0].length + 1 && grid[i][j + 1] == 1)
    // å³
    helper(i, j + 1, grid);
}

numIslands([
  ['1', '0', '1', '1', '1'],
  ['1', '0', '1', '0', '1'],
  ['1', '1', '1', '0', '1'],
]);
```
