---
layout: CustomPages
title: 常见算法公式
date: 2020-11-29
aside: false
---

# 常见算法公式

## String

### 回文判断

```js
var isPalindrome = function(s) {
  // \w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
  s = s.replace(/[^\w]/g, '').toLowerCase();
  return (
    s
      .split('')
      .reverse()
      .join('') === s
  );
};
```

### 二分查找

在计算 mid 时不能使用 `mid = (i + j) / 2` 这种方式，因为 `i + j` 可能会导致加法溢出，应该使用 `mid = i + (i - j) / 2`

非递归版本：

```js
const binarySearch = (arr, target) => {
  let i = 0,
    j = arr.length - 1;
  while (i <= j) {
    // let mid = i + parseInt((j - i) / 2);
    let mid = (i + j) >> 1;
    if (target === arr[mid]) return mid;
    if (target < arr[mid]) {
      j = mid - 1;
    } else {
      i = mid + 1;
    }
  }
  return -1;
};
```

递归版本：

```js
const binarySearch = (a, left, right, key) => {
  const mid = (left + right) >> 1;
  if (a[mid] === key) return mid;
  if (a[mid] > key) return binarySearch(a, left, mid - 1, key);
  if (a[mid] < key) return binarySearch(a, mid + 1, right, key);
};
```

## DP

### 斐波那契

```js
function fib(n) {
  if (n <= 1) return n;
  let i = 1,
    j = 1;
  for (let k = 3; k <= n; k++) {
    const sum = i + j;
    i = j;
    j = sum;
  }
  return j;
}
```

# 常见数据结构

### 链表节点

```js
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}
```
