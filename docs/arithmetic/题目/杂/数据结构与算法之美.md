---
layout: CustomPages
title: 算法笔记
date: 2020-11-15
aside: false
---

# 算法笔记

## 数据结构与算法之美 笔记

10 个数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树;
10 个算法:递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。

** 如何分析一段代码的时间复杂度? ** 1.只关注循环执行次数最多的一段代码 2.加法法则:总复杂度等于量级最大的那段代码的复杂度 我这里还有一段代码。 3.乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 数据结构知识点结构

- 线性表
  - 数组
  - 链表
    - 单链表
    - 双向链表
    - 循环链表
    - 双向循环链表
    - 静态链表
  - 栈
    - 顺序栈
    - 链式栈
  - 队列
    - 普通队列
    - 双端队列
    - 阻塞队列
    - 并发队列
    - 阻塞并发队列
- 散列表
  - 散列函数
  - 冲突解决
    - 链表法
    - 开放寻址
    - 其他
  - 动态扩容
  - 位图
- 树
  - 二叉树
    - 平衡二叉树
    - 二叉查找树
    - 平衡二叉树
      - AVL 树
      - 红黑树
    - 完全二叉树
    - 满二叉树
  - 多路查找树
    - B 树
    - B+ 树
    - 2-3 树
    - 2-3-4 树
  - 堆
    - 小顶堆
    - 大顶堆
    - 优先级队列
    - 斐波那契堆
    - 二顶堆
  - 其他
    - 树状数组
    - 线段树
- 图
  - 图的存储
    - 邻接矩阵
    - 邻接表
  - 拓扑排序
  - 最短路径
  - 关键路径
  - 最小生成树
  - 二分图
  - 最大流
- 复杂度分析
  - 空间复杂度
  - 时间复杂度
    - 最好
    - 最坏
    - 平均
    - 均摊
- 基本算法思想
  - 贪心算法
  - 分治算法
  - 动态规划
  - 回溯算法
  - 枚举算法
- 排序
  - O(n^2)
    - 冒泡
    - 插入
    - 选择
    - 希尔
  - O(nlogn)
    - 归并
    - 快排
    - 堆排序
  - O(n)
    - 计数排序
    - 基数排序
    - 桶排序
- 搜索
  - 深度优先
  - 广度优先
  - A\* 启发式搜索
- 查找
  - 线性表查找
  - 树结构查找
  - 散列表查找
- 字符串匹配
  - 朴素
  - KMP
  - Robin-Karp
  - Boyer-Moore
  - AC 自动机
  - Tire
  - 后缀数组
- 其他
  - 数论
  - 计算几何
  - 概率分析
  - 并查集
  - 拓扑网络
  - 矩阵运算
  - 线性规划

### 事半功倍的学习技巧

1. 边学边练，适度刷题。
   “边学边练”这一招非常有用。建议你每周花 1~2 个小时的时间，集中把这周的三节内容涉及的数据结构和算法，全都自己写出来，用代码实现一遍。这样一定会比单纯地看或者听的效果要好很多! 有面试需求的同学，可能会问了，那我还要不要去刷题呢?
   我个人的观点是可以“适度”刷题，但一定不要浪费太多时间在刷题上。我们学习的目的还是掌握，然后应用。除非你要面试 Google、Facebook 这样的公司，它们的算法题目非常非常难，必须大量刷题，才能在短期内提 升应试正确率。如果是应对国内公司的技术面试，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。
2. 多问、多思考、多互动
   学习最好的方法是，找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑。 但是，离开大学之后，既没有同学也没有老师，这个条件就比较难具备了。
   不过，这也就是咱们专栏学习的优势。专栏里有很多跟你一样的学习者。你可以多在留言区写下自己的疑问、思考和总结，也可以经常看看别人的留言，和他们进行互动。
   除此之外，如果你有疑问，你可以随时在留言区给我留言，我只要有空就会及时回复你。你不要担心问的问题太小白。因为我初学的时候，也常常会被一些小白问题困扰。不懂一点都不丢人，只要你勇敢提出来，我们
   一起解决了就可以了。
   我也会力争每节课都最大限度地给你讲透，帮你扫除知识盲点，而你要做的就是，避免一知半解，要想尽一切办法去搞懂我讲的所有内容。
3. 打怪升级学习法
   学习的过程中，我们碰到最大的问题就是，坚持不下来。 是的，很多基础课程学起来都非常枯燥。为此，我自己总结了一套“打怪升级学习法”。
   游戏你肯定玩过吧?为什么很多看起来非常简单又没有乐趣的游戏，你会玩得不亦乐乎呢?这是因为，当你努力打到一定级别之后，每天看着自己的经验值、战斗力在慢慢提高，那种每天都在一点一点成长的成就感就不由自主地产生了。
   所以，我们在枯燥的学习过程中，也可以给自己设立一个切实可行的目标，就像打怪升级一样。 比如，针对这个专栏，你就可以设立这样一个目标:每节课后的思考题都认真思考，并且回复到留言区。当你看到很多人给你点赞之后，你就会为了每次都能发一个漂亮的留言，而更加认真地学习。 当然，还有很多其他的目标，比如，每节课后都写一篇学习笔记或者学习心得;或者你还可以每节课都找一下我讲得不对、不合理的地方......诸如此类，你可以总结一个适合你的“打怪升级攻略”。
   如果你能这样学习一段时间，不仅能收获到知识，你还会有意想不到的成就感。因为，这其实帮你改掉了一点学习的坏习惯。这个习惯一旦改掉了，你的人生也会变得不一样。
4. 知识需要沉淀，不要想试图一下子掌握所有
   在学习的过程中，一定会碰到“拦路虎”。如果哪个知识点没有怎么学懂，不要着急，这是正常的。因为，想听一遍、看一遍就把所有知识掌握，这肯定是不可能的。学习知识的过程是反复迭代、不断沉淀的过程。 如果碰到“拦路虎”，你可以尽情地在留言区问我，也可以先沉淀一下，过几天再重新学一遍。所谓，书读百遍其义自见，我觉得是很有道理的! 我讲的这些学习方法，不仅仅针对咱们这一个课程的学习，其实完全适用任何知识的学习过程。你可以通过这个专栏的学习，实践一下这些方法。如果效果不错，再推广到之后的学习过程中。

### 几种常见时间复杂度实例分析

- 复杂度量级（按照数量级递增）
- 常数阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n\*n) ...
-
- 指数阶 O(2 的 n 次)
- 阶乘阶 O(n!)

对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个:O(2n)和 O(n!)。

#### O(logn)、O(nlogn)

不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。
因为对数之间是可以互相转换的，log3n 就等于 log32 _ log2n，所以 O(log3n) = O(C _ log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论:在采用 大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”， 统一表示为 O(logn)。

如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复 杂度就是 O(nlogn)了。而且，O(nlogn)也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

#### O(m+n)、O(m\*n)

m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一 个。所以时间复杂度就是 O(m+n) 或者 O(m\*n) 了。

### 空间复杂度分析

常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。

![image-20190819171103164](http://media.zhijianzhang.cn/image-20190819171103164.png)

### 最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度

为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念:最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。
顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组 都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。

### 平均时间复杂度

### 均摊时间复杂度

### 数组

数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所
以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

## 链表

三种最常见的链表结构，它们分别是:单链表、双向链表和循环链表。

**单链表**
单链表有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最 后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是:指针不是指向下一个结点，而 是指向一个空地址 NULL，表示这是链表上最后一个结点。

链表随机访问的性能没有数组好，需要 O(n)的时间复杂度。

**循环链表**
循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后 的结点了。而循环链表的尾结点指针是指向链表的头结点。
和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。

**双向链表**
双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内
存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。

### 边界情况处理

我经常用来检查链表代码是否正确的边界条件有这样几个:

1. 如果链表为空时，代码是否能正常工作?
1. 如果链表只包含一个结点时，代码是否能正常工作?
1. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作?

实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮!

5 个常见的链表操作。你只要把这几个操作都能写熟练，不熟就多写几遍，我保证你之后再也不会害怕写链表代码。

1. 单链表反转
1. 链表中环的检测
1. 两个有序的链表合并
1. 删除链表倒数第 n 个结点
1. 求链表的中间结点

## 栈

栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。

# 覃超直播笔记

刷题 leetcode
数据结构： 极客时间 王争

### 学习算法和数据结构

正确姿势：三位一体刷题发

#### 要点一

1. 快速过所有算法的知识点，串成知识体系
2. 反复过遍数： 遍数 > 每次时长 (跟学托福一样~)
3. 背诵、记忆、默写：算法模板

#### 要点三

五遍刷题法

#### 刷题第一遍

- 5-10 分钟思考，读题 + 思考
- 直接看解法
- 直接看解法
- 直接看解法
- 背诵、默写好的解法
- 多解法，比较解法优劣

#### 刷题第二遍

- 马上自己写， leetcode 提交
- 多种解法比较，体会 + 优化

#### 刷题第三遍

- 过了一天，再做重复题
- 不同解法的熟练程度 -> 专项练习

#### 刷题第四遍

- 过了一周，反复练习相同的题

#### 刷题第五遍

- 面试前一周恢复性训练
