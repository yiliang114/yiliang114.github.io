---
layout: CustomPages
title: 数组与链表，堆栈与队列
date: 2020-11-15
aside: false
draft: true
---

## 基本数据结构之数组与链表，队列与栈

### Array

计算机中的数组与数学中的数组概念类似，只是计算机中的数组的值可以是多种类型。
一般语言中的数组，指的都是连续线性表，由于数据保存在连续的内存块中、数组头保存了数组的地址，所以数据的定位是非常方便的。
根据数组地址+元素的偏移量算出指定元素的内存地址，直接移动指针到该处即可进行数据的读写。

但是由于数据存储的空间连续，所以对元素的增删就变得非常麻烦，比如要在第五位插入一个元素，那么第五位后面的所有元素都要向后挪一个数组空间的位置。
如果是删除元素，那么就需要将后面的元素依次向前挪一个位置。实际操作中我们还需要额外的临时空间来保存要移动的元素，然后依次移动各个元素，相当繁琐。

但 js 与传统数组不一样，js 中的数据结构就只有一种：哈希表。哈希表用来描述 Object，其他所有的数据结构，都是建立在哈希表上的伪结构。
js 中的数组，其实就是 key 为 index 的对象，其底层也就是哈希表。
所以 js 中的数组并不储存在一片连续的存储空间里，因此数组的操作也跟传统的数组操作不一样。

> ES6 中的 typed Array 和 ArrayBuffer 是存储连续内存的数组，与传统意义上的数组一样。

js 中封装好的操作数组元素的方法有：

- push：向数组末尾添加**任意**个元素，@return 修改后的新数组长度
- pop：从数组末尾移除最后**一个**元素，@return 被移除的元素
- shift：从数组头部移除最前**一个**元素，@return 被移除的元素
- unshift：向数组头部添加**任意**个元素，@return 修改后的新数组长度
- splice：前 2 个参数为操作起始点和删除个数，第 3 个参数开始是插入的元素，@return 被删除项组成的数组
- sort 和 reverse：数组排序和反转，其中排序方法接受一个排序函数，可以自定义排序规则。例如：

```js
array.sort(function(pre, next) {
  return pre - next; // 返回负数则pre在前，返回正数则pre在后
});
```

注: 以上这些操作都是对数组元素的操作，是直接改变原数组的方法；以下方法不改变原数组，只返回新数组：

- concat：连接两个或者多个数组。
- slice：从当前数组中截取得到一个新数组。

还有一些比较实用的方法：

- forEach：对数组的所有元素都执行传入函数，无返回值
- map: 对数组的所有元素都执行传入函数，@return 函数返回值组成的数组，也就是数组映射
- filter：对数组的所有元素都执行传入函数，@return 函数返回值为真的元素组成的数组，也就是数组过滤
- every：对数组的所有元素都执行传入函数，@return 当所有元素的返回值都为真时，返回真。数组全体的与操作
- some：对数组的所有元素都执行传入函数，@return 当任一元素的返回值为真是，返回真。数组全体的或操作。
  以上传入函数的参数均为 item、index、array，后两项为可选参数。例如平方映射函数：

```js
array.map(function(item, index, array) {
  return item * item;
});
```

- reduce：从头到尾依次迭代，将每次迭代的结果作为输入与当前元素执行传入函数。
- reduceRight：从尾到头依次迭代，刚好与 reduce 相反。
  例如一个数组求和：

```js
array.reduce(function(prev, next, index, array) {
  return prev + next;
});
```

### Chain 链表

因为传统数组的存储空间都是连续的，元素的增删操作非常麻烦，所以链表这种数据结构就被设计出来了。
链表元素的存储空间都是分散的，每个元素除了保存本身的值之外，还保存着其他元素的内存地址，根据地址就可以将整个链表串起来了。
根据这个特点，只要我们改写一个元素指向的内存地址指向一个新的链表元素，然后设置新的链表元素指向原来元素指向的地址，就插入了一个链表元素。
由于链表的所有元素的实际内存地址并不连续，所以也就不必像定义数组一样声明其存储空间了，换言之链表占用的是动态空间。

js 中数组本身就不是连续的，所以在 js 中直接使用数组即可，没必要使用链表结构。

为了加深理解，这里也给出一个在 js 中通过对象来模拟链表结构的写法，更多方法参考[chain.js](./chain.js)文件。

```js
function Chain(key, value) {
  this.next = null;
  this.key = key;
  this.value = value;
  this.length = 1;
}

// 插入元素
Chain.prototype.insertAfter = function(pos, key, value) {
  var currentObj = this;
  var addObj = {
    key: key,
    value: value,
  };
  while (currentObj.key !== pos) {
    currentObj = currentObj.next;
  }
  addObj.next = currentObj.next;
  currentObj.next = addObj;
  this.length++;
  return this;
};

// 删除元素
Chain.prototype.delele = function(key) {
  var last = null;
  var currentObj = this;
  while (currentObj.key !== key) {
    last = currentObj;
    currentObj = currentObj.next;
  }
  last.next = currentObj.next;
  this.length--;
  return this;
};

// 查找元素
Chain.prototype.find = function(key) {
  var currentObj = this;
  while (currentObj.key !== key) {
    currentObj = currentObj.next;
  }
  return currentObj.value;
};
```

以上所说的都是单向链表，根据上述原理双向链表也很容易实现，这里就不再赘述了。

### Stack

堆栈是一种特殊的线性表，其特性是后进先出，可以类比弹夹，先塞进的子弹在最后才出来。
js 中可以用数组来模拟栈结构的先进后出，使用到的方法有 push、pop。

如果我说堆栈可能是计算机程序中应用最多的数据结构，你会不会说我扯淡？平时我们写的代码里面，根本就没怎么用到堆栈这种数据结构呀。
但是，回忆一下单片机里面的汇编程序设计里面，是不是通篇都是堆栈这个词呢？
在函数调用、跳转、循环的时候，我们都要做现场保护，所有现场数据都要压入堆栈里面，跳转之后再将栈顶的现场数据恢复回来。
但是，高级语言里面，这种流程控制都已经封装到底层里面，上层编程者无需再关心具体实现，所以即使堆栈遍布程序每个角落我们依然没有任何感知。

虽然普通的现场保护不用我们手工控制，但是在写递归函数的时候我们可以照葫芦画瓢，在进入递归前使用堆栈来保存各种过程状态，出递归的时候读取堆栈的状态。

递归的堆栈可能使用场景不多，在前端处理 html 模板的时候倒是可以用堆栈来匹配成对的括号。遇到开括号则将其压入，遇到匹配的闭括号则压出相应的开括号，否则继续压入。

```js
function pairTest(str) {
  var open = {
    '<': '>',
    '{': '}',
    '(': ')',
  };
  var close = {
    '>': '<',
    '}': '{',
    ')': '(',
  };
  var stack = [];
  var result = [];
  for (var i = 0, len = str.length; i < len; i++) {
    if (open[str[i]]) {
      stack.push({ index: i, value: str[i] });
    }
    if (close[str[i]]) {
      if (close[str[i]] === stack[stack.length - 1].value) {
        var temp = stack.pop();
        result.push(str.slice(temp.index + 1, i));
      } else {
        throw new Error('匹配出错！');
      }
    }
  }
  return result;
}
```

#### 例题分析一

LeetCode 第 20 题：给定一个只包括 '('，')'，'{'，'}'，'\['，'\]' 的字符串，判断字符串是否有效。

有效字符串需满足：

1.  左括号必须用相同类型的右括号闭合。

2.  左括号必须以正确的顺序闭合。

**注意**：空字符串可被认为是有效字符串。

**示例 1**

输入: "()"

输出: true

**示例 2**

输入: "(\]"

输出: false

解题思路

利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。

![](http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRLSATKk3AMg-Ag7s3RA865.gif)

#### 例题分析二

LeetCode 第 739 题：根据每日气温列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

提示：气温列表 temperatures 长度的范围是 \[1, 30000\]。

**示例**：给定一个数组 T 代表了未来几天里每天的温度值，要求返回一个新的数组 D，D 中的每个元素表示需要经过多少天才能等来温度的升高。

给定 T：\[23, 25, 21, 19, 22, 26, 23\]

返回 D: \[ 1, 4, 2, 1, 1, 0, 0\]

解题思路

第一个温度值是 23 摄氏度，它要经过 1 天才能等到温度的升高，也就是在第二天的时候，温度升高到 24 摄氏度，所以对应的结果是 1。接下来，从 25 度到下一次温度的升高需要等待 4 天的时间，那时温度会变为 26 度。

**思路 1**：最直观的做法就是针对每个温度值向后进行依次搜索，找到比当前温度更高的值，这样的计算复杂度就是 O(n2)。

但是，在这样的搜索过程中，产生了很多重复的对比。例如，从 25 度开始往后面寻找一个比 25 度更高的温度的过程中，经历了 21 度、19 度和 22 度，而这是一个温度由低到高的过程，也就是说在这个过程中已经找到了 19 度以及 21 度的答案，它就是 22 度。

**思路 2**：可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。

![](http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRMSAYv0mAJhTnwV5DmQ777.gif)

1.  对第一个温度 23 度，堆栈为空，把它的下标压入堆栈；

2.  下一个温度 24 度，高于 23 度高，因此 23 度温度升高只需 1 天时间，把 23 度下标从堆栈里弹出，把 24 度下标压入；

3.  同样，从 24 度只需要 1 天时间升高到 25 度；

4.  21 度低于 25 度，直接把 21 度下标压入堆栈；

5.  19 度低于 21 度，压入堆栈；

6.  22 度高于 19 度，从 19 度升温只需 1 天，从 21 度升温需要 2 天；

7.  由于堆栈里保存的是下标，能很快计算天数；

8.  22 度低于 25 度，意味着尚未找到 25 度之后的升温，直接把 22 度下标压入堆栈顶端；

9.  后面的温度与此同理。

该方法只需要对数组进行一次遍历，每个元素最多被压入和弹出堆栈一次，算法复杂度是 O(n)。

利用堆栈，还可以解决如下常见问题：

- 求解算术表达式的结果(LeetCode 224、227、772、770)

- 求解直方图里最大的矩形区域(LeetCode 84)

### queue

队列也是一种特殊的线性表，其特性是先进先出，就跟日常中的排队一样，先排先得。
js 中可以用数组来模拟队列的先进先出，使用到的方法有 push、shift。也可以用 unshift+pop 的方法来模拟反向队列。

队列在计算机程序的应用也非常广，由于其先进先出的特点，一般用在任务控制方面，也就是任务队列。
JS 是单线程的，但是却能执行异步任务，这主要是因为 JS 中存在事件循环(Event Loop)和任务队列(Task Queue)。
简单一点来说明一下：

关于线程：运行我们写的 js 代码的线程就是主线程，除此之外还有 io 线程、定时器线程等各种工作线程。

主线程一直在运行，主程序会到任务队列中去取任务来执行；任务队列中的任务是由各个工作线程添加进去的。

举例：
主线程：起床、开煮蛋器煮蛋，再开烤箱烤面包，然后去刷牙
工作线程(煮蛋器)：煮蛋，煮好之后给出一个信号，尖叫三声让主人来吃
工作线程(烤箱)：烤面包，烤好之后给出一个信号，尖叫两声让主人来吃
吃蛋和吃面包就是两个任务，他们会被工作线程塞到任务队列里面去。

主线程同时只能做一件事情，没办法一遍刷牙一遍去吃蛋，所以要等刷完牙之后才能去吃蛋。
至于先吃蛋还是先吃面包，那就要看任务的先后了，也就是先进先出。

#### 栈和队列的区别?

栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。队列先进先出，栈先进后出。栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

#### 栈和堆的区别？

栈区(stack): 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
堆区(heap) : 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收。
堆(数据结构):堆可以被看成是一棵树，如：堆排序；
栈(数据结构):一种先进后出的数据结构。
