---
layout: CustomPages
title: 数组与链表，堆栈与队列
date: 2020-11-15
aside: false
draft: true
---

## 基本数据结构之数组与链表，队列与栈

### Array

计算机中的数组与数学中的数组概念类似，只是计算机中的数组的值可以是多种类型。
一般语言中的数组，指的都是连续线性表，由于数据保存在连续的内存块中、数组头保存了数组的地址，所以数据的定位是非常方便的。
根据数组地址+元素的偏移量算出指定元素的内存地址，直接移动指针到该处即可进行数据的读写。

但是由于数据存储的空间连续，所以对元素的增删就变得非常麻烦，比如要在第五位插入一个元素，那么第五位后面的所有元素都要向后挪一个数组空间的位置。
如果是删除元素，那么就需要将后面的元素依次向前挪一个位置。实际操作中我们还需要额外的临时空间来保存要移动的元素，然后依次移动各个元素，相当繁琐。

但 js 与传统数组不一样，js 中的数据结构就只有一种：哈希表。哈希表用来描述 Object，其他所有的数据结构，都是建立在哈希表上的伪结构。
js 中的数组，其实就是 key 为 index 的对象，其底层也就是哈希表。
所以 js 中的数组并不储存在一片连续的存储空间里，因此数组的操作也跟传统的数组操作不一样。

> ES6 中的 typed Array 和 ArrayBuffer 是存储连续内存的数组，与传统意义上的数组一样。

js 中封装好的操作数组元素的方法有：

- push：向数组末尾添加**任意**个元素，@return 修改后的新数组长度
- pop：从数组末尾移除最后**一个**元素，@return 被移除的元素
- shift：从数组头部移除最前**一个**元素，@return 被移除的元素
- unshift：向数组头部添加**任意**个元素，@return 修改后的新数组长度
- splice：前 2 个参数为操作起始点和删除个数，第 3 个参数开始是插入的元素，@return 被删除项组成的数组
- sort 和 reverse：数组排序和反转，其中排序方法接受一个排序函数，可以自定义排序规则。例如：

```js
array.sort(function(pre, next) {
  return pre - next; // 返回负数则pre在前，返回正数则pre在后
});
```

注: 以上这些操作都是对数组元素的操作，是直接改变原数组的方法；以下方法不改变原数组，只返回新数组：

- concat：连接两个或者多个数组。
- slice：从当前数组中截取得到一个新数组。

还有一些比较实用的方法：

- forEach：对数组的所有元素都执行传入函数，无返回值
- map: 对数组的所有元素都执行传入函数，@return 函数返回值组成的数组，也就是数组映射
- filter：对数组的所有元素都执行传入函数，@return 函数返回值为真的元素组成的数组，也就是数组过滤
- every：对数组的所有元素都执行传入函数，@return 当所有元素的返回值都为真时，返回真。数组全体的与操作
- some：对数组的所有元素都执行传入函数，@return 当任一元素的返回值为真是，返回真。数组全体的或操作。
  以上传入函数的参数均为 item、index、array，后两项为可选参数。例如平方映射函数：

```js
array.map(function(item, index, array) {
  return item * item;
});
```

- reduce：从头到尾依次迭代，将每次迭代的结果作为输入与当前元素执行传入函数。
- reduceRight：从尾到头依次迭代，刚好与 reduce 相反。
  例如一个数组求和：

```js
array.reduce(function(prev, next, index, array) {
  return prev + next;
});
```

### Chain 链表

因为传统数组的存储空间都是连续的，元素的增删操作非常麻烦，所以链表这种数据结构就被设计出来了。
链表元素的存储空间都是分散的，每个元素除了保存本身的值之外，还保存着其他元素的内存地址，根据地址就可以将整个链表串起来了。
根据这个特点，只要我们改写一个元素指向的内存地址指向一个新的链表元素，然后设置新的链表元素指向原来元素指向的地址，就插入了一个链表元素。
由于链表的所有元素的实际内存地址并不连续，所以也就不必像定义数组一样声明其存储空间了，换言之链表占用的是动态空间。

js 中数组本身就不是连续的，所以在 js 中直接使用数组即可，没必要使用链表结构。

为了加深理解，这里也给出一个在 js 中通过对象来模拟链表结构的写法，更多方法参考[chain.js](./chain.js)文件。

```js
function Chain(key, value) {
  this.next = null;
  this.key = key;
  this.value = value;
  this.length = 1;
}

// 插入元素
Chain.prototype.insertAfter = function(pos, key, value) {
  var currentObj = this;
  var addObj = {
    key: key,
    value: value,
  };
  while (currentObj.key !== pos) {
    currentObj = currentObj.next;
  }
  addObj.next = currentObj.next;
  currentObj.next = addObj;
  this.length++;
  return this;
};

// 删除元素
Chain.prototype.delele = function(key) {
  var last = null;
  var currentObj = this;
  while (currentObj.key !== key) {
    last = currentObj;
    currentObj = currentObj.next;
  }
  last.next = currentObj.next;
  this.length--;
  return this;
};

// 查找元素
Chain.prototype.find = function(key) {
  var currentObj = this;
  while (currentObj.key !== key) {
    currentObj = currentObj.next;
  }
  return currentObj.value;
};
```

以上所说的都是单向链表，根据上述原理双向链表也很容易实现，这里就不再赘述了。

### Stack

堆栈是一种特殊的线性表，其特性是后进先出，可以类比弹夹，先塞进的子弹在最后才出来。
js 中可以用数组来模拟栈结构的先进后出，使用到的方法有 push、pop。

如果我说堆栈可能是计算机程序中应用最多的数据结构，你会不会说我扯淡？平时我们写的代码里面，根本就没怎么用到堆栈这种数据结构呀。
但是，回忆一下单片机里面的汇编程序设计里面，是不是通篇都是堆栈这个词呢？
在函数调用、跳转、循环的时候，我们都要做现场保护，所有现场数据都要压入堆栈里面，跳转之后再将栈顶的现场数据恢复回来。
但是，高级语言里面，这种流程控制都已经封装到底层里面，上层编程者无需再关心具体实现，所以即使堆栈遍布程序每个角落我们依然没有任何感知。

虽然普通的现场保护不用我们手工控制，但是在写递归函数的时候我们可以照葫芦画瓢，在进入递归前使用堆栈来保存各种过程状态，出递归的时候读取堆栈的状态。

递归的堆栈可能使用场景不多，在前端处理 html 模板的时候倒是可以用堆栈来匹配成对的括号。遇到开括号则将其压入，遇到匹配的闭括号则压出相应的开括号，否则继续压入。

```js
function pairTest(str) {
  var open = {
    '<': '>',
    '{': '}',
    '(': ')',
  };
  var close = {
    '>': '<',
    '}': '{',
    ')': '(',
  };
  var stack = [];
  var result = [];
  for (var i = 0, len = str.length; i < len; i++) {
    if (open[str[i]]) {
      stack.push({ index: i, value: str[i] });
    }
    if (close[str[i]]) {
      if (close[str[i]] === stack[stack.length - 1].value) {
        var temp = stack.pop();
        result.push(str.slice(temp.index + 1, i));
      } else {
        throw new Error('匹配出错！');
      }
    }
  }
  return result;
}
```

### queue

队列也是一种特殊的线性表，其特性是先进先出，就跟日常中的排队一样，先排先得。
js 中可以用数组来模拟队列的先进先出，使用到的方法有 push、shift。也可以用 unshift+pop 的方法来模拟反向队列。

队列在计算机程序的应用也非常广，由于其先进先出的特点，一般用在任务控制方面，也就是任务队列。
JS 是单线程的，但是却能执行异步任务，这主要是因为 JS 中存在事件循环（Event Loop）和任务队列（Task Queue）。
简单一点来说明一下：

关于线程：运行我们写的 js 代码的线程就是主线程，除此之外还有 io 线程、定时器线程等各种工作线程。

主线程一直在运行，主程序会到任务队列中去取任务来执行；任务队列中的任务是由各个工作线程添加进去的。

举例：
主线程：起床、开煮蛋器煮蛋，再开烤箱烤面包，然后去刷牙
工作线程（煮蛋器）：煮蛋，煮好之后给出一个信号，尖叫三声让主人来吃
工作线程（烤箱）：烤面包，烤好之后给出一个信号，尖叫两声让主人来吃
吃蛋和吃面包就是两个任务，他们会被工作线程塞到任务队列里面去。

主线程同时只能做一件事情，没办法一遍刷牙一遍去吃蛋，所以要等刷完牙之后才能去吃蛋。
至于先吃蛋还是先吃面包，那就要看任务的先后了，也就是先进先出。

#### 栈和队列的区别?

栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。队列先进先出，栈先进后出。栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

#### 栈和堆的区别？

栈区（stack）: 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
堆区（heap） : 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收。
堆（数据结构）:堆可以被看成是一棵树，如：堆排序；
栈（数据结构）:一种先进后出的数据结构。
