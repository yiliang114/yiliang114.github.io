---
layout: CustomPages
title: 栈
date: 2020-11-22
aside: false
draft: true
---

## 栈

### 例题分析一

#### 例题分析一

LeetCode 第 20 题：给定一个只包括 '('，')'，'{'，'}'，'\['，'\]' 的字符串，判断字符串是否有效。

有效字符串需满足：

1.  左括号必须用相同类型的右括号闭合。

2.  左括号必须以正确的顺序闭合。

**注意**：空字符串可被认为是有效字符串。

**示例 1**

输入: "()"

输出: true

**示例 2**

输入: "(\]"

输出: false

解题思路

利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。

![](http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRLSATKk3AMg-Ag7s3RA865.gif)

#### 例题分析二

LeetCode 第 739 题：根据每日气温列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

提示：气温列表 temperatures 长度的范围是 \[1, 30000\]。

**示例**：给定一个数组 T 代表了未来几天里每天的温度值，要求返回一个新的数组 D，D 中的每个元素表示需要经过多少天才能等来温度的升高。

给定 T：\[23, 25, 21, 19, 22, 26, 23\]

返回 D: \[ 1, 4, 2, 1, 1, 0, 0\]

解题思路

第一个温度值是 23 摄氏度，它要经过 1 天才能等到温度的升高，也就是在第二天的时候，温度升高到 24 摄氏度，所以对应的结果是 1。接下来，从 25 度到下一次温度的升高需要等待 4 天的时间，那时温度会变为 26 度。

**思路 1**：最直观的做法就是针对每个温度值向后进行依次搜索，找到比当前温度更高的值，这样的计算复杂度就是 O(n2)。

但是，在这样的搜索过程中，产生了很多重复的对比。例如，从 25 度开始往后面寻找一个比 25 度更高的温度的过程中，经历了 21 度、19 度和 22 度，而这是一个温度由低到高的过程，也就是说在这个过程中已经找到了 19 度以及 21 度的答案，它就是 22 度。

**思路 2**：可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。

![](http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRMSAYv0mAJhTnwV5DmQ777.gif)

1.  对第一个温度 23 度，堆栈为空，把它的下标压入堆栈；

2.  下一个温度 24 度，高于 23 度高，因此 23 度温度升高只需 1 天时间，把 23 度下标从堆栈里弹出，把 24 度下标压入；

3.  同样，从 24 度只需要 1 天时间升高到 25 度；

4.  21 度低于 25 度，直接把 21 度下标压入堆栈；

5.  19 度低于 21 度，压入堆栈；

6.  22 度高于 19 度，从 19 度升温只需 1 天，从 21 度升温需要 2 天；

7.  由于堆栈里保存的是下标，能很快计算天数；

8.  22 度低于 25 度，意味着尚未找到 25 度之后的升温，直接把 22 度下标压入堆栈顶端；

9.  后面的温度与此同理。

该方法只需要对数组进行一次遍历，每个元素最多被压入和弹出堆栈一次，算法复杂度是 O(n)。

利用堆栈，还可以解决如下常见问题：

- 求解算术表达式的结果（LeetCode 224、227、772、770)

- 求解直方图里最大的矩形区域（LeetCode 84）
