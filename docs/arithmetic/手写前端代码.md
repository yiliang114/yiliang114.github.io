---
title: 手写前端代码
date: 2020-12-16
draft: true
---

# 手写前端代码

## 数组去重（对象、非对象）

1. set 去重

```js
[...new Set(arr)];
```

2. 利用 indexOf 去重

```js
const newArr = arr.filter((item, index, arr) => index === arr.indexOf(item));
```

```js
let newArrB = [];
arr.forEach(item => (newArrB.indexOf(item) === -1 ? newArrB.push(item) : ''));
```

3. 利用对象去重

```js
let objA = {};
const newArrA = arr.filter((item, index, arr) => (objA.hasOwnProperty(item) ? false : (objA[item] = true)));
```

4. 双重循环去重

```js
function removeDuplicatedItem(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1); //console.log(arr[j]);
        j--;
      }
    }
  }
  return arr;
}
```

5. 利用 sort()加前后比较去重

```js
const newArrC = arr.sort().filter((item, index, arr) => item !== arr[index + 1]);
```

## 大数相加

## url 解析

### 正则法

```js
function getQueryString(name) {
  var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
  var r = window.location.search.substr(1).match(reg);
  if (r != null) {
    return unescape(r[2]);
  }
  return null;
}
```

### split 拆分法

```js
function GetRequest() {
  var url = location.search; //获取url中"?"符后的字串
  var theRequest = new Object();
  if (url.indexOf('?') != -1) {
    var str = url.substr(1);
    strs = str.split('&');
    for (var i = 0; i < strs.length; i++) {
      theRequest[strs[i].split('=')[0]] = unescape(strs[i].split('=')[1]);
    }
  }
  return theRequest;
}
```

### 又见正则

```js
function GetQueryString(name) {
  var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
  var r = window.location.search.substr(1).match(reg); //获取url中"?"符后的字符串并正则匹配
  var context = '';
  if (r != null) context = r[2];
  reg = null;
  r = null;
  return context == null || context == '' || context == 'undefined' ? '' : context;
}
alert(GetQueryString('q'));
```

### 单个参数的获取方法

```js
function GetRequest() {
  var url = location.search; //获取url中"?"符后的字串
  if (url.indexOf('?') != -1) {
    //判断是否有参数
    var str = url.substr(1); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串
    strs = str.split('='); //用等号进行分隔 （因为知道只有一个参数 所以直接用等号进分隔 如果有多个参数 要用&号分隔 再用等号进行分隔）
    alert(strs[1]); //直接弹出第一个参数 （如果有多个参数 还要进行循环的）
  }
}
```

## 深拷贝

```js
function assignDeep(target, ...sources) {
  for (let source of sources) {
    for (let key in source) {
      if (isObject(source[key])) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        assignDeep(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}

function isObject(a) {
  return typeof a === 'object' && a !== null;
}
```

## 防抖、节流

有立即执行和非立即执行版。lodash 的话， debounce 第三个参数给一个对象，{ leading: true }, 表示立即执行版本。

### debounce

```js
// 非最好
function debounce(fn, delay = 0) {
  // keep track of the last call to the debounced function
  let last = {
    time: null,
    timerId: null,
  };

  // return a debounced version of fn
  return () => {
    let time = Date.now();

    // if the debounced function was called again before the delay elapsed,
    // cancel the timer (started in the previous call) that would have called
    // fn, and start a new timer.
    if (last.time && time - last.time < delay) {
      clearTimeout(last.timerId);
    }

    // start a timer to call fn after the given delay
    last = {
      time,
      timerId: setTimeout(fn, delay),
    };
  };
}
```

### throttle and debounce

```js
// 节流throttle，多次触发但只执行一部分，(恒时间间距执行)
function throttle(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    if (!timer) {
      timer = setTimeout(function() {
        timer = null;
        method.apply(ctx, args);
      }, threshold);
    }
  };
}

// 防抖debounce, 多次触发但只执行一次，(时间差大于阈值才执行)
function debounce(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    timer && clearTimeout(timer);
    timer = setTimeout(function() {
      method.apply(ctx, args);
    }, threshold);
  };
}

// 轮循函数
// usage: wait(fn.bind(ctx, ...args), 10000);
function wait(fn, timeout, tick) {
  timeout = timeout || 5000;
  tick = tick || 250;
  var timeoutTimer = null;
  var execTimer = null;

  return new Promise(function(resolve, reject) {
    timeoutTimer = setTimeout(function() {
      clearTimeout(execTimer);
      reject(new Error('polling fail because timeout'));
    }, timeout);

    tickHandler(fn);

    function tickHandler(fn) {
      var ret = fn();
      if (!ret) {
        execTimer = setTimeout(function() {
          tickHandler(fn);
        }, tick);
      } else {
        clearTimeout(timeoutTimer);
        resolve();
      }
    }
  });
}

var n = 1;
wait(
  function() {
    console.log(n++);
    return n > 10;
  },
  2000,
  300,
)
  .then(function() {
    console.log('===== end ====');
  })
  .catch(function(err) {
    console.error('error', err);
  });
```

## Event Class

```js
const Noop = () => {};

class EventEmitter {
  constructor() {
    this.events = [];
  }

  on(event, handler = Noop) {
    if (typeof this.events[event] === 'undefined') {
      this.events[event] = [handler];
    } else {
      this.events[event].push(handler);
    }
  }

  once(event, handler = Noop) {
    const once = `once_${event}`;
    if (typeof this.events[once] === 'undefined') {
      this.events[once] = [handler];
    } else {
      this.events[once].push(handler);
    }
  }

  emit(event, args) {
    const once = `once_${event}`;
    if (typeof this.events[once] !== 'undefined') {
      this.events[once].forEach(handler => {
        handler(args);
      });
      delete this.events[`once_${event}`];
    }
    if (typeof this.events[event] !== 'undefined') {
      this.events[event].forEach(handler => {
        handler(args);
      });
    }
  }

  off(event, handler) {
    if (typeof this.events[event] !== 'undefined') {
      if (!!handler) {
        const index = this.events[event].indexOf(handler);
        this.events[event].splice(index, 1);
      } else {
        delete this.events[event];
      }
    }
  }
}

function test() {
  const eh = new EventEmitter();

  const firstHd = str => {
    console.log('first greet: ', str);
  };

  eh.on('greet', firstHd);

  eh.on('greet', str => {
    console.log('second greet: ', str);
  });

  eh.on('bye', name => {
    console.log(name + ', goodbye!');
  });

  eh.once('break', str => {
    console.log(`once break: ${str}`);
  });
  eh.on('break', str => {
    console.log(`on break: ${str}`);
  });

  console.log('======  start  ======');
  eh.emit('greet', 'Green');
  eh.emit('bye', 'Mark');
  eh.emit('break', 'Jack');
  eh.emit('break', 'Tony');

  console.log('======  removeListener  ======');
  eh.off('bye');
  eh.emit('bye', 'Mark');

  eh.off('greet', firstHd);
  eh.emit('greet', 'Green');
}

test();
```

## 实现一个 Event 类

继承自此类的对象都会拥有两个方法 on,off,once 和 trigger

```js
function Event() {
  if (!(this instanceof Event)) {
    return new Event();
  }
  this._callbacks = {};
}
Event.prototype.on = function(type, handler) {
  this_callbacks = this._callbacks || {};
  this._callbacks[type] = this.callbacks[type] || [];
  this._callbacks[type].push(handler);

  return this;
};

Event.prototype.off = function(type, handler) {
  var list = this._callbacks[type];

  if (list) {
    for (var i = list.length; i >= 0; --i) {
      if (list[i] === handler) {
        list.splice(i, 1);
      }
    }
  }

  return this;
};

Event.prototype.trigger = function(type, data) {
  var list = this._callbacks[type];

  if (list) {
    for (var i = 0, len = list.length; i < len; ++i) {
      list[i].call(this, data);
    }
  }
};

Event.prototype.once = function(type, handler) {
  var self = this;

  function wrapper() {
    handler.apply(self, arguments);
    self.off(type, wrapper);
  }
  this.on(type, wrapper);
  return this;
};
```

## 实现 vue 中的 on,emit,off,once，手写代码

```js
// 参照 vue 源码实现
var EventEmitter = function() {
  this._events = {};
};
EventEmitter.prototype.on = function(event, cb) {
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.on(event[i], cb);
    }
  } else {
    (this._events[event] || (this._events[event] = [])).push(cb);
  }
  return this;
};
EventEmitter.prototype.once = function(event, cb) {
  function on() {
    this.off(event, cb);
    cb.apply(this, arguments);
  }
  on.fn = cb;
  this.on(event, on);
  return this;
};
EventEmitter.prototype.off = function(event, cb) {
  if (!arguments.length) {
    this._events = Object.create(null);
    return this;
  }
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.off(event[i], cb);
    }
    return this;
  }
  if (!cb) {
    this._events[event] = null;
    return this;
  }
  if (cb) {
    let cbs = this._events[event];
    let i = cbs.length;
    while (i--) {
      if (cb === cbs[i] || cb === cbs[i].fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return this;
  }
};
EventEmitter.prototype.emit = function(event) {
  let cbs = this._events[event];
  let args = Array.prototype.slice.call(arguments, 1);
  if (cbs) {
    for (let i = 0, l = cbs.length; i < l; i++) {
      cbs[i].apply(this, args);
    }
  }
};
```

## 基于 ES5/ES6 实现“双向绑定”

要想实现，就要先看看什么是“双向数据绑定”，它和“单向数据绑定”有什么区别？这样才能知道要实现什么效果嘛。

**双向绑定**：视图（View）的变化能实时让数据模型（Model）发生变化，而数据的变化也能实时更新到视图层。

**单向数据绑定**：只有从数据到视图这一方向的关系。

### ES5 的 Object.defineProperty

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script>
      const obj = {
        value: '',
      };

      function onKeyUp(event) {
        obj.value = event.target.value;
      }

      // 对 obj.value 进行拦截
      Object.defineProperty(obj, 'value', {
        get: function() {
          return value;
        },
        set: function(newValue) {
          value = newValue;
          document.querySelector('#value').innerHTML = newValue; // 更新视图层
          document.querySelector('input').value = newValue; // 数据模型改变
        },
      });
    </script>
  </head>
  <body>
    <p>值是：<span id="value"></span></p>
    <input type="text" onkeyup="onKeyUp(event)" />
  </body>
</html>
```

### ES6 的 Proxy

随着，vue3.0 放弃支持了 IE 浏览器。而且`Proxy`兼容性越来越好，能支持 13 种劫持操作。

因此，vue3.0 选择使用`Proxy`来实现双向数据绑定，而不再使用`Object.defineProperty`。

```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script>
    const obj = {}

    const newObj = new Proxy(obj, {
      get: function(target, key, receiver) {
        return Reflect.get(target, key, receiver)
      },
      set: function(target, key, value, receiver) {
        if(key === 'value') {
          document.querySelector('#value').innerHTML = value
          document.querySelector('input').value = value
        }
        return Reflect.set(target, key, value, receiver)
      }
    })

    function onKeyUp(event) {
      newObj.value = event.target.value
    }

  </script>
</head>
<body>
  <p>
    值是：<span id="value"></span>
  </p>
  <input type="text" onkeyup="onKeyUp(event)">
</body>
</html>
```

## instanceof 原理与实现

`instanceof`是通过原型链来进行判断的，所以只要不断地通过访问`__proto__`，就可以拿到构造函数的原型`prototype`。直到`null`停止。

```js
/**
 * 判断left是不是right类型的对象
 * @param {*} left
 * @param {*} right
 * @return {Boolean}
 */
function instanceof2(left, right) {
  let prototype = right.prototype;

  // 沿着left的原型链, 看看是否有何prototype相等的节点
  left = left.__proto__;
  while (1) {
    if (left === null || left === undefined) {
      return false;
    }
    if (left === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}

/**
 * 测试代码
 */

console.log(instanceof2([], Array)); // output: true

function Test() {}
let test = new Test();
console.log(instanceof2(test, Test)); // output: true
```

## 实现支持绑定、解绑和派发的事件类

**实现思路**：这里涉及了“订阅/发布模式”的相关知识。参考`addEventListener(type, func)`和`removeEventListener(type, func)`的具体效果来实现即可。

```js
// 数组置空：
// arr = []; arr.length = 0; arr.splice(0, arr.length)
class Event {
  constructor() {
    this._cache = {};
  }

  // 注册事件：如果不存在此种type，创建相关数组
  on(type, callback) {
    this._cache[type] = this._cache[type] || [];
    let fns = this._cache[type];
    if (fns.indexOf(callback) === -1) {
      fns.push(callback);
    }
    return this;
  }

  // 触发事件：对于一个type中的所有事件函数，均进行触发
  trigger(type, ...data) {
    let fns = this._cache[type];
    if (Array.isArray(fns)) {
      fns.forEach(fn => {
        fn(...data);
      });
    }
    return this;
  }

  // 删除事件：删除事件类型对应的array
  off(type, callback) {
    let fns = this._cache[type];
    // 检查是否存在type的事件绑定
    if (Array.isArray(fns)) {
      if (callback) {
        // 卸载指定的回调函数
        let index = fns.indexOf(callback);
        if (index !== -1) {
          fns.splice(index, 1);
        }
      } else {
        // 全部清空
        fns = [];
      }
    }
    return this;
  }
}

// 以下是测试函数

const event = new Event();
event
  .on('test', a => {
    console.log(a);
  })
  .trigger('test', 'hello');
```

## 合集

**手写事件侦听器，并要求兼容浏览器**

```js
var eventUtil = {
  getEvent: function(event) {
    return event || window.event;
  },

  getTarget: function(event) {
    return event.target || event.srcElement;
  },

  addListener: function(element, type, hander) {
    if (element.addEventListener) {
      element.addEventListener(type, hander, false);
    } else if (element.attachEvent) {
      element.attachEvent('on' + type, hander);
    } else {
      element['on' + type] = hander;
    }
  },

  removeListener: function(element, type, hander) {
    if (element.removeEventListener) {
      element.removeEventListener(type, hander, false);
    } else if (element.deattachEvent) {
      element.detachEvent(type, hander);
    } else {
      element['on' + type] = null;
    }
  },

  preventDefault: function(event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  },

  stopPropagation: function(event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  },
};

// 调用
(function() {
  var btn = document.getElementById('btn');
  var link = document.getElementsByTagName('a')[0];

  eventUtil.addListener(btn, 'click', function(event) {
    var event = eventUtil.getEvent(event);
    var target = eventUtil.getTarget(event);
    alert(event.type);
    alert(target);
    eventUtil.stopPropagation(event);
  });

  eventUtil.addListener(link, 'click', function(event) {
    alert('prevent default event');
    var event = eventUtil.getEvent(event);
    eventUtil.preventDefault(event);
  });

  eventUtil.addListener(document.body, 'click', function() {
    alert('click body');
  });
})();
```

**手写事件模型**

```js
var Event = (function() {
  var list = {},
    bind,
    trigger,
    remove;
  bind = function(key, fn) {
    if (!list[key]) {
      list[key] = [];
    }
    list[key].push(fn);
  };
  trigger = function() {
    var key = Array.prototype.shift.call(arguments);
    var fns = list[key];
    if (!fns || fns.length === 0) {
      return false;
    }
    for (var i = 0, fn; (fn = fns[i++]); ) {
      fn.apply(this, arguments);
    }
  };
  remove = function(key, fn) {
    var fns = list[key];
    if (!fns) {
      return false;
    }
    if (!fn) {
      fns & (fns.length = 0);
    } else {
      for (var i = fns.length - 1; i >= 0; i--) {
        var _fn = fns[i];
        if (_fn === fn) {
          fns.splice(i, 1);
        }
      }
    }
  };
  return {
    bind: bind,
    trigger: trigger,
    remove: remove,
  };
})();

// 调用
Event.bind('Hit', function() {
  console.log('bind event');
}); // 绑定事件
Event.trigger('Hit', function() {
  console.log('trigger event');
}); // 触发事件
```

**手写事件代理，并要求兼容浏览器**

```js
function delegateEvent(parentEl, selector, type, fn) {
  var handler = function(e) {
    var e = e || window.event;
    var target = e.target || e.srcElement;
    if (matchSelector(target, selector)) {
      if (fn) {
        fn.call(target, e);
      }
    }
  };
  if (parentEl.addEventListener) {
    parentEl.addEventListener(type, handler);
  } else {
    parentEl.attachEvent('on' + type, handler);
  }
}
/**
 * support #id, tagName, .className
 */
function matchSelector(ele, selector) {
  // if use id
  if (selector.charAt(0) === '#') {
    return ele.id === selector.slice(1);
  }
  // if use class
  if (selector.charAt(0) === '.') {
    return (' ' + ele.className + ' ').indexOf(' ' + selector.slice(1) + ' ') != -1;
  }
  // if use tagName
  return ele.tagName.toLowerCase() === selector.toLowerCase();
}

// 调用
var box = document.getElementById('box');
delegateEvent(box, 'a', 'click', function() {
  console.log(this.href);
});
```

**手写事件触发器，并要求兼容浏览器**

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return element.dispatchEvent(mockEvent);
  }
};
```

**用 JS 实现千位分隔符**

```js
function test1(num) {
  var str = +num + '';
  var len = str.length;
  if (len <= 3) return str;
  num = '';
  while (len > 3) {
    len -= 3;
    num = ',' + str.substr(len, 3) + num;
  }
  return str.substr(0, len) + num;
}

function test2(num) {
  // ?= 正向匹配:匹配位置
  // ?! 正向不匹配:排除位置
  var str = (+num).toString();
  var reg = /(?=(?!\b)(\d{3})+$)/g;
  return str.replace(reg, ',');
}
```
