---
layout: CustomPages
title: 前端与数据结构-剑指 offer 50-59
date: 2020-11-14
aside: false
draft: true
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [50. 第一个只出现一次的字符位置](#50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
- [51. 数组中的逆序对](#51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1)
- [52. 两个链表的第一个公共结点](#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2)
- [53. 数字在排序数组中出现的次数](#53-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3)
- [54. 二叉查找树的第 K 个结点](#54-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4)
- [55.1 二叉树的深度](#551-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5)
- [55.2 平衡二叉树](#552-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6)
- [56. 数组中只出现一次的数字](#56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7)
- [57.1 和为 S 的两个数字](#571-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8)
- [57.2 和为 S 的连续正数序列](#572-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9)
- [58.1 翻转单词顺序列](#581-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10)
- [58.2 左旋转字符串](#582-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11)
- [59. 滑动窗口的最大值](#59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 50. 第一个只出现一次的字符位置

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。

```
Input: abacc
Output: b
```

### 解题思路

最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```

以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。

```js
function FirstNotRepeatingChar(str) {
  if (str.length < 1 || str.length > 10000) return -1;
  const map = {};
  for (let i = 0; i < str.length; i++) {
    if (!map[str[i]]) {
      map[str[i]] = 1;
    } else {
      map[str[i]]++;
    }
  }
  for (let i = 0; i < str.length; i++) {
    if (map[str[i]] === 1) {
      return i;
    }
  }
  return -1;
}
```

### 思路

从头到尾遍历一遍，统计每个字符的出现次数，保存到哈希表中。

再重新遍历一遍，每次都检查哈希表中的次数是不是 1，是 1，直接返回，这就是第一个字符。

### 代码实现

```js
/**
 *
 * @param {String} str
 */
function findFirstNoRepeatChar(str) {
  const chars = str.split('');
  const map = {};
  for (let char of chars) {
    if (char in map) {
      map[char] += 1;
    } else {
      map[char] = 1;
    }
  }

  for (let char of chars) {
    if (map[char] === 1) {
      return char;
    }
  }
}

/**
 * 测试代码
 */

console.log(findFirstNoRepeatChar('abaccdeff')); // output: 'b'
```

## 51. 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

### 解题思路

```js
function InversePairs(data) {
  if (!data || data.length < 2) return 0;
  const copy = data.slice();
  let count = 0;
  count = mergeCount(data, copy, 0, data.length - 1);
  return count % 1000000007;
}
function mergeCount(data, copy, start, end) {
  if (start === end) return 0;
  const mid = (end - start) >> 1,
    left = mergeCount(copy, data, start, start + mid), // 注意参数，copy作为data传入
    right = mergeCount(copy, data, start + mid + 1, end); // 注意参数，copy作为data传入
  let [p, q, count, copyIndex] = [start + mid, end, 0, end];
  while (p >= start && q >= start + mid + 1) {
    if (data[p] > data[q]) {
      copy[copyIndex--] = data[p--];
      count = count + q - start - mid;
    } else {
      copy[copyIndex--] = data[q--];
    }
  }
  while (p >= start) {
    copy[copyIndex--] = data[p--];
  }
  while (q >= start + mid + 1) {
    copy[copyIndex--] = data[q--];
  }
  return count + left + right;
}
```

### 思路分析

暴力法的时间复杂度是 O(N^2)。利用归并排序的思路，可以将时间复杂度降低到 O(NlogN)。

比如对于 7、5、6、4 来说，会被分成 5、7 和 4、6 两组。

准备两个指针指向两组最后元素，当左边数组指针的对应元素小于右边指针对应元素，结果可以加上从左指针到右指针之间的元素个数（都是逆序的）。

依次移动指针，直到达到边界。

### 代码实现

代码最后输出了数组，经过归并，数组已经是有序的了。

```js
/**
 *
 * @param {Array} arr
 * @param {Number} start
 * @param {Number} end
 * @return {Number}
 */
function findInversePairNum(arr, start, end) {
  if (start === end) {
    return 0;
  }

  const copy = new Array(end - start + 1);
  const length = (end - start) >> 1;
  const leftNum = findInversePairNum(arr, start, start + length);
  const rightNum = findInversePairNum(arr, start + length + 1, end);

  let i = start + length, // 左子数组的最后一个下标
    j = end, // 右子数组的最后一个下标
    count = leftNum + rightNum,
    copyIndex = end - start; // copy数组中的最后一个下标

  // 可以参考数据集合：[2, 3, 1, 4]
  for (; i >= start && j >= start + length + 1; ) {
    if (arr[i] > arr[j]) {
      copy[copyIndex--] = arr[i--];
      count += j - start - length;
    } else {
      copy[copyIndex--] = arr[j--];
    }
  }

  for (; i >= start; --i) {
    copy[copyIndex--] = arr[i];
  }

  for (; j >= start + length + 1; --j) {
    copy[copyIndex--] = arr[j];
  }

  // 将排序号的数据放到原数组中
  for (i = 0; i < end - start + 1; ++i) {
    arr[i + start] = copy[i];
  }

  // clear
  copy.length = 0;

  return count;
}

/**
 * 测试代码
 */

const arr = [7, 5, 6, 4];
console.log(findInversePairNum(arr, 0, arr.length - 1)); // output: 5
console.log(arr); // output: [4, 5, 6, 7]
```

## 52. 两个链表的第一个公共结点

### 解题思路

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```js
function FindFirstCommonNode(pHead1, pHead2) {
  const len1 = getLinkLength(pHead1),
    len2 = getLinkLength(pHead2);
  let pLong = pHead1,
    pShort = pHead2,
    lenGap = len1 - len2;
  if (len1 < len2) {
    pLong = pHead2;
    pShort = pHead1;
    lenGap = len2 - len1;
  }
  while (lenGap--) {
    pLong = pLong.next;
  }
  while (pLong !== null) {
    // pLong,pShort一起跑
    if (pLong.val === pShort.val) {
      return pLong;
    }
    pLong = pLong.next;
    pShort = pShort.next;
  }
  return null;
}
function getLinkLength(pHead) {
  let length = 0;
  while (pHead !== null) {
    pHead = pHead.next;
    length++;
  }
  return length;
}
```

### 思路分析

#### 2.1 思路一：栈实现

在第一个公共节点前的节点都是不相同的，因此只要倒序遍历两个链表，找出最后一个出现的相同节点即可。

因为链表不能倒序遍历，所以借助栈实现。

#### 2.2 思路二：快慢指针

假设链表 A 长度大于链表 B 长度，它们的长度差为 diff。

让 A 的指针先移动 diff 的位移，然后 A 和 B 的指针再同时向后移动，每次比较节点，选出第一个出现的相同节点。

### 代码实现

为了方便，先简单实现节点数据结构：

```js
class Node {
  constructor(value, next) {
    this.value = value;
    this.next = next;
  }
}
```

#### 3.1 思路一：栈实现

```js
/**
 * 思路一：利用栈实现
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method1(list1, list2) {
  const stack1 = [],
    stack2 = [];

  let node = list1;
  while (node) {
    stack1.push(node);
    node = node.next;
  }

  node = list2;
  while (node) {
    stack2.push(node);
    node = node.next;
  }

  node = null;
  while (stack1.length && stack2.length) {
    let top1 = stack1.pop(),
      top2 = stack2.pop();
    if (top1 === top2) {
      node = top1;
    } else {
      break;
    }
  }

  return node;
}
```

#### 3.2 思路二：快慢指针

```js
/**
 * 思路二：快慢指针
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method2(list1, list2) {
  let length1 = 0,
    length2 = 0;

  let node = list1;
  while (node) {
    ++length1;
    node = node.next;
  }

  node = list2;
  while (node) {
    ++length2;
    node = node.next;
  }

  let diff = Math.abs(length1 - length2),
    longList = null,
    shortList = null;
  if (length1 > length2) {
    longList = list1;
    shortList = list2;
  } else {
    longList = list2;
    shortList = list1;
  }

  while (diff > 0) {
    longList = longList.next;
    --diff;
  }

  while (longList && shortList) {
    if (longList === shortList) {
      return longList;
    }
    longList = longList.next;
    shortList = shortList.next;
  }

  return null;
}
```

#### 3.3 测试代码

```js
const node4th = new Node(4);
const node3th = new Node(3, node4th);
const list1 = new Node(1, new Node(2, new Node(3, node3th)));
const list2 = new Node(5, new Node(6, node3th));

console.log(method2(list1, list2));
```

## 53. 数字在排序数组中出现的次数

- 查找

```html
Input: nums = 1, 2, 3, 3, 3, 3, 4, 6 K = 3 Output: 4
```

### 解题思路

```js
function GetNumberOfK(data, k) {
  if (getEnd(data, k) === -1 && getBegin(data, k) === -1) return 0;
  return getEnd(data, k) - getBegin(data, k) + 1;
}
function getBegin(data, k) {
  let [left, right] = [0, data.length - 1];
  let mid = (left + right) >> 1;
  while (left <= right) {
    if (data[mid] > k) {
      right = mid - 1;
    } else if (data[mid] < k) {
      left = mid + 1;
    } else if (mid - 1 >= 0 && data[mid - 1] === k) {
      right = mid - 1;
    } else return mid;
    mid = (left + right) >> 1;
  }
  return -1;
}
function getEnd(data, k) {
  let [left, right] = [0, data.length - 1];
  let mid = (left + right) >> 1;
  while (left <= right) {
    if (data[mid] > k) {
      right = mid - 1;
    } else if (data[mid] < k) {
      left = mid + 1;
    } else if (mid + 1 < data.length && data[mid + 1] === k) {
      left = mid + 1;
    } else return mid;
    mid = (left + right) >> 1;
  }
  return -1;
}
```

### 1. 题目

统计一个数字在排序数组中出现的次数。

### 思路解析

题目说是排序数组，所以可以使用“二分查找”的思想。

一种思路是查找到指定数字，然后向前向后遍历，复杂度是 O(N)。

另一种是不需要遍历所有的数字，只需要找到数字在数组中的左右边界即可，做差即可得到出现次数。

### 代码实现

```js
/**
 * 寻找指定数字的左 / 右边界
 *
 * @param {Array} nums
 * @param {*} target
 * @param {String} mode left | right 寻找左 | 右边界
 */
function findBoundary(nums, target, mode) {
  let left = 0,
    right = nums.length - 1;

  while (left < right) {
    let mid = (right + left) >> 1;

    if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else if (mode === 'left') {
      // nums[mid] === target
      // 如果下标是0或者前一个元素不等于target
      // 那么mid就是左边界
      if (mid === 0 || nums[mid - 1] !== target) {
        return mid;
      }
      // 否则，继续在左部分遍历
      right = mid - 1;
    } else if (mode === 'right') {
      // nums[mid] === target
      // 如果下标是最后一位 或者 后一个元素不等于target
      // 那么mid就是右边界
      if (mid === nums.length - 1 || nums[mid + 1] !== target) {
        return mid;
      }
      // 否则，继续在右部分遍历
      left = mid + 1;
    }
  }

  // left === right
  if (nums[left] === target) {
    return left;
  }

  return -1;
}

/**
 * 寻找指定数字的出现次数
 *
 * @param {Array} nums
 * @param {*} target
 */
function getTotalTimes(nums, target) {
  const length = nums.length;
  if (!length) {
    return 0;
  }

  return findBoundary(nums, target, 'right') - findBoundary(nums, target, 'left') + 1;
}

/**
 * 以下是测试代码
 */

const nums = [1, 2, 3, 3, 3, 4, 5];
console.log(getTotalTimes(nums, 3));
```

### 1. 题目

统计一个数字在排序数组中出现的次数。

### 思路解析

题目说是排序数组，所以可以使用“二分查找”的思想。

一种思路是查找到指定数字，然后向前向后遍历，复杂度是 O(N)。

另一种是不需要遍历所有的数字，只需要找到数字在数组中的左右边界即可，做差即可得到出现次数。

### 代码实现

```js
/**
 * 寻找指定数字的左 / 右边界
 *
 * @param {Array} nums
 * @param {*} target
 * @param {String} mode left | right 寻找左 | 右边界
 */
function findBoundary(nums, target, mode) {
  let left = 0,
    right = nums.length - 1;

  while (left < right) {
    let mid = (right + left) >> 1;

    if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else if (mode === 'left') {
      // nums[mid] === target
      // 如果下标是0或者前一个元素不等于target
      // 那么mid就是左边界
      if (mid === 0 || nums[mid - 1] !== target) {
        return mid;
      }
      // 否则，继续在左部分遍历
      right = mid - 1;
    } else if (mode === 'right') {
      // nums[mid] === target
      // 如果下标是最后一位 或者 后一个元素不等于target
      // 那么mid就是右边界
      if (mid === nums.length - 1 || nums[mid + 1] !== target) {
        return mid;
      }
      // 否则，继续在右部分遍历
      left = mid + 1;
    }
  }

  // left === right
  if (nums[left] === target) {
    return left;
  }

  return -1;
}

/**
 * 寻找指定数字的出现次数
 *
 * @param {Array} nums
 * @param {*} target
 */
function getTotalTimes(nums, target) {
  const length = nums.length;
  if (!length) {
    return 0;
  }

  return findBoundary(nums, target, 'right') - findBoundary(nums, target, 'left') + 1;
}

/**
 * 以下是测试代码
 */

const nums = [1, 2, 3, 3, 3, 4, 5];
console.log(getTotalTimes(nums, 3));
```

## 54. 二叉查找树的第 K 个结点

### 解题思路

利用二叉查找树中序遍历有序的特点。

```js
function KthNode(pRoot, k) {
  if (pRoot === null || k === 0) {
    return null;
  }
  // 为了能追踪k，应该把KthNodeCore函数定义在这里面，k应该在KthNodeCore函数外面
  function KthNodeCore(pRoot) {
    let target = null;
    if (pRoot.left !== null) {
      target = KthNodeCore(pRoot.left, k);
    }
    if (target === null) {
      if (k === 1) {
        target = pRoot;
      }
      k--;
    }
    if (target === null && pRoot.right !== null) {
      target = KthNodeCore(pRoot.right, k);
    }
    return target;
  }
  return KthNodeCore(pRoot);
}
```

## 55.1 二叉树的深度

从根结点到叶结点依次经过的结点(含根、叶结点)形成树的一条路径，最长路径的长度为树的深度。

### 解题思路

```java
public int TreeDepth(TreeNode root) {
    return root == null ? 0 : 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
}
```

```js
function TreeDepth(pRoot) {
  if (pRoot === null) return 0;
  const leftDep = TreeDepth(pRoot.left);
  const rightDep = TreeDepth(pRoot.right);
  return Math.max(leftDep, rightDep) + 1;
}
```

## 55.2 平衡二叉树

平衡二叉树左右子树高度差不超过 1。

### 解题思路

```js
function IsBalancedSolution(pRoot) {
  return TreeDepth(pRoot) !== -1;
}
function TreeDepth(pRoot) {
  if (pRoot === null) return 0;
  const leftLen = TreeDepth(pRoot.left);
  if (leftLen === -1) return -1;
  const rightLen = TreeDepth(pRoot.right);
  if (rightLen === -1) return -1;
  return Math.abs(leftLen - rightLen) > 1 ? -1 : Math.max(leftLen, rightLen) + 1;
}
```

### 思路分析

思路一：计算出左右子树的深度，然后检查差。递归继续判断左子树和右子树是不是平衡二叉树。

思路二：先计算左子树和右子树是不是平衡二叉树，然后再计算本身是不是平衡二叉树。

关于思路二为什么能比思路一更好，请看代码。

### 代码实现

#### 3.1 树的深度

先递归实现树的深度函数：

```js
class Node {
  /**
   *
   * @param {Number} value
   * @param {Node} left
   * @param {Node} right
   */
  constructor(value, left, right) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

/**
 * 获取二叉树的深度
 *
 * @param {Node} root
 */
function treeDepth(root) {
  if (!root) {
    return 0;
  }

  const leftDepth = treeDepth(root.left);
  const rightDepth = treeDepth(root.right);
  return leftDepth > rightDepth ? leftDepth + 1 : rightDepth + 1;
}
```

#### 3.2 思路一

这种思路慢是因为：节点被重复计算了。得出 `leftDepth` 计算了一遍 `root.left` ，最后还要再调用自身计算 `root.left`。尤其是叶子节点，会造成很多的计算浪费。

```js
/**
 * 判断是否是平衡二叉树
 *
 * @param {Node} root
 */
function isBalanced(root) {
  if (!root) {
    return true;
  }

  const leftDepth = treeDepth(root.left);
  const rightDepth = treeDepth(root.right);
  const diff = Math.abs(leftDepth - rightDepth);
  if (diff > 1) {
    return false;
  }

  return isBalanced(root.left) && isBalanced(root.right);
}
```

#### 3.3 思路二

先遍历和计算左右子树，最后计算本身。不需要重复计算。

```js
/**
 * 优化：判断是否是平衡二叉树
 *
 * @param {Node} root
 * @param {Object} obj
 */
function isBalanced2(root, obj = {}) {
  if (!root) {
    obj.depth = 0;
    return true;
  }

  const left = {},
    right = {};
  if (isBalanced2(root.left, left) && isBalanced2(root.right, right)) {
    const diff = Math.abs(left.depth - right.depth);
    if (diff > 1) {
      return false;
    }

    obj.depth = 1 + (left.depth > right.depth ? left.depth : right.depth);
    return true;
  } else {
    return false;
  }
}
```

#### 3.4 测试

```js
/**
 * 测试代码
 */
const root = new Node(1, new Node(2, new Node(4), new Node(5, new Node(7))), new Node(3, null, new Node(6)));

// 测试树的深度
console.log(treeDepth(root)); // output: 4

// 判断是否是平衡二叉树
console.time();
console.log(isBalanced(root)); // true
console.timeEnd(); // 0.594ms

// 优化算法：判断是否是平衡二叉树
console.time();
console.log(isBalanced2(root)); // true
console.timeEnd(); // 0.242ms
```

## 56. 数组中只出现一次的数字

一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。

### 解题思路

两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。

diff &= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。

```js
// 第一种
function FindNumsAppearOnce(array) {
  const res = [];
  for (let i = 0; i < array.length; i++) {
    if (array.indexOf(array[i]) === array.lastIndexOf(array[i])) {
      res.push(array[i]);
    }
  }
  return res;
}
// 第二种
function FindNumsAppearOnce2(array) {
  const map = {},
    res = [];
  for (let i = 0; i < array.length; i++) {
    if (!map[array[i]]) {
      map[array[i]] = 1;
    } else {
      map[array[i]]++;
    }
  }
  for (let i = 0; i < array.length; i++) {
    if (map[array[i]] === 1) {
      res.push(array[i]);
    }
  }
  return res;
}
// 第三种
function FindNumsAppearOnce3(array) {
  let tmp = array[0];
  for (let i = 1; i < array.length; i++) {
    tmp = tmp ^ array[i];
  }
  if (tmp === 0) return;
  let index = 0; // 记录第几位是1
  while ((tmp & 1) === 0) {
    tmp = tmp >> 1;
    index++;
  }
  let num1 = 0,
    num2 = 0;
  for (let i = 0; i < array.length; i++) {
    if (isOneAtIndex(array[i], index)) num1 = num1 ^ array[i];
    else num2 = num2 ^ array[i];
  }
  return [num1, num2];
}
function isOneAtIndex(num, index) {
  num = num >> index;
  return num & 1;
}
```

### 思路分析

因为空间复杂度限制，所以没法用哈希表。

如果只有 1 个数字出现 1 次，那么可以使用“异或”运算，最后的结果就是这个数字。

但题目中有 2 个数字，要考虑分组问题。将这两个数字分到 2 组中，然后再每组内分别异或：

1. 全部异或，最终结果是 2 个数字异或结果
2. 找到结果中第一个 1 出现的位数
3. 按照此位是不是 1，将原数据分成 2 组
4. 组内分别异或

### 代码实现

```js
/**
 * 找到num二进制表示中第一个1的位
 *
 * @param {Number} num
 */
function findFirstBitIsOne(num) {
  let indexBit = 0,
    flag = 1;
  while (flag && (flag & num) === 0) {
    ++indexBit;
    flag = flag << 1;
  }
  return indexBit;
}

/**
 * 判断num的第index二进制位是否为1
 *
 * @param {Number} num
 * @param {Number} index
 */
function checkIndexBitIsOne(num, index) {
  num = num >> index;
  return !!(num & 1);
}

/**
 * 主函数
 *
 * @param {Array} nums
 */
function findNumsAppearOnce(nums) {
  if (!nums) {
    return null;
  }

  let orResult = 0;
  for (let num of nums) {
    orResult ^= num;
  }

  let indexOfOne = findFirstBitIsOne(orResult);
  let num1 = 0,
    num2 = 0;
  for (let num of nums) {
    if (checkIndexBitIsOne(num, indexOfOne)) {
      num1 ^= num;
    } else {
      num2 ^= num;
    }
  }

  return [num1, num2];
}

/**
 * 测试
 */

console.log(findNumsAppearOnce([2, 4, 3, 6, 3, 2, 5, 5]));
```

### 4. 拓展阅读

在实现的过程中遇到一个好玩的问题：

```sh
$ 1 << 32 ## 1

$ 1 << 31 ## -2147483648
$ -2147483648 << 1 ## 0
```

同样是 1 移动了 32 位，但是结果不同。这是因为在位移操作中，原数和位移数都是 32 位有符号位表示。

为了防止越界，js 会“自作聪明”地帮你把位移数做运算：`shiftNum & 0x1f`。

所以，`1 << 32` 就相当于 `1 << (32 & 0x1f)`，即：`1 << 0`。

参考：[ECMA 官方定义](https://www.ecma-international.org/ecma-262/5.1/#sec-11.7.1)

## 57.1 和为 S 的两个数字

输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。

### 解题思路

使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```js
function FindContinuousSequence(sum) {
  let a = 0,
    half = sum >> 1;
  const res = [];
  while (half--) {
    a++;
    let i = 1;
    while ((i + 1) * (2 * a + i) < 2 * sum) {
      i++;
    }
    if ((i + 1) * (2 * a + i) === 2 * sum) {
      const tmp = [];
      tmp.push(a);
      tmp.push(i);
      res.push(tmp);
    }
  }
  for (let i = 0; i < res.length; i++) {
    let num = res[i][1],
      k = 1;
    const tmp = [];
    tmp.push(res[i][0]);
    while (num--) {
      tmp.push(res[i][0] + k);
      k++;
    }
    res[i] = tmp;
  }
  return res;
}
```

### 解题思路

如果这个数组不是递增的，就得用哈希表来解决，空间复杂度是 O(N)。

但是题目条件是“递增数组”，因此可以使用“双指针”的思路来实现：即一个指针指向开头，另一个指向结尾。

比较指针对应的 2 个元素的和与给定数组 s：

- 元素和 > s: 后指针向前移动
- 元素和 < s: 前指针向后移动
- 元素和 = s: 返回指针对应的 2 个元素

### 代码实现

```js
/**
 *
 * @param {Array} data
 * @param {Number} sum
 */
function findNumsWithSum(data, sum) {
  if (!Array.isArray(data) || data.length <= 1) {
    return [null, null];
  }
  let i = 0,
    j = data.length - 1;
  while (i < j) {
    let now = data[i] + data[j];
    if (now === sum) {
      return [data[i], data[j]];
    } else if (now > sum) {
      --j;
    } else {
      ++i;
    }
  }

  return [null, null];
}

/**
 * 以下是测试代码
 */

// 输出：[ 4, 11 ]
console.log(findNumsWithSum([1, 2, 4, 7, 11, 15], 15));
```

## 57.2 和为 S 的连续正数序列

输出所有和为 S 的连续正数序列。

例如和为 100 的连续序列有：

```
[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。
```

### 解题思路

```js
function FindNumbersWithSum(array, sum) {
  if (array.length < 2) return [];
  let left = 0,
    right = array.length - 1;
  const res = [];
  while (left < right) {
    if (array[left] + array[right] < sum) {
      left++;
    } else if (array[left] + array[right] > sum) {
      right--;
    } else {
      res.push(array[left], array[right]);
      break;
    }
  }
  return res;
}
```

### 思路分析

和前面题目很相似，这里也是“双指针”的思路。不同的地方有 2 个点：

- 指针是从第 0 个和第 1 个位置开始的（下面称为 a 和 b）
- 这里要计算指针范围内的所有元素和（题目要求是“连续序列”）

每次移动 a、b 之前，都要计算一下当前`[a,b]`范围内的所有元素和。如果等于 s，打印并且 b 右移；如果小于 s，b 右移；如果大于 s，a 右移。

至于为什么相等的时候 b 右移而不是 a 右移？因为 a 右移会漏掉情况，而且指针可能重叠。比如对于数组 `[1, 2, 2]`，给定 s 是 3。

### 算法实现

```js
/**
 * 打印指定数组的起始下标内的所有元素
 *
 * @param {Array} data 打印数组
 * @param {Array} seq [start, end] 数组打印元素的起始下标
 */
function print(data, seq) {
  const [start, end] = seq;
  for (let i = start; i <= end; ++i) {
    process.stdout.write(data[i] + ', ');
  }
  process.stdout.write('\n');
}

/**
 * 打印出递增数组中，所有和为s的元素
 *
 * @param {Array} data 递增数组
 * @param {Number} sum 和
 */
function findSequenceWithSum(data, sum) {
  let small = 0,
    big = 1,
    cur = data[small] + data[big];
  const middle = (data.length + 1) >> 1;
  while (small < middle) {
    if (cur <= sum) {
      cur === sum && print(data, [small, big]);
      ++big;
      cur += data[big];
    } else {
      cur -= data[small];
      ++small;
    }
  }
}

/**
 * 测试代码
 */

// 输出：
// 2, 3, 4,
// 4, 5,
findSequenceWithSum([1, 2, 3, 4, 5, 6, 7, 8], 9);
```

## 58.1 翻转单词顺序列

```html
Input: "I am a student." Output: "student. a am I"
```

### 解题思路

<!-- 第一感觉 -->

```js
function reverseString(s) {
  return s
    .split(' ')
    .reverse()
    .join(' ');
}
```

<!-- 按照书上的解法: 翻转两次 -->

```js
function reverseString(sentence) {
  // 第一次翻转：每个字符
  const chars = sentence.split('').reverse();
  let result = '',
    last = []; // 保存上一个空格到当前空格之间的所有字符

  chars.forEach(ch => {
    // 遇到空格，说明之前的字符组成了单词
    // 进行第二次翻转：单词
    if (ch === ' ') {
      result += last.reverse().join('');
      last.length = 0; // 清空上一个单词
    }

    last.push(ch);
  });

  result += last.reverse().join('');
  return result;
}

/**
 * 测试代码，输出：
 * student.a am I
 */
console.log(reverseString('I am a student.'));
```

## 58.2 左旋转字符串

```html
Input: S="abcXYZdef" K=3 Output: "XYZdefabc"
```

### 解题思路

先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。

```js
function LeftRotateString(str, n) {
  if (str === null || str.length === 0) return '';
  n = n % str.length;
  return str.slice(n) + str.slice(0, n);
}
```

## 59. 滑动窗口的最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。

例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。

### 解题思路

```js
function maxInWindows(num, size) {
  const res = [];
  if (size === 0) {
    return res;
  }
  let begin;
  const queue = [];
  for (let i = 0; i < num.length; i++) {
    begin = i - size + 1; // 代表滑动窗口的左边界
    if (queue.length === 0) {
      queue.push(i);
    } else if (begin > queue[0]) {
      queue.shift();
    }
    while (queue.length !== 0 && num[queue[queue.length - 1]] <= num[i]) {
      queue.pop();
    }
    queue.push(i);
    if (begin >= 0) {
      res.push(num[queue[0]]);
    }
  }
  return res;
}
```
