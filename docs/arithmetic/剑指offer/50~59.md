---
layout: CustomPages
title: 前端与数据结构-剑指 offer 50-59
date: 2020-11-14
aside: false
draft: true
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [50. 第一个只出现一次的字符位置](#50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
- [51. 数组中的逆序对](#51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1)
- [52. 两个链表的第一个公共结点](#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2)
- [53. 数字在排序数组中出现的次数](#53-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3)
- [54. 二叉查找树的第 K 个结点](#54-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4)
- [55.1 二叉树的深度](#551-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5)
- [55.2 平衡二叉树](#552-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6)
- [56. 数组中只出现一次的数字](#56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7)
- [57.1 和为 S 的两个数字](#571-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8)
- [57.2 和为 S 的连续正数序列](#572-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9)
- [58.1 翻转单词顺序列](#581-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10)
- [58.2 左旋转字符串](#582-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11)
- [59. 滑动窗口的最大值](#59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 50. 第一个只出现一次的字符位置

## 题目描述

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。

```
Input: abacc
Output: b
```

## 解题思路

最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```

以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。

```java
public int FirstNotRepeatingChar2(String str) {
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) && !bs2.get(c))
            bs1.set(c);     // 0 0 -> 0 1
        else if (bs1.get(c) && !bs2.get(c))
            bs2.set(c);     // 0 1 -> 1 1
    }
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) && !bs2.get(c))  // 0 1
            return i;
    }
    return -1;
}
```

```js
function FirstNotRepeatingChar(str) {
  if (str.length < 1 || str.length > 10000) return -1;
  const map = {};
  for (let i = 0; i < str.length; i++) {
    if (!map[str[i]]) {
      map[str[i]] = 1;
    } else {
      map[str[i]]++;
    }
  }
  for (let i = 0; i < str.length; i++) {
    if (map[str[i]] === 1) {
      return i;
    }
  }
  return -1;
}
```

# 51. 数组中的逆序对

## 题目描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

## 解题思路

```java
private long cnt = 0;
private int[] tmp;  // 在这里声明辅助数组，而不是在 merge() 递归函数中声明

public int InversePairs(int[] nums) {
    tmp = new int[nums.length];
    mergeSort(nums, 0, nums.length - 1);
    return (int) (cnt % 1000000007);
}

private void mergeSort(int[] nums, int l, int h) {
    if (h - l < 1)
        return;
    int m = l + (h - l) / 2;
    mergeSort(nums, l, m);
    mergeSort(nums, m + 1, h);
    merge(nums, l, m, h);
}

private void merge(int[] nums, int l, int m, int h) {
    int i = l, j = m + 1, k = l;
    while (i <= m || j <= h) {
        if (i > m)
            tmp[k] = nums[j++];
        else if (j > h)
            tmp[k] = nums[i++];
        else if (nums[i] <= nums[j])
            tmp[k] = nums[i++];
        else {
            tmp[k] = nums[j++];
            this.cnt += m - i + 1;  // nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]
        }
        k++;
    }
    for (k = l; k <= h; k++)
        nums[k] = tmp[k];
}
```

```js
function InversePairs(data) {
  if (!data || data.length < 2) return 0;
  const copy = data.slice();
  let count = 0;
  count = mergeCount(data, copy, 0, data.length - 1);
  return count % 1000000007;
}
function mergeCount(data, copy, start, end) {
  if (start === end) return 0;
  const mid = (end - start) >> 1,
    left = mergeCount(copy, data, start, start + mid), // 注意参数，copy作为data传入
    right = mergeCount(copy, data, start + mid + 1, end); // 注意参数，copy作为data传入
  let [p, q, count, copyIndex] = [start + mid, end, 0, end];
  while (p >= start && q >= start + mid + 1) {
    if (data[p] > data[q]) {
      copy[copyIndex--] = data[p--];
      count = count + q - start - mid;
    } else {
      copy[copyIndex--] = data[q--];
    }
  }
  while (p >= start) {
    copy[copyIndex--] = data[p--];
  }
  while (q >= start + mid + 1) {
    copy[copyIndex--] = data[q--];
  }
  return count + left + right;
}
```

# 52. 两个链表的第一个公共结点

## 题目描述

## 解题思路

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode l1 = pHead1, l2 = pHead2;
    while (l1 != l2) {
        l1 = (l1 == null) ? pHead2 : l1.next;
        l2 = (l2 == null) ? pHead1 : l2.next;
    }
    return l1;
}
```

```js
function FindFirstCommonNode(pHead1, pHead2) {
  const len1 = getLinkLength(pHead1),
    len2 = getLinkLength(pHead2);
  let pLong = pHead1,
    pShort = pHead2,
    lenGap = len1 - len2;
  if (len1 < len2) {
    pLong = pHead2;
    pShort = pHead1;
    lenGap = len2 - len1;
  }
  while (lenGap--) {
    pLong = pLong.next;
  }
  while (pLong !== null) {
    // pLong,pShort一起跑
    if (pLong.val === pShort.val) {
      return pLong;
    }
    pLong = pLong.next;
    pShort = pShort.next;
  }
  return null;
}
function getLinkLength(pHead) {
  let length = 0;
  while (pHead !== null) {
    pHead = pHead.next;
    length++;
  }
  return length;
}
```

# 53. 数字在排序数组中出现的次数

## 题目描述

```html
Input: nums = 1, 2, 3, 3, 3, 3, 4, 6 K = 3 Output: 4
```

## 解题思路

```java
public int GetNumberOfK(int[] nums, int K) {
    int first = binarySearch(nums, K);
    int last = binarySearch(nums, K + 1);
    return (first == nums.length || nums[first] != K) ? 0 : last - first;
}

private int binarySearch(int[] nums, int K) {
    int l = 0, h = nums.length;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= K)
            h = m;
        else
            l = m + 1;
    }
    return l;
}
```

```js
function GetNumberOfK(data, k) {
  if (getEnd(data, k) === -1 && getBegin(data, k) === -1) return 0;
  return getEnd(data, k) - getBegin(data, k) + 1;
}
function getBegin(data, k) {
  let [left, right] = [0, data.length - 1];
  let mid = (left + right) >> 1;
  while (left <= right) {
    if (data[mid] > k) {
      right = mid - 1;
    } else if (data[mid] < k) {
      left = mid + 1;
    } else if (mid - 1 >= 0 && data[mid - 1] === k) {
      right = mid - 1;
    } else return mid;
    mid = (left + right) >> 1;
  }
  return -1;
}
function getEnd(data, k) {
  let [left, right] = [0, data.length - 1];
  let mid = (left + right) >> 1;
  while (left <= right) {
    if (data[mid] > k) {
      right = mid - 1;
    } else if (data[mid] < k) {
      left = mid + 1;
    } else if (mid + 1 < data.length && data[mid + 1] === k) {
      left = mid + 1;
    } else return mid;
    mid = (left + right) >> 1;
  }
  return -1;
}
```

# 54. 二叉查找树的第 K 个结点

## 解题思路

利用二叉查找树中序遍历有序的特点。

```java
private TreeNode ret;
private int cnt = 0;

public TreeNode KthNode(TreeNode pRoot, int k) {
    inOrder(pRoot, k);
    return ret;
}

private void inOrder(TreeNode root, int k) {
    if (root == null || cnt >= k)
        return;
    inOrder(root.left, k);
    cnt++;
    if (cnt == k)
        ret = root;
    inOrder(root.right, k);
}
```

# 55.1 二叉树的深度

## 题目描述

从根结点到叶结点依次经过的结点(含根、叶结点)形成树的一条路径，最长路径的长度为树的深度。

## 解题思路

```java
public int TreeDepth(TreeNode root) {
    return root == null ? 0 : 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
}
```

```js
function TreeDepth(pRoot) {
  if (pRoot === null) return 0;
  const leftDep = TreeDepth(pRoot.left);
  const rightDep = TreeDepth(pRoot.right);
  return Math.max(leftDep, rightDep) + 1;
}
```

# 55.2 平衡二叉树

## 题目描述

平衡二叉树左右子树高度差不超过 1。

## 解题思路

```java
private boolean isBalanced = true;

public boolean IsBalanced_Solution(TreeNode root) {
    height(root);
    return isBalanced;
}

private int height(TreeNode root) {
    if (root == null || !isBalanced)
        return 0;
    int left = height(root.left);
    int right = height(root.right);
    if (Math.abs(left - right) > 1)
        isBalanced = false;
    return 1 + Math.max(left, right);
}
```

```js
function IsBalancedSolution(pRoot) {
  return TreeDepth(pRoot) !== -1;
}
function TreeDepth(pRoot) {
  if (pRoot === null) return 0;
  const leftLen = TreeDepth(pRoot.left);
  if (leftLen === -1) return -1;
  const rightLen = TreeDepth(pRoot.right);
  if (rightLen === -1) return -1;
  return Math.abs(leftLen - rightLen) > 1 ? -1 : Math.max(leftLen, rightLen) + 1;
}
```

# 56. 数组中只出现一次的数字

## 题目描述

一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。

## 解题思路

两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。

diff &= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。

```java
public void FindNumsAppearOnce(int[] nums, int num1[], int num2[]) {
    int diff = 0;
    for (int num : nums)
        diff ^= num;
    diff &= -diff;
    for (int num : nums) {
        if ((num & diff) == 0)
            num1[0] ^= num;
        else
            num2[0] ^= num;
    }
}
```

```js
// 第一种
function FindNumsAppearOnce(array) {
  const res = [];
  for (let i = 0; i < array.length; i++) {
    if (array.indexOf(array[i]) === array.lastIndexOf(array[i])) {
      res.push(array[i]);
    }
  }
  return res;
}
// 第二种
function FindNumsAppearOnce2(array) {
  const map = {},
    res = [];
  for (let i = 0; i < array.length; i++) {
    if (!map[array[i]]) {
      map[array[i]] = 1;
    } else {
      map[array[i]]++;
    }
  }
  for (let i = 0; i < array.length; i++) {
    if (map[array[i]] === 1) {
      res.push(array[i]);
    }
  }
  return res;
}
// 第三种
function FindNumsAppearOnce3(array) {
  let tmp = array[0];
  for (let i = 1; i < array.length; i++) {
    tmp = tmp ^ array[i];
  }
  if (tmp === 0) return;
  let index = 0; // 记录第几位是1
  while ((tmp & 1) === 0) {
    tmp = tmp >> 1;
    index++;
  }
  let num1 = 0,
    num2 = 0;
  for (let i = 0; i < array.length; i++) {
    if (isOneAtIndex(array[i], index)) num1 = num1 ^ array[i];
    else num2 = num2 ^ array[i];
  }
  return [num1, num2];
}
function isOneAtIndex(num, index) {
  num = num >> index;
  return num & 1;
}
```

# 57.1 和为 S 的两个数字

## 题目描述

输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。

## 解题思路

使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    int i = 0, j = array.length - 1;
    while (i < j) {
        int cur = array[i] + array[j];
        if (cur == sum)
            return new ArrayList<>(Arrays.asList(array[i], array[j]));
        if (cur < sum)
            i++;
        else
            j--;
    }
    return new ArrayList<>();
}
```

```js
function FindContinuousSequence(sum) {
  let a = 0,
    half = sum >> 1;
  const res = [];
  while (half--) {
    a++;
    let i = 1;
    while ((i + 1) * (2 * a + i) < 2 * sum) {
      i++;
    }
    if ((i + 1) * (2 * a + i) === 2 * sum) {
      const tmp = [];
      tmp.push(a);
      tmp.push(i);
      res.push(tmp);
    }
  }
  for (let i = 0; i < res.length; i++) {
    let num = res[i][1],
      k = 1;
    const tmp = [];
    tmp.push(res[i][0]);
    while (num--) {
      tmp.push(res[i][0] + k);
      k++;
    }
    res[i] = tmp;
  }
  return res;
}
```

# 57.2 和为 S 的连续正数序列

## 题目描述

输出所有和为 S 的连续正数序列。

例如和为 100 的连续序列有：

```
[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。
```

## 解题思路

```java
public ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    int start = 1, end = 2;
    int curSum = 3;
    while (end < sum) {
        if (curSum > sum) {
            curSum -= start;
            start++;
        } else if (curSum < sum) {
            end++;
            curSum += end;
        } else {
            ArrayList<Integer> list = new ArrayList<>();
            for (int i = start; i <= end; i++)
                list.add(i);
            ret.add(list);
            curSum -= start;
            start++;
            end++;
            curSum += end;
        }
    }
    return ret;
}
```

```js
function FindNumbersWithSum(array, sum) {
  if (array.length < 2) return [];
  let left = 0,
    right = array.length - 1;
  const res = [];
  while (left < right) {
    if (array[left] + array[right] < sum) {
      left++;
    } else if (array[left] + array[right] > sum) {
      right--;
    } else {
      res.push(array[left], array[right]);
      break;
    }
  }
  return res;
}
```

# 58.1 翻转单词顺序列

## 题目描述

```html
Input: "I am a student." Output: "student. a am I"
```

## 解题思路

<!-- 第一感觉 -->

```js
function reverseString(s) {
  return s
    .split(' ')
    .reverse()
    .join(' ');
}
```

<!-- 按照书上的解法: 翻转两次 -->

```js
function reverseString(sentence) {
  // 第一次翻转：每个字符
  const chars = sentence.split('').reverse();
  let result = '',
    last = []; // 保存上一个空格到当前空格之间的所有字符

  chars.forEach(ch => {
    // 遇到空格，说明之前的字符组成了单词
    // 进行第二次翻转：单词
    if (ch === ' ') {
      result += last.reverse().join('');
      last.length = 0; // 清空上一个单词
    }

    last.push(ch);
  });

  result += last.reverse().join('');
  return result;
}

/**
 * 测试代码，输出：
 * student.a am I
 */
console.log(reverseString('I am a student.'));
```

# 58.2 左旋转字符串

## 题目描述

```html
Input: S="abcXYZdef" K=3 Output: "XYZdefabc"
```

## 解题思路

先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。

```java
public String LeftRotateString(String str, int n) {
    if (n >= str.length())
        return str;
    char[] chars = str.toCharArray();
    reverse(chars, 0, n - 1);
    reverse(chars, n, chars.length - 1);
    reverse(chars, 0, chars.length - 1);
    return new String(chars);
}

private void reverse(char[] chars, int i, int j) {
    while (i < j)
        swap(chars, i++, j--);
}

private void swap(char[] chars, int i, int j) {
    char t = chars[i];
    chars[i] = chars[j];
    chars[j] = t;
}
```

```js
function LeftRotateString(str, n) {
  if (str === null || str.length === 0) return '';
  n = n % str.length;
  return str.slice(n) + str.slice(0, n);
}
```

# 59. 滑动窗口的最大值

## 题目描述

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。

例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。

## 解题思路

```java
public ArrayList<Integer> maxInWindows(int[] num, int size) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (size > num.length || size < 1)
        return ret;
    PriorityQueue<Integer> heap = new PriorityQueue<>((o1, o2) -> o2 - o1);  /* 大顶堆 */
    for (int i = 0; i < size; i++)
        heap.add(num[i]);
    ret.add(heap.peek());
    for (int i = 0, j = i + size; j < num.length; i++, j++) {            /* 维护一个大小为 size 的大顶堆 */
        heap.remove(num[i]);
        heap.add(num[j]);
        ret.add(heap.peek());
    }
    return ret;
}
```
