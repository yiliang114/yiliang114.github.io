---
layout: CustomPages
title: 前端与数据结构-剑指 offer ~68
date: 2020-11-14
aside: false
draft: true
---

## 60. n 个骰子的点数

把 n 个骰子扔在地上，求点数和为 s 的概率。

### 思路分析

递归的思路就是组合出所有情况，然后每种情况记录出现次数，最后除以 6^n 即可。其中，6^n 就是所有情况的总数。

书中提出的方法是**使用循环来优化递归**，递归是自顶向下，循环是自底向上，思考起来有难度。

技巧性很强，准备 2 个数组，假想每次投掷一个骰子，出现和为 n 的次数，就是之前骰子和为 n-1, n-2, ..., n-6 的次数和。依次类推，每次存储结果都和之前的数组不同。

### 算法实现

```js
const gMaxValue = 6; // 每个骰子的最大点数

/**
 *
 * @param {Number} number 骰子的个数
 */
function printProbability(number) {
  if (number < 1) {
    return;
  }

  const probabilities = [new Array(gMaxValue * number + 1), new Array(gMaxValue * number + 1)];
  let flag = 0;

  // 初始化
  for (let i = 0; i < gMaxValue * number + 1; ++i) {
    probabilities[0][i] = probabilities[1][i] = 0;
  }

  // 第一次掷骰子，出现的和只有有 gMaxValue 种情况，每种和的次数为 1
  for (let i = 1; i <= gMaxValue; ++i) {
    probabilities[flag][i] = 1;
  }

  // 之后是从第 2 ~ number 次掷骰子
  //
  for (let k = 2; k <= number; ++k) {
    // 第k次掷骰子，那么最小值就是k
    // 不可能出现比k小的情况
    for (let i = 0; i < k; ++i) {
      probabilities[1 - flag][i] = 0;
    }

    // 可能出现的和的范围就是 [k, gMaxValue * k + 1)
    // 此时和为i的出现次数，就是上次循环中骰子点数和为
    // i - 1, i - 2, ..., i - 6 的次数总和
    for (let i = k; i < gMaxValue * k + 1; ++i) {
      probabilities[1 - flag][i] = 0;
      // 这里的j是指：本骰子掷出的结果
      for (let j = 1; j < i && j <= gMaxValue; ++j) {
        probabilities[1 - flag][i] += probabilities[flag][i - j];
      }
    }

    flag = 1 - flag;
  }

  // 全部情况的总数
  const total = Math.pow(gMaxValue, number);
  for (let i = number; i < gMaxValue * number + 1; ++i) {
    console.log(`sum is ${i}, ratio is ${probabilities[flag][i] / total}`);
  }
}
```

#### 动态规划

使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。

空间复杂度：O(N^2)

```java
public List<Map.Entry<Integer, Double>> dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[n + 1][pointNum + 1];

    for (int i = 1; i <= face; i++)
        dp[1][i] = 1;

    for (int i = 2; i <= n; i++)
        for (int j = i; j <= pointNum; j++)     /* 使用 i 个骰子最小点数为 i */
            for (int k = 1; k <= face && k <= j; k++)
                dp[i][j] += dp[i - 1][j - k];

    final double totalNum = Math.pow(6, n);
    List<Map.Entry<Integer, Double>> ret = new ArrayList<>();
    for (int i = n; i <= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry<>(i, dp[n][i] / totalNum));

    return ret;
}
```

#### 动态规划 + 旋转数组

空间复杂度：O(N)

```java
public List<Map.Entry<Integer, Double>> dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[2][pointNum + 1];

    for (int i = 1; i <= face; i++)
        dp[0][i] = 1;

    int flag = 1;                                     /* 旋转标记 */
    for (int i = 2; i <= n; i++, flag = 1 - flag) {
        for (int j = 0; j <= pointNum; j++)
            dp[flag][j] = 0;                          /* 旋转数组清零 */

        for (int j = i; j <= pointNum; j++)
            for (int k = 1; k <= face && k <= j; k++)
                dp[flag][j] += dp[1 - flag][j - k];
    }

    final double totalNum = Math.pow(6, n);
    List<Map.Entry<Integer, Double>> ret = new ArrayList<>();
    for (int i = n; i <= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry<>(i, dp[1 - flag][i] / totalNum));

    return ret;
}
```

## 61. 扑克牌顺子

五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。

### 思路分析

难度不大，可以将大小王看成数字 0，可以在任何不连续的两个数字之间做填充。

首先将原数组排序，然后统计任意数字（0）的出现次数。再遍历之后的数字，找出不相邻数字之间总共差多少个数字。

最后比较 0 的出现次数和总共差多少个数字，两者的大小关系。

**注意**：连续两个相同的数字是对子，不符合要求。

### 代码实现

```js
function IsContinuous(numbers) {
  let max = 0,
    min = 14,
    flag = 0;
  if (numbers.length !== 5) return false;
  for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 13 || numbers[i] < 0) return false;
    if (numbers[i] === 0) continue;
    if (((flag >> numbers[i]) & 1) === 1) return false;
    flag = flag | (1 << numbers[i]);
    if (numbers[i] > max) max = numbers[i];
    if (numbers[i] < min) min = numbers[i];
  }
  if (max - min >= 5) return false;
  return true;
}
```

```js
/**
 *
 * @param {Array} numbers
 */
function isContinuous(numbers) {
  numbers.sort();
  const length = numbers.length;

  let zeroNum = 0;
  for (let i = 0; i < length && !numbers[i]; ++i) {
    ++zeroNum;
  }

  let interval = 0;
  for (let i = zeroNum + 1; i < length - 1; ++i) {
    if (numbers[i] === numbers[i + 1]) {
      return false;
    }
    interval += numbers[i + 1] - numbers[i] - 1;
  }

  return interval <= zeroNum;
}
```

## 62. 圆圈中最后剩下的数

让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。

### 解题思路

约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。

```js
function LastRemainingSolution(n, m) {
  if (n === 0 || m === 0) return -1;
  const child = [];
  let del = 0;
  for (let i = 0; i < n; i++) {
    child[i] = i;
  }
  while (child.length > 1) {
    const k = m - 1;
    del = (del + k) % child.length;
    child.splice(del, 1);
  }
  return child[0];
}
```

### 思路分析

这个其实是经典的“约瑟夫环”问题。常用解法就是“循环取余”。每次都把下标移动 m 个位置，然后移除当前元素。直到只剩最后一个元素。

### 代码实现

```js
/**
 * @param {Number} n 0, 1, 2, ..., n-1 一共n个数字
 * @param {Number} m 被删除的第m个数字(从0计算)
 */
function lastRemain(n, m) {
  // 生成 [0, 1, ... , n-1] 的列表
  const nums = new Array(n);
  for (let i = 0; i < n; ++i) {
    nums[i] = i;
  }

  // 逐步移除第m个数字
  let start = 0;
  while (nums.length > 1) {
    start = (start + m) % nums.length;
    nums.splice(start, 1);
  }

  return nums.shift();
}

/**
 * 测试函数
 */
console.log(lastRemain(5, 2));
```

## 63. 股票的最大利润

[LeetCode](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/)

可以有一次买入和一次卖出，买入必须在前。求最大收益。

### 解题思路

使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let min = prices[0];
  let profit = 0;
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] > prices[i - 1]) {
      profit = Math.max(profit, prices[i] - min);
    } else {
      min = Math.min(min, prices[i]);
    }
  }
  return profit;
};
```

## 64. 求 1+2+3+...+n

要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。

### 解题思路

使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。

条件与 && 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 && 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。

本题的递归返回条件为 n <= 0，取非后就是 n > 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) > 0。

```js
function SumSolution(n) {
  return n && Sum_Solution(n - 1) + n;
}
```

## 65. 不用加减乘除做加法

写一个函数，求两个整数之和，要求不得使用 +、-、`*`、/ 四则运算符号。

### 解题思路

a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位。

递归会终止的原因是 (a & b) << 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。

```js
function Add(num1, num2) {
  while (num2 !== 0) {
    const tmp1 = num1 ^ num2;
    num2 = (num1 & num2) << 1;
    num1 = tmp1;
  }
  return num1;
}
```

## 66. 构建乘积数组

给定一个数组 A[0, 1,..., n-1]，请构建一个数组 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]\*A[1]\*...\*A[i-1]\*A[i+1]\*...\*A[n-1]。要求不能使用除法。

### 解题思路

```js
// 第一种
function multiply(array) {
  const C = [],
    D = [],
    n = array.length;
  C[0] = array[0];
  for (let i = 1; i < n; i++) {
    C[i] = array[i] * C[i - 1];
  }
  D[n - 1] = array[n - 1];
  for (let i = n - 2; i >= 0; i--) {
    D[i] = array[i] * D[i + 1];
  }
  const B = [];
  B[0] = D[1];
  B[n - 1] = C[n - 2];
  for (let i = 1; i < n - 1; i++) {
    B[i] = C[i - 1] * D[i + 1];
  }
  return B;
}
// 第二种
function multiply2(array) {
  const B = [],
    len = array.length;
  B[0] = 1;
  // 计算前i - 1个元素的乘积
  for (let i = 1; i < len; i++) {
    B[i] = array[i - 1] * B[i - 1];
  }
  let tmp = 1;
  // 计算后N - i个元素的乘积并连接
  for (let i = len - 2; i >= 0; i--) {
    tmp *= array[i + 1];
    B[i] *= tmp;
  }
  return B;
}
```

## 67. 把字符串转换成整数

将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。

```
Input: +2147483647 1a33 Output: 2147483647 0
```

### 解题思路

```js
function strToInt(str) {
  let res = 0,
    flag = 1;
  const n = str.length;
  if (!n) return 0;
  if (str[0] === '-') {
    flag = -1;
  }
  for (let i = str[0] === '+' || str[0] === '-' ? 1 : 0; i < n; i++) {
    if (!(str[i] >= '0' && str[i] <= '9')) return 0;
    res = (res << 1) + (res << 3) + (str[i] - '0');
  }
  return res * flag;
}
```

## 68. 树中两个节点的最低公共祖先

### 二叉查找树

[LeetCode : 235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val >= p.val && root.val <= q.val。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null)
        return root;
    if (root.val > p.val && root.val > q.val)
        return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val)
        return lowestCommonAncestor(root.right, p, q);
    return root;
}
```

### 普通二叉树

[LeetCode : 236. Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```
