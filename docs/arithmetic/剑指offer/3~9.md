---
layout: CustomPages
title: 前端与数据结构-剑指 offer 3~9
date: 2020-12-6
aside: false
poc: false
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

**Table of Contents** _generated with [DocToc](https://github.com/thlorenz/doctoc)_

- [3. 数组中重复的数字](#3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97)
  - [解法一](#%E8%A7%A3%E6%B3%95%E4%B8%80)
  - [解法二](#%E8%A7%A3%E6%B3%95%E4%BA%8C)
- [4. 二维数组中的查找](#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
- [5. 替换空格](#5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC)
- [6. 从尾到头打印链表](#6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1)
    - [使用递归](#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92)
    - [使用头插法](#%E4%BD%BF%E7%94%A8%E5%A4%B4%E6%8F%92%E6%B3%95)
    - [使用栈](#%E4%BD%BF%E7%94%A8%E6%A0%88)
    - [js](#js)
- [7. 重建二叉树](#7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2)
- [8. 二叉树的下一个结点](#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3)
- [9. 用两个栈实现队列](#9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4)
- [9.1 旋转数组中最小的数字](#91-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 3. 数组中重复的数字

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

```
Input: {2, 3, 1, 0, 2, 5}
Output: 2
```

### 解法一

利用哈希表，遍历数组，如果哈希表中没有该元素，则存入哈希表中，否则返回重复的元素。时间复杂度为 `O(n)`，空间复杂度为 `O(n)`。但使用了额外的空间。

```js
function duplicateInArray(arr = []) {
  if (arr && arr.length) {
    const map = {};
    for (const val of arr) {
      if (map[val]) {
        return val;
      }
      map[val] = true;
    }
  }
}
```

### 解法二

要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。

长度为 `n`，元素的数值范围也为 `n`，如果没有重复元素，那么数组每个下标对应的值与下标相等。

从头到尾遍历数组，当扫描到下标 `i` 的数字 `nums[i]`：

- 如果等于 `i`，继续向下扫描；
- 如果不等于 `i`，拿它与第 `nums[i]` 个数进行比较，如果相等，说明有重复值，返回 `nums[i]`。如果不相等，就把第 `i` 个数 和第 `nums[i]` 个数交换。重复这个比较交换的过程。

此算法时间复杂度为 `O(n)`，因为每个元素最多只要两次交换，就能确定位置(比如把 2 跟 5 交换，此时 2 在正确的位置，而 5 需要再交换一次就能跑到正确的位置)。空间复杂度为 `O(1)`。

```js
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}

function duplicateInArray(arr = []) {
  // 不符合题目条件
  if (!arr || arr.length < 2) return -1;
  for (let i = 0; i < arr.length; i++) {
    // 值超出范围
    if (arr[i] < 0 || arr[i] >= arr.length) return -1;
    // 每个元素最多交换两次
    while (arr[i] != i) {
      const val = arr[arr[i]];
      if (arr[i] == val) {
        return val;
      }
      swap(arr, i, arr[i]);
    }
  }
  return -1;
}
```

### JS

```js
// 第一种
function duplicate(numbers, duplication) {
  for (let i = 0; i < numbers.length; i++) {
    while (i !== numbers[i]) {
      if (numbers[i] === numbers[numbers[i]]) {
        duplication[0] = numbers[i];
        return true;
      }
      let temp = numbers[i];
      [numbers[i], numbers[temp]] = [numbers[temp], numbers[i]]; // 交换
    }
  }
  return false;
}

// 第二种
function duplicate2(numbers, duplication) {
  for (let i = 0; i < numbers.length; i++) {
    let index = numbers[i];
    if (index >= numbers.length) {
      index -= numbers.length;
    }
    if (numbers[index] >= numbers.length) {
      duplication[0] = index;
      return true;
    }
    numbers[index] = numbers[index] + numbers.length;
  }
  return false;
}
```

# 4. 二维数组中的查找

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21,
23, 26, 30] ] Given target = 5, return true. Given target = 20, return false.
```

## 解题思路

要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。

```js
function find(arr, target) {
  if (!arr || !arr.length || !arr[0].length) {
    return false;
  }
  const rows = arr.length,
    cols = arr[0].length;
  // 从右上角开始
  let i = 0,
    j = cols - 1;
  while (i <= rows - 1 && j >= 0) {
    const k = arr[i][j];
    if (k === target) {
      return true;
    } else if (k < target) {
      // 越往下值越大
      i++;
    } else {
      // 越往前值越小
      j--;
    }
  }
  return false;
}

const a = [
  [1, 4, 7, 11, 15],
  [2, 5, 8, 12, 19],
  [3, 6, 9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30],
];

console.log(find(a, 5));
console.log(find(a, 20));
```

```js
function Find(target, array) {
  // write code here
  const n = array.length,
    m = array[0].length;
  let row = n - 1,
    col = 0;
  if (m === 0 && n === 0) {
    return false;
  }
  while (row >= 0 && col <= m - 1) {
    if (array[row][col] > target) {
      row--;
    } else if (array[row][col] < target) {
      col++;
    } else return true;
  }
  return false;
}
```

## 2. 解题思路

时间复杂度是 $O(N)$，空间复杂度是$O(1)$

**利用数组的排序性质**：如果要查找的元素小于当前元素，那么一定不在当前元素左边的列；如果要查找的元素大于当前元素，那么一定在当前元素下面的行。

## 3. 代码

```js
/**
 * 题目答案
 * @param {Array} arr
 * @param {Number} elem
 */

function findElem(arr, elem) {
  let row = arr.length - 1,
    col = arr[0].length - 1;
  let i = 0,
    j = col;

  while (i <= row && j >= 0) {
    if (arr[i][j] === elem) {
      return true;
    }

    if (elem > arr[i][j]) {
      ++i;
    } else {
      --j;
    }
  }

  return false;
}

/**
 * 以下是测试代码
 */

const arr = [
  [1, 2, 8, 9],
  [2, 4, 9, 12],
  [4, 7, 10, 13],
  [6, 8, 11, 15],
];

console.log(findElem(arr, 8));
console.log(findElem(arr, 1));
console.log(findElem(arr, 145));
```

# 5. 替换空格

JS 中直接用正则进行替换。

```js
function replaceSpace(str) {
  return str.replace(/\s/g, '%20');
}
```

# 6. 从尾到头打印链表

从尾到头反过来打印出每个结点的值。

## 解题思路

可以从头到尾遍历一遍链表，将节点放入栈中，然后依次取出打印（后入先出）。

优化就是借助“递归”，先向下查找再打印输出，也可实现这种“后入先出”。可以类比二叉树的后序遍历。

### 使用递归

要逆序打印链表 1->2->3(3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。

```js
class Node {
  /**
   * 节点构造函数
   * @param {*} value
   * @param {Node} next
   */
  constructor(value, next) {
    this.value = value;
    this.next = next;
  }
}

class List {
  constructor() {
    this.head = new Node(null, null);
  }

  /**
   * 从0开始计算，找到包括head在内的位于index的节点
   * @param {Number} index
   */
  find(index) {
    let current = this.head;
    for (let i = 0; i < index; ++i) {
      current = current.next;
    }
    return current;
  }

  /**
   * 向index位置插入元素
   * @param {*} value
   * @param {Number} index
   */
  insert(value, index) {
    const prev = this.find(index);
    const next = new Node(value, prev.next);
    prev.next = next;
  }
}

/**
 * 逆序打印链表
 * @param {Node} node
 */
function printFromTailToHead(node) {
  if (node.next) {
    printFromTailToHead(node.next);
  }
  node.value && console.log(node.value);
}

/**
 * 以下是测试代码
 */
let list = new List();
list.insert('a', 0);
list.insert('b', 1);
list.insert('c', 2);

printFromTailToHead(list.head);
```

### 使用头插法

使用头插法可以得到一个逆序的链表。

头结点和第一个节点的区别：

- 头结点是在头插法中使用的一个额外节点，这个节点不存储值；
- 第一个节点就是链表的第一个真正存储值的节点。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    // 头插法构建逆序链表
    ListNode head = new ListNode(-1);
    while (listNode != null) {
        ListNode memo = listNode.next;
        listNode.next = head.next;
        head.next = listNode;
        listNode = memo;
    }
    // 构建 ArrayList
    ArrayList<Integer> ret = new ArrayList<>();
    head = head.next;
    while (head != null) {
        ret.add(head.val);
        head = head.next;
    }
    return ret;
}
```

### 使用栈

栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。

```js
function ListNode(x) {
  this.val = x;
  this.next = null;
}

function printListFromTailToHead(head) {
  // write code here
  const res = [];
  let pNode = head;
  while (pNode !== null) {
    res.unshift(pNode.val);
    pNode = pNode.next;
  }
  return res;
}
```

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    Stack<Integer> stack = new Stack<>();
    while (listNode != null) {
        stack.add(listNode.val);
        listNode = listNode.next;
    }
    ArrayList<Integer> ret = new ArrayList<>();
    while (!stack.isEmpty())
        ret.add(stack.pop());
    return ret;
}
```

# 7. 重建二叉树

根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

## 解题思路

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

```java
// 缓存中序遍历数组每个值对应的索引
private Map<Integer, Integer> indexForInOrders = new HashMap<>();

public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
    for (int i = 0; i < in.length; i++)
        indexForInOrders.put(in[i], i);
    return reConstructBinaryTree(pre, 0, pre.length - 1, 0);
}

private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL) {
    if (preL > preR)
        return null;
    TreeNode root = new TreeNode(pre[preL]);
    int inIndex = indexForInOrders.get(root.val);
    int leftTreeSize = inIndex - inL;
    root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, inL);
    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, inL + leftTreeSize + 1);
    return root;
}
```

```js
function TreeNode(x) {
  this.val = x;
  this.left = null;
  this.right = null;
}

function reConstructBinaryTree(pre, vin) {
  // write code here
  if (pre.length === 0 || vin.length === 0) {
    return null;
  }
  // 前序第一个是根节点，也是中序左右子树的分割点
  const index = vin.indexOf(pre[0]),
    left = vin.slice(0, index),
    right = vin.slice(index + 1);
  return {
    val: pre[0],
    // 递归左右子树的前序、中序
    left: reConstructBinaryTree(pre.slice(1, index + 1), left),
    right: reConstructBinaryTree(pre.slice(index + 1), right),
  };
}
```

## 2. 解题思路

1. 前序遍历的第一个元素一定是树的根结点
2. 在中序遍历中找到此节点，左边是左子树，右边是右子树
3. 根据左右子树的长度，再次划分两个序列，进一步递归

![](https://i.loli.net/2019/06/09/5cfcfdba0879632882.png)

## 3. 代码

```js
/**
 * 二叉树结点类
 */
class Node {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

/**
 * 根据前序遍历和中序遍历重构二叉树
 * @param {Array} preorder
 * @param {Array} inorder
 * @return {Node}
 */

function reConstruct(preorder, inorder) {
  if (!preorder.length || !inorder.length) {
    return;
  }

  let node = new Node(preorder[0]);

  let i = 0;
  for (; i < inorder.length; ++i) {
    if (inorder[i] === preorder[0]) {
      break;
    }
  }

  // 通过变量i可以确定在 前序遍历 / 中序遍历中 确定 左 / 右子树的长度
  node.left = reConstruct(preorder.slice(1, i + 1), inorder.slice(0, i));
  node.right = reConstruct(preorder.slice(i + 1), inorder.slice(i + 1));

  return node;
}

/**
 * 以下是测试代码
 */

const preArr = [1, 2, 4, 7, 3, 5, 6, 8];
const midArr = [4, 7, 2, 1, 5, 3, 8, 6];
const binTree = reConstruct(preArr, midArr);
console.log(binTree);
```

# 8. 二叉树的下一个结点

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

```java
public class TreeLinkNode {

    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
```

## 解题思路

① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；

② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。

```java
public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if (pNode.right != null) {
        TreeLinkNode node = pNode.right;
        while (node.left != null)
            node = node.left;
        return node;
    } else {
        while (pNode.next != null) {
            TreeLinkNode parent = pNode.next;
            if (parent.left == pNode)
                return parent;
            pNode = pNode.next;
        }
    }
    return null;
}
```

```js
function GetNext(pNode) {
  if (pNode === null) {
    return null;
  }
  if (pNode.right !== null) {
    // 第1种
    pNode = pNode.right;
    while (pNode.left !== null) {
      pNode = pNode.left;
    }
    return pNode;
  }
  while (pNode.next !== null) {
    // 第2种
    if (pNode === pNode.next.left) {
      return pNode.next;
    }
    pNode = pNode.next;
  }
  return null;
}
```

# 9. 用两个栈实现队列

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

## 解题思路

in 栈用来处理入栈(push)操作，out 栈用来处理出栈(pop)操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。

```java
Stack<Integer> in = new Stack<Integer>();
Stack<Integer> out = new Stack<Integer>();

public void push(int node) {
    in.push(node);
}

public int pop() throws Exception {
    if (out.isEmpty())
        while (!in.isEmpty())
            out.push(in.pop());

    if (out.isEmpty())
        throw new Exception("queue is empty");

    return out.pop();
}
```

```js
const outStack = [],
  inStack = [];
function push(node) {
  // write code here
  inStack.push(node);
}
function pop() {
  // write code here
  if (!outStack.length) {
    while (inStack.length) {
      outStack.push(inStack.pop());
    }
  }
  return outStack.pop();
}
```

## 2. 解题思路

一个栈用来存储插入队列数据，一个栈用来从队列中取出数据。

从第一个栈向第二个栈转移数据的过程中：数据的性质已经从后入先出变成了先入先出。

## 3. 代码

```js
class Queue {
  constructor() {
    this.stack1 = [];
    this.stack2 = [];
  }

  appendTail(value) {
    // 新插入队列的数据都放在 stack1
    this.stack1.splice(0, 0, value);
  }

  deleteHead() {
    // 将要取出的值都从stack2中取
    // 如果stack2为空，那么将 stack1 中的元素都转移过来
    // 此时，stack2中的元素顺序已经被改变了，满足队列的条件
    if (this.stack2.length === 0) {
      let length = this.stack1.length;
      for (let i = 0; i < length; ++i) {
        this.stack2.splice(0, 0, this.stack1.shift());
      }
    }

    return this.stack2.length === 0 ? null : this.stack2.shift();
  }
}

/**
 * 测试代码
 */

let queue = new Queue();
queue.appendTail(1);
queue.appendTail(2);
queue.appendTail(3);

console.log(queue.deleteHead());
queue.appendTail(1);

console.log(queue.deleteHead());
console.log(queue.deleteHead());
console.log(queue.deleteHead());
```

# 9.1 旋转数组中最小的数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。

## 2. 解题思路

最简单的肯定是从头到尾遍历，复杂度是 $O(N)$。**这种方法没有利用“旋转数组”的特性**。

借助二分查找的思想，时间复杂度可以降低到 $O(log(N))$。

可以通过以下方法确定最小值元素的位置，然后移动指针，缩小范围：

- 中间指针对应的元素 ≥ 左侧元素, 那么中间元素位于原递增数组中, 最小值在右侧
- 中间指针对应的元素 ≤ 右侧元素, 那么中间元素位于被移动的递增数组中，最小值在左侧

特殊情况，如果三者相等，那么无法判断最小值元素的位置，就退化为普通遍历即可。

## 3. 代码

先上一段二分查找和实现思路：

```javascript
/**
 * 二分查找
 * @param {Array} arr
 * @param {*} elem
 */
function binarySearch(arr, elem) {
  let left = 0,
    right = arr.length - 1,
    mid = -1;

  while (left <= right) {
    // 注意是≤：考虑只剩1个元素的情况
    mid = Math.floor((left + right) / 2);

    if (arr[mid] === elem) {
      return true;
    }

    if (elem < arr[mid]) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return false;
}

/**
 * 测试代码
 */
console.log(binarySearch([1, 2], 2));
console.log(binarySearch([1, 2], -1));
console.log(binarySearch([1, 2, 10], 2));
```

借助二分查找的思想，写出本题代码：

```javascript
/**
 * 在arr[left, right]中顺序查找最小值
 * @param {Array} arr
 * @param {Number} left
 * @param {Number} right
 */
function orderSearchMin(arr, left, right) {
  let min = arr[left];

  for (let i = left + 1; i <= right; ++i) {
    arr[i] < min && (min = arr[i]);
  }

  return min;
}

/**
 * 在旋转数组arr中用二分法查找最小值
 * @param {Array} arr
 */

function binSearchMin(arr) {
  if (!Array.isArray(arr) || !arr.length) {
    throw Error('Empty Array');
  }

  let left = 0,
    right = arr.length - 1,
    mid = null;

  while (left < right) {
    if (right === 1 + left) {
      return arr[right];
    }

    mid = Math.floor((left + right) / 2);

    if (arr[mid] === arr[left] && arr[mid] === arr[right]) {
      // 无法判断最小值位置
      return orderSearchMin(arr, left, right);
    }

    if (arr[mid] >= arr[left]) {
      // 最小值在右边
      left = mid;
    } else if (arr[mid] <= arr[right]) {
      // 最小值在左边
      right = mid;
    }
  }

  return arr[right];
}

/**
 * 测试代码
 */

console.log(binSearchMin([3, 4, 5, 1, 2]));
console.log(binSearchMin([2, 3, 4, 5, 1]));
console.log(binSearchMin([2, 2, 2, 1, 1, 2]));
console.log(binSearchMin([1]));
```

```js
// 第一种
function minNumberInRotateArray1(rotateArray) {
  // write code here
  if (rotateArray.length === 0) return 0;
  for (let i = 0; i < rotateArray.length; i++) {
    if (rotateArray[i] > rotateArray[i + 1]) return rotateArray[i + 1];
  }
  return rotateArray[0];
}

// 第二种
function minNumberInRotateArray2(rotateArray) {
  let left = 0,
    right = rotateArray.length - 1;
  while (right - left > 1) {
    let mid = (left + (right - left)) >> 1;
    mid = left + ((right - left) >> 1);
    if (rotateArray[mid] > rotateArray[right]) {
      left = mid;
    } else {
      right = mid;
    }
  }
  return Math.min(rotateArray[left], rotateArray[right]);
}
```
