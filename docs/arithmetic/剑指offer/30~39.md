---
layout: CustomPages
title: 前端与数据结构-剑指 offer 30-39
date: 2020-11-14
aside: false
draft: true
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [30. 包含 min 函数的栈](#30-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
- [31. 栈的压入、弹出序列](#31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1)
- [32.1 从上往下打印二叉树](#321-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2)
- [32.2 把二叉树打印成多行](#322-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3)
- [32.3 按之字形顺序打印二叉树](#323-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4)
- [33. 二叉搜索树的后序遍历序列](#33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5)
- [34. 二叉树中和为某一值的路径](#34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6)
- [35. 复杂链表的复制](#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7)
- [36. 二叉搜索树与双向链表](#36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8)
- [37. 序列化二叉树](#37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9)
- [38. 字符串的全排列](#38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10)
- [39. 数组中出现次数超过一半的数字](#39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 30. 包含 min 函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

### 解题思路

```js
const stack = [],
  minStack = [];
let tmp = null;
function push(node) {
  if (tmp !== null) {
    if (tmp > node) {
      tmp = node;
    }
    stack.push(node);
    minStack.push(tmp);
  } else {
    tmp = node;
    stack.push(node);
    minStack.push(tmp);
  }
}
function pop() {
  stack.pop();
  minStack.pop();
}
function top() {
  return stack[stack.length - 1];
}
function min() {
  return minStack[minStack.length - 1];
}
```

### 思路分析

有关栈的题目，可以考虑使用“辅助栈”，即利用空间换时间的方法。

这道题就是借助“辅助栈”来实现。当有新元素被 push 进普通栈的时候，**程序比较新元素和辅助栈中的原有元素，选出最小的元素，将其放入辅助栈**。

根据栈的特点和操作思路，辅助栈顶的元素就是最小元素。并且辅助栈的元素和普通栈的元素是“一一对应”的。

### 代码实现

```js
/**
 * 包含Min函数的栈
 */
class MinStack {
  constructor() {
    this.stack = []; // 数据栈
    this.minStack = []; // 辅助栈
  }

  push(item) {
    const minLength = this.minStack.length;
    this.stack.push(item);

    if (minLength === 0) {
      // 初始情况: 直接放入
      this.minStack.push(item);
    } else {
      if (item < this.minStack[minLength - 1]) {
        // 新元素 ＜ 辅助栈的最小元素: 将新元素放入
        this.minStack.push(item);
      } else {
        // 否则,为了保持2个栈的对应关系，放入辅助栈最小元素
        this.minStack.push(this.minStack[minLength - 1]);
      }
    }
  }

  pop() {
    if (this.stack.length === 0) {
      return null;
    }

    this.stack.pop();
    return this.minStack.pop();
  }

  min() {
    const minLength = this.minStack.length;
    if (minLength === 0) {
      return null;
    }

    return this.minStack[minLength - 1];
  }
}

/**
 * 以下是测试代码
 */

const minStack = new MinStack();

minStack.push(3);
minStack.push(4);
minStack.push(2);
minStack.push(1);
console.log(minStack.minStack, minStack.min()); // output: [ 3, 3, 2, 1 ] 1

minStack.pop();
minStack.pop();
minStack.push(0);
console.log(minStack.minStack, minStack.min()); // output: [ 3, 3, 0 ] 0
```

## 31. 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。

例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。

### 解题思路

使用一个栈来模拟压入弹出操作。

```js
// 第一种
function IsPopOrder(pushV, popV) {
  const helpStack = [];
  let flag = false;
  while (pushV.length || helpStack.length) {
    while (helpStack[helpStack.length - 1] === popV[0] && helpStack.length) {
      helpStack.pop();
      popV.shift();
    }
    if (!popV.length) {
      flag = true;
    }
    if (!pushV.length) {
      break;
    }
    helpStack.push(pushV.shift());
  }
  return flag;
}
```

### 思路分析

栈的题目还是借助“辅助栈”。大体思路如下：

1. 将入栈序列的元素依次入辅助栈
2. 检查辅助栈顶元素和弹栈序列栈顶元素是否一致：

- 元素一致，弹出辅助栈元素，弹栈序列指针后移
- 不一致，回到第一步

需要注意的是，过程中的边界条件检查（多试试几种情况）。除此之外，由于 js 不提供指针运算，所以用标记下标的方法代替指针。

### 代码实现

```js
/**
 * 获得栈顶元素
 * @param {Array} stack
 */
function getStackTop(stack) {
  if (!Array.isArray(stack)) {
    return null;
  }

  if (!stack.length) {
    return null;
  }

  return stack[stack.length - 1];
}

/**
 * 第二个参数是否是该栈的弹出顺序
 * @param {Array} pushOrder
 * @param {Array} popOrder
 * @return {Boolean}
 */
function check(pushOrder, popOrder) {
  if (!pushOrder.length || !popOrder.length || pushOrder.length !== popOrder.length) {
    return false;
  }

  const stack = []; // 辅助栈
  let i = 0,
    j = 0; // i: 压入序列指针; j: 弹出序列指针

  while (j < popOrder.length) {
    for (; i < pushOrder.length && popOrder[j] !== getStackTop(stack); ++i) {
      stack.push(pushOrder[i]);
    }

    if (popOrder[j] !== getStackTop(stack)) {
      return false;
    }

    stack.pop();
    ++j;
  }

  return true;
}

/**
 * 以下是测试代码
 */

console.log(check([1, 2, 3, 4], [4, 3, 2, 1]));

console.log(check([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]));

console.log(check([1, 2, 3, 4, 5], [4, 3, 5, 1, 2]));
```

## 32.1 从上往下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7

### 解题思路

使用队列来进行层次遍历。

不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。

```js
/* function TreeNode(x) {
 this.val = x;
 this.left = null;
 this.right = null;
 } */
function PrintFromTopToBottom(root) {
  const queue = [],
    res = [];
  if (root === null) {
    return res;
  }
  queue.push(root);
  while (queue.length) {
    const pRoot = queue.shift();
    if (pRoot.left !== null) {
      queue.push(pRoot.left);
    }
    if (pRoot.right !== null) {
      queue.push(pRoot.right);
    }
    res.push(pRoot.val);
  }
  return res;
}
```

### 思路分析

借助队列这种“先入先出”的线性数据结构即可。每次访问队列中的元素的时候，输出它的值，并且将其非空左右节点放入队列中。直到队列为空，停止输出，结束函数循环即可。

### 代码实现

```js
class TreeNode {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

/**
 * 层级遍历二叉树
 * @param {TreeNode} root
 */
function levelTravel(root) {
  const queue = [root];
  while (queue.length) {
    let first = queue.shift();
    console.log(first.value);

    if (first.left) {
      queue.push(first.left);
    }

    if (first.right) {
      queue.push(first.right);
    }
  }
}

/**
 *
 */

const root = new TreeNode(
  10,
  new TreeNode(6, new TreeNode(4), new TreeNode(8)),
  new TreeNode(14, new TreeNode(12), new TreeNode(16)),
);

levelTravel(root);
```

## 32.2 把二叉树打印成多行

和上题几乎一样。

### 解题思路

```js
function Print(pRoot) {
  const queue = [],
    res = [];
  if (pRoot === null) {
    return res;
  }
  queue.push(pRoot);
  let nextLevel = 0; // 下一层节点个数
  let toBePrinted = 1; // 这一层还有多少个节点要打印
  let list = []; // 存放每一层节点
  while (queue.length) {
    const pNode = queue.shift();
    list.push(pNode.val);
    if (pNode.left !== null) {
      queue.push(pNode.left);
      nextLevel++;
    }
    if (pNode.right !== null) {
      queue.push(pNode.right);
      nextLevel++;
    }
    toBePrinted--;
    if (toBePrinted === 0) {
      res.push(list);
      list = [];
      toBePrinted = nextLevel;
      nextLevel = 0;
    }
  }
  return res;
}
```

## 32.3 按之字形顺序打印二叉树

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

### 解题思路

```js
function Print(pRoot) {
  const lists = [];

  if (pRoot === null) {
    return lists;
  }

  const stack1 = [];
  const stack2 = [];

  stack2.push(pRoot);
  let i = 1;
  while (stack1.length !== 0 || stack2.length !== 0) {
    const list = [];

    // 为奇数层
    if ((i & 1) === 1) {
      while (stack2.length !== 0) {
        const tmp = stack2[stack2.length - 1];
        stack2.pop();
        list.push(tmp.val);
        if (tmp.left !== null) stack1.push(tmp.left);
        if (tmp.right !== null) stack1.push(tmp.right);
      }
    }
    // 为偶数层
    else {
      while (stack1.length !== 0) {
        const tmp = stack1[stack1.length - 1];
        stack1.pop();
        list.push(tmp.val);
        if (tmp.right !== null) stack2.push(tmp.right);
        if (tmp.left !== null) stack2.push(tmp.left);
      }
    }
    ++i;
    lists.push(list);
  }
  return lists;
}
```

## 33. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。

例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。

### 解题思路

```js
// 递归版
function VerifySquenceOfBST(sequence) {
  if (!sequence.length) return false;
  return judge(sequence, 0, sequence.length - 1);
}
function judge(a, l, r) {
  if (l >= r) return true;
  let i = r;
  while (a[i - 1] > a[r] && i > l) i--;
  for (let j = i - 1; j >= l; j--) {
    if (a[j] > a[r]) return false;
  }
  return judge(a, l, i - 1) && judge(a, i, r - 1);
}

// 非递归版
function VerifySquenceOfBST2(sequence) {
  let n = sequence.length,
    i = 0;
  if (!n) return false;
  while (n--) {
    while (sequence[i] < sequence[n]) i++;
    while (sequence[i] > sequence[n]) i++;
    if (i < n) return false;
    i = 0;
  }
  return true;
}
```

### 思路描述

因为是后序遍历，所以根节点是最后一个元素。然后前面序列分为 2 部分，有一部分是左子树，有一部分是右子树。

根据二叉搜索树的性质，左子树的元素一定小于最后一个元素，右子树的元素一定大于最后一个元素。

根据这个思路，一直递归下去即可。只要所有部分都满足二叉搜索树的性质，那么符合条件。

### 代码实现

```js
/**
 * 判断是否是二叉搜索树的后序遍历结果
 * @param {Array} tailOrder 后序遍历顺序
 */
function isBST(tailOrder) {
  // 空序列代表空树, 这里认为是BST
  if (tailOrder.length === 0) {
    return true;
  }

  const length = tailOrder.length;
  let root = tailOrder[length - 1],
    i,
    j;

  // 找到左子树
  for (i = 0; i < length - 1 && tailOrder[i] < root; ++i);
  // 找到右子树
  for (j = i; j < length - 1 && tailOrder[j] > root; ++j);

  // 如果没有遍历完, 说明不是左边部分小，右边部分大的分布
  // 显然，不符合后序遍历的定义
  if (j !== length - 1) {
    return false;
  }

  // 处理左右子树
  let left = isBST(tailOrder.slice(0, i));
  let right = isBST(tailOrder.slice(i, length - 1));

  return left && right;
}

/**
 * 以下是测试代码
 */
console.log(isBST([5, 7, 6, 9, 11, 10, 8]));
console.log(isBST([4, 3, 2, 1]));
console.log(isBST([7, 4, 6, 5]));
```

## 34. 二叉树中和为某一值的路径

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12

### 解题思路

```js
function FindPath(root, expectNumber) {
  const list = [],
    listAll = [];
  return findPath(root, expectNumber, list, listAll);
}
function findPath(root, expectNumber, list, listAll) {
  if (root === null) {
    return listAll;
  }
  list.push(root.val);
  const x = expectNumber - root.val;
  if (root.left === null && root.right === null && x === 0) {
    listAll.push(Array.of(...list));
  }
  findPath(root.left, x, list, listAll);
  findPath(root.right, x, list, listAll);
  list.pop();
  return listAll;
}
```

### 思路分析

1. 每次来到新的节点，记录新节点信息
2. 检查新节点是否是叶子节点，如果是，判断路径上的节点值总和是否符合条件；如果不是，继续递归处理左右子树，回到第 1 步
3. 最后需要将新节点的信息移除

### 代码实现

```js
/**
 * 二叉树结点类
 */
class Node {
  constructor(value = 0, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

/**
 *
 * @param {Node} root
 * @param {Number} target
 */
function findPath(root, target) {
  const paths = []; // 存放所有满足条件的路径
  let sum = 0; // 路径上的节点值的总和

  function _findPath(node, path) {
    if (node === null) {
      return;
    }

    // 把当前节点放入路径中
    sum = sum + node.value;
    path.push(node);

    const isLeaf = node.left === null && node.right === null;

    // 如果是叶节点, 并且路径上的节点和满足条件, 记录这条路径
    if (isLeaf && sum === target) {
      paths.push([...path]);
    }

    // 当前节点有左子树, 向左子树递归
    if (node.left !== null) {
      _findPath(node.left, path);
    }

    // 当前节点有右子树, 向右子树递归
    if (node.right !== null) {
      _findPath(node.right, path);
    }

    // 把当前节点从路径中移除
    sum = sum - node.value;
    path.pop(node);
  }

  _findPath(root, []);
  return paths;
}

/**
 * 以下是测试代码
 */
const root = new Node(1, new Node(2), new Node(3, null, new Node(-1)));

console.log(findPath(root, 3));
```

## 35. 复杂链表的复制

输入一个复杂链表(每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点)，返回结果为复制后复杂链表的 head。

### 解题思路

第一步，在每个节点的后面插入复制的节点。

第二步，对复制节点的 random 链接进行赋值。

第三步，拆分。

```js
// 第一种
function RandomListNode(x) {
  this.label = x;
  this.next = null;
  this.random = null;
}
function Clone(pHead) {
  if (pHead === null) {
    return null;
  }
  const map = new Map();
  let p, p2;
  p = pHead;
  p2 = new RandomListNode(pHead.label);
  const pHead2 = p2;
  map.set(p, p2);
  while (p) {
    if (p.next) p2.next = new RandomListNode(p.next.label);
    else p2.next = null;
    p = p.next;
    p2 = p2.next;
    map.set(p, p2);
  }
  p = pHead;
  p2 = pHead2;
  while (p !== null) {
    p2.random = map.get(p.random);
    p = p.next;
    p2 = p2.next;
  }
  return pHead2;
}

// 第二种
/* function RandomListNode(x){
 this.label = x;
 this.next = null;
 this.random = null;
 }*/
function Clone2(pHead) {
  cloneNodes(pHead);
  connectRandom(pHead);
  return reconnectNodes(pHead);
}
function cloneNodes(pHead) {
  // 复制链表
  let pNode = pHead;
  while (pNode !== null) {
    const newNode = new RandomListNode(pNode.label);
    newNode.next = pNode.next;
    pNode.next = newNode;
    pNode = newNode.next;
  }
}
function connectRandom(pHead) {
  // 设置random指针
  let pNode = pHead;
  while (pNode !== null) {
    if (pNode.random !== null) {
      pNode.next.random = pNode.random.next;
    }
    pNode = pNode.next.next;
  }
}
function reconnectNodes(pHead) {
  // 拆开链表
  let pNode = pHead;
  let newNodeHead = null,
    newNode = null;
  if (pNode !== null) {
    newNodeHead = newNode = pNode.next;
    pNode.next = newNode.next;
    pNode = newNode.next;
  }
  while (pNode !== null) {
    newNode.next = pNode.next;
    newNode = newNode.next;
    pNode.next = newNode.next;
    pNode = pNode.next;
  }
  return newNodeHead;
}
```

### 思路分析

按照正常的思路，首先从头到尾遍历链表，拷贝每个节点的 value 和 next 指针。然后从头再次遍历，第二次遍历的目的在于拷贝每个节点的 sibling 指针。

然而即使找到原节点的 sibling 指针，还是得为了找到复制节点对应的 sibling 指针而再遍历一遍。那么对于 n 个要寻找 sibling 指针的节点，复杂度就是 O(N\*N)。

显然，为了降低复杂度，必须从第二次遍历着手。这里采用的方法是，在第一次遍历的时候，把 `(原节点, 复制节点)` 作为映射保存在表中。那么第二次遍历的时候，就能在 O(1) 的复杂度下立即找到原链上 sibling 指针在复制链上对应的映射。

### 代码分析

```js
class Node {
  constructor(value, next = null, sibling = null) {
    this.value = value;
    this.next = next;
    this.sibling = sibling;
  }
}

/**
 * 复制复杂链表
 * @param {Node} first
 */
function cloneNodes(first) {
  if (!first) {
    return null;
  }

  const map = new Map();

  let copyFirst = new Node(first.value),
    node = first.next, // 被copy链的当前节点
    last = copyFirst; // copy链的当前节点, 此节点相对于被copy链短位移少1位

  map.set(first, copyFirst);

  while (node) {
    last.next = new Node(node.value);
    last = last.next;
    map.set(node, last);
    node = node.next;
  }

  // 第二次遍历, 迁移sibling
  node = first;
  while (node) {
    map.get(node) && (map.get(node).sibling = map.get(node.sibling));
    node = node.next;
  }

  return copyFirst;
}

/**
 * 测试代码
 */
const node1 = new Node('a'),
  node2 = new Node('b'),
  node3 = new Node('c'),
  node4 = new Node('d');

node1.next = node2;
node2.next = node3;
node3.next = node4;

node1.sibling = node3;
node4.sibling = node2;

let copyNode = cloneNodes(node1);
while (copyNode) {
  console.log(copyNode);
  copyNode = copyNode.next;
}
```

## 36. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

### 解题思路

```js
/* function TreeNode(x) {
 this.val = x;
 this.left = null;
 this.right = null;
 } */
function Convert(pRootOfTree) {
  if (pRootOfTree === null) return null;
  let pLast = null;
  pLast = ConvertNode(pRootOfTree, pLast);
  let pHead = pLast;
  while (pHead && pHead.left) {
    pHead = pHead.left;
  }
  return pHead;
}
function ConvertNode(pNode, pLast) {
  if (pNode === null) return;
  if (pNode.left) {
    pLast = ConvertNode(pNode.left, pLast);
  }
  pNode.left = pLast;
  if (pLast) {
    pLast.right = pNode;
  }
  pLast = pNode;
  if (pNode.right) {
    pLast = ConvertNode(pNode.right, pLast);
  }
  return pLast;
}
```

### 思路分析

在搜索二叉树中，左子结点的值总是小于父结点的值，右子结点的值总是大于父结点的值。因此我们在转换成排序双向链表时，**原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点指针**。

因为要遍历树，所以要选取遍历算法。**为了保证遍历的有序性，采用中序遍历**。在 convertNode 函数实现中，注意 lastNodeInList 语意，剩下的按照思路写出来即可。

### 代码实现

```js
class TreeNode {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

/**
 * 将node和左右子树转化为双向链表
 * @param {TreeNode} node 待转化的节点
 * @param {TreeNode} lastNodeInList 已转换好的双向链表的尾结点
 */
function convertNode(node, lastNodeInList = null) {
  if (!node) {
    return null;
  }

  // 先处理左子树
  if (node.left) {
    lastNodeInList = convertNode(node.left, lastNodeInList);
  }

  // 将当前节点与原双向链表拼接
  node.left = lastNodeInList;
  if (lastNodeInList) {
    lastNodeInList.right = node;
  }

  // 处理右子树
  lastNodeInList = node;
  if (node.right) {
    lastNodeInList = convertNode(node.right, lastNodeInList);
  }

  // 返回新链表的尾节点
  return lastNodeInList;
}

/**
 *
 * @param {TreeNode} root
 */
function convertTreeToList(root) {
  let lastNodeInList = convertNode(root);
  let headOfList = lastNodeInList;
  // 返回转化好的双向链表的头节点
  while (headOfList && headOfList.left) {
    headOfList = headOfList.left;
  }
  return headOfList;
}

/**
 * 测试代码
 */

const root = new TreeNode(
  10,
  new TreeNode(6, new TreeNode(4), new TreeNode(8)),
  new TreeNode(14, new TreeNode(12), new TreeNode(16)),
);

let nodeOfList = convertTreeToList(root);
while (nodeOfList) {
  console.log(nodeOfList.value);
  nodeOfList = nodeOfList.right;
}
```

## 37. 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

### 解题思路

```js
const arr = [];
function Serialize(pRoot) {
  if (pRoot === null) {
    arr.push('a');
  } else {
    arr.push(pRoot.val);
    Serialize(pRoot.left);
    Serialize(pRoot.right);
  }
}
function Deserialize() {
  let node = null;
  if (arr.length < 1) {
    return null;
  }
  const number = arr.shift();
  if (typeof number === 'number') {
    node = new TreeNode(number);
    node.left = Deserialize();
    node.right = Deserialize();
  }
  return node;
}
```

## 38. 字符串的全排列

输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。

### 解题思路

把集合看成 2 个部分，第一部分是第一个元素，第二部分是后面剩余元素。所有字符都要与当前集合的第一个元素交换，交换后的元素是固定的，也就是一种情况。

每次交换，都继续处理后面剩余元素，它们又可以分成 2 部分，和之前讲述的一样。就这样一直递归下去，直到最后一个元素，那么就排出了其中一种情况。所有情况放在一起，就是全排列的结果。

```js
/**
 * 交换数组指定坐标的2个元素
 * @param {Array} arr
 * @param {Number} i
 * @param {Number} j
 */
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}

/**
 * 检测arr[start, end)中, 是否有和arr[end]相等的元素
 * @param {Array} arr
 * @param {Number} start
 * @param {Number} end
 */
function check(arr, start, end) {
  for (let i = start; i < end; ++i) {
    if (arr[end] === arr[i]) {
      return false;
    }
  }
  return true;
}

/**
 * 全排列
 * @param {Array} arr 元素集合
 * @param {Number} n 起始位置
 */
function perm(arr = [], n = 0) {
  const length = arr.length;
  if (length === n) {
    console.log(arr.join(' '));
    return;
  }

  for (let i = n; i < length; ++i) {
    if (check(arr, n, i)) {
      swap(arr, n, i);
      perm(arr, n + 1);
      swap(arr, n, i);
    }
  }
}

/**
 * 测试代码
 */
perm(['a', 'b', 'c'], 0);
console.log('*'.repeat(10));
perm(['a', 'b', 'b'], 0);
```

```js
var permutation = function(s) {
  let res = [];
  if (s.length <= 0) return res;
  arr = s.split(''); // 将字符串转化为字符数组
  res = permutate(arr, 0, res);
  res = [...new Set(res)]; // 去重
  res.sort(); // 排序
  return res;
};
function permutate(arr, index, res) {
  if (arr.length === index) {
    return res.push(arr.join(''));
  }
  for (let i = index; i < arr.length; i++) {
    [arr[index], arr[i]] = [arr[i], arr[index]]; // 交换
    permutate(arr, index + 1, res);
    [arr[index], arr[i]] = [arr[i], arr[index]]; // 交换
  }

  return res;
}
```

```js
// 回溯法
function Permutation(str) {
  let res = [];
  const pStr = '';
  if (str.length <= 0) return res;
  arr = str.split(''); // 将字符串转化为字符数组
  res = permutate(arr, pStr, res);
  return res;
}
function permutate(arr, pStr, res) {
  if (arr.length === 0) {
    return res.push(pStr);
  }
  const isRepeated = new Set();
  for (let i = 0; i < arr.length; i++) {
    if (!isRepeated.has(arr[i])) {
      // 避免相同的字符交换
      const char = arr.splice(i, 1)[0];
      pStr += char;
      permutate(arr, pStr, res);
      arr.splice(i, 0, char); // 恢复字符串，回溯
      pStr = pStr.slice(0, pStr.length - 1); // 回溯
      isRepeated.add(char);
    }
  }

  return res;
}

// 递归全排列法
function Permutation2(str) {
  let res = [];
  if (str.length <= 0) return res;
  arr = str.split(''); // 将字符串转化为字符数组
  res = permutate2(arr, 0, res);
  res = [...new Set(res)]; // 去重
  res.sort(); // 排序
  return res;
}
function permutate2(arr, index, res) {
  if (arr.length === index) {
    return res.push(arr.join(''));
  }
  for (let i = index; i < arr.length; i++) {
    [arr[index], arr[i]] = [arr[i], arr[index]]; // 交换
    permutate2(arr, index + 1, res);
    [arr[index], arr[i]] = [arr[i], arr[index]]; // 交换
  }

  return res;
}
```

### 思路分析

把集合看成 2 个部分，第一部分是第一个元素，第二部分是后面剩余元素。所有字符都要与当前集合的第一个元素交换，交换后的元素是固定的，也就是一种情况。

每次交换，都继续处理后面剩余元素，它们又可以分成 2 部分，和之前讲述的一样。就这样一直递归下去，直到最后一个元素，那么就排出了其中一种情况。所有情况放在一起，就是全排列的结果。

### 代码实现

```js
/**
 * 交换数组指定坐标的2个元素
 * @param {Array} arr
 * @param {Number} i
 * @param {Number} j
 */
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}

/**
 * 检测arr[start, end)中, 是否有和arr[end]相等的元素
 * @param {Array} arr
 * @param {Number} start
 * @param {Number} end
 */
function check(arr, start, end) {
  for (let i = start; i < end; ++i) {
    if (arr[end] === arr[i]) {
      return false;
    }
  }
  return true;
}

/**
 * 全排列
 * @param {Array} arr 元素集合
 * @param {Number} n 起始位置
 */
function perm(arr = [], n = 0) {
  const length = arr.length;
  if (length === n) {
    console.log(arr.join(' '));
    return;
  }

  for (let i = n; i < length; ++i) {
    if (check(arr, n, i)) {
      swap(arr, n, i);
      perm(arr, n + 1);
      swap(arr, n, i);
    }
  }
}

/**
 * 测试代码
 */
perm(['a', 'b', 'c'], 0);
console.log('*'.repeat(10));
perm(['a', 'b', 'b'], 0);
```

## 39. 数组中出现次数超过一半的数字

### 解题思路

多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。

使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。

```js
// 第一种
function MoreThanHalfNumSolution(numbers) {
  const left = 0,
    right = numbers.length - 1;
  let key = partition(numbers, left, right);
  const mid = numbers.length >> 1;
  while (key !== mid) {
    if (key > mid) {
      key = partition(numbers, left, key - 1);
    } else {
      key = partition(numbers, key + 1, right);
    }
  }
  let res = numbers[mid];
  if (!checkMoreThanHalf(numbers, res)) {
    res = 0;
  }
  return res;
}
function partition(a, left, right) {
  const key = a[left]; // 一开始让key为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把key现在所在的下标返回
}
function checkMoreThanHalf(numbers, num) {
  let times = 0;
  for (let i = 0; i < numbers.length; i++) {
    if (num === numbers[i]) {
      times++;
    }
  }
  if (times * 2 <= numbers.length) {
    return false;
  }
  return true;
}

// 第二种
function MoreThanHalfNumSolution2(numbers) {
  let res = numbers[0],
    times = 1;
  for (let i = 0; i < numbers.length; i++) {
    if (times === 0) {
      res = numbers[i];
      times = 1;
    } else if (numbers[i] === res) {
      times++;
    } else {
      times--;
    }
  }
  if (!checkMoreThanHalf(numbers, res)) {
    res = 0;
  }
  return res;
}
function checkMoreThanHalf2(numbers, num) {
  let times = 0;
  for (let i = 0; i < numbers.length; i++) {
    if (num === numbers[i]) {
      times++;
    }
  }
  if (times * 2 <= numbers.length) {
    return false;
  }
  return true;
}
```

### 思路分析

数组中有一个数字出现的次数超过数组长度的一半，**说明它出现的次数比其他所有数字出现次数的和还要多**。

在遍历的过程中保存两个变量：一个数字 + 一个次数。遍历到每个元素都会更新次数，元素 = 数字，加次数；否则，减次数；如果次数为 0，当前元素赋值给数字。

需要注意的是，最后结果不一定符合条件，比如数组 `[1, 2, 3]`，结果是 3。所以要再统计一下最后数字的次数，是否有一半那么多。

### 代码

```js
// 检查指定元素的次数是否大于等于长度一半
function checkMoreThanHalf(nums = [], target) {
  let times = 0;
  nums.forEach(num => num === target && ++times);
  return times * 2 >= nums.length;
}

// 计算出数组元素
function moreThanHalfNum(nums = []) {
  if (!Array.isArray(nums) || !nums.length) {
    return null;
  }

  let times = 1,
    result = nums[0];
  for (let i = 1; i < nums.length; ++i) {
    if (times === 0) {
      times = 1;
      result = nums[i];
    } else if (result === nums[i]) {
      ++times;
    } else {
      --times;
    }
  }

  return checkMoreThanHalf(nums, result) ? result : null;
}

/**
 * 以下是测试代码
 */

console.log(moreThanHalfNum([3, 1, 3, 2, 2])); // output: null
console.log(moreThanHalfNum([1, 2, 3, 2, 2, 2, 5, 4, 2])); // output: 2
```
