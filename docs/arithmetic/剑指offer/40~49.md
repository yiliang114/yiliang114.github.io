---
layout: CustomPages
title: 前端与数据结构-剑指 offer 40-49
date: 2020-11-14
aside: false
draft: true
---

<!-- GFM-TOC -->

- [40. 最小的 K 个数](#40-最小的-k-个数)
  - [快速选择](#快速选择)
  - [大小为 K 的最小堆](#大小为-k-的最小堆)
  - [思路分析](#思路分析)
  - [代码实现](#代码实现)
- [41.1 数据流中的中位数](#411-数据流中的中位数)
  - [解题思路](#解题思路)
- [41.2 字符流中第一个不重复的字符](#412-字符流中第一个不重复的字符)
  - [解题思路](#解题思路-1)
- [42. 连续子数组的最大和](#42-连续子数组的最大和)
  - [解题思路](#解题思路-2)
- [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
  - [解题思路](#解题思路-3)
- [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
  - [解题思路](#解题思路-4)
- [45. 把数组排成最小的数](#45-把数组排成最小的数)
  - [解题思路](#解题思路-5)
  - [思路分析](#思路分析-1)
  - [代码实现](#代码实现-1)
- [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
  - [解题思路](#解题思路-6)
- [47. 礼物的最大价值](#47-礼物的最大价值)
  - [解题思路](#解题思路-7)
- [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
  - [解题思路](#解题思路-8)
- [49. 丑数](#49-丑数)
  - [解题思路](#解题思路-9)
    - [2.1 思路一](#21-思路一)
    - [2.2 思路二](#22-思路二)
  - [代码](#代码)
    - [3.1 思路一实现](#31-思路一实现)
    - [3.2 思路二实现](#32-思路二实现)
      <!-- GFM-TOC -->

## 40. 最小的 K 个数

### 快速选择

- 复杂度：O(N) + O(1)
- 只有当允许修改数组元素时才可以使用

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。

```js
function GetLeastNumbersSolution(input, k) {
  if (input.length === 0 || k > input.length || k < 1) return [];
  const left = 0,
    right = input.length - 1;
  let key = partition(input, left, right);
  while (key !== k - 1) {
    if (key > k - 1) {
      key = partition(input, left, key - 1);
    } else {
      key = partition(input, key + 1, right);
    }
  }
  const res = input.slice(0, key + 1);
  res.sort((a, b) => a - b);
  return res;
}
function partition(a, left, right) {
  const key = a[left]; // 一开始让key为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把key现在所在的下标返回
}
```

### 大小为 K 的最小堆

- 复杂度：O(NlogK) + O(K)
- 特别适合处理海量数据

应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。

维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    if (k > nums.length || k <= 0)
        return new ArrayList<>();
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);
    for (int num : nums) {
        maxHeap.add(num);
        if (maxHeap.size() > k)
            maxHeap.poll();
    }
    return new ArrayList<>(maxHeap);
}
```

### 思路分析

利用“快速排序”的中的 partition 操作：返回 index，小于 index 对应元素的元素都放在了左边，大于 index 对应元素的元素都放在右边。

利用这个特性，只要我们的 partition 返回值是 k - 1，那么数组中前 k 个元素已经被摆放到了正确位置，直接遍历输出即可。

由于不需要排序全部，整体的时间复杂度是 O(N)。但美中不足的是：要在原数组操作，除非用 O(N)的空间来做拷贝。除此之外，针对海量动态增加的数据，也不能很好处理。这种情况需要用到“最大堆”，请前往《堆》章节查看。

### 代码实现

```js
function partiton(arr = [], start, end) {
  const length = arr.length;
  if (!length) {
    return null;
  }

  let v = arr[start],
    left = start + 1,
    right = end;

  while (1) {
    while (left <= end && arr[left] <= v) ++left;
    while (right >= start + 1 && arr[right] >= v) --right;

    if (left >= right) {
      break;
    }

    [arr[left], arr[right]] = [arr[right], arr[left]];
    ++left;
    --right;
  }

  [arr[right], arr[start]] = [arr[start], arr[right]];
  return right;
}

function getKthNumbers(nums = [], k) {
  if (k <= 0) {
    return null;
  }

  const length = nums.length;
  const result = new Array(k);
  let start = 0,
    end = length - 1;
  let index = partiton(nums, start, end);
  while (index !== k - 1) {
    if (index > k - 1) {
      // 前k个元素在 [start, index] 下标范围内
      // 要进一步处理，缩小区间
      end = index - 1;
      index = partiton(nums, start, end);
    } else {
      // [start, index]都属于小于k的元素，但不是全部
      // 剩下要处理的区间是 [index + 1, end]
      start = index + 1;
      index = partiton(nums, start, end);
    }
  }

  for (let i = 0; i < k; ++i) {
    result[i] = nums[i];
  }

  return result;
}

/**
 * 以下是测试代码
 */

console.log(getKthNumbers([4, 5, 1, 6, 2, 7, 3, 8], 4)); // output: [2, 3, 1, 4]
console.log(getKthNumbers([10, 2], 1));
```

## 41.1 数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

### 解题思路

```js
const array = [];
function Insert(num) {
  array.push(num);
  for (let i = array.length - 2; array[i] > num; i--) {
    [array[i], array[i + 1]] = [array[i + 1], array[i]];
  }
}
function GetMedian() {
  if (array.length & (1 === 1)) {
    return array[(array.length - 1) / 2];
  }
  return (array[array.length / 2] + array[array.length / 2 - 1]) / 2;
}
```

## 41.2 字符流中第一个不重复的字符

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。

### 解题思路

```js
let map = {};
function Init() {
  map = {};
}
function Insert(ch) {
  if (map[ch]) {
    map[ch] += 1;
  } else {
    map[ch] = 1;
  }
}
function FirstAppearingOnce() {
  for (const i in map) {
    if (map[i] === 1) {
      return i;
    }
  }
  return '#';
}
```

## 42. 连续子数组的最大和

{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8(从第 0 个开始，到第 3 个为止)。

### 解题思路

```js
function findGreatestSumOfSubArray(array) {
  if (array.length <= 0) return 0;
  let sum = array[0],
    max = array[0];
  for (let i = 1; i < array.length; i++) {
    if (sum < 0) sum = array[i];
    else sum = sum + array[i];
    if (sum > max) max = sum;
  }
  return max;
}
```

## 43. 从 1 到 n 整数中 1 出现的次数

### 解题思路

```js
// 暴力解法
function NumberOf1Between1AndNSolution(n) {
  let ones = 0;
  for (let i = 0; i <= n; i++) {
    let num = i;
    while (num) {
      if (num % 10 === 1) {
        ones++;
      }
      num = ~~(num / 10);
    }
  }
  return ones;
}

// 优化版
function NumberOf1Between1AndNSolution2(n) {
  if (n <= 0) return 0;
  let count = 0;
  for (let i = 1; i <= n; i *= 10) {
    const a = ~~(n / i),
      b = n % i;
    count = count + ~~((a + 8) / 10) * i + (a % 10 === 1) * (b + 1);
  }
  return count;
}
```

> [LeetCode : 233. Number of Digit One](<https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython>)

## 44. 数字序列中的某一位数字

数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。

### 解题思路

```java
public int getDigitAtIndex(int index) {
    if (index < 0)
        return -1;
    int place = 1;  // 1 表示个位，2 表示 十位...
    while (true) {
        int amount = getAmountOfPlace(place);
        int totalAmount = amount * place;
        if (index < totalAmount)
            return getDigitAtIndex(index, place);
        index -= totalAmount;
        place++;
    }
}

/**
 * place 位数的数字组成的字符串长度
 * 10, 90, 900, ...
 */
private int getAmountOfPlace(int place) {
    if (place == 1)
        return 10;
    return (int) Math.pow(10, place - 1) * 9;
}

/**
 * place 位数的起始数字
 * 0, 10, 100, ...
 */
private int getBeginNumberOfPlace(int place) {
    if (place == 1)
        return 0;
    return (int) Math.pow(10, place - 1);
}

/**
 * 在 place 位数组成的字符串中，第 index 个数
 */
private int getDigitAtIndex(int index, int place) {
    int beginNumber = getBeginNumberOfPlace(place);
    int shiftNumber = index / place;
    String number = (beginNumber + shiftNumber) + "";
    int count = index % place;
    return number.charAt(count) - '0';
}
```

## 45. 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。

### 解题思路

可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。

```js
function PrintMinNumber(numbers) {
  numbers.sort(function(s1, s2) {
    const c1 = `${s1}${s2}`;
    const c2 = `${s2}${s1}`;
    return c1 > c2;
  });
  let min = '';
  numbers.forEach(i => (min += i));
  return min;
}
```

### 思路分析

因为涉及拼接，所以可以将其看做字符串，同时规避了大数溢出的问题，而且字符串的比较规则和数字相同。

借助自定义排序，可以快速比较两个数的大小。比如只看{3, 32}这两个数字。它们可以拼接成 332 和 323，按照题目要求，这里应该取 323。也就是说，此处自定义函数应该返回-1。

### 代码实现

```js
/**
 *
 * @param {Array} numbers
 */
function printMinNumber(numbers) {
  numbers.sort((x, y) => {
    const s1 = x + '' + y,
      s2 = y + '' + x;

    if (s1 < s2) return -1;
    if (s1 > s2) return 1;
    return 0;
  });

  console.log(numbers.join(''));
}

/**
 * 测试代码
 */

printMinNumber([3, 32, 321]);
```

## 46. 把数字翻译成字符串

[LeetCode](https://leetcode.com/problems/decode-ways/description/)

给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。

### 解题思路

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0)
        return 0;
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i <= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0)
            dp[i] += dp[i - 1];
        if (s.charAt(i - 2) == '0')
            continue;
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
}
```

## 47. 礼物的最大价值

在一个 m\*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值(大于 0)。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘

```
1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
```

礼物的最大价值为 1+12+5+7+7+16+5=53。

### 解题思路

应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。

```java
public int getMost(int[][] values) {
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) {
        dp[0] += value[0];
        for (int i = 1; i < n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    }
    return dp[n - 1];
}
```

## 48. 最长不含重复字符的子字符串

输入一个字符串(只包含 a\~z 的字符)，求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。

### 解题思路

```java
public int longestSubStringWithoutDuplication(String str) {
    int curLen = 0;
    int maxLen = 0;
    int[] preIndexs = new int[26];
    Arrays.fill(preIndexs, -1);
    for (int curI = 0; curI < str.length(); curI++) {
        int c = str.charAt(curI) - 'a';
        int preI = preIndexs[c];
        if (preI == -1 || curI - preI > curLen) {
            curLen++;
        } else {
            maxLen = Math.max(maxLen, curLen);
            curLen = curI - preI;
        }
        preIndexs[c] = curI;
    }
    maxLen = Math.max(maxLen, curLen);
    return maxLen;
}
```

## 49. 丑数

把只包含因子 2、3 和 5 的数称作丑数(Ugly Number)。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。

### 解题思路

#### 2.1 思路一

根据定义，将给定的数不断除 2、3、5，看看能不能除尽即可。然后从 1 遍历到 1500。

#### 2.2 思路二

前面速度慢是因为计算了太多非丑数。根据丑数定义，**每一个丑数都是根据前面一个丑数乘以 2、3 或者 5 得到的**。

在确保顺序的情况下，逐步计算即可。

### 代码

#### 3.1 思路一实现

```js
// 判断是否符合丑数定义
function isUgly(number) {
  while (number % 2 === 0) {
    number /= 2;
  }
  while (number % 3 === 0) {
    number /= 3;
  }
  while (number % 5 === 0) {
    number /= 5;
  }
  return number === 1;
}

// 找出 [1, index) 之中的所有丑数
function getUglyNumber(index) {
  if (index <= 0) return 0;

  let number = 0,
    uglyFound = 0;

  while (uglyFound < index) {
    ++number;
    if (isUgly(number)) {
      ++uglyFound;
    }
  }

  return number;
}
```

#### 3.2 思路二实现

```js
function getUglyNumber(index) {
  if (index <= 0) return 0;

  const uglyNum = [1]; // 存放丑数
  // 2，3，5 三个因子各自的指针
  let pointer2 = 0,
    pointer3 = 0,
    pointer5 = 0;

  for (let i = 1; i < index; ++i) {
    // 找出下一个丑数，确保顺序
    uglyNum[i] = Math.min(uglyNum[pointer2] * 2, uglyNum[pointer3] * 3, uglyNum[pointer5] * 5);
    // 如果结果相同，移动指针，防止下次重复计算
    if (uglyNum[i] == uglyNum[pointer2] * 2) ++pointer2;
    if (uglyNum[i] == uglyNum[pointer3] * 3) ++pointer3;
    if (uglyNum[i] == uglyNum[pointer5] * 5) ++pointer5;
  }

  return uglyNum[index - 1];
}

/**
 * 测试代码
 */

console.log(getUglyNumber(1500)); // 859963392
```

```js
function GetUglyNumberSolution(index) {
  if (index < 7) return index;
  const res = [];
  res[0] = 1;
  let t2 = 0,
    t3 = 0,
    t5 = 0;
  for (let i = 1; i < index; i++) {
    res[i] = Math.min(res[t2] * 2, ress[t3] * 3, res[t5] * 5);
    if (res[i] === res[t2] * 2) t2++;
    if (res[i] === res[t3] * 3) t3++;
    if (res[i] === res[t5] * 5) t5++;
  }
  return res[index - 1];
}
```
