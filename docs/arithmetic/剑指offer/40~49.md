---
layout: CustomPages
title: 前端与数据结构-剑指 offer 40-49
date: 2020-11-14
aside: false
draft: true
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [40. 最小的 K 个数](#40-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
    - [快速选择](#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9)
    - [大小为 K 的最小堆](#%E5%A4%A7%E5%B0%8F%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A0%86)
- [41.1 数据流中的中位数](#411-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1)
- [41.2 字符流中第一个不重复的字符](#412-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2)
- [42. 连续子数组的最大和](#42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3)
- [43. 从 1 到 n 整数中 1 出现的次数](#43-%E4%BB%8E-1-%E5%88%B0-n-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4)
- [44. 数字序列中的某一位数字](#44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5)
- [45. 把数组排成最小的数](#45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6)
- [46. 把数字翻译成字符串](#46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7)
- [47. 礼物的最大价值](#47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8)
- [48. 最长不含重复字符的子字符串](#48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9)
- [49. 丑数](#49-%E4%B8%91%E6%95%B0)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<!-- GFM-TOC -->

- [40. 最小的 K 个数](#40-最小的-k-个数)
  - [解题思路](#解题思路)
    - [快速选择](#快速选择)
    - [大小为 K 的最小堆](#大小为-k-的最小堆)
  - [2. 思路分析](#2-思路分析)
  - [3. 代码实现](#3-代码实现)
- [41.1 数据流中的中位数](#411-数据流中的中位数)
  - [题目描述](#题目描述)
  - [解题思路](#解题思路-1)
- [41.2 字符流中第一个不重复的字符](#412-字符流中第一个不重复的字符)
  - [题目描述](#题目描述-1)
  - [解题思路](#解题思路-2)
- [42. 连续子数组的最大和](#42-连续子数组的最大和)
  - [题目描述](#题目描述-2)
  - [解题思路](#解题思路-3)
- [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
  - [解题思路](#解题思路-4)
- [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
  - [题目描述](#题目描述-3)
  - [解题思路](#解题思路-5)
- [45. 把数组排成最小的数](#45-把数组排成最小的数)
  - [题目描述](#题目描述-4)
  - [解题思路](#解题思路-6)
  - [2. 思路分析](#2-思路分析-1)
  - [3. 代码实现](#3-代码实现-1)
- [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
  - [题目描述](#题目描述-5)
  - [解题思路](#解题思路-7)
- [47. 礼物的最大价值](#47-礼物的最大价值)
  - [题目描述](#题目描述-6)
  - [解题思路](#解题思路-8)
- [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
  - [题目描述](#题目描述-7)
  - [解题思路](#解题思路-9)
- [49. 丑数](#49-丑数)
  - [题目描述](#题目描述-8)
  - [解题思路](#解题思路-10)
  - [2. 解题思路](#2-解题思路)
    - [2.1 思路一](#21-思路一)
    - [2.2 思路二](#22-思路二)
  - [3. 代码](#3-代码)
    - [3.1 思路一实现](#31-思路一实现)
    - [3.2 思路二实现](#32-思路二实现)
    <!-- GFM-TOC -->

# 40. 最小的 K 个数

## 解题思路

### 快速选择

- 复杂度：O(N) + O(1)
- 只有当允许修改数组元素时才可以使用

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (k > nums.length || k <= 0)
        return ret;
    findKthSmallest(nums, k - 1);
    /* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */
    for (int i = 0; i < k; i++)
        ret.add(nums[i]);
    return ret;
}

public void findKthSmallest(int[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int j = partition(nums, l, h);
        if (j == k)
            break;
        if (j > k)
            h = j - 1;
        else
            l = j + 1;
    }
}

private int partition(int[] nums, int l, int h) {
    int p = nums[l];     /* 切分元素 */
    int i = l, j = h + 1;
    while (true) {
        while (i != h && nums[++i] < p) ;
        while (j != l && nums[--j] > p) ;
        if (i >= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

```js
function GetLeastNumbersSolution(input, k) {
  if (input.length === 0 || k > input.length || k < 1) return [];
  const left = 0,
    right = input.length - 1;
  let key = partition(input, left, right);
  while (key !== k - 1) {
    if (key > k - 1) {
      key = partition(input, left, key - 1);
    } else {
      key = partition(input, key + 1, right);
    }
  }
  const res = input.slice(0, key + 1);
  res.sort((a, b) => a - b);
  return res;
}
function partition(a, left, right) {
  const key = a[left]; // 一开始让key为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把key现在所在的下标返回
}
```

### 大小为 K 的最小堆

- 复杂度：O(NlogK) + O(K)
- 特别适合处理海量数据

应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。

维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {
    if (k > nums.length || k <= 0)
        return new ArrayList<>();
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);
    for (int num : nums) {
        maxHeap.add(num);
        if (maxHeap.size() > k)
            maxHeap.poll();
    }
    return new ArrayList<>(maxHeap);
}
```

## 2. 思路分析

利用“快速排序”的中的 partition 操作：返回 index，小于 index 对应元素的元素都放在了左边，大于 index 对应元素的元素都放在右边。

利用这个特性，只要我们的 partition 返回值是 k - 1，那么数组中前 k 个元素已经被摆放到了正确位置，直接遍历输出即可。

由于不需要排序全部，整体的时间复杂度是 O(N)。但美中不足的是：要在原数组操作，除非用 O(N)的空间来做拷贝。除此之外，针对海量动态增加的数据，也不能很好处理。这种情况需要用到“最大堆”，请前往《堆》章节查看。

## 3. 代码实现

```js
function partiton(arr = [], start, end) {
  const length = arr.length;
  if (!length) {
    return null;
  }

  let v = arr[start],
    left = start + 1,
    right = end;

  while (1) {
    while (left <= end && arr[left] <= v) ++left;
    while (right >= start + 1 && arr[right] >= v) --right;

    if (left >= right) {
      break;
    }

    [arr[left], arr[right]] = [arr[right], arr[left]];
    ++left;
    --right;
  }

  [arr[right], arr[start]] = [arr[start], arr[right]];
  return right;
}

function getKthNumbers(nums = [], k) {
  if (k <= 0) {
    return null;
  }

  const length = nums.length;
  const result = new Array(k);
  let start = 0,
    end = length - 1;
  let index = partiton(nums, start, end);
  while (index !== k - 1) {
    if (index > k - 1) {
      // 前k个元素在 [start, index] 下标范围内
      // 要进一步处理，缩小区间
      end = index - 1;
      index = partiton(nums, start, end);
    } else {
      // [start, index]都属于小于k的元素，但不是全部
      // 剩下要处理的区间是 [index + 1, end]
      start = index + 1;
      index = partiton(nums, start, end);
    }
  }

  for (let i = 0; i < k; ++i) {
    result[i] = nums[i];
  }

  return result;
}

/**
 * 以下是测试代码
 */

console.log(getKthNumbers([4, 5, 1, 6, 2, 7, 3, 8], 4)); // output: [2, 3, 1, 4]
console.log(getKthNumbers([10, 2], 1));
```

# 41.1 数据流中的中位数

## 题目描述

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

## 解题思路

```java
/* 大顶堆，存储左半边元素 */
private PriorityQueue<Integer> left = new PriorityQueue<>((o1, o2) -> o2 - o1);
/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */
private PriorityQueue<Integer> right = new PriorityQueue<>();
/* 当前数据流读入的元素个数 */
private int N = 0;

public void Insert(Integer val) {
    /* 插入要保证两个堆存于平衡状态 */
    if (N % 2 == 0) {
        /* N 为偶数的情况下插入到右半边。
         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，
         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */
        left.add(val);
        right.add(left.poll());
    } else {
        right.add(val);
        left.add(right.poll());
    }
    N++;
}

public Double GetMedian() {
    if (N % 2 == 0)
        return (left.peek() + right.peek()) / 2.0;
    else
        return (double) right.peek();
}
```

```js
const array = [];
function Insert(num) {
  array.push(num);
  for (let i = array.length - 2; array[i] > num; i--) {
    [array[i], array[i + 1]] = [array[i + 1], array[i]];
  }
}
function GetMedian() {
  if (array.length & (1 === 1)) {
    return array[(array.length - 1) / 2];
  }
  return (array[array.length / 2] + array[array.length / 2 - 1]) / 2;
}
```

# 41.2 字符流中第一个不重复的字符

## 题目描述

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。

## 解题思路

```java
private int[] cnts = new int[256];
private Queue<Character> queue = new LinkedList<>();

public void Insert(char ch) {
    cnts[ch]++;
    queue.add(ch);
    while (!queue.isEmpty() && cnts[queue.peek()] > 1)
        queue.poll();
}

public char FirstAppearingOnce() {
    return queue.isEmpty() ? '#' : queue.peek();
}
```

```js
let map = {};
function Init() {
  map = {};
}
function Insert(ch) {
  if (map[ch]) {
    map[ch] += 1;
  } else {
    map[ch] = 1;
  }
}
function FirstAppearingOnce() {
  for (const i in map) {
    if (map[i] === 1) {
      return i;
    }
  }
  return '#';
}
```

# 42. 连续子数组的最大和

## 题目描述

{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8(从第 0 个开始，到第 3 个为止)。

## 解题思路

```java
public int FindGreatestSumOfSubArray(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    int greatestSum = Integer.MIN_VALUE;
    int sum = 0;
    for (int val : nums) {
        sum = sum <= 0 ? val : sum + val;
        greatestSum = Math.max(greatestSum, sum);
    }
    return greatestSum;
}
```

```js
function FindGreatestSumOfSubArray(array) {
  if (array.length <= 0) return 0;
  let sum = array[0],
    max = array[0];
  for (let i = 1; i < array.length; i++) {
    if (sum < 0) sum = array[i];
    else sum = sum + array[i];
    if (sum > max) max = sum;
  }
  return max;
}
```

# 43. 从 1 到 n 整数中 1 出现的次数

## 解题思路

```java
public int NumberOf1Between1AndN_Solution(int n) {
    int cnt = 0;
    for (int m = 1; m <= n; m *= 10) {
        int a = n / m, b = n % m;
        cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
    }
    return cnt;
}
```

```js
// 暴力解法
function NumberOf1Between1AndNSolution(n) {
  let ones = 0;
  for (let i = 0; i <= n; i++) {
    let num = i;
    while (num) {
      if (num % 10 === 1) {
        ones++;
      }
      num = ~~(num / 10);
    }
  }
  return ones;
}

// 优化版
function NumberOf1Between1AndNSolution2(n) {
  if (n <= 0) return 0;
  let count = 0;
  for (let i = 1; i <= n; i *= 10) {
    const a = ~~(n / i),
      b = n % i;
    count = count + ~~((a + 8) / 10) * i + (a % 10 === 1) * (b + 1);
  }
  return count;
}
```

> [LeetCode : 233. Number of Digit One](<https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython>)

# 44. 数字序列中的某一位数字

## 题目描述

数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。

## 解题思路

```java
public int getDigitAtIndex(int index) {
    if (index < 0)
        return -1;
    int place = 1;  // 1 表示个位，2 表示 十位...
    while (true) {
        int amount = getAmountOfPlace(place);
        int totalAmount = amount * place;
        if (index < totalAmount)
            return getDigitAtIndex(index, place);
        index -= totalAmount;
        place++;
    }
}

/**
 * place 位数的数字组成的字符串长度
 * 10, 90, 900, ...
 */
private int getAmountOfPlace(int place) {
    if (place == 1)
        return 10;
    return (int) Math.pow(10, place - 1) * 9;
}

/**
 * place 位数的起始数字
 * 0, 10, 100, ...
 */
private int getBeginNumberOfPlace(int place) {
    if (place == 1)
        return 0;
    return (int) Math.pow(10, place - 1);
}

/**
 * 在 place 位数组成的字符串中，第 index 个数
 */
private int getDigitAtIndex(int index, int place) {
    int beginNumber = getBeginNumberOfPlace(place);
    int shiftNumber = index / place;
    String number = (beginNumber + shiftNumber) + "";
    int count = index % place;
    return number.charAt(count) - '0';
}
```

# 45. 把数组排成最小的数

## 题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。

## 解题思路

可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。

```java
public String PrintMinNumber(int[] numbers) {
    if (numbers == null || numbers.length == 0)
        return "";
    int n = numbers.length;
    String[] nums = new String[n];
    for (int i = 0; i < n; i++)
        nums[i] = numbers[i] + "";
    Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
    String ret = "";
    for (String str : nums)
        ret += str;
    return ret;
}
```

```js
function PrintMinNumber(numbers) {
  numbers.sort(function(s1, s2) {
    const c1 = `${s1}${s2}`;
    const c2 = `${s2}${s1}`;
    return c1 > c2;
  });
  let min = '';
  numbers.forEach(i => (min += i));
  return min;
}
```

## 2. 思路分析

因为涉及拼接，所以可以将其看做字符串，同时规避了大数溢出的问题，而且字符串的比较规则和数字相同。

借助自定义排序，可以快速比较两个数的大小。比如只看{3, 32}这两个数字。它们可以拼接成 332 和 323，按照题目要求，这里应该取 323。也就是说，此处自定义函数应该返回-1。

## 3. 代码实现

```js
/**
 *
 * @param {Array} numbers
 */
function printMinNumber(numbers) {
  numbers.sort((x, y) => {
    const s1 = x + '' + y,
      s2 = y + '' + x;

    if (s1 < s2) return -1;
    if (s1 > s2) return 1;
    return 0;
  });

  console.log(numbers.join(''));
}

/**
 * 测试代码
 */

printMinNumber([3, 32, 321]);
```

# 46. 把数字翻译成字符串

[LeetCode](https://leetcode.com/problems/decode-ways/description/)

## 题目描述

给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。

## 解题思路

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0)
        return 0;
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i <= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0)
            dp[i] += dp[i - 1];
        if (s.charAt(i - 2) == '0')
            continue;
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
}
```

# 47. 礼物的最大价值

## 题目描述

在一个 m\*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值(大于 0)。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘

```
1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
```

礼物的最大价值为 1+12+5+7+7+16+5=53。

## 解题思路

应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。

```java
public int getMost(int[][] values) {
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) {
        dp[0] += value[0];
        for (int i = 1; i < n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    }
    return dp[n - 1];
}
```

# 48. 最长不含重复字符的子字符串

## 题目描述

输入一个字符串(只包含 a\~z 的字符)，求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。

## 解题思路

```java
public int longestSubStringWithoutDuplication(String str) {
    int curLen = 0;
    int maxLen = 0;
    int[] preIndexs = new int[26];
    Arrays.fill(preIndexs, -1);
    for (int curI = 0; curI < str.length(); curI++) {
        int c = str.charAt(curI) - 'a';
        int preI = preIndexs[c];
        if (preI == -1 || curI - preI > curLen) {
            curLen++;
        } else {
            maxLen = Math.max(maxLen, curLen);
            curLen = curI - preI;
        }
        preIndexs[c] = curI;
    }
    maxLen = Math.max(maxLen, curLen);
    return maxLen;
}
```

# 49. 丑数

## 题目描述

把只包含因子 2、3 和 5 的数称作丑数(Ugly Number)。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。

## 解题思路

```java
public int GetUglyNumber_Solution(int N) {
    if (N <= 6)
        return N;
    int i2 = 0, i3 = 0, i5 = 0;
    int[] dp = new int[N];
    dp[0] = 1;
    for (int i = 1; i < N; i++) {
        int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
        dp[i] = Math.min(next2, Math.min(next3, next5));
        if (dp[i] == next2)
            i2++;
        if (dp[i] == next3)
            i3++;
        if (dp[i] == next5)
            i5++;
    }
    return dp[N - 1];
}
```

```js
function GetUglyNumberSolution(index) {
  if (index < 7) return index;
  const res = [];
  res[0] = 1;
  let t2 = 0,
    t3 = 0,
    t5 = 0;
  for (let i = 1; i < index; i++) {
    res[i] = Math.min(res[t2] * 2, ress[t3] * 3, res[t5] * 5);
    if (res[i] === res[t2] * 2) t2++;
    if (res[i] === res[t3] * 3) t3++;
    if (res[i] === res[t5] * 5) t5++;
  }
  return res[index - 1];
}
```

## 2. 解题思路

### 2.1 思路一

根据定义，将给定的数不断除 2、3、5，看看能不能除尽即可。然后从 1 遍历到 1500。

### 2.2 思路二

前面速度慢是因为计算了太多非丑数。根据丑数定义，**每一个丑数都是根据前面一个丑数乘以 2、3 或者 5 得到的**。

在确保顺序的情况下，逐步计算即可。

## 3. 代码

### 3.1 思路一实现

```js
// 判断是否符合丑数定义
function isUgly(number) {
  while (number % 2 === 0) {
    number /= 2;
  }
  while (number % 3 === 0) {
    number /= 3;
  }
  while (number % 5 === 0) {
    number /= 5;
  }
  return number === 1;
}

// 找出 [1, index) 之中的所有丑数
function getUglyNumber(index) {
  if (index <= 0) return 0;

  let number = 0,
    uglyFound = 0;

  while (uglyFound < index) {
    ++number;
    if (isUgly(number)) {
      ++uglyFound;
    }
  }

  return number;
}
```

### 3.2 思路二实现

```js
function getUglyNumber(index) {
  if (index <= 0) return 0;

  const uglyNum = [1]; // 存放丑数
  // 2，3，5 三个因子各自的指针
  let pointer2 = 0,
    pointer3 = 0,
    pointer5 = 0;

  for (let i = 1; i < index; ++i) {
    // 找出下一个丑数，确保顺序
    uglyNum[i] = Math.min(uglyNum[pointer2] * 2, uglyNum[pointer3] * 3, uglyNum[pointer5] * 5);
    // 如果结果相同，移动指针，防止下次重复计算
    if (uglyNum[i] == uglyNum[pointer2] * 2) ++pointer2;
    if (uglyNum[i] == uglyNum[pointer3] * 3) ++pointer3;
    if (uglyNum[i] == uglyNum[pointer5] * 5) ++pointer5;
  }

  return uglyNum[index - 1];
}

/**
 * 测试代码
 */

console.log(getUglyNumber(1500)); // 859963392
```
