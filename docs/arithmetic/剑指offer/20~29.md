---
layout: CustomPages
title: 前端与数据结构-剑指 offer 20~29
date: 2020-11-14
aside: false
draft: true
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [20. 表示数值的字符串](#20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
- [21. 调整数组顺序使奇数位于偶数前面](#21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1)
- [22. 链表中倒数第 K 个结点](#22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2)
- [23. 链表中环的入口结点](#23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3)
- [24. 反转链表](#24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8)
  - [递归](#%E9%80%92%E5%BD%92)
  - [迭代](#%E8%BF%AD%E4%BB%A3)
- [25. 合并两个排序的链表](#25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4)
    - [递归](#%E9%80%92%E5%BD%92-1)
    - [迭代](#%E8%BF%AD%E4%BB%A3-1)
- [26. 树的子结构](#26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5)
- [27. 二叉树的镜像](#27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6)
- [28 对称的二叉树](#28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7)
- [29. 顺时针打印矩阵](#29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5)
  - [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 20. 表示数值的字符串

## 题目描述

```
true

"+100"
"5e2"
"-123"
"3.1416"
"-1E-16"
```

```
false

"12e"
"1a3.14"
"1.2.3"
"+-5"
"12e+4.3"
```

## 解题思路

使用正则表达式进行匹配。

```html
[] ： 字符集合 () ： 分组 ? ： 重复 0 ~ 1 次 + ： 重复 1 ~ n 次 * ： 重复 0 ~ n 次 . ： 任意字符 \\. ： 转义后的 . \\d
： 数字
```

```java
public boolean isNumeric(char[] str) {
    if (str == null || str.length == 0)
        return false;
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
}
```

```js
// 第一种
function isNumeric(s) {
  return s.match(/[+-]?\d*(\.\d*)?([eE][+-]?\d+)?/g)[0] === s;
}
// 第二种
function isNumeric2(s) {
  return s.search(/^[+-]?\d*(\.\d*)?$/) === 0 || s.search(/^[+-]?\d+(\.\d*)?[Ee]{1}[+-]?\d+$/) === 0;
}
```

# 21. 调整数组顺序使奇数位于偶数前面

## 题目描述

需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。

## 解题思路

方法一：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。

```java
public void reOrderArray(int[] nums) {
    // 奇数个数
    int oddCnt = 0;
    for (int x : nums)
        if (!isEven(x))
            oddCnt++;
    int[] copy = nums.clone();
    int i = 0, j = oddCnt;
    for (int num : copy) {
        if (num % 2 == 1)
            nums[i++] = num;
        else
            nums[j++] = num;
    }
}

private boolean isEven(int x) {
    return x % 2 == 0;
}
```

方法二：使用冒泡思想，每次都当前偶数上浮到当前最右边。时间复杂度 O(N^2)，空间复杂度 O(1)，时间换空间。

```java
public void reOrderArray(int[] nums) {
    int N = nums.length;
    for (int i = N - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
            if (isEven(nums[j]) && !isEven(nums[j + 1])) {
                swap(nums, j, j + 1);
            }
        }
    }
}

private boolean isEven(int x) {
    return x % 2 == 0;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

oddBegin 主要是用作奇数的索引，oddCount 是用作偶数的索引,newArray 用来存储，以空间换时间，复杂度为 O(n)

```js
function reOrderArray(array) {
  let oddBegin = 0,
    oddCount = 0;
  const newArray = [];
  for (let i = 0; i < array.length; i++) {
    if (array[i] & 1) {
      oddCount++;
    }
  }
  for (let i = 0; i < array.length; i++) {
    if (array[i] & 1) {
      newArray[oddBegin++] = array[i];
    } else {
      newArray[oddCount++] = array[i];
    }
  }
  return newArray;
}
```

# 21.1 数组顺序调整

## 1. 题目描述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

## 2. 思路描述

这题进一步抽象就是满足一定条件的元素都移动到数组的前面，不满足的移动到后面。所以，需要有一个参数用来传递**判断函数**。

最优解法就是数组两头分别有一个指针，然后向中间靠拢。符合条件，就一直向中间移动；不符合条件，就停下来指针，交换两个元素；然后继续移动，直到两个指针相遇。

## 3. 代码实现

函数`change`运用了设计模式中的“[桥接模式](https://godbmw.com/passages/2019-01-19-bridge-pattern/)”，判断条件由用户自己定义。

```js
/**
 * 交换数组元素
 * @param {Array} arr
 * @param {Number} i
 * @param {Number} j
 */
const swap = (arr, i, j) => ([arr[i], arr[j]] = [arr[j], arr[i]]);

/**
 * 将符合compareFn要求的数据排在前半部分，不符合要求的排在后半部分
 * @param {Array} brr
 * @param {Function} compareFn
 * @return {Array}
 */
function change(brr, compareFn) {
  const arr = [...brr],
    length = brr.length;
  let i = 0,
    j = arr.length - 1;
  while (i < j) {
    while (i < length && compareFn(arr[i])) ++i;
    while (j >= 0 && !compareFn(arr[j])) --j;

    if (i < j) {
      swap(arr, i, j);
      ++i;
      --j;
    }
  }
  return arr;
}

/**
 * 测试代码
 */

const isOdd = num => (num & 1) === 1;
console.log(change([1, 2, 3, 4], isOdd));
```

# 22. 链表中倒数第 K 个结点

## 解题思路

设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。

```java
public ListNode FindKthToTail(ListNode head, int k) {
    if (head == null)
        return null;
    ListNode P1 = head;
    while (P1 != null && k-- > 0)
        P1 = P1.next;
    if (k > 0)
        return null;
    ListNode P2 = head;
    while (P1 != null) {
        P1 = P1.next;
        P2 = P2.next;
    }
    return P2;
}
```

```js
function FindKthToTail(head, k) {
  if (head === null || k <= 0) return null;
  let pNode1 = head,
    pNode2 = head;
  while (--k) {
    if (pNode2.next !== null) {
      pNode2 = pNode2.next;
    } else {
      return null;
    }
  }
  while (pNode2.next !== null) {
    pNode1 = pNode1.next;
    pNode2 = pNode2.next;
  }
  return pNode1;
}
```

## 2. 思路描述

**思路一**：从头到尾遍历一遍，统计长度`length`。再从头遍历，直到`length - k`个节点停止，这就是倒数第 k 个节点。

**思路二**：只需要遍历一遍。准备 2 个指针`a`和`b`均指向第一个节点，`a`先移动`k`个位置；然后`a`和`b`一起向后移动，此时两个只指针的位置差为`k`；直到`a`移动到尾结点停止，此时`b`指向的节点就是倒数第 k 个节点。

## 3. 代码实现

下面是“思路二”的实现。

```js
/**
 * 节点定义
 */
class Node {
  constructor(value, next) {
    this.value = value;
    this.next = next;
  }
}

/**
 * 寻找倒数第k个节点
 * @param {Node} head 初始节点
 * @param {Number} k 顺序(倒数)
 */
function findKthFromTail(head, k) {
  if (!head || k <= 0) {
    return null;
  }

  let a = head,
    b = head;

  for (let i = 0; i < k; ++i) {
    a = a.next;
    if (!a) {
      return null;
    }
  }

  while (a) {
    b = b.next;
    a = a.next;
  }

  return b;
}

/**
 * 以下是测试代码, 分别输出倒数第2、3和5个节点
 */

let node3 = new Node(3, null),
  node2 = new Node(2, node3),
  node1 = new Node(1, node2),
  head = new Node(0, node1);

console.log(findKthFromTail(head, 2));
console.log(findKthFromTail(head, 3));
console.log(findKthFromTail(head, 5));
```

# 23. 链表中环的入口结点

## 题目描述

一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。

## 解题思路

使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在下图的 z1 位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。

在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。

```java
public ListNode EntryNodeOfLoop(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return null;
    ListNode slow = pHead, fast = pHead;
    do {
        fast = fast.next.next;
        slow = slow.next;
    } while (slow != fast);
    fast = pHead;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
```

```js
/* function ListNode(x){
 this.val = x;
 this.next = null;
 }*/
function EntryNodeOfLoop(pHead) {
  let fast = pHead;
  let slow = pHead;
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
    if (fast === slow) {
      // 两者相遇
      let p = pHead;
      while (p !== slow) {
        p = p.next;
        slow = slow.next;
      }
      return p;
    }
  }
  return null;
}
```

# 24. 反转链表

### js

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

```js
function ReverseList(pHead) {
  // write code here
  let pPre = null,
    pNext = null;
  while (pHead !== null) {
    pNext = pHead.next;
    pHead.next = pPre;
    pPre = pHead;
    pHead = pNext;
  }
  return pPre;
}
```

```js
var reverseList = function(head) {
  const l1 = new ListNode(null);
  if (!head) return l1;

  // 收集到数组
  const result = [];
  while (head !== null) {
    result.push(head.val);
    head = head.next;
  }
  // result.push(head.val)

  // 重新创建一个链表
  let cur = l1;

  for (let i = result.length - 1; i >= 0; i--) {
    cur.next = new ListNode(result[i]);
    cur = cur.next;
  }

  return l[1].next;
};

function ListNode(val) {
  this.val = val;
  this.next = null;
}

function List(arr) {
  let head = new ListNode(null);
  const guard = head;
  if (arr.length === 0) return guard;
  for (let i = 0; i < arr.length; i++) {
    let temp = new ListNode(arr[i]);
    head.next = temp;
    head = temp;
  }
  return guard.next;
}

function ListNodeToString(listNode) {
  let resp = '';
  let cur = listNode;
  while (cur.next) {
    resp += `${cur.val} -> `;
    cur = cur.next;
  }
  if (cur.val) resp += `${cur.val}`;
  console.log(resp);
}

const l1 = List([1, 2, 3]);
// ListNodeToString(l1)
const l2 = reverseList(l1);
ListNodeToString(l2);

const l3 = List([]);
ListNodeToString(l3);
const l4 = reverseList(l3);
ListNodeToString(l4);

// Wrong Answer
// ✘ 26 / 27 cases passed(N / A)
// ✘ testcase: '[]'
// ✘ answer: [0]
// ✘ expected_answer: []
// ✘ stdout:
```

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let cur = head;
  let pre = null;
  let next = null;
  while (cur != null) {
    next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
};
```

### 递归

```java
public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode next = head.next;
    head.next = null;
    ListNode newHead = ReverseList(next);
    next.next = head;
    return newHead;
}
```

### 迭代

使用头插法。

```java
public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}
```

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let cur = head;
  let pre = null;
  let next = null;
  while (cur != null) {
    next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
};
```

# 25. 合并两个排序的链表

## 2. 思路分析

准备一个指针`node`，假设指向两个链表的中节点的指针分别是：`p1`和`p2`。

1. 比较`p1`和`p2`的`value`大小

- 如果，p1.value 小于 p2.value, node.next 指向 p1, p1 向后移动
- 否则，node.next 指向 p2, p2 向后移动

2. 重复第 1 步，直到其中一个链表遍历完
3. 跳出循环，将 node.next 指向未遍历完的链表的剩余部分

整个过程的时间复杂度是 O(N), 空间复杂度是 O(1)

## 3. 代码实现

```js
/**
 * 节点定义
 */
class Node {
  constructor(value = null, next = null) {
    this.value = value;
    this.next = next;
  }
}

/**
 * 合并2个有序单链表成为1个新的有序单链表
 * @param {Node} p1
 * @param {Node} p2
 */
function merge(p1, p2) {
  if (!p1) {
    return p2;
  } else if (!p2) {
    return p1;
  }

  let head = new Node(),
    node = head;

  while (p1 && p2) {
    if (p1.value < p2.value) {
      node.next = p1;
      p1 = p1.next;
    } else {
      node.next = p2;
      p2 = p2.next;
    }

    node = node.next;
  }

  if (!p1) {
    node.next = p2;
  }

  if (!p2) {
    node.next = p1;
  }

  return head.next;
}

/**
 * 以下是测试代码
 */

let list1 = new Node(1, new Node(3, new Node(5, new Node(7, null))));
let list2 = new Node(2, new Node(4, new Node(6, new Node(8, null))));

let head = merge(list1, list2);
while (head) {
  console.log(head.value);
  head = head.next;
}
```

### js

```js
function Merge(pHead1, pHead2) {
  let pMergeHead = null;
  // write code here
  if (pHead1 === null) return pHead2;
  if (pHead2 === null) return pHead1;
  if (pHead1.val < pHead2.val) {
    pMergeHead = pHead1;
    pMergeHead.next = Merge(pHead1.next, pHead2);
  } else {
    pMergeHead = pHead2;
    pMergeHead.next = Merge(pHead1, pHead2.next);
  }
  return pMergeHead;
}
```

### 递归

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    if (list1 == null)
        return list2;
    if (list2 == null)
        return list1;
    if (list1.val <= list2.val) {
        list1.next = Merge(list1.next, list2);
        return list1;
    } else {
        list2.next = Merge(list1, list2.next);
        return list2;
    }
}
```

### 迭代

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    if (list1 != null)
        cur.next = list1;
    if (list2 != null)
        cur.next = list2;
    return head.next;
}
```

# 26. 树的子结构

## 解题思路

```java
public boolean HasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null || root2 == null)
        return false;
    return isSubtreeWithRoot(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
}

private boolean isSubtreeWithRoot(TreeNode root1, TreeNode root2) {
    if (root2 == null)
        return true;
    if (root1 == null)
        return false;
    if (root1.val != root2.val)
        return false;
    return isSubtreeWithRoot(root1.left, root2.left) && isSubtreeWithRoot(root1.right, root2.right);
}
```

```js
function HasSubtree(pRoot1, pRoot2) {
  let res = false;
  if (pRoot1 === null || pRoot2 === null) return false;
  if (pRoot1.val === pRoot2.val) res = doesTree1HasTree2(pRoot1, pRoot2);
  if (!res) res = HasSubtree(pRoot1.left, pRoot2);
  if (!res) res = HasSubtree(pRoot1.right, pRoot2);
  return res;
}
function doesTree1HasTree2(pRoot1, pRoot2) {
  if (pRoot2 === null) return true;
  if (pRoot1 === null) return false;
  if (pRoot1.val !== pRoot2.val) return false;
  return doesTree1HasTree2(pRoot1.left, pRoot2.left) && doesTree1HasTree2(pRoot1.right, pRoot2.right);
}
```

# 27. 二叉树的镜像

## js

```js
function Mirror(root) {
  if (root === null) return;
  Mirror(root.left);
  Mirror(root.right);
  [root.left, root.right] = [root.right, root.left];
  return root;
}
```

## 解题思路

```java
public void Mirror(TreeNode root) {
    if (root == null)
        return;
    swap(root);
    Mirror(root.left);
    Mirror(root.right);
}

private void swap(TreeNode root) {
    TreeNode t = root.left;
    root.left = root.right;
    root.right = t;
}
```

## 2. 解题思路

书上给了一个示意图：

![](https://i.loli.net/2019/06/09/5cfcfdba2e61382505.png)

显而易见，从根节点开始，交换左右子树的位置；再照这个思路向下处理子树节点。

## 3. 代码实现

```js
/**
 * 二叉树结点类
 */
class Node {
  constructor(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
  }
}

/**
 * 二叉树镜像函数
 * @param {Node} root
 */
function mirrorBinaryTree(root) {
  if (root === null) {
    return;
  }

  // 交换左右节点
  let left = root.left;
  root.left = root.right;
  root.right = left;

  // 继续处理左右子树
  if (root.left) {
    mirrorBinaryTree(root.left);
  }

  if (root.right) {
    mirrorBinaryTree(root.right);
  }
}

/**
 * 以下是测试代码
 */

const root = new Node(0, new Node(1, new Node(3)), new Node(2));

mirrorBinaryTree(root);

console.log(root);
```

# 28 对称的二叉树

## 题目描述

## 解题思路

```java
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null)
        return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}

boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null)
        return true;
    if (t1 == null || t2 == null)
        return false;
    if (t1.val != t2.val)
        return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}
```

```js
function isSymmetrical(pRoot) {
  if (pRoot === null) {
    return true;
  }
  return compareRoot(pRoot.left, pRoot.right);
}
function compareRoot(left, right) {
  if (left === null) {
    return right === null;
  }
  if (right === null) {
    return false;
  }
  if (left.val !== right.val) {
    return false;
  }
  return compareRoot(left.left, right.right) && compareRoot(left.right, right.left);
}
```

# 29. 顺时针打印矩阵

## 题目描述

下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

## 解题思路

```java
public ArrayList<Integer> printMatrix(int[][] matrix) {
    ArrayList<Integer> ret = new ArrayList<>();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 <= r2 && c1 <= c2) {
        for (int i = c1; i <= c2; i++)
            ret.add(matrix[r1][i]);
        for (int i = r1 + 1; i <= r2; i++)
            ret.add(matrix[i][c2]);
        if (r1 != r2)
            for (int i = c2 - 1; i >= c1; i--)
                ret.add(matrix[r2][i]);
        if (c1 != c2)
            for (int i = r2 - 1; i > r1; i--)
                ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}
```

```js
// 第一种
function printMatrix(matrix) {
  if (matrix === null) return null;
  const rows = matrix.length,
    cols = matrix[0].length;
  let start = 0,
    res = [];
  while (rows > start * 2 && cols > start * 2) {
    res = res.concat(printMatrixInCircle(matrix, rows, cols, start));
    start++;
  }
  return res;
}
function printMatrixInCircle(matrix, rows, cols, start) {
  const endX = cols - 1 - start,
    endY = rows - 1 - start,
    res = [];
  for (let i = start; i <= endX; i++) {
    res.push(matrix[start][i]);
  }
  for (let i = start + 1; i <= endY; i++) {
    res.push(matrix[i][endX]);
  }
  for (let i = endX - 1; i >= start && endY > start; i--) {
    res.push(matrix[endY][i]);
  }
  for (let i = endY - 1; i >= start + 1 && endX > start; i--) {
    res.push(matrix[i][start]);
  }
  return res;
}

// 第二种
function printMatrix2(matrix) {
  if (!matrix) return;
  let res = [];
  const firstRow = matrix.shift();
  res = res.concat(firstRow);
  while (matrix.length) {
    // 判断数组是否为空一定要用matrix.length来判断
    matrix = rotateMatrix(matrix);
    res = res.concat(matrix.shift());
  }
  return res;
}
function rotateMatrix(matrix) {
  if (matrix[0].length === undefined) return matrix; // 数组为一维数组时，直接返回原数组
  const rows = matrix.length,
    cols = matrix[0].length,
    newMatrix = [];
  for (let j = cols - 1; j >= 0; j--) {
    const tempMatrix = [];
    for (let i = 0; i < rows; i++) {
      tempMatrix.push(matrix[i][j]);
    }
    newMatrix.push(tempMatrix);
  }
  return newMatrix;
}
```

## 2. 思路分析

既然是顺时针打印，其实就是**由外向内一圈圈打印**，将过程分为 2 步：

第一步：`printMatrix`函数，确定要打印的圈的左上角坐标（比较简单）

第二步：`printMatrixInCircle`函数，根据左上角坐标，顺时针打印这一圈的信息。这个过程又分为四步：左上 -> 右上 -> 右下 -> 左下 -> 左上。

## 3. 代码实现

如果觉得，函数`printMatrixInCircle`的条件判断不清楚，可以配合下面这张图一起看：

![](https://i.loli.net/2019/06/09/5cfcfe24760b637950.jpg)

```js
/**
 * 打印从 (start, start) 与 (endX, endY) 围成的一圈矩形
 * @param {Array} arr
 * @param {Number} cols
 * @param {Number} rows
 * @param {Number} start
 */
function printMatrixInCircle(arr, cols, rows, start) {
  let endX = cols - start - 1,
    endY = rows - start - 1,
    result = '';

  // 从 左上 到 右上 打印一行
  for (let i = start; i <= endX; ++i) {
    result = result + ' ' + arr[start][i];
  }

  // 从 右上 到 右下 打印一行
  if (start < endY) {
    for (let i = start + 1; i <= endY; ++i) {
      result = result + ' ' + arr[i][endX];
    }
  }

  // 从 右下 到 左下 打印一行
  if (start < endX && start < endY) {
    for (let i = endX - 1; i >= start; --i) {
      result = result + ' ' + arr[endY][i];
    }
  }

  // 从 左下 到 左上 打印一行
  if (start < endX && start < endY - 1) {
    for (let i = endY - 1; i >= start + 1; --i) {
      result = result + ' ' + arr[i][start];
    }
  }

  console.log(result);
}

/**
 * 打印的外层函数, 主要用于控制要打印的圈
 * @param {Array} arr
 */
function printMatrix(arr) {
  if (!Array.isArray(arr) || !Array.isArray(arr[0])) {
    return;
  }

  let start = 0,
    cols = arr[0].length,
    rows = arr.length;

  while (cols > start * 2 && rows > start * 2) {
    console.log(`第${start + 1}层: `);
    printMatrixInCircle(arr, cols, rows, start);
    ++start;
  }
}

/**
 * 以下是测试代码
 */

printMatrix([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);

printMatrix([
  [1, 2, 3, 4],
  [4, 5, 6, 7],
  [8, 9, 10, 11],
]);
```
