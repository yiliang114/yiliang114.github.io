---
layout: CustomPages
title: 前端与数据结构-剑指 offer 10~19
date: 2020-11-14
aside: false
draft: true
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [10.1 斐波那契数列](#101-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
- [10.2 矩形覆盖](#102-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1)
- [10.3 跳台阶](#103-%E8%B7%B3%E5%8F%B0%E9%98%B6)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2)
- [10.4 变态跳台阶](#104-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3)
    - [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
    - [数学推导](#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC)
- [11. 旋转数组的最小数字](#11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4)
  - [思路](#%E6%80%9D%E8%B7%AF)
  - [代码](#%E4%BB%A3%E7%A0%81)
- [12. 矩阵中的路径](#12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5)
- [13. 机器人的运动范围](#13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6)
- [14. 剪绳子](#14-%E5%89%AA%E7%BB%B3%E5%AD%90)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7)
    - [贪心](#%E8%B4%AA%E5%BF%83)
    - [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1)
- [15. 二进制中 1 的个数](#15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0)
  - [n&(n-1)](#nn-1)
  - [Integer.bitCount()](#integerbitcount)
- [16. 数值的整数次方](#16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8)
- [17. 打印从 1 到最大的 n 位数](#17-%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9)
- [18.1 在 O(1) 时间内删除链表节点](#181-%E5%9C%A8-o1-%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10)
- [18.2 删除链表中重复的结点](#182-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9)
  - [解题描述](#%E8%A7%A3%E9%A2%98%E6%8F%8F%E8%BF%B0)
- [19. 正则表达式匹配](#19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D)
  - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 10.1 斐波那契数列

求斐波那契数列的第 n 项，n <= 39。

### 解题思路

```js
function Fibonacci(n) {
  let f = 0,
    g = 1;
  while (n--) {
    g += f;
    f = g - f;
  }
  return f;
}
```

## 10.2 矩形覆盖

我们可以用 2\*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共有多少种方法？

### 解题思路

当 n 为 1 时，只有一种覆盖方法：

当 n 为 2 时，有两种覆盖方法：

要覆盖 2\*n 的大矩形，可以先覆盖 2\*1 的矩形，再覆盖 2\*(n-1) 的矩形；或者先覆盖 2\*2 的矩形，再覆盖 2\*(n-2) 的矩形。而覆盖 2\*(n-1) 和 2\*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：

```js
function rectCover(number) {
  // write code here
  if (number === 0) return 0;
  let f = 1,
    g = 2;
  while (--number) {
    g += f;
    f = g - f;
  }
  return f;
}
```

## 10.3 跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

### 解题思路

当 n = 1 时，只有一种跳法：

当 n = 2 时，有两种跳法：

跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：

```js
function jumpFloor(number) {
  // write code here
  let f = 1,
    g = 2;
  while (--number) {
    g += f;
    f = g - f;
  }
  return f;
}
```

### 2. 思路分析

跳到 n 阶假设有 f(n)种方法。

往前倒退，如果青蛙最后一次是跳了 2 阶，那么之前有 f(n-2)种跳法; 如果最后一次跳了 1 阶，那么之前有 f(n-1)种跳法。

所以：f(n) = f(n-1) + f(n-2)。就是斐波那契数列。

### 3. 代码

这里利用缓存模式（又称备忘录模式）实现了代码。

```js
const fibonacci = (() => {
  let mem = new Map();
  mem.set(1, 1);
  mem.set(2, 1);

  const _fibonacci = n => {
    if (n <= 0) {
      throw new Error('Unvalid param');
    }

    if (mem.has(n)) {
      return mem.get(n);
    }

    mem.set(n, _fibonacci(n - 1) + _fibonacci(n - 2));
    return mem.get(n);
  };

  return _fibonacci;
})();

/**
 * 测试代码
 */

let start = new Date().getTime(),
  end = null;

fibonacci(8000);
end = new Date().getTime();
console.log(`耗时为${end - start}ms`);

start = end;
fibonacci(8000);
end = new Date().getTime();
console.log(`耗时为${end - start}ms`);
```

## 10.4 变态跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

### 解题思路

#### 动态规划

```js
function jumpFloorII(number) {
  // write code here
  let i = 1;
  while (--number) {
    i *= 2;
  }
  return i;
}
```

#### 数学推导

跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么

```
f(n-1) = f(n-2) + f(n-3) + ... + f(0)
```

同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么

```
f(n) = f(n-1) + f(n-2) + ... + f(0)
```

综上可得

```
f(n) - f(n-1) = f(n-1)
```

即

```
f(n) = 2*f(n-1)
```

所以 f(n) 是一个等比数列

```java
public int JumpFloorII(int target) {
    return (int) Math.pow(2, target - 1);
}
```

## 11. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。

### 解题思路

将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)(为了方便，这里将 log<sub>2</sub>N 写为 logN)。

此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。

通过修改二分查找算法进行求解(l 代表 low，m 代表 mid，h 代表 high)：

- 当 nums[m] <= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；
- 否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}
```

如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[l] == nums[m] && nums[m] == nums[h])
            return minNumber(nums, l, h);
        else if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}

private int minNumber(int[] nums, int l, int h) {
    for (int i = l; i < h; i++)
        if (nums[i] > nums[i + 1])
            return nums[i + 1];
    return nums[l];
}
```

### 思路

最简单的肯定是从头到尾遍历，复杂度是 $O(N)$。这种方法没有利用“旋转数组”的特性。

借助二分查找的思想，时间复杂度可以降低到 $O(log(N))$。

可以通过以下方法确定最小值元素的位置，然后移动指针，缩小范围：

- 中间指针对应的元素 ≥ 左侧元素, 那么中间元素位于原递增数组中, 最小值在右侧
- 中间指针对应的元素 ≤ 右侧元素, 那么中间元素位于被移动的递增数组中，最小值在左侧

特殊情况，如果三者相等，那么无法判断最小值元素的位置，就退化为普通遍历即可。

### 代码

先上一段二分查找和实现思路：

```js
/**
 * 二分查找
 * @param {Array} arr
 * @param {*} elem
 */
function binarySearch(arr, elem) {
  let left = 0,
    right = arr.length - 1,
    mid = -1;

  while (left <= right) {
    // 注意是≤：考虑只剩1个元素的情况
    mid = Math.floor((left + right) / 2);

    if (arr[mid] === elem) {
      return true;
    }

    if (elem < arr[mid]) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return false;
}

/**
 * 测试代码
 */
console.log(binarySearch([1, 2], 2));
console.log(binarySearch([1, 2], -1));
console.log(binarySearch([1, 2, 10], 2));
```

借助二分查找的思想，写出本题代码：

```js
/**
 * 在arr[left, right]中顺序查找最小值
 * @param {Array} arr
 * @param {Number} left
 * @param {Number} right
 */
function orderSearchMin(arr, left, right) {
  let min = arr[left];

  for (let i = left + 1; i <= right; ++i) {
    arr[i] < min && (min = arr[i]);
  }

  return min;
}

/**
 * 在旋转数组arr中用二分法查找最小值
 * @param {Array} arr
 */

function binSearchMin(arr) {
  if (!Array.isArray(arr) || !arr.length) {
    throw Error('Empty Array');
  }

  let left = 0,
    right = arr.length - 1,
    mid = null;

  while (left < right) {
    if (right === 1 + left) {
      return arr[right];
    }

    mid = Math.floor((left + right) / 2);

    if (arr[mid] === arr[left] && arr[mid] === arr[right]) {
      // 无法判断最小值位置
      return orderSearchMin(arr, left, right);
    }

    if (arr[mid] >= arr[left]) {
      // 最小值在右边
      left = mid;
    } else if (arr[mid] <= arr[right]) {
      // 最小值在左边
      right = mid;
    }
  }

  return arr[right];
}

/**
 * 测试代码
 */

console.log(binSearchMin([3, 4, 5, 1, 2]));
console.log(binSearchMin([2, 3, 4, 5, 1]));
console.log(binSearchMin([2, 2, 2, 1, 1, 2]));
console.log(binSearchMin([1]));
```

## 12. 矩阵中的路径

判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

例如下面的矩阵包含了一条 bfce 路径。

### 解题思路

使用回溯法(backtracking)进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯(回退)，将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。

本题的输入是数组而不是矩阵(二维数组)，因此需要先将数组转换成矩阵。

```js
function hasPath(matrix, rows, cols, path) {
  const pathLength = 0;
  const visited = new Array(rows * cols);
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      // 遍历，遍历的点为起点。
      if (hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited)) {
        return true;
      }
    }
  }
  return false;
}
function hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited) {
  let hasPath = false;
  if (pathLength === path.length) return true;
  if (
    row >= 0 &&
    row < rows &&
    col >= 0 &&
    col < cols &&
    matrix[row * cols + col] === path[pathLength] &&
    !visited[row * cols + col]
  ) {
    ++pathLength;
    visited[row * cols + col] = true;
    // 因为||为短路运算符，只要第一个满足就会返回，而不会去计算后面的，所以有些路径可以不用去走。
    hasPath =
      hasPathCore(matrix, rows, cols, row - 1, col, path, pathLength, visited) ||
      hasPathCore(matrix, rows, cols, row, col - 1, path, pathLength, visited) ||
      hasPathCore(matrix, rows, cols, row + 1, col, path, pathLength, visited) ||
      hasPathCore(matrix, rows, cols, row, col + 1, path, pathLength, visited);
    if (!hasPath) {
      --pathLength;
      visited[row * cols + col] = false;
    }
  }
  return hasPath;
}
```

## 13. 机器人的运动范围

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

### 解题思路

使用深度优先搜索(Depth First Search，DFS)方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。

```js
function movingCount(threshold, rows, cols) {
  const visited = [];
  for (let i = 0; i < rows; i++) {
    visited.push([]);
    for (let j = 0; j < cols; j++) {
      visited[i][j] = false;
    }
  }
  return move(0, 0, rows, cols, visited, threshold);
}
function move(i, j, rows, cols, visited, threshold) {
  if (i < 0 || i === rows || j < 0 || j === cols || visited[i][j]) {
    return 0;
  }
  let sum = 0;
  const tmp = `${i}${j}`;
  for (let k = 0; k < tmp.length; k++) {
    sum += tmp.charAt(k) / 1; // 转成数字
  }
  if (sum > threshold) {
    return 0;
  }
  visited[i][j] = true;
  return (
    1 +
    move(i + 1, j, rows, cols, visited, threshold) +
    move(i, j + 1, rows, cols, visited, threshold) +
    move(i - 1, j, rows, cols, visited, threshold) +
    move(i, j - 1, rows, cols, visited, threshold)
  );
}
```

## 14. 剪绳子

[LeetCode](https://leetcode.com/problems/integer-break/description/)

把一根绳子剪成多段，并且使得每段的长度乘积最大。

```html
n = 2 return 1 (2 = 1 + 1) n = 10 return 36 (10 = 3 + 3 + 4)
```

### 解题思路

#### 贪心

尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。

证明：当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。

```java
public int integerBreak(int n) {
    if (n < 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

#### 动态规划

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 1; j < i; j++)
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}
```

## 15. 二进制中 1 的个数

输入一个整数，输出该数二进制表示中 1 的个数。

#### n&(n-1)

该位运算去除 n 的位级表示中最低的那一位。

```
n       : 10110100
n-1     : 10110011
n&(n-1) : 10110000
```

时间复杂度：O(M)，其中 M 表示 1 的个数。

```js
// 第一种
function NumberOf1(n) {
  let count = 0,
    flag = 1;
  while (flag) {
    // 循环的次数等于整数二进制的位数，32位的整数需要循环32位
    if (flag & n) count++;
    flag = flag << 1;
  }
  return count;
}
// 第二种
function newNumberOf1(n) {
  let count = 0;
  while (n) {
    n = n & (n - 1); // 核心
    count++;
  }
  return count;
}
```

#### Integer.bitCount()

```java
public int NumberOf1(int n) {
    return Integer.bitCount(n);
}
```

### 2. 思路

注意到，如果要判断一个二进制数指定位数是否为 1，比如这个二进制数是 1011。那么只需要构造除了这个位为 1，其他位为 0 的二进制即可，这个例子是 0100。

两者进行`&`运算，如果结果为 0，那么指定位数不为 1；否则为 1。

现在事情就简单了，只要准备数字`1`，每次与原数进行`&`操作，然后左移`1`；
重复前面的步骤，就能逐步比较出每一位是不是`1`。

### 3. 代码实现

```js
/**
 * @param {Number} n
 */
function numberOf1(n) {
  let count = 0,
    flag = 1;

  while (flag) {
    if (flag & n) {
      ++count;
    }

    flag = flag << 1;
  }

  return count;
}

/**
 * 测试代码
 */

console.log(numberOf1(3));
```

**注意**：有更好的实现思路，请见“02-二进制中 1 的个数进阶版”。

## 优化版 二进制中的 1 的个数

### 1. 优化做法

有个不错的规律，对于一个整数`n`，运算结果`n & (n - 1)`可以消除而今中从右向左出现的第一个`1`。比如二进制数`011`，减去 1 是`010`，做与运算的结果就是`010`。

利用这个性质，可以逐步剔除原数二进制中的`1`。每次剔除，统计量`count`都加 1；直到所有的`1`都被移除，原数变成`0`。

```js
/**
 * @param {Number} n
 */
function numberOf1(n) {
  let count = 0;

  while (n) {
    ++count;
    n = n & (n - 1);
  }

  return count;
}

/**
 * 测试代码
 */

console.log(numberOf1(3));
```

### 2. 如何判断 2 的整次方

如果一个数是 2 的整次方，那么只有一个二进制位为 1。所以，`n & (n - 1)`如果不是 1，说明二进制表示中有多个 1，那么就不是 2 的整次方；否则，就是得。

```js
/**
 * 判断是否是2的整次方
 * @param {Number} n
 */
function is2Power(n) {
  if (n <= 0) {
    throw new Error('Unvalid param');
  }

  return !(n & (n - 1));
}

console.log(is2Power(128));
```

### 3. 求多少个不同的二进制位

题目：输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到 n。翻译过来就是：m 和 n 二进制位上有多少个不同的数。

思路：

1. m 和 n 进行异或操作，不同的位都变成了 1
2. 利用前面的思路统计 1 的个数

```js
/**
 * 求解二进制表示中有多少位不相同
 * @param {Number} a
 * @param {Number} b
 */
function getDiffBytes(a, b) {
  let count = 0,
    n = a ^ b;

  while (n) {
    ++count;
    n = n & (n - 1);
  }

  return count;
}

/**
 * 测试代码
 */

console.log(getDiffBytes(1, 1));
console.log(getDiffBytes(3, 1));
```

## 16. 数值的整数次方

给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。

### 解题思路

下面的讨论中 x 代表 base，n 代表 exponent。

因为 (x\*x)<sup>n/2</sup> 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。

```js
function Power(base, exponent) {
  // write code here
  let res = 1,
    n;
  if (exponent > 0) {
    // 指数大于0的情况下
    n = exponent;
  } else if (exponent < 0) {
    // 指数小于0的情况下
    if (!base) throw new Error('分母不能为0');
    n = -exponent;
  } else {
    // 指数等于0的情况下
    return 1;
  }
  while (n) {
    // 也可以用递归做，这里采用了循环
    if (n & 1)
      // 当指数为奇数时，包括了1
      res *= base;
    base *= base;
    n >>= 1;
  }
  return exponent > 0 ? res : 1 / res;
}
```

### 2. 思路分析

**简单思路**：最简单的做法是循环，但是要考虑异常值的检验。比如指数是负数，底数为 0。

**优化思路**：书上提供了一种复杂度为 $O(logN)$ 的做法。比如我们要求 32 次方，那么只要求出 16 次方再平方即可。依次类推，是递归函数的结构。

递推公式如下：

$$
a^n=\left\{
\begin{aligned}
a^{n/2}*a^{n/2} ; n为偶数\\
a^{(n - 1)/2}*a^{(n - 1)/2} ; n为奇数
\end{aligned}
\right.
$$

需要注意的是，如果幂是奇数，例如 5 次方，可以先计算 2 次方，结果平方后（4 次方），再乘以自身（5 次方）。按照此思路处理。

### 3. 代码实现

#### 简单思路

```js
/**
 *
 * @param {Number} base
 * @param {Number} exp
 */
function pow(base, exp) {
  // 规定0的任何次方均为0
  if (!base) {
    return 0;
  }
  let result = 1,
    absExp = Math.abs(exp);

  for (let i = 0; i < absExp; ++i) {
    result *= base;
  }

  // 对于指数小于0的情况，求其倒数
  if (exp < 0) {
    result = 1 / result;
  }

  return result;
}

/**
 * 以下是测试代码
 */

console.log(pow(2, -2));
console.log(pow(2, 2));
console.log(pow(2, 0));
console.log(pow(0, -9));
```

#### 优化思路

在 Js 中整数除 2 不会自动取整，可以使用`Math.floor()`。但更好的做法是使用`>>`位运算。

判断奇数可以用`%2`判断。但更好的做法是和`1`进行`&`运算后（除了最后 1 位，都被置 0 了），判断是不是 1

```js
/**
 * 求base 的 exp次幂，其中exp永远是正数
 * @param {Number} base
 * @param {Number} exp
 */
function unsignedPow(base, exp) {
  if (exp === 0) {
    return 1;
  } else if (exp === 1) {
    return base;
  }

  let result = pow(base, exp >> 1);
  result *= result;
  if (exp & (1 === 1)) {
    result *= base;
  }

  return result;
}

/**
 * 求 base的exp次幂
 * @param {Number} base
 * @param {Number} exp
 */
function pow(base, exp) {
  if (!base) {
    return 0;
  }

  let absExp = Math.abs(exp);

  return exp < 0 ? 1 / unsignedPow(base, absExp) : unsignedPow(base, absExp);
}

/**
 * 以下是测试代码
 */

console.log(pow(2, 2));
console.log(pow(2, 0));
console.log(pow(0, -9));
console.log(pow(2, -2));
```

## 17. 打印从 1 到最大的 n 位数

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

### 解题思路

由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

使用回溯法得到所有的数。

```java
public void print1ToMaxOfNDigits(int n) {
    if (n <= 0)
        return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, 0);
}

private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length) {
        printNumber(number);
        return;
    }
    for (int i = 0; i < 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}

private void printNumber(char[] number) {
    int index = 0;
    while (index < number.length && number[index] == '0')
        index++;
    while (index < number.length)
        System.out.print(number[index++]);
    System.out.println();
}
```

### 2. 思路分析

主要的坑点在：大数的溢出。当然，es6 提供了`BigInt`数据类型，可以直接相加不用担心溢出。

除此之外，这题显然是要我们模拟“大数相加”：将最低位加 1，然后每次检查是否进位，如果不进位，直接退出循环；如果进位，需要保留进上来的 1，然后加到下一位，直到不进位或者超出了我们规定的范围。

### 3. 代码实现

js 中不方便操作字符串中指定位置的字符，因此用数组对象来模拟。

```js
/**
 * 用数组模拟大数相加操作
 * @param {Array} arr
 * @return {Boolean} true, 超出arr.length位最大整数; false, 没有超出arr.length位最大整数
 */
function increase(arr) {
  let length = arr.length,
    over = 0; // 记录前一位相加后的进位数

  for (let i = length - 1; i >= 0; --i) {
    arr[i] = arr[i] + over;

    if (i === length - 1) {
      arr[i] += 1;
    }

    if (arr[i] >= 10) {
      // 如果第n位进位，说明超出了n位最大数字
      if (i === 0) {
        return true;
      }

      arr[i] = arr[i] - 10;
      over = 1;
    } else {
      break;
    }
  }

  return false;
}

/**
 *
 * @param {Number} n
 */
function printMaxDigits(n) {
  if (n <= 0) {
    return;
  }

  let arr = new Array(n).fill(0);
  while (!increase(arr)) {
    console.log(arr);
  }
}

/**
 * 测试代码
 */
printMaxDigits(2);
printMaxDigits(3);
printMaxDigits(10);
```

## 18.1 在 O(1) 时间内删除链表节点

### 解题思路

① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。

② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N \~ 2，因此该算法的平均时间复杂度为 O(1)。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if (head == null || tobeDelete == null)
        return null;
    if (tobeDelete.next != null) {
        // 要删除的节点不是尾节点
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    } else {
        if (head == tobeDelete)
             // 只有一个节点
            head = null;
        else {
            ListNode cur = head;
            while (cur.next != tobeDelete)
                cur = cur.next;
            cur.next = null;
        }
    }
    return head;
}
```

### 2. 思路描述

正常的做法肯定是在 $O(N)$ 时间内删除节点。而这么过分的要求，显然是通过“重新赋值”才能做到。

比如要删除节点 a，那么就将 a.next 的 value 和 next 赋值给节点 a，然后删除 a.next。

表面“看起来”像是删除了节点 a，其实是将其后节点的信息转移到了它自己身上。

除此之外，对于最后一个节点，还是要退化成 $O(N)$ 的复杂度。而整体分析一下复杂度：

$$
O(T) = (O(N) + O(1) * (n - 1)) / n = O(1)
$$

### 3. 代码实现

```js
class Node {
  /**
   * 节点构造函数
   * @param {*} value
   * @param {Node} next
   */
  constructor(value, next) {
    this.value = value;
    this.next = next;
  }
}

/**
 *
 * @param {Node} head
 * @param {Node} toDelete
 */
function deleteNode(head, toDelete) {
  if (head === toDelete || !toDelete || !head) {
    return;
  }

  let nextNode = toDelete.next;

  if (!nextNode) {
    // 尾节点
    let node = head;
    while (node.next !== toDelete) {
      node = node.next;
    }
    node.next = null;
    toDelete = null;
  } else {
    toDelete.value = nextNode.value;
    toDelete.next = nextNode.next;
    nextNode = null;
  }
}

/**
 * 测试代码
 */

let node3 = new Node(3, null),
  node2 = new Node(2, node3),
  node1 = new Node(1, node2),
  head = new Node(null, node1);

deleteNode(head, node2);
let node = head.next;
while (node) {
  console.log(node.value);
  node = node.next;
}
```

## 18.2 删除链表中重复的结点

### 解题描述

```js
function ListNode(x) {
  this.val = x;
  this.next = null;
}
function deleteDuplication(pHead) {
  if (pHead === null || pHead.next === null) {
    return pHead;
  }
  const Head = new ListNode(0); // 重要，方便处理第一个、第二个节点就是相同的情况。
  Head.next = pHead;
  let pre = Head;
  let cur = Head.next;
  while (cur !== null) {
    if (cur.next !== null && cur.val === cur.next.val) {
      // 找到最后的一个相同节点,因为相同节点可能重复多个
      while (cur.next !== null && cur.val === cur.next.val) {
        cur = cur.next;
      }
      pre.next = cur.next;
      cur = cur.next;
    } else {
      pre = pre.next;
      cur = cur.next;
    }
  }
  return Head.next;
}

// 测试
const one = new ListNode(1);
const two = new ListNode(2);
const thr1 = new ListNode(3);
const thr2 = new ListNode(3);
const fou1 = new ListNode(4);
const fou2 = new ListNode(4);
const fiv = new ListNode(5);
fou2.next = fiv;
fou1.next = fou2;
thr2.next = fou1;
thr1.next = thr2;
two.next = thr1;
one.next = two;
console.log(deleteDuplication(one));
```

## 19. 正则表达式匹配

请实现一个函数用来匹配包括 '.' 和 '\*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '\*' 表示它前面的字符可以出现任意次(包含 0 次)。

在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab\*ac\*a" 匹配，但是与 "aa.a" 和 "ab\*a" 均不匹配。

### 解题思路

应该注意到，'.' 是用来当做一个任意字符，而 '\*' 是用来重复前面的字符。这两个的作用不同，不能把 '.' 的作用和 '\*' 进行类比，从而把它当成重复前面字符一次。

```js
// 第一种
function match(s, pattern) {
  const reg = new RegExp(`^${pattern}$`);
  return reg.test(s);
}

// 第二种
function matchCore(s, istr, pattern, ipattern) {
  if (istr === s.length && ipattern === pattern.length) {
    return true;
  }

  if (istr !== s.length && ipattern === pattern.length) {
    return false;
  }
  if (pattern[ipattern + 1] === '*') {
    if ((pattern[ipattern] === '.' && istr !== s.length) || pattern[ipattern] === s[istr]) {
      return (
        matchCore(s, istr + 1, pattern, ipattern + 2) ||
        matchCore(s, istr + 1, pattern, ipattern) ||
        matchCore(s, istr, pattern, ipattern + 2)
      );
    }
    return matchCore(s, istr, pattern, ipattern + 2);
  }

  if (s[istr] === pattern[ipattern] || (pattern[ipattern] === '.' && istr !== s.length)) {
    return matchCore(s, istr + 1, pattern, ipattern + 1);
  }
  return false;
}

function match2(s, pattern) {
  if (s === null || pattern === null) {
    return false;
  }
  return matchCore(s, 0, pattern, 0);
}
```
