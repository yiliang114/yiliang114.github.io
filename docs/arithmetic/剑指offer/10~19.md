---
layout: CustomPages
title: 前端与数据结构-剑指 offer 10~19
date: 2020-11-14
aside: false
draft: true
---

## 10.1 斐波那契数列

求斐波那契数列的第 n 项，n <= 39。 这里很多人可能会忘记取模 1000000007...

```js
var fib = function(n) {
  if (n < 2) return n;
  let i = 0,
    j = 1;
  // 0 1 已经存在了。。。
  while (n > 1) {
    [i, j] = [j, (i + j) % 1000000007];
    n--;
  }
  return j;
};
```

## 10.2 矩形覆盖

我们可以用 `2*1` 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 `2*1` 的小矩形无重叠地覆盖一个 `2*n` 的大矩形，总共有多少种方法？

### 解题思路

当 n 为 1 时，只有一种覆盖方法；当 n 为 2 时，有两种覆盖方法：

要覆盖 `2*n` 的大矩形，可以先覆盖 `2*1` 的矩形，再覆盖 `2*(n-1)` 的矩形；或者先覆盖 `2*2` 的矩形，再覆盖 `2*(n-2)` 的矩形。而覆盖 `2*(n-1)` 和 `2*(n-2)` 的矩形可以看成子问题。该问题的递推公式如下：

```js
function rectCover(number) {
  if (number === 0) return 0;
  let f = 1,
    g = 2;
  while (--number) {
    g += f;
    f = g - f;
  }
  return f;
}
```

## 10.3 跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

### 解题思路

当 n = 1 时，只有一种跳法；当 n = 2 时，有两种跳法；跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题。

### 代码

比普通的斐波那契函数多了 1. 可以在初始值中修改，或者直接修改传参即可。

```js
var numWays = function(n) {
  let f = 1,
    g = 1;
  while (n--) {
    g += f % 1000000007;
    f = (g - f) % 1000000007;
  }
  return f;
};
```

```js
var numWays = function(n) {
  return fib(n + 1);
};
```

## 10.4 变态跳台阶

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

#### 动态规划

```js
function jumpFloorII(number) {
  let i = 1;
  while (--number) {
    i *= 2;
  }
  return i;
}
```

#### 数学推导

跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么

```
f(n-1) = f(n-2) + f(n-3) + ... + f(0)
```

同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么

```
f(n) = f(n-1) + f(n-2) + ... + f(0)
```

综上可得

```
f(n) - f(n-1) = f(n-1)
```

即

```
f(n) = 2*f(n-1)
```

所以 f(n) 是一个等比数列

```js
function jumpFloorII(number) {
  return Math.pow(2, number - 1);
}
```

## 11. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组`[3,4,5,1,2]`为 `[1,2,3,4,5]`的一个旋转，该数组的最小值为 1。

### 思路

最简单的肯定是从头到尾遍历，复杂度是 `O(N)`。这种方法没有利用“旋转数组”的特性。

借助二分查找的思想，时间复杂度可以降低到 `O(log(N))`。

可以通过以下方法确定最小值元素的位置，然后移动指针，缩小范围：

- 中间指针对应的元素 ≥ 左侧元素, 那么中间元素位于原递增数组中, 最小值在右侧
- 中间指针对应的元素 ≤ 右侧元素, 那么中间元素位于被移动的递增数组中，最小值在左侧

特殊情况，如果三者相等，那么无法判断最小值元素的位置，就退化为普通遍历即可。

### 代码

```js
// 理论上说任意增序数组旋转都可以处理
var minNumberInRotateArray1 = function(numbers) {
  if (numbers.length === 0) return 0;
  for (let i = 0; i < numbers.length; i++) {
    // 在递增数组中，只要当前值比下一个值还大，说明此处是经过旋转的点
    if (numbers[i] > numbers[i + 1]) {
      return numbers[i + 1];
    }
  }
  return numbers[0];
};

// mid 与 right or left 的值相等的话 就无法处理了。。。
var minNumberInRotateArray2 = function(numbers) {
  let left = 0,
    right = numbers.length - 1;
  while (right - left > 1) {
    // 找到中间的位置
    let mid = left + ((right - left) >> 1);
    // 中间值如果比右侧值还要大的话，说明 mid - right 部分中存在最小值；否则最小值在 left - mid 位置
    if (numbers[mid] > numbers[right]) {
      left = mid;
    } else {
      right = mid;
    }
  }
  // 最后如果只剩下两个值，则取更小的
  return Math.min(numbers[left], numbers[right]);
};

// 先使用二分搜索的思想查找，但是如果 mid 与 right 的值相等的话，那就改用普通搜索
var minNumberInRotateArray3 = function(numbers) {
  let left = 0,
    right = numbers.length - 1;
  while (right - left > 1) {
    // 找到中间的位置
    let mid = left + ((right - left) >> 1);
    // 中间值如果比右侧值还要大的话，说明 mid - right 部分中存在最小值；否则最小值在 left - mid 位置
    if (numbers[mid] > numbers[right]) {
      left = mid;
    } else if (numbers[mid] === numbers[right]) {
      // 无法判断最小值位置，则采用直接循环的形式搜索
      return minNumberInRotateArray1(numbers.slice(left, right));
    } else {
      right = mid;
    }
  }
  // 最后如果只剩下两个值，则取更小的
  return Math.min(numbers[left], numbers[right]);
};
```

## 12. 矩阵中的路径

判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

例如下面的矩阵包含了一条 bfce 路径。

### 解题思路

使用回溯法(backtracking)进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯(回退)，将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。

本题的输入是数组而不是矩阵(二维数组)，因此需要先将数组转换成矩阵。

```js
function hasPath(matrix, rows, cols, path) {
  const pathLength = 0;
  const visited = new Array(rows * cols);
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      // 遍历，遍历的点为起点。
      if (hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited)) {
        return true;
      }
    }
  }
  return false;
}
function hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited) {
  let hasPath = false;
  if (pathLength === path.length) return true;
  if (
    row >= 0 &&
    row < rows &&
    col >= 0 &&
    col < cols &&
    matrix[row * cols + col] === path[pathLength] &&
    !visited[row * cols + col]
  ) {
    ++pathLength;
    visited[row * cols + col] = true;
    // 因为||为短路运算符，只要第一个满足就会返回，而不会去计算后面的，所以有些路径可以不用去走。
    hasPath =
      hasPathCore(matrix, rows, cols, row - 1, col, path, pathLength, visited) ||
      hasPathCore(matrix, rows, cols, row, col - 1, path, pathLength, visited) ||
      hasPathCore(matrix, rows, cols, row + 1, col, path, pathLength, visited) ||
      hasPathCore(matrix, rows, cols, row, col + 1, path, pathLength, visited);
    if (!hasPath) {
      --pathLength;
      visited[row * cols + col] = false;
    }
  }
  return hasPath;
}
```

## 13. 机器人的运动范围

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

### 解题思路

使用深度优先搜索(Depth First Search，DFS)方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。

```js
function move(i, j, rows, cols, visited, threshold) {
  if (i < 0 || i === rows || j < 0 || j === cols || visited[i][j]) {
    return 0;
  }
  let sum = 0;
  const tmp = `${i}${j}`;
  for (let k = 0; k < tmp.length; k++) {
    sum += tmp.charAt(k) / 1; // 转成数字
  }
  if (sum > threshold) {
    return 0;
  }
  visited[i][j] = true;
  return (
    1 +
    move(i + 1, j, rows, cols, visited, threshold) +
    move(i, j + 1, rows, cols, visited, threshold) +
    move(i - 1, j, rows, cols, visited, threshold) +
    move(i, j - 1, rows, cols, visited, threshold)
  );
}

function movingCount(threshold, rows, cols) {
  const visited = [];
  for (let i = 0; i < rows; i++) {
    visited.push([]);
    for (let j = 0; j < cols; j++) {
      visited[i][j] = false;
    }
  }
  return move(0, 0, rows, cols, visited, threshold);
}
```

## 14. 剪绳子

[LeetCode](https://leetcode-cn.com/problems/integer-break/description/)

把一根绳子剪成多段，并且使得每段的长度乘积最大。

```html
n = 2 return 1 (2 = 1 + 1) n = 10 return 36 (10 = 3 + 3 + 4)
```

### 解题思路

#### 贪心

尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。

证明：当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。

```java
public int integerBreak(int n) {
    if (n < 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

#### 动态规划

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 1; j < i; j++)
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}
```

## 15. 二进制中 1 的个数

输入一个整数，输出该数二进制表示中 1 的个数。

#### n&(n-1)

该位运算去除 n 的位级表示中最低的那一位。

```
n       : 10110100
n-1     : 10110011
n&(n-1) : 10110000
```

时间复杂度：O(M)，其中 M 表示 1 的个数。

```js
// 第一种
function NumberOf1(n) {
  let count = 0,
    flag = 1;
  while (flag) {
    // 循环的次数等于整数二进制的位数，32位的整数需要循环32位
    if (flag & n) count++;
    flag = flag << 1;
  }
  return count;
}
// 第二种
function newNumberOf1(n) {
  let count = 0;
  while (n) {
    n = n & (n - 1); // 核心
    count++;
  }
  return count;
}
```

#### Integer.bitCount()

```java
public int NumberOf1(int n) {
    return Integer.bitCount(n);
}
```

### 思路

注意到，如果要判断一个二进制数指定位数是否为 1，比如这个二进制数是 1011。那么只需要构造除了这个位为 1，其他位为 0 的二进制即可，这个例子是 0100。

两者进行`&`运算，如果结果为 0，那么指定位数不为 1；否则为 1。

现在事情就简单了，只要准备数字`1`，每次与原数进行`&`操作，然后左移`1`；
重复前面的步骤，就能逐步比较出每一位是不是`1`。

### 代码实现

```js
/**
 * @param {Number} n
 */
function numberOf1(n) {
  let count = 0,
    flag = 1;

  while (flag) {
    if (flag & n) {
      ++count;
    }

    flag = flag << 1;
  }

  return count;
}

/**
 * 测试代码
 */

console.log(numberOf1(3));
```

**注意**：有更好的实现思路，请见“02-二进制中 1 的个数进阶版”。

### 优化版 二进制中的 1 的个数

### 1. 优化做法

有个不错的规律，对于一个整数`n`，运算结果`n & (n - 1)`可以消除而今中从右向左出现的第一个`1`。比如二进制数`011`，减去 1 是`010`，做与运算的结果就是`010`。

利用这个性质，可以逐步剔除原数二进制中的`1`。每次剔除，统计量`count`都加 1；直到所有的`1`都被移除，原数变成`0`。

```js
/**
 * @param {Number} n
 */
function numberOf1(n) {
  let count = 0;

  while (n) {
    ++count;
    n = n & (n - 1);
  }

  return count;
}

/**
 * 测试代码
 */

console.log(numberOf1(3));
```

### 如何判断 2 的整次方

如果一个数是 2 的整次方，那么只有一个二进制位为 1。所以，`n & (n - 1)`如果不是 1，说明二进制表示中有多个 1，那么就不是 2 的整次方；否则，就是得。

```js
/**
 * 判断是否是2的整次方
 * @param {Number} n
 */
function is2Power(n) {
  if (n <= 0) {
    throw new Error('Unvalid param');
  }

  return !(n & (n - 1));
}

console.log(is2Power(128));
```

### 求多少个不同的二进制位

题目：输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到 n。翻译过来就是：m 和 n 二进制位上有多少个不同的数。

思路：

1. m 和 n 进行异或操作，不同的位都变成了 1
2. 利用前面的思路统计 1 的个数

```js
/**
 * 求解二进制表示中有多少位不相同
 * @param {Number} a
 * @param {Number} b
 */
function getDiffBytes(a, b) {
  let count = 0,
    n = a ^ b;

  while (n) {
    ++count;
    n = n & (n - 1);
  }

  return count;
}

/**
 * 测试代码
 */

console.log(getDiffBytes(1, 1));
console.log(getDiffBytes(3, 1));
```

## 16. 数值的整数次方

给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。

### 解题思路

下面的讨论中 x 代表 base，n 代表 exponent。

因为 (x\*x)<sup>n/2</sup> 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。

```js
function Power(base, exponent) {
  let res = 1,
    n;
  if (exponent > 0) {
    // 指数大于0的情况下
    n = exponent;
  } else if (exponent < 0) {
    // 指数小于0的情况下
    if (!base) throw new Error('分母不能为0');
    n = -exponent;
  } else {
    // 指数等于0的情况下
    return 1;
  }
  while (n) {
    // 也可以用递归做，这里采用了循环
    if (n & 1)
      // 当指数为奇数时，包括了1
      res *= base;
    base *= base;
    n >>= 1;
  }
  return exponent > 0 ? res : 1 / res;
}
```

### 思路分析

**简单思路**：最简单的做法是循环，但是要考虑异常值的检验。比如指数是负数，底数为 0。

**优化思路**：书上提供了一种复杂度为 $O(logN)$ 的做法。比如我们要求 32 次方，那么只要求出 16 次方再平方即可。依次类推，是递归函数的结构。

递推公式如下：

$$
a^n=\left\{
\begin{aligned}
a^{n/2}*a^{n/2} ; n为偶数\\
a^{(n - 1)/2}*a^{(n - 1)/2} ; n为奇数
\end{aligned}
\right.
$$

需要注意的是，如果幂是奇数，例如 5 次方，可以先计算 2 次方，结果平方后（4 次方），再乘以自身（5 次方）。按照此思路处理。

### 代码实现

#### 简单思路

```js
/**
 *
 * @param {Number} base
 * @param {Number} exp
 */
function pow(base, exp) {
  // 规定0的任何次方均为0
  if (!base) {
    return 0;
  }
  let result = 1,
    absExp = Math.abs(exp);

  for (let i = 0; i < absExp; ++i) {
    result *= base;
  }

  // 对于指数小于0的情况，求其倒数
  if (exp < 0) {
    result = 1 / result;
  }

  return result;
}

/**
 * 以下是测试代码
 */

console.log(pow(2, -2));
console.log(pow(2, 2));
console.log(pow(2, 0));
console.log(pow(0, -9));
```

#### 优化思路

在 Js 中整数除 2 不会自动取整，可以使用`Math.floor()`。但更好的做法是使用`>>`位运算。

判断奇数可以用`%2`判断。但更好的做法是和`1`进行`&`运算后（除了最后 1 位，都被置 0 了），判断是不是 1

```js
/**
 * 求base 的 exp次幂，其中exp永远是正数
 * @param {Number} base
 * @param {Number} exp
 */
function unsignedPow(base, exp) {
  if (exp === 0) {
    return 1;
  } else if (exp === 1) {
    return base;
  }

  let result = pow(base, exp >> 1);
  result *= result;
  if (exp & (1 === 1)) {
    result *= base;
  }

  return result;
}

/**
 * 求 base的exp次幂
 * @param {Number} base
 * @param {Number} exp
 */
function pow(base, exp) {
  if (!base) {
    return 0;
  }

  let absExp = Math.abs(exp);

  return exp < 0 ? 1 / unsignedPow(base, absExp) : unsignedPow(base, absExp);
}

/**
 * 以下是测试代码
 */

console.log(pow(2, 2));
console.log(pow(2, 0));
console.log(pow(0, -9));
console.log(pow(2, -2));
```

## 17. 打印从 1 到最大的 n 位数

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

### 解题思路

由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

使用回溯法得到所有的数。

```java
public void print1ToMaxOfNDigits(int n) {
    if (n <= 0)
        return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, 0);
}

private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length) {
        printNumber(number);
        return;
    }
    for (int i = 0; i < 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}

private void printNumber(char[] number) {
    int index = 0;
    while (index < number.length && number[index] == '0')
        index++;
    while (index < number.length)
        System.out.print(number[index++]);
    System.out.println();
}
```

### 思路分析

主要的坑点在：大数的溢出。当然，es6 提供了`BigInt`数据类型，可以直接相加不用担心溢出。

除此之外，这题显然是要我们模拟“大数相加”：将最低位加 1，然后每次检查是否进位，如果不进位，直接退出循环；如果进位，需要保留进上来的 1，然后加到下一位，直到不进位或者超出了我们规定的范围。

### 代码实现

js 中不方便操作字符串中指定位置的字符，因此用数组对象来模拟。

```js
/**
 * 用数组模拟大数相加操作
 * @param {Array} arr
 * @return {Boolean} true, 超出arr.length位最大整数; false, 没有超出arr.length位最大整数
 */
function increase(arr) {
  let length = arr.length,
    over = 0; // 记录前一位相加后的进位数

  for (let i = length - 1; i >= 0; --i) {
    arr[i] = arr[i] + over;

    if (i === length - 1) {
      arr[i] += 1;
    }

    if (arr[i] >= 10) {
      // 如果第n位进位，说明超出了n位最大数字
      if (i === 0) {
        return true;
      }

      arr[i] = arr[i] - 10;
      over = 1;
    } else {
      break;
    }
  }

  return false;
}

/**
 *
 * @param {Number} n
 */
function printMaxDigits(n) {
  if (n <= 0) {
    return;
  }

  let arr = new Array(n).fill(0);
  while (!increase(arr)) {
    console.log(arr);
  }
}

/**
 * 测试代码
 */
printMaxDigits(2);
printMaxDigits(3);
printMaxDigits(10);
```

## 18.1 在 O(1) 时间内删除链表节点

### 解题思路

① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。

② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N \~ 2，因此该算法的平均时间复杂度为 O(1)。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if (head == null || tobeDelete == null)
        return null;
    if (tobeDelete.next != null) {
        // 要删除的节点不是尾节点
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    } else {
        if (head == tobeDelete)
             // 只有一个节点
            head = null;
        else {
            ListNode cur = head;
            while (cur.next != tobeDelete)
                cur = cur.next;
            cur.next = null;
        }
    }
    return head;
}
```

### 思路描述

正常的做法肯定是在 `O(N)` 时间内删除节点。而这么过分的要求，显然是通过“重新赋值”才能做到。

比如要删除节点 a，那么就将 a.next 的 value 和 next 赋值给节点 a，然后删除 a.next。

表面“看起来”像是删除了节点 a，其实是将其后节点的信息转移到了它自己身上。

除此之外，对于最后一个节点，还是要退化成 `O(N)` 的复杂度。而整体分析一下复杂度：

O(T) = (O(N) + O(1) \* (n - 1)) / n = O(1)

### 代码实现

```js
/**
 *
 * @param {Node} head
 * @param {Node} toDelete
 */
function deleteNode(head, toDelete) {
  if (head === toDelete || !toDelete || !head) {
    return;
  }

  let nextNode = toDelete.next;

  if (!nextNode) {
    // 尾节点
    let node = head;
    while (node.next !== toDelete) {
      node = node.next;
    }
    node.next = null;
    toDelete = null;
  } else {
    toDelete.value = nextNode.value;
    toDelete.next = nextNode.next;
    nextNode = null;
  }
}

/**
 * 测试代码
 */

let node3 = new Node(3, null),
  node2 = new Node(2, node3),
  node1 = new Node(1, node2),
  head = new Node(null, node1);

deleteNode(head, node2);
let node = head.next;
while (node) {
  console.log(node.value);
  node = node.next;
}
```

## 18.2 删除链表中重复的结点

### 解题描述

```js
function ListNode(x) {
  this.val = x;
  this.next = null;
}
function deleteDuplication(pHead) {
  if (pHead === null || pHead.next === null) {
    return pHead;
  }
  const Head = new ListNode(0); // 重要，方便处理第一个、第二个节点就是相同的情况。
  Head.next = pHead;
  let pre = Head;
  let cur = Head.next;
  while (cur !== null) {
    if (cur.next !== null && cur.val === cur.next.val) {
      // 找到最后的一个相同节点,因为相同节点可能重复多个
      while (cur.next !== null && cur.val === cur.next.val) {
        cur = cur.next;
      }
      pre.next = cur.next;
      cur = cur.next;
    } else {
      pre = pre.next;
      cur = cur.next;
    }
  }
  return Head.next;
}

// 测试
const one = new ListNode(1);
const two = new ListNode(2);
const thr1 = new ListNode(3);
const thr2 = new ListNode(3);
const fou1 = new ListNode(4);
const fou2 = new ListNode(4);
const fiv = new ListNode(5);
fou2.next = fiv;
fou1.next = fou2;
thr2.next = fou1;
thr1.next = thr2;
two.next = thr1;
one.next = two;
console.log(deleteDuplication(one));
```

## 19. 正则表达式匹配

请实现一个函数用来匹配包括 '.' 和 '\*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '\*' 表示它前面的字符可以出现任意次(包含 0 次)。

在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab\*ac\*a" 匹配，但是与 "aa.a" 和 "ab\*a" 均不匹配。

### 解题思路

应该注意到，'.' 是用来当做一个任意字符，而 '\*' 是用来重复前面的字符。这两个的作用不同，不能把 '.' 的作用和 '\*' 进行类比，从而把它当成重复前面字符一次。

```js
// 第一种
function match(s, pattern) {
  const reg = new RegExp(`^${pattern}$`);
  return reg.test(s);
}

// 第二种
function matchCore(s, istr, pattern, ipattern) {
  if (istr === s.length && ipattern === pattern.length) {
    return true;
  }

  if (istr !== s.length && ipattern === pattern.length) {
    return false;
  }
  if (pattern[ipattern + 1] === '*') {
    if ((pattern[ipattern] === '.' && istr !== s.length) || pattern[ipattern] === s[istr]) {
      return (
        matchCore(s, istr + 1, pattern, ipattern + 2) ||
        matchCore(s, istr + 1, pattern, ipattern) ||
        matchCore(s, istr, pattern, ipattern + 2)
      );
    }
    return matchCore(s, istr, pattern, ipattern + 2);
  }

  if (s[istr] === pattern[ipattern] || (pattern[ipattern] === '.' && istr !== s.length)) {
    return matchCore(s, istr + 1, pattern, ipattern + 1);
  }
  return false;
}

function match2(s, pattern) {
  if (s === null || pattern === null) {
    return false;
  }
  return matchCore(s, 0, pattern, 0);
}
```
