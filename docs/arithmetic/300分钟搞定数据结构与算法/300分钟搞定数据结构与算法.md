---
layout: CustomPages
title: 前端与数据结构
date: 2020-11-16
aside: false
draft: true
---

# 300 分钟搞定数据结构与算法

## 开篇寄语：算法功底决定 Offer 质量

![](http://s0.lgstatic.com/i/image2/M01/9D/51/CgotOV2td9qAFNJZAAVW-BReZVA180.png)

算法和数据结构最能体现一个人的基本功。基本功扎实的人，无论是做工程还是去做算法，都不会差到哪里去。

考察算法的原因有四:

- 算法能力能够准确辨别一个程序员的技术功底是否扎实；
- 算法能力是发掘程序员的学习能力与成长潜力的关键手段；
- 算法能力能够协助判断程序员在面对新问题时，分析并解决问题的能力；
- 算法能力是设计一个高性能系统的必备基础。

## 第 01 讲：常用数据结构

数据结构是算法的基石，如果没有扎实的数据结构基础，想要把算法学好甚至融会贯通是非常困难的，而优秀的算法又往往取决于你采用哪种数据结构。

所以，接下来两节课的主题是，在算法面试中经常会被用到的数据结构以及一些实用技巧。同时穿插一些经典的题目，加深理解。这节课主要讲：

- 数组、字符串

- 链表

- 栈

- 队列

- 双端队列

- 树

###### 数组、字符串（Array & String）

###### 字符串转化

数组和字符串是最基本的数据结构，在很多编程语言中都有着十分相似的性质，而围绕着它们的算法面试题也是最多的。

很多时候，在分析字符串相关面试题的过程中，我们往往要针对字符串当中的每一个字符进行分析和处理，甚至有时候我们得先把给定的字符串转换成字符数组之后再进行分析和处理。

**举例：**翻转字符串“algorithm”。

![](http://s0.lgstatic.com/i/image2/M01/90/CA/CgoB5l2IRiCATj5LAGJa69BtQRA357.gif)

**解法：**用两个指针，一个指向字符串的第一个字符 a，一个指向它的最后一个字符 m，然后互相交换。交换之后，两个指针向中央一步步地靠拢并相互交换字符，直到两个指针相遇。这是一种比较快速和直观的方法。

**注意：**由于无法直接修改字符串里的字符，所以必须先把字符串变换为数组，然后再运用这个算法。

**数组的优缺点**

要掌握一种数据结构，就必须要懂得分析它的优点和缺点。数组的优点在于：

- 构建非常简单

- 能在 O(1) 的时间里根据数组的下标（index）查询某个元素

而数组的缺点在于：

- 构建时必须分配一段连续的空间

- 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）

- 删除和添加某个元素时，同样需要耗费 O(n) 的时间

所以，当你在考虑是否应当采用数组去辅助你的算法时，请务必考虑它的优缺点，看看它的缺点是否会阻碍你的算法复杂度以及空间复杂度。

**例题分析**

LeetCode 第 242 题：给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。

说明：你可以假设字符串只包含小写字母。

**示例 1**

输入: s = "anagram", t = "nagaram"

输出: true

**示例 2**

输入: s = "rat", t = "car"

输出: false

字母异位词，也就是两个字符串中的相同字符的数量要对应相等。例如，s 等于 “anagram”，t 等于 “nagaram”，s 和 t 就互为字母异位词。因为它们都包含有三个字符 a，一个字符 g，一个字符 m，一个字符 n，以及一个字符 r。而当 s 为 “rat”，t 为 “car”的时候，s 和 t 不互为字母异位词。

**解题思路**

一个重要的前提“假设两个字符串只包含小写字母”，小写字母一共也就 26 个，因此：

1.  可以利用两个长度都为 26 的字符数组来统计每个字符串中小写字母出现的次数，然后再对比是否相等；

2.  可以只利用一个长度为 26 的字符数组，将出现在字符串 s 里的字符个数加 1，而出现在字符串 t 里的字符个数减 1，最后判断每个小写字母的个数是否都为 0。

按上述操作，可得出结论：s 和 t 互为字母异位词。

**建议**：限于篇幅不对此题进行代码剖析，但是这道题非常经典，建议大家到 LeetCode 上试试。

###### 链表（LinkedList）

单链表：链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。

双链表：与单链表不同的是，双链表的每个结点中都含有两个引用字段。

###### 链表的优缺点

链表的优点如下：

- 链表能灵活地分配内存空间；

- 能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。

链表的缺点是：

- 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；

- 查询第 k 个元素需要 O(k) 时间。

**应用场景**：如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。

###### 经典解法

链表是实现很多复杂数据结构的基础，经典解法如下。

**1\. 利用快慢指针（有时候需要用到三个指针）**

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。

**2\. 构建一个虚假的链表头**

一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条 if else 语句。比较简洁的写法是创建一个空的链表头，直接往其后面添加元素即可，最后返回这个空的链表头的下一个节点即可。

**建议：**在解决链表的题目时，可以在纸上或者白板上画出节点之间的相互关系，然后画出修改的方法，既可以帮助你分析问题，又可以在面试的时候，帮助面试官清楚地看到你的思路。

###### 例题分析

LeetCode 第 25 题：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：

- 你的算法只能使用常数的额外空间。

- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：

给定这个链表：1\->2\->3\->4\->5

当 k=2 时，应当返回：2\->1\->4\->3\->5

当 k=3 时，应当返回：3\->2\->1\->4\->5

解题思路

这道题考察了两个知识点：

1.  对链表翻转算法是否熟悉

2.  对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif)

1.  将 curr 指向的下一节点保存到 next 指针；

2.  curr 指向 prev，一起前进一步；

3.  重复之前步骤，直到 k 个元素翻转完毕；

4.  当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。

**注意**：这道题是“LeetCode 第 24 题，两个一组翻转链表“的扩展，即当 k 等于 2 时，第 25 题就变成了第 24 题。

###### 栈（Stack）

特点：栈的最大特点就是后进先出（LIFO）。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。

实现：利用一个单链表来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成。

应用场景：在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。

如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。

**注意**：栈是许多 LeetCode 中等难度偏上的题目里面经常需要用到的数据结构，掌握好它是十分必要的。

###### **例题分析一**

LeetCode 第 20 题：给定一个只包括 '('，')'，'{'，'}'，'\['，'\]' 的字符串，判断字符串是否有效。

有效字符串需满足：

1.  左括号必须用相同类型的右括号闭合。

2.  左括号必须以正确的顺序闭合。

**注意**：空字符串可被认为是有效字符串。

**示例 1**

输入: "()"

输出: true

**示例 2**

输入: "(\]"

输出: false

解题思路

利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。

![](http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRLSATKk3AMg-Ag7s3RA865.gif)

###### **例题分析二**

LeetCode 第 739 题：根据每日气温列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

提示：气温列表 temperatures 长度的范围是 \[1, 30000\]。

**示例**：给定一个数组 T 代表了未来几天里每天的温度值，要求返回一个新的数组 D，D 中的每个元素表示需要经过多少天才能等来温度的升高。

给定 T：\[23, 25, 21, 19, 22, 26, 23\]

返回 D: \[ 1, 4, 2, 1, 1, 0, 0\]

解题思路

第一个温度值是 23 摄氏度，它要经过 1 天才能等到温度的升高，也就是在第二天的时候，温度升高到 24 摄氏度，所以对应的结果是 1。接下来，从 25 度到下一次温度的升高需要等待 4 天的时间，那时温度会变为 26 度。

**思路 1**：最直观的做法就是针对每个温度值向后进行依次搜索，找到比当前温度更高的值，这样的计算复杂度就是 O(n2)。

但是，在这样的搜索过程中，产生了很多重复的对比。例如，从 25 度开始往后面寻找一个比 25 度更高的温度的过程中，经历了 21 度、19 度和 22 度，而这是一个温度由低到高的过程，也就是说在这个过程中已经找到了 19 度以及 21 度的答案，它就是 22 度。

**思路 2**：可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。

![](http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRMSAYv0mAJhTnwV5DmQ777.gif)

1.  对第一个温度 23 度，堆栈为空，把它的下标压入堆栈；

2.  下一个温度 24 度，高于 23 度高，因此 23 度温度升高只需 1 天时间，把 23 度下标从堆栈里弹出，把 24 度下标压入；

3.  同样，从 24 度只需要 1 天时间升高到 25 度；

4.  21 度低于 25 度，直接把 21 度下标压入堆栈；

5.  19 度低于 21 度，压入堆栈；

6.  22 度高于 19 度，从 19 度升温只需 1 天，从 21 度升温需要 2 天；

7.  由于堆栈里保存的是下标，能很快计算天数；

8.  22 度低于 25 度，意味着尚未找到 25 度之后的升温，直接把 22 度下标压入堆栈顶端；

9.  后面的温度与此同理。

该方法只需要对数组进行一次遍历，每个元素最多被压入和弹出堆栈一次，算法复杂度是 O(n)。

利用堆栈，还可以解决如下常见问题：

- 求解算术表达式的结果（LeetCode 224、227、772、770)

- 求解直方图里最大的矩形区域（LeetCode 84）

###### 队列（Queue）

特点：和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。

实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。

应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth\-First Search）是运用队列最多的地方，我们将在第 06 课时中详细介绍。

###### 双端队列（Deque）

特点：双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。

实现：与队列相似，我们可以利用一个双链表实现双端队列。

应用场景：双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目里都有运用。

###### 例题分析

LeetCode 第 239 题：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字，滑动窗口每次只向右移动一位。返回滑动窗口最大值。

**注意：**你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。

**示例：**给定一个数组以及一个窗口的长度 k，现在移动这个窗口，要求打印出一个数组，数组里的每个元素是当前窗口当中最大的那个数。

输入：nums = \[1, 3, \-1, \-3, 5, 3, 6, 7\]，k = 3

输出：\[3, 3, 5, 5, 6, 7\]

###### 解题思路

**思路 1**：移动窗口，扫描，获得最大值。假设数组里有 n 个元素，算法复杂度就是 O(n)。这是最直观的做法。

**思路 2**：利用一个双端队列来保存当前窗口中最大那个数在数组里的下标，双端队列新的头就是当前窗口中最大的那个数。通过该下标，可以很快地知道新的窗口是否仍包含原来那个最大的数。如果不再包含，我们就把旧的数从双端队列的头删除。

因为双端队列能让上面的这两种操作都能在 O(1) 的时间里完成，所以整个算法的复杂度能控制在 O(n)。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRR6AHz-iADMO9EtKhbI610.gif)

1.  初始化窗口 k=3，包含 1，3，\-1，把 1 的下标压入双端队列的尾部；

2.  把 3 和双端队列的队尾的数据逐个比较，3 >1，把 1 的下标弹出，把 3 的下标压入队尾；

3.  \-1<3，\-1 压入双端队列队尾保留到下一窗口进行比较；

4.  3 为当前窗口的最大值；

5.  窗口移动，\-3 与队尾数据逐个比较，\-3<\-1，\-3 压入双端队列队尾保留；

6.  3 为当前窗口的最大值；

7.  窗口继续移动，5>\-3，\-3 从双端队列队尾弹出；

8.  5>\-1，\-1 从队尾弹出；

9.  3 超出当前窗口，从队列头部弹出；

10. 5 压入队列头部，成为当前窗口最大值；

11. 继续移动窗口，操作与上述同理。

窗口最大值只需读取双端队列头部元素。

###### 树（Tree）

树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树。

正因为树有这样的性质，大部分关于树的面试题都与递归有关，换句话说，面试官希望通过一道关于树的问题来考察你对于递归算法掌握的熟练程度。

###### 树的形状

在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N\-ary Tree）。

对于一些特殊的树，例如红黑树（Red\-Black Tree）、自平衡二叉搜索树（AVL Tree），一般在面试中不会被问到，除非你所涉及的研究领域跟它们相关或者你十分感兴趣，否则不需要特别着重准备。

关于树的考题，无非就是要考查树的遍历以及序列化（serialization)。

###### 树的遍历

**1\. 前序遍历（Preorder Traversal）**

方法：先访问根节点，然后访问左子树，最后访问右子树。在访问左、右子树的时候，同样，先访问子树的根节点，再访问子树根节点的左子树和右子树，这是一个不断递归的过程。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRUqAYTBNAHdENl7o0CI095.gif)

应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。

**2\. 中序遍历（Inorder Traversal）**

方法：先访问左子树，然后访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右边。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRWCAF4adALLk-4fku-E775.gif)

应用场景：最常见的是二叉搜索树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。

**3\. 后序遍历（Postorder Traversal）**

方法：先访问左子树，然后访问右子树，最后访问根节点。

![](http://s0.lgstatic.com/i/image2/M01/90/CA/CgoB5l2IRW6AKLrvAL5-qvzxLkw345.gif)

应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。

**注意**：

- 掌握好这三种遍历的递归写法和非递归写法是非常重要的，懂得分析各种写法的时间复杂度和空间复杂度同样重要。

- 无论是前端工程师，还是后端工程师，在准备面试的时候，树这个数据结构都是最应该花时间学习的，既能证明你对递归有很好的认识，又能帮助你学习图论（关于图论，我们将在下一节课一起讨论）。树的许多性质都是面试的热门考点，尤其是二叉搜索树（BST）。

**建议**：练习一道经典的 LeetCode 第 250 题，在一棵二叉树里，统计有多少棵子树，要求子树里面的元素拥有相同的数字。

###### 例题分析

LeetCode 第 230 题：给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

解题思路

这道题考察了两个知识点：

1.  二叉搜索树的性质

2.  二叉搜索树的遍历

二叉搜索树的性质：对于每个节点来说，该节点的值比左孩子大，比右孩子小，而且一般来说，二叉搜索树里不出现重复的值。

二叉搜索树的中序遍历是高频考察点，节点被遍历到的顺序是按照节点数值大小的顺序排列好的。即，中序遍历当中遇到的元素都是按照从小到大的顺序出现。

因此，我们只需要对这棵树进行中序遍历的操作，当访问到第 k 个元素的时候返回结果就好。

![](http://s0.lgstatic.com/i/image2/M01/90/CA/CgoB5l2IRaOAag5tAHlWAofWh6A551.gif)

**注意**：这道题可以变成求解第 K 大的元素，方法就是对这个二叉搜索树进行反向的中序遍历，那么数据的被访问顺序就是由大到小了。

###### 总结

这节课主要讲解算法面试中常用的基本数据结构。掌握好这些数据结构是基础，绝大部分的算法面试题都得靠它们来帮忙，因此，一定要花功夫勤练题目来深入理解它们。

下一节课将讲解相对高级的数据结构，对应解决的是许多中等难度以上的面试题目。

## 第 02 讲：高级数据结构

上一课时主要讲解了一些常用的数据结构和它们的使用技巧，以及一些经典的例题。

然而，仅仅掌握好它们不足以应付大厂的算法面试的。为了达到对时间和空间复杂度的理想要求，本节课探究高级数据结构，它们的实现要比那些常用的数据结构要复杂得多。其中重点介绍：

- 优先队列

- 图

- 前缀树

- 线段树

- 树状数组

掌握好高级数据结构的性质以及所适用的场合，在分析问题的时候回归本质，很多题目都能迎刃而解。

###### 优先队列（Priority Queue）

###### 特点

能保证每次取出的元素都是队列中优先级别最高的。优先级别可以是自定义的，例如，数据的数值越大，优先级越高；或者数据的数值越小，优先级越高。优先级别甚至可以通过各种复杂的计算得到。

###### 应用场景

从一堆杂乱无章的数据当中按照一定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据。

**举例**：任意一个数组，找出前 k 大的数。

**解法 1**：先对这个数组进行排序，然后依次输出前 k 大的数，复杂度将会是 O(nlogn)，其中，n 是数组的元素个数。这是一种直接的办法。

**解法 2**：使用优先队列，复杂度优化成 O(k + nlogk)。

当数据量很大（即 n 很大），而 k 相对较小的时候，显然，利用优先队列能有效地降低算法复杂度。因为要找出前 k 大的数，并不需要对所有的数进行排序。

###### 实现

优先队列的本质是一个二叉堆结构。堆在英文里叫 Binary Heap，它是利用一个数组结构来实现的完全二叉树。换句话说，优先队列的本质是一个数组，数组里的每个元素既有可能是其他元素的父节点，也有可能是其他元素的子节点，而且，每个父节点只能有两个子节点，很像一棵二叉树的结构。

牢记下面优先队列有三个重要的性质。

1\. 数组里的第一个元素 array\[0\] 拥有最高的优先级别。

2\. 给定一个下标 i，那么对于元素 array\[i\] 而言：

- 它的父节点所对应的元素下标是 (i\-1)/2

- 它的左孩子所对应的元素下标是 2×i + 1

- 它的右孩子所对应的元素下标是 2×i + 2

3\. 数组里每个元素的优先级别都要高于它两个孩子的优先级别。

优先队列最基本的操作有两个。

**1\. 向上筛选（sift up / bubble up）**

- 当有新的数据加入到优先队列中，新的数据首先被放置在二叉堆的底部。

- 不断进行向上筛选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止。

  ![](http://s0.lgstatic.com/i/image2/M01/90/EC/CgotOV2ISXaAJ9iGACXUNreouXo038.gif)

时间复杂度：由于二叉堆是一棵完全二叉树，并假设堆的大小为 k，因此整个过程其实就是沿着树的高度往上爬，所以只需要 O(logk) 的时间。

**2\. 向下筛选（sift down / bubble down）**

- 当堆顶的元素被取出时，要更新堆顶的元素来作为下一次按照优先级顺序被取出的对象，需要将堆底部的元素放置到堆顶，然后不断地对它执行向下筛选的操作。

- 将该元素和它的两个孩子节点对比优先级，如果优先级最高的是其中一个孩子，就将该元素和那个孩子进行交换，然后反复进行下去，直到无法继续交换为止。

  ![](http://s0.lgstatic.com/i/image2/M01/90/CC/CgoB5l2ISa-Af-7tAB97MaSBBWo211.gif)

时间复杂度：整个过程就是沿着树的高度往下爬，所以时间复杂度也是 O(logk)。

因此，无论是添加新的数据还是取出堆顶的元素，都需要 O(logk) 的时间。

###### 初始化

优先队列的初始化是一个最重要的时间复杂度，是分析运用优先队列性能时必不可少的，也是经常容易弄错的地方。

**举例**：有 n 个数据，需要创建一个大小为 n 的堆。

**误区**：每当把一个数据加入到堆里，都要对其执行向上筛选的操作，这样一来就是 O(nlogn)。

**解法**：在创建这个堆的过程中，二叉树的大小是从 1 逐渐增长到 n 的，所以整个算法的复杂度经过推导，最终的结果是 O(n)。

       ![](http://s0.lgstatic.com/i/image2/M01/90/B0/CgoB5l2ILXuAYVN6AAAwD4S9aDs940.png)

**注意**：算法面试中是不要求推导的，你只需要记住，初始化一个大小为 n 的堆，所需要的时间是 O(n) 即可。

###### 例题分析

LeetCode 第 347 题：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

说明：

- 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。

- 你的算法的时间复杂度必须优于 O(nlogn) ，n 是数组的大小

**示例：**car，car，book，desk，desk，desk

###

解题思路

这道题的输入是一个字符串数组，数组里的元素可能会重复一次甚至多次，要求按顺序输出前 k 个出现次数最多的字符串。

解这类求"前 k 个"的题目，关键是看如何定义优先级以及优先队列中元素的数据结构。

- 题目中有”前 k 个“这样的字眼，应该很自然地联想到优先队列。

- 优先级别可以由字符串出现的次数来决定，出现的次数越多，优先级别越高，反之越低。

- 统计词频的最佳数据结构就是哈希表（Hash Map），利用一个哈希表，就能快速地知道每个单词出现的次数。

- 将单词和其出现的次数作为一个新的对象来构建一个优先队列，那么这个问题就很轻而易举地解决了。

**建议**：这道题是利用优先队列处理问题的典型，建议好好练习。

** Desk (3)**

** / \\**

** car(2) book(1)**

###### 图（Graph）

###### 基本知识点

图可以说是所有数据结构里面知识点最丰富的一个，最基本的知识点如下。

- 阶（Order）、度：出度（Out\-Degree）、入度（In\-Degree）

- 树（Tree）、森林（Forest）、环（Loop）

- 有向图（Directed Graph）、无向图（Undirected Graph）、完全有向图、完全无向图

- 连通图（Connected Graph）、连通分量（Connected Component）

- 存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）

围绕图的算法也是五花八门。

- 图的遍历：深度优先、广度优先

- 环的检测：有向图、无向图

- 拓扑排序

- 最短路径算法：Dijkstra、Bellman\-Ford、Floyd Warshall

- 连通性相关算法：Kosaraju、Tarjan、求解孤岛的数量、判断是否为树

- 图的着色、旅行商问题等

以上的知识点只是图论里的冰山一角，对于算法面试而言，完全不需要对每个知识点都一一掌握，而应该有的放矢地进行准备。

###### 必会知识点

根据长期的经验总结，以下的知识点是必须充分掌握并反复练习的。

- 图的存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）

- 图的遍历：深度优先、广度优先

- 二部图的检测（Bipartite）、树的检测、环的检测：有向图、无向图

- 拓扑排序

- 联合\-查找算法（Union\-Find）

- 最短路径：Dijkstra、Bellman\-Ford

其中，环的检测、二部图的检测、树的检测以及拓扑排序都是基于图的遍历，尤其是深度优先方式的遍历。而遍历可以在邻接矩阵或者邻接链表上进行，所以掌握好图的遍历是重中之重！因为它是所有其他图论算法的基础。

至于最短路径算法，能区分它们的不同特点，知道在什么情况下用哪种算法就很好了。对于有充足时间准备的面试者，能熟练掌握它们的写法当然是最好的。

**建议**：LeetCode 里边有许多关于图论的算法题，而且都是非常经典的题目，可以通过练习解题来熟练掌握必备知识。

###### 例题分析

LeetCode 第 785 题：给定一个无向图 graph，当这个图为二部图时返回 true。

提示：如果能将一个图的节点集合分割成两个独立的子集 A 和 B，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为二部图。

###

解题思路

判断一个给定的任意图是否为二部图，就必须要对该图进行一次遍历：

- 深度优先

- 广度优先

（关于深度优先和广度优先算法，将在第 06 节课进行详细讨论）。

二部图，图的所有顶点可以分成两个子集 U 和 V，子集里的顶点互不直接相连，图里面所有的边，一头连着子集 U 里的顶点，一头连着子集 V 里的顶点。

![](http://s0.lgstatic.com/i/image2/M01/90/EC/CgotOV2ISc-ADjNDAK_6wbp-nzI430.gif)

1.  给图里的顶点涂上颜色，子集 U 里的顶点都涂上红色，子集 V 里的顶点都涂上蓝色。

2.  开始遍历这个图的所有顶点，想象一下手里握有红色和蓝色的画笔，每次交替地给遍历当中遇到的顶点涂上颜色。

3.  如果这个顶点还没有颜色，那就给它涂上颜色，然后换成另外一支画笔。

4.  下一个顶点，如果发现这个顶点已经涂上了颜色，而且颜色跟我手里画笔的颜色不同，那么表示这个顶点它既能在子集 U 里，也能在子集 V 里。

5.  所以，它不是一个二部图。

###### 前缀树（Trie）

###### 应用场景

前缀树被广泛地运用在字典查找当中，也被称为字典树。

**举例**：给定一系列字符串，这些字符串构成了一种字典，要求你在这个字典当中找出所有以“ABC”开头的字符串。

**解法 1**：暴力搜索

直接遍历一遍字典，然后逐个判断每个字符串是否由“ABC”开头。假设字典很大，有 N 个单词，要对比的不是“ABC”，而是任意的，那不妨假设所要对比的开头平均长度为 M，那么时间复杂度是 O(M×N)。

**解法 2**：前缀树

如果用前缀树头帮助对字典的存储进行优化，那么可以把搜索的时间复杂度下降为 O(M)，其中 M 表示字典里最长的那个单词的字符个数，在很多情况下，字典里的单词个数 N 是远远大于 M 的。因此，前缀树在这种场合中是非常高效的。

###### 经典应用

1.  网站上的搜索框会罗列出以搜索文字作为开头的相关搜索信息，这里运用了前缀树进行后端的快速检索。

2.  汉字拼音输入法的联想输出功能也运用了前缀树。

**举例**：假如有一个字典，字典里面有如下词："A"，"to"，"tea"，"ted"，"ten"，"i"，"in"，"inn"，每个单词还能有自己的一些权重值，那么用前缀树来构建这个字典将会是如下的样子：

       ![](http://s0.lgstatic.com/i/image2/M01/90/D0/CgotOV2ILXyAAbuPAAHuMjoQ0_M307.png)

###### 性质

1. 每个节点至少包含两个基本属性。

- children：数组或者集合，罗列出每个分支当中包含的所有字符

- isEnd：布尔值，表示该节点是否为某字符串的结尾

2\. 前缀树的根节点是空的

所谓空，即只利用到这个节点的 children 属性，即只关心在这个字典里，有哪些打头的字符。

3\. 除了根节点，其他所有节点都有可能是单词的结尾，叶子节点一定都是单词的结尾。

###### 实现

前缀树最基本的操作就是两个：创建和搜索。

**1\. 创建**

- 遍历一遍输入的字符串，对每个字符串的字符进行遍历

- 从前缀树的根节点开始，将每个字符加入到节点的 children 字符集当中。

- 如果字符集已经包含了这个字符，则跳过。

- 如果当前字符是字符串的最后一个，则把当前节点的 isEnd 标记为真。

由上，创建的方法很直观。

前缀树真正强大的地方在于，每个节点还能用来保存额外的信息，比如可以用来记录拥有相同前缀的所有字符串。因此，当用户输入某个前缀时，就能在 O(1) 的时间内给出对应的推荐字符串。

**2\. 搜索**

与创建方法类似，从前缀树的根节点出发，逐个匹配输入的前缀字符，如果遇到了就继续往下一层搜索，如果没遇到，就立即返回。

##

例题分析

LeetCode 第 212 题：给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。

![](http://s0.lgstatic.com/i/image2/M01/90/B0/CgoB5l2ILXyAYLwPAAAO6ajgsHk324.png)

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

说明：你可以假设所有输入都由小写字母 a\-z 组成。

###

解题思路

这是一道出现较为频繁的难题，题目给出了一个二维的字符矩阵，然后还给出了一个字典，现在要求在这个字符矩阵中找到出现在字典里的单词。

由于字符矩阵的每个点都能作为一个字符串的开头，所以必须得尝试从矩阵中的所有字符出发，上下左右一步步地走，然后去和字典进行匹配，如果发现那些经过的字符能组成字典里的单词，就把它记录下来。

可以借用深度优先的算法来实现（关于深度优先算法，将在第 06 节课深入探讨），如果你对它不熟悉，可以把它想象成走迷宫。

![](http://s0.lgstatic.com/i/image2/M01/90/CD/CgoB5l2IShaAfIDFAAElACD4d7I232.png)

**字典匹配的解法 1**：每次都循环遍历字典，看看是否存在字典里面，如果把输入的字典变为哈希集合的话，似乎只需要 O(1) 的时间就能完成匹配。

但是，这样并不能进行前缀的对比，即，必须每次都要进行一次全面的深度优先搜索，或者搜索的长度为字典里最长的字符串长度，这样还是不够高效。

**字典匹配的解法 2**：对比字符串的前缀，借助前缀树来重新构建字典。

假如在矩阵里遇到了一个字符”V”，而字典里根本就没有以“V”开头的字符串，则不需要将深度优先搜索进行下去，可以大大地提高搜索效率。

构建好了前缀树之后，每次从矩阵里的某个字符出发进行搜索的时候，同步地对前缀树进行对比，如果发现字符一直能被找到，就继续进行下去，一步一步地匹配，直到在前缀树里发现一个完整的字符串，把它输出即可。

###### 线段树（Segment Tree）

**举例**：假设有一个数组 array\[0 … n\-1\]， 里面有 n 个元素，现在要经常对这个数组做两件事。

1.  更新数组元素的数值

2.  求数组任意一段区间里元素的总和（或者平均值）

**解法 1**：遍历一遍数组。

- 时间复杂度 O(n)。

**解法 2**：线段树。

- 线段树，就是一种按照二叉树的形式存储数据的结构，每个节点保存的都是数组里某一段的总和。

- 适用于数据很多，而且需要频繁更新并求和的操作。

- 时间复杂度 O(logn)。

###### 实现

**举例**：数组是 \[1, 3, 5, 7, 9, 11\]，那么它的线段树如下。

       ![](http://s0.lgstatic.com/i/image2/M01/90/D0/CgotOV2ILX2AB5E_AABPrKDb2WM573.png)

根节点保存的是从下标 0 到下标 5 的所有元素的总和，即 36。左右两个子节点分别保存左右两半元素的总和。按照这样的逻辑不断地切分下去，最终的叶子节点保存的就是每个元素的数值。

**解法**：

1\. 更新数组里某个元素的数值

从线段树的根节点出发，更新节点的数值，它保存的是数组元素的总和。修改的元素有可能会落在线段树里一些区间里，至少叶子节点是肯定需要更新的，所以，要做的是从根节点往下，判断元素的下标是否在左边还是右边，然后更新分支里的节点大小。因此，复杂度就是遍历树的高度，即 O(logn)。

2\. 对数组某个区间段里的元素进行求和

方法和更新操作类似，首先从根节点出发，判断所求的区间是否落在节点所代表的区间中。如果所要求的区间完全包含了节点所代表的区间，那么就得加上该节点的数值，意味着该节点所记录的区间总和只是所要求解总和的一部分。接下来，不断地往下寻找其他的子区间，最终得出所要求的总和。

**建议**：线段树的实现书写起来有些繁琐，需要不断地练习。

###### 例题分析

######

LeetCode 第 315 题：给定一个整数数组 nums，按要求返回一个新数组 counts，使得数组 counts 有该性质——counts\[i\] 的值是 nums\[i\] 右侧小于 nums\[i\] 的元素的数量。

**示例**

输入：\[5, 2, 6, 1\]

输出：\[2, 1, 1, 0\]

**解释**

5 的右侧有 2 个更小的元素（2 和 1）

2 的右侧仅有 1 个更小的元素（1）

6 的右侧有 1 个更小的元素（1）

1 的右侧有 0 个更小的元素

###

解题思路

给定一个数组 nums，里面都是一些整数，现在要求打印输出一个新的数组 counts，counts 数组的每个元素 counts\[i\] 表示 nums 中第 i 个元素右边有多少个数小于 nums\[i\]。

例如，输入数组是 \[5, 2, 6, 1\]，应该输出的结果是 \[2, 1, 1, 0\]。

因为，对于 5，右边有两个数比它小，分别是 2 和 1，所以输出的结果中，第一个元素是 2；对于 2，右边只有 1 比它小，所以第二个元素是 1，类推。

如果使用线段树解法，需要理清线段树的每个节点应该需要包含什么样的信息。

线段树每个节点记录的区间是数组下标所形成的区间，然而对于这道题，因为要统计的是比某个数还要小的数的总和，如果把分段的区间设计成按照数值的大小来划分，并记录下在这个区间中的数的总和，就能快速地知道比当前数还要小的数有多少个。

![](http://s0.lgstatic.com/i/image2/M01/90/ED/CgotOV2IStmAJxNFAHcB4XzkqCg286.gif)

1\. 首先，让从线段树的根节点开始，根节点记录的是数组里最小值到最大值之间的所有元素的总和，然后分割根节点成左区间和右区间，不断地分割下去。

2\. 初始化，每个节点记录的在此区间内的元素数量是 0，接下来从数组的最后一位开始往前遍历，每次遍历，判断这个数落在哪个区间，那么那个区间的数量加一。

3\. 遇到 1，把它加入到线段树里，此时线段树里各个节点所统计的数量会发生变化。

4\. 当前所遇到的最小值就是 1。

5. 把 6 加入到线段树里。

6\. 求比 6 小的数有多少个，即查询线段树，从 1 到 5 之间有多少个数。

7\. 从根节点开始查询。由于所要查询的区间是 1 到 5，无法包含根节点的区间 1 到 6，所以继续往下查询。

8\. 左边，区间 1 到 3 被完全包含在 1 到 5 之间，把该节点所统计好的数返回。

9\. 右边，区间 1 到 5 跟区间 4 到 6 有交叉，继续往下看，区间 4 到 5 完全被包含在 1 到 5 之间，所以可以马上返回，并把统计的数量相加。

10\. 最后得出，在当前位置，在 6 的右边比 6 小的数只有一个。

通过这样的方法，每次把当前的数用线段树进行个数统计，然后再计算出比它小的数即可。算法复杂度是 O(nlogm)。

###### 树状数组（Fenwick Tree / Binary Indexed Tree）

###### 实现

**举例**：假设有一个数组 array\[0 … n\-1\]， 里面有 n 个元素，现在要经常对这个数组做两件事。

1.  更新数组元素的数值

2.  求数组前 k 个元素的总和（或者平均值）

**解法 1**：线段树。

- 线段树能在 O(logn) 的时间里更新和求解前 k 个元素的总和。

**解法 2**：树状数组。

- 该问题只要求求解前 k 个元素的总和，并不要求任意一个区间。

- 树状数组可以在 O(logn) 的时间里完成上述的操作。

- 相对于线段树的实现，树状数组显得更简单。

###### 特点

树状数组的数据结构有以下几个重要的基本特征。

1.  它是利用数组来表示多叉树的结构，在这一点上和优先队列有些类似，只不过，优先队列是用数组来表示完全二叉树，而树状数组是多叉树。

2.  树状数组的第一个元素是空节点。

3.  如果节点 tree\[y\] 是 tree\[x\] 的父节点，那么需要满足条件：y = x \- (x & (\-x))。

**建议**：由于树状数组所解决的问题跟线段树有些类似，所以不花篇幅进行问题的讨论。LeetCode 上有很多经典的题目可以用树状数组来解决，比如 LeetCode 第 308 题，求一个动态变化的二维矩阵里，任意子矩阵里的数的总和。

###### 总结

这节课讲解了一些高级的数据结构。

1\. 优先队列

经常出现在考题里的，它的实现过程比较繁琐，但是很多编程语言里都有它的实现，所以在解决面试中的问题时，实行“拿来主义”即可。

鼓励你自己练习实现一个优先队列，在实现它的过程中更好地去了解它的结构和特点。

2\. 图

被广泛运用的数据结构，很多涉及大数据的问题都得运用到图论的知识。

比如在社交网络里，每个人可以用图的顶点表示，人与人直接的关系可以用图的边表示；再比如，在地图上，要求解从起始点到目的地，如何行驶会更快捷，需要运用图论里的最短路径算法。

3\. 前缀树

出现在许多面试的难题当中。

因为很多时候你得自己实现一棵前缀树，所以你要能熟练地书写它的实现以及运用它。

4\. 线段树和树状数组

应用场合比较明确。

例如，问题变为在一幅图片当中修改像素的颜色，然后求解任意矩形区间的灰度平均值，那么可以考虑采用二维的线段树了。

**建议**：LeetCode 平台上，针对上面的这些高级数据结构都有丰富的题目，希望你能用功学习。

下节课的主题是“面试中常用的算法”。
