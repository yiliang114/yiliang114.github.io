---
title: 手写
date: 2020-11-22
draft: true
---

## 前端算法

- 数组去重（对象、非对象）
- 大数相加
- url 解析
- event class

### 深拷贝

```js
function assignDeep(target, ...sources) {
  for (let source of sources) {
    for (let key in source) {
      if (isObject(source[key])) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        assignDeep(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}

function isObject(a) {
  return typeof a === 'object' && a !== null;
}
```

### 防抖、节流

有立即执行和非立即执行版。lodash 的话， debounce 第三个参数给一个对象，{ leading: true }, 表示立即执行版本。

#### debounce

```js
// 非最好
function debounce(fn, delay = 0) {
  // keep track of the last call to the debounced function
  let last = {
    time: null,
    timerId: null,
  };

  // return a debounced version of fn
  return () => {
    let time = Date.now();

    // if the debounced function was called again before the delay elapsed,
    // cancel the timer (started in the previous call) that would have called
    // fn, and start a new timer.
    if (last.time && time - last.time < delay) {
      clearTimeout(last.timerId);
    }

    // start a timer to call fn after the given delay
    last = {
      time,
      timerId: setTimeout(fn, delay),
    };
  };
}
```

#### throttle and debounce

```js
// 节流throttle，多次触发但只执行一部分，(恒时间间距执行)
function throttle(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    if (!timer) {
      timer = setTimeout(function() {
        timer = null;
        method.apply(ctx, args);
      }, threshold);
    }
  };
}

// 防抖debounce, 多次触发但只执行一次，(时间差大于阈值才执行)
function debounce(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    timer && clearTimeout(timer);
    timer = setTimeout(function() {
      method.apply(ctx, args);
    }, threshold);
  };
}

// 轮循函数
// usage: wait(fn.bind(ctx, ...args), 10000);
function wait(fn, timeout, tick) {
  timeout = timeout || 5000;
  tick = tick || 250;
  var timeoutTimer = null;
  var execTimer = null;

  return new Promise(function(resolve, reject) {
    timeoutTimer = setTimeout(function() {
      clearTimeout(execTimer);
      reject(new Error('polling fail because timeout'));
    }, timeout);

    tickHandler(fn);

    function tickHandler(fn) {
      var ret = fn();
      if (!ret) {
        execTimer = setTimeout(function() {
          tickHandler(fn);
        }, tick);
      } else {
        clearTimeout(timeoutTimer);
        resolve();
      }
    }
  });
}

var n = 1;
wait(
  function() {
    console.log(n++);
    return n > 10;
  },
  2000,
  300,
)
  .then(function() {
    console.log('===== end ====');
  })
  .catch(function(err) {
    console.error('error', err);
  });
```

### Event

```js
const Noop = () => {};

class EventEmitter {
  constructor() {
    this.events = [];
  }

  on(event, handler = Noop) {
    if (typeof this.events[event] === 'undefined') {
      this.events[event] = [handler];
    } else {
      this.events[event].push(handler);
    }
  }

  once(event, handler = Noop) {
    const once = `once_${event}`;
    if (typeof this.events[once] === 'undefined') {
      this.events[once] = [handler];
    } else {
      this.events[once].push(handler);
    }
  }

  emit(event, args) {
    const once = `once_${event}`;
    if (typeof this.events[once] !== 'undefined') {
      this.events[once].forEach(handler => {
        handler(args);
      });
      delete this.events[`once_${event}`];
    }
    if (typeof this.events[event] !== 'undefined') {
      this.events[event].forEach(handler => {
        handler(args);
      });
    }
  }

  off(event, handler) {
    if (typeof this.events[event] !== 'undefined') {
      if (!!handler) {
        const index = this.events[event].indexOf(handler);
        this.events[event].splice(index, 1);
      } else {
        delete this.events[event];
      }
    }
  }
}

function test() {
  const eh = new EventEmitter();

  const firstHd = str => {
    console.log('first greet: ', str);
  };

  eh.on('greet', firstHd);

  eh.on('greet', str => {
    console.log('second greet: ', str);
  });

  eh.on('bye', name => {
    console.log(name + ', goodbye!');
  });

  eh.once('break', str => {
    console.log(`once break: ${str}`);
  });
  eh.on('break', str => {
    console.log(`on break: ${str}`);
  });

  console.log('======  start  ======');
  eh.emit('greet', 'Green');
  eh.emit('bye', 'Mark');
  eh.emit('break', 'Jack');
  eh.emit('break', 'Tony');

  console.log('======  removeListener  ======');
  eh.off('bye');
  eh.emit('bye', 'Mark');

  eh.off('greet', firstHd);
  eh.emit('greet', 'Green');
}

test();
```
