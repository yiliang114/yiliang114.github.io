---
layout: CustomPages
title: 动态规划-DP-台阶问题
date: 2020-11-14
aside: false
draft: true
---

# 台阶问题

> 假设一个楼梯有 n 个阶台阶，人每次最多可以跨 m 个台阶，编写函数 fn(n, m)输出所有的爬楼梯方案。

还是先手动走下流程：

例如楼梯总共有 4 个台阶，人每次最多跨 3 个台阶，也就是说人每次可以走 1 个
、2 个或者 3 个台阶，那么楼梯总共有这么几种走法：31, 22, 211, 13, 121, 112, 1111。

流程分析一下：

1. 当前有 n 个台阶，如果 n>m 则先用最大步数 m 去走, 再换 m-1，再换 m-2 直到 1；如果 n<m，那么就先用 n 去走，然后换 n-1、n-2。。。
2. 走完 1 之后剩下的台阶再用 1 的规则去套。。。

退出条件是什么呢？n=0 时，代表一个走法走完了。

总结：
for [1 m]:
if (n == 1): step = 1
if (n < m): go(n, n)
if (n >= m): step = m, go(n-m, m)

## Code

```js
// 对动态规划，做个总结，我们从一个例子开始：
// 有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。
// 比如，每次走1级台阶，一共走10步，这是其中一种走法。我们可以简写成 1, 1, 1, 1, 1, 1, 1, 1, 1, 1。
// 再比如，每次走2级台阶，一共走5步，这是另一种走法。我们可以简写成 2, 2, 2, 2, 2。
// 当然，除此之外，还有很多很多种走法。
// 这里就要用到了动态规划的思想了：动态规划(Dynamic Programming)是一种分阶段求解决策问题的数学思想。总结起来就是一句话，大事化小，小事化了。
// 我们用动态规划问题来看看上述的问题吧：
// 问题建模：
// 假如只差一步就能走完整个楼梯，要分为几种情况？因为每一步能走一级或者两级台阶，所以有如下两种情况：
// 1.最后一步走2级台阶，也就是从8级到10级
// 2.最后一步走1级台阶，也就是从9级到10级
// 那么在上面的基础上假设1级到8级有X种走法，1级到9级有Y种走法，那么1级到10级有几种走法？
// 实际上，10级台阶的所有走法可以根据最后一步的不同分为两个部分。
// 第一部分：最后一步从9级到10级，这种走法的数量和1级到9级的数量一致，也就是Y种。
// 第二部分：最后一步从8级到10级，这种走法的数量和1级到8级的数量一致，也就是X种。
// 总的走法就是两种走法的总和，也就是SUM = X + Y种。
// 我们把10级台阶的走法表达为F(10)此时:
// F(10) = F(9) + F(8)
// F(9) = F(8) + F(7)
// F(8) = F(7) + F(6)
// ...
// F(3) = F(2) + F(1)
// 看到没，我们把一个复杂的问题分阶段分步的简化，简化成简单的问题，这就是动态规划的思想。
// 当只有1级台阶和2级台阶时走法很明显，即F(1) = 1、F(2) = 2，可以归纳出如下公式：
// F(n) = F(n - 1) + F(n - 2)(n >= 3);
// F(2) = 2;
// F(1) = 1;
// 动态规划中包含三个重要的概念，最优子结构、边界、状态转移公式。
// 上面我们分析出F(10) = F(9) + F(8) ， 其中，F(9)和F(8)是F(10)的最优子结构。
// 当只有1级和2级台阶时，我们可以直接得出结果，而无需再次简化。我们称F(2)和F(1)是问题的"边界"，如果一个问题没有边界，那么这个问题就没有有限解。
// F(n) = F(n - 1) + F(n - 2)是阶段之间的状态转移公式，它是动态规划的核心，决定了问题的每个阶段和下阶段之间的关系。
// 至此，动态规划的“问题建模就完成了”。

const countStep = num => {
  if (num < 0) return;
  return num <= 2 && num >= 0 ? num : countStep(num - 1) + countStep(num - 2);
};

const cached = {};
const countStepCached = num => {
  if (num < 0) return;
  if (cached[num]) {
    return cached[num];
  } else {
    const resp = num <= 2 && num >= 0 ? num : countStepCached(num - 1) + countStepCached(num - 2);
    cached[num] = resp;
    return resp;
  }
};

const compare = num => {
  console.log('No.' + num + ' start ...');
  console.log('======');

  console.time('countStep');
  console.log('countStep result: ', countStep(num));
  console.timeEnd('countStep');
  console.time('countStepCached');
  console.log('countStepCached result: ', countStepCached(num));
  console.timeEnd('countStepCached');

  console.log('======');
  console.log('');
};

compare(10);
compare(20);
compare(30);
```
