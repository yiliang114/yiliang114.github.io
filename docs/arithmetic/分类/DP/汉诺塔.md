---
layout: CustomPages
title: 动态规划-汉诺塔
date: 2020-11-15
aside: false
draft: true
---

# Tower of Hanoi

The Tower of Hanoi (also called the Tower of Brahma or Lucas'
Tower and sometimes pluralized) is a mathematical game or puzzle.
It consists of three rods and a number of disks of different sizes,
which can slide onto any rod. The puzzle starts with the disks in
a neat stack in ascending order of size on one rod, the smallest
at the top, thus making a conical shape.

The objective of the puzzle is to move the entire stack to another
rod, obeying the following simple rules:

- Only one disk can be moved at a time.
- Each move consists of taking the upper disk from one of the
  stacks and placing it on top of another stack or on an empty rod.
- No disk may be placed on top of a smaller disk.

![Hanoi Tower](https://upload.wikimedia.org/wikipedia/commons/8/8d/Iterative_algorithm_solving_a_6_disks_Tower_of_Hanoi.gif)

Animation of an iterative algorithm solving 6-disk problem

With `3` disks, the puzzle can be solved in `7` moves. The minimal
number of moves required to solve a Tower of Hanoi puzzle
is `2^n − 1`, where `n` is the number of disks.

## Code

```js
/**
 * @param {number} numberOfDiscs
 * @param {Stack} fromPole
 * @param {Stack} withPole
 * @param {Stack} toPole
 * @param {function(disc: number, fromPole: number[], toPole: number[])} moveCallback
 */
function hanoiTowerRecursive({ numberOfDiscs, fromPole, withPole, toPole, moveCallback }) {
  if (numberOfDiscs === 1) {
    // Base case with just one disc.
    moveCallback(fromPole.peek(), fromPole.toArray(), toPole.toArray());
    const disc = fromPole.pop();
    toPole.push(disc);
  } else {
    // In case if there are more discs then move them recursively.

    // Expose the bottom disc on fromPole stack.
    hanoiTowerRecursive({
      numberOfDiscs: numberOfDiscs - 1,
      fromPole,
      withPole: toPole,
      toPole: withPole,
      moveCallback,
    });

    // Move the disc that was exposed to its final destination.
    hanoiTowerRecursive({
      numberOfDiscs: 1,
      fromPole,
      withPole,
      toPole,
      moveCallback,
    });

    // Move temporary tower from auxiliary pole to its final destination.
    hanoiTowerRecursive({
      numberOfDiscs: numberOfDiscs - 1,
      fromPole: withPole,
      withPole: fromPole,
      toPole,
      moveCallback,
    });
  }
}

/**
 * @param {number} numberOfDiscs
 * @param {function(disc: number, fromPole: number[], toPole: number[])} moveCallback
 * @param {Stack} [fromPole]
 * @param {Stack} [withPole]
 * @param {Stack} [toPole]
 */
export default function hanoiTower({
  numberOfDiscs,
  moveCallback,
  fromPole = new Stack(),
  withPole = new Stack(),
  toPole = new Stack(),
}) {
  // Each of three poles of Tower of Hanoi puzzle is represented as a stack
  // that might contain elements (discs). Each disc is represented as a number.
  // Larger discs have bigger number equivalent.

  // Let's create the discs and put them to the fromPole.
  for (let discSize = numberOfDiscs; discSize > 0; discSize -= 1) {
    fromPole.push(discSize);
  }

  hanoiTowerRecursive({
    numberOfDiscs,
    fromPole,
    withPole,
    toPole,
    moveCallback,
  });
}
```

## 汉诺塔问题

> 汉诺塔：汉诺塔(又称河内塔)问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

这里要构造一个输出移动过程的函数`move(n, a, b, c)`，其中 n 为 a 柱子的数量，a, b, c 分别代表三根柱子，a 为源柱子、b 为过渡柱子、c 为目标柱子。

函数调用方式：'A'柱子有 5 个盘子，全移动到'C'，调用(5, 'A', 'B', 'C')；全移动到'B'，则调用(5, 'A', 'C', 'B');

使用递归的思路，自然就是想着从最后一步倒推 n-1 步了。当我们手动尝试了 n=[1, 4]的情况后，基本就知道这个套路应该是怎样的了。

1. 当我们要移动 a 柱子的最大盘子 n 到 c 的话，那这一步的前提肯定是：比 n 小的盘子都在 b 上，我们才能将 n 号盘从 a --> c，这个场景也就是 n=1 的情况。
2. 接着就是如何将 b 中的 n-1 号盘移动到 c 呢？这一步就不用考虑 n 号盘了，因为他已经就位了，那这一步前提肯定是，比 n-1 小的盘子都在 a 上了，咦，这里不就是 1 的翻版吗？递归的规律已经出来了。
3. 然后想想怎么才能得到 1 这种局面呢？显然，就是要将 n-1 个盘子从 a 移动到 b 上面，怎么做？重复 1 和 2 不就完了？

所以盘子移动的套路就是：

1. 将 n-1 个盘子从 a 移动到 b：`move(n-1, a, c, b)`
2. 将 n 号盘从 a 移动到 c：`move(1, a, b, c)`
3. 将 n-1 个盘子从 b 移动到 c：`move(n-1, b, a, c)`

退出条件？n=1 呗，n=1 的时候，那自然就是`a --> c`了

总结：

```py
if n == 1: `a --> c`
else: move(n-1, a, c, b) move(1, a, b, c) move(n-1, b, a, c)
```
