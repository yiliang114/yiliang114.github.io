---
layout: CustomPages
title: 数据结构
date: 2020-08-31
aside: false
draft: true
---

# 数据结构

算法和数据结构最能体现一个人的基本功。考察算法的原因有四:

1. 算法能力能够准确辨别一个程序员的技术功底是否扎实；
2. 算法能力是发掘程序员的学习能力与成长潜力的关键手段；
3. 算法能力能够协助判断程序员在面对新问题时，分析并解决问题的能力；
4. 算法能力是设计一个高性能系统的必备基础。

## 简介

10 个数据结构: 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树;
10 个算法: 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

## 常用数据结构

- 线性表
  - 数组
  - 链表
    - 单链表
    - 双向链表
    - 循环链表
    - 双向循环链表
    - 静态链表
  - 栈
    - 顺序栈
    - 链式栈
  - 队列
    - 普通队列
    - 双端队列
    - 阻塞队列
    - 并发队列
- 树
  - 二叉树
    - 平衡二叉树
    - 二叉查找树
    - 平衡二叉树
      - AVL 树
      - 红黑树
    - 完全二叉树
    - 满二叉树
  - 多路查找树
    - B 树
    - B+ 树
    - 2-3 树
    - 2-3-4 树
  - 堆
    - 小顶堆
    - 大顶堆
    - 优先级队列
    - 斐波那契
    - 二顶堆
  - 其他
    - 树状数组
    - 线段树
- 图
  - 图的存储
    - 邻接矩阵
    - 邻接表
  - 拓扑排序
  - 最短路径
  - 关键路径
  - 最小生成树
  - 二分图
  - 最大流
- 复杂度分析
  - 空间复杂度
  - 时间复杂度
    - 最好
    - 最坏
    - 平均
    - 均摊
- 基本算法思想
  - 贪心算法
  - 分治算法
  - 动态规划
  - 回溯算法
  - 枚举算法
- 排序
  - O(n^2)
    - 冒泡
    - 插入
    - 选择
    - 希尔
  - O(nlogn)
    - 归并
    - 快排
    - 堆排序
  - O(n)
    - 计数排序
    - 基数排序
    - 桶排序
- 搜索
  - 深度优先
  - 广度优先
- 查找
  - 线性表查找
  - 树结构查找
  - 散列表查找
- 字符串匹配
  - 朴素
  - KMP

数据结构我们可以从逻辑上分为线性结构和非线性结构。

## 分类

### 数组

一般语言中的数组，指的都是连续线性表，数据保存在连续的内存块中、数组头保存了数组的地址。

数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所
以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

数组的优点：

1. 构建非常简单
2. 能在 O(1) 的时间里根据数组的下标(index)查询某个元素

数组的缺点：

1. 构建时必须分配一段连续的空间
2. 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间(其中，n 是元素的个数)
3. 删除和添加某个元素时，同样需要耗费 O(n) 的时间，因为后面的元素都需要移动位置。

**但 js 与传统数组不一样，js 中的数据结构就只有一种：哈希表。** 哈希表用来描述 Object，其他所有的数据结构，都是建立在哈希表上的伪结构。

js 中的数组，其实就是 key 为 index 的对象，其底层也就是哈希表。所以 js 中的数组并不储存在一片连续的存储空间里，因此数组的操作也跟传统的数组操作不一样。

> ES6 中的 typed Array 和 ArrayBuffer 是存储连续内存的数组，与传统意义上的数组一样。

### 字符串

很多时候，在分析字符串相关问题的过程中，我们往往要针对字符串当中的每一个字符进行分析和处理，甚至有时候我们得先把给定的字符串转换成字符数组之后再进行分析和处理。

### 链表

链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

三种最常见的链表结构，它们分别是: 单链表、双向链表和循环链表。

**单链表**
单链表第一个结点和最后一个结点是比较特殊的。我们习惯性地把第一个结点叫作头结点，最后一个结点叫作尾结点。
其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是: 指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。

链表随机访问的性能没有数组好，需要 O(n)的时间复杂度。

**双向链表**
双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内
存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。

两个节点链接允许在任一方向上遍历列表。在双向链表中进行添加或者删除节点时,需做的链接更改要比单向链表复杂得多。这种操作在单向链表中更简单高效,因为不需要关注一个节点(除第一个和最后一个节点以外的节点)的两个链接,而只需要关注一个链接即可。

**循环链表**
循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。
和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。

链表的优点：

1. 链表能灵活地分配内存空间；
2. 能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。

链表的缺点：

1. 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；
2. 查询第 k 个元素需要 O(k) 时间。

**应用场景**：如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。

因为传统数组的存储空间都是连续的，元素的增删操作非常麻烦，所以链表这种数据结构就被设计出来了。
链表元素的存储空间都是分散的，每个元素除了保存本身的值之外，还保存着其他元素的内存地址，根据地址就可以将整个链表串起来了。
根据这个特点，只要我们改写一个元素指向的内存地址指向一个新的链表元素，然后设置新的链表元素指向原来元素指向的地址，就插入了一个链表元素。
由于链表的所有元素的实际内存地址并不连续，所以也就不必像定义数组一样声明其存储空间了，换言之链表占用的是动态空间。

js 中数组本身就不是连续的，所以在 js 中直接使用数组即可，没必要使用链表结构。

为了加深理解，这里也给出一个在 js 中通过对象来模拟链表结构的写法。

#### 边界情况处理

我经常用来检查链表代码是否正确的边界条件有这样几个:

1. 如果链表为空时，代码是否能正常工作?
1. 如果链表只包含一个结点时，代码是否能正常工作?
1. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作?

#### 5 个常见的操作

1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第 n 个结点
5. 求链表的中间结点

#### 跳跃表

增加了向前指针的链表叫作跳表(跳跃表)。跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。

#### 哈希表

哈希表使用 "哈希函数/散列函数" 来计算一个值在数组或桶(buckets)中或槽(slots)中对应的索引,可使用该索引找到所需的值。哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。

### 位运算

位运算在算法中很有用，速度可以比四则运算快很多。

在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式

- 十进制 `33` 可以看成是 `32 + 1` ，并且 `33` 应该是六位二进制的(因为 `33` 近似 `32`，而 `32` 是 2 的五次方，所以是六位)，那么 十进制 `33` 就是 `100001` ，只要是 2 的次方，那么就是 1 否则都为 0
- 那么二进制 `100001` 同理，首位是 `2^5` ，末位是 `2^0` ，相加得出 33

#### 左移 <<

```js
10 << 1; // -> 20
```

左移就是将二进制全部往左移动，`10` 在二进制中表示为 `1010` ，左移一位后变成 `10100` ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 `a * (2 ^ b)`

#### 算数右移 >>

```js
10 >> 1; // -> 5
```

算数右移就是将二进制全部往右移动并去除多余的右边，`10` 在二进制中表示为 `1010` ，右移一位后变成 `101` ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 `int v = a / (2 ^ b)`

右移很好用，比如可以用在二分算法中取中间值

```js
13 >> 1; // -> 6
```

#### 按位操作

**按位与**

每一位都为 1，结果才为 1

```js
8 & 7; // -> 0
// 1000 & 0111 -> 0000 -> 0
```

**按位或**

其中一位为 1，结果就是 1

```js
8 | 7; // -> 15
// 1000 | 0111 -> 1111 -> 15
```

**按位异或**

每一位都不同，结果才为 1

```js
8 ^ 7; // -> 15
8 ^ 8; // -> 0
// 1000 ^ 0111 -> 1111 -> 15
// 1000 ^ 1000 -> 0000 -> 0
```

从以上代码中可以发现按位异或就是不进位加法

**面试题**：两个数不使用四则运算得出和

这道题中可以按位异或，因为按位异或就是不进位加法，`8 ^ 8 = 0` 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 `a + b = (a ^ b) + ((a & b) << 1)` ，然后通过迭代的方式模拟加法

```js
function sum(a, b) {
  if (a == 0) return b;
  if (b == 0) return a;
  let newA = a ^ b;
  let newB = (a & b) << 1;
  return sum(newA, newB);
}
```
