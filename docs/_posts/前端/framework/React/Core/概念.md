---
title: React 概念
date: '2020-10-26'
draft: true
---

### React 是什么？

1. React 不是 `MV*` 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层。
2. React 主要的原理：
   1. 虚拟 DOM + diff 算法 -> 不直接操作 DOM 对象
   2. Components 组件 -> Virtual DOM 的节点
   3. State 触发视图的渲染 -> 单向数据绑定
   4. React 解决方案：React + Redux + react-router + Fetch + webpack

#### React 的优点是什么?

1. 使用 `Virtual DOM` 提高应用程序的性能。
1. JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的
1. 支持服务端渲染，可改进 SEO 和性能
1. React 只关注 View 层，易于与框架（Angular，Backbone）集成，因为它只是一个视图库。
1. 使用 Jest 等工具轻松编写单元与集成测试。

### 什么是 JSX?

一个类似 XML 的语法扩展。基本上，它是 `React.createElement()` 函数提供语法糖.

在下面的示例中，`<h1>` 内的文本标签会作为 JavaScript 函数返回给渲染函数。

```jsx
class App extends React.Component {
  render() {
    return (
      <div>
        <h1>{'Welcome to React world!'}</h1>
      </div>
    );
  }
}
```

以上示例 render 方法中的 JSX 将会被转换为以下内容：

```js
React.createElement('div', null, React.createElement('h1', null, 'Welcome to React world!'));
```

编译函数

```js
/** @jsx h */
```

jsx 文件顶部可以指定 pragma, 默认情况下是 `React.createElement` 这也就是为什么，js 文件中需要默认引入 react 的原因。
指定 h 函数。

### JSX 如何防止注入攻击?

React DOM 会在渲染 JSX 中嵌入的任何值之前对其进行转义。因此，它确保你永远不能注入任何未在应用程序中显式写入的内容。

```js
const name = response.potentiallyMaliciousInput;
const element = <h1>{name}</h1>;
```

这样可以防止应用程序中的 XSS（跨站点脚本）攻击。

### 何为纯函数(pure function)

一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。

### 除了在构造函数中绑定 `this`，还有其它方式吗

你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。

### 为什么不能直接更新状态?

如果你尝试直接改变状态，那么组件将不会重新渲染。

```js
//Wrong
this.state.message = 'Hello world';
```

正确方法应该是使用 `setState()` 方法。它调度组件状态对象的更新。当状态更改时，组件通将会重新渲染。

```js
//Correct
this.setState({ message: 'Hello World' });
```

**注意：** 你可以在 `constructor` 中或使用最新的 JavaScript 类属性声明语法直接设置状态对象。

### 在渲染方法中使用箭头函数好么?

在使用时需要优化性能。

```js
class Foo extends Component {
  handleClick() {
    console.log('Click happened');
  }
  render() {
    return <button onClick={() => this.handleClick()}>Click Me</button>;
  }
}
```

**注意：** 组件每次渲染时，在 render 方法中的箭头函数都会创建一个新的函数，这可能会影响性能。

### 支持 React 应用程序的浏览器有哪一些?

React 支持所有流行的浏览器，包括 Internet Explorer 9 和更高版本，但旧版本的浏览器（如 IE 9 和 IE 10）需要一些 polyfill。如果你使用 **es5-shim and es5-sham** polyfill，那么它甚至支持不支持 ES5 方法的旧浏览器。

### React 绑定 this

为什么要主动绑定 this ？

### 什么是 "key" 属性，在元素数组中使用它们有什么好处?

`key` 是一个特殊的字符串属性，你在创建元素数组时需要包含它。_Keys_ 帮助 React 识别哪些项已更改、添加或删除。

我们通常使用数据中的 IDs 作为 _keys_:

```jsx
const todoItems = todos.map(todo => <li key={todo.id}>{todo.text}</li>);
```

在渲染列表项时，如果你没有稳定的 IDs，你可能会使用 _index_ 作为 _key_：

```jsx
const todoItems = todos.map((todo, index) => <li key={index}>{todo.text}</li>);
```

**注意：**

由于列表项的顺序可能发生改变，因此并不推荐使用 _indexes_ 作为 _keys_。这可能会对性能产生负面影响，并可能导致组件状态出现问题。
如果将列表项提取为单独的组件，则在列表组件上应用 _keys_ 而不是 `li` 标签。
如果在列表项中没有设置 `key` 属性，在控制台会显示警告消息。

### 在 React 中的提升状态是什么?

当多个组件需要共享相同的更改数据时，建议将共享状态提升到最接近的共同祖先。这意味着，如果两个子组件共享来自其父组件的相同数据，则将状态移动到父组件，而不是在两个子组件中维护局部状态。

### 什么是上下文（Context）?

_Context_ 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递`props`。比如，需要在应用中许多组件需要访问登录用户信息、地区偏好、UI 主题等。

```jsx
// 创建一个 theme Context,  默认 theme 的值为 light
const ThemeContext = React.createContext('light');

function ThemedButton(props) {
  // ThemedButton 组件从 context 接收 theme
  return <ThemeContext.Consumer>{theme => <Button {...props} theme={theme} />}</ThemeContext.Consumer>;
}

// 中间组件
function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class App extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}
```

### 每次组件渲染时调用函数的常见错误是什么?

你需要确保在将函数作为参数传递时未调用该函数。

```jsx
render() {

// Wrong: handleClick is called instead of passed as a reference!
return <button onClick={this.handleClick()}>{'Click Me'}</button>
}
```

相反地，传递函数本身应该没有括号：

```jsx
render() {

// Correct: handleClick is passed as a reference!
return <button onClick={this.handleClick}>{'Click Me'}</button>
}
```

### 为什么有组件名称要首字母大写?

这是必要的，因为组件不是 DOM 元素，它们是构造函数。 此外，在 JSX 中，小写标记名称是指 HTML 元素，而不是组件。

### 客户端渲染与服务端渲染

客户端渲染即普通的 React 项目渲染方式。
客户端渲染流程：

1. 浏览器发送请求
2. 服务器返回 HTML
3. 浏览器发送 bundle.js 请求
4. 服务器返回 bundle.js
5. 浏览器执行 bundle.js 中的 React 代码

CSR 带来的问题：

1. 首屏加载时间过长
2. SEO 不友好

因为时间在往返的几次网络请求中就耽搁了，而且因为 CSR 返回到页面的 HTML 中没有内容，就只有一个 root 空元素，页面内容是靠 js 渲染出来的，爬虫在读取网页时就抓不到信息，所以 SEO 不友好

SSR 带来的问题：

1. React 代码在服务器端执行，很大的消耗了服务器的性能

### React 同构时页面加载流程

1. 服务端运行 React 代码渲染出 HTML
2. 浏览器加载这个无交互的 HTML 代码
3. 浏览器接收到内容展示
4. 浏览器加载 JS 文件
5. JS 中 React 代码在浏览器中重新执行

### react 的 class 组件为什么需要在开头 import react？ 去掉能不能跑？

### 在 React 中 registerServiceWorker 的用途是什么?

默认情况下，React 会为你创建一个没有任何配置的 service worker。Service worker 是一个 Web API，它帮助你缓存资源和其他文件，以便当用户离线或在弱网络时，他/她仍然可以在屏幕上看到结果，因此，它可以帮助你建立更好的用户体验，这是你目前应该了解的关于 Service worker 的内容。

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(<App />, document.getElementById('root'));
registerServiceWorker();
```

### React memo 函数是什么?

当类组件的输入属性相同时，可以使用 **pureComponent** 或 **shouldComponentUpdate** 来避免组件的渲染。现在，你可以通过把函数组件包装在 **React.memo** 中来实现相同的功能。

```jsx
const MyComponent = React.memo(function MyComponent(props) {
  /* only rerenders if props change */
});
```

### React lazy 函数是什么?

使用 React.lazy 函数允许你将动态导入的组件作为常规组件进行渲染。当组件开始渲染时，它会自动加载包含 OtherComponent 的包。它必须返回一个 Promise，该 Promise 解析后为一个带有默认导出 React 组件的模块。

```jsx
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}
```

**注意：** React.lazy 和 Suspense 还不能用于服务端渲染。如果要在服务端渲染的应用程序中进行代码拆分，我们仍然建议使用 React Loadable。

### 如何在 React 类中使用类字段声明语法?

使用类字段声明可以使 React 类组件更加简洁。你可以在不使用构造函数的情况下初始化本地状态，并通过使用箭头函数声明类方法，而无需额外对它们进行绑定。让我们以一个 counter 示例来演示类字段声明，即不使用构造函数初始化状态且不进行方法绑定：

```jsx
class Counter extends Component {
  state = { value: 0 };

  handleIncrement = () => {
    this.setState(prevState => ({
      value: prevState.value + 1,
    }));
  };

  handleDecrement = () => {
    this.setState(prevState => ({
      value: prevState.value - 1,
    }));
  };

  render() {
    return (
      <div>
        {this.state.value}

        <button onClick={this.handleIncrement}>+</button>
        <button onClick={this.handleDecrement}>-</button>
      </div>
    );
  }
}
```

### React 其他

- 为什么要绑定 this
- setState 是同步还是异步，立即获取值的操作
- hooks
- diff 原理
- fiber
- mobx content 以及 redux 几种状态管理的区别

#### 主要

- 异步渲染
- 事件系统
- fiber

### react 面试题

- mixin、hoc、render props、react-hooks 的优劣如何？
- 你是如何理解 fiber 的?
- 你对 Time Slice 的理解?
- react-redux 是如何工作的?
- redux 与 mobx 的区别?
- redux 异步中间件之间的优劣?
- redux 中如何进行异步操作?
- React 如何进行组件/逻辑复用?

### 核心架构

- O(n) 复杂度的的 diff 算法。
  > ![](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/react-diff.png)
  > React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。
  > [详细学习](https://blog.csdn.net/u011413061/article/details/77823299)
- react 的生命周期
  ![react-lifecycle.png](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/react-lifecycle.png)
- setState 实现机制

### react 的工作原理

react 引用了虚拟 DOM 的机制，在浏览器端用 Javascript 实现了一套 DOM API。。

虚拟 DOM 的原理：React 会在内存中维护一个虚拟 DOM 树，对这个树进行读或写，实际上是对虚拟 DOM 进行。当数据变化时，React 会自动更新虚拟 DOM，然后将新的虚拟 DOM 和旧的虚拟 DOM 进行对比，找到变更的部分，得出一个 diff，然后将 diff 放到一个队列里，最终批量更新这些 diff 到 DOM 中。

虚拟 DOM 的优点：

最终表现在 DOM 上的修改只是变更的部分，可以保证非常高效的渲染。

虚拟 DOM 的缺点：

首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。

### react 项目中的`registerServiceWorker.js`文件是做什么的？

在生产中，我们注册一个服务工作者来从本地缓存服务资产。
这使得应用程序在以后的产品访问中加载速度更快，并使其具备离线功能。但是，这也意味着开发人员(和用户)将只看到在“N+1”访问页面时部署的更新，因为以前缓存的资源在后台更新。

也就是实现 PWA。

### UI 库中的 theme 主题是怎么实现的？

添加默认主题只需要在项目的根目录所在文件`App.js`中使用`createTheme()`方法创建主题,然后将创建的主题通过`ThemeProvider`装饰器传递给整个 APP 的子元素，我们通过改变`ThemeProvider`的`theme`属性的值来改变主题
