---
title: React 渲染
date: '2020-10-26'
draft: true
---

### 当组件重新渲染时顺序执行的方法有哪些?

更新可能由属性或状态的更改引起。在重新渲染组件时，会按以下顺序调用下列方法。

- static getDerivedStateFromProps()
- shouldComponentUpdate()
- render()
- getSnapshotBeforeUpdate()
- componentDidUpdate()

### React 的批量更新机制 BatchUpdates？

[从源码全面剖析 React 组件更新机制](https://segmentfault.com/a/1190000014442208)

### forceUpdate 经历了哪些生命周期，子组件呢?

forceUpdate()将会经历：

- componentWillUpdate
- render
- componentDidUpdate
  调用 forceUpdate() 将会导致 render() 方法在相应的组件上被调用，并且子级组件也会调用自己的 render()，但是如果标记改变了，那么 React 仅会更新 DOM。

通常情况下，应该尽量避免所有使用 forceUpdate() 的情况，在 render() 中仅从 this.props 和 this.state 中读取数据。这会使应用大大简化，并且更加高效

### 在 React 测试中什么是浅层渲染（Shallow Renderer）?

*浅层渲染*对于在 React 中编写单元测试用例很有用。它允许您渲染一个*一级深的组件*并断言其渲染方法返回的内容，而不必担心子组件未实例化或渲染。

例如，如果您有以下组件：

```js
function MyComponent() {
  return (
    <div>
      <span className={'heading'}>{'Title'}</span>
      <span className={'description'}>{'Description'}</span>
    </div>
  );
}
```

然后你可以如下断言：

```jsx
import ShallowRenderer from 'react-test-renderer/shallow';

// in your test
const renderer = new ShallowRenderer();
renderer.render(<MyComponent />);

const result = renderer.getRenderOutput();

expect(result.type).toBe('div');
expect(result.props.children).toEqual([
  <span className={'heading'}>{'Title'}</span>,
  <span className={'description'}>{'Description'}</span>,
]);
```
