---
title: 'c++入门'
draft: true
---

### 前言

c++ 是在 c 语言的基础上开发的一种集面向对象编程、泛型编程和面向过程化编程与一体的编程语言， 是 c 语言的超集。

c++语言容纳了好几种编程范式，其中包括面向对象、泛型编程和传统的编程过程。

c++ 在 c 语言的基础之上添加了很多新的特性，包括：

- 类和对象
- 继承
- 多态、虚函数和 RTTI
- 函数重载
- 引用变量
- 泛型（独立于类型的）编程
- 处理错误条件的异常机制
- 管理函数、类和变量名的命名空间

### 1. 预备知识

泛型编程与 oop 目标相同，即使重用代码和抽象通用概念更简单。不过 oop 强调的是编程的数据方面，而泛型编程强调的是独立于特定类型。

### 常用的 math 函数

1. fabs(double x) 取绝对值

2. floor(double x) ceil(double x) 向上取整 向下取整

3. pow(double x, double y) 指数

4. sqrt(double x) 算数平方根

5. log(double x) 取自然对数为底的对数

6. Sin(double x) Cos(double x) Tan(double x) 正弦、余弦 和正切数， 参数要求为弧度制，sin(x \* 45 / 180)

7. asin(double x) acos(double x) atan(double x) 反正弦、 反余弦 和反正切数

8. round(double x) 将 x 值进行四舍五入

### memset 为数据中的每一个元素赋相同的值

2.5.4 章节

两种方法：1. memset 函数； 2. fill 函数

### String.h 头文件函数

1. strlen(字符数组) 可以获取字符数组的长度，第一个 \0 前的字符个数
2. strcmp(字符数组 a, 字符数组 b) 返回两个字符串大小的比较结果，字典排序，如果 a 小于 b 返回一个负整数， 等于返回 0 ，大于返回一个正整数
3. strcpy(字符数组 a, 字符数组 b) 把字符串 b 的内容完全复制给字符数组 a， 包括了结束符 \0
4. Strcat(字符数组 a, 字符数组 b) 把字符串 b 的内容连接到字符数组 a 后面

### sscanf 和 sprintf

从单词上看 sscanf 就是 string + scanf； sprintf 就是 string + printf

使用的格式：

sscanf(str, "%d", &n) 从字符数组 str 中按照 %d 的格式读取数据，写入到 n 这个变量中；

sprintf(str, "%d", n) 将变量 n 的值，按照 %d 的格式写入数据到字符数组 str 中；

### c/c++ 常用头文件

https://www.cnblogs.com/zuiuren/p/6067400.html

### typedef char _String_t; 和#define String_d char _ 这两句在使用上有什么区别?

答：typedef char _String_t 定义了一个新的类型别名，有类型检查。而#define String_d char _ 只是做了
个简单的替换，无类型检查，前者在编译的时候处理，后者在预编译的时候处理。
同时定义多个变量的时候有区别，主要区别在于这种使用方式 String_t a,b; String_d c,d; a,b ,c 都是
char\*类型，而 d 为 char 类型
由于 typedef 还要做类型检查。。#define 没有。。所以 typedef 比#define 安全。

### 已知 rand7()可以产生 1~7 的 7 个数(均匀概率),利用 rand7() 产 生 rand10() 1~10(均匀概率)。

```c
int rand7()
{
    return rand()%7+1;
}
int rand10()
{
    int x=0;
    do
    {
        x=(rand7()-1)*7+rand7();
    }
    while(x>=40);
    return x%10+1;
}
```

### sizeof

```c
char str[] = "Hello";
// 会输出6，要包括最后一位。
printf("%d\n", sizeof(str));
// 会输出5正常字符串字符串长度不包括最后一位。
printf("%d\n", strlen(str));

char *p = str;
printf("%d\n", sizeof(p));
// sizeof一个指针，占4位


void Func(char str_arg[100])
{
    printf("%d\n", sizeof(str_arg));
}
Func(str);

// 这个时候其实sizeof的是一个指针，所以输出4

cout<<sizeof(string)<<endl;
cout<<sizeof(int)<<endl;
cout<<sizeof(a)<<endl;
cout<<sizeof(float)<<endl;
cout<<sizeof(char)<<endl;
// 输出：
24
4
4
4
1
```

### 给定能随机生成整数 1 到 5 的函数,写出能随机生成整数 1 到 7 的函数。

```c
int rand7()
{
    int n=25;
    while(n>21){
        n=5*(rand5()-1)+rand5();
    }
    return (n%7)+1;
}
```

### C++中，关于`#include<***.h>`和`#include"***.h"`的区别

如果是标准库头文件，那么既可以采用<>的方式，又可以采用" "的方式，而用户自定义的头文件只能采用" "的方式。

- `#include<iostream>`效率较高(编译器自带的函数库中寻找文件)

- `#include "iostream"` 效率较低(从自定义的文件中找 ，如果找不到在从函数库中寻找文件)

### c++的 namespace 以及多个 namespace

使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突。在 C++中，变量、函数和类都是大量存在的。如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，会导致很多冲突。

只要保证多个 namespace 中的没有相同命名的变量和函数。

### extern 声明变量

如果想声明一个变量而非定义它，就在变量名前添加 extern 关键字，而且不要显式地初始化变量：

```
extern int i;  //声明i而非定义
int j;         //声明并定义i


extern int v = 2;
int v = 2;     //这两个语句效果完全一样，都是v的定义
```

### 工具

makefile 文件：

makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。

### 语法

单冒号的作用：

1. public:和 private:后面的冒号，表示后面定义的所有成员都是公有或私有的，直到下一个"public:”或"private:”出现为止。

2. 类名冒号后面的是用来定义类的继承。class 派生类名 : 继承方式 基类名。 继承方式：public、private 和 protected，默认处理是 public。

双冒号的作用：

构造函数、析构函数、virtual 虚函数：

- 构造函数不能为虚函数，而析构函数可以且常常为虚函数。

- 虚函数是指一个类中希望重载的函数。

指针和引用：

OIDB: 即通对外统一接口

### 概念

#### 析构函数

是类的一个成员函数，名字由波浪线加类名构成，从名字中联想它的功能： 是执行与构造函数相反的操作：释放对象使用的资源，并销毁非 static 成员。

- 析构函数不销毁 static 成员？什么时候销毁 static 成员？

- 析构函数什么时候执行？

- 析构函数为什么不能重载？

#### 重载、重写、重定义

- 重载指在同一个作用域内，函数名相同，但是函数的参数个数、类型或者顺序不同。不能依靠返回值来区分。
- 重写（override），是指派生类重新定义基类的虚函数。在不同作用域中（不同类中），函数名称相同，函数个数

### c++ 类的实例化

```
A a;
A * a = new a();
```

以上两种方式皆可实现类的实例化，有 new 的区别在于：

1. 前者在堆栈中分配内存，后者为动态内存分配，在一般应用中是没有什么区别的，但动态内存分配会使对象的可控性增强。
2. 不加 new 在堆栈中分配内存
3. 大程序用 new，小程序直接申请
4. 只是把对象分配在堆栈内存中
5. new 必须 delete 删除，不用 new 系统会自动回收内存

### Run 函数

或许一个 c++ 类实例调用 Run 函数的作用就是实现多线程的调用？

run 函数一般会是用于实现线程类的线程函数调用。

虚函数 Run，这个 Run 函数最终会利用多态调用到用户线程类的 Run 函数。这也是面向对象用的比较多的地方，用户要想启用一个线程，必须要继承 Thread 这个类，而且要覆盖 Run 这个虚函数，很麻烦。

### 指针

常量指针： `const char* a = "abcd";`

### 引用、指针、值传递

- 值传递：形参是实参的拷贝，当函数内部需要改变参数，并且希望这个改变不影响调用者（实参），应该采用值传递。
- 指针：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作
- 引用： 形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

### 引用和指针的异同

##### 相同点：

引用和指针都是地址的概念。指针指向一块内存，它的内容是所指向的内存的地址；而引用是一块内存的别名。

##### 不同点：

- 指针是一个实体，而引用只是一个别名。
- 引用只能在初始化时被定义一次，之后不可变，而指针可变。
- 引用没有 const， 而指针有 const， const 的指针不可变。
- “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
- 引用不能为空，指针可以为空；
- 指针和引用的自增(++)运算意义不一样；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

### uint8_t / uint16_t / uint32_t /uint64_t

在 C 语言中有 6 种基本数据类型：short、int、long、float、double、char

1. 数值类型
2. 整型：short、int、long
3. 浮点型：float、double
4. 字符类型：char

typedef 用来定义关键字或标识符的别名，例如：

```
typedef double wages;
typedef wages salary;
```

### uint8_t\uint_16_t\uint32_t\uint64_t

1. 这些类型的来源：这些数据类型中都带有\_t, \_t 表示这些数据类型是通过 typedef 定义的，而不是新的数据类型。也就是说，它们其实是我们已知的类型的别名。

2. 使用这些类型的原因：方便代码的维护。比如，在 C 中没有 bool 型，于是在一个软件中，一个程序员使用 int，一个程序员使用 short，会比较混乱。最好用一个 typedef 来定义一个统一的 bool：

   ```
   typedef char bool;
   // 又如：
   typedef unsigned short uint16_t;
   ```

   在涉及到跨平台时，不同的平台会有不同的字长，所以利用预编译和 typedef 可以方便的维护代码
