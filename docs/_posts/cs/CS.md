---
title: 'CS'
draft: true
---

### 什么是依赖注入

- 当一个类的实例依赖另一个类的实例时，自己不创建该实例，由 IOC 容器创建并注入给自己，因此称为依赖注入。
- 依赖注入解决的就是如何有效组织代码依赖模块的问题

### 权限管理

rbac idap 等
https://www.v2ex.com/t/468437
美团将军令 https://tech.meituan.com/2019/02/14/data-security-platform-construction-practice-jiangjunling.html

#### travis

自动部署 npm 包：https://blog.csdn.net/lym152898/article/details/81868524

https://juejin.im/post/5ab39fedf265da23a04979cb

https://blog.stephencode.com/p/ssh-login-no-pwd

http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html

https://segmentfault.com/a/1190000011218410

需要删除私钥：

https://www.zhuwenlong.com/blog/article/5c24b6f2895e3a0fb4072a5c

### 压缩解压

压缩：tar cvf FileName.tar FileName
排除文件压缩：tar zc --exclude node_modules --exclude .git -f 1.tar.gz \*
解压：tar xvf FileName.tar

https://blog.csdn.net/liuyanfeier/article/details/62422315

### 轮播 10000 张图片过程

### 如何将一个 html 页面解析（用数据结构回答）

### 输入网址后如何查找服务器

### 服务器如何知道你(用到计算机网络的知识)

### try catch

try 语句执行一个代码块，并捕获该代码块抛出的异常。catch 从句定义了一个新的变量，它将接收该异常。
throw 语句抛出一个异常，如果 throw 语句在一个 try 代码块中，那么控制权会跳到 catch 从句中。如果 throw 语句在函数中，则该函数调用被抛弃，且控制权会跳到调用该函数的 try 语句的 catch 从句中。
throw 语句中的表达式通常是一个对象字面量，它包含一个 name 属性和 message 属性。异常捕获器可以使用这些信息区决定该做什么。？？

### 一个静态资源要上线，里面有各种资源依赖，你如何平稳上线

### 如果要你去实现一个前端模板引擎，你会怎么做

### 手指点击可以触控的屏幕时，是什么事件？

### 去除代码里面所有的空格和换行，你怎么做？

### 一页有上百张图片，加载的有点慢，你有考虑过优化吗？（可以把 100 张图用缩略图，即用小图，大概在 2-3K 放出来，要具体查看每张图的时候再把原图呈现。）

### 什么是函数柯里化？以及说一下 JS 的 API 有哪些应用到了函数柯里化的实现？(函数柯里化一些了解，以及在函数式编程的应用，最后说了一下 JS 中 bind 函数和数组的 reduce 方法用到了函数柯里化。)

### 拖拽实现

### 如何及时捕获前端出现的异常

### 业务场景：比如说百度的一个服务不想让阿里使用，如果识别到是阿里的请求，然后跳转到 404 或者拒绝服务之类的？(主要是考察 http 协议头 Referer，然后怎么判断是阿里的 ip 或者啥的)

### 线性顺序存储结构和链式存储结构有什么区别？以及优缺点。(类比 JS 数组和对象来回答的，反正还算凑合吧，自己都数据结构这块多少还是有些印象，所以入了前端，对数据结构和算法确实一直淡忘了)

### 怎么实现草稿，多终端同步，以及冲突问题？

### 预渲染和服务端渲染区别, 据说大多数情况使用预渲染就能解决问题，不需要上服务端渲染。

### 字符串超出限制，自动截取并添加 “...”

### 单元测试。 开源库的单元测试， 一个库并不能直接运行，所以需要单元测试，并且能够提高准确性。 jest

### iframe 一般用来干什么

### dom 树的重绘和重排？ 修改什么内容，浏览器会进行重绘 ？如何考虑优化 ？

### 现在有一个下拉加载更多的列表，当加载次数非常多时，页面 dom 结构会变得非常复杂，会不会出现性能问题，该如何解决？

### click 在 ios 上有 300ms 延迟，原因及如何解决

### 移动端的适配，rem+媒体查询/meta 头设置

### 移动端的手势和事件；

### unicode，utf8，gbk 编码的了解，乱码的解决

### 线程与进程的区别

一个程序至少有一个进程,一个进程至少有一个线程.线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程调度和管理以及资源分配。这就是进程和线程的重要区别。

### 进程和线程的区别？

一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下的所有线程共享该进程的所有资源。

### 堆和栈的区别是什么？

栈一般是用来存储函数的参数值和局部变量的值，由编译器自动分配和释放，
存储方式是连续的，且会出现溢出现象，堆有程序员手动分配释放，存储地址是
链式的，内存较大不会溢出。栈由系统自动分配，速度快，堆由 new 分配内存，速度慢

### CI/CD 流程

ci(持续构建)
代码提交后触发自动化的单元测试，代码预编译，构建镜像，上传镜像等．

cd(持续发布)
持续发布则指将构建好的程序发布到各种环境，如预发布环境，正式环境

### 线程与进程的区别

- 一个程序至少有一个进程，一个进程至少有一个线程
- 线程的划分尺度小于进程，使得多线程程序的并发性高
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存
- 线程不能够独立执行，必须应用程序提供多个线程执行控制

### 解释 TCO - 尾调用优化（Tail Call Optimization）。 有没有支持尾调用优化的 JavaScript 引擎？

尾调用(Tail Call)是函数式编程的一个重要概念，用简单的一句话描述就是“在函数的最后一步调用函数”

```js
function f(x) {
  let y = x + 1;
  return g(y);
}
```

尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。
现在还没有支持尾调用优化的 JavaScript 引擎

### 线性顺序存储结构和链式存储结构有什么区别？以及优缺点

顺序存储结构和链式存储结构的区别:
链表存储结构的内存地址不一定是连续的，每个数据元素 (结点)的存储包括数据区和指针区两个部分。数据区存放结点本身的数据，指针区存放其后继元素的地址只要知道该线性表的起始地址表中的各个元素就可通过其间的链接关系逐步找到。但顺序存储结构的内存地址一定是连续的，用一组地址连续的存储单元依次存储该线性表中的各个元素。
链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。

顺序存储结构和链式存储结构的优缺点
空间上
顺序比链式节约空间。是因为链式结构每一个节点都有一个指针存储域。顺序存储密度大（＝ 1），存储空间利用率高。链表的存储密度 < 1(存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量)

存储操作上
顺序支持随机存取，方便操作，顺序表的存储空间是静态分配的,链表的存储空间是动态分配的。

插入和删除上
链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了）

使用情况
顺序表适宜于做查找这样的静态操作；链表宜于做插入、删除这样的动态操作。
若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；
若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表。

#### 顺序存储结构和链式存储结构的区别

链表存储结构的内存地址不一定是连续的，每个数据元素 (结点)的存储包括数据区和指针区两个部分。数据区存放结点本身的数据，指针区存放其后继元素的地址只要知道该线性表的起始地址表中的各个元素就可通过其间的链接关系逐步找到。但顺序存储结构的内存地址一定是连续的，用一组地址连续的存储单元依次存储该线性表中的各个元素。
链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。

#### 顺序存储结构和链式存储结构的优缺点

空间上
顺序比链式节约空间。是因为链式结构每一个节点都有一个指针存储域。顺序存储密度大（＝ 1），存储空间利用率高。链表的存储密度 < 1(存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量)

存储操作上
顺序支持随机存取，方便操作，顺序表的存储空间是静态分配的,链表的存储空间是动态分配的。

插入和删除上
链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了）

使用情况
顺序表适宜于做查找这样的静态操作；链表宜于做插入、删除这样的动态操作。
若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；
若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表。

### 解释一下何为面向对象编程

面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

数据封装、继承和多态是面向对象的三大特点
对象有如下几个特点：

1. 对象具有唯一标识性:即完全相同的两个对象，也并非同一个对象
2. 对象有状态： 对象具有状态，同一对象可能处于不同状态下
3. 对象具有行为：即对象的状态可能因为行为发生变迁

对象的第一特征在 js 体现在内存地址，对象的内存地址不同，第二第三特征 js 体现具有属性和方法
在实现了对象基本特征的基础上，js 中对象独有的特色是对象具有高度的动态性，这是因为 js 赋予来使用者在运行时为对象添加状态和行为的能力，js 的对象设计虽然和目前主流基于类的面向对象差异非常大，但是提供了完全运行时的对象系统，因此 js 是面向对象的语言。

### 什么是面向对象编程及面向过程编程，它们的异同和优缺点

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了
面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为
面向对象是以功能来划分问题，而不是步骤

面向对象思想：
基本思想是使用对象，类，继承，封装等基本概念来进行程序设计
优点
易维护
采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的
易扩展
开发工作的重用性、继承性高，降低重复工作量。
缩短了开发周期

### 请解释可变 (mutable) 和不变 (immutable) 对象的区别

Mutable 对象：
在 JavaScript 中，对象是引用类型的数据，其优点在于频繁地修改对象时都是在原对象的基础上修改，并不需要重新创建，这样就可以有效地利用内存，不会造成内存空间的浪费

Immutable 对象：
每次修改一个 immutable 对象时都会创建一个新的不可变对象，在新对象上的操作不会影响到原对象的数据

区别：
Immutable 对象在修改数据时并不会复制一整份数据，而是将变化的节点与未变化的节点的父子关系转移到一个新节点上，而 Mutable 在复制时是“全量”。Immutable 对象需要通过 set 和 get 来对数据进行读和写

不变性对象 (immutable object) 的例子
例如：String， number 就是不可变对象

不变性 (immutability) 优缺点
优点:

- 降低 Mutable 带来的复杂度
  引用赋值虽然可以节省内存，但当应用复杂之后，可变状态往往会变成噩梦，通常一般的做法是使用 shallowCopy 或者 deepCopy 来避免被修改，但这样造成了 CPU 和内存的消耗，不过 Immulate 可以很好地解决这些问题
- 节省内存空间
  上面提到了结构共享，Immutable.js 使用这种方式会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收
- Undo/Redo，Copy/Paste，随意穿越！

因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功

- 拥抱函数式编程
  Immutable（持久化数据结构）本身就是函数式编程中的概念。函数式编程关心数据的映射，命令式编程关心解决问题的步骤，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装
  缺点
- 容易与原生对象混
  如何用你自己的代码来实现不变性 (immutability)
  例如定义一个不可变更，不可枚举的变量

### 请解释可变对象和不可变对象之间的区别。

- 什么是 JavaScript 中的不可变对象的例子？
- 不变性有什么优点和缺点？
- 你如何在自己的代码中实现不变性？

**_可变对象_** 在创建之后是可以被改变的。

**_不可变对象_** 在创建之后是不可以被改变的。

1. 在 `JavaScript` 中，`string` 和 `number` 从设计之初就是不可变(Immutable)。
2. **_不可变_** 其实是保持一个对象状态不变，这样做的好处是使得开发更加简单，可回溯，测试友好，减少了任何可能的副作用。但是，每当你想添加点东西到一个不可变(Immutable)对象里时，它一定是先拷贝已存在的值到新实例里，然后再给新实例添加内容，最后返回新实例。相比可变对象，这势必会有更多内存、计算量消耗。
3. 比如：构造一个纯函数

```js
const student1 = {
  school: 'Baidu',
  name: 'HOU Ce',
  birthdate: '1995-12-15',
};

const changeStudent = (student, newName, newBday) => {
  return {
    ...student, // 使用解构
    name: newName, // 覆盖name属性
    birthdate: newBday, // 覆盖birthdate属性
  };
};

const student2 = changeStudent(student1, 'YAN Haijing', '1990-11-10');

// both students will have the name properties
console.log(student1, student2);
// Object {school: "Baidu", name: "HOU Ce", birthdate: "1995-12-15"}
// Object {school: "Baidu", name: "YAN Haijing", birthdate: "1990-11-10"}
```
