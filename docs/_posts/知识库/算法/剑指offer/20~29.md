---
title: 前端与数据结构-剑指 offer 20~29
date: 2020-11-14
aside: false
draft: true
---

## 20. 表示数值的字符串

```
true

"+100"
"5e2"
"-123"
"3.1416"
"-1E-16"
```

```
false

"12e"
"1a3.14"
"1.2.3"
"+-5"
"12e+4.3"
```

### 解题思路

使用正则表达式进行匹配。

```html
[] ： 字符集合 () ： 分组 ? ： 重复 0 ~ 1 次 + ： 重复 1 ~ n 次 * ： 重复 0 ~ n 次 . ： 任意字符 \\. ： 转义后的 . \\d
： 数字
```

```js
// 第一种
function isNumeric(s) {
  return s.match(/[+-]?\d*(\.\d*)?([eE][+-]?\d+)?/g)[0] === s;
}
// 第二种
function isNumeric2(s) {
  return s.search(/^[+-]?\d*(\.\d*)?$/) === 0 || s.search(/^[+-]?\d+(\.\d*)?[Ee]{1}[+-]?\d+$/) === 0;
}
```

## 21. 调整数组顺序使奇数位于偶数前面

需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。

### 解题思路

oddBegin 主要是用作奇数的索引，oddCount 是用作偶数的索引,newArray 用来存储，以空间换时间，复杂度为 O(n)

```js
function reOrderArray(array) {
  let oddBegin = 0,
    oddCount = 0;
  const newArray = [];
  for (let i = 0; i < array.length; i++) {
    if (array[i] & 1) {
      oddCount++;
    }
  }
  for (let i = 0; i < array.length; i++) {
    if (array[i] & 1) {
      newArray[oddBegin++] = array[i];
    } else {
      newArray[oddCount++] = array[i];
    }
  }
  return newArray;
}
```

## 21.1 数组顺序调整

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

### 思路描述

这题进一步抽象就是满足一定条件的元素都移动到数组的前面，不满足的移动到后面。所以，需要有一个参数用来传递**判断函数**。

最优解法就是数组两头分别有一个指针，然后向中间靠拢。符合条件，就一直向中间移动；不符合条件，就停下来指针，交换两个元素；然后继续移动，直到两个指针相遇。

### 代码实现

函数`change`运用了设计模式中的“[桥接模式](https://godbmw.com/passages/2019-01-19-bridge-pattern/)”，判断条件由用户自己定义。

```js
/**
 * 交换数组元素
 * @param {Array} arr
 * @param {Number} i
 * @param {Number} j
 */
const swap = (arr, i, j) => ([arr[i], arr[j]] = [arr[j], arr[i]]);

/**
 * 将符合compareFn要求的数据排在前半部分，不符合要求的排在后半部分
 * @param {Array} brr
 * @param {Function} compareFn
 * @return {Array}
 */
function change(brr, compareFn) {
  const arr = [...brr],
    length = brr.length;
  let i = 0,
    j = arr.length - 1;
  while (i < j) {
    while (i < length && compareFn(arr[i])) ++i;
    while (j >= 0 && !compareFn(arr[j])) --j;

    if (i < j) {
      swap(arr, i, j);
      ++i;
      --j;
    }
  }
  return arr;
}
```

## 22. 链表中倒数第 K 个结点

快慢指针， 类似删除链表中的最后一个节点的算法。

### 解题思路

设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。

```js
/**
 * 寻找倒数第 k 个节点
 * @param {Node} head 初始节点
 * @param {Number} k 顺序(倒数)
 */
function findKthFromTail(head, k) {
  if (head === null || k <= 0) return null;
  let pNode1 = head,
    pNode2 = head;
  while (--k) {
    if (pNode2.next !== null) {
      pNode2 = pNode2.next;
    } else {
      return null;
    }
  }
  while (pNode2.next !== null) {
    pNode1 = pNode1.next;
    pNode2 = pNode2.next;
  }
  return pNode1;
}
```

## 23. 链表中环的入口结点

一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。

### 解题思路

使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在下图的 z1 位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。

在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。

```js
function EntryNodeOfLoop(pHead) {
  let fast = pHead;
  let slow = pHead;
  while (fast !== null && fast.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
    if (fast === slow) {
      // 两者相遇
      let p = pHead;
      while (p !== slow) {
        p = p.next;
        slow = slow.next;
      }
      return p;
    }
  }
  return null;
}
```

## 24. 反转链表

```js
// 递归
var reverseList = function(head) {
  let reverse = (prev, curr) => {
    if (!curr) {
      return prev;
    }
    let next = curr.next;
    curr.next = prev;
    return reverse(curr, next);
  };
  return reverse(null, head);
};
```

```js
// 迭代
var reverseList = function(head) {
  let prev = null;
  let curr = head;
  while (curr != null) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
};
```

## 25. 合并两个排序的链表

合并 2 个有序单链表成为 1 个新的有序单链表

### 思路分析

准备一个指针`node`，假设指向两个链表的中节点的指针分别是：`p1`和`p2`。

1. 比较`p1`和`p2`的`value`大小

- 如果，p1.value 小于 p2.value, node.next 指向 p1, p1 向后移动
- 否则，node.next 指向 p2, p2 向后移动

2. 重复第 1 步，直到其中一个链表遍历完
3. 跳出循环，将 node.next 指向未遍历完的链表的剩余部分

整个过程的时间复杂度是 O(N), 空间复杂度是 O(1)

### 代码实现

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

#### js

```js
function Merge(pHead1, pHead2) {
  let pMergeHead = null;

  if (pHead1 === null) return pHead2;
  if (pHead2 === null) return pHead1;
  if (pHead1.val < pHead2.val) {
    pMergeHead = pHead1;
    pMergeHead.next = Merge(pHead1.next, pHead2);
  } else {
    pMergeHead = pHead2;
    pMergeHead.next = Merge(pHead1, pHead2.next);
  }
  return pMergeHead;
}
```

## 26. 树的子结构

```js
/**
 * @param {TreeNode} A
 * @param {TreeNode} B
 * @return {boolean}
 */
var isSubStructure = function(A, B) {
  // 约定空树不是任意一个树的子结构
  if (!A || !B) {
    return false;
  }
  return isSubTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
};

/**
 * A 包含 B 并且开头的节点需要相同
 * isSubTree 的职能：封装“判断 B 是否是 A 的子结构”的具体逻辑。
 * @param {TreeNode} A
 * @param {TreeNode} B
 * @return {boolean}
 */
var isSubTree = function(A, B) {
  // B子树是空子树 ok
  if (!B) {
    return true;
  }
  // A子树是空子树 且 B 非空，不 ok
  if (!A) {
    return false;
  }
  // 当前节点的值不相等，不 ok
  if (A.val !== B.val) {
    return false;
  }
  // 递归考察左子树、右子树
  return isSubTree(A.left, B.left) && isSubTree(A.right, B.right);
};
```

## 27. 二叉树的镜像

```js
var mirrorTree = function(root) {
  if (root === null) {
    return null;
  }

  // 交换左右节点
  let left = root.left;
  root.left = root.right;
  root.right = left;

  // 继续处理左右子树
  if (root.left) {
    mirrorTree(root.left);
  }

  if (root.right) {
    mirrorTree(root.right);
  }

  return root;
};
```

## 28. 对称的二叉树

```js
var isSymmetric = function(root) {
  if (!root) return true;
  return helper(root.left, root.right);
};

function helper(a, b) {
  if (!a && !b) return true;
  if (!a || !b || a.val !== b.val) return false;
  // 对称。 左树的左树与右树的右树比较； 左树的右树与右树的左树比较
  return helper(a.left, b.right) && helper(a.right, b.left);
}
```

## 29. 顺时针打印矩阵

```js
var spiralOrder = function(matrix) {
  let res = [];
  let flag = true;
  while (matrix.length) {
    // 从左到右
    if (flag) {
      // 第一层
      res = res.concat(matrix.shift());
      // '现在'的第一层到最后一层的末尾
      for (let i = 0; i < matrix.length; i++) {
        matrix[i].length && res.push(matrix[i].pop());
      }
      // 右到左
    } else {
      // 最后一层
      res = res.concat(matrix.pop().reverse());
      // '现在'的最后一层到第一层
      for (let i = matrix.length - 1; i > 0; i--) {
        matrix[i].length && res.push(matrix[i].shift());
      }
    }
    flag = !flag;
  }
  return res;
};

/**
 * 以下是测试代码
 */
spiralOrder([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);

spiralOrder([
  [1, 2, 3, 4],
  [4, 5, 6, 7],
  [8, 9, 10, 11],
]);
```
