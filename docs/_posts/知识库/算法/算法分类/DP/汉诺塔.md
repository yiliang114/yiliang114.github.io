---
title: 动态规划-汉诺塔
date: 2020-11-15
aside: false
draft: true
---

## 汉诺塔问题

汉诺塔(又称河内塔)问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

这里要构造一个输出移动过程的函数`move(n, a, b, c)`，其中 n 为 a 柱子的数量，a, b, c 分别代表三根柱子，a 为源柱子、b 为过渡柱子、c 为目标柱子。

函数调用方式：'A'柱子有 5 个盘子，全移动到'C'，调用(5, 'A', 'B', 'C')；全移动到'B'，则调用(5, 'A', 'C', 'B');

使用递归的思路，自然就是想着从最后一步倒推 n-1 步了。当我们手动尝试了 n=[1, 4]的情况后，基本就知道这个套路应该是怎样的了。

1. 当我们要移动 a 柱子的最大盘子 n 到 c 的话，那这一步的前提肯定是：比 n 小的盘子都在 b 上，我们才能将 n 号盘从 a --> c，这个场景也就是 n=1 的情况。
2. 接着就是如何将 b 中的 n-1 号盘移动到 c 呢？这一步就不用考虑 n 号盘了，因为他已经就位了，那这一步前提肯定是，比 n-1 小的盘子都在 a 上了，咦，这里不就是 1 的翻版吗？递归的规律已经出来了。
3. 然后想想怎么才能得到 1 这种局面呢？显然，就是要将 n-1 个盘子从 a 移动到 b 上面，怎么做？重复 1 和 2 不就完了？

所以盘子移动的套路就是：

1. 将 n-1 个盘子从 a 移动到 b：`move(n-1, a, c, b)`
2. 将 n 号盘从 a 移动到 c：`move(1, a, b, c)`
3. 将 n-1 个盘子从 b 移动到 c：`move(n-1, b, a, c)`

退出条件？n=1 呗，n=1 的时候，那自然就是`a --> c`了

总结：

```js
function hanoiTowerRecursive({ numberOfDiscs, fromPole, withPole, toPole, moveCallback }) {
  if (numberOfDiscs === 1) {
    // Base case with just one disc.
    moveCallback(fromPole.peek(), fromPole.toArray(), toPole.toArray());
    const disc = fromPole.pop();
    toPole.push(disc);
  } else {
    // In case if there are more discs then move them recursively.

    // Expose the bottom disc on fromPole stack.
    hanoiTowerRecursive({
      numberOfDiscs: numberOfDiscs - 1,
      fromPole,
      withPole: toPole,
      toPole: withPole,
      moveCallback,
    });

    // Move the disc that was exposed to its final destination.
    hanoiTowerRecursive({
      numberOfDiscs: 1,
      fromPole,
      withPole,
      toPole,
      moveCallback,
    });

    // Move temporary tower from auxiliary pole to its final destination.
    hanoiTowerRecursive({
      numberOfDiscs: numberOfDiscs - 1,
      fromPole: withPole,
      withPole: fromPole,
      toPole,
      moveCallback,
    });
  }
}

export default function hanoiTower({
  numberOfDiscs,
  moveCallback,
  fromPole = new Stack(),
  withPole = new Stack(),
  toPole = new Stack(),
}) {
  for (let discSize = numberOfDiscs; discSize > 0; discSize -= 1) {
    fromPole.push(discSize);
  }

  hanoiTowerRecursive({
    numberOfDiscs,
    fromPole,
    withPole,
    toPole,
    moveCallback,
  });
}
```

**举例**：(汉诺塔问题)有三个塔 A、B、C，一开始的时候，在塔 A 上放着 n 个盘子，它们自底向上按照从大到小的顺序叠放。现在要求将塔 A 中所有的盘子搬到塔 C 上，让你打印出搬运的步骤。在搬运的过程中，每次只能搬运一个盘子，另外，任何时候，无论在哪个塔上，大盘子不能放在小盘子的上面。

**解法**：

![](http://s0.lgstatic.com/i/image2/M01/91/12/CgoB5l2IjneAd7CsALPFsWgB1rw332.gif)

1. 从最终的结果出发，要把 n 个盘子按照大小顺序叠放在塔 C 上，就需要将塔 A 的底部最大的盘子搬到塔 C；
2. 为了实现步骤 1，需要将除了这个最大盘子之外的其余盘子都放到塔 B 上。

由上可知，将原来的问题规模从 n 个盘子变成了 `n - 1` 个盘子，即将 `n - 1` 个盘子转移到塔 B 上。

如果一个函数，能将 n 个盘子从塔 A，借助塔 B，搬到塔 C。那么，也可以利用该函数将 `n - 1` 个盘子从塔 A，借助塔 C，搬到塔 B。同理，不断地把问题规模变小，当 n 为 1，也就是只有 1 个盘子的时候，直接打印出步骤。

```js
function hanoi(A, B, C, n) {
  if (n > 0) {
    hanoi(A, C, B, n - 1);
    move(A, C);
    hanoi(B, A, C, n - 1);
  }
}
```
