---
title: 动态规划-DP-斐波那契
date: 2020-11-14
aside: false
draft: true
---

# 斐波那契

（动态规划法）公式：

```js
function fib(n) {
  if (n <= 1) return n;
  let i = 1,
    j = 1;
  for (let k = 3; k <= n; k++) {
    const sum = i + j;
    i = j;
    j = sum;
  }
  return j;
}
```

```js
// 时间复杂度 O(n) 空间复杂度 O(1)
function fib(n) {
  if (n < 3) return 1;
  let f = 0,
    s = 1;
  while (--n) {
    // s += f; // f + s
    // f = s - f; // 旧 s 值
    [f, s] = [s, f + s];
  }
  return s;
}
```

递归法

```js
function fib(n) {
  switch (n) {
    case 0:
      return 0;
    case 1:
      return 1;
    default:
      return fib(n - 1) + fib(n - 2);
  }
}
```

加缓存的递归

```js
let fib2 = memoize(n => {
  switch (n) {
    case 0:
      return 0;
    case 1:
      return 1;
    default:
      return fib2(n - 1) + fib2(n - 2);
  }
});

function memoize(fn) {
  let cache = new Map();
  return _ => {
    if (!cache.has(_)) {
      cache.set(_, fn(_));
    }
    return cache.get(_);
  };
}
```

## 真题

### 1. 爬楼梯

[70. Climbing Stairs (Easy)](https://leetcode-cn.com/problems/climbing-stairs/description/)

斐波那契数列 n 往后推了 1 项.

### 2. 强盗抢劫

[198. House Robber (Easy)](https://leetcode-cn.com/problems/house-robber/description/)

### 3. 强盗在环形街区抢劫

[213. House Robber II (Medium)](https://leetcode-cn.com/problems/house-robber-ii/description/)

跟上一题的差别在于，抢不抢第一户。

### 4. 信件错排

有 N 个信件和信箱，每封信件对应一个正确信箱位置。现在它们被打乱，求错误装信方式的数量。保证每一封信都装在错误的位置。

定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 k 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 `dp[i-2]` 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 `(i-1)*dp[i-2]` 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 `dp[i-1]` 种错误装信方式。由于 j 有 i-1 种取值，因此共有 `(i-1)*dp[i-1]` 种错误装信方式。

综上所述，错误装信数量方式数量为：

`dp[n] = (n - 1) * dp[n - 2] + (n - 1) * dp[n - 1]`

```js
/**
 * 动态规划-信件错排问题
 */
function MailMisalignment(n) {
  if (n == 0) return 0;
  if (n == 1) return 0;
  let dp = [];
  dp[0] = 0;
  dp[1] = 1;
  for (let i = 2; i < n; ++i) {
    dp[i] = (i - 1) * dp[i - 2] + (i - 1) * dp[i - 1];
  }
  return dp[n - 1];
}
```

### 5. 母牛生产

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

#### 思路分析

每一年的母牛数等于前一年的母牛数和三年前的母牛数。用 `dp[i]` 代表第 i 年的母牛数。

`dp[i] = dp[i-1] + dp[i-3]`

```js
function cowNums(n) {
  const dp = [];
  if (n == 0) return 0;
  if (n == 1) return 1;
  if (n == 2) return 2;
  if (n == 3) return 3;
  dp[0] = 0;
  dp[1] = 1;
  dp[2] = 2;
  dp[3] = 3;
  for (let i = 4; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 3];
  }
  return dp[n];
}
```
