---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### v-if 和 v-show 的区别

v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

### v-model.lazy

input 输入框 enter 键或失去焦点传数据

### v-model v-for 和 数组一起使用

https://segmentfault.com/q/1010000010718798/a-1020000010719502
通过 `list[x] = x` 这样的方式 不会被 vue 监听到，估计是个浅层监听吧。

### v-model 的背后实现？ v-input ? v-on 等指令系统

### Vue 性能优化问题。 v-for

### v-model 的实现原理

### vue 中的 v-html 中会导致的 xss

https://github.com/lynnic26/LynnNote/issues/1

解决办法？ vue 为什么会去做这一层转义？

### 如何在 v-html 中使用 filters

https://www.jianshu.com/p/29b7eaabd1b

### vue 的 sync 的原理

通过在子组件中 `this.$emit(update:target, value);` 在父组件中 `<SlotInputMain :SlotName.sync="SlotNameTest" />` 这样的形式，父组件就能够监听到子组件中的值。至于父组件中需要触发 input 事件还是 onchange 事件，全看子组件中触发 emit 的时机。

### 指令

`oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。

### vue 的 watch 是如何实现的？ mixin 是如何实现的？指令

### vue 指令处理，外部点击

https://github.com/xunleif2e/vue-clickout

### directive 执行是什么原理

### 指令

https://segmentfault.com/a/1190000012093024

### 请问 v-if 和 v-show 有什么区别

### v-on 可以监听多个方法吗？

### v-for 与 v-if 的优先级

### v-for 产生的列表，实现 active 的切换

### v-model 语法糖的组件中的使用

### 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

#### key 的作用是什么？

我重新梳理了一下文字，可能这样子会更好理解一些。

key 是给每一个 vnode 的唯一 id,可以`依靠key`,更`准确`, 更`快`的拿到 oldVnode 中对应的 vnode 节点。

##### 1. 更准确

因为带 key 就不是`就地复用`了，在 sameNode 函数 `a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。

##### 2. 更快

利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map 会比遍历更快。)

#### 完整

能提高 diff 效率其实是不准确的。

见[vue/patch.js](https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L424)，在不带 key 的情况下，判断[sameVnode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L35)时因为 a.key 和 b.key 都是 undefined，**对于列表渲染**来说已经可以判断为相同节点然后调用 patchVnode 了，实际根本不会进入到答主给的 else 代码，也就无从谈起“带 key 比不带 key 时 diff 算法更高效”了。

然后，官网推荐推荐的使用 key，应该理解为“使用唯一 id 作为 key”。因为 index 作为 key，和不带 key 的效果是一样的。index 作为 key 时，每个列表项的 index 在变更前后也是一样的，都是直接判断为 sameVnode 然后复用。

说到底，key 的作用就是更新组件时**判断两个节点是否相同**。相同就复用，不相同就删除旧的创建新的。

正是因为带唯一 key 时每次更新都不能找到可复用的节点，不但要销毁和创建 vnode，在 DOM 里添加移除节点对性能的影响更大。所以会才说“不带 key 可能性能更好”。看下面这个实验，渲染 10w 列表项，带唯一 key 与不带 key 的时间对比：

不使用 key 的情况：

```
<li v-for="item in list">{{ item.text }}</li>
```

[![image](https://user-images.githubusercontent.com/23716085/53108518-22543a80-3572-11e9-83b2-16b4aab7cdb9.png)](https://user-images.githubusercontent.com/23716085/53108518-22543a80-3572-11e9-83b2-16b4aab7cdb9.png)

使用 id 作为 key 的情况：

```
<li v-for="item in list" :key="item.id">{{ n.text }}</li>
```

[![image](https://user-images.githubusercontent.com/23716085/53108768-88d95880-3572-11e9-9f29-0082bf89eb3a.png)](https://user-images.githubusercontent.com/23716085/53108768-88d95880-3572-11e9-9f29-0082bf89eb3a.png)

list 构造：

```
  const list1 = []
  const list2 = []
  for (let i = 0; i <= 100000; i++) {
    list1.push({
      id: i,
      text: i
    })
    list2.push({
      id: i * 2,
      name: 100000 - i
    })
  }
```

因为不带 key 时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改 DOM 文本内容而不是移除/添加节点，这就是文档中所说的“刻意依赖默认行为以获取性能上的提升”。

既然如此，为什么还要建议带 key 呢？因为这种模式只适用于渲染简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。

举个例子：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过 tab 切换“娱乐新闻”或是“社会新闻”。

不带 key 属性的情况下，在“娱乐新闻”下选中第二项然后切换到“社会新闻”，"社会新闻"里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上新闻 id 作为唯一 key，那么每次渲染列表时都会完全替换所有组件，使其拥有正确状态。

这只是个简单的例子，实际应用会更复杂。带上唯一 key 虽然会增加开销，但是对于用户来说基本感受不到差距，而且能保证组件状态正确，这应该就是为什么推荐使用唯一 id 作为 key 的原因。至于具体怎么使用，就要根据实际情况来选择了。

以上个人见解，如有误望指正。

### Vue 的 v-html 指令，为什么 xss 没有生效

### 常见的自定义指令

#### vue-click-outside

https://github.com/ndelvalle/v-click-outside
