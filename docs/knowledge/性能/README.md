---
title: performance
date: 2020-11-21
draft: true
---

### 性能优化

- 网络部分
  - 尽量减少 HTTP 请求数
    - 合并文件
    - 雪碧图
    - 小图 Base64
  - 减少 DNS 查找
    - 开启 DNS 预解析
  - 使用 CND 静态资源服务器
  - 避免重定向
  - 杜绝 404
- 缓存
  - 配置 ETags
    - 实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制
  - 添上 Expires 或者 Cache-Control HTTP 头
  - 使用外链的方式引入 JS 和 CSS（缓存）
- 内容部分
  - 按需加载组件
  - 预加载组件
  - 减少 DOM 元素的数量
  - 尽量少用 iframe
  - 压缩 JavaScript 和 CSS（代码层面）
- CSS 部分
  - 避免使用 CSS 表达式
  - 选择`<link>`而不是`@import`
  - 避免使用滤镜
  - 把样式表放在顶部
- JS 部分
  - 把脚本放在底部， 加快渲染页面
  - 去除重复脚本
  - 减少 DOM 访问
  - 将脚本成组打包，减少请求
  - 使用非阻塞方式下载 js 脚本， 异步加载等
    - 动态脚本加载： 使用 JS 创建一个 script 标签再插入到页面中
    - defer（IE）：整个 HTML**解析完**后才会执行，如果是多个，按照加载顺序依次执行
    - async： **加载完**之后立即执行，如果是多个，执行和加载顺序无关
  - 大的文件使用 code split 进行切割，按需加载 js 文件
- 图片部分
  - 选用合适的图片格式
  - 雪碧图中间少留空白
  - 不要用 HTML 缩放图片，要小图就去加载小图
  - 用小的可缓存的 favicon.ico
  - 图片按需加载
- 组件的按需加载，接口按需请求，code split
- cookie
  - 给 cookie 减肥
    - 清除不必要的 cookie
    - cookie 尽可能小
    - 设置好合适的域
    - 合适的有效期
  - 把静态资源放在不含 cookie 的域下
    - 当浏览器发送对静态图像的请求时，cookie 也会一起发送，而服务器根本不需要这些 cookie。
- 移动端
  - 保证所有组件都小于 25K
  - 把组件打包到一个复合文档里
- 服务器
  - 开启 Gzip 等压缩
  - 避免图片 src 属性为空（为空浏览器也会向服务器发送另一个请求）
  - 对 Ajax 用 GET 请求
  - 尽早清空缓冲区
  - 使用 CDN（内容分发网络）
    - 内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。
- 表格(table)布局改为 DIV + CSS
- 减少代码间的耦合， 设计可扩展的 API， 复杂的计算不放在前端
- 实现良好的页面效果， 比如 loading 和骨架屏等

### 代码细节

- 尽量减少使用闭包
- 缓存 DOM 节点访问
- 避免使用 eval()和 Function()构造器
- 尽量使用直接量取创建对象和数组
- 最小化重绘(repaint)和回流(reflow)

### 总结

1. 减少 HTTP 请求，资源压缩合并，开启 gzip 压缩， 使用 CDN 加速静态资源
2. DNS 预解析
3. 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
4. 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
5. 当需要设置的样式很多时设置 className 而不是直接操作 style。
6. 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。
7. 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)。
8. 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
9. 非核心代码的异步加载
   1. 异步加载方式
   2. 异步加载的区别
10. 利用浏览器缓存
    1. 缓存分类
    2. 缓存原理
11. 避免空的 src 和 href
12. 为文件头指定 Expires
13. 使用 gzip 压缩内容
14. 把 CSS 放到顶部，把 JS 放到底部，避免使用 CSS 表达式
15. 将 CSS 和 JS 放到外部文件中
16. 避免跳转
17. 可缓存的 AJAX
18. 使用 GET 来完成 AJAX 请求

### 如何进行网站性能优化

- content 方面

  1. 减少 HTTP 请求：合并文件、CSS 精灵、inline Image
  2. 减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询
  3. 避免重定向：多余的中间访问
  4. 使 Ajax 可缓存
  5. 非必须组件延迟加载
  6. 未来所需组件预加载
  7. 减少 DOM 元素数量
  8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
  9. 减少 iframe 数量
  10. 不要 404

- Server 方面
  1. 使用 CDN
  2. 添加 Expires 或者 Cache-Control 响应头
  3. 对组件使用 Gzip 压缩
  4. 配置 ETag
  5. Flush Buffer Early
  6. Ajax 使用 GET 进行请求
  7. 避免空 src 的 img 标签
- Cookie 方面
  1. 减小 cookie 大小
  2. 引入资源的域名不要包含 cookie
- css 方面
  1. 将样式表放到页面顶部
  2. 不使用 CSS 表达式
  3. 使用<link>不使用@import
  4. 不使用 IE 的 Filter
- Javascript 方面
  1. 将脚本放到页面底部
  2. 将 javascript 和 css 从外部引入
  3. 压缩 javascript 和 css
  4. 删除不需要的脚本
  5. 减少 DOM 访问
  6. 合理设计事件监听器
- 图片方面
  1. 优化图片：根据实际颜色需要选择色深、压缩
  2. 优化 css 精灵
  3. 不要在 HTML 中拉伸图片
  4. 保证 favicon.ico 小并且可缓存
- 移动方面
  1. 保证组件小于 25k
  2. Pack Components into a Multipart Document

### 你如何对网站的文件和资源进行优化？

    期待的解决方案包括：
     文件合并
     文件最小化/文件压缩
     使用 CDN 托管
     缓存的使用（多个域名来提供缓存）
     其他

### 请说出三种减少页面加载时间的方法。

1. 优化图片
2. 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）
3. 优化 CSS（压缩合并 css，如 margin-top,margin-left...)
4. 网址后加斜杠（如 www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）
5. 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）
6. 减少 http 请求（合并文件，合并图片）。

### 面试题

**如何渲染几万条数据并不卡住界面**

这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 `requestAnimationFrame` 来每 16 ms 刷新一次。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      控件
    </ul>
    <script>
      setTimeout(() => {
        // 插入十万条数据
        const total = 100000;
        // 一次插入 20 条，如果觉得性能不好就减少
        const once = 20;
        // 渲染数据总共需要几次
        const loopCount = total / once;
        let countOfRender = 0;
        let ul = document.querySelector('ul');
        function add() {
          // 优化性能，插入不会造成回流
          const fragment = document.createDocumentFragment();
          for (let i = 0; i < once; i++) {
            const li = document.createElement('li');
            li.innerText = Math.floor(Math.random() * total);
            fragment.appendChild(li);
          }
          ul.appendChild(fragment);
          countOfRender += 1;
          loop();
        }
        function loop() {
          if (countOfRender < loopCount) {
            window.requestAnimationFrame(add);
          }
        }
        loop();
      }, 0);
    </script>
  </body>
</html>
```

1. 前端长列表的性能优化

只渲染页面用用户能看到的部分。并且在不断滚动的过程中去除不在屏幕中的元素，不再渲染，从而实现高性能的列表渲染。
借鉴着这个想法，我们思考一下。当列表不断往下拉时，web 中的 dom 元素就越多，即使这些 dom 元素已经离开了这个屏幕，不被用户所看到了，这些 dom 元素依然存在在那里。导致浏览器在渲染时需要不断去考虑这些 dom 元素的存在，
造成 web 浏览器的长列表渲染非常低效。因此，实现的做法就是捕捉 scroll 事件，当 dom 离开屏幕，用户不再看到时，就将其移出 dom tree。

### 插入几万个 DOM，如何实现页面不卡顿？

肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。部分人应该可以想到通过 `requestAnimationFrame` 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：**虚拟滚动**（virtualized scroller）。

**这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**

![滚动](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/vScroll.png)

从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这发问题。如果你想了解更多的内容可以了解下这个 [react-virtualized](https://github.com/bvaughn/react-virtualized)。

项目中使用过哪些优化方法
优化中会提到缓存的问题，问：静态资源或者接口等如何做缓存优化
页面 DOM 节点太多，会出现什么问题？如何优化？

### 2 万小球问题：在浏览器端，用 js 存储 2 万个小球的信息，包含小球的大小，位置，颜色等，如何做到对这 2 万条小球信息进行最优检索和存储

思路：

- 用 ArrayBuffer 实现极致存储
- 哈夫曼编码 + 字典查询树实现更优索引
- 用 bit-map 实现大数据筛查
- 用 hash 索引实现简单快捷的检索
- 用 IndexedDB 实现动态存储扩充浏览器端虚拟容量
- 用 iframe 的漏洞实现浏览器端 localStorage 无限存储，实现 2 千万小球信息存储

扩展：如何尽可能流畅的实现这 2 万小球在浏览器中，以直线运动的动效显示出来. 提供几个思路：

- 使用 GPU 硬件加速
- 使用 webGL
- 使用 assembly 辅助计算，然后在浏览器端控制动画帧频
- 用 web worker 实现 javascript 多线程，分块处理小球
- 用单链表树算法和携程机制，实现任务动态分割和任务暂停、恢复、回滚，动态渲染和处理小球

### 100 亿排序问题：内存不足，一次只允许你装载和操作 1 亿条数据，如何对 100 亿条数据进行排序

- 把这 100 亿的 int 型数据以文件形式存储到 100 个小文件中
- 对这 100 个小文件分别读取后排序再存入
- 遍历排序后对 100 个小文件，每个小文件里面取第一个数字, 组成一个 100 大数的堆
- new 个空的大文件存最后的结果
- 之后出 100 个数的那个堆,找到对应的小文件取数字,写入大文件, 记得 flash, gc 之类的
- 循环 3, 等所有的小文件都取完, 大文件就是存的最后结果

### 页面大量图片，如何优化加载，优化用户体验

图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
如果图片为 css 图片，可以使用 CSSsprite，SVGsprite 等技术。
如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。

### 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少

![image](https://user-images.githubusercontent.com/21194931/57821866-bd9d2a80-77c4-11e9-8c27-c38ed2752197.png)

数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)
消耗时间几乎一致，差异可以忽略不计

### 性能优化

- 减少 http 请求数
- vue 中 code spilt ，路由懒加载。
- css，js 放置位置， 异步加载 js
- 代码压缩、图片压缩
- 雪碧图
- 域名收敛和发散 也是一种优化
- 图片进行懒加载

### vuex 动态加载 namespace， 整个 store 树一起加载会很慢

- 首先，vuex 里面并不推荐使用 redux 的状态机，success error 等状态，都能够触发不同的自定义异步事件，至于 loading 的状态，应该是根据 vuex getter 中获取的数据，是否符合预期，符合预期就显示，如果不符合预期，比如报错了，如果不使用全局通知的话怎么全局显示 是一个问题？这就是状态机的必要之处吧？ 想一想这里如何进行处理。 如果能用全局通知的话，状态机似乎就真的没啥用了。

### 谈谈你对前端性能优化的理解:

a. 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域
b. 请求带宽：开启 GZip，精简 JavaScript，移除重复脚本，图像优化，将 icon 做成字体
c. 缓存利用：使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使
AjaX 可缓存
d. 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出
e. 代码校验：避免 CSS 表达式，避免重定向

### 一个页面上有大量的图片（大型电商网站），加载很慢

你有哪些方法优化这些图片的加载，给用户更好的体验。

a. 图片懒加载，滚动到相应位置才加载图片。
b. 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。
c. 使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术，如果图片为 css 图片的话。
d. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。

### 图片懒加载与预加载

图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比如先写在 data-src 里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载

图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在 css 的 background 的 url 属性里面，一种是通过 javascript 的 Image 对象设置实例对象的 src 属性实现图片的预加载。相关代码如下：
css 实现

```css
#preload-01 {
  background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px;
}
#preload-02 {
  background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px;
}
#preload-03 {
  background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px;
}
```

Javascript 预加载图片的方式：

```js
function preloadImg(url) {
  var img = new Image();
  img.src = url;
  if (img.complete) {
    //接下来可以使用图片了
    //do something here
  } else {
    img.onload = function() {
      //接下来可以使用图片了
      //do something here
    };
  }
}
```

预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。
两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。
懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力

### Gzip

差不多能压缩 1/4 的体积
https://blog.csdn.net/baidu_35407267/article/details/77141871
es6 以上不支持 uglify 需要压缩代码的话，要使用 babel 的 minify

### react-loadable

react-loadable 用来创建动态路由，能够根据路由进行 code spliting。

但是，所有有切换状态的组件上，都使用 react-loadable 会造成 js 文件过多的问题么？

### 常见的网页性能优化方法

- 减少 HTTP 请求。使用雪碧图、内联图片，合并脚本和样式表。
- 使用内容分发网络（CDN）
- 添加 Expires 头
- 压缩组件。压缩样式表和脚本，开启 gzip 压缩大概减少 70%的大小
- 样式表放在顶部
- 将脚本放在底部
- 避免 CSS 表达式
- 使用外部 JavaScript 和 CSS
- 减少 DNS 查找
- 精简 JavaScript
- 避免重定向。网站中除了域名首页外缺少斜杠将引起 301 重定向，个人测试工作室网站这个重定向消耗的时间在 30ms 左右
- 删除重复脚本
- 配置 ETag
- 使 Ajax 可缓存

##### 客户端优化

- 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。
- 使用 CSS 雪碧图（CSS Sprites）CSS Sprites 一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的 HTTP 请求。
- 减少 DOM 操作次数，优化 javascript 性能。
- 少用全局变量、减少 DOM 操作、缓存 DOM 节点查找的结果。减少 IO 读取操作。
- 延迟加载 | 延迟渲染
- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
- 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。

##### 服务端优化

- 尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，压缩 css 和 js；或加快文件读取速度，优化服务端的缓存策略。
- 客户端优化 dom、css 和 js 的代码和加载顺序；或进行服务器端渲染，减轻客户端渲染的压力。
- 优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。

##### 缓存

http 缓存 设置好 cache-control expires Last-modified；
前端缓存 对于一些页面今天配置直接存储到 localStorage 中；对于长期不发生改变的代码可以直接通过 server-work 存储到本地；

##### 优化加载

webpack 开启 tree-shaking 减少代码体积
通过 preload prefetch 优化加载资源的时间
import('').then()异步加载资源
图片小于 30k 的图片直接做成 base64；
对于首屏的样式可以直接内嵌到 html 中；

##### 服务端渲染

SSR
对于首页可以直接通过 node jade 模板引擎输出，其他页面继续使用前端渲染，优化首屏、SEO

### 移动端性能优化

- 尽量使用 css3 动画，开启硬件加速。
- 适当使用`touch`事件代替`click`事件。
- 避免使用`css3`渐变阴影效果。
- 可以用`transform: translateZ(0)`来开启硬件加速。
- 不滥用 Float。Float 在渲染时计算量比较大，尽量减少使用
- 不滥用 Web 字体。Web 字体需要下载，解析，重绘当前页面，尽量减少使用。
- 合理使用 requestAnimationFrame 动画代替 setTimeout
- CSS 中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发 GPU 渲染，请合理使用。过渡使用会引发手机过耗电增加
- PC 端的在移动端同样适用

### 异步加载和延迟加载

1. 异步加载的方案： 动态插入 script 标签
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行
3. script 标签上添加 defer 或者 async 属性
4. 创建并插入 iframe，让它异步执行 js
5. 延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的

## 网络优化

压缩传输内容，用好缓存

### 合并资源文件，减少 HTTP 请求

浏览器并发的 HTTP 请求是由数量限制的（比如桌面浏览器并发请求可能是 8 个，手机浏览器是 6 个），如果一下子并发的几十个请求那么会有很多请求会停下来等，等前面的请求好了下一个再进去，这样就延长了整个页面的加载时间

### 压缩资源文件减小请求大小

文件大小越小当然加载速度就越快。
可对代码进行压缩，去掉空格、注释、变量替换，在传输时，使用 gzip 等压缩方式也可以降低资源文件的大小。

### 利用缓存机制，尽可能使用缓存减少请求

浏览器是有缓存机制的，在返回资源的时候设置一个 cache-control 设置过期时间，在过期时间内浏览器会默认使用本地缓存。

但缓存机制也存在一定的问题，因为网站开发是阶段性的，隔一段时间会发布一个新的版本。因为 HTTP 请求是根据 url 来定位的，如果资源文件名的 url 没有发生更改那么浏览器还是会使用缓存，这个时候怎么办那？
这时就需要一个缓存更新机制来让修改过的文件具有一个新的名字。
最简单的方法就是在 url 后加一个时间戳，但是这会导致只要有新的版本发布就会重新获取所有的新资源。
一个现代流行的方法就是根据文件计算一个 hash 值，这个 hash 值是根据文件的更新变化而变化的。 当浏览器获取文件时如果这个文件名有更新那么就会请求新的文件。

### 使用 HTTP / 2.0

- 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间
- 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小

### DNS 预解析

- DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP

现代浏览器在 DNS Prefetch 上做了两项工作：

1. html 源码下载完成后，会解析页面的包含链接的标签，提前查询对应的域名

2. 对于访问过的页面，浏览器会记录一份域名列表，当再次打开时，会在 html 下载的同时去解析 DNS

**自动解析**

浏览器使用超链接的 href 属性来查找要预解析的主机名。当遇到 a 标签，浏览器会自动将 href 中的域名解析为 IP 地址，这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在 HTTPS 页面中不会自动解析

**手动解析**

```html
预解析某域名
<link rel="dns-prefetch" href="//img.alicdn.com" />

强制开启HTTPS下的DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on" />
```

### CDN

CDN 的原理是尽可能的在各个地方分布机房缓存数据。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

- CDN 是一种部署策略，根据不同的地区部署类似 nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在静态资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源
- (CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理 4 个要件

### 负载均衡

当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力

### 预加载

- 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载
- 预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com" />
```

> 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好

### 预渲染

> 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

- 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

### 使用 Cookie 隔离

- 通过将一些静态资源或者不需要通过鉴权的请求转移到非主域名下去，因为跨域的限制，主域名的一些 cookie 就不会带上，降低请求头的大小，节省流量，降低时延。
- server 不会接收到 cookie ， 因此也减少了 server 对 cookie 的处理时间，提高 server 的请求解析速度。

## 文件优化

- CSS 文件放在 `head` 中
- 服务端开启文件压缩功能
- 将 `script` 标签放在 `body` 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 `script` 标签放在任意位置然后加上 `defer` ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 `async` ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。
- 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 `Webworker`。`Webworker` 可以让我们另开一个线程执行脚本而不影响渲染。

## 代码层面

- 防抖
- 节流

## 其他

### 使用 Webpack 优化项目

- 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
- 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 base64 的方式写入文件中
- 按照路由拆分代码，实现按需加载
- 给打包出来的文件名添加哈希，实现浏览器缓存文件

### 首屏加载优化

- Vue-Router 路由懒加载（利用 Webpack 的代码切割）
- 使用 CDN 加速，将通用的库从 vendor 进行抽离
- Nginx 的 gzip 压缩
- Vue 异步组件
- 服务端渲染 SSR
- 如果使用了一些 UI 库，采用按需加载
- Webpack 开启 gzip 压缩
- 如果首屏为登录页，可以做成多入口
- Service Worker 缓存文件处理
- 使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

### 对组件库的优化

- 提供按需加载
- 图片、样式等走 cdn，懒加载等
- table list 海量数据，虚拟列表
- 页面加载海量数据
  - https://juejin.im/post/5ae17a386fb9a07abc299cdd

### 前端性能优化的考虑 2020.11.02

1. 网页长度超出一个窗口屏幕比较多的时候，需要考虑图片、接口的懒加载
2. webpack 的 code split 拆分 bundle 包大小之后，由于大多引用的是 min.js 文件 cdn 因此对于错误的堆栈不清晰，采用上传 sourcemap 恢复真实的行数的形式，类似 sentry 的操作。
3. 前端组件的 keep-alive ，页面退出及时 cancel 未完成的请求（封装 axios）
