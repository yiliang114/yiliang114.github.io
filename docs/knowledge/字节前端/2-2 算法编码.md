---
title: 算法编码
date: 2020-12-16
draft: true
---

## 原题

### [1].两数之和 twoSum

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

```js
// 80 ms	39.8 MB
var twoSum = function(nums = [], target) {
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    if (map[target - nums[i]] !== undefined) {
      return [map[target - nums[i]], i];
    }
    map[nums[i]] = i;
  }
};
```

```js
// 76 ms	39.8 MB
var twoSum = function(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i];
    }
    map.set(nums[i], i);
  }
};
```

事实证明，{} 与 Map 的存取速度差不多

### [19].删除链表的倒数第 n 个节点 Remove-Nth-Node-From-End-of-List

```html
Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes
1->2->3->5.
```

#### 思路

双指针，指针 A 先移动 n 次， 指针 B 再开始移动。当 A 到达 null 的时候， 指针 b 的位置正好是倒数 n

#### 代码

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let dummy = new ListNode(0);
  dummy.next = head;
  let fast = dummy;
  let slow = dummy;

  for (let i = 1; i <= n + 1; i++) {
    fast = fast.next;
  }
  while (fast != null) {
    fast = fast.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return dummy.next;
};
```

### [20].有效的括号 validParentheses

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true

#### 思路

使用栈, 遍历输入字符串, 如果当前字符为左半边括号时，则将其压入栈中, 如果遇到右半边括号时，分类讨论：

1. 如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环
2. 若此时栈为空，则直接返回 false
3. 若不为对应的左半边括号，反之返回 false

#### 代码

```js
var isValid = function(s) {
  let valid = true;
  const stack = [];
  const hashmap = {
    '{': '}',
    '[': ']',
    '(': ')',
  };

  for (let i in s) {
    const v = s[i];
    if (['(', '[', '{'].indexOf(v) > -1) {
      stack.push(v);
    } else {
      const peak = stack.pop();
      if (v !== hashmap[peak]) {
        return false;
      }
    }
  }

  if (stack.length > 0) return false;

  return valid;
};
```

```js
// 最高赞
var isValid = function(s) {
  var st = [];
  for (var l of s)
    if ((i = '({[]})'.indexOf(l)) > -1)
      if (st[st.length - 1] + i === 5)
        // 相加为 5 则意味着匹配上了。 另 length-- 操作直接删除了顶部元素
        st.length--;
      else st.push(i);
  return st.length === 0;
};
```

```js
console.log(isValid('()[]{}'));
console.log(isValid('[()][]{}'));
console.log(isValid('(])'));
```

### [21].合并两个有序链表 merge-two-sorted-lists

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

### [22].括号匹配 Generate-Parentheses

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

For example, given n = 3, a solution set is:
[
"((()))",
"(()())",
"(())()",
"()(())",
"()()()"
]

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  var ans = [];
  helper(ans, '', 0, 0, n);
  return ans;
};

function helper(ans, str, left, right, n) {
  if (right === n) ans.push(str);
  if (left < n) {
    helper(ans, str + '(', left + 1, right, n);
  }
  if (right < left) {
    helper(ans, str + ')', left, right + 1, n);
  }
}
```

```js
let result = [];

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  dfs(n, 1, 1, '(');
  return result;
};

function dfs(n, sum, used, s) {
  if (s.length == 2 * n) {
    result.push(s);
    return;
  }
  if (sum == 0) {
    dfs(n, sum + 1, used + 1, s + '(');
  } else if (sum == n || used == n) {
    dfs(n, sum - 1, used, s + ')');
  } else {
    dfs(n, sum + 1, used + 1, s + '(');
    dfs(n, sum - 1, used, s + ')');
  }
}
```

### [23].合并 K 个升序链表 merge-k-sorted-lists

[link](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```

#### 关键点解析

这道题目是合并 k 个已排序的链表，号称 leetcode 目前`最难`的链表题。

- 分治
- 合并排序(merge sort)

当 k=1 的时候，直接返回结果；当 k=2 的时候，把这两个链表归并。当 k=3 的时候，我们可以把它们分成两组，分别归并完毕后再进行最后的归并操作，如下。

![](http://s0.lgstatic.com/i/image2/M01/91/50/CgotOV2InqWAExguACYe_inhacY345.gif)

上述做法运用了典型的分治思想，非常类似归并排序操作。

**时间复杂度**：O(nk×log(k))。
**空间复杂度**：O(1)。因为不像最小堆解法那样需要维护一个额外的数据结构。

#### 代码

```js
var mergeKLists = function(lists) {
  const len = lists.length;
  if (!len) return null;
  if (len === 1) return lists[0];
  if (len === 2) return mergeTwoLists(...lists);

  const mid = len >> 1;
  const result = mergeTwoLists(mergeKLists(lists.slice(0, mid)), mergeKLists(lists.slice(mid)));
  return result;
};

function mergeTwoLists(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

##### 解题思路二：最小堆法

面对 k 个排好序的链表时，最小的那个数肯定是从这 k 个链表的头里面选出来。

那么，第二小的如何选择？例如，有下面 k 个链表。 ![](http://s0.lgstatic.com/i/image2/M01/91/30/CgoB5l2InqSAHLY0ACSlxIOkYh0731.gif)

1.  把最小的 1 从所有的 k 个链表头里选出来之后，把 1 从链表里删掉。

2.  下一个最小的数，还是从所有的 k 个链表头里选出来。

3.  以此类推，每一轮都比较 k 个新的链表头的大小，得出最后的结果。

上述操作的时间复杂度是 O(k)。而针对找出最小的数，可以使用最小堆来提高效率。时间复杂度计算如下。

1.  对 k 个链表头创建一个大小为 k 的最小堆，在第 2 课中提到创建一个大小为 k 的最小堆所需的时间是 O(k)；

2.  从堆里取出最小的数，都是 O(lg(k))；

3.  若每个链表的平均长度为 n，一共有 nk 个元素，即用大小为 k 的最小堆去过滤 nk 个元素；

4.  整体的时间复杂度就是 O(nk×log(k))。

维护这个大小为 k 的最小堆，直到遍历完所有 k 个链表里的所有元素。

**代码实现**

public ListNode mergeKLists(ListNode\[\] lists) {
    //利用一个空的链表头方便插入节点。
    ListNode fakeHead = new ListNode(0), p = fakeHead;
    int k = lists.length;

//  定义一个最小堆来保存  k  个链表节点；将  k  个链表的头放入到最小堆里。
    PriorityQueue<ListNode> heap =
        new PriorityQueue<>(k, new Comparator<ListNode>() {
            public int compare(ListNode a, ListNode b) {
                return a.val - b.val;
            }
        });

//  从最小堆里将当前最小的节点取出，插入到结果链表中。
    for (int i = 0; i < k; i++) {
        if (lists\[i\] != null) {
            heap.offer(lists\[i\]);
        }
    }

while (!heap.isEmpty()) {
        ListNode node = heap.poll();

p.next = node;
        p = p.next;

//  如果发现该节点后面还有后续节点，将后续节点加入到最小堆里。
        if (node.next != null) {
            heap.offer(node.next);
        }
    }
    return fakeHead.next;

}

### [24].交换链表中的相邻结点 swapPairs

```html
Given 1->2->3->4, you should return the list as 2->1->4->3.
```

题目要求：不能修改结点的 val 值，O(1) 空间复杂度。

```js
var swapPairs = function(head) {
  const dummy = new ListNode(0);
  dummy.next = head;

  let pre = dummy,
    cur = dummy.next,
    next = null;
  // 仍然存在两个节点
  while (cur && cur.next) {
    next = cur.next.next;
    cur.next.next = cur;

    // 首先需要保证前面能链接上
    pre.next = cur.next;
    cur.next = next;

    pre = cur;
    cur = next;
  }
  return dummy.next;
};
```

```js
var swapPairs = function(head) {
  if (head === null || head.next === null) {
    return head;
  }
  // 相当于先拿两个节点进行处理
  const newHead = head.next;
  head.next = swapPairs(newHead.next);
  newHead.next = head;
  return newHead;
};
```

### [25].K 个一组翻转链表 reverseKGroup

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：

- 你的算法只能使用常数的额外空间。
- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：

给定这个链表：`1->2->3->4->5`

当 k=2 时，应当返回：`2->1->4->3->5`

当 k=3 时，应当返回：`3->2->1->4->5`

解题思路

这道题考察了两个知识点：

1.  对链表翻转算法是否熟悉
2.  对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif)

1.  将 curr 指向的下一节点保存到 next 指针；
2.  curr 指向 prev，一起前进一步；
3.  重复之前步骤，直到 k 个元素翻转完毕；
4.  当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。

**注意**：这道题是“LeetCode 第 24 题，两个一组翻转链表“的扩展，即当 k 等于 2 时，第 25 题就变成了第 24 题。

## 排序

### 冒泡排序(稳定)

原地排序、稳定排序。每次两两比较，大的放到后面。每一次遍历都会将最后一位“就位”。

- 最好 O(n)
- 最坏 O(n^2)
- 平均 O(n^2)

```js
function sort(arr = []) {
  const len = arr.length;
  // 外层，需要遍历的次数
  for (let i = 0; i < len - 1; i++) {
    // 内层，每次比较
    for (let j = i + 1; j < len; j++) {
      if (arr[i] > arr[j]) {
        // 大的放到后面
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  }
  return arr;
}
```

### 选择排序(不稳定)

选择排序，从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。

原地排序；不稳定排序

复杂度：

- 最好 O(n^2)
- 最坏 O(n^2)
- 平均 O(n^2)

```js
function sort(arr) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    let min = i;
    // 找到第 n 个最小值。 在 arr[i + 1, arr.length - 1] 中找最小值索引， i+1 代表有序的下一个数，我们默认第一个元素是最小的
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) min = j;
    }
    // 每次循环， a[i] 位都将是未选择出的数据中的最小值
    if (min !== i) {
      [arr[i], arr[min]] = [arr[min], arr[i]];
    }
  }
  return arr;
}
```

### 快速排序(不稳定)

时间复杂度 O(nlogn)

```js
function swap(a, i, j) {
  let temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}

function quickSort(arr, start = 0, end = arr.length - 1) {
  if (arr && arr.length < 2) return arr;
  if (start >= end) return;

  let target = arr[start],
    i = start,
    j = end;

  while (i < j) {
    while (target <= a[j] && i < j) j--;
    while (target >= a[i] && i < j) i++;

    if (i < j) swap(arr, i, j);
  }

  // i === j
  swap(arr, start, i);
  quickSort(arr, start, i - 1);
  quickSort(arr, i + 1, end);

  return arr;
}
```

## 二分查找

非递归版本：

```js
const binarySearch = (arr, target) => {
  let i = 0,
    j = arr.length - 1;
  while (i <= j) {
    let mid = i + ((j - i) >> 1);
    if (target === arr[mid]) return mid;
    if (target < arr[mid]) {
      j = mid - 1;
    } else {
      i = mid + 1;
    }
  }
  return -1;
};
```

递归版本：

```js
const binarySearch = (a, left, right, key) => {
  const mid = (left + right) >> 1;
  if (a[mid] === key) return mid;
  if (a[mid] > key) return binarySearch(a, left, mid - 1, key);
  if (a[mid] < key) return binarySearch(a, mid + 1, right, key);
};
```

## 斐波那契

时间复杂度 O(n) 空间复杂度 O(1)

```js
var fib = function(n) {
  if (n < 2) return n;
  let i = 0,
    j = 1;
  while (n > 1) {
    [i, j] = [j, i + j];
    n--;
  }
  return j;
};
new Array(10).fill(0).forEach((item, index) => console.log(fib(index)));
```

## 字符串/数组

两数之和：找出数组中两个元素的和为 target 的组合
三数之和

给定两个无重复升序数组，求合并之后数组。如给定 m={1,2,3},n{2,4,5},则应输出{1,2,3,4,5}
合并乱序区间
两个无序数组合并成一个有序数组，问时间复杂度。 延伸：快排和冒泡排序的时间复杂度，使用场景
合并 k 个有序数组
数组中的第 K 个最大元素
在一个无序数组中找到第二大的数

回文字符串，字符串中最长回文子串
字符串中的第一个唯一字符
找出字符串中第一个不重复的字符
给定一个字符串，找出其中无重复字符的最长子字符串长度 ![](https://pic4.zhimg.com/80/v2-d8136dca742eb7560c23d1a39e99e86b_1440w.jpg) ![](https://pic1.zhimg.com/80/v2-291f6f8dcd093229bb7d0a9102c826dc_1440w.jpg)

给一数组和一数字，求数组中出现次数大于数组长度除该数字的项？
数组中数字出现的次数 https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/

实现一个 match 函数 判断 `()()()[] => true` , `{{[(){}[]}}=>true , {{{[]][]}}}[] =>false`
数组顺时针螺旋遍历
搜索旋转排序数组

剑指 Offer 39. 数组中出现次数超过一半的数字
剑指 Offer 50. 第一个只出现一次的字符 45° 打印矩阵，回形打印矩阵

### 实现 reduce

```js
function reduce(array, fn, value) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    value = fn(value, current, i, array);
  }
  return value;
}
```

### 整数数组的最大子串和

```js
// 求整数数组的最大子串和，如 [-23, 17, -7, 11, -2, 1, -34] 的最大子串和是21，对应子串是 [17, -7, 11]
function maxSeqSum(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const len = arr.length;
  let maxSum = arr[0];
  let seqSum = arr[0];
  for (let i = 1; i < len; i++) {
    if (seqSum <= 0) {
      seqSum = arr[i];
    } else {
      seqSum += arr[i];
    }
    if (seqSum > maxSum) {
      maxSum = seqSum;
    }
  }
  return maxSum;
}
```

### 合并两个有序数组

```js
function mergeSortedArray(arrA, arrB) {
  var result = [];
  var i = 0,
    j = 0,
    targetLen = arrA.length,
    toolLen = arrB.length;

  while (i < targetLen && j < toolLen) {
    if (arrA[i] < arrB[j]) {
      result.push(arrA[i++]);
    } else {
      result.push(arrB[j++]);
    }
  }

  while (i < targetLen) {
    result.push(arrA[i++]);
  }
  while (j < toolLen) {
    result.push(arrB[j++]);
  }
  return result;
}
```

### 查找第 K 大的数

```js
function findKMax(a, k) {
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  let len = a.length - key;

  while (len !== k) {
    if (len > k) {
      key = partition(a, key + 1, right);
    } else {
      key = partition(a, left, key - 1);
    }
    len = a.length - key;
  }

  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让 key 为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把 key 现在所在的下标返回
}
```

### 最长无重复子串

```js
var lengthOfLongestSubstring = function(s = '') {
  let start = 0,
    longestLen = 0;
  const map = {};

  for (let i = 0; i < s.length; i++) {
    const val = s[i];

    if (val in map && map[val] >= start) {
      // 旧节点往后移一位
      start = map[val] + 1;
      map[val] = i;
    } else {
      map[val] = i;
      longestLen = Math.max(longestLen, i + 1 - start);
    }
  }
  return longestLen;
};
```

### 洗牌算法 shuffle

算法思想就是 从原始数组中随机抽取一个新的元素到新数组中

```js
function shuffle(arr) {
  var result = [],
    random;
  while (arr.length > 0) {
    random = Math.floor(Math.random() * arr.length);
    result.push(arr[random]);
    arr.splice(random, 1);
  }
  return result;
}
```

## 链表

实现一个函数，将输入的数组转为链表，并实现一个方法向链表指定位置插入值
环形链表
从排好序的两个链表中，找到相同的节点，并输出链表
面试题 02.07. 链表相交

### 反转链表

```js
// 递归
var reverseList = function(head) {
  let reverse = (prev, curr) => {
    if (!curr) {
      return prev;
    }
    let next = curr.next;
    curr.next = prev;
    return reverse(curr, next);
  };
  return reverse(null, head);
};
```

```js
// 迭代
var reverseList = function(head) {
  let prev = null;
  let curr = head;
  while (curr != null) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
};
```

### 合并两个排序的链表

合并 2 个有序单链表成为 1 个新的有序单链表

#### 思路分析

准备一个指针`node`，假设指向两个链表的中节点的指针分别是：`p1`和`p2`。

1. 比较`p1`和`p2`的`value`大小

- 如果，p1.value 小于 p2.value, node.next 指向 p1, p1 向后移动
- 否则，node.next 指向 p2, p2 向后移动

2. 重复第 1 步，直到其中一个链表遍历完
3. 跳出循环，将 node.next 指向未遍历完的链表的剩余部分

整个过程的时间复杂度是 O(N), 空间复杂度是 O(1)

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

### 两个链表的第一个公共结点

#### 思路一：栈实现

在第一个公共节点前的节点都是不相同的，因此只要倒序遍历两个链表，找出最后一个出现的相同节点即可。

因为链表不能倒序遍历，所以借助栈实现。

```js
/**
 * 思路一：利用栈实现
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method1(list1, list2) {
  const stack1 = [],
    stack2 = [];

  let node = list1;
  while (node) {
    stack1.push(node);
    node = node.next;
  }

  node = list2;
  while (node) {
    stack2.push(node);
    node = node.next;
  }

  node = null;
  while (stack1.length && stack2.length) {
    let top1 = stack1.pop(),
      top2 = stack2.pop();
    if (top1 === top2) {
      node = top1;
    } else {
      break;
    }
  }

  return node;
}
```

#### 思路二：快慢指针

假设链表 A 长度大于链表 B 长度，它们的长度差为 diff。

让 A 的指针先移动 diff 的位移，然后 A 和 B 的指针再同时向后移动，每次比较节点，选出第一个出现的相同节点。

```js
/**
 * 思路二：快慢指针
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method2(list1, list2) {
  let length1 = 0,
    length2 = 0;

  let node = list1;
  while (node) {
    ++length1;
    node = node.next;
  }

  node = list2;
  while (node) {
    ++length2;
    node = node.next;
  }

  let diff = Math.abs(length1 - length2),
    longList = null,
    shortList = null;
  if (length1 > length2) {
    longList = list1;
    shortList = list2;
  } else {
    longList = list2;
    shortList = list1;
  }

  while (diff > 0) {
    longList = longList.next;
    --diff;
  }

  while (longList && shortList) {
    if (longList === shortList) {
      return longList;
    }
    longList = longList.next;
    shortList = shortList.next;
  }

  return null;
}
```

#### 思路三： 另一种快慢指针

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```js
function findFirstCommonNode(pHead1, pHead2) {
  const len1 = getLinkLength(pHead1),
    len2 = getLinkLength(pHead2);

  let pLong = pHead1,
    pShort = pHead2,
    lenGap = len1 - len2;
  if (len1 < len2) {
    pLong = pHead2;
    pShort = pHead1;
    lenGap = len2 - len1;
  }
  while (lenGap--) {
    pLong = pLong.next;
  }
  while (pLong !== null) {
    // pLong,pShort一起跑
    if (pLong.val === pShort.val) {
      return pLong;
    }
    pLong = pLong.next;
    pShort = pShort.next;
  }
  return null;
}

function getLinkLength(pHead) {
  let length = 0;
  while (pHead !== null) {
    pHead = pHead.next;
    length++;
  }
  return length;
}
```

### 判断链表是否存在环

使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。

```js
/**
 * 哈希表 Set add has 来查询
 * 牺牲了空间换时间
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  // 停止条件： 1. Set 判断出有环 2. 无环，正常结束
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

```js
/**
 * 快慢指针。 如果有环，快指针一定能追上慢指针
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // 快指针一次移动两个
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### 回文链表

请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用  O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

快慢指针，起初都指向表头，快指针一次走两步，慢指针一次走一步，遍历结束时：

要么，slow 正好指向中间两个结点的后一个。
要么，slow 正好指向中间结点。
用 prev 保存 slow 的前一个结点，通过 prev.next = null 断成两个链表。

将后半段链表翻转，和前半段从头比对。空间复杂度降为 O(1)。

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  let fast = head,
    slow = head;
  while (fast != null && fast.next !== null) {
    // 慢指针一次走一步
    slow = slow.next;
    // 快指针一次走两步
    fast = fast.next.next;
  }
  slow = reverseList(slow);
  // slow 一定比 head 要短，所以不用判读较长的链表的情况
  while (slow != null) {
    if (slow.val != head.val) return false;
    slow = slow.next;
    head = head.next;
  }
  return true;
};

var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

## 栈/队列

基本计算器
基本计算器 II
用队列实现栈
剑指 Offer 09. 用两个栈实现队列

## 二叉树

### 二叉树前中后遍历

#### 递归

前序

```js
const res = [];
var inorderTraversal = function(root) {
  if (root === null) return;
  // 中-左-右
  res.push(root);
  inorderTraversal(root.left);
  inorderTraversal(root.right);
  return res;
};
```

中序

```js
const res = [];
var inorderTraversal = function(root) {
  if (root === null) return;
  // 左-中-右
  inorderTraversal(root.left);
  res.push(root);
  inorderTraversal(root.right);
  return res;
};
```

后序

```js
const res = [];
var inorderTraversal = function(root) {
  if (root === null) return;
  // 左-右-中
  inorderTraversal(root.left);
  inorderTraversal(root.right);
  res.push(root);
  return res;
};
```

#### 非递归

前序遍历

```js
function preorderTraversal(root) {
  if (!root) return null;
  const ret = [];
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    ret.push(node.val);
    // 先右后左，保证左子树先遍历
    stack.push(node.right);
    stack.push(node.left);
  }
  return ret;
}
```

中序遍历

```js
// 迭代
var inorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根.
  while (root || stack.length) {
    if (root) {
      // 先往左，迭代存入所有的根
      stack.push(root);
      root = root.left;
    } else {
      // 拿出根之后，先压入左值
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};
```

后序遍历

```js
function postOrderTraversal(root) {
  if (!root) return null;
  const ret = [];
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    if (node == null) continue;
    ret.push(node.val);
    stack.push(node.left);
    stack.push(node.right);
  }
  return ret.reverse();
}
```

### 二叉树层次遍历

层次遍历二叉树

树的遍历有几种方式，实现下层次遍历

二叉树深度优先遍历(递归、非递归)
二叉树广度优先遍历(递归、非递归)

### 二叉树先序中序 生成后序

### 构造一棵二叉树

### 判断对称二叉树

### 二叉搜索树中第 K 小的元素

```js
let kthSmallest = function(root, k) {
  let res = null;
  let inOrderTraverseNode = function(node) {
    if (node !== null && k > 0) {
      // 先遍历左子树
      inOrderTraverseNode(node.left);
      // 然后根节点
      if (--k === 0) {
        res = node.val;
        return;
      }
      // 再遍历右子树
      inOrderTraverseNode(node.right);
    }
  };
  inOrderTraverseNode(root);
  return res;
};
```

### 合并二叉树

```js
/**
 * 递归思想
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
  if (t1 === null) return t2;
  if (t2 === null) return t1;
  t1.val += t2.val;
  t1.left = mergeTrees(t1.left, t2.left);
  t1.right = mergeTrees(t1.right, t2.right);
  return t1;
};
```

### 翻转二叉树

```js
var mirrorTree = function(root) {
  if (root === null) {
    return null;
  }
  // 交换左右节点
  let left = root.left;
  root.left = root.right;
  root.right = left;
  // 继续处理左右子树
  if (root.left) {
    mirrorTree(root.left);
  }
  if (root.right) {
    mirrorTree(root.right);
  }
  return root;
};
```

### [104].二叉树的最大深度 Maximum Depth of Binary Tree

```js
/**
 * 递归
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### [105].从前序与中序遍历序列构造二叉树

> 剑指 offer 7 重建二叉树

```js
/**
 * 根据前序遍历和中序遍历重构二叉树
 * @param {Array} preorder
 * @param {Array} inorder
 * @return {Node}
 */
var buildTree = function(preorder, inorder) {
  if (!preorder.length || !inorder.length) return null;
  // 前序的第一个值为根节点
  const headValue = preorder[0];
  // 前序第一个是根节点，也是中序左右子树的分割点
  // 通过变量 index 可以确定在 前序遍历 / 中序遍历中 确定 左 / 右子树的长度
  const index = inorder.findIndex(val => val === headValue);
  if (index === -1) return null;

  // 递归左右子树的前序、中序
  const left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));
  const right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));
  return new TreeNode(headValue, left, right);
};
```

### 求根节点到叶节点数字之和

```js
var sumNumbers = function(root, t = 0) {
  if (!root) return 0;
  if (!root.left && !root.right) return t + root.val;
  t = (t + root.val) * 10;
  return sumNumbers(root.left, t) + sumNumbers(root.right, t);
};
```

### 和为 n 的二叉树路径

找到二叉树路径和为 n 的路径

给一个二叉树和一个值，问是否有一条路径上的值相加等于该值的，有就返回 true，没有就返回 false
蛇形二叉树
求二叉树每层的最大节点

二叉树中的所有路径
二叉树中和为某一值的路径
给定一个二叉树, 找到该树中两个指定节点间的最短距离

平衡二叉树
路径总和
路径总和 II
剑指 Offer 28. 对称的二叉树
剑指 Offer 55 - I. 二叉树的深度前中后序知道其二还原二叉树

### 剑指 Offer 32 - I. 从上到下打印二叉树

```js
var levelOrder = function(root) {
  const res = [];
  function traversal(root, depth) {
    if (root !== null) {
      if (!res[depth]) {
        res[depth] = [];
      }
      traversal(root.left, depth + 1);
      res[depth].push(root.val);
      traversal(root.right, depth + 1);
    }
  }
  traversal(root, 0);
  return res;
};
```

## 动态规划

给你一道算法题，盛水最多的容器
编辑距离
买卖股票的最佳时机
买卖股票的最佳时机 II
买卖股票的最佳时机 III
剑指 Offer 19. 正则表达式匹配

### 爬楼梯(经典 DP）

```js
// 时间复杂度 O(n) 空间复杂度 O(1)
function fib(n) {
  if (n < 3) return 1;
  let f = 0,
    s = 1;
  while (--n) {
    // s += f; // f + s
    // f = s - f; // 旧 s 值
    [f, s] = [s, f + s];
  }
  return s;
}
```

## 回溯

剑指 Offer 38. 字符串的排列

## 找到所有出现两次的元素

不用到任何额外空间并在 O(n)时间复杂度: 原地哈希

```js
var findDuplicates = function(nums) {
  const res = [];

  for (const num of nums) {
    const absNum = Math.abs(num);
    if (nums[absNum - 1] < 0) {
      res.push(absNum);
    } else {
      nums[absNum - 1] *= -1;
    }
  }

  return res;
};
```

## 老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。 目标是尽量让更多的孩子满意。 如孩子的要求是 1, 3, 5, 4, 2，饼干是 1, 1， 最多能让 1 个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是 7, 6, 5，最多能 让 2 个孩子满足。

贪心算法

```js
function splitCake(childrenIssue, cake) {
  var sortChildrenIssue = childrenIssue.sort((item1, item2) => item1 - item2);
  var sortCake = cake.sort((item1, item2) => item1 - item2);
  var result = [];
  for (var i = 0, j = 0; i < sortChildrenIssue.length && j < sortCake.length; j++) {
    if (sortChildrenIssue[i] <= sortCake[j]) {
      result.push(sortChildrenIssue[i]);
      i++;
    }
  }
  return result;
}
```

## 给定一个正整数数列 a, 对于其每个区间, 我们都可以计算一个 X 值; X 值的定义如下: 对于任意区间, 其 X 值等于区间内最小的那个数乘上区间内所有数和; 现在需要你找出数列 a 的所有区间中, X 值最大的那个区间; 如数列 a 为: 3 1 6 4 5 2; 则 X 值最大的区间为 6, 4, 5, X = 4 \* (6+4+5) = 60;

```js
function getMaxX(array) {
  let n = array.length;
  if (n === 0) return 0;
  let min = [array[0]];
  let dp = [array[0] * array[0]];
  let max = dp[0];
  for (let i = 1; i < n; i++) {
    let val = array[i];
    let preMin = min[i - 1];
    min[i] = Math.min(preMin, val);
    let one = (dp[i - 1] * min[i]) / preMin + val * min[i];
    let two = val * val;
    if (one > two) {
      dp[i] = one;
    } else {
      dp[i] = two;
      min[i] = val;
    }
    max = Math.max(max, dp[i]);
  }
  return max;
}
console.log(getMaxX([3, 1, 6, 4, 5, 2])); // 60
```

## 编写一个树的深度优先遍历函数（节点最深的最先访问到，依次类推），满足以下测试用例

```js
// 假设树的结构如下：
const tree = [
  {
    id: 1,
    name: '张三',
    children: [
      {
        id: 2,
        name: '李四',
        children: [
          {
            id: 5,
            name: '张五',
          },
        ],
      },
    ],
  },
  {
    id: 6,
    name: '玛丽',
  },
];

//测试用例：
//1. 生成一棵新树，姜将所有节点的id,加1
console.log(
  treeMap(tree, node => {
    let newNode = { ...node };
    newNode.id = node.id + 1;
    return newNode;
  }),
);
//打印的新树，应该与tree的结构一致，只是每个id自增1，老的tree，应该没有任何改动
//2.打印每个节点的id
treeMap(tree, node => {
  console.log(node.id);
  return node;
});
//应打印顺序应该是：5,2,1,6
//3. 对于非法输入，应直接返回第一个入参
console.log(treeMap(null)); //输出null
console.log(treeMap(tree, true /*不是函数*/)); //输出tree
```

## 实现一个 getIntersection 函数，可获取多个区间的交集

```js
function intersection(left, right) {
  let seen = left.reduce((seen, item) => {
    seen[item] = true;
    return seen;
  }, {});

  return right.reduce((result, current) => {
    if (current in seen) {
      return result.concat(current);
    }
    seen[current] = true;
    return result;
  }, []);
}
```
