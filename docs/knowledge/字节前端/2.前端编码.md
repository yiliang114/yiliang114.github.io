---
title: 前端编码
date: 2020-12-16
draft: true
---

# 手写前端

1. 实现一个判断变量类型的函数
2. 二进制相加，给两字符串求值
3. 对输入的字符串：去除其中的字符'b'；去除相邻的'a'和'c'。 'aabcd' -> 'ad' 'aaabbccc' -> '' 不允许使用类似 string.replace 函数。要求时间、空间复杂度尽量优化
4. js 中处理大数。如果后端传给前端一个很大的数，前端会怎么样，该怎么处理？
5. 找出两个有序数组中的重复项，分析时间和空间复杂度
6. 实现 toFix 函数
7. fetch 兼容超时重传
8. atoi 把任意进制的数转为十进制的数。 需要考虑负数。
9. 实现一个 promiseify 方法，将 callback 风格调用转成 promise 调用方式
10. 工厂生产了十批原件，其中有一批是次品。正常的原件每个重量都是 100 克，次品的是 99 克。现在给你一个秤，要求只称一次，怎么确定哪批原件是次品。
11. 版本号比较排序
12. 实现一个构造函数，new 的时候每次加 1

## 防抖、节流

```js
function debounce(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

```js
function throttle(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        fn.apply(this, args);
      }, delay);
    }
  };
}
```

## 拷贝函数

### 浅拷贝

- `Object.assign`
- 展开运算符 `...`
- for 循环方式， 手动复制属性

### 深拷贝

#### 1. JSON.parse JSON.stringify

简单的做法：`JSON.parse(JSON.stringify(obj))`， 但是该方法也是有局限性的：

- 会忽略`undefined`
- 会忽略`symbol`
- 会忽略函数
- 不能解决循环引用的对象 （会报错）

#### 2. MessageChannel

如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 `MessageChannel`。 这种方法有局限性，当属性值是函数的时候，会报错。

```js
function structuralClone(obj) {
  return new Promise(resolve => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = ev => resolve(ev.data);
    port1.postMessage(obj);
  });
}

var obj = {
  a: 1,
  b: {
    c: 2,
  },
};

obj.b.d = obj.b;

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () => {
  const clone = await structuralClone(obj);
  console.log(clone);
};
test();
```

#### 3. for 循环深拷贝

```js
// 判断属性值类型是原始类型和引用类型
function isObj(obj) {
  return typeof obj === 'object' && obj !== null;
}

function deepClone(obj, map = new WeakMap()) {
  // 解决环的情况
  if (map.has(obj)) return map.get(obj);
  // 数组 or 对象
  let cloneObj = Array.isArray(obj) ? [] : {};
  map.set(obj, cloneObj);
  // for-in 会遍历原型链上的属性
  for (let key in obj) {
    // 需要判断是否是原型链上的属性，不是原型链才拷贝
    if (obj.hasOwnProperty(key)) {
      // 原始类型直接赋值（注意 null）
      cloneObj[key] = isObj(obj[key]) ? deepClone(obj[key], map) : obj[key];
    }
  }
  return cloneObj;
}
```

## 手写 call、apply 及 bind 函数

```js
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  context = context || window;
  // 通过将函数挂载到 context 对象上来使得 this 改变
  context.fn = this;
  const args = [...arguments].slice(1);
  const result = context.fn(...args);
  delete context.fn;
  return result;
};
```

```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  context = context || window;
  context.fn = this;
  let result;
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

bind 实现

`bind` 的实现对比其他两个函数略微地复杂了一点，因为 `bind` 需要返回一个函数，需要判断一些边界问题，以下是 `bind` 的实现

```js
Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  const that = this;
  const args = [...arguments].slice(1);
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new that(...args, ...arguments);
    }
    return that.apply(context, args.concat(...arguments));
  };
};
```

以下是对实现的分析：

- 前几步和之前的实现差不多，就不赘述了
- `bind` 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 `new` 的方式，我们先来说直接调用的方式
- 对于直接调用来说，这里选择了 `apply` 的方式实现，但是对于参数需要注意以下情况：因为 `bind` 可以实现类似这样的代码 `f.bind(obj, 1)(2)`，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 `args.concat(...arguments)`
- 最后来说通过 `new` 的方式，在之前的章节中我们学习过如何判断 `this`，对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况我们需要忽略传入的 `this`

```js
Function.prototype.bind = function(oThis) {
  if (typeof this !== 'function') {
    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
      // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
      // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
      return fToBind.apply(
        this instanceof fNOP && oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments)),
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
```

## 实现一个 EventEmitter 类

```js
function EventEmitter() {
  this.callbacksMap = {};
}

EventEmitter.prototype.on = function(type, handler) {
  const callbacks = this.callbacksMap[type];
  if (!callbacks) {
    this.callbacksMap[type] = [handler];
  } else {
    callbacks.push(handler);
  }
  return this;
};

EventEmitter.prototype.off = function(type, handler) {
  const list = this.callbacksMap[type] || [];

  for (let i = list.length; i >= 0; --i) {
    if (!handler || list[i] === handler) {
      list.splice(i, 1);
    }
  }

  return this;
};

EventEmitter.prototype.emit = function(type, data) {
  const list = this.callbacksMap[type];

  if (list) {
    for (let i = 0, len = list.length; i < len; ++i) {
      list[i].call(this, data);
    }
  }
};

EventEmitter.prototype.once = function(type, handler) {
  const self = this;

  function wrapper() {
    handler.apply(self, arguments);
    self.off(type, wrapper);
  }
  this.on(type, wrapper);
  return this;
};

const evt = new EventEmitter();

evt.on('haha', () => {
  console.log('haha1');
});

function haha2() {
  console.log('haha2');
}

evt.on('haha', haha2);

evt.emit('haha');

evt.once('haha', () => {
  console.log('haha3');
});

evt.emit('haha');
evt.emit('haha');

evt.off('haha', haha2);
evt.emit('haha');

evt.off('haha');
evt.emit('haha');
```

## 解析 url

写一段匹配 URL 的正则，包括协议、域名、端口、path、hash、querystring

### 解析一个参数

```js
function getQueryString(name) {
  const reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
  const r = window.location.search.slice(1).match(reg);
  if (r != null) {
    return r[2];
  }
  return null;
}
```

### url 所有参数转化为一个对象

```js
var parseQueryString = function(search) {
  if (!search) return {};
  const regExp = /([^&=]+)=([\w\W]*?)(&|$)/g;
  const ret = {};
  search = search[0] === '?' ? search.slice(1) : search;
  while ((result = regExp.exec(search)) != null) {
    ret[result[1]] = result[2];
  }
  return ret;
};
```

## 手写的 ajax

手写的 ajax 是否兼容 IE ， IE 下面的 ajax 与普通浏览器的 ajax 对象不一样

```js
function ajax(url, cb) {
  let xhr;
  // 创建 XMLHttpRequest 对象
  if (window.XMLHttpRequest) {
    // `XMLHttpRequest`只有在高级浏览器中才支持. 非 IE 内核
    xhr = new XMLHttpRequest();
  } else {
    // IE内核
    xhr = ActiveXObject('Microsoft.XMLHTTP');
  }
  // 绑定 onreadystatechange 事件
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      //  获取异步调用返回的数据
      cb(xhr.responseText);
    }
  };
  // 向服务器发送请求
  xhr.open('GET', url, true);
  xhr.send();
}
```

## 手写 promise

```js
const PENDING = 'pending';
const RESOLVED = 'resolved';
const REJECTED = 'rejected';

function MyPromise(fn) {
  const that = this;
  that.state = PENDING;
  that.value = null;
  that.resolvedCallbacks = [];
  that.rejectedCallbacks = [];

  function resolve(value) {
    if (that.state === PENDING) {
      that.state = RESOLVED;
      that.value = value;
      that.resolvedCallbacks.map(cb => cb(that.value));
    }
  }

  function reject(value) {
    if (that.state === PENDING) {
      that.state = REJECTED;
      that.value = value;
      that.rejectedCallbacks.map(cb => cb(that.value));
    }
  }

  try {
    fn(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

MyPromise.prototype.then = function(onFulfilled, onRejected) {
  return new MyPromise((resolve, reject) => {
    const that = this;
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : r => {
            throw r;
          };
    if (that.state === PENDING) {
      that.resolvedCallbacks.push(onFulfilled);
      that.rejectedCallbacks.push(onRejected);
    }
    if (that.state === RESOLVED) {
      onFulfilled(that.value);
      resolve(that.value);
    }
    if (that.state === REJECTED) {
      onRejected(that.value);
      reject(that.value);
    }
  });
};
```

## 实现 destructuringArray 方法，达到如下效果

```js
// destructuringArray( [1,[2,4],3], "[a,[b],c]" );
// result
// { a:1, b:2, c:3 }
```

实现：

```js
destructuringArray = (value, keys) => {
  let obj = {};
  // "[a,[b],c]".replace(/\w+/g, '"$&"')
  let arr = JSON.parse(keys.replace(/\w+/g, '"$&"'));
  console.log(arr);
  const iterate = (value, keys) => {
    keys.forEach((item, index) => {
      if (Array.isArray(item)) iterate(value[index], item);
      else obj[item] = value[index];
    });
  };
  iterate(value, arr);
  console.log(obj);
  return obj;
};
```

## reduce 实现 map

```js
Array.prototype.map = function(callback) {
  var arr = this;
  return arr.reduce((acc, cur, i) => {
    acc.push(callback(cur, i, arr));
    return acc;
  }, []);
};

var m = [1, 2, 3, 4, 54].map(function(v, i, arr) {
  return v * v;
});
console.log(m);
```

```js
const selfMap2 = function(fn, context) {
  let arr = Array.prototype.slice.call(this);
  // 这种实现方法和循环的实现方法有异曲同工之妙，利用 reduce contact 起数组中每一项
  // 不过这种有个弊端，会跳过稀疏数组中为空的项
  return arr.reduce((pre, cur, index) => {
    return [...pre, fn.call(context, cur, index, this)];
  }, []);
};
```

## sleep 函数

```js
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
async function output() {
  let out = await sleep(1000);
  console.log(1);
  return out;
}
output();
```

```js
async function sleep(time) {
  // 这里是实现
  return new Promise(res => {
    setTimeout(() => {
      res();
    }, time);
  });
}
console.log(1);
await sleep(3000);
console.log(2);
```

## 实现 Promise.all(list, limit)

1. js 实现带并发限制的调度器，其实就是使用 promise 限制并发
2. 实现一个可以控制请求并发数的最高效的发送请求功能。
3. 手动控制并发请求 fetchWithLimit。 手动控制并发请求 fetchWithLimit 尽量快的实现

控制一下子发出的请求个数。异步请求控制并发 LimitPromise

```js
function PromiseLimit(funcArray, limit = 5) {
  let i = 0;
  // promise 存储
  const result = [];
  // 执行存储
  const executing = [];
  const queue = function() {
    // 边界处理, funcArray 为空数组
    if (i === funcArray.length) return Promise.all(executing);
    // 一个 promise
    const p = funcArray[i++]();
    // 最终返回的 promise 队列
    result.push(p);
    // 在 p 执行结束之后，将 e 从 executing 数组中取出
    const e = p.then(() => executing.splice(executing.indexOf(e), 1));
    // 执行中的 promise 队列
    executing.push(e);
    // 如果个数到了 limit， 先 race 等待执行结束，再执行 queue 添加一个 promise
    if (executing.length >= limit) {
      return Promise.race(executing).then(
        () => queue(),
        e => Promise.reject(e),
      );
    }
    // 如果个数还没到，则直接执行 queue() 函数添加 promise
    return Promise.resolve().then(() => queue());
  };
  return queue().then(() => Promise.all(result));
}
```

## 实现 Promise.retry(promiseFn, times)

可以设置时间间隔和次数。

```js
Promise.retry = function(promiseFn, times = 3) {
  return new Promise(async (resolve, reject) => {
    while (times--) {
      try {
        var ret = await promiseFn();
        resolve(ret);
        break;
      } catch (error) {
        if (!times) reject(error);
      }
    }
  });
};

function getProm() {
  const n = Math.random();
  return new Promise((resolve, reject) => {
    setTimeout(() => (n > 0.9 ? resolve(n) : reject(n)), 1000);
  });
}

Promise.retry(getProm);
```

## 数组去重（对象、非对象）

```js
// set 去重
[...new Set(arr)];

// 利用 indexOf 去重
const newArr = arr.filter((item, index, arr) => index === arr.indexOf(item));

// 利用对象去重
let objA = {};
const newArrA = arr.filter((item, index, arr) => (objA.hasOwnProperty(item) ? false : (objA[item] = true)));

// 双重循环去重
```

### 数组对象去重

```js
function removeDuplication(arr = [], key = '') {
  if (!key) return Array.from(new Set(arr));
  const map = {};
  return arr.reduce((result, next) => {
    map[next[key]] ? '' : (map[next[key]] = true && result.push(next));
    return result;
  }, []);
}
```

## 实现 flatten 扁平化函数

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
  return a - b;
});
```

**竟然原生就有这个 flat 函数，用来拍平数组**
flat 函数的参数是层级。Infinity 无限大。 会拍平数组中的所有数组值。

```js
function flatten(arr) {
  let temp = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      temp.push(...flatten(item));
    } else {
      temp.push(item);
    }
  });
  return temp;
}
```

递归实现

```js
function flatten(arr, result = []) {
  arr.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
}
```

使用 es6 的 reduce 函数

```js
const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
```

### 有层级的数组扁平化

```js
function flatten(arr, deep) {
  if (!deep) return arr;
  let temp = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      temp.push(...flatten(item, --deep));
    } else {
      temp.push(item);
    }
  });
  return temp;
}
```

## 实现一下 curry（柯里化）

```js
function curry(fn, arr = []) {
  return fn.length === arr.length
    ? fn.apply(null, arr)
    : function(...args) {
        return curry(fn, arr.concat(args));
      };
}

const curry = (fn, arr = []) => (fn.length === arr.length ? fn(...arr) : (...args) => curry(fn, [...arr, ...args]));
```

实现加法函数使得 sum(2)(3)和 sum(2,3)都输出 5

## 千分位

```js
function test1(num) {
  var str = +num + '';
  var len = str.length;
  if (len <= 3) return str;
  num = '';
  while (len > 3) {
    len -= 3;
    num = ',' + str.substr(len, 3) + num;
  }
  return str.substr(0, len) + num;
}

function test2(num) {
  // ?= 正向匹配:匹配位置
  // ?! 正向不匹配:排除位置
  var str = (+num).toString();
  var reg = /(?=(?!\b)(\d{3})+$)/g;
  return str.replace(reg, ',');
}
```

### 千分位

如 12000000.11 转化为 12,000,000.11

```js
function commafy(num) {
  const val = Math.abs(num);
  const isPositive = num === val;
  const result =
    val &&
    val.toString().replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2) {
      return $2 + ',';
    });
  // return isPositive ? result : `-${result}`;
  return result;
}
```

### 实现千分位标注位

考虑小数、负数和整数三种情况。

`sep`参数是自定义的分隔符，默认是`,`

```js
/**
 * 实现千分位标注位
 * @param {*} str 待标注的字符串
 * @param {*} sep 标注符号
 */
const addSeparator = (str = '', sep = ',') => {
  str += '';
  const arr = str.split('.'),
    re = /(\d+)(\d{3})/;

  let integer = arr[0],
    decimal = arr.length <= 1 ? '' : `.${arr[1]}`;

  while (re.test(integer)) {
    integer = integer.replace(re, '$1' + sep + '$2');
  }

  return integer + decimal;
};

console.log(addSeparator(-10000.23)); // -10,000.23
console.log(addSeparator(100)); // 100
console.log(addSeparator(1234, ';')); // 1;234
```

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

### 格式化金钱，每千分位加逗号

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

## a~z 有 26 个字母，按照 1~26 编码，现在给定一个数字字符串，输出所有可能的解码结果，如：输入 1234，输出 ['axd', 'abcd', 'lcd']

leetcode 原题

## 顺序发送 4 个请求 a，b，c，d，要求按照顺序输出

顺序发送 4 个请求 a，b，c，d，要求按照顺序输出，即如果先返回 b，则不输出，再返回 a，输出 a，b

```js
function getData(urls) {
  return new Promise((resolve, reject) => {
    const res = [],
      len = urls.length;
    urls.forEach((url, i) => {
      fetch('http://localhost:8080' + url)
        .then(data => data.json())
        .then(data => {
          res[i] = { data, printed: false }; // 将数据放入缓存数组
          let flag = true;
          for (let j = 0; j < len && flag; j += 1) {
            if (res[j]) {
              // 如果标志为 j 的有返回值，则继续
              if (!res[j].printed) {
                console.log(res[j].data);
                res[j].printed = true;
                j === len - 1 && resolve(res.map(o => o.data));
              }
            } else {
              // 无返回值，则跳出
              flag = false;
            }
          }
        }, reject);
    });
  });
}

const listPromise = getData(['/data.json', '/data2.json', '/data3.json', '/data4.json']);
listPromise.then(res => console.log(res));
```

## 用 promise 实现一个请求超时功能

```js
function promiseWithTimeout(url, timeout = 3000) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(data => data.json())
      .then(data => resolve(data)); // fetch 先得到结果就 resolve
    setTimeout(() => reject(Error('time is out!')), timeout); // 时间到了还没 fetch 到就 reject
  });
}

promiseWithTimeout('http://localhost:8080/data.json')
  .then(data => console.log(data))
  .catch(err => console.error(err));

// server.js 测试
const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors({ origin: '*' }));

app.use('/data.json', (req, res) => {
  setTimeout(() => res.end(JSON.stringify({ a: 1 })), Math.floor(Math.random() * 6 * 1000));
});

app.listen(8080, () => console.log('the app is running at http://localhost:8080'));
```

## JS 实现一个带并发限制的异步调度器 Scheduler

完善代码中 Scheduler 类，使得以下程序能正确输出。

```js
// JS实现一个带并发限制的异步调度器Scheduler，
// 保证同时运行的任务最多有两个。
// 完善代码中Scheduler类，
// 使得以下程序能正确输出

class Scheduler {
  constructor() {
    this.count = 2;
    this.queue = [];
    this.run = [];
  }

  add(task) {
    // ...
  }
}

const timeout = time =>
  new Promise(resolve => {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler();
const addTask = (time, order) => {
  scheduler.add(() => timeout(time)).then(() => console.log(order));
};

addTask(1000, '1');
addTask(500, '2');
addTask(300, '3');
addTask(400, '4');
// output: 2 3 1 4

// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进队
// 800ms时，3完成，输出3，任务4进队
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4
```

别人的解答：

```js
class Scheduler {
  constructor(count) {
    this.count = 2;
    this.queue = [];
    this.run = [];
  }

  add(task) {
    this.queue.push(task);
    return this.schedule();
  }

  schedule() {
    if (this.run.length < this.count && this.queue.length) {
      const task = this.queue.shift();
      const promise = task().then(() => {
        this.run.splice(this.run.indexOf(promise), 1);
      });
      this.run.push(promise);
      return promise;
    } else {
      return Promise.race(this.run).then(() => this.schedule());
    }
  }
}
```

## 实现一个并发限制功能。

```js
function asyncPool(poolLimit, array, iteratorFn) {
  let i = 0;
  const ret = [];
  const executing = [];
  const enqueue = function() {
    if (i === array.length) {
      return Promise.resolve();
    }
    const item = array[i++];
    const p = Promise.resolve().then(() => iteratorFn(item, array));
    ret.push(p);
    const e = p.then(() => executing.splice(executing.indexOf(e), 1));
    executing.push(e);
    let r = Promise.resolve();
    if (executing.length >= poolLimit) {
      r = Promise.race(executing);
    }
    return r.then(() => enqueue());
  };
  return enqueue().then(() => Promise.all(ret));
}
```

## 写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串

## 大数相加

1000000000 + 1000000000 允许返回字符串。处理大数。大数问题其实就是通过字符串来处理，从后往前加，然后处理进位的问题。

```js
function add(a, b) {
  //取两个数字的最大长度
  let maxLength = Math.max(a.length, b.length);
  //用 0 去补齐长度
  a = a.padStart(maxLength, 0); //"0009007199254740991"
  b = b.padStart(maxLength, 0); //"1234567899999999999"
  // 定义加法过程中需要用到的变量
  let t = 0;
  let f = 0; // 进位
  let sum = '';
  for (let i = maxLength - 1; i >= 0; i--) {
    t = parseInt(a[i]) + parseInt(b[i]) + f;
    // Math.floor 向下取整。 Math.ceil 向上取整。
    f = Math.floor(t / 10);
    sum = (t % 10) + sum;
  }
  if (f == 1) {
    sum = '1' + sum;
  }
  return sum;
}
```

## 加法函数

写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3

```js
function accAdd(arg1, arg2) {
  var r1, r2, m;
  try {
    r1 = arg1.toString().split('.')[1].length;
  } catch (e) {
    r1 = 0;
  }
  try {
    r2 = arg2.toString().split('.')[1].length;
  } catch (e) {
    r2 = 0;
  }
  // 计算出一个倍数。看小数点后面的值的长度
  m = Math.pow(10, Math.max(r1, r2));
  // 先乘这个倍数，再除以这个倍数
  return (arg1 * m + arg2 * m) / m;
}
var result = accAdd(0.1, 0.2);
console.log(result); // 0.3
```

自定义处理函数，放大指定的位数，最后再缩小。

```js
// f代表需要计算的表达式，digit代表小数位数
Math.formatFloat = function(f, digit) {
  // Math.pow(指数，幂指数)
  var m = Math.pow(10, digit);
  // Math.round（） 四舍五入
  return Math.round(f * m, 10) / m;
};
console.log(Math.formatFloat(0.3 * 8, 1)); // 2.4
console.log(Math.formatFloat(0.35 * 8, 2)); // 2.8
```

### js 浮点数运算不精确 如何解决?

## 原生 js 实现 MVVM

```js
<span id="box">
  <h1 id="text"></h1>
  <input type="text" id="input" oninput="inputChange(event)" />
  <button id="button" onclick="clickChange()">
    Click me
  </button>
</span>
```

```js
const input = document.getElementById('input');
const text = document.getElementById('text');
const button = document.getElementById('button');
const data = {
  value: '',
};
function defineProperty(obj, attr) {
  let val;
  Object.defineProperty(obj, attr, {
    set(newValue) {
      console.log('set');
      if (val === newValue) {
        return;
      }
      val = newValue;
      input.value = newValue;
      text.innerHTML = newValue;
    },
    get() {
      console.log('get');
      return val;
    },
  });
}
defineProperty(data, 'value');
function inputChange(event) {
  data.value = event.target.value;
}

function clickChange() {
  data.value = 'hello';
}
```

## 手写 JSONP

jsonp 原理：因为 jsonp 发送的并不是 ajax 请求，其实是动态创建 script 标签
script 标签是没有同源限制的，把 script 标签的 src 指向请求的服务端地址。

```js
function jsonp(url, data = {}, callback = 'callback') {
  //处理json对象，拼接url
  data.callback = callback;
  let params = [];
  for (let key in data) {
    params.push(key + '=' + data[key]);
  }
  let script = document.createElement('script');
  script.src = url + '?' + params.join('&');
  document.body.appendChild(script);

  //返回Promise
  return new Promise((resolve, reject) => {
    window[callback] = data => {
      try {
        resolve(data);
      } catch (e) {
        reject(e);
      } finally {
        //移除 script 元素
        script.parentNode.removeChild(script);
        console.log(script);
      }
    };
  });
}

//请求数据
jsonp(
  'http://photo.sina.cn/aj/index',
  {
    page: 1,
    cate: 'recommend',
  },
  'jsonCallback',
).then(data => {
  console.log(data);
});
```

### Jsonp 方案需要服务端怎么配合 ?

## 用两个栈实现队列

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

### 思路

一个栈用来存储插入队列数据，一个栈用来从队列中取出数据。从第一个栈向第二个栈转移数据的过程中：数据的性质已经从后入先出变成了先入先出。

```js
var CQueue = function() {
  this.outStack = [];
  this.inStack = [];
};

/**
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
  if (value) {
    // 新插入队列的数据都放在 inStack
    this.inStack.push(value);
  }
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
  const { outStack, inStack } = this;
  //  如果 outStack 为空，那么将 inStack 中的元素都转移过来
  if (!outStack.length) {
    while (inStack.length) {
      outStack.push(inStack.pop());
    }
  }
  return !outStack.length ? -1 : outStack.pop();
};
```

## js 实现一个拖拽？

首先是三个事件，分别是 mousedown，mousemove，mouseup
当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。

clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：
鼠标移动时候的坐标-鼠标按下去时候的坐标。

也就是说定位信息为：

鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.

还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left
以及 top 等等值。
div:

```html
<div class="drag" style="left:0;top:0;width:100px;height:100px">按住拖动</div>

<style>
  .drag {
    background-color: skyblue;
    position: absolute;
    line-height: 100px;
    text-align: center;
  }
</style>
```

js:

```js
// 获取DOM元素
let dragDiv = document.getElementsByClassName('drag')[0];
// 鼠标按下事件 处理程序
let putDown = function(event) {
  dragDiv.style.cursor = 'pointer';
  let offsetX = parseInt(dragDiv.style.left); // 获取当前的x轴距离
  let offsetY = parseInt(dragDiv.style.top); // 获取当前的y轴距离
  let innerX = event.clientX - offsetX; // 获取鼠标在方块内的x轴距
  let innerY = event.clientY - offsetY; // 获取鼠标在方块内的y轴距
  // 按住鼠标时为div添加一个border
  dragDiv.style.borderStyle = 'solid';
  dragDiv.style.borderColor = 'red';
  dragDiv.style.borderWidth = '3px';
  // 鼠标移动的时候不停的修改div的left和top值
  document.onmousemove = function(event) {
    dragDiv.style.left = event.clientX - innerX + 'px';
    dragDiv.style.top = event.clientY - innerY + 'px';
    // 边界判断
    if (parseInt(dragDiv.style.left) <= 0) {
      dragDiv.style.left = '0px';
    }
    if (parseInt(dragDiv.style.top) <= 0) {
      dragDiv.style.top = '0px';
    }
    if (parseInt(dragDiv.style.left) >= window.innerWidth - parseInt(dragDiv.style.width)) {
      dragDiv.style.left = window.innerWidth - parseInt(dragDiv.style.width) + 'px';
    }
    if (parseInt(dragDiv.style.top) >= window.innerHeight - parseInt(dragDiv.style.height)) {
      dragDiv.style.top = window.innerHeight - parseInt(dragDiv.style.height) + 'px';
    }
  };
  // 鼠标抬起时，清除绑定在文档上的mousemove和mouseup事件
  // 否则鼠标抬起后还可以继续拖拽方块
  document.onmouseup = function() {
    document.onmousemove = null;
    document.onmouseup = null;
    // 清除border
    dragDiv.style.borderStyle = '';
    dragDiv.style.borderColor = '';
    dragDiv.style.borderWidth = '';
  };
};
// 绑定鼠标按下事件
dragDiv.addEventListener('mousedown', putDown, false);
```

## 需要通过 threshold 参数控制调用函数频率

```js
const yourFunction = function(func, threshold) {
  // 请实现
};
const triggerSearch = yourFunction(val => {
  const { onSearch } = this.props;
  onSearch(val);
}, 300);
triggerSearch(searchText);
```

实现

```js
const yourFunction = function(func, threshold) {
  let timeOut;
  return function() {
    if (!timeOut) {
      timeOut = setTimeout(() => {
        timeOut = null;
        func.apply(this, arguments);
      }, threshold);
    }
  };
};

const triggerSearch = yourFunction(val => {
  const { onSearch } = this.props;
  onSearch(val);
}, 300);
```

## 事件触发器

兼容所有浏览器

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return element.dispatchEvent(mockEvent);
  }
};
```

## 代码中 a 在什么情况下会打印 1？

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

考察隐式转换,重写 toString 方法即可

```js
var a = {
  i: 1,
  toString() {
    return a.i++;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```

```js
let a = {
  i: 1,
  valueOf() {
    return a.i++;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

```js
var a = [1, 2, 3];
a.join = a.shift;
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

```js
let a = { [Symbol.toPrimitive]: (i => () => ++i)(0) };
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

## 实现 (5).add(3).minus(2) 功能

```js
Number.prototype.add = function(value) {
  let number = parseFloat(value);
  if (typeof number !== 'number' || Number.isNaN(number)) {
    throw new Error('请输入数字或者数字字符串～');
  }
  return this + number;
};
Number.prototype.minus = function(value) {
  let number = parseFloat(value);
  if (typeof number !== 'number' || Number.isNaN(number)) {
    throw new Error('请输入数字或者数字字符串～');
  }
  return this - number;
};
console.log((5).add(3).minus(2));
```

## 要求设计 LazyMan 类，实现以下功能

```js
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony')
  .sleep(10)
  .eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony')
  .eat('lunch')
  .sleep(10)
  .eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony')
  .eat('lunch')
  .eat('dinner')
  .sleepFirst(5)
  .sleep(10)
  .eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

答案：

```js
class LazyManClass {
  constructor(name) {
    this.taskList = [];
    this.name = name;
    console.log(`Hi I am ${this.name}`);
    setTimeout(() => {
      this.next();
    }, 0);
  }
  eat(name) {
    var that = this;
    var fn = (function(n) {
      return function() {
        console.log(`I am eating ${n}`);
        that.next();
      };
    })(name);
    this.taskList.push(fn);
    return this;
  }
  sleepFirst(time) {
    var that = this;
    var fn = (function(t) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${t}秒...`);
          that.next();
        }, t * 1000);
      };
    })(time);
    this.taskList.unshift(fn);
    return this;
  }
  sleep(time) {
    var that = this;
    var fn = (function(t) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${t}秒...`);
          that.next();
        }, t * 1000);
      };
    })(time);
    this.taskList.push(fn);
    return this;
  }
  next() {
    var fn = this.taskList.shift();
    fn && fn();
  }
}
function LazyMan(name) {
  return new LazyManClass(name);
}
LazyMan('Tony')
  .eat('lunch')
  .eat('dinner')
  .sleepFirst(5)
  .sleep(4)
  .eat('junk food');
```

## 实现一个持续的动画效果

js 定时器实现

```js
var e = document.getElementById('e');
var flag = true;
var left = 0;
setInterval(() => {
  left == 0 ? (flag = true) : left == 100 ? (flag = false) : '';
  flag ? (e.style.left = ` ${left++}px`) : (e.style.left = ` ${left--}px`);
}, 1000 / 60);
```

js API requestAnimationFrame 实现

```js
//兼容性处理
window.requestAnimFrame = (function() {
  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
    }
  );
})();

var e = document.getElementById('e');
var flag = true;
var left = 0;

function render() {
  left == 0 ? (flag = true) : left == 100 ? (flag = false) : '';
  flag ? (e.style.left = ` ${left++}px`) : (e.style.left = ` ${left--}px`);
}

(function animloop() {
  render();
  requestAnimFrame(animloop);
})();
```

优势：

浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果
解决毫秒的不精确性
避免过度渲染（渲染频率太高、tab 不可见暂停等等）
注：requestAnimFrame 和 定时器一样也头一个类似的清除方法 cancelAnimationFrame

css 实现：

```css
.test {
  animation: mymove 5s infinite;
  @keyframes mymove {
    from {
      top: 0px;
    }
    to {
      top: 200px;
    }
  }
}
```

## 实现函数字符串转对象

```
'a.b.c'
=>
a: {
    b: {
        c: null
    }
}
```

## 输入字符串输出二维数组

```
`
12312

1  3
12 3
`
=>
[
    ['12312'],
    ['13'],
    ['123']
]
```

```js
function handler(str = '') {
  return str
    .split('\n')
    .filter(Boolean)
    .map(val => val.replace(/\s/g, ''));
}
```

## 十六进制转十进制

```js
// 10进制转16进制
function handler(params) {
  typeof params == 'string' ? (params = Number(params)) : '';
  console.log(params.toString(16)); //a8
}
handler('168');

// 16进制转10进制
function handler2(params) {
  console.log(Number('0x' + params)); //168
}
handler2('a8');

// 16进制转10进制
function handler3(params) {
  console.log(parseInt(params, 16)); //168
}
handler3('a8');
```

## 实现 36 进制转换

```js
function getNums36() {
  var nums36 = [];
  for (var i = 0; i < 36; i++) {
    if (i >= 0 && i <= 9) {
      nums36.push(i);
    } else {
      nums36.push(String.fromCharCode(i + 87));
    }
  }
  return nums36;
}

//十进制数转成36进制
function scale36(n) {
  var arr = [];
  var nums36 = getNums36();
  while (n) {
    var res = n % 36;
    //作为下标，对应的36进制数，转换成
    arr.unshift(nums36[res]);
    //去掉个位
    n = parseInt(n / 36);
  }
  return arr.join('');
}
```

# 算法

## 排序

### 冒泡排序(稳定)

原地排序、稳定排序。每次两两比较，大的放到后面。每一次遍历都会将最后一位“就位”。

- 最好 O(n)
- 最坏 O(n^2)
- 平均 O(n^2)

```js
function sort(arr = []) {
  const len = arr.length;
  // 外层，需要遍历的次数
  for (let i = 0; i < len - 1; i++) {
    // 内层，每次比较
    for (let j = i + 1; j < len; j++) {
      if (arr[i] > arr[j]) {
        // 大的放到后面
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  }
  return arr;
}
```

### 选择排序(不稳定)

选择排序，从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。

原地排序；不稳定排序

复杂度：

- 最好 O(n^2)
- 最坏 O(n^2)
- 平均 O(n^2)

```js
function sort(arr) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    let min = i;
    // 找到第 n 个最小值。 在 arr[i + 1, arr.length - 1] 中找最小值索引， i+1 代表有序的下一个数，我们默认第一个元素是最小的
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) min = j;
    }
    // 每次循环， a[i] 位都将是未选择出的数据中的最小值
    if (min !== i) {
      [arr[i], arr[min]] = [arr[min], arr[i]];
    }
  }
  return arr;
}
```

### 快速排序(不稳定)

时间复杂度 O(nlogn)

```js
function swap(a, i, j) {
  let temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}

function quickSort(arr, start = 0, end = arr.length - 1) {
  if (arr && arr.length < 2) return arr;
  if (start >= end) return;

  let target = arr[start],
    i = start,
    j = end;

  while (i < j) {
    while (target <= a[j] && i < j) j--;
    while (target >= a[i] && i < j) i++;

    if (i < j) swap(arr, i, j);
  }

  // i === j
  swap(arr, start, i);
  quickSort(arr, start, i - 1);
  quickSort(arr, i + 1, end);

  return arr;
}
```

## 二分查找

在计算 mid 时不能使用 `mid = (i + j) / 2` 这种方式，因为 `i + j` 可能会导致加法溢出，应该使用 `mid = i + (i - j) / 2`

非递归版本：

```js
const binarySearch = (arr, target) => {
  let i = 0,
    j = arr.length - 1;
  while (i <= j) {
    let mid = i + ((j - i) >> 1);
    if (target === arr[mid]) return mid;
    if (target < arr[mid]) {
      j = mid - 1;
    } else {
      i = mid + 1;
    }
  }
  return -1;
};
```

递归版本：

```js
const binarySearch = (a, left, right, key) => {
  const mid = (left + right) >> 1;
  if (a[mid] === key) return mid;
  if (a[mid] > key) return binarySearch(a, left, mid - 1, key);
  if (a[mid] < key) return binarySearch(a, mid + 1, right, key);
};
```

## 斐波那契

时间复杂度（O(2^N)）

```js
var fib = function(n) {
  if (n < 2) return n;
  let i = 0,
    j = 1;
  // 0 1 已经存在了。。。
  while (n > 1) {
    [i, j] = [j, (i + j) % 1000000007];
    n--;
  }
  return j;
};
```

## 查询

给你 1 亿个数字，找出最大的前 1K 个，如何优化效率比较高

分治+Trie 树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照 Hash 方法分解成多个小数据集，然后使用 Trie 树活着 Hash 统计每个小数据集中的 query 词频，之后用小顶堆求出每个数据集中出现频率最高的前 K 个数，最后在所有 top K 中求出最终的 top K。

1. 分治法，将 1 亿个数据分成 100 份，每份 100 万个数据，找到每份数据中最大的 10000 个，最后在剩下的 100*10000 个数据里面找出最大的 10000 个。如果 100 万数据选择足够理想，那么可以过滤掉 1 亿数据里面 99%的数据。100 万个数据里面查找最大的 10000 个数据的方法如下：用快速排序的方法，将数据分为 2 堆，如果大的那堆个数 N 大于 10000 个，继续对大堆快速排序一次分成 2 堆，如果大的那堆个数 N 大于 10000 个，继续对大堆快速排序一次分成 2 堆，如果大堆个数 N 小于 10000 个，就在小的那堆里面快速排序一次，找第 10000-n 大的数字；递归以上过程，就可以找到第 1w 大的数。参考上面的找出第 1w 大数字，就可以类似的方法找到前 10000 大数字了。此种方法需要每次的内存空间为 10^6*4=4MB，一共需要 101 次这样的比较。

2. Hash 法。如果这 1 亿个书里面有很多重复的数，先通过 Hash 法，把这 1 亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的 10000 个数。

3. 采用最小堆。首先读入前 10000 个数来创建大小为 10000 的最小堆，建堆的时间复杂度为 O（mlogm）（m 为数组的大小即为 10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至 1 亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有 10000 个数字。该算法的时间复杂度为 O（nmlogm），空间复杂度是 10000（常数）。

## 字符串/数组

给一数组和一数字，求数组中出现次数大于数组长度除该数字的项？
两个无序数组合并成一个有序数组，问时间复杂度。 延伸：快排和冒泡排序的时间复杂度，使用场景
数组中数字出现的次数 https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/
最长无重复子串
数组乱序: 洗牌算法
实现一个 match 函数 判断 `()()()[] => true` , `{{[(){}[]}}=>true , {{{[]][]}}}[] =>false`
数组顺时针螺旋遍历
搜索旋转排序数组
给定两个无重复升序数组，求合并之后数组。如给定 m={1,2,3},n{2,4,5},则应输出{1,2,3,4,5}
回文字符串，字符串中最长回文子串
大数相加
合并 k 个有序数组
两数之和：找出数组中两个元素的和为 target 的组合
三数之和
字符串中的第一个唯一字符
找出字符串中第一个不重复的字符
在一个无序数组中找到第二大的数
数组中的第 K 个最大元素
数组中第 k 个最大元素
数组中第 K 大元素 （快排，我先说思路然后问了下时间复杂度，然后写
合并乱序区间
给定一个字符串，找出其中无重复字符的最长子字符串长度 ![](https://pic4.zhimg.com/80/v2-d8136dca742eb7560c23d1a39e99e86b_1440w.jpg) ![](https://pic1.zhimg.com/80/v2-291f6f8dcd093229bb7d0a9102c826dc_1440w.jpg)
数组区间
剑指 Offer 39. 数组中出现次数超过一半的数字
剑指 Offer 50. 第一个只出现一次的字符 45° 打印矩阵，回形打印矩阵

## 链表

实现一个函数，将输入的数组转为链表，并实现一个方法向链表指定位置插入值
环形链表
从排好序的两个链表中，找到相同的节点，并输出链表
面试题 02.07. 链表相交

### 反转链表

```js
// 递归
var reverseList = function(head) {
  let reverse = (prev, curr) => {
    if (!curr) {
      return prev;
    }
    let next = curr.next;
    curr.next = prev;
    return reverse(curr, next);
  };
  return reverse(null, head);
};
```

```js
// 迭代
var reverseList = function(head) {
  let prev = null;
  let curr = head;
  while (curr != null) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
};
```

### 合并两个排序的链表

合并 2 个有序单链表成为 1 个新的有序单链表

#### 思路分析

准备一个指针`node`，假设指向两个链表的中节点的指针分别是：`p1`和`p2`。

1. 比较`p1`和`p2`的`value`大小

- 如果，p1.value 小于 p2.value, node.next 指向 p1, p1 向后移动
- 否则，node.next 指向 p2, p2 向后移动

2. 重复第 1 步，直到其中一个链表遍历完
3. 跳出循环，将 node.next 指向未遍历完的链表的剩余部分

整个过程的时间复杂度是 O(N), 空间复杂度是 O(1)

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

```js
function Merge(pHead1, pHead2) {
  let pMergeHead = null;

  if (pHead1 === null) return pHead2;
  if (pHead2 === null) return pHead1;
  if (pHead1.val < pHead2.val) {
    pMergeHead = pHead1;
    pMergeHead.next = Merge(pHead1.next, pHead2);
  } else {
    pMergeHead = pHead2;
    pMergeHead.next = Merge(pHead1, pHead2.next);
  }
  return pMergeHead;
}
```

### 两个链表的第一个公共结点

#### 思路一：栈实现

在第一个公共节点前的节点都是不相同的，因此只要倒序遍历两个链表，找出最后一个出现的相同节点即可。

因为链表不能倒序遍历，所以借助栈实现。

```js
/**
 * 思路一：利用栈实现
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method1(list1, list2) {
  const stack1 = [],
    stack2 = [];

  let node = list1;
  while (node) {
    stack1.push(node);
    node = node.next;
  }

  node = list2;
  while (node) {
    stack2.push(node);
    node = node.next;
  }

  node = null;
  while (stack1.length && stack2.length) {
    let top1 = stack1.pop(),
      top2 = stack2.pop();
    if (top1 === top2) {
      node = top1;
    } else {
      break;
    }
  }

  return node;
}
```

#### 思路二：快慢指针

假设链表 A 长度大于链表 B 长度，它们的长度差为 diff。

让 A 的指针先移动 diff 的位移，然后 A 和 B 的指针再同时向后移动，每次比较节点，选出第一个出现的相同节点。

```js
/**
 * 思路二：快慢指针
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method2(list1, list2) {
  let length1 = 0,
    length2 = 0;

  let node = list1;
  while (node) {
    ++length1;
    node = node.next;
  }

  node = list2;
  while (node) {
    ++length2;
    node = node.next;
  }

  let diff = Math.abs(length1 - length2),
    longList = null,
    shortList = null;
  if (length1 > length2) {
    longList = list1;
    shortList = list2;
  } else {
    longList = list2;
    shortList = list1;
  }

  while (diff > 0) {
    longList = longList.next;
    --diff;
  }

  while (longList && shortList) {
    if (longList === shortList) {
      return longList;
    }
    longList = longList.next;
    shortList = shortList.next;
  }

  return null;
}
```

#### 思路三： 另一种快慢指针

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```js
function findFirstCommonNode(pHead1, pHead2) {
  const len1 = getLinkLength(pHead1),
    len2 = getLinkLength(pHead2);

  let pLong = pHead1,
    pShort = pHead2,
    lenGap = len1 - len2;
  if (len1 < len2) {
    pLong = pHead2;
    pShort = pHead1;
    lenGap = len2 - len1;
  }
  while (lenGap--) {
    pLong = pLong.next;
  }
  while (pLong !== null) {
    // pLong,pShort一起跑
    if (pLong.val === pShort.val) {
      return pLong;
    }
    pLong = pLong.next;
    pShort = pShort.next;
  }
  return null;
}

function getLinkLength(pHead) {
  let length = 0;
  while (pHead !== null) {
    pHead = pHead.next;
    length++;
  }
  return length;
}
```

### 判断链表是否存在环

使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。

```js
/**
 * 哈希表 Set add has 来查询
 * 牺牲了空间换时间
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  // 停止条件： 1. Set 判断出有环 2. 无环，正常结束
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

```js
/**
 * 快慢指针。 如果有环，快指针一定能追上慢指针
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // 快指针一次移动两个
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### 回文链表

请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用  O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

快慢指针，起初都指向表头，快指针一次走两步，慢指针一次走一步，遍历结束时：

要么，slow 正好指向中间两个结点的后一个。
要么，slow 正好指向中间结点。
用 prev 保存 slow 的前一个结点，通过 prev.next = null 断成两个链表。

将后半段链表翻转，和前半段从头比对。空间复杂度降为 O(1)。

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  let fast = head,
    slow = head;
  while (fast != null && fast.next !== null) {
    // 慢指针一次走一步
    slow = slow.next;
    // 快指针一次走两步
    fast = fast.next.next;
  }
  slow = reverseList(slow);
  // slow 一定比 head 要短，所以不用判读较长的链表的情况
  while (slow != null) {
    if (slow.val != head.val) return false;
    slow = slow.next;
    head = head.next;
  }
  return true;
};

var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

## 栈/队列

基本计算器
基本计算器 II
用队列实现栈
剑指 Offer 09. 用两个栈实现队列

## 二叉树

### 二叉树前，中，后遍历

（递归、非递归）

### 二叉树层次遍历

层次遍历二叉树

树的遍历有几种方式，实现下层次遍历

二叉树深度优先遍历(递归、非递归)
二叉树广度优先遍历(递归、非递归)

### 二叉树先序中序 生成后序

### 构造一棵二叉树

### 判断对称二叉树

### 求二叉树深度

### 合并二叉树

### 翻转二叉树

### 打印二叉树

### 和为 n 的二叉树路径

找到二叉树路径和为 n 的路径

给一个二叉树和一个值，问是否有一条路径上的值相加等于该值的，有就返回 true，没有就返回 false
蛇形二叉树
求二叉树每层的最大节点

二叉树中的所有路径
二叉树中和为某一值的路径
给定一个二叉树, 找到该树中两个指定节点间的最短距离

平衡二叉树
路径总和
路径总和 II
剑指 Offer 28. 对称的二叉树
剑指 Offer 32 - I. 从上到下打印二叉树
剑指 Offer 55 - I. 二叉树的深度前中后序知道其二还原二叉树

## 动态规划

给你一道算法题，盛水最多的容器
编辑距离
买卖股票的最佳时机
买卖股票的最佳时机 II
买卖股票的最佳时机 III
剑指 Offer 19. 正则表达式匹配

### 爬楼梯(经典 DP）

```js
// 时间复杂度 O(n) 空间复杂度 O(1)
function fib(n) {
  if (n < 3) return 1;
  let f = 0,
    s = 1;
  while (--n) {
    // s += f; // f + s
    // f = s - f; // 旧 s 值
    [f, s] = [s, f + s];
  }
  return s;
}
```

## 回溯

剑指 Offer 38. 字符串的排列

## 找到所有出现两次的元素。你可以不用到任何额外空间并在 O(n)时间复杂度内解决这个问题吗？

输入:

[4,3,2,7,8,2,3,1]

输出:

[2,3]

这种题，其实看见不用空间、o(n)时间，通常潜台词就是，用原地哈希来做。做过这题的肯定是秒杀，没做过的慌得一逼，我当时就是没做过的。遍历的时候把数字放到 index 下（比如数字 4 放在数组的第 4 个位置），如果发现后面的数的 n,arr[n]已经满足了 arr[n] === n 那就结果算一个。lc 标准答案：和我交换位置不一样，lc 的是让那个数变成负数，如果后面发现 arr[n]是负数那就算一个，比我的交换 index 简单很多。

## 老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。 目标是尽量让更多的孩子满意。 如孩子的要求是 1, 3, 5, 4, 2，饼干是 1, 1， 最多能让 1 个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是 7, 6, 5，最多能 让 2 个孩子满足。

## 给定一个正整数数列 a, 对于其每个区间, 我们都可以计算一个 X 值; X 值的定义如下: 对于任意区间, 其 X 值等于区间内最小的那个数乘上区间内所有数和; 现在需要你找出数列 a 的所有区间中, X 值最大的那个区间; 如数列 a 为: 3 1 6 4 5 2; 则 X 值最大的区间为 6, 4, 5, X = 4 \* (6+4+5) = 60;

## 请使用 JavaScript 编写一个树的深度优先遍历函数（节点最深的最先访问到，依次类推），满足以下测试用例

```js
// 假设树的结构如下：
const tree = [
    {
        id: 1,
        name: '张三',
        children: [
            {
                id: 2,
                name: '李四',
                children: [
                    {
                        id: 5,
                        name: '张五'
                    }
                ]
            }
        ]
    }，
    {
        id: 6,
        name: '玛丽'
    }
]

//测试用例：
//1. 生成一棵新树，姜将所有节点的id,加1
console.log(treeMap(tree, node => {
    let newNode = { ...node }
    newNode.id = node.id + 1
    return newNode
}))
//打印的新树，应该与tree的结构一致，只是每个id自增1，老的tree，应该没有任何改动
//2.打印每个节点的id
treeMap(tree, node => {
    console.log(node.id)
    return node
});
//应打印顺序应该是：5,2,1,6
//3. 对于非法输入，应直接返回第一个入参
console.log(treeMap(null)) //输出null
console.log(treeMap(tree,true/*不是函数*/))  //输出tree
```

## 请使用 JavaScript 实现一个 getIntersection 函数，可获取多个区间的交集，规则如下

```js
function compa(a, b) {
  if (a instanceof Array && b instanceof Array && a.length != 0 && b.length != 0) {
    let a1 = a.sort();
    let b1 = b.sort();
    if (typeof a1[0] == 'number' && typeof a1[1] == 'number' && typeof b1[0] == 'number' && typeof b1[1] == 'number') {
      let arr = [];
      if (b1[0] >= a1[0] && b1[0] <= a1[1]) {
        arr.push(b1[0]);
        if (b1[1] <= a1[1]) {
          arr.push(b1[1]);
        } else {
          arr.push(a1[1]);
        }
        return arr;
      } else {
        if (b1[0] <= a1[0] && b1[1] >= a1[0]) {
          arr.push(a1[0]);
          if (b1[1] >= a1[1]) {
            arr.push(a1[1]);
          } else {
            arr.push(b1[1]);
          }
          return arr;
        } else {
          return null;
        }
      }
    } else {
      return null;
    }
  } else {
    if (a == null && b != null) {
      if (typeof b[0] == 'number' && typeof b[1] == 'number') {
        return b;
      } else {
        return null;
      }
    } else if (a != null && b == null) {
      if (typeof a[0] == 'number' && typeof a[1] == 'number') {
        return a;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
}
function getIntersection(...arg) {
  let a = [];
  for (let i = 0; i < arg.length; i += 2) {
    if (i == 0) {
      a = compa(arg[i], arg[i + 1]);
    } else {
      if (a == null) {
        return null;
      } else {
        a = compa(a, arg[i]);
      }
    }
  }
}

getIntersection([1, 4], [3, 5]); // return [3,4]
getIntersection([5, 2], [4, 9], [3, 6]); //return [4,5]
getIntersection([1, 7], [8, 9]); //return null
getIntersection(['x', 7], [4, 9]); //return null
getIntersection([1, 2]); //return [1,2]
getIntersection([1, 2], [2, 3]); //return [2,2]
```

# 总结

```js
// 使用箭头函数缩减代码
// 处理输入，可以用.map，需要注意其所有参数
// 此外其他迭代方法也需要掌握。
let line = readline().split(' ');
line = line.map(e => parseInt(e, 10));

// 去重
arr = [...new Set(arr)];
// 升序,排序可以用sort，默认是字典序,并且可以根据需要定制，需要深入掌握
arr.sort((a, b) => a - b);
// 迭代输出
arr.forEach(i => console.log(i));
// 求最大值，使用扩展运算符...
max = Math.max.call(...arr);
// 复制数组
arr2 = [...arr1];
arr2 = arr.concat();
arr2 = arr.slice();

// 善用解构
// 变量赋值
const [a, b, c, d, e] = [1, 2, 3, 4, 5]; // a=1,b=2,c=3,d=4,e=5
// 交换变量值
let x = 1,
  y = 2;
[x, y] = [y, x];
// 题外话：字符串中的字符是无法交换的
let str = 'ab';
[str[0], str[1]] = [str[1], str[0]]; // 无效，"ab"
// 不过可以将字符串拆成字符数组后就可以交换了
str = str.split(''); // ["a","b"]
[str[0], str[1]] = [str[1], str[0]]; // ["b","a"]

// 善用位操作符
// 求数组一半长度
halfLen = a.length >> 1;

// 不过需要注意右移运算符>>优先级别加号+还低，例如
console.log(3 + ((5 - 3) >> 1)); // 2
console.log(3 + ~~((5 - 3) / 2)); // 4

// 因此在于其他操作符号想结合时候可以适当增加括号,例如求中位
mid = left + ((right - left) >> 1);
mid = left + ~~((right - left) / 2);
// 不建议使用mid = (left + right)>>1;，因为加号操作可能造成溢出

// ~~等价于Math.floor(),|0 也等价于Math.floor()
halfLen = ~~(a.length / 2);
halfLen = (a.length / 2) | 0;

// 判断奇偶
evenNum & (1 === 0); // 偶数
oddNum & (1 === 1); // 奇数

// 善用异或
5 ^ (5 === 0);
5 ^ 5 ^ 6 ^ 6 ^ (7 === 7);

// 判断数是否是2的幂次方
num & (num - 1 === 0);

// 翻转数的第K位
num ^= 1 << k;

// 将第K位设为0
num &= ~(1 << k);

// 将第K位设为1
num |= 1 << K;

// 判断第K位是否为0
num & (1 << k === 0);
```
