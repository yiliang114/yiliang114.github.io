---
title: vue 3
date: '2020-10-26'
draft: true
---

## 3.0

vue-next 打包后的代码是 ES2015+，不支持 IE 11

Vue.js 3.0 核⼼优势：

- 没有 this，没烦恼；
- 更好的类型推导能⼒（`TypeScript`）；
- 更友好的 `Tree-shaking` ⽀持（渐进式体验）；
- 更⼤的代码压缩空间；
- 更灵活的逻辑复⽤能⼒。

### 为什么不用 class

class 提案被撤回， 并且 class 因为会有副作用不能 tree sharking。类被封装成了一个 IIFE(立即执行函数)，然后返回一个构造函数。Vue 3 的源代码完全没有使用 class 关键字！（只在测试代码和示例代码里用到了 class 关键字）。

### vue 3 源码的阅读顺序

1. 先读 reactivity，能最快了解 Vue 3 的新特性；
2. 再读 runtime，理解组件和生命周期的实现；
3. 如果还有时间再读 compiler，理解编译优化过程。

如果你想省时间，可以直接看所有 `__tests__` 目录里的测试用例来了解 Vue 3 的所有功能。

### ref 与 reactive 的区别

## 3.0 与 2.0 有什么差别？

1. Proxy 比 Object.defineProperty 更强大，体现在：
   1. 可以检测属性的新增和删除
   2. 可以检测数组索引的变化和 length 的变化
   3. 支持 Map、Set、WeakMap 和 WeakSet
2. 性能更比 Vue 2.0 强。打包更科学不再打包没用到的模块，体积更小、速度更快，支持 tree-shaking
3. Composition API（组合 API）
4. 三个新内置组件
   1. Fragment 不再需要使用 template 包裹标签，一个组件包含多个根节点
   2. Teleport 组件插入的位置灵活，在 DOM 中渲染一个 subtree，而不需要在一个组件中
   3. Suspense 异步组件
5. 更友好的支持兼容 TS

#### 源码组织方式的变化

采用 Typescript 重写
采用 Monorepo 管理项目结构

#### composition API

包含一个描述组件的选项（data、methods、props 等）的对象。
Options API 开发复杂组件，同一功能逻辑代码会被拆分到不同选项
Vue 3.0 新增了一组 API
一组基于函数的 API
可以更灵活的组织组件的逻辑

#### 性能提升

响应式系统升级
Vue.js 2.0 x 中响应式系统的核心 defineProperty
Vue.js 3.0 x 中使用 Proxy 对象重写响应式系统

#### 编译优化

Vue.js 2.0 x 中通过标记静态节点，优化 diff 的过程
Vue.js 3.0 x 中标记和提升所有的静态根节点，diff 的时候只需要对比动态内容
Fragments （升级 Vuter 插件）
静态提升
Patch flag
缓存事件处理函数

#### 源码体积优化

更好地支持 Tree-shaking

Vue.js 3.0 x 中移除了一些不常用的 API
例如：inline-template filter 等

在大部分情况下，我们并不需要 vue 中的所有功能，但是在之前的 vue 版本中，我们没有一个合适的办法用来除去不需要的功能，而 Vue3 中，为了满足体积更小的需求，支持 Tree-shaking，也就意味着我们可以按需求引用的内置的指令和方法。

#### Vite

在开发模式下不需要打包可以直接运行
开发模式下必须对项目打包才能运行
特点
快速冷启动
按需编译
模块热更新
ES Module

现代浏览器都支持 ES Module （IE 不支持）
通过下面的方式加载模块 `<script type="module" src="..."></script>`
支持模块的 script 默认延时加载
类似 script 标签设置 defer
在文档解析完成后，触发 DOMContentLoaded 事件前执行

#### Vite as Vue-CLI

Vite 在生产环境使用 Rollup 打包
基于 ES Module 的方式打包

Vue-CLI 使用 Webpack 打包

### 2.x 存在的问题

1. 随着功能的增长，复杂组件的代码变得越来越难以维护。 尤其发生你去新接手别人的代码时。 根本原因是 Vue 的现有 API 通过「选项」组织代码，但是在大部分情况下，通过逻辑考虑来组织代码更有意义。
2. 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制。
3. 类型推断不够友好。

### 3.0 与 2.0 响应式部分做了哪些优化？

1. 响应式实现优化
2. 编译优化
3. 源码体积优化

### 两者 diff 算法有什么区别？ 静态标记？

静态标记是什么，如何做的？
