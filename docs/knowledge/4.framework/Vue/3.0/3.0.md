---
title: vue 3
date: '2020-10-26'
draft: true
---

## 其他

- vue@2 与 vue@3 的差别， 性能如何提升的，静态标记？
- Vue 的模板编译原理，怎么讲 template 编译成 render 函数的？
- nextTick 与异步事件更新队列
- 生命钩子函数执行的顺序
- 组件 keep-alive 的原理，以及对应执行的钩子

## 3.0

### 兼容性

vue-next 打包后的代码是 ES2015+，不支持 IE 11

### 为什么不用 class

class 提案被撤回， 并且 class 因为会有副作用不能 tree sharking。类被封装成了一个 IIFE(立即执行函数)，然后返回一个构造函数。Vue 3 的源代码完全没有使用 class 关键字！（只在测试代码和示例代码里用到了 class 关键字）。

### vue 3 源码的阅读顺序

1. 先读 reactivity，能最快了解 Vue 3 的新特性；
2. 再读 runtime，理解组件和生命周期的实现；
3. 如果还有时间再读 compiler，理解编译优化过程。

如果你想省时间，可以直接看所有 `__tests__` 目录里的测试用例来了解 Vue 3 的所有功能。

## 2.x 存在的问题

1. 随着功能的增长，复杂组件的代码变得越来越难以维护。根本原因是 Vue 的现有 API 通过「选项」组织代码，但是在大部分情况下，通过逻辑考虑来组织代码更有意义。
2. 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制。
3. 类型推断不够友好。

## 3.0 与 2.0 有什么差别？

Vue 3 核⼼优势：

1. Proxy 比 Object.defineProperty 更强大，体现在：
   1. 可以检测属性的新增和删除
   2. 可以检测数组索引的变化和 length 的变化
   3. 支持 Map、Set、WeakMap 和 WeakSet
2. 性能更比 Vue 2.0 强。打包更科学不再打包没用到的模块，体积更小、速度更快，支持 tree-shaking。更友好的 `Tree-shaking` ⽀持（渐进式体验）更⼤的代码压缩空间；
3. Composition API（组合 API），没有 this，没烦恼，更灵活的逻辑复⽤能⼒。
4. 三个新内置组件
   1. Fragment 不再需要使用 template 包裹标签，一个组件包含多个根节点
   2. Teleport 组件插入的位置灵活，在 DOM 中渲染一个 subtree，而不需要在一个组件中
   3. Suspense 异步组件
5. 更好的类型推导能⼒（`TypeScript`

#### 3.0 与 2.0 响应式部分做了哪些优化？

1. 响应式实现优化
2. 编译优化
3. 源码体积优化

#### 1. 响应式系统升级

Vue.js 2.0 x 中响应式系统的核心 defineProperty
Vue.js 3.0 x 中使用 Proxy 对象重写响应式系统

#### 2. 编译优化

Vue.js 2.0 x 中通过标记静态节点，优化 diff 的过程
Vue.js 3.0 x 中标记和提升所有的静态根节点，diff 的时候只需要对比动态内容
Fragments （升级 Vuter 插件）
静态提升
Patch flag
缓存事件处理函数: 缓存事件处理函数减少了不必要的更新操作

vue2.x 和 vue 3.x 编译的部分完完全全重构了，之前 Vue2.x 采用，`_c` 的模式创建标签，`_v` 为 Vnode 节点， 而当前的 Vue 3.x 通过 `_createBlock` 生成 block tree

- Vue 2.x 数据更新并触发重新渲染的粒度是组件级的，单个组件内部需要遍历该组件的整个 vnode 树
- Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的。每个区块只需要追踪自身包含的动态节点。

静态提升：静态节点都会被提升到 render 的外部，只有初始化时会被创建，再次调用 render 时不会再次创建，可以直接重用这些静态节点对应的 vnode

#### 3. 源码体积优化

更好地支持 Tree-shaking

Vue.js 3.0 x 中移除了一些不常用的 API
例如：inline-template filter 等

在大部分情况下，我们并不需要 vue 中的所有功能，但是在之前的 vue 版本中，我们没有一个合适的办法用来除去不需要的功能，而 Vue3 中，为了满足体积更小的需求，支持 Tree-shaking，也就意味着我们可以按需求引用的内置的指令和方法。

#### 4. Vite

在开发模式下不需要打包可以直接运行
开发模式下必须对项目打包才能运行
特点
快速冷启动
按需编译
模块热更新
ES Module

现代浏览器都支持 ES Module （IE 不支持）
通过下面的方式加载模块 `<script type="module" src="..."></script>`
支持模块的 script 默认延时加载
类似 script 标签设置 defer
在文档解析完成后，触发 DOMContentLoaded 事件前执行

#### 5. Vite as Vue-CLI

Vite 在生产环境使用 Rollup 打包
基于 ES Module 的方式打包

Vue-CLI 使用 Webpack 打包

#### 6. 源码组织方式的变化

采用 Typescript 重写
采用 Monorepo 管理项目结构

#### 7. composition API

Composition API 主要是提高了代码逻辑的可复用性，并且将 Reactivity 模块独立出来，这也使得 vue 3 变得更加灵活地与其他框架组合使用。

包含一个描述组件的选项（data、methods、props 等）的对象。
Options API 开发复杂组件，同一功能逻辑代码会被拆分到不同选项
Vue 3.0 新增了一组 API
一组基于函数的 API
可以更灵活的组织组件的逻辑

优点：

1. 优化逻辑组织
2. 优化逻辑复用。项目变得复杂的时候，免不了需要抽象出一些复用的逻辑。在 vue 2 的时候通常会使用 mixins， 使用单个 mixin 似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候，会存在两个非常明显的问题：命名冲突和数据来源不清晰。使用组合式 api 能保证变量的整个数据来源清晰了，

#### 性能提升

### 两者 diff 算法有什么区别？ 静态标记？

Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树。如果一个组件的 template 很大，但是动态部分比较少。因为这段代码中只有一个动态节点，所以这里有很多 diff 和遍历其实都是不需要的，这就会导致 vnode 的性能跟模版大小正相关，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。

而对于上述例子，理想状态只需要 diff 这个绑定 message 动态节点的 p 标签即可。
Vue.js 3.0 做到了，它通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破。

除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法

### 静态节点提升

## Proxy

Vue.js 3.x 中使用 Proxy 对象重写响应式系统.

1. 一次性监听所有属性
1. 监听动态新增的属性
1. 监听删除的属性
1. 监听数组的索引和 length 属性

### Proxy 代理器

他可以实现 js 中的“元编程”：在目标对象之前架设拦截，可以过滤和修改外部的访问。

它支持多达 13 种拦截操作，例如下面代码展示的`set`和`get`方法，分别可以在设置对象属性和访问对象属性时候进行拦截。

拦截方式

- **get()**：拦截对象属性读取
- **set()**：拦截对象属性设置，返回布尔值
- **has()**：拦截对象属性检查`k in obj`，返回布尔值
- **deleteProperty()**：拦截对象属性删除`delete obj[k]`，返回布尔值
- **defineProperty()**：拦截对象属性定义`Object.defineProperty()`、`Object.defineProperties()`，返回布尔值
- **ownKeys()**：拦截对象属性遍历`for-in`、`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`，返回数组
- **getOwnPropertyDescriptor()**：拦截对象属性描述读取`Object.getOwnPropertyDescriptor()`，返回对象
- **getPrototypeOf()**：拦截对象读取`instanceof`、`Object.getPrototypeOf()`、`Object.prototype.__proto__`、`Object.prototype.isPrototypeOf()`、`Reflect.getPrototypeOf()`，返回对象
- **setPrototypeOf()**：拦截对象设置`Object.setPrototypeOf()`，返回布尔值
- **isExtensible()**：拦截对象是否可扩展读取`Object.isExtensible()`，返回布尔值
- **preventExtensions()**：拦截对象不可扩展设置`Object.preventExtensions()`，返回布尔值
- **apply()**：拦截 Proxy 实例作为函数调用`proxy()`、`proxy.apply()`、`proxy.call()`
- **construct()**：拦截 Proxy 实例作为构造函数调用`new proxy()`

```js
const handler = {
  // receiver 指向 proxy 实例
  get(target, property, receiver) {
    console.log(`GET: target is ${target}, property is ${property}`);
    return Reflect.get(target, property, receiver);
  },
  set(target, property, value, receiver) {
    console.log(`SET: target is ${target}, property is ${property}`);
    return Reflect.set(target, property, value);
  },
};

const obj = { a: 1, b: { c: 0, d: { e: -1 } } };
const newObj = new Proxy(obj, handler);

/**
 * 以下是测试代码
 */

newObj.a; // output: GET...
newObj.b.c; // output: GET...

newObj.a = 123; // output: SET...
newObj.b.c = -1; // output: GET...
```

运行这段代码，会发现最后一行的输出是 `GET ...`。也就是说它触发的是`get`拦截器，而不是期望的`set`拦截器。**这是因为对于对象的深层属性，需要专门对其设置 Proxy**。

### 为什么 Vue 3 采用 Proxy 替换 Object.defineProperty

之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。

### Proxy 与 Object.defineProperty 的对比

数据劫持: 在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果

Object.defineProperty() 和 ES6 中新增的 Proxy 对象，会经常用来做数据劫持，数据劫持的典型应用就是双向数据绑定。

`Object.defineProperty` 虽然已经能够实现双向绑定了，但是他还是有缺陷的。

1. 只能对属性进行数据劫持，所以需要深度遍历整个对象
2. 对于数组不能监听到数据的变化

虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的。

反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty

Proxy 重点难点：

- 要使`Proxy`起作用，必须针对`实例`进行操作，而不是针对`目标对象`进行操作
- 没有设置任何拦截时，等同于`直接通向原对象`
- 属性被定义为`不可读写/扩展/配置/枚举`时，使用拦截方法会报错
- 代理下的目标对象，内部`this`指向`Proxy代理`

#### Object.defineProperty

Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

#### Proxy

Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等），代理会将所有应用到它的操作转发到这个目标对象上。

```js
let target = {};
let handler = {
  get: function(obj, name) {
    console.log('get');
    return name in obj ? obj[name] : 37;
  },
  set: function(obj, name, value) {
    console.log('set');
    obj[name] = value;
  },
};

// target: 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
// handler: 一个对象，其属性是当执行一个操作时定义代理的行为的函数
let p = new Proxy(target, handler);
p.a = 1; // 进行set操作，并且操作会被转发到目标
p.b = undefined; // 进行set操作，并且操作会被转发到目标
console.log(p.a, p.b); // 1, undefined ，进行get操作
console.log('c' in p, p.c); // false, 37  进行get操作
console.log(target); // {a: 1, b: undefined}. 操作已经被正确地转发
```

#### Proxy 解决问题

1. 针对对象
   Proxy 是针对 整个对象 obj 的。因此无论 obj 内部包含多少个 key ，都可以走进 set。(并不需要通过 Object.keys() 的遍历)，解决了 Object.defineProperty() 必须遍历对象的每个属性的问题。

```js
let obj = {
  name: 'Eason',
  age: 30,
};
let handler = {
  get(target, key, receiver) {
    console.log('get', key);
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    console.log('set', key, value);
    return Reflect.set(target, key, value, receiver);
  },
};
let proxy = new Proxy(obj, handler);
proxy.name = 'Zoe'; // set name Zoe
proxy.age = 18; // set age 18
```

Reflect.get 和 Reflect.set 可以理解为类继承里的 super，即调用原来的方法

2. 支持数组
   Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的

```js
let arr = [1, 2, 3];
let proxy = new Proxy(arr, {
  get(target, key, receiver) {
    console.log('get', key);
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    console.log('set', key, value);
    return Reflect.set(target, key, value, receiver);
  },
});
proxy.push(4);
// 能够打印出很多内容. 会触发多次 handler 的问题 vue 是怎么解决的？
// get push     (寻找 proxy.push 方法)
// get length   (获取当前的 length)
// set 3 4      (设置 proxy[3] = 4)
// set length 4 (设置 proxy.length = 4)
```

3. 嵌套支持
   Proxy 也是不支持嵌套的，这点和 Object.defineProperty() 是一样的。因此也需要通过逐层遍历来解决。Proxy 的写法是在 get 里面递归调用 Proxy 并返回

```js
let obj = {
  info: {
    name: 'eason',
    blogs: ['webpack', 'babel', 'cache'],
  },
};
let handler = {
  get(target, key, receiver) {
    console.log('get', key);
    // 递归创建并返回
    if (typeof target[key] === 'object' && target[key] !== null) {
      return new Proxy(target[key], handler);
    }
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    console.log('set', key, value);
    return Reflect.set(target, key, value, receiver);
  },
};
let proxy = new Proxy(obj, handler);
// 以下两句都能够进入 set
proxy.info.name = 'Zoe';
proxy.info.blogs.push('proxy');
```

#### 总结

Proxy / Object.defineProperty 两者的区别：

- 当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截
- defineProperty 必须深层遍历嵌套的对象。 Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的
  > Proxy 对比 defineProperty 的优势
- Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富
- Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法
- Proxy 的兼容性不如 Object.defineProperty() (caniuse 的数据表明，QQ 浏览器和百度浏览器并不支持 Proxy，这对国内移动开发来说估计无法接受，但两者都支持 Object.defineProperty())
- 不能使用 polyfill 来处理兼容性
  > 接下来我们将会分别用 Proxy / Object.defineProperty 来实现双向绑定

## 用 Proxy 与 Object.defineProperty 实现双向绑定

```html
<body>
  hello,world
  <input type="text" id="model" />
  <p id="word"></p>
</body>
<script>
  const model = document.getElementById('model');
  const word = document.getElementById('word');
  var obj = {};

  const newObj = new Proxy(obj, {
    get: function(target, key, receiver) {
      console.log(`getting ${key}!`);
      return Reflect.get(target, key, receiver);
    },
    set: function(target, key, value, receiver) {
      console.log('setting', target, key, value, receiver);
      if (key === 'text') {
        model.value = value;
        word.innerHTML = value;
      }
      return Reflect.set(target, key, value, receiver);
    },
  });

  model.addEventListener('keyup', function(e) {
    newObj.text = e.target.value;
  });
</script>
```

Vue 的双向数据绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，那么我们起码要做以下三个步骤：

1. 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

流程图如下：
![image](https://user-images.githubusercontent.com/21194931/58623762-48237500-8301-11e9-8a69-75b342eaa7ab.png)

##### 实现 Observer

使用 Object.defineProperty 定义一个 Observer

```js
function defineProperty(obj, key, value) {
  Observer(value); // 递归遍历所有子属性
  Object.defineProperty(obj, key, {
    enumerable: true, // 可枚举
    configurable: false, // 不能再define
    set(newValue) {
      if (value === newValue) {
        return;
      }
      value = newValue;
      console.log(`set ${key}: ${newValue}`);
    },
    get() {
      console.log(`get ${key}: ${value}`);
      return value;
    },
  });
}
function Observer(data) {
  if (!data || typeof data !== 'object') {
    // 非对象即终止遍历
    return;
  }
  Object.keys(data).forEach(function(key) {
    defineReactive(data, key, data[key]); // 监听所有对象属性
  });
}
```

##### 实现 Dep

创建一个用来存储订阅者 Watcher 的订阅器，订阅器 Dep 主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。

```js
function Dep() {
  this.list = [];
}
Dep.prototype = {
  addSub: function(watcher) {
    this.list.push(watcher);
  },
  notify: function() {
    this.list.forEach(function(watcher) {
      watcher.update();
    });
  },
};
```

##### 实现 Watcher

既然实现了一个订阅器，那么就需要一个订阅者，订阅者 Watcher 在初始化的时候需要将自己添加进订阅器 Dep 中，

1. 在自身实例化时往属性订阅器(dep)里面添加自己
2. 待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发回调，更新视图

```js
function Watcher(obj, key, cb) {
  this.cb = cb;
  this.obj = obj;
  this.key = key;
  // 此处为了触发属性的getter，从而在dep添加自己
  this.value = this.get();
}
Watcher.prototype = {
  update: function() {
    this.run(); // 属性值变化收到通知
  },
  run: function() {
    var value = this.get(); // 取到最新值
    var oldVal = this.value;
    if (value !== oldVal) {
      this.value = value;
      this.cb.call(this.obj, value, oldVal); // 执行Compile中绑定的回调，更新视图
    }
  },
  get: function() {
    Dep.target = this; // 将当前订阅者指向自己
    var value = this.obj[this.key]; // 触发getter，添加自己到属性订阅器中
    Dep.target = null; // 添加完毕，重置
    return value;
  },
};
```

实现了订阅器和订阅者之后，需要将订阅器添加进入订阅者，将 Observer 改造以下植入订阅器。如果不好理解可以结合 watcher 一起看。

```js
function defineProperty(obj, key, value) {
  Observer(value); // 递归遍历所有子属性
  var dep = new Dep(); // 生成一个Dep实例
  Object.defineProperty(obj, key, {
    enumerable: true, // 可枚举
    configurable: false, // 不能再define
    set(newValue) {
      if (value === newValue) {
        return;
      }
      value = newValue;
      console.log(`set ${key}: ${newValue}`);
      dep.notify(); // 如果数据变化，通知所有订阅者
    },
    get() {
      if (Dep.target) {
        dep.addSub(Dep.target); // 在这里添加一个订阅者，这里的Dep.target是指订阅器本身
      }
      console.log(`get ${key}: ${value}`);
      return value;
    },
  });
}
```

Observer 改造完成后，已经具备了监听数据， 添加订阅器和数据变化通知订阅者的功能。接下来就是将 watcher 添加进入订阅者，模拟实现 Compile，并进行数据初始化。

##### 模拟实现 Compile

我们这里不解析指令所以直接写出 watcher,并添加进去订阅者

```js
function inputChange(event) {
  data.value = event.target.value
}
>
function clickChange() {
  data.value = '你好 世界'
}
function renderInput(newValue) {
  if (input) {
    input.value = newValue
  }
}
>
function renderText(newValue) {
  if (text) {
    text.innerHTML = newValue
  }
}
new Watcher(data, 'value', renderInput)
new Watcher(data, 'value', renderText)
```

数据初始化

```js
let data = {
  value: '',
};
Observer(data);
```

这样一个简单的基于 Object.defineProperty 的双向数据绑定就完成了。

## API

### ref 与 reactive 的区别

#### vue@2 与 vue@3 做了哪些升级

1. 开发语言切换到 ts, 包使用 lerna 来管理。
2. diff 算法优化，编译速度更快。vue2.x 的虚拟 DOM 是进行全量比较，vue3 新增了静态标记（PatchFlag）。
3. 静态提升：vue2.x 无论元素是否参与更新，每次都会重新创新，然后渲染；vue3 中对于不参与更新的元素会做静态提升，只会创建一次，在渲染的时候复用即可。
4. 包拆的更细，更小。用了 Tree-shaking， 没有用到的代码基本不会被打包进去。
5. 引入了很多 hooks

## vue3 的响应式

https://segmentfault.com/a/1190000022198316

## 总结优点

Vue3 通过 Proxy 响应式+组件内部 vdom+静态标记，把任务颗粒度控制的足够细致，所以也不太需要 time-slice 了，就可能不太需要 react 的 fiber 这种时间切片的概念了。
