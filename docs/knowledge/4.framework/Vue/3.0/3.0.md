---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

## 3.0

> vue-next 打包后的代码是 ES2015+，不支持 IE 11

### 为什么不用 class

class 提案被撤回， 并且 class 因为会有副作用不能 tree sharking。类被封装成了一个 IIFE(立即执行函数)，然后返回一个构造函数。Vue 3 的源代码完全没有使用 class 关键字！（只在测试代码和示例代码里用到了 class 关键字）。

### 解决的问题

### vue 3 源码的阅读顺序

1. 先读 reactivity，能最快了解 Vue 3 的新特性；
2. 再读 runtime，理解组件和生命周期的实现；
3. 如果还有时间再读 compiler，理解编译优化过程。

如果你想省时间，可以直接看所有 `__tests__` 目录里的测试用例来了解 Vue 3 的所有功能。

### ref 与 reactive 的区别

## 问题

### 3.0 与 2.0 有什么差别？

1. Proxy 比 Object.defineProperty 更强大，体现在：
   1. 可以检测属性的新增和删除
   2. 可以检测数组索引的变化和 length 的变化
   3. 支持 Map、Set、WeakMap 和 WeakSet
2. 性能更比 Vue 2.0 强。打包更科学不再打包没用到的模块，体积更小、速度更快，支持 tree-shaking
3. Composition API（组合 API）
4. 三个新内置组件
   1. Fragment 不再需要使用 template 包裹标签，一个组件包含多个根节点
   2. Teleport 组件插入的位置灵活，在 DOM 中渲染一个 subtree，而不需要在一个组件中
   3. Suspense 异步组件
5. 更友好的支持兼容 TS

### 3.0 与 2.0 响应式部分做了哪些优化？

### 两者 diff 算法有什么区别？ 静态标记？
