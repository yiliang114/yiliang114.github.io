---
title: vue 3
date: '2020-10-26'
draft: true
---

<!-- https://juejin.cn/post/6844904050014552072-->
<!-- https://github.com/cuixiaorui/mini-vue/blob/master/README_CN.md -->

## vue@2 与 vue@3 的差别， 性能如何提升的，静态标记？
## 3.0

### 兼容性

vue-next 打包后的代码是 ES2015+，不支持 IE 11

### 为什么不用 class

class 提案被撤回， 并且 class 因为会有副作用不能 tree sharking。类被封装成了一个 IIFE(立即执行函数)，然后返回一个构造函数。Vue 3 的源代码完全没有使用 class 关键字！（只在测试代码和示例代码里用到了 class 关键字）。

### vue 3 源码的阅读顺序

1. 先读 reactivity，能最快了解 Vue 3 的新特性；
2. 再读 runtime，理解组件和生命周期的实现；
3. 如果还有时间再读 compiler，理解编译优化过程。

如果你想省时间，可以直接看所有 `__tests__` 目录里的测试用例来了解 Vue 3 的所有功能。

## 2.x 存在的问题

1. 随着功能的增长，复杂组件的代码变得越来越难以维护。根本原因是 Vue 的现有 API 通过「选项」组织代码，但是在大部分情况下，通过逻辑考虑来组织代码更有意义。
2. 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制。
3. 类型推断不够友好。

## 3.0 与 2.0 有什么差别？

Vue 3 核⼼优势：

1. Proxy 比 Object.defineProperty 更强大，体现在：
   1. 可以检测属性的新增和删除
   2. 可以检测数组索引的变化和 length 的变化
   3. 支持 Map、Set、WeakMap 和 WeakSet
2. 性能更比 Vue 2.0 强。打包更科学不再打包没用到的模块，体积更小、速度更快，支持 tree-shaking。更友好的 `Tree-shaking` ⽀持（渐进式体验）更⼤的代码压缩空间；
3. Composition API（组合 API），没有 this，没烦恼，更灵活的逻辑复⽤能⼒。
4. 三个新内置组件
   1. Fragment 不再需要使用 template 包裹标签，一个组件包含多个根节点
   2. Teleport 组件插入的位置灵活，在 DOM 中渲染一个 subtree，而不需要在一个组件中
   3. Suspense 异步组件
5. 更好的类型推导能⼒（`TypeScript`

#### 3.0 与 2.0 响应式部分做了哪些优化？

1. 响应式实现优化
2. 编译优化
3. 源码体积优化

#### 1. 响应式系统升级

Vue.js 2.0 x 中响应式系统的核心 defineProperty
Vue.js 3.0 x 中使用 Proxy 对象重写响应式系统

#### 2. 编译优化

Vue.js 2.0 x 中通过标记静态节点，优化 diff 的过程
Vue.js 3.0 x 中标记和提升所有的静态根节点，diff 的时候只需要对比动态内容
Fragments （升级 Vuter 插件）
静态提升
Patch flag
缓存事件处理函数: 缓存事件处理函数减少了不必要的更新操作

vue2.x 和 vue 3.x 编译的部分完完全全重构了，之前 Vue2.x 采用，`_c` 的模式创建标签，`_v` 为 Vnode 节点， 而当前的 Vue 3.x 通过 `_createBlock` 生成 block tree

- Vue 2.x 数据更新并触发重新渲染的粒度是组件级的，单个组件内部需要遍历该组件的整个 vnode 树
- Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的。每个区块只需要追踪自身包含的动态节点。

静态提升：静态节点都会被提升到 render 的外部，只有初始化时会被创建，再次调用 render 时不会再次创建，可以直接重用这些静态节点对应的 vnode

#### 3. 源码体积优化

更好地支持 Tree-shaking

Vue.js 3.0 x 中移除了一些不常用的 API
例如：inline-template filter 等

在大部分情况下，我们并不需要 vue 中的所有功能，但是在之前的 vue 版本中，我们没有一个合适的办法用来除去不需要的功能，而 Vue3 中，为了满足体积更小的需求，支持 Tree-shaking，也就意味着我们可以按需求引用的内置的指令和方法。

#### 4. Vite

在开发模式下不需要打包可以直接运行
开发模式下必须对项目打包才能运行
特点
快速冷启动
按需编译
模块热更新
ES Module

现代浏览器都支持 ES Module （IE 不支持）
通过下面的方式加载模块 `<script type="module" src="..."></script>`
支持模块的 script 默认延时加载
类似 script 标签设置 defer
在文档解析完成后，触发 DOMContentLoaded 事件前执行

#### 5. Vite as Vue-CLI

Vite 在生产环境使用 Rollup 打包
基于 ES Module 的方式打包

Vue-CLI 使用 Webpack 打包

#### 6. 源码组织方式的变化

采用 Typescript 重写
采用 Monorepo 管理项目结构

#### 7. composition API

Composition API 主要是提高了代码逻辑的可复用性，并且将 Reactivity 模块独立出来，这也使得 vue 3 变得更加灵活地与其他框架组合使用。

包含一个描述组件的选项（data、methods、props 等）的对象。
Options API 开发复杂组件，同一功能逻辑代码会被拆分到不同选项
Vue 3.0 新增了一组 API
一组基于函数的 API
可以更灵活的组织组件的逻辑

优点：

1. 优化逻辑组织
2. 优化逻辑复用。项目变得复杂的时候，免不了需要抽象出一些复用的逻辑。在 vue 2 的时候通常会使用 mixins， 使用单个 mixin 似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候，会存在两个非常明显的问题：命名冲突和数据来源不清晰。使用组合式 api 能保证变量的整个数据来源清晰了，

#### 性能提升

## Proxy

Vue.js 3.x 中使用 Proxy 对象重写响应式系统.

1. 一次性监听所有属性
1. 监听动态新增的属性
1. 监听删除的属性
1. 监听数组的索引和 length 属性

### Proxy 代理器

他可以实现 js 中的“元编程”：在目标对象之前架设拦截，可以过滤和修改外部的访问。

它支持多达 13 种拦截操作，例如下面代码展示的`set`和`get`方法，分别可以在设置对象属性和访问对象属性时候进行拦截。

拦截方式

- **get()**：拦截对象属性读取
- **set()**：拦截对象属性设置，返回布尔值
- **has()**：拦截对象属性检查`k in obj`，返回布尔值
- **deleteProperty()**：拦截对象属性删除`delete obj[k]`，返回布尔值
- **defineProperty()**：拦截对象属性定义`Object.defineProperty()`、`Object.defineProperties()`，返回布尔值
- **ownKeys()**：拦截对象属性遍历`for-in`、`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`，返回数组
- **getOwnPropertyDescriptor()**：拦截对象属性描述读取`Object.getOwnPropertyDescriptor()`，返回对象
- **getPrototypeOf()**：拦截对象读取`instanceof`、`Object.getPrototypeOf()`、`Object.prototype.__proto__`、`Object.prototype.isPrototypeOf()`、`Reflect.getPrototypeOf()`，返回对象
- **setPrototypeOf()**：拦截对象设置`Object.setPrototypeOf()`，返回布尔值
- **isExtensible()**：拦截对象是否可扩展读取`Object.isExtensible()`，返回布尔值
- **preventExtensions()**：拦截对象不可扩展设置`Object.preventExtensions()`，返回布尔值
- **apply()**：拦截 Proxy 实例作为函数调用`proxy()`、`proxy.apply()`、`proxy.call()`
- **construct()**：拦截 Proxy 实例作为构造函数调用`new proxy()`

```js
const handler = {
  // receiver 指向 proxy 实例
  get(target, property, receiver) {
    console.log(`GET: target is ${target}, property is ${property}`);
    return Reflect.get(target, property, receiver);
  },
  set(target, property, value, receiver) {
    console.log(`SET: target is ${target}, property is ${property}`);
    return Reflect.set(target, property, value);
  },
};

const obj = { a: 1, b: { c: 0, d: { e: -1 } } };
const newObj = new Proxy(obj, handler);

/**
 * 以下是测试代码
 */

newObj.a; // output: GET...
newObj.b.c; // output: GET...

newObj.a = 123; // output: SET...
newObj.b.c = -1; // output: GET...
```

运行这段代码，会发现最后一行的输出是 `GET ...`。也就是说它触发的是`get`拦截器，而不是期望的`set`拦截器。**这是因为对于对象的深层属性，需要专门对其设置 Proxy**。

### 为什么 Vue 3 采用 Proxy 替换 Object.defineProperty

之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。

### Proxy 与 Object.defineProperty 的对比

数据劫持: 在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果

Object.defineProperty() 和 ES6 中新增的 Proxy 对象，会经常用来做数据劫持，数据劫持的典型应用就是双向数据绑定。

`Object.defineProperty` 虽然已经能够实现双向绑定了，但是他还是有缺陷的。

1. 只能对属性进行数据劫持，所以需要深度遍历整个对象
2. 对于数组不能监听到数据的变化

虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的。

反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty

Proxy 重点难点：

- 要使`Proxy`起作用，必须针对`实例`进行操作，而不是针对`目标对象`进行操作
- 没有设置任何拦截时，等同于`直接通向原对象`
- 属性被定义为`不可读写/扩展/配置/枚举`时，使用拦截方法会报错
- 代理下的目标对象，内部`this`指向`Proxy代理`

#### Object.defineProperty

Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

#### Proxy

Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等），代理会将所有应用到它的操作转发到这个目标对象上。

```js
let target = {};
let handler = {
  get: function(obj, name) {
    console.log('get');
    return name in obj ? obj[name] : 37;
  },
  set: function(obj, name, value) {
    console.log('set');
    obj[name] = value;
  },
};

// target: 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
// handler: 一个对象，其属性是当执行一个操作时定义代理的行为的函数
let p = new Proxy(target, handler);
p.a = 1; // 进行set操作，并且操作会被转发到目标
p.b = undefined; // 进行set操作，并且操作会被转发到目标
console.log(p.a, p.b); // 1, undefined ，进行get操作
console.log('c' in p, p.c); // false, 37  进行get操作
console.log(target); // {a: 1, b: undefined}. 操作已经被正确地转发
```

#### Proxy 解决问题

1. 针对对象
   Proxy 是针对 整个对象 obj 的。因此无论 obj 内部包含多少个 key ，都可以走进 set。(并不需要通过 Object.keys() 的遍历)，解决了 Object.defineProperty() 必须遍历对象的每个属性的问题。

```js
let obj = {
  name: 'Eason',
  age: 30,
};
let handler = {
  get(target, key, receiver) {
    console.log('get', key);
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    console.log('set', key, value);
    return Reflect.set(target, key, value, receiver);
  },
};
let proxy = new Proxy(obj, handler);
proxy.name = 'Zoe'; // set name Zoe
proxy.age = 18; // set age 18
```

Reflect.get 和 Reflect.set 可以理解为类继承里的 super，即调用原来的方法

2. 支持数组
   Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的

```js
let arr = [1, 2, 3];
let proxy = new Proxy(arr, {
  get(target, key, receiver) {
    console.log('get', key);
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    console.log('set', key, value);
    return Reflect.set(target, key, value, receiver);
  },
});
proxy.push(4);
// 能够打印出很多内容. 会触发多次 handler 的问题 vue 是怎么解决的？
// get push     (寻找 proxy.push 方法)
// get length   (获取当前的 length)
// set 3 4      (设置 proxy[3] = 4)
// set length 4 (设置 proxy.length = 4)
```

3. 嵌套支持
   Proxy 也是不支持嵌套的，这点和 Object.defineProperty() 是一样的。因此也需要通过逐层遍历来解决。Proxy 的写法是在 get 里面递归调用 Proxy 并返回

```js
let obj = {
  info: {
    name: 'eason',
    blogs: ['webpack', 'babel', 'cache'],
  },
};
let handler = {
  get(target, key, receiver) {
    console.log('get', key);
    // 递归创建并返回
    if (typeof target[key] === 'object' && target[key] !== null) {
      return new Proxy(target[key], handler);
    }
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    console.log('set', key, value);
    return Reflect.set(target, key, value, receiver);
  },
};
let proxy = new Proxy(obj, handler);
// 以下两句都能够进入 set
proxy.info.name = 'Zoe';
proxy.info.blogs.push('proxy');
```

#### 总结

Proxy / Object.defineProperty 两者的区别：

- 当使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截
- defineProperty 必须深层遍历嵌套的对象。 Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的
  > Proxy 对比 defineProperty 的优势
- Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富
- Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法
- Proxy 的兼容性不如 Object.defineProperty() (caniuse 的数据表明，QQ 浏览器和百度浏览器并不支持 Proxy，这对国内移动开发来说估计无法接受，但两者都支持 Object.defineProperty())
- 不能使用 polyfill 来处理兼容性
  > 接下来我们将会分别用 Proxy / Object.defineProperty 来实现双向绑定

## 用 Proxy 与 Object.defineProperty 实现双向绑定

```html
<body>
  hello,world
  <input type="text" id="model" />
  <p id="word"></p>
</body>
<script>
  const model = document.getElementById('model');
  const word = document.getElementById('word');
  var obj = {};

  const newObj = new Proxy(obj, {
    get: function(target, key, receiver) {
      console.log(`getting ${key}!`);
      return Reflect.get(target, key, receiver);
    },
    set: function(target, key, value, receiver) {
      console.log('setting', target, key, value, receiver);
      if (key === 'text') {
        model.value = value;
        word.innerHTML = value;
      }
      return Reflect.set(target, key, value, receiver);
    },
  });

  model.addEventListener('keyup', function(e) {
    newObj.text = e.target.value;
  });
</script>
```

Vue 的双向数据绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，那么我们起码要做以下三个步骤：

1. 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
2. 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3. 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

流程图如下：
![image](https://user-images.githubusercontent.com/21194931/58623762-48237500-8301-11e9-8a69-75b342eaa7ab.png)

##### 实现 Observer

使用 Object.defineProperty 定义一个 Observer

```js
function defineProperty(obj, key, value) {
  Observer(value); // 递归遍历所有子属性
  Object.defineProperty(obj, key, {
    enumerable: true, // 可枚举
    configurable: false, // 不能再define
    set(newValue) {
      if (value === newValue) {
        return;
      }
      value = newValue;
      console.log(`set ${key}: ${newValue}`);
    },
    get() {
      console.log(`get ${key}: ${value}`);
      return value;
    },
  });
}
function Observer(data) {
  if (!data || typeof data !== 'object') {
    // 非对象即终止遍历
    return;
  }
  Object.keys(data).forEach(function(key) {
    defineReactive(data, key, data[key]); // 监听所有对象属性
  });
}
```

##### 实现 Dep

创建一个用来存储订阅者 Watcher 的订阅器，订阅器 Dep 主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。

```js
function Dep() {
  this.list = [];
}
Dep.prototype = {
  addSub: function(watcher) {
    this.list.push(watcher);
  },
  notify: function() {
    this.list.forEach(function(watcher) {
      watcher.update();
    });
  },
};
```

##### 实现 Watcher

既然实现了一个订阅器，那么就需要一个订阅者，订阅者 Watcher 在初始化的时候需要将自己添加进订阅器 Dep 中，

1. 在自身实例化时往属性订阅器(dep)里面添加自己
2. 待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发回调，更新视图

```js
function Watcher(obj, key, cb) {
  this.cb = cb;
  this.obj = obj;
  this.key = key;
  // 此处为了触发属性的getter，从而在dep添加自己
  this.value = this.get();
}
Watcher.prototype = {
  update: function() {
    this.run(); // 属性值变化收到通知
  },
  run: function() {
    var value = this.get(); // 取到最新值
    var oldVal = this.value;
    if (value !== oldVal) {
      this.value = value;
      this.cb.call(this.obj, value, oldVal); // 执行Compile中绑定的回调，更新视图
    }
  },
  get: function() {
    Dep.target = this; // 将当前订阅者指向自己
    var value = this.obj[this.key]; // 触发getter，添加自己到属性订阅器中
    Dep.target = null; // 添加完毕，重置
    return value;
  },
};
```

实现了订阅器和订阅者之后，需要将订阅器添加进入订阅者，将 Observer 改造以下植入订阅器。如果不好理解可以结合 watcher 一起看。

```js
function defineProperty(obj, key, value) {
  Observer(value); // 递归遍历所有子属性
  var dep = new Dep(); // 生成一个Dep实例
  Object.defineProperty(obj, key, {
    enumerable: true, // 可枚举
    configurable: false, // 不能再define
    set(newValue) {
      if (value === newValue) {
        return;
      }
      value = newValue;
      console.log(`set ${key}: ${newValue}`);
      dep.notify(); // 如果数据变化，通知所有订阅者
    },
    get() {
      if (Dep.target) {
        dep.addSub(Dep.target); // 在这里添加一个订阅者，这里的Dep.target是指订阅器本身
      }
      console.log(`get ${key}: ${value}`);
      return value;
    },
  });
}
```

Observer 改造完成后，已经具备了监听数据， 添加订阅器和数据变化通知订阅者的功能。接下来就是将 watcher 添加进入订阅者，模拟实现 Compile，并进行数据初始化。

##### 模拟实现 Compile

我们这里不解析指令所以直接写出 watcher,并添加进去订阅者

```js
function inputChange(event) {
  data.value = event.target.value
}
>
function clickChange() {
  data.value = '你好 世界'
}
function renderInput(newValue) {
  if (input) {
    input.value = newValue
  }
}
>
function renderText(newValue) {
  if (text) {
    text.innerHTML = newValue
  }
}
new Watcher(data, 'value', renderInput)
new Watcher(data, 'value', renderText)
```

数据初始化

```js
let data = {
  value: '',
};
Observer(data);
```

这样一个简单的基于 Object.defineProperty 的双向数据绑定就完成了。

## API

### ref 与 reactive 的区别

#### vue@2 与 vue@3 做了哪些升级

1. 开发语言切换到 ts, 包使用 lerna 来管理。
2. diff 算法优化，编译速度更快。vue2.x 的虚拟 DOM 是进行全量比较，vue3 新增了静态标记（PatchFlag）。
3. 静态提升：vue2.x 无论元素是否参与更新，每次都会重新创新，然后渲染；vue3 中对于不参与更新的元素会做静态提升，只会创建一次，在渲染的时候复用即可。
4. 包拆的更细，更小。用了 Tree-shaking， 没有用到的代码基本不会被打包进去。
5. 引入了很多 hooks

## vue3 的响应式

https://segmentfault.com/a/1190000022198316

## 静态节点提升

**「静态节点提升」**是「Vue3」针对 `VNode` 更新过程性能问题而提出的一个优化点。众所周知，在大型应用场景下，[「Vue2.x」](https://www.w3cschool.cn/vuejs2/) 的 `patchVNode` 过程，即 `diff` 过程是非常缓慢的，这是一个十分令人头疼的问题。

虽然，对于面试常问的 `diff` 过程在一定程度上是减少了对 `DOM` 的直接操作。但是，**「这个减少是有一定成本的」**。因为，如果是复杂应用，那么就会存在父子关系非常复杂的 `VNode`，而这也就是 `diff` 的痛点，它会不断地递归调用 `patchVNode`，不断堆叠而成的几毫秒，最终就会造成 `VNode` 更新缓慢。

「Vue3」重写了整个 `Compiler` 过程，提出了静态提升、靶向更新等优化点，来提高 `patchVNode` 过程。

### 什么是 patchFlag

由于，在 `compile` 过程的 `transfrom` 阶段会提及 AST Element 上的 `patchFlag` 属性。所以，在正式认识 `complie` 之前，我们先搞清楚一个概念，什么是 `patchFlag`？

`patchFlag` 是 `complier` 时的 `transform` 阶段解析 AST Element 打上的**「优化标识」**。并且，顾名思义 `patchFlag`，`patch` 一词表示着它会为 `runtime`时的 `patchVNode` 提供依据，从而实现靶向更新 `VNode` 的效果。因此，这样一来一往，也就是耳熟能详的 Vue3 巧妙结合 `runtime` 与 `compiler` 实现靶向更新和静态提升。

而在源码中 `patchFlag` 被定义为一个**「数字枚举类型」**，每一个枚举值对应的标识意义会是这样：

![数字枚举类型](https://atts.w3cschool.cn/attachments/image/20200922/1600755364127867.png)

并且，值得一提的是整体上 `patchFlag` 的分为两大类：

- 当 `patchFlag` 的值**「大于」** 0 时，代表所对应的元素在 `patchVNode` 时或 `render` 时是可以被优化生成或更新的。
- 当 `patchFlag` 的值**「小于」** 0 时，代表所对应的元素在 `patchVNode` 时，是需要被 `full diff`，即进行递归遍历 `VNode tree` 的比较更新过程。

> 其实，还有两类特殊的 `flag`：`shapeFlag` 和 `slogFlag`，这里我就不对此展开，有兴趣的同学可以自行去了解。

### Compile 编译过程

#### 对比 Vue2.x 编译过程

了解过[「Vue2.x」](https://www.w3cschool.cn/vuejs2/)源码的同学，我想应该都知道在[「Vue2.x」](https://www.w3cschool.cn/vuejs2/)中的 `Compile` 过程会是这样：

- `parse` 编译模板生成原始 AST。
- `optimize` 优化原始 AST，标记 AST Element 为静态根节点或静态节点。
- `generate` 根据优化后的 AST，生成可执行代码，例如 `_c`、`_l` 之类的。

![对比 Vue2.x 编译过程](https://atts.w3cschool.cn/attachments/image/20200922/1600755393238571.png)

而在「Vue3」中，整体的 `Compile` 过程仍然是三个阶段，但是不同于「Vue2.x」的是，第二个阶段换成了正常编译器都会存在的阶段 `transform`。所以，它看起来会是这样：

![对比 Vue2.x 编译过程](https://atts.w3cschool.cn/attachments/image/20200922/1600755408986063.png)

在源码中，它对应的伪代码会是这样：

```
export function baseCompile(
  template: string | RootNode,
  options: CompilerOptions = {}
): CodegenResult {
  ...
  const ast = isString(template) ? baseParse(template, options) : template
  ...
  transform(
    ast,
    extend({}, options, {....})
  )


  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  )
}
```

那么，我想这个时候大家可能会问为什么会是 `transform`？它的职责是什么？

通过简单的对比[「Vue2.x」](https://www.w3cschool.cn/vuejs2/)编译过程的第二阶段的 `optimize`，很明显，`transform`并不是**「无米之炊」**，它仍然有着**「优化」**原始 AST 的作用，而具体职责会表现在：

- 对所有 AST Element 新增 `codegen` 属性来帮助 `generate` 更准确地生成**「最优」**的可执行代码。
- 对静态 AST Element 新增 `hoists` 属性来实现静态节点的**「单独创建」**。
- ...

此外，`transform` 还标识了诸如 `isBlock`、`helpers` 等属性，来生成最优的可执行代码，这里我们就不细谈，有兴趣的同学可以自行了解。

#### baseParse 构建原始抽象语法树（AST）

`baseParse` 顾名思义起着**「解析」**的作用，它的表现和[「Vue2.x」](https://www.w3cschool.cn/vuejs2/)的 `parse` 相同，都是解析模板 `tempalte` 生成**「原始 AST」**。

假设，此时我们有一个这样的模板 `template`：

```
<div><div>hi vue3</div><div>{{msg}}</div></div>
```

那么，它在经过 `baseParse` 处理后生成的 AST 看起来会是这样：

```
{
  cached: 0,
  children: [{…}],
  codegenNode: undefined,
  components: [],
  directives: [],
  helpers: [],
  hoists: [],
  imports: [],
  loc: {start: {…}, end: {…}, source: "<div><div>hi vue3</div><div>{{msg}}</div></div>"},
  temps: 0,
  type: 0
}
```

如果，了解过[「Vue2.x」](https://www.w3cschool.cn/vuejs2/)编译过程的同学应该对于上面这颗 `AST` 的大部分属性不会陌生。`AST` 的本质是通过用对象来描述「DSL」（特殊领域语言），例如：

- `children` 中存放的就是最外层 `div` 的后代。
- `loc` 则用来描述这个 AST Element 在整个字符串（`template`）中的位置信息。
- `type` 则是用于描述这个元素的类型（例如 5 为插值、2 为文本）等等。

并且，可以看到的是不同于「Vue2.x」的 AST，这里我们多了诸如 `helpers`、`codegenNode`、`hoists` 等属性。而，这些属性会在 `transform` 阶段进行相应地赋值，进而帮助 `generate` 阶段生成**「更优的」**可执行代码。

#### transform 优化原始抽象语法树（AST）

对于 `transform` 阶段，如果了解过**「编译器」**的工作流程的同学应该知道，一个完整的编译器的工作流程会是这样：

- 首先，`parse` 解析原始代码字符串，生成抽象语法树 AST。
- 其次，`transform` 转化抽象语法树，让它变成更贴近目标「DSL」的结构。
- 最后，`codegen` 根据转化后的抽象语法树生成目标「DSL」的可执行代码。

而在「Vue3」采用 `Monorepo` 的方式管理项目后，`compile` 对应的能力就是一个编译器。所以，`transform` 也是整个编译过程的重中之重。换句话说，如果没有 `transform` 对 **AST** 做诸多层面的转化，「Vue」仍然会挂在 `diff` 这个**「饱受诟病」**的过程。

> 相比之下，「Vue2.x」的编译阶段没有完整的 `transform`，只是 `optimize` 优化了一下 AST，可以想象在「Vue」设计之初尤大也没想到它以后会**「这么地流行」**！

那么，我们来看看 `transform` 函数源码中的定义：

```
function transform(root: RootNode, options: TransformOptions) {
  const context = createTransformContext(root, options)
  traverseNode(root, context)
  if (options.hoistStatic) {
    hoistStatic(root, context)
  }
  if (!options.ssr) {
    createRootCodegen(root, context)
  }
  // finalize meta information
  root.helpers = [...context.helpers]
  root.components = [...context.components]
  root.directives = [...context.directives]
  root.imports = [...context.imports]
  root.hoists = context.hoists
  root.temps = context.temps
  root.cached = context.cached
}
```

可以说，`transform` 函数做了什么，在它的定义中是**「一览无余」**。这里我们提一下它对静态提升其决定性作用的两件事：

- 将原始 AST 中的静态节点对应的 AST Element 赋值给根 AST 的 `hoists` 属性。
- 获取原始 AST 需要的 helpers 对应的键名，用于 `generate` 阶段的生成可执行代码的获取对应函数，例如 `createTextVNode`、`createStaticVNode`、`renderList` 等等。

并且，在 `traverseNode` 函数中会对 AST Element 应用具体的 `transform` 函数，大致可以分为两类：

- 静态节点 `transform` 应用，即节点不含有插值、指令、props、动态样式的绑定等。
- 动态节点 `transform` 应用，即节点含有插值、指令、props、动态样式的绑定等。

那么，我们就来看看对于静态节点 `transform` 是如何应用的？

##### 静态节点 `transform` 应用

这里，对于上面我们说到的这个栗子，静态节点就是这个部分：

```
<div>hi vue3</div>
```

而它在没有进行 `transform` 应用之前，它对应的 AST 会是这样：

```
{
  children: [{
    content: "hi vue3"
    loc: {start: {…}, end: {…}, source: "hi vue3"}
    type: 2
  }],
  codegenNode: undefined,
  isSelfClosing: false,
  loc: {start: {…}, end: {…}, source: "<div>hi vue3</div>"},
  ns: 0,
  props: [],
  tag: "div",
  tagType: 0,
  type: 1
}
```

可以看出，此时它的 `codegenNode` 是 `undefined`。而在源码中各类 `transform`函数被定义为 `plugin`，它会根据 `baseParse` 生成的 AST **「递归应用」**对应的 `plugin`。然后，创建对应 AST Element 的 `codegen` 对象。

所以，此时我们会命中 `transformElement` 和 `transformText` 两个 `plugin`的逻辑。

**「transformText」**

`transformText` 顾名思义，它和**「文本」**相关。很显然，此时的 AST Element 所属的类型就是 `Text`。那么，我们先来看一下 `transformText` 函数对应的伪代码：

```
export const transformText: NodeTransform = (node, context) => {
  if (
    node.type === NodeTypes.ROOT ||
    node.type === NodeTypes.ELEMENT ||
    node.type === NodeTypes.FOR ||
    node.type === NodeTypes.IF_BRANCH
  ) {
    return () => {
      const children = node.children
      let currentContainer: CompoundExpressionNode | undefined = undefined
      let hasText = false


      for (let i = 0; i < children.length; i++) { // {1}
        const child = children[i]
        if (isText(child)) {
          hasText = true
          ...
        }
      }
      if (
        !hasText ||
        (children.length === 1 &&
          (node.type === NodeTypes.ROOT ||
            (node.type === NodeTypes.ELEMENT &&
              node.tagType === ElementTypes.ELEMENT)))
      ) { // {2}
        return
      }
      ...
    }
  }
}
```

可以看到，这里我们会命中 **「{2}」** 的逻辑，即如果对于**「节点含有单一文本」** `transformText` 并不需要进行额外的处理，即该节点仍然在这里仍然保留和「Vue2.x」版本一样的处理方式。

而 `transfromText` 真正发挥作用的场景是当模板中存在这样的情况:

```
<div>ab {a} {b}</div>
```

此时 `transformText` 需要将两者放在一个**「单独的」** AST Element 下，在源码中它被称为「Compound Expression」，即**「组合的表达式」**。这种组合的目的是为了 `patchVNode` 这类 `VNode` 时做到**「更好地定位和实现 `DOM` 的更新」**。反之，如果是一个文本节点和插值动态节点的话，在 `patchVNode` 阶段同样的操作需要进行两次，例如对于同一个 `DOM` 节点操作两次。

**「transformElement」**

`transformElement` 是一个所有 AST Element 都会被执行的一个 `plugin`，它的核心是为 AST Element 生成最基础的 `codegen` 属性。例如标识出对应 `patchFlag`，从而为生成 `VNode` 提供依据，例如 `dynamicChildren`。

而对于静态节点，同样是起到一个初始化它的 `codegenNode` 属性的作用。并且，从上面介绍的 `patchFlag` 的类型，我们可以知道它的 `patchFlag` 为默认值 `0`。所以，它的 `codegenNode` 属性值看起来会是这样：

```
{
  children: {
    content: "hi vue3"
    loc: {start: {…}, end: {…}, source: "hi vue3"}
    type: 2
  },
  directives: undefined,
  disableTracking: false,
  dynamicProps: undefined,
  isBlock: false,
  loc: {start: {…}, end: {…}, source: "<div>hi vue3</div>"},
  patchFlag: undefined,
  props: undefined,
  tag: ""div"",
  type: 13
}
```

#### generate 生成可执行代码

`generate` 是 `compile` 阶段的最后一步，它的作用是将 `transform` 转换后的 AST 生成对应的**「可执行代码」**，从而在之后 Runtime 的 Render 阶段时，就可以通过可执行代码生成对应的 VNode Tree，然后最终映射为真实的 DOM Tree 在页面上。

同样地，这一阶段在「Vue2.x」也是由 `generate` 函数完成，它会生成是诸如 `_l`、`_c` 之类的函数，这本质上是对 `_createElement` 函数的封装。而相比较「Vue2.x」版本的 `generate`，「Vue3」改变了很多，其 `generate` 函数对应的伪代码会是这样：

```
export function generate(
  ast: RootNode,
  options: CodegenOptions & {
    onContextCreated?: (context: CodegenContext) => void
  } = {}
): CodegenResult {
  const context = createCodegenContext(ast, options)
  if (options.onContextCreated) options.onContextCreated(context)
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context
  ...
  genFunctionPreamble(ast, context)
  ...


  if (!ssr) {
    ...
    push(`function render(_ctx, _cache${optimizeSources}) {`)
  }
  ....


  return {
    ast,
    code: context.code,
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? (context.map as any).toJSON() : undefined
  }
}
```

所以，接下来，我们就来**「一睹」**带有静态节点对应的 AST 生成的可执行代码的过程会是怎样。

##### CodegenContext 代码生成上下文

从上面 `generate` 函数的伪代码可以看到，在函数的开始调用了 `createCodegenContext` 为当前 AST 生成了一个 `context`。在整个 `generate` 函数的执行过程**「都依托」**于一个 `CodegenContext` **「生成代码上下文」**（对象）的能力，它是通过 `createCodegenContext` 函数生成。而 `CodegenContext` 的接口定义会是这样：

```
interface CodegenContext
  extends Omit {
  source: string
  code: string
  line: number
  column: number
  offset: number
  indentLevel: number
  pure: boolean
  map?: SourceMapGenerator
  helper(key: symbol): string
  push(code: string, node?: CodegenNode): void
  indent(): void
  deindent(withoutNewLine?: boolean): void
  newline(): void
}
```

可以看到 `CodegenContext` 对象中有诸如 `push`、`indent`、`newline` 之类的方法。而它们的作用是在根据 AST 来生成代码时用来**「实现换行」**、**「添加代码」**、**「缩进」**等功能。从而，最终形成一个个可执行代码，即我们所认知的 `render` 函数，并且，它会作为 `CodegenContext` 的 `code` 属性的值返回。

下面，我们就来看下静态节点的可执行代码生成的核心，它被称为 `Preamble` 前导。

##### genFunctionPreamble 生成前准备

整个静态提升的可执行代码生成就是在 `genFunctionPreamble` 函数部分完成的。并且，大家仔细**「斟酌」**一番静态提升的字眼，静态二字我们可以不看，但是**「提升二字」**，直抒本意地表达出它（静态节点）被**「提高了」**。

为什么说是提高了？因为在源码中的体现，确实是被提高了。在前面的 `generate` 函数，我们可以看到 `genFunctionPreamble` 是先于 `render` 函数加入`context.code` 中，所以，在 Runtime 时的 Render 阶段，它会先于 `render` 函数执行。

`geneFunctionPreamble` 函数（伪代码）：

```
function genFunctionPreamble(ast: RootNode, context: CodegenContext) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName
  } = context
  ...
  const aliasHelper = (s: symbol) => `${helperNameMap[s]}: _${helperNameMap[s]}`
  if (ast.helpers.length > 0) {
    ...
    if (ast.hoists.length) {
      const staticHelpers = [
        CREATE_VNODE,
        CREATE_COMMENT,
        CREATE_TEXT,
        CREATE_STATIC
       ]
        .filter(helper => ast.helpers.includes(helper))
        .map(aliasHelper)
        .join(', ')
      push(`const { ${staticHelpers} } = _Vue\n`)
    }
  }
  ...
  genHoists(ast.hoists, context)
  newline()
  push(`return `)
}
```

可以看到，这里会对前面我们在 `transform` 函数提及的 `hoists` 属性的长度进行判断。显然，对于前面说的这个栗子，它的 `ast.hoists.length` 长度是大于 0 的。所以，这里就会根据 `hoists` 中的 AST 生成对应的可执行代码。因此，到这里，生成的可执行代码会是这样：

```
const _Vue = Vue
const { createVNode: _createVNode } = _Vue
// 静态提升部分
const _hoisted_1 = _createVNode("div", null, "hi vue3", -1 /* HOISTED */)
// render 函数会在这下面
```

#### 小结

静态节点提升在整个 `compile` 编译阶段体现，从最初的 `baseCompile` 到 `transform` 转化原始 AST、再到 `generate` 的优先 `render` 函数处理生成可执行代码，最后交给 Runtime 时的 Render 执行，这种设计可以说是非常精妙！所以，这样一来，就完成了我们经常看到在一些文章提及的「Vue3」对于静态节点在整个生命周期中它只会执行**「一次创建」**的源码实现，这在一定程度上降低了性能上的开销。

### 两者 diff 算法有什么区别？ 静态标记？

Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树。如果一个组件的 template 很大，但是动态部分比较少。因为这段代码中只有一个动态节点，所以这里有很多 diff 和遍历其实都是不需要的，这就会导致 vnode 的性能跟模版大小正相关，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。

而对于上述例子，理想状态只需要 diff 这个绑定 message 动态节点的 p 标签即可。
Vue.js 3.0 做到了，它通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破。

除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法

## 总结优点

Vue3 通过 Proxy 响应式+组件内部 vdom+静态标记，把任务颗粒度控制的足够细致，所以也不太需要 time-slice 了，就可能不太需要 react 的 fiber 这种时间切片的概念了。
