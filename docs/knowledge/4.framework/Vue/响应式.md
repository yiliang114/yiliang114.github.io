---
title: Vue 响应式
date: '2020-10-26'
draft: true
---

## 双向绑定

### 几种实现双向绑定的做法

1. backbone 发布者-订阅者模式
2. angular 脏检查
3. vue 数据劫持结合发布者-订阅者模式

## Vue 响应式

### vue 的双向绑定的原理

1. 数据劫持 / 数据代理
2. 依赖收集
3. 发布订阅模式

#### 响应式的具体步骤：

1. 需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化， 获取值会触发 getter， 进行依赖收集。
2. compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
   1. 在自身实例化时往属性订阅器 (dep) 里面添加自己
   2. 自身必须有一个 `update()` 方法
   3. 待属性变动 `dep.notify()` 通知时，能调用自身的 `update()` 方法，并触发 `Compile` 中绑定的回调，则功成身退。
4. MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。
5. 依赖的拆卸。Watch 实例中包含 2 对属性，名字分别为 depId, deps/newDepIds, newDeps。 其中 depId/newDepIds 是一个 Set 值，用来保证依赖只会被收集一次。另外每一次重新求值之后，根据新旧 Set 中的差异，会将已经不依赖的依赖删除收集的关系；在一个组件的 destroy 钩子被调用的时候，会主动执行 Watch 的拆卸函数，目的是将不再使用的依赖全部拆卸掉，避免后续不必要的计算。

```js
var data = { name: 'yiliang114' };
observe(data);
let name = data.name; // -> get value
data.name = 'yyy'; // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return;
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key]);
  });
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val);
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log('get value');
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log('change value');
      val = newVal;
    },
  });
}
```

以上代码简单的实现了如何监听数据的 `set` 和 `get` 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。

```html
<div>{{name}}</div>
```

在解析如上模板代码时，遇到 `{{name}}` 就会进行依赖收集。

接下来我们先来实现一个 `Dep` 类，用于解耦属性的依赖收集和派发更新操作。

```js
// 通过 Dep 解耦属性的依赖和更新操作
class Dep {
  constructor() {
    this.subs = [];
  }
  // 添加依赖
  addSub(sub) {
    this.subs.push(sub);
  }
  // 更新
  notify() {
    this.subs.forEach(sub => {
      sub.update();
    });
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null;
```

当需要依赖收集的时候调用 `addSub`，当需要派发更新的时候调用 `notify`。

在组件挂载时，会先对所有需要的属性调用 `Object.defineProperty()`，然后实例化 `Watcher`，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。

```js
class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this;
    this.cb = cb;
    this.obj = obj;
    this.key = key;
    this.value = obj[key];
    Dep.target = null;
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key];
    // 调用 update 方法更新 Dom
    this.cb(this.value);
  }
}
```

在执行构造函数的时候将 `Dep.target` 指向自身，从而使得收集到了对应的 `Watcher`，在派发更新的时候取出对应的 `Watcher` 然后执行 `update` 函数。

```js
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val);
  let dp = new Dep();
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value');
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target);
      }
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log('change value');
      val = newVal;
      // 执行 watcher 的 update 方法
      dp.notify();
    },
  });
}
```

以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。

Vue 无法检测到对象属性的添加或删除。Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value)方法向嵌套对象添加响应式属性。

watch 属性，都是一个 new Watcher 实例。

进行观察的时候执行 defineReactive 函数，在每一次执行的时候，都是创建一个 Dep 依赖实例， get 属性中 如果存在 Dep.target （也就是响应函数的 watcher 实例）那就执行依赖收集，这个 Dep.target 的收集是在 new Watcher 的时候，new Watcher 第二个参数是一个函数表达值，会被记录下来，表明这是当前响应式的反馈。

每一个 watcher 里面有一个依赖数组，dep.depend() 依赖收集就是往 watcher 里依赖项。当然如果添加的属性是一个对象或者数组的话，继续添加依赖，在 watcher 表达式执行完毕之前，会清理掉 Dep.target ，防止会收集到错误的依赖。 然后在属性改变的时候，就会触发 set ，set 中基本上是观察新添加的属性之外最重要的就是 dep.notify 通知操作了。这个操作就是循环收集的所有 watcher ，执行 watcher 的 update 函数， update 函数如果设置了同步执行的话，就是直接重新执行一次表达式； 但是一般情况下，会执行 queueWatcher 将当前的 watcher 推入一个事件缓冲队列 queue 中， 这是通过 nextTick 实现的， 会一次更新队列中的所有 watcher 的表达式。这样就达到了响应式的目的。(队列执行的时候，会根据 watcher.id 进行去重)

## Object.defineProperty

通过 `Object.defineProperty(obj, prop, descriptor)` 来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

1. 对象属性描述符
   1. configurable 可配置性相当于属性的总开关，只有为 true 时才能设置，而且不可逆
   2. enumerable 是否可枚举，为 false 时 for..in 以及 Object.keys()将不能枚举出该属性
2. 数据描述符
   1. value
   2. writable 是否可写，为 false 时将不能够修改属性的值
3. 存取描述符
   1. get
   2. set

#### 存在的问题

1. 不能监听数组的变化
   数组的以下几个方法不会触发 set,push、pop、shift、unshift、splice、sort、reverse

```js
let arr = [1, 2, 3];
let obj = {};
Object.defineProperty(obj, 'arr', {
  get() {
    console.log('get arr');
    return arr;
  },
  set(newVal) {
    console.log('set', newVal);
    arr = newVal;
  },
});
obj.arr.push(4); // 只会打印 get arr, 不会打印 set
obj.arr = [1, 2, 3, 4]; // 这个能正常 set
```

2. 必须遍历对象的每个属性
   使用 Object.defineProperty() 多数要配合 Object.keys() 和遍历，于是多了一层嵌套

```js
Object.keys(obj).forEach(key => {
  Object.defineProperty(obj, key, {
    // ...
  });
});
```

3. 必须深层遍历嵌套的对象
   如果嵌套对象，那就必须逐层遍历，直到把每个对象的每个属性都调用 Object.defineProperty() 为止。 Vue 的源码中就能找到这样的逻辑 (叫做 walk 方法)。

### Object.defineProperty 的缺陷

1. Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
2. 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
3. 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。
4. Proxy 可以劫持整个对象，并返回一个新的对象。Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 `Object.defineProperty` 不能拦截到这些操作，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。

对于第一个问题，Vue 提供了一个 API 解决

```js
export function set(target, key, val) {
  // 判断是否为数组且下标是否有效
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 调用 splice 函数触发派发更新
    // 该函数已被重写
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  // 判断 key 是否已经存在
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  const ob = target.__ob__;
  // 如果对象不是响应式对象，就赋值返回
  if (!ob) {
    target[key] = val;
    return val;
  }
  // 进行双向绑定
  defineReactive(ob.value, key, val);
  // 手动派发更新
  ob.dep.notify();
  return val;
}
```

Vue 重写方法来对数组的劫持实现派发更新。 例如 push、pop、splice 等方法。对于这些变异方法 vue 做了包裹，在原型上进行了拦截，调用原生的数组方法后，还会执行发布和变更的操作来触发视图的更新。

```js
// 获得数组原型
const arrayProto = Array.prototype;
export const arrayMethods = Object.create(arrayProto);
// 重写以下函数
const methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
methodsToPatch.forEach(function(method) {
  // 缓存原生函数
  const original = arrayProto[method];
  // 重写函数
  def(arrayMethods, method, function mutator(...args) {
    // 先调用原生函数获得结果
    const result = original.apply(this, args);
    const ob = this.__ob__;
    let inserted;
    // 调用以下几个函数时，监听新数据
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    // 手动派发更新
    ob.dep.notify();
    return result;
  });
});
```

## 其他

### 实现 a === 1 && a === 2 && a === 3) === true

可以采用数据劫持来实现

```js
let current = 0;
Object.defineProperty(window, 'a', {
  get() {
    current++;
    return current;
  },
});
console.log(a === 1 && a === 2 && a === 3); // true
```

#### 几种实现双向绑定的做法

- 发布者-订阅者模式（backbone.js）
- 脏检查 (angular.js)
- 数据劫持（vue.js） 是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

##### Object.defineProperty

属性描述符包括：configurable(可配置性相当于属性的总开关，只有为 true 时才能设置，而且不可逆)、Writable(是否可写，为 false 时将不能够修改属性的值)、Enumerable(是否可枚举，为 false 时 for..in 以及 Object.keys()将不能枚举出该属性)、get(一个给属性提供 getter 的方法)、set(一个给属性提供 setter 的方法)

```js
var o = { name: 'vue' };
Object.defineProperty(o, 'age', {
  value: 3,
  writable: true, //可以修改属性a的值
  enumerable: true, //能够在for..in或者Object.keys()中枚举
  configurable: true, //可以配置
});
```

#### Vue 的响应式

1. 需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
2. compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
   1. 在自身实例化时往属性订阅器(dep)里面添加自己
   2. 自身必须有一个 update()方法
   3. 待属性变动 dep.notify()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。
4. MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。

#### 计算属性是如何做到属性值改变才重新计算（缓存）

1. 初始化 props 和 data， 使用 `Object.defineProperty` 把这些属性全部转为 `getter/setter`。
2. 初始化 `computed`, 遍历 `computed` 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。
3. `Object.defineProperty getter` 依赖收集。用于依赖发生变化时，触发属性重新计算。
4. 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集
