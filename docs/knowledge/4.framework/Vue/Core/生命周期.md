---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 生命周期

生命周期钩子函数就是每个 Vue 实例在被创建、更新时都要经过一系列的初始化过程会触发的钩子函数。

![](https://cn.vuejs.org/images/lifecycle.png)

在初始化时，会调用以下代码，生命周期就是通过 `callHook` 调用的

```js
Vue.prototype._init = function(options) {
  // 初始化生命周期函数
  initLifeCycle(vm);
  // 事件
  initEvents(vm);
  // 渲染函数
  initRender(vm);
  // 执行 beforeCreate 钩子
  callHook(vm, 'beforeCreate'); // 拿不到 props data
  // 初始化 inject
  initInjections(vm);
  // 初始化 props data 之类的值
  initState(vm);
  // 初始化 provide
  initProvide(vm);
  // 执行 created 钩子。 此时已经可以拿到 props data 了
  callHook(vm, 'created');
};
```

可以发现在以上代码中，`beforeCreate` 调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 `initState` 中。

接下来会执行挂载函数

```js
export function mountComponent {
  // 挂载节点之前的钩子
    callHook(vm, 'beforeMount')
    // ...
    if (vm.$vnode == null) {
        vm._isMounted = true
        // 挂载节点完毕钩子
        callHook(vm, 'mounted')
    }
}
```

`beforeMount` 就是在挂载前执行的，然后开始创建 VDOM 并替换成真实 DOM，最后执行 `mounted` 钩子。这里会有个判断逻辑，如果是外部 `new Vue({})` 的话，不会存在 `$vnode` ，所以直接执行 `mounted` 钩子了。如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。

接下来是数据更新时会调用的钩子函数

```js
function flushSchedulerQueue() {
  // ...
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before(); // 调用 beforeUpdate
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' +
            (watcher.user ? `in watcher with expression "${watcher.expression}"` : `in a component render function.`),
          watcher.vm,
        );
        break;
      }
    }
  }
  callUpdatedHooks(updatedQueue);
}

function callUpdatedHooks(queue) {
  let i = queue.length;
  while (i--) {
    const watcher = queue[i];
    const vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}
```

上图还有两个生命周期没有说，分别为 `activated` 和 `deactivated` ，这两个钩子函数是 `keep-alive` 组件独有的。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `activated` 钩子函数。

最后就是销毁组件的钩子函数了

```js
Vue.prototype.$destroy = function() {
  // ...
  callHook(vm, 'beforeDestroy');
  vm._isBeingDestroyed = true;
  // remove self from parent
  const parent = vm.$parent;
  if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
    remove(parent.$children, vm);
  }
  // teardown watchers
  if (vm._watcher) {
    vm._watcher.teardown();
  }
  let i = vm._watchers.length;
  while (i--) {
    vm._watchers[i].teardown();
  }
  // remove reference from data ob
  // frozen object may not have observer.
  if (vm._data.__ob__) {
    vm._data.__ob__.vmCount--;
  }
  // call the last hook...
  vm._isDestroyed = true;
  // invoke destroy hooks on current rendered tree
  vm.__patch__(vm._vnode, null);
  // fire destroyed hook
  callHook(vm, 'destroyed');
  // turn off all instance listeners.
  vm.$off();
  // remove __vue__ reference
  if (vm.$el) {
    vm.$el.__vue__ = null;
  }
  // release circular reference (#6759)
  if (vm.$vnode) {
    vm.$vnode.parent = null;
  }
};
```

在执行销毁操作前会调用 `beforeDestroy` 钩子函数，然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 `destroyed` 钩子函数。

### Vue 的生命周期

Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、销毁等一系列过程，称之为 Vue 的生命周期。

总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。

- beforeCreate（创建前） 在数据观测和初始化事件还未开始
- created（创建后） 完成数据观测，属性和方法的运算，初始化事件，\$el 属性还没有显示出来
- beforeMount（载入前） 在挂载开始之前被调用，相关的 render 函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html。注意此时还没有挂载 html 到页面上。
- mounted（载入后） 在 el 被新创建的 vm.\$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。
- beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
- updated（更新后） 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
- beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。
- destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

### 生命周期钩子函数

在 `beforeCreate` 钩子函数调用的时候，是获取不到 `props` 或者 `data` 中的数据的，因为这些数据的初始化都在 `initState` 中。

然后会执行 `created` 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。

接下来会先执行 `beforeMount` 钩子函数，开始创建 VDOM，最后执行 `mounted` 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。

接下来是数据更新时会调用的钩子函数 `beforeUpdate` 和 `updated`，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。

另外还有 `keep-alive` 独有的生命周期，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `actived` 钩子函数。

最后就是销毁组件的钩子函数 `beforeDestroy` 和 `destroyed`。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 `destroyed` 钩子函数。

### 请详细说下你对 vue 生命周期的理解

> 总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后

- 创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。在 created 阶段，vue 实例的数据对象 data 有了，el 还没有
- 载入前/后：在 beforeMount 阶段，vue 实例的\$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。
- 更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法
- 销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在

### 生命周期函数, 说一说生命周期函数，以及都做了一些什么东西

- 父子节点，谁先创建，谁先挂载？
  父组件先 created 后 mounted
  子组件后 created 先 mounted
- 需要注意的是，mounted 钩子函数是将 vdom 形成真实的 dom 节点并挂载到父组件上去。所以在一个组件 mounted 钩子函数之前，都不能获取真实的 dom 节点，比如 `document.querySelector(".content")` 或者 `getELementById` ，包括 `this.$el` 也是。(本来以为 `this.$el` 是会有的，结果也是 null， 需要继续去看一下 `this.$el` 是什么时候挂载的)。啊， 到底是什么时候形成 dom 树的 ？
- 为什么在 child 的 mounted 钩子中，只能能够获取到 parent 的 dom 了？

#### vue 生命周期的作用是什么？

它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。

#### 第一次页面加载会触发哪几个钩子？

会触发下面这几个 beforeCreate, created, beforeMount, mounted 。

DOM 渲染在 mounted 中就已经完成了。

### created 钩子中获取 dom ？

不能够直接获取 dom 因为 dom 够没有挂载，document.getElementById 之类的方法都不一定会生效。

### 生命周期函数执行顺序

vue 父子组件的生命周期函数执行顺序 与 使用 router-link 的父子组件的生命周期函数执行顺序不一致！
![](http://media.zhijianzhang.cn//file/2018/11/9577028a77ac411ebbee0ec2b99a834e_image.png)
![](http://media.zhijianzhang.cn//file/2018/11/38defa803e1a49f59ce4eb758a7ec94f_image.png)
Promise 不会阻碍其他的任务执行。

### await created 为什么没有同步执行

async 只能保证函数内部存在的 await 语法函数能够同步执行，但是并不能保证整个 created 函数执行完了之后才会执行后面的操作。

### vue created 和 mounted 的异同。

<!-- TODO: -->

很多人会觉得，异步请求函数放在 created 钩子中会比放在 mounted 钩子中页面加载速度更快，其实这是没有事实依据的。created 钩子函数的执行标志着事件循环系统、初始化 props,data 、渲染函数的初始化等工作的完成，但是还没有开始真正的渲染节点 ？？？ 而 mounted 钩子的执行标志着节点的渲染已经结束，并且已经挂载节点到 dom 上去了，此时获取 dom 节点是可以获取到的，反之在 mounted 之前的钩子函数中都是获取不到的。

### Vue 的父组件和子组件生命周期钩子执行顺序是什么

父组建： beforeCreate -> created -> beforeMount
子组件： -> beforeCreate -> created -> beforeMount -> mounted
父组件： -> mounted
总结：从外到内，再从内到外

### 组件 keep-alive 的时候又是什么道理？

直接将组件缓存在了内存中，而没有直接走入销毁阶段。
