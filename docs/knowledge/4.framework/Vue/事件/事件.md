---
title: vue 事件
date: '2020-10-26'
draft: true
---

## 基础事件

### 事件冒泡

原生的事件可以冒泡，比如 click 事件，如果不主动进行 stop 的话，就会一直往上传。但是貌似自定义事件，并不会冒泡。自定义事件的冒泡和广播的问题，很早就被官方废弃了，主要是因为事件传递的规则让人比较难以琢磨，多层级之间传数据的问题，可以使用 vuex 很好的解决。 父子组件传参的话，可以使用 emit 很好解决。 但是实际上 element 中又实现了已经废弃的 dispatch 和 broadcast api ， 这在组件封装的时候，能够很好地处理数据流。

https://www.cnblogs.com/xxcanghai/p/Vue-kuang-jiaElement-de-shi-jian-chuan-dibroadcast.html
https://www.cnblogs.com/xxcanghai/p/Vue-kuang-jiaElement-de-shi-jian-chuan-dibroadcast.html

### 取消冒泡事件

```html
<!-- 只需将 click 改成 click.stop -->
<p @click.stop="getEventTar($event)">Test</p>
```

### 阻止默认事件

```html
<!-- 只需将click改成click.prevent -->
<p @click.prevent="getEventTar($event)">Test</p>
```

### emit

```js
this.$emit('input', val);
```

### 解决 vue 的 enter 和 blur 触发两次的问题

如果没有绑定 blur 事件也可以，会触发默认的 input blur 事件即失去焦点

```html
<input @blur="handleEditConfirm(c.type_id, c.description)" @keyup.enter="$event.target.blur" />
```

### vue @click.native 与 @click 意思就是当你给一个 vue 组件绑定事件时候，要加上 native！如果是普通的 html 元素！就不需要

### @click @click.native @on-click 好像是 qcvue 的事件不是 vue 的。 事件的修饰符是符合进行处理的。

### 解释 vue input 的 input change 事件， keydown keyup focus bulr 事件等等

### vue 是如何实现绑定事件的 ?

### vue 的 `$event` 与普通的点击事件， 按钮事件有什么不同？

### vue 的 @ 语法糖 @ 会默认为是 on 开头的事件。。 比如 on-change on-enter 等

### event bus

https://juejin.im/post/5ac2fb886fb9a028b86e328c

### emit bug

好像在 data 函数中直接 emit 的事件，不会再 devtools 中显示出来。

### 事件类型

```js
// .sync
this.$emit('update:value', this.visible);
// 普通 change 事件
this.$emit('change', this.visible);
```

## 异步更新队列

### Vue 的数据为什么频繁变化但只会更新一次

Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。

另外，关于 waiting 变量，这是很重要的一个标志位，它保证 flushSchedulerQueue 回调（\$nextTick 中执行）允许被置入 callbacks 一次。
因为 Vue 的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先会去等待所有的同步代码执行完成之后再去一次更新。这样的性能优势很明显，比如：

现在有这样的一种情况，mounted 的时候 test 的值会被循环执行++1000 次。 每次++时，都会根据响应式触发 setter->Dep->Watcher->update->run。 如果这时候没有异步更新视图，那么每次++都会直接操作 DOM 更新视图，这是非常消耗性能的。 所以 Vue 实现了一个 queue 队列，在下一个 tick（或者是当前 tick 的微任务阶段）统一执行 queue 中 Watcher 的 run。同时，拥有相同 id 的 Watcher 不会被重复加入到该 queue 中去，所以不会执行 1000 次 Watcher 的 run。最终更新视图只会直接将 test 对的 DOM 的 0 变成 1000。 保证更新视图操作 DOM 的动作是在当前栈执行完以后下一个 tick（或者是当前 tick 的微任务阶段）的时候调用，大大优化了性能。
执行顺序 update -> queueWatcher -> 维护观察者队列（重复 id 的 Watcher 处理） -> waiting 标志位处理（保证需要更新 DOM 或者 Watcher 视图更新的方法 flushSchedulerQueue 只会被推入异步执行的$nextTick 回调数组一次） -> 处理\$nextTick（在为微任务或者宏任务中异步更新 DOM）->

Vue 是异步更新 Dom 的，Dom 的更新放在下一个宏任务或者当前宏任务的末尾（微任务）中进行执行

由于 VUE 的数据驱动视图更新是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在同一事件循环中的数据变化后，DOM 完成更新，立即执行 nextTick(callback)内的回调。
vue 和 react 一样，对 dom 的修改都是异步的。它会在队列里记录你对 dom 的操作并进行 diff 操作，后一个操作会覆盖前一个，然后更新 dom。

### 异步更新队列

vue 更新 dom 时是异步执行的。数据变化、更新是在主线程中同步执行的；在侦听到数据变化时，watcher 将数据变更存储到异步队列中，当本次数据变化，即主线成任务执行完毕，异步队列中的任务才会被执行（已去重）。

宏事件

- setImmediate
- MessageChannel
- setTimeout
  微事件
- promise

顺序是， promise => setImmediate => MessageChannel => setTimeout

#### 观察对象和观察数组的区别

数组的 api 需要去重写。所以数组一般通过扩展重新赋值，或者使用这些覆盖的 api 变化的时候才可以被更新，否则的话不更新，比如通过下标直接进行更改。

### Vue 的更新机制

有一个的事件队列推入，多次推入，会多次更新。 如果在一个作用域中，同时修改一个值，这样会被合成一个更新，推入事件队列中。

上面提到, vue 的更新是 model 中数据的变化引发在初始化时注入的 watcher 的变化,从而引起 view 层的更新.只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。

根据以上特点,我们知道 vue 中的组件更新是有 model 数据的更新引起的,因为 view 和 model 在初始化时已经完成绑定,所以当 model 发生变化时,哪些 view 需要变化已经很明确了,所以就不需要像 React 那般去判断比对了。
