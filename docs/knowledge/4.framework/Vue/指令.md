---
title: 指令
date: '2020-10-26'
draft: true
---

### v-show 与 v-if 区别

`v-show` 只是在 `display: none` 和 `display: block` 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 `v-show` 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。

### Vue 的 v-for 为什么需要添加 key 属性

为什么 key 不能使用 index 而一定要用一个唯一不变的值？
尽量用 id。 如果使用 index 的话，往数组的末尾添加元素的话问题不大，但是往数组的首位添加元素的话，就会有问题了。 原本 key 值为 0 的 item
value 变了，导致组件重新渲染； key 为 1 ， 2， 3， 4 ... 等也是如此，那就相当于说所有的 item 都重新更新了一遍，哪怕其他 item 没有任何变化。
优化的点：

1. 将所有拥有 id 的 v-for 循环 key 都更换成 id
2. 没有 id 的循环，例如 字符串数组，当然如果字符串元素不会重复的话也无妨，如果会重复的话，最好再加上一个出现次数，那么就能够保证所有的 key 都是唯一的。

### key 的作用是什么？

key 是给每一个 vnode 的唯一 id,可以`依靠key`,更`准确`, 更`快`的拿到 oldVnode 中对应的 vnode 节点。

#### 1. 更准确

因为带 key 就不是`就地复用`了，在 sameNode 函数 `a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。

#### 2. 更快

利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map 会比遍历更快。)

#### 完整

能提高 diff 效率其实是不准确的。

见[vue/patch.js](https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L424)，在不带 key 的情况下，判断[sameVnode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L35)时因为 a.key 和 b.key 都是 undefined，**对于列表渲染**来说已经可以判断为相同节点然后调用 patchVnode 了，实际根本不会进入到答主给的 else 代码，也就无从谈起“带 key 比不带 key 时 diff 算法更高效”了。

然后，官网推荐推荐的使用 key，应该理解为“使用唯一 id 作为 key”。因为 index 作为 key，和不带 key 的效果是一样的。index 作为 key 时，每个列表项的 index 在变更前后也是一样的，都是直接判断为 sameVnode 然后复用。

说到底，key 的作用就是更新组件时**判断两个节点是否相同**。相同就复用，不相同就删除旧的创建新的。

正是因为带唯一 key 时每次更新都不能找到可复用的节点，不但要销毁和创建 vnode，在 DOM 里添加移除节点对性能的影响更大。所以会才说“不带 key 可能性能更好”。看下面这个实验，渲染 10w 列表项，带唯一 key 与不带 key 的时间对比：

不使用 key 的情况：

```html
<li v-for="item in list">{{ item.text }}</li>
```

[![image](https://user-images.githubusercontent.com/23716085/53108518-22543a80-3572-11e9-83b2-16b4aab7cdb9.png)](https://user-images.githubusercontent.com/23716085/53108518-22543a80-3572-11e9-83b2-16b4aab7cdb9.png)

使用 id 作为 key 的情况：

```html
<li v-for="item in list" :key="item.id">{{ n.text }}</li>
```

[![image](https://user-images.githubusercontent.com/23716085/53108768-88d95880-3572-11e9-9f29-0082bf89eb3a.png)](https://user-images.githubusercontent.com/23716085/53108768-88d95880-3572-11e9-9f29-0082bf89eb3a.png)

list 构造：

```js
const list1 = [];
const list2 = [];
for (let i = 0; i <= 100000; i++) {
  list1.push({
    id: i,
    text: i,
  });
  list2.push({
    id: i * 2,
    name: 100000 - i,
  });
}
```

因为不带 key 时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改 DOM 文本内容而不是移除/添加节点，这就是文档中所说的“刻意依赖默认行为以获取性能上的提升”。

既然如此，为什么还要建议带 key 呢？因为这种模式只适用于渲染简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。

举个例子：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过 tab 切换“娱乐新闻”或是“社会新闻”。

不带 key 属性的情况下，在“娱乐新闻”下选中第二项然后切换到“社会新闻”，"社会新闻"里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上新闻 id 作为唯一 key，那么每次渲染列表时都会完全替换所有组件，使其拥有正确状态。

这只是个简单的例子，实际应用会更复杂。带上唯一 key 虽然会增加开销，但是对于用户来说基本感受不到差距，而且能保证组件状态正确，这应该就是为什么推荐使用唯一 id 作为 key 的原因。至于具体怎么使用，就要根据实际情况来选择了。

### vue 中的 v-html 中会导致的 xss

https://github.com/lynnic26/LynnNote/issues/1

解决办法？ vue 为什么会去做这一层转义？

### Vue 的 v-html 指令，为什么 xss 没有生效

### v-html 的缺点 ？

### v-html 与 {{}} 同时使用的话会显示哪一个？为什么

会显示 {{}} 中设置的值，具体原理应该是跟模板编译有关系的。

### directive 执行是什么原理

### vue watch 不生效

watch 生命周期函数是什么时候初始化的，如果通过 props 传值的时候，子组件已经拿到了值(已经不是 undefined 了)。 那么在注册 watch 的时候， 就不会被触发了。

props 值代理到子组件的 this 上，应该在子组件的 created 函数之前。

### 自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数

- 全局定义指令：在 vue 对象的 directive 方法里面有两个参数, 一个是指令名称, 另一个是函数。
- 组件内定义指令：directives
- 钩子函数: bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新)
- 钩子函数参数： el、binding

### Vue input focus

https://segmentfault.com/q/1010000009861687
中文输入法回车的时候，会触发 input 的回车事件的解决办法：
https://segmentfault.com/q/1010000004348896/a-1020000004352130

```html
<input
  :disabled="working"
  type="text"
  ref="createRobotInput"
  class="tc-15-input-text xl"
  v-model="robotName"
  @input="checkRobotName"
  @keyup.enter="enterHandle('keyup')"
  @keydown.enter="enterHandle('keydown')"
/>
```

```js
enterHandle(target) {
  // 解决中文输入法时按回车会触发 input 的回车事件的问题
  if (target === "keydown") {
    this.oldRobotName = this.robotName;
  } else if (this.oldRobotName === this.robotName) {
    this.createRobotHandle();
  }
}
```

### vue 常用的修饰符？

.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用

### vue 的 sync 的原理

通过在子组件中 `this.$emit(update:target, value);` 在父组件中 `<SlotInputMain :SlotName.sync="SlotNameTest" />` 这样的形式，父组件就能够监听到子组件中的值。至于父组件中需要触发 input 事件还是 onchange 事件，全看子组件中触发 emit 的时机。

### .native 事件

### 自定义指令

`oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。

### 其他自定义指令

#### vue-click-outside

https://github.com/ndelvalle/v-click-outside

https://github.com/xunleif2e/vue-clickout
