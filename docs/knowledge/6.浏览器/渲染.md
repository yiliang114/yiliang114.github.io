---
title: '渲染'
date: 2020-10-25
draft: true
---

## 渲染过程

从 HTTP 请求回来 ，产生流式的数据，DOM 的构建、CSS 计算、渲染、绘制，都是尽可能的流式处理前一步的产出，不需要等待上一步完全接受才开始处理，所以我们在浏览网页的时候，才会逐步出现页面

浏览器的工作流程大致就是：构建 DOM 树-构建 CSSOM-构建渲染树-布局-绘制

1. 根据 HTML 结构生成 DOM 树
2. 根据 CSS 生成 CSSOM
3. 将 `DOM` 与 `CSSOM` 合并成一个渲染树。
4. 根据渲染树来布局，计算每个节点的位置。渲染和展示。
5. 遇到 `<script>` 时，会执行并阻塞渲染

DOM 树 和 渲染树 的区别：

- DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素
- 渲染树不包括 head 和隐藏元素，每一个节点都有对应的 css 属性

## 重绘和回流

重绘：当渲染树中的元素**外观**（如：颜色）发生改变，不影响布局时，产生重绘。一般都是修改元素的属性
回流：当渲染树中的元素的**布局**（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流

引起 Repaint 和 Reflow 的一些操作：

- 调整窗口大小
- 字体大小
- 样式表变动
- 元素内容变化，尤其是输入控件
- CSS 伪类激活，在用户交互过程中发生
- DOM 操作，DOM 元素增删、修改
- width, clientWidth, scrollTop 等布局宽高的计算

回流必将引起重绘，而重绘不一定会引起回流。

另外，在写代码的时候要避免回流和重绘：

一些属性的读取也会引起回流，比如 JS 获取 Layout 属性值（如：offsetLeft、scrollTop、getComputedStyle 等），也会引起回流。因为浏览器需要通过回流计算最新值。

### 如何最小化重绘(repaint)和回流(reflow)？

- 使用 `visibility` 替换`display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 需要要对 DOM 元素进行复杂的操作时，可以先隐藏(display:"none")，操作完成后再显示。避免频繁操作 DOM。创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后添加到文档里。设置 display:none 的元素上操作，最后显示出来。
- 需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document，或使用字符串拼接方式构建好对应 HTML 后再使用 innerHTML 来修改页面
- 避免频繁读取元素几何属性（例如 scrollTop）。绝对定位具有复杂动画的元素。
- 缓存 Layout 属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流
- 不要使用 `table` 布局，可能很小的一个小改动会造成整个 table 的重新布局。避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）
- 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color
- 避免逐条更改样式。建议集中修改样式，例如操作 className。批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx

## 其他

假设某个组织下面挂了 10 w 个节点，如何做优化处理？
