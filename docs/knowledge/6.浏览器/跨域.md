---
title: 跨域
date: '2020-10-26'
draft: true
---

## 跨域

因为浏览器出于安全考虑（CSRF），有同源策略。域名、协议或者端口有一个不同就是跨域，浏览器请求资源会失败。

限制范围

- `Cookie`、`LocalStorage`和`IndexDB`无法获取。
- 无法获取和操作`DOM`。
- 不能发送`ajax`请求。我们要注意，`ajax`只适合**同源**的通信。

### 出于什么安全考虑才会引入跨域

主要是用来防止 CSRF 攻击的。CSRF 攻击是利用用户的登录态发起恶意请求。没有同源策略的情况下，A 网站可以被任意其他来源的 ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。

### 跨域通信的几种方式

1. `JSONP`
2. `WebSocket`
3. `CORS`
4. `Hash`
5. `postMessage`
6. 通过修改 `document.domain` 来跨子域
7. 使用 `window.name` 来进行跨域

#### JSONP 原理

JSONP = JSON + Padding. 原理很简单，因为 `<script>` 标签没有跨域限制。JSONP 使用简单且兼容性不错，但是只限于 `get` 请求。前端需要常见一个回调函数，拼接到动态创建的 `script` 标签的 query 中，服务端接收到请求之后将数据填充到回调函数中。

#### CORS

服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
如果浏览器检测到相应的设置，就可以允许`ajax`进行跨域的访问

- `CORS`需要浏览器和后端同时支持
- 浏览器会自动进行 `CORS` 通信，实现 CORS 通信的关键是后端。只要后端实现了 `CORS`，就实现了跨域。
- 服务端设置 `Access-Control-Allow-Origin` 就可以开启 `CORS`。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

后台响应 options 请求类型

```shell
location ~/cgi {
    if ($request_method = 'OPTIONS' ) {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header Access-Control-Allow-Methods "GET, OPTIONS, POST";
        add_header 'Access-Control-Allow-Credentials' "true";
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range';
        #add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain charset=UTF-8';
        add_header 'Content-Length' 0;
        return 204;
    }
    proxy_pass   http://127.0.0.1:80;
    add_header Access-Control-Allow-Origin '*';
    add_header 'Access-Control-Allow-Credentials' "true";
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
}
```

##### 简单请求

以 ajax 为例，当满足以下条件时，会触发简单请求

1. 使用下列方法之一：
   - `GET`
   - `HEAD`
   - `POST`
2. `Content-Type` 的值仅限于下列三者之一：
   - `text/plain`
   - `multipart/form-data`
   - `application/x-www-form-urlencoded`

请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器； `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。

##### 复杂请求

对于复杂请求来说，首先会发起一个预检请求，该请求是 `option` 方法的，通过该请求来知道服务端是否允许跨域请求。对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑。

以下以 express 框架举例：

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS');
  res.header(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials',
  );
  next();
});
```

该请求会验证你的 `Authorization` 字段，没有的话就会报错。

当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 `next` 方法，因为预检请求并不包含 `Authorization` 字段，所以服务端会报错。

想解决这个问题很简单，只需要在回调中过滤 `option` 方法即可

```js
res.statusCode = 204;
res.setHeader('Content-Length', '0');
res.end();
```

##### options

OPTIONS 方法比较少见，该方法可以说这是一个探测性的方法，客户端通过该方法可以在不访问服务器上实际资源的情况下就知道处理该资源的最优方式。

客户端发起的这个 OPTIONS 可以说是一个“预请求”，用于探测后续真正需要发起的跨域 POST 请求对于服务器来说是否是安全可接受的，因为跨域提交数据对于服务器来说可能存在很大的安全问题。

一般的处理方式为：设置响应状态码为 204 是为了告知客户端表示该响应成功了，但是该响应并没有返回任何响应体，如果状态码为 200，还得携带多余的响应体，在这种场景下是完全多余的，只会浪费流量。

#### 注意事项

- 跨域请求头具体的值
  - 跨域的时候 不能设置 `*` 通配符，而是要写具体的域名
  - 有自定义的 header 部分需要做一定的配置

#### PostMessage

这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', event => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === 'http://test.com') {
    console.log('验证通过');
  }
});
```

> `H5`中新增的`postMessage()``方法，可以用来做跨域通信。既然是 H5 中新增的，那就一定要提到。

**场景**：窗口 A (`http:A.com`)向跨域的窗口 B (`http:B.com`)发送信息。步骤如下

1. 在`A`窗口中操作如下：向`B`窗口发送数据：

```js
// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
Bwindow.postMessage('data', 'http://B.com'); //这里强调的是B窗口里的window对象
```

2. onmessage 事件。在`B`窗口中操作如下：

```js
// 在窗口B中监听 message 事件
Awindow.addEventListener(
  'message',
  function(event) {
    //这里强调的是A窗口里的window对象
    console.log(event.origin); //获取 ：url。这里指：http://A.com
    console.log(event.source); //获取：A window对象
    console.log(event.data); //获取传过来的数据
  },
  false,
);
```

### axios 的 cookie 跨域以及相关配置

```js
// 携带 cookie
axios.defaults.withCredentials = true;
```

axios 默认是发送请求的时候不会带上 cookie 的，需要通过设置 withCredentials: true 来解决。 这个时候需要注意需要后端配合设置：

1. header 信息 Access-Control-Allow-Credentials:true
2. Access-Control-Allow-Origin 不可以为 `*`，因为 `*` 会和 Access-Control-Allow-Credentials:true 冲突，需配置指定的地址

并不是因为 axios 请求不能携带 cookie，axios 的原理和 ajax 一样，axios 只不过引入了 promise，之所以不能携带 cookie，是因为后端使用了 CORS 解决了跨域，这种方式默认是不携带 cookie 的，所以需要设置这样一个参数。

开发的环境下我们前端可以自己配置个 proxy 代理就能跨域了，真正的生产环境下还需要后端的配合的。

```json
{
  "proxyTable": {
    "/api": {
      "target": "http://10.1.5.11:8080/",
      "changeOrigin": true, //跨域 TODO:
      "pathRewrite": {
        "^/api": "/"
      }
    }
  }
}
```

### CORS 全称"跨域资源共享"（Cross-origin resource sharing）

主要的字段

- Access-Control-Allow-Origin
- Access-Control-Allow-Credentials
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers 实际请求将携带的自定义请求首部字段
- Access-Control-Max-Age 用来指定本次预检请求的有效期，单位为秒。

### fetch 发送 2 次请求的原因

fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？

原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求

### 简单请求

请求方式使用下列方法之一：

- GET
- HEAD
- POST

Content-Type 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

对于简单请求，浏览器会直接发送 CORS 请求，具体说来就是在 header 中加入 origin 请求头字段。同样，在响应头中，返回服务器设置的相关 CORS 头部字段，Access-Control-Allow-Origin 字段为允许跨域请求的源。

#### options nginx 配置

预检请求发生的条件：

使用了下面任一 HTTP 方法：

- PUT
- DELETE
- CONNECT
- OPTIONS
- TRACE
- PATCH

Content-Type 的值不属于下列之一:

- application/x-www-form-urlencoded
- multipart/form-data
- text/plain

```shell
# 配置如果是OPTIONS方法直接返回 204 状态
if ($request_method = 'OPTIONS') {
     add_header 'Access-Control-Allow-Origin' '*' always;
     add_header 'Access-Control-Allow-Credentials' 'true';
     add_header 'Access-Control-Allow-Methods' 'GET, POST, PATCH, DELETE, PUT, OPTIONS';
     add_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,  Access-Control-Expose-Headers, Token, Authorization';
     add_header 'Access-Control-Max-Age' 1728000;
     add_header 'Content-Type' 'text/plain charset=UTF-8';
     add_header 'Content-Length' 0;
     return 204;
}
```
