---
title: 工程化能效
date: 2020-11-21
draft: true
---

## 工程化

1. 前端项目标准， ci，监控等配置内置
2. 组件库集成
3. 脚手架工具， 内置 webpack ，webpack 编译优化？webpack 打包构建优化？
4. git 提交规范 commit-msg？代码检查规范 eslint？
5. 前端性能监控？前端异常监控？前端用户埋点 sdk？

## 统一 CI/CD 流程与工程化

在团队内推行 eslint，并给出工程化解决方案。

建设内部云构建体系，产出通用命令行指令工具；将发布、环境切换、快速回滚能力平台化，保证了线上环境稳定性；同时将研发流程量化管控，每周产出研发效能报告。

- eslint/prettier
- commit message lint
- 前端、node 发布流程
- 与企业微信的流程打通，监控与通知的桥接。

### 工程化方面

前端工程化方面做了哪些东西?

1. 前端项目标准？
   表现为库的选择？文件划分目录的规定？pc、mobile 多端实践？ssr 方案集成？
2. 组件库集成？
   组件库建设的目的？npm 包的发布？
3. 脚手架工具？
   webpack 编译优化？webpack 打包构建优化？自我脚手架的工具使用？
4. git 提交规范 commit-msg？代码检查规范 eslint？
5. 前端性能监控？前端异常监控？前端用户埋点 sdk？
6. rap？jenkins？

### CI 流程

- 本地开发（developing）
- 静态代码检查（linting）
- 单元测试（testing）
- 合并进入主干（merging）
- 自动构建（building）
- 自动发布（publishing）
- 可以支持快速回滚。

代码合并进主干以后，就可以进行自动构建和发布了。

### Eslint 的配置

为了遵循代码规范，使用 eslint 是必不可少的，配置 eslint 有两种方式

1. 使用 eslintrc.js 配置文件
2. 通过 eslint-loader 的配置

为了提升团队的代码规范，也可以通过 git 的钩子，在代码提交时就对代码作出 eslint 检查

### Code Review

1. 什么时候做？ 跟谁一起做？
2. 开发流程是怎么样的

#### 前端工程化

1. 前端工程化
2. 统一的 git eslint 发布（oci）流程等

semantic-release 集成
https://zqblog.beaf.tech/semantic-release/ 主题的开关

自动化 release 流程 https://blog.amowu.com/2017/01/how-to-automate-js-release.html

#### git 开发、发布流程

1. 分支
2. 前端 oci 发布
3. node oci 发布

#### 分支

- feature 开发分支。提交，自动 test， 自动提交 pr 到 dev 分支。
- dev 发布分支。 合并，test， 自动部署。 自动跑 changelog。
- master 归档分支。 合并，自动 tag 和 release

#### eslint

#### vscode 格式化代码

eslint
prettier
vetur

三者会互相影响。 默认情况下 prettier 的配置信息不够灵活而且条数不够，例如对于箭头函数要不要加括号的问题，eslint 是可以针对不同情况的，是否有 {} 等，但是 prettier 只能设置 never 或者 always； 关闭 vscode 的 prettier 插件之后，实际上只要项目中还存在 prettier 配置文件的话，vetur 格式化 js 语言的格式，默认也会是 prettier 规则，所以还需要将 vetur 中的规则修改为 none

#### 可回滚

5 分钟的可回滚。需要保证的是用户端的是否生效，而不是点一下回滚的按钮的时间。

#### CI/CD 流程

ci(持续构建)
代码提交后触发自动化的单元测试，代码预编译，构建镜像，上传镜像等．

cd(持续发布)
持续发布则指将构建好的程序发布到各种环境，如预发布环境，正式环境

**oci 发布管理**

- feature-xxx 分支作为日常的开发分支。 pr 合入 dev 发布测试环境

- dev 分支对应测试环境
- preview 分支对应预发环境
- release 分支对应正式环境

- dev 分支 pr 到 preview
- preview 分支 pr 到 release
- master 分支不作修改，仅仅作为当前线上最新可运行的最新副本

- release 分支发布成功之后，自动打 tag 然后自动合入 master 分支中
- hotfix 分支从 release master 或者 tag 中拉出来，需要重新 dev 分支开始合并

#### CI 持续集成

- ars 平台
- qci + ars
- 蓝盾 + ars
- oci

规范： git commit, 分支, 单元测试, 发布等

#### ci cd 的迭代历史

1. 手动 rz
2. ars 平台， 手动 build
3. qci + ars
4. 蓝盾 一开始不支持前端，界面操作
5. oci

## 前端与 serverless

### 使用 node 的场景

## -1. 工程化

1. 前端项目标准？表现为库的选择？文件划分目录的规定？pc、mobile 多端实践？ssr 方案集成？
2. 组件库集成？组件库建设的目的？npm 包的发布？
3. 脚手架工具？webpack 编译优化？webpack 打包构建优化？自我脚手架的工具使用？
4. git 提交规范 commit-msg？代码检查规范 eslint？
5. 前端性能监控？前端异常监控？前端用户埋点 sdk？
6. rap？jenkins？

## 5. 能效工具

- create-cdata-app. 基于 template 快速创建脚手架项目，内置监控、CI/CD、webpack 优化等功能。
- utils 工具库，提取多个项目中的功能函数，加入单元测试 Jest 功能，保证多个项目中的功能一致性，减少重复代码的书写。
- 组件库， cli 脚手架
  - cli 脚手架将组件分别打包成多种形式，普通 umd 形式和 es module 形式，后者原生就支持 tree sharking.
- axios 的封装等

#### 组件库

1. pc
2. h5

- 腾讯云风格的业务组件库
- 包装 ant d 的业务组件库
  - 组件直接显示在文档上的模块
  - webpack 自动 loader ？
- 内部开源 TDesign

#### table 组件

高性能的移动端 table

1.  固定宽 固定列，自适应宽度等
2.  大列表滑动
3.  性能渲染

说明白 oteam table

### 打造易用的前端工作台

提升前端工作效率

能力沉淀 = sdk 化 （npm 包）

真实环境环境自助调试接口 + JSAPI 验证 （大家的依赖如何降到最低，不仅仅是前端等后台，还有后台等前端，如何为后台做一个易用的接口调试工具）

### 提升前端的生产力

提高开发速度，快速上线

能做的事情：

1. 组件的复用
2. 一套代码多段运行
   1. 多端的开放能力对齐
   2. 统一的 js sdk
   3. 多端的接口统一

#### plugin

1. 监控： tam/sentry
2. common report
3. mixins beforeEntry

#### 密码下发方案的思考

1. 以前项目都是不开源，直接写在 node 项目中的 env 文件中即可。
2. 要求项目内源，将密码放到配置中心，通过 secretKey 去拉取配置中心的配置，拿到配置之后再启动 node 项目。
   1. 看起来没有问题，但是 secretKey 是直接写在代码中的，项目开源了，等于秘钥信息别人直接能拿到，数据库密码不安全 。
3. 通过 CI/CD 每次编译项目时，将配置文件下发到机器上，node 项目再去读取，一起打包进 docker 中

#### axios 取消

https://segmentfault.com/a/1190000021290514

同一个模块的同一个请求何时取消
