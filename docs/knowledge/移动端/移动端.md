---
title: 移动端
date: 2020-11-21
draft: true
---

<!-- TODO: -->

## 1px 像素问题

1. 画 0.5px 的线
2. 伪类 + transform 实现
3. viewport + rem 实现
4. 使用 border-image 实现
5. 使用 background-image 实现
6. 多背景渐变实现
7. 使用 box-shadow 模拟边框

#### 0.5px

```html
<!-- 在不同浏览器的标准模式与怪异模式下都能保持一致的效果 -->
<div style="height:1px;overflow:hidden;background:red"></div>
```

1. 直接设置 0.5px

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <style>
      .hr {
        width: 300px;
        background-color: #000;
      }
      .hr.half-px {
        height: 0.5px;
      }
      .hr.one-px {
        height: 1px;
      }
    </style>
  </head>
  <body>
    <p>0.5px</p>
    <div class="hr half-px"></div>
    <p>1px</p>
    <div class="hr one-px"></div>
  </body>
</html>
```

2. 使用 scale 缩放

```css
.scale-half {
  height: 1px;
  transform: scaleY(0.5);
  background-color: red;
}
```

3. 线性渐变 linear-gradient

```js
<style>
.hr.gradient {
    height: 1px;
    background: linear-gradient(0deg, #fff, #000);
}
</style>
<p>linear-gradient(0deg, #fff, #000)</p>
<div class="hr gradient"></div>
```

4. boxshadow

```js
<style>
.hr.boxshadow {
    height: 1px;
    background: none;
    box-shadow: 0 0.5px 0 #000;
}
</style>
<p>box-shadow: 0 0.5px 0 #000</p>
<div class="hr boxshadow"></div>
```

5. viewport

```js
<meta name="viewport" content="width=device-width,initial-sacle=0.5">
```

#### 1px

一般来说，在 PC 端浏览器中，设备像素比（dpr）等于 1，1 个 css 像素就代表 1 个物理像素；但是在 retina 屏幕中，dpr 普遍是 2 或 3，1 个 css 像素不再等于 1 个物理像素，因此比实际设计稿看起来粗不少。

1. 伪元素+scale

```html
<style>
  .box {
    width: 100%;
    height: 1px;
    margin: 20px 0;
    position: relative;
  }
  .box::after {
    content: '';
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 1px;
    transform: scaleY(0.5);
    transform-origin: 0 0;
    background: red;
  }
</style>

<div class="box"></div>
```

2. border-image

```css
div {
  border-width: 1px 0px;
  -webkit-border-image: url(border.png) 2 0 stretch;
  border-image: url(border.png) 2 0 stretch;
}
```

### 一像素边框问题

有的手机分辨率比较高，是 2 倍屏或 3 倍屏，手机上的浏览器就会把 CSS 中的 1 像素值展示为 2 个或 3 个物理宽度 解决方法： 添加一个 border.css 库，将利用**scroll 缩放的原理**将边框重置。当我们需要使用一像素边框时只需要在标签上添加对应类名，如设置底部一像素边框就在标签上加入"border-bottom"的 class 名

## 响应式

### 响应式设计和布局

在不同设备上正常使用，一般主要处理屏幕大小问题

- 隐藏 + 折行 + 自适应空间
- rem 做单位
- viewport
  - width=divice-width,
- 媒体查询

#### 1. meta 标签的实用

设置布局宽度等于设备宽度，布局 viewport 等于度量 viewport

```html
<meta name="viewport" content="width=device-width,initial-scale=1" />
```

### 媒体查询

> HTML 4 和 CSS 2 目前支持为不同的媒体类型设定专有的样式表, 比如, 一个页面在屏幕上显示时使用无衬线字体, 而在打印时则使用衬线字体, screen 和 print 是两种已定义的媒体类型, 媒体查询让样式表有更强的针对性, 扩展了媒体类型的功能;媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成, 媒体查询中可用于检测的媒体特性有 width、height 和 color（等）, 使用媒体查询, 可以在不改变页面内容的情况下, 为特定的一些输出设备定制显示效果。

语法

```css
@media screen and (max-width: 960px) {
  ....;
}
```

### 移动端的布局

可以通过百分比，rem，vw，vh 等自适应方式实现布局。

### 最简单的 rem 自适应

大家都知道，`rem`的值是根据`根元素的字体大小`相对计算的，但是我们每个设备的大小不一样，所以`根元素的字体大小`要动态设置

```
html {
 font-size: calc(100vw / 3.75);
}

body {
  font-size: .14rem;
}
```

效果如下：

![img](https://mmbiz.qpic.cn/mmbiz_gif/iaibsyicqkwnjuWg2Mn4MS0DkicHmQCNtl9CS0pwEibOpomE4W87zDiaEqKOcqiadZS5j0TAtwKNF3KiaSlv0j9YhaGkfw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

一般的话，直接搞`lib-flexible`、`postcss-pxtorem`就完事啦！
rem 单位，是相对于 html 的根元素的字体大小的倍数。只要调整 html 的根元素字体的大小就能够对布局进行等比例缩放，从而做到自适应。

### 媒体查询的原理是什么？

### 响应式设计与自适应设计有何不同？

响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。

响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。

自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。

### viewport 和移动端布局方案

### 移动端适配方案，除了 rem, vw, 还有什么方案？

淘宝的 flexible.js 来做屏幕适配，然后面试官询问了它的实现原理，以及浏览器中几种长度单位（rem、em、px）的特点和区别

### 你是否使用过媒体查询或移动优先的布局？

是的，一个例子就是根据窗口的尺寸改变导航的样式。

### 移动端的布局用过媒体查询吗？

- 假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS 就是为文档提供在不同媒介上展示的适配方法

- <!-- link元素中的CSS媒体查询 -->

  - 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。
  - 当媒体查询返回假， <link> 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）

- <link rel="stylesheet" media="(max-width: 800px)" href="example.css" />

- <!-- 样式表中的CSS媒体查询 -->

  - 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式
  - CSS3 加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围

```
<style>
@media (min-width: 700px) and (orientation: landscape){
  .sidebar {
    display: none;
  }
}
</style>
```

### 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？

- 响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本
- 基本原理是利用 CSS3 媒体查询，为不同尺寸的设备适配不同样式
- 对于低版本的 IE，可采用 JS 获取屏幕宽度，然后通过 resize 方法来实现兼容：

```js
$(window).resize(function() {
  screenRespond();
});
screenRespond();
function screenRespond() {
  var screenWidth = $(window).width();
  if (screenWidth <= 1800) {
    $('body').attr('class', 'w1800');
  }
  if (screenWidth <= 1400) {
    $('body').attr('class', 'w1400');
  }
  if (screenWidth > 1800) {
    $('body').attr('class', '');
  }
}
```

### 你用过媒体查询，或针对移动端的布局/CSS 吗？

媒体查询，就是响应式布局。通过不同的媒介类型和条件定义样式表规则。媒介查询让 CSS 可以更精确作用于不同的媒介类型和同一媒介的不同条件。

语法结构及用法：@media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二{sRules}。

```css
/* 当浏览器的可视区域小于980px */
@media screen and （max-width： 980px） {
#wrap {width： 90%; margin:0 auto;}
#content {width： 60%;padding： 5%;}
#sidebar {width： 30%;}
#footer {padding： 8% 5%;margin-bottom： 10px;}
}
/* 当浏览器的可视区域小于650px */
@media screen and （max-width： 650px） {
#header {height： auto;}
#searchform {position： absolute;top： 5px;right： 0;}
#content {width： auto; float： none; margin： 20px 0;}
#sidebar {width： 100%; float： none; margin： 0;}
}
```

### 移动端布局方案

百分比布局
百分比布局的，这样的做法的话是比较费时间的，有些细节的地方还需要用媒体查询来做兼容。做起来挺费时间，而且对于设计稿的还原也不好。所以这里>也不怎么推荐
固定的设备宽度
在做移动开发的时候很多人都会加上 viewport 的配置，
那么固定设备宽度的布局就是根据这个来设置的，将 viewport 里面的宽度 width 设置成设计稿的宽度，也就是说原本是 width=device-width，即宽度为设备的宽度，假如在 iphone6 上显示的时候，那么页面的宽度就是 375px; 当我们将 width 设置成设计稿的宽度的，假如设计稿是 750px，而我们的 css 也按设计的尺寸来做，例如一个图片是 200px\*200px，那么在 css 上也是宽高都是写 200px,也就是 1：1 的比例。那么在 375px 的手机上显示的时候，就会缩小 2 倍显示，以此类推，在 320px 的宽度的时候，就会缩小 2.3 倍显示，在 414px 的宽度的时候就会缩小 1.8 倍。
这样的写法是会比较好的还原设计稿，而且速度也会比较快，但是这样也有缺点，在缩>小的时候有些设备会比较模糊，因为你强行将设备放大了
rem 布局
我现在常用的移动端布局主要是用 rem 布局，这个应该是比较多人使用的，也是比较流行的。使用 rem 布局优点是可以适应多个屏幕 ，也比较好的还原设计稿。在有些地方需要一屏显示完设计稿的时候，可能需要用到 vh,或是百分比。
rem 布局简单来说就是根据页面的 font-size 的大小来设置页面元素的属性

### 为什么响应式设计 (responsive design) 和自适应设计 (adaptive design) 不同

响应式（RWD
所有设备的代码是一样的,响应式的概念覆盖了自适应，而且涵盖的内容更多
优点：面对不同分辨率设备灵活性强；能够快捷解决多设备显示适应问题
缺点：兼容各种设备工作量大，效率低下；代码累赘会出现隐藏无用的元素，加载时间加长；一定程度上改变了网站原有的布局结构，会出现用户混淆的结果

自适应（AWD
不同设备的代码是不一样的,自适应是为了解决如何在不同大小的设备上呈现同样的网页（网页的主题和内容不改变）
自适应暴露的一个问题，如果屏幕太小，即使网页能够根据屏幕大小进行适配，但是会感觉在小屏幕上查看内容太过拥挤。
响应式正是针对这个问题衍生出的概念。它可以自动识别屏幕宽度、并做出相应调整的网页设计、布局和展示的内容可能会有所改变

自适应设计实现方法： 1.允许网页宽度自动调整
首先在代码的头部加入一行 viewport 标签

viewport 是网页默认的宽度和高度，上面代码的意思是，网页宽度默认等于屏幕宽度，原始缩放比例为 1.0，即网页出事大小占屏幕的 100%。
所有主流浏览器都支持这个设置。对于老式浏览器（主要针对 IE6,7,8），需要使用 css3-mediaqueries.js。

<script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>

2.尽量少使用绝对宽度
由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。
具体：如不能使用 px 作为单位，使用百分比，同时可以配合 css 的 cal 进行宽度，或者 width：auto；

3.相对大小的字体
字体也不能使用绝对大小（px），只能使用相对大小（em）或者高清方案（rem），rem 不局限字体大小，而前面的 width 也可以使用，代替百分百。

4.流动布局
流动布局是各个区块的位置都是浮动的，不是固定不变的。
float 的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚到前面元素的下方，不会再水平方向溢出，避免了水平滚动条的实现。另外绝对定位也要谨慎使用

5.选择加载 css

区别
响应式布局中你可能需要面对非常多状态——是的，大部分状态之间的区别很小，但它们又的确是不同的——这样一来就很难确切搞清你的设计会是什么样
自适应布局有它自己的优势，因为它们实施起来代价更低，测试更容易，这往往让他们成为更切实际的解决方案。自适应布局可以看做响应式布局的“穷兄弟”，在资源有限的情况下就可以让它出马

扩展：
那起飞页是响应式还是自适应呢？这个。。。严格的说，起飞页是自适应的，因为我们针对不同的设备进行了优化和加速。但是不同设备上的代码，又竟然是 90%一致的。我们只能说，起飞页九成是响应式，一成是自适应，是这两种技术的完美结合

## 移动端高清方案

一份视觉稿如何适配多个机型的设备(大漠老师的文章和 seven 的文章)

### 你有兼容 retina 屏幕的经历吗？如果有，在什么地方使用了何种技术？

retina 是苹果推出的新型屏幕，由 4 个原像素点去描述一个新像素点（即压缩了 2 倍），且存在 0.5 个像素点这样的描述，所以需要兼容。
当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保真的显示，因为一个位置像素不能进一步分裂。而当在 Retina 屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形。换句话说，每一位图像素被乘以四填补相同的物理表面在视网膜屏幕下显示。

解决方法就是通过制作两种不同的图形，一张是普通屏幕的图片，另外一种是 Retina 屏幕的图形，而且 Retina 屏幕下的图片是普通屏幕的两倍像素

- 直接加载 2 倍大小的图片

```js
<img class="pic" src="pic.png" height="200px" width="300px"/>

<script type="text/javascript">
$(document).ready(function () {
    if (window.devicePixelRatio > 1) {
        var images = $("img.pic");
        images.each(function(i) {
            var x1 = $(this).attr('src');
            var x2 = x1.replace(/(.*)(.w+)/, "$1@2x$2");
            $(this).attr('src', x2);
        });
    }
});
```

- Image-set 控制

```js
#logo {
    background: url(pic.png) 0 0 no-repeat;
    background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x);
    background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);
    background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);
    background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);
```

- 使用@media 控制

```js
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */
only screen and (-o-min-device-pixel-ratio: 3/2),
only screen and (min-device-pixel-ratio: 1.5) {
    #logo {
        background-image: url(pic@2x.png);
        background-size: 100px auto;
    }
}
```

### 你有没有使用过视网膜分辨率的图形？当中使用什么技术？

我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像`@media only screen and (min-device-pixel-ratio: 2) { ... }`，然后改变`background-image`。

对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。

还有一种方法是，在检查了`window.devicePixelRatio`的值后，利用 JavaScript 将`<img>`的`src`属性修改，用更高分辨率的版本进行替换。

### 让页面里的字体变清晰，变细用 CSS 怎么做？（IOS 手机浏览器字体齿轮设置）

```css
-webkit-font-smoothing: antialiased;
```

## 事件

### 300ms 延迟

移动端 click 有 300ms 延迟，浏览器为了区分“双击”（放大页面）还是“单击”而设计

解决方案：

1. 禁用缩放(对 safari 无效)
2. 使用 Zepto 的 tap 事件(有点透 BUG)
3. 使用 FastClick 插件(体积大[压缩后 8k])
4. 使用指针事件(IE 私有特性，且仅 IE10+)

### 点击、滑动穿透

position: fixed 导致的 onClick 事件透传到底下被遮住的部分。

当你想在出现`遮罩`的时候，锁住用户的滚动行为，你可以这么做。

假设`HTML`结构如下：

```html
<div class="mask">
  <div class="content">我是弹框</div>
</div>
```

`CSS`样式如下：

```css
.mask {
  position: fixed;
  top: 0;
  left: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: 100%;
  background-color: rgba($color: #333, $alpha: 0.6);

  .content {
    padding: 20px;
    background-color: #fff;
    width: 300px;
  }
}
```

可以看到，当在`遮罩`上滑动的时候，是会穿透到父节点的，最简单的办法就是阻住默认行为：

```js
document.querySelector('.mask').addEventListener('touchmove', event => {
  event.preventDefault();
});
```

如果在`vue`中，你可以这么写：

```html
<div class="mask" @touchumove.prevent></div>
```

如果`.content`也有滚动条，那么只要阻止`遮罩`本身就行：

```js
document.querySelector('.mask').addEventListener('touchmove', event => {
  if (event.target.classList.contains('mask')) event.preventDefault();
});
```

或者：

```html
<div class="mask" @touchumove.self.prevent></div>
```

### 滑动不顺畅，粘手

在`IOS`设备中，自定义盒子使用了`overflow: auto || scroll`后出现的情况。

```css
div {
  -webkit-overflow-scrolling: touch;
}
```

## 白屏故障

### 如何改善首屏优化和白屏

1. 路由懒加载组件懒加载等。
2. 骨架屏效果。
3. 首屏请求的接口的优化？
4. SSR

#### 总结

1. cdn 分发（减少传输距离）。通过在多台服务器部署相同的副本，当用户访问时，服务器根据用户跟哪台服务器距离近，来决定哪台服务器去响应这个请求。
2. 后端在业务层的缓存。数据库查询缓存是可以设置缓存的，这个对于处于高频率的请求很有用。浏览器一般不会对 content-type: application/json；的接口进行缓存，所以有时需要我们手动地为接口设置缓存。比如一个用户的签到状态，它的缓存时间可以设置到明天之前。
3. 静态文件缓存方案。这个最常看到。现在流行的方式是文件 hash+强缓存的一个方案。比如 hash+ cache control: max-age=1 年。
4. 前端的资源动态加载：
   1. 路由动态加载，最常用的做法，以页面为单位，进行动态加载。
   2. 组件动态加载(offScreen Component)，对于不在当前视窗的组件，先不加载。
   3. 图片懒加载(offScreen Image)，同上。值得庆幸的是，越来越多的浏览器支持原生的懒加载，通过给 img 标签加上 loading="lazy 来开启懒加载模式。
5. 减少请求的数量。这点在 http1.1 的优势很明显，因为 http1.1 的请求是串行的（尽管有多个 tcp 通道），每个请求都需要往返后才能继续下个请求。此时合并请求可以减少在路途上浪费的时间，此外还会带来重复的请求头部信息（比如 cookie)。在 http2.0 中这个问题会弱化很多，但也有做的必要。
6. 页面使用骨架屏。意思是在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏的好处在于可以减少用户等待时的急躁情绪。这点很有效，在很多成熟的网站（京东、淘宝、Youtube）都有大量应用。没有骨架屏的话，一个 loading 的菊花图也是可以的。
7. 使用 ssr 渲染。
8. 引入 http2.0。http2.0 对比 http1.1，最主要的提升是传输性能，在接口小而多的时候会更加明显。
9. 利用好 http 压缩。即使是最普通的 gzip，也能把 bootstrap.min.css 压缩到原来的 17%。可见，压缩的效果非常明显，特别是对于文本类的静态资源。另外，接口也是能压缩的。接口不大的话不用压缩，因为性价比低（考虑压缩和解压的时间）。
10. 利用好 script 标签的 async 和 defer 这两个属性。功能独立且不要求马上执行的 js 文件，可以加入 async 属性。如果是优先级低且没有依赖的 js，可以加入 defer 属性。

### 用户页面遇到白屏问题，解决问题的思路（场景题）

1. 白屏时间节点指的是从用户进入网站（输入 url、刷新、跳转等方式）的时刻开始计算，一直到页面有内容展示出来的时间节点。这个过程包括 dns 查询、建立 tcp 连接、发送首个 http 请求（如果使用 https 还要介入 TLS 的验证时间）、返回 html 文档、html 文档 head 解析完毕。
2. 查看监控系统，有误错误日志上报。
3. 模拟该用户，（所有接口都会被替换身份），排查是否是接口原因。
4. 从监控日志中或者直接问用户，捞用户的机型（移动端）和浏览器版本，排查是否是某个 api 有兼容性问题导致的。
5. 最好能够有一致型号的手机，复现。 或者给一个测试的链接，包含 vConsole 和全量日志上报的版本，让其访问，看是否表现一致。
6. 用过仅有他的手机，且仅有某一个环境能复现，那就只能麻烦它再请求一次，观察一下实时日志，看实在 cdn 阶段 or nginx 阶段 or 服务阶段出现的问题。如果自己能复现，则自己排查。

## 移动端项目需要注意的问题

### meta 中设置 viewport

阻止用户手滑放大或缩小页面，需要在 index.html 中添加 meta 元素,设置 viewport。

```html
<meta
  name="viewport"
  content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"
/>
```

### CSS 样式统一问题

重置页面样式，因为在不同的手机浏览器上，默认的 css 样式不是统一的。 解决方法：使用 reset.css 重置所有元素的默认样式
