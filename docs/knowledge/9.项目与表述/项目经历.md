---
title: 项目经历
date: 2020-11-21
aside: false
draft: true
---

# 项目把握程度

项目 + 解决方案。 有什么问题， 如何优化的。对接手的项目要吃透，要发现自己实现的局限性和市面上比较好的解决方案，这个会加分。回答要有规划，从顶层设计到底层实现原理。

# 询问项目经历

在一面二面中问到你具体做过的项目，然后追问项目的细节。这类问题往往会通过下面形式来提问:

1. 发现你简历的一个项目，直接让你介绍下这个项目
2. 做过最满意的项目是什么？
3. 项目背景：为什么要做这件事情？最终达到什么效果？
4. 让你回忆下你做过的项目中，最值得分享(最大型/最困难/最能体现技术能力/最难忘)的
5. 在项目中遇到什么技术问题？具体是如何解决的？
6. 你处于什么样的角色，起到了什么方面的作用？
7. 如果再做这个项目，你会在哪些方面进行改善？
8. 如果让你设计 xx 系统/项目，你会怎么着手干

## 怎样介绍自己做过的一个项目

简历当中的项目，你要精挑细选，既要体现技术难度，又要想好细节。具体要介绍一个项目(包括梳理一个项目)，可以按照下面几个阶段来做。

### 1. 介绍项目背景

这个项目为什么做，当初大的环境背景是什么? 还是为了解决一个什么问题而设立的项目? 背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。

### 2. 做了什么

一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。

### 3. 最终的结果和收益

项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。

### 4. 有始有终:项目总结和反思

有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官 说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理:

1. 收获有哪些?
2. 是否有做得不足的地方，怎么改进?
3. 是否具有可迁移性?

比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来:现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。

再比如:做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。
介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。

按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。

## 项目细节和技术点的追问

介绍项目的过程中，面试官可能会追问技术细节，所以我们在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括:

1. 技术选型方案: 当时做技术选型所面临的状况
2. 技术解决方案: 最终确定某种技术方案的原因，比如:选择用 Vue 而没有用 React 是为什么?
3. 项目数据和收益
4. 项目中最难的地方
5. 遇见的坑: 如使用某种框架遇见哪些坑。

一般来说，做技术选型的时候需要考虑下面几个因素:

1. 时代: 现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项 目中?
2. 团队: 个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的?
3. 业务需求: 需求是怎样的，能否套用现在的成熟解决方案/库来快速解决?
4. 维护成本: 一个解决方案的是否再能够 cover 住的范围之内?

在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术(Vue、React、webpack)，一 般团队都在使用，所以一定要提前准备下。

# 主题

可视化、性能优化、拖拽、低代码

# 项目经历

## 0. 优化

接手老的前端项目，接入监控系统，懒加载等性能优化。

### 1. 性能优化

#### 1. 资源加载速度

1. 图片懒加载
2. 组件懒加载
3. 数据懒加载
4. 虚拟列表
5. 组件按需加载

- 海量数据的虚拟列表
  - https://www.jianshu.com/p/15cc08ec366a
  - https://juejin.im/post/5ae17a386fb9a07abc299cdd
- 图片懒加载原理

补充 vue-lazyLoad、普通组件懒加载以及虚拟列表的原理

#### 2. webpack 开发编译速度

#### 3. webpack 打包优化

### 2. 统一 CI/CD 流程与工程化

- eslint/prettier
- commit message lint
- 前端、node 发布流程
- 与企业微信的流程打通，监控与通知的桥接。

#### 前端工程化

1. 前端工程化
2. 统一的 git eslint 发布（oci）流程等

semantic-release 集成
https://zqblog.beaf.tech/semantic-release/ 主题的开关

自动化 release 流程 https://blog.amowu.com/2017/01/how-to-automate-js-release.html

#### git 开发、发布流程

1. 分支
2. 前端 oci 发布
3. node oci 发布

#### 分支

- feature 开发分支。提交，自动 test， 自动提交 pr 到 dev 分支。
- dev 发布分支。 合并，test， 自动部署。 自动跑 changelog。
- master 归档分支。 合并，自动 tag 和 release

#### eslint

#### vscode 格式化代码

eslint
prettier
vetur

三者会互相影响。 默认情况下 prettier 的配置信息不够灵活而且条数不够，例如对于箭头函数要不要加括号的问题，eslint 是可以针对不同情况的，是否有 {} 等，但是 prettier 只能设置 never 或者 always； 关闭 vscode 的 prettier 插件之后，实际上只要项目中还存在 prettier 配置文件的话，vetur 格式化 js 语言的格式，默认也会是 prettier 规则，所以还需要将 vetur 中的规则修改为 none

#### 可回滚

5 分钟的可回滚。需要保证的是用户端的是否生效，而不是点一下回滚的按钮的时间。

#### CI/CD 流程

ci(持续构建)
代码提交后触发自动化的单元测试，代码预编译，构建镜像，上传镜像等．

cd(持续发布)
持续发布则指将构建好的程序发布到各种环境，如预发布环境，正式环境

**oci 发布管理**

- feature-xxx 分支作为日常的开发分支。 pr 合入 dev 发布测试环境

- dev 分支对应测试环境
- preview 分支对应预发环境
- release 分支对应正式环境

- dev 分支 pr 到 preview
- preview 分支 pr 到 release
- master 分支不作修改，仅仅作为当前线上最新可运行的最新副本

- release 分支发布成功之后，自动打 tag 然后自动合入 master 分支中
- hotfix 分支从 release master 或者 tag 中拉出来，需要重新 dev 分支开始合并

#### CI 持续集成

- ars 平台
- qci + ars
- 蓝盾 + ars
- oci

规范： git commit, 分支, 单元测试, 发布等

#### ci cd 的迭代历史

1. 手动 rz
2. ars 平台， 手动 build
3. qci + ars
4. 蓝盾 一开始不支持前端，界面操作
5. oci

### 3. 重构

背景

hc 少，有很多稍微老一点的项目，以及很多前端项目都是外包处理的。 解决方案：

1. js 改 ts
2. 加入测试用例
3. 加入 ci cd
4. 升级 vue react 的依赖
5. 抽离大量的公共 npm 包
6. 引入微前端的概念
7. 考虑 iframe 的重构
   1. 目的是为了实现页面的复用
   2. 从组件、脚手架级别实现复用
      1. 组件库
      2. 脚手架
      3. 种子项目
   3. json 生成页面和模块的方案， 直接生成代码的方案

#### 重构 vue 的项目

1. 目录结构规范
   1. 统一 @ 路径
   2. 统一 eslint 与 prettier
2. 接入 ci/cd
3. 某些依赖升级，比如 vue webpack 等
4. 单元测试

## 1. TBP 控制台

背景：ASR + NLP + TTS

- 语义配置平台
- 小程序、h5（一键对外接入对话机器人）、公众号

点击授权， 带上 RobotId, 进行微信公众号绑定，再通过微信 code2Key 换到 accessToken 作身份鉴权用。

qcmagic + dev

腾讯云官网的 console, 难点在于不能使用 vue router ,用过 seajs 来做的一层操作，一个比较麻烦的功能是： 用户在页面点击修改之后，退出未保存，自定义弹框提醒用户，而不是使用浏览器自带的提示框(说明有什么坏处)， 在有 vue router 的时候将 next 函数储存起来，点击确定之后再去主动触发。而不能用 router 的时候，seajs 中的 路由跳转其实是 navigate 函数做的，所以给了一个解决方案是，在 路由组件中，点击跳转前会做一次校验，是否没保存，如果是需要提示的页面，手动储存 next 函数(这里是 navigate)，否则直接进行跳转。讲一讲 webpack 的模块加载原理？我理解的 seajs 与 vue 的共生问题。

1.  vue 的 input 中中文输入法的 bug， value 为空，但是一直在 input， keydown 值为 229 的解决办法
2.  输入框限频校验输入是否合法的问题，解释原理是由于 settimeout 造成的，为了适用于 promise 该如何改写，实现类似 sleep 的效果。

vue 全家桶的运营平台：说一说性能优化的点，开发模式下使用 import vue 等模块，产品模式下会再 html 文件中自动插入比较大的 js 的 cdn 文件(这里吃了一次亏，最好用自己的 cdn)，而 bundlejs 中自动将这些 js 文件打包分离出来，再通过脚本将这些 js 都上传到七牛云上去，所以基本上可以直接被访问。剩余的几个问题:

1.  路由的懒加载
2.  图片如何实现懒加载，原理(手动实现的组件)，分析其余的几种方案的优劣
3.  vuex 模块的懒加载，为什么会想到去优化？ 因为 redux 中有，并且其实在开发过程中 devtool 会变得很慢。。。
4.  解释 cdn 原理，element ui 的官方 cdn 在很多场景下会很慢。如何进行接口请求耗时的优化，从 1s 以上的耗时优化到 300ms 一下，有 多个服务器，跨地域之类的。

### 企业微信 helper

http://km.oa.com/articles/show/436893

### console

1. 意图配置的 tag 输入框，多 tag 下拉框的位置计算
2. 页面跳转的处理，vuex 存储 next（）
3. 轮询接口的封装
4. requestId 捕捉器
5. vuex 的小封装

#### 搜索高亮

- vue 项目中搜索高亮，通过正则表达式拼接标签高亮，再通过 v-html 显示，能够高亮，但是会带来跨站攻击 ？需要手动过滤 script 标签等
- v-html 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容插值。
- 你项目中如何进行用户输入过滤的？都过滤了那些内容？(根据回答有了下一个问题)
- 为什么没有过滤<img>标签？

#### 自定义提示保存弹框的处理

有几个不同版本：

##### 不使用 vue-router 使用原生的 confirm 函数

缺点： 难看，不能自定义。

##### 能使用 vue-router

使用 vue-router 的钩子函数，主动赋值 next 函数

##### 不使用 vue-router

1. seajs 中我是如何进行处理的。
2. seajs 中这样处理的问题在哪里？ 最后我是如何进行处理的？

#### TBP

1. 路由跳转前弹框。没有 vue router 的守卫函数的情况下如何处理？seajs 的路由处理方式。
2. vue 项目开发环境和生产环境的 bundle js 优化，以及如何对于线上环境打开 vue devtool 查看参数。如何在上线时使用 cdn 在开发环境又默认使用 install
3. 如何判断一个大表单有没有进行修改数据？ 是否弹框提醒

#### 实现自动伸长的 textarea

#### TBP vue

vuex 的 mutation 触发，

1. 严格模式下写很多 mutation 很麻烦。
2. vue 通过是数组下标直接修改数据不能够触发重新渲染

解决：

1. vuex 的插件，会自动生成 mutations getters
2. omiv 能够监听通过下标修改数组，并且可以直接修改，不需要写 mutations， 能够复用 vuex-logger-plugin

#### 动态输入框下拉框

场景是一个输入框，输入过程中如果输入了单个 { 符号的话，出现 tag 标签，并且出现下拉框

1. input width 如果设置为 auto 的话跟没有设置是一样的，默认 html5 原生 input 的 width content 是 125 px

2. 需要动态获取输入框中的内容的长度，有几个方案

   1. vue 的 v-model 可以直接获取双向绑定的值，通过 value.length 可以直接获取长度。 一个 input content 的计算方式是 value.length \* font-size 但是有一个问题，数字、英文字体与中文字体的宽度计算方式不一致，也就是说上面的计算方式仅限于中文，如果 value 中包含英文或者数字，width 计算是不准的。
   2. 监听 input 的 input 事件（注意与 change 事件的差别）变动的 dom 节点的获取是 event.target 。 默认情况不指定 input 的 width 的话，输入超出 width 的文本可能乎出现滑动条或者字符往左进行滚动，通过 event.target.scrollWidth 可以直接获取 input 真实的 width 不需要考虑是什么字符

3. 在 vue 中的解决方案

   1. 在 input 监听回调中通过 e.target.style.width = e.target.scrollWidth + "px"; 可以达到我们想要的效果，但是理论上这是在直接操作 dom，在 vue 中也算是比较忌讳的。

   2. 直接通过 vue 的指令来实现 v-autoWidth 加上即可。 input 每次输入都会执行指令的 update 钩子函数，首次挂载的时候执行 bind 钩子函数，首次执行的时候为了初始化 input 的长度。

      ```
        directives: {
          autoWidth: _debounce(function(el) {
            el.style.width = el.scrollWidth + "px";
          })
        },
      ```

      需要注意的是这里不能够使用限频，因为同一个指令有被多次使用，就会在渲染期间多次触发，限频会被影响。

   3. <http://www.cnblogs.com/cythia/p/5977643.html> 另一种方案。。

   4. 指令中没有 this 指向 vm， 但是如果需要获取 this 的话，vnode.context 就是指向当前的 this 的。

参考：

<https://blog.csdn.net/superit401/article/details/72473318>

<https://blog.csdn.net/young_Emily/article/details/77335158>

```
        // clientWidth = width（可见区域）+ padding - 滚动条宽度
        // offsetWidth = width（可见区域） + padding + border（若有滚动条宽，那就包含在里面了）
        // scrollWidth = width（自身实际长度，包括不可见区） + padding + border + margin
```

#### vue 指令打点上报

1. PV/UV
2. 点击事件 声明式上报 （很多节点注册事件的性能问题， 如何使用代理形式 ？）
3. 主动上报 耦合进业务逻辑

曝光和打点，全部通过指令来完成，尽可能与业务逻辑进行解耦，抽成组件的形式

https://www.cnblogs.com/xumengxuan/p/10682338.html
https://www.cnblogs.com/huiwenhua/p/13368415.html

https://hughfenghen.github.io/fe/vue-directive-track.html#%E4%BC%A0%E7%BB%9F%E5%9F%8B%E7%82%B9-vs-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%9F%8B%E7%82%B9

上报的几种分类型是：

https://www.cnblogs.com/xumengxuan/p/10682338.html

https://hughfenghen.github.io/fe/vue-directive-track.html#%E5%8F%AF%E5%8F%82%E8%80%83%E7%9A%84%E6%8C%87%E4%BB%A4%E6%BA%90%E7%A0%81

#### 问题点

binding.value 不是响应式的

#### 轮询延迟接口查询

这里很重要的一点是，一个 promise 执行完毕之后，如果没有 resolve 或者 rejected 结果的话，这个 promise 就不会返回任何东西，也就是说 await 或者 then 都获取不到结果。就算在执行期间重新又 new Promise 了，但那是一个新的 Promise，对于之前的 那个 promise 来说，正确的轮询接口返回结果传递的方式应该是将执行期间的 new Promise 的结果由第一个 promise resolve 出去。 就像这里的 `resolve(await sleepHandle(async () => await pollCheck(TaskRequestId)))`, await 的结果是一个有结果， 也就是说，最后 pollCheck 函数能够得到结果。

```js
// 递归轮训函数
export function pollCheck(TaskRequestId) {
  // Vue.prototype.$tip.loading({
  //   msg: 'loading...',
  //   duration: 0
  // })
  return new Promise((resolve, reject) => {
    queryTaskStatus(TaskRequestId).then(async resp => {
      const Status = (resp && resp.Response && resp.Response.Status) || 0;
      if (Status === 0) {
        console.log('pollCheck...');
        // 这里也需要 resolve 一个 promise
        resolve(await sleepHandle(async () => await pollCheck(TaskRequestId)));
      } else {
        console.log('resp', resp);
        resolve(resp);
      }
    });
  });
}
```

#### 大文件上传

### 在 Vue 中使用 localStorage 的时候， computed 不能够触发 getter 的重新计算，如何解决的。 通过自定义事件

### h5

1. 1px 那个问题，以前是直接通过 dpi 进行缩放，现在的解决是通过媒体查询，进行缩放
2. h5 的输入框、键盘的处理，安卓 ios 等等会有不同的表现

## 2. Node BFF 与 SSR

- BFF
- Node 全栈
  - BFF
  - GateWay
  - 公共中间件提取
  - 性能调优，解决内存瓶颈，能对系统整体性能进行评估

#### 自动生成 mock 的服务

https://jsonplaceholder.typicode.com/

物料：

- json demo
- js 对象
- class 类
- d.ts 文件
- pb 文件

通过词法分析，根据值或者类型来判断该 mock 的值的类型。通过数据资产平台，拉取数据，自动生成 mock 元素的结构。

namespace 与类、维度、指标的维护和共享。

- MOCK
  - proxy： https://jsonplaceholder.typicode.com/ https://segmentfault.com/a/1190000008635891
  - json-server
- 数据 mock 平台 https://github.com/thx/rap2-delos

#### 基础服务

- 企业微信机器人
- 邮件
  - html 转 inline

### API 网关？

### 小程序、公众号

1.  解释 appid 的获取与兑换
2.  如何对接口做一层安全校验加密（前端如何来说公钥才能不被破解），收费等，才能防止被褥羊毛(举例说明有道翻译 api)
    1. 简单描述一下腾讯云官网的云 api3.0 的意义，appid -> tinyid

### SSR/CSR 优雅降级

### Feature Flag 灰度配置中心

背景很重要。！！！
一个基于 git 和 node 的轻量化灰度配置工具。
接入流水线，打通企业微信对话机器人。能够理解语义，自动打开配置的开关？

#### 可复用 灰度

页面灰度

用户级别 （id ），模块（功能）级别

通过 js api 传一个 key 去拿到配置文件，与客户端和后台公用，可见不可见。

## 3. Low Code 数据工厂

可配置化的前端项目

1. json 中无法写函数，写的函数无法很好的注入 content 或者 this 之类的上下文，除非改造函数的写法，比如 vm => vm.data 之类的将 this 传入
   解决： 参考 vscode 中的 ui 可配置化，采用 when 的形式，对操作符进行处理，将 when 字符串拼接上 with(this) 执行的接口会被自动 return， 这样就可以直接写属性名的判断条件，而不用带上 this 之类的前缀

2. 随着项目的更新，旧的配置解析器慢慢显示出一些问题（项目初期设计不算太完善），但是线上已经有多个项目在跑了，新功能要加入旧解析器不能再很好的工作了。
   解决： 优雅降级，对于老的组件，额外开发一些 transfor 转换器，将新配置（可读性更好）的配置转化成旧配置进行渲染； 对于新组件，直接将新的配置文件进行解析渲染。

1) 可视化组件库的规范？？？

搭建系统 https://github.com/MrXujiang/h5-Dooring

### 高管驾驶舱

- vue
- 可视化
- echart
- 通过 json 配置文件生成目录结构
- 小程序 + webview

### renderChild

一个主 Vue 实例渲染所有组件的形式。

问题：

1. 最大的问题之一， bff 层的对接，不是直连后台服务。解决方式： 手动填入数据，或者接口
2. 组件生态不够好，设计师设计稿很好看，前期组件沉淀还不够，不能够迅速搭建起移动端页面。
3. 传统的可视化搭建系统存在的最大问题是，基本上都是单个页面的，比如活动页，表单收集页等，因为路由切换、多页数据共享等逻辑会与传统可搭建系统的纯粹性产生冲突，当然也不排除一些业务本身的场景比较简单。从编译的角度上来做的 搭建系统就可以解决这个问题，所谓的搭建，其实就是在写 dom json 。

### 数据可视化前端 + 数据中台

1. 可视化的页面搭建，云凤蝶 等平台，直接拿页面上的 ui 拖动来搭建。最终输出是一个 json 配置文件。
   难点：

   1. pc 上的操作交互
   2. ui 数据格式的定义
   3. 丰富的组件库支持

2. （可视化场景的落地）获取到 json 配置文件之后，能够根据配置文件直接渲染生成一个项目，一般以 h5 为主。
   难点：

   1. 输出除了 h5 还有 小程序和 pc 端
   2. 组件库三端都需要有，并且最好需要能够高度统一
   3. 同构：多端编译的框架，至少是 h5 到小程序一套代码实现。pc 端与 h5 的区别一般只是在于布局样式等等。

3. 基础建设：

   1. pc 端组件库
   2. 小程序组件库
   3. 移动端组件库

4. 监控上报： 自己配置仪表盘，自己分析数据
5. 脚手架

   1. 移动端、小程序、pc
   2. 微前端方案
   3. eslint, commitLint, code split, 内置组件库等等
   4. 提交代码， pr 以及发布流程的规范。
   5. 单元测试

6. 通用组件的沉淀（非 UI）

   1. ts + axios
   2. 数据接口的定义

7. 数据可视化 UI 的深入

   1. svg canvas 等底层
   2. echart antv 等

8. 数据中台
   1. 数据处理
   2. 网关层
   3. 数据缓存
   4. 权限
   5. TS 接入

### Iframe 自适应高度

- 同域
- 跨域

#### postMessage

1. 子 iframe 页面只能调用 top.postMessage. 不能调用 parent.postMessage 的原因 ？
2. 父页面往子 iframe 发送事件，可以拿 iframe 的 dom 节点的 contentWindow 调用 postMessage 事件。但是父页面不知道子页面什么时候加载完毕，只能退而求其次，先让子 iframe 发送事件给父页面之后，通过 event.source 调用 postMessage 节点发送消息。 虽然实际上是同一个引用。

## 4. 前端监控系统 SDK

## 5. 小程序、移动端

### 小程序

1. 自定义的头部
2. 跳转 js sdk 强行 navigateTo

#### 小程序内嵌 web-view 的 crash 问题

主要原因是上面的 table 性能问题。

#### 移动网关的自定义域名映射

处理之前，需要给前端项目打两份包出来，动态插入网关 key 到 baseUrl 中去， 发布两份 dist 静态资源。

通过申请一个自定义域名，与指定的 key 建立绑定关系，那前端在打包脚本上就不需要做额外的处理，baseUrl 也不需要做特殊处理，只打包一份前端代码。缺点： 微信公众号授权域名只支持添加 2 个域名，所以对于测试环境、预发环境、正式环境 有强烈 3 个环境需求的项目，这种方式就不适合。我们的项目是建立在小程序上的，开发环境只能开发者进行访问，所以可以用一个测试域名，本地开发者工具忽略域名的检查，线上的授权域名使用预发环境 和 正式环境两个域名即可。

#### 移动端偶现耗时极长的问题

1. 小程序 h5 授权问题，只能绑定两个域名，所以只能绑定一个预发环境域名，正式环境域名。 测试环境域名只能在本地的开发版小程序使用，本地开发工具忽略域名检查。
2. 公司所有内网资源外部访问，都需要经过移动网关（pc 端经过智能网关）做鉴权，登录态每天失效一次，会自动进行登录。域名是 `oa.m.tencent.com` 但是小程序上需要绑定一个 request 域名，公司内部很多小程序已经绑定了这个域名，所以没有办法再直接绑定上了，想了个办法就只能新申请了一个域名 cname 到这个域名上。（通过路径转发 ？ 可能也可以实现，再想一想）
3. 经过移动网关之后，访问内网环境的服务器，请求静态资源和接口。 接口会经过机器上的 nginx 负载均衡转发到 stke 上。 stke 是用来部署后台服务的 docker 平台。
4. 问题： 小程序中网页打开发现 loading 时间过长，偶现。 前端通过在 ajax 请求之前已经接口返回之后上报接口耗时，发现长达 30s - 1min 。 移动网关处排查也发现耗时有那么久，但是 node 日志中间件打印耗时不到 1 秒。
5. 解决：
   1. nginx 默认打印的日志不会添加耗时字段，添加字段。
   2. 移动端 whistle 代理，观察每一个请求的状态，因为直接观察 nginx 日志不好观察。
   3. whistle 上的耗时显示即为前端的体验耗时。查看 nginx 上日志打印的耗时。发现也是 30 多秒。
   4. stke 上能够查看到请求到达和返回的时间节点，差值是业务计算出的耗时，这个值是正常的。
   5. dns cname 耗时排查，gslb 上，询问运维，以及 performance 上应该也能查看 ？
   6. 移动网关处也是 30 多秒。
   7. 所以推断是 请求到 stke 上的时间有问题 ？
   8. 最终排查到是 访问链路是 vip--》clb 后端--〉TKE 集群 --》业务 pod

微信公众号 or 小程序 webview 内嵌 h5 授权的流程： https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html

#### 身份权限处理

后台路由权限，通过角色映射。前端也动态插入路由，差不多相同的逻辑， 用一个 npm 模块进行处理，保证结果的统一。 使用 lerna ？

#### 移动端 ant d vue table 性能问题

出现的原因： 数据量大，滑动，大量的插槽
解决办法：阅读源码，提取一个单独的 table 移动端高性能组件。

https://www.zhihu.com/question/319837974
https://zhuanlan.zhihu.com/p/102037418

##### 在对 IE 的兼容性方面做了一些取舍，原因是什么？兼容 IE 的难点都有哪些？

微信小程序 web-view 内存溢出

v3 版本为了兼容旧版 IE，不得不做一些妥协。比如说 flex 布局不能用，我们就用 float 和 table 来搞；不能用 sticky，Table 为了实现固定列不得不额外再渲染一个 Table 达到固定列的效果。最近几年，随着 windows 系统的升级，旧版 IE 的占比已经越来越小。这也是一个契机，让我们在 v4 版本可以舍弃过于陈旧的 IE 版本，从而轻装上阵。

兼容 IE 的难点在于很多行为是非预期的，往往代码没有什么问题，但是页面渲染就是不正常。对于这种情况，就需要做不少的黑科技。比如说让组件强制刷新、使用 IE only 的 css hack 等等。此外前面提到的很多 HTML 新特性在 IE 环境下无法使用，只能自行模拟导致严重的性能损耗。

#### 影响

顶部固定，左侧从栏，都是用一个单独的 table 拼接出来的，所以导致它在 ios 在滑动的时候 会有阻尼效果, overflow-x: auto 一定程度上会出现两块 table 脱离的状况。

##### 解决办法

诉求： 手机端的 table： 固定表头 + 左侧栏
sticky 固定，长列表用用虚拟列表。 table 的渲染性能比 div 慢，也可以直接用 div 来模拟。

#### 小程序中打开页面缓存导致无法重定向的问题

302 301 会重定向页面，到（自动）登录的页面，登录之后再重定向会原链接，此时已经戴上了登录态。正常状态是这样。

但是在小程序中静态文件会被缓存起来，每次打开小程序、打开小程序中的 webview 不一定会重定向成功。 是因为跨域了 ？https://www.cnblogs.com/wxlevel/p/7833595.html
https://blog.csdn.net/liyantianmin/article/details/73485545
https://harttle.land/2016/12/30/cors-redirect.html#header-2

**如何进行排查的**：

1. 每天的首次进入耗时会比较大
2. 小程序可能会缓存 index.html 一开始 ci 的发布不是增量发布的。后续修改为增量发布
3. 偶现接口耗时巨大，但是业务部分的中间件耗时统计显示并不高，排查问题，可能是打点节点跟业务接口同域名导致 ？需要测试一下。打点接口不需要过移动网关

#### 移动端

1. 分：多个移动端 h5 页面，业务分开，独立开发部署，业务逻辑不会互相影响，复用度不够，重复开发。
2. 合：新技术栈 vue 引入，组件库，拖拽、可视化搭建开始，建立 schema 规范，模块化渲染。时间和人力，可视化搭建部分暂缓。重用逻辑增多。
3. 分：多个业务模块分开，抽离组件库、渲染器
4. 合：可视化搭建的形态， 重复模块搭建 + 微前端形式。

## 5. 能效工具

- cli 脚手架
- utils 工具库

#### 组件库

1. pc
2. h5

- 腾讯云风格的业务组件库
- 包装 ant d 的业务组件库
  - 组件直接显示在文档上的模块
  - webpack 自动 loader ？
- 内部开源 TDesign

#### table 组件

高性能的移动端 table

1.  固定宽 固定列，自适应宽度等
2.  大列表滑动
3.  性能渲染

说明白 oteam table

### 打造易用的前端工作台

提升前端工作效率

能力沉淀 = sdk 化 （npm 包）

真实环境环境自助调试接口 + JSAPI 验证 （大家的依赖如何降到最低，不仅仅是前端等后台，还有后台等前端，如何为后台做一个易用的接口调试工具）

### 提升前端的生产力

提高开发速度，快速上线

能做的事情：

1. 组件的复用
2. 一套代码多段运行
   1. 多端的开放能力对齐
   2. 统一的 js sdk
   3. 多端的接口统一

#### plugin

1. 监控： tam/sentry
2. common report
3. mixins beforeEntry

#### 密码下发方案的思考

1. 以前项目都是不开源，直接写在 node 项目中的 env 文件中即可。
2. 要求项目内源，将密码放到配置中心，通过 secretKey 去拉取配置中心的配置，拿到配置之后再启动 node 项目。
   1. 看起来没有问题，但是 secretKey 是直接写在代码中的，项目开源了，等于秘钥信息别人直接能拿到，数据库密码不安全 。
3. 通过 CI/CD 每次编译项目时，将配置文件下发到机器上，node 项目再去读取，一起打包进 docker 中

#### axios 取消

https://segmentfault.com/a/1190000021290514

同一个模块的同一个请求何时取消

## 背景

### 数据平台中心

1. 平台整个工作链路
2. 介绍高管驾驶舱

平台：

1. 报表
2. 工作表
3. 维表
4. 仪表盘 PC/Mobile

数据应用：

1. 驾驶舱
2. 行业经分
3. 产品分析
4. 客户分析
5. 销售看板
6. 月度经营分析等。。

数据工具：

1. 数据资产
2. 小程序
3. 仪表盘移动端

前端库包：

1. cdata-cli
2. cdata-utils
3. material
4. t1
5. cdata-bot
6. cdata-plugin

组件库：

1. vue 组件库， pc + mobile

## 开源

1. omi/omiv
2. cloudbase-framework 框架
3. generate-vuex
4. tdesign oteam table
5. 监控 oteam
6. qcmagic 的思想， qcvue emonitor qcmagic 提交一定的 pr
7. fre

### omi/omiv

- omiv 的实现
- omi 的原理与实现

### generateVuex

- 自动写入的 setMutations
- 状态机

vuex helper 参考:

能够自动导入的

https://github.com/vuetifyjs/vuetify/blob/master/packages/vuetifyjs.com/src/store/modules/index.js
