---
title: low code
date: 2020-11-21
draft: true
---

# low code

要有价值才做，而不是为了能做而做!!!

1. 为什么要有这个东西？ 背景是什么
2. 怎么做的
3. 中间遇到了什么问题，怎么解决的
4. 成果是什么

## 是什么？

这是一种针对收入数据多场景、多维度看板的数据可视化 low code 配置的解决方案。

## 为什么要做 low code 这个解决方案？

1. pc 仪表盘项目很老，虽然也提供了响应式的移动端页面，但是因为是老项目，组件不够丰富（满足不了新的功能需求），历史包袱重。汇报看板这种对时间要求高的需求，仪表盘的迭代速度跟不上。
2. 权限颗粒度问题，老的仪表盘权限颗粒度只到了表级别，如果希望有更新的颗粒度，比如行权限，经过评估改造成本大， 也怕会影响其他现有的表。
3. pc 仪表盘功能丰富，存在大量的其他模块的代码，汇报看板用它显得很重。更希望有轻量级的应用，来快速迭代，并往可搭建、low code 的方向去做，以此来节省开发的人力。

因此，继续一个权限管控更细，迭代更快，开发更灵活的方案来做这个事。

## 服务对象

1. 腾讯云各个中心的 leader/GM, 以及更上面的老板。
2. 销售
3. （其他中心的）产品经理

## 配置

### 1. ui 前端组件渲染

属性名：

- is
- props
- on
- `$attrs`
- `$listener`
- children

关键词：

- JSX
- 可视化搭建
- 组件传参

### 2. dataOptions 取数逻辑

属性名：

- WorksheetId 工作表 id
- Config 小计
- Order 排序
- Fields 字段筛选。 默认会拉出全部的字段，做字段筛选的。
- Filters 值筛选
- Variables 筛选和小计 ？

关键词：

- Id 映射到实际的表名
- Node 开发完成之后给到一份协议文档

## 前端

要点：

1. 沉淀组件库
2. markdown-demo-loader
3. 如何提高组件、项目开发环境的编译速度。

关键词：

1. jsx + vue + config
2. 动态 component + is 标签渲染组件，传入 dataSource 渲染图块
3. Module 层包裹 Component 层，拥有 loadData 的行为，在指定时机触发取数操作。另外根据 dataOptions 中的 handler 函数名，在取数回来之后，对数据做加工处理，供 Component 层做直接渲染。
   1. Module 也可以包裹多个 Component，用于多个相同组件共享一份渲染数据。
   2. Table, Line, List 组件所需的数据结构是不同的，需要做额外的处理。这部分的逻辑最开始是写在 Module 组件的 Methods 中，不过这部分与业务逻辑几乎无关，已经在慢慢处理成 npm 包的形式了，一是便于单元测试，而是便于很方便的移植到 node BFF 层去。
   3. Module 层设计了一些钩子函数:
      1. onShow 判断组件是否可见，如果不可见的话，就不会继续后面的钩子。
      2. beforeLoad 会根据 dataOptions 中的传参，在发请求之前处理一下请求参数 options
      3. loaded 已经触发的取数操作，一般会在这里做数据的规范化， 处理 rowData 成为 dataSource
      4. error 会将 error 传到上层组件中做统一处理。
   4. 如果通用的配置和数据函数还是不能满足，或者统一在 Module 出配置不够灵活的话，每一个 Component 其实可以自定义补充一些处理函数，或者是自定义事件。
4. Modules 层会包裹多个 Module。Tabbars, Tabs 会包裹 Modules 组成一个个的看板。 同时这几个模块都是继承 Module 的，都拥有这些钩子和取数能力。
5. 筛选条件一类的组件，没有取数逻辑，只会触发事件， 或者在组件设计的时候，我们会考虑受控和非受控。非受控简单理解为，没有传值和事件进去，也能够正常工作，而受控则需要额外传入属性和事件才可以工作。一般会考虑设计成受控的，在 vue 的 jsx 中，需要重新通配 vModel 的能力，也就是给大多数筛选组件都定义 model 自定义表单。来控制 Module/Modules 级别的 state.

## （前端）难点

主要一块还是在数据通信。 因为换了几波产品经理、几波设计，会有多种场景的数据交互：

1. 一个页面多个图表，公用同一个数据源，同一个筛选条件，也可能不同的筛选条件
2. 多个页面共享一个筛选条件
3. 同个页面，有多个触发重新取数的操作。
4. 针对上面的几种公用数据的场景，存在：
   1. vuex 传统的使用方式会不够领会
   2. vue bus 在一定场景下面，会更灵活好用
5. 数据的权限控制，沉淀了另一个平台：数据资产平台。
6. 每个月固定跑数，一开始需要人工打开配置开关。
   1. 配置中心配置。 开发得到产品的指令， 手动配置。 开关开启、关闭，开发会对线上环境负责。
   2. 工作表配置。 project 颗粒度的权限，交给产品自己配置。产品权限太大， 不会关注、测试所有的模块，这是一个隐患。
   3. 上面都是人工手动进行修改。 这边是希望能够跟企业微信机器人打通，通过 api 的形式去处理。

## 开发流程

1. 总的一个配置文件。 一份配置文件，对应一个 App
2. auth 接口登录， 拉取 tabs, tabbars 的权限，从 App Config 中筛选拼接出当前角色的 Config
3. 动态注册路由，addRoute。 其他的前端项目一般会考虑，全部路由都注册， 但是通过 router 的 meta 携带参数来判断页面是否有权限。 这样子，前后端都需要维护一份角色、权限的配置信息。 另外一个用户可能包含多个角色，每次做一次筛选也不方便。这样做至少只需要维护一份权限配置即可。
4. atomConfig to chart

### 数据来源

1. 计费平台的流水表， 例如 cos 100 元，200 元等
2. 数仓的同学，处理 tdw， 写 Python 脚本开发 日表、月表、季表等
3. 数仓同学最终会通过洛子任务，将数据出库到结果库中，这里就是数仓的主题层？结果库中包含很多其他的数据库，例如：
   1. mysql
   2. clickHouse
   3. PG
   4. ...
4. 工程组这里会拿一些宽表，做一些拼接，比如补充说明之类的，或者多表关联，这是在线的工作表做的事情。当然，针对一份数据宽表，因为数据的隐私性，需要加入行权限，那这里的权限筛选也是在工作表（这个服务中）处理的。 所谓的权限筛选，其实在真正的结果数据中，是不存在的。
   1. 权限的定义和维护，需要依赖另一个平台，定义了角色和权限点的概念。维护了一位同事与角色之间的关联关系。
   2. 表结构的基本样子：
      1. ftime
      2. gid
      3. cid
      4. uin
      5. productionName
      6. companyName
      7. ...
   3. 对于同一张宽表，以客户维度筛选、或者以公司维度筛选，如果处理成多个接口，肯定是不划算的。这里只需要通过不同的传参，来小计某一列即可。就可以做到搜 cid, gid 级别。TODO: 小计？？？
      1. sum ？
      2. with rollup ？

## Node 逻辑

取数粘合层。

1. 拼接图块的数据筛选条件， 配置指定筛选、过滤出的字段信息。
2. 对当前表数据做权限筛选， AuthFilters
3. 将条件拼接之后，执行动态 SQL 获取数据结果；或者将条件转化为底层元数据取数（多种数据库类型的抹平层）所需的条件，最终获取数据。

### 拼接图筛选条件

1. 权限点
2. select xxx from yyy where
   1. Filters
   2. Config
   3. Variables
   4. Fields
   5. WorksheetId

## 维度

- 产品
- 客户
- ...

### 表命名

- 收入明细表
- 毛利表
- top 损益
- top 收入客户等

## 优点

1. 开发更快
2. 开发流程更快，各部分人力沟通成本小，各方面工作量都减少了。

## 不足

1. 开发环境下，可能就是这么直接用 Node 从结果库中取数据了。 一般如果宽表不是很大的话，速度慢的没有那么明显，但是如果没有优先处理好输出，直接这样拿出来的数据就会很大。
2. 部分接口是实时 SQL， 目前的缓存策略，较为暴力。
3. 取数任务服务会经过 redis 缓存，定时任务 mock 角色来预加载缓存，但是因为页面越来越多，定时任务 mock 所有角色跑所有页面的数据也不是很科学，未命中 cache 的话， 速度就会很慢。优化措施如下：
   1. 底表接着分库分表。
4. 开发环境下， 无法做到颗粒度很细的 render ？？？ 常常因为修改了一个图块的配置信息，而导致整个页面都重新加载了。

## 渲染加速

1. 虚拟列表
2. 数据懒加载
