---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

## HTML

### 语义化

页面能够结构化，爬虫能够更好的解析，利于开发者的维护，视障人士专用的阅读器适配等

### 标签

- header
- content
- footer
- aside
- video
- canvas
- ...

### 内核

- chrome
  - 排版引擎 Blink
  - js 引擎 v8
- Safari
  - 排版引擎 Webkit
- IE
  - 排版引擎 Trident

IE 内核浏览器识别：<!--[if IE]><![endif]-->
非 IE 内核浏览器识别：<!--[if !IE]><![endif]-->

### 储存

- sessionStorage
- localStorage
- cookie
  - 跨域 cookie ajax 请求用 withCred
  - 一般的登录态设置： 登录态失效，接口返回 401 （未授权 ？） 然后重定向（有主动重定向也有自动重定向的），302 重定向到登录页面，登录成功之后 302 回原来的地址，此时返回的请求头里面会有 set-Cookie 设置 cookie 域名和有效时间等
  - http-only 设置了之后 js 不能获取到
  - 单个最大 4k 左右
  - 一个网站的 cookie 一般最多 20 个左右
- session(误) 存服务端

### script 的异步加载？

### script 的模块化 ？

### js 加载阻塞 ？

### Doctype

- 放大缩小

### 请指出 document load 和 document ready 的区别

### 浏览器的冒泡、捕获

### js 的事件循环机制

- 宏事件
- 微事件

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去，当执行栈为空的时候，主线程会首先查看微任务中的事件，如果微任务不是空的那么执行微任务中的事件，如果没有在宏任务中取出最前面的一个事件。把对应的回调加入当前执行栈...如此反复，进入循环。

macro-task(宏任务)

setTimeout
setInterval
setImmediate

micro-task(微任务)

Promise
process.nextTick

### 模块化

模块化解决了前端的哪些痛点
命名冲突
文件依赖
代码复用

## CSS

- margin 的合并
- 高度塌陷的问题，如何解决
- 水平居中、垂直居中 transform
- 盒模型
- bfc
- 相对定位、绝对定位
- flex 布局
- fixed 是相对谁定位 如果加上 transform 会出现问题吗
- 伪类的作用
- 纯 css 换行
- 媒体查询
- 响应式布局如何做 ？

### 单位

rem em px 单位的区别。 em 相对于父元素，rem 相对于根元素。

- %
- vh vw
- rem
- em
- px
- rpx

### reset

重置不同浏览器不同的自带样式，统一处理

### 盒模型

```
box-sizing: border-box
box-sizing: content-box
```

## 合集

- HTML5 为什么只写 <!DOCTYPE html>
- data- 属性的作用？
- <img> 的 title 和 alt 有什么区别？
- meta 有哪些常见的值？
- meta viewport 是做什么用的，怎么写？

CSS 加载方式有几种？

2. @import 有什么作用？如何使用
3. 6. 简述 src 和 href 的区别？
4. 页面导入时，使用 link 和 @import 有什么区别？

- 自定义字体、自定义 icon svg 导入？

伪类选择器有哪些？

2. 伪元素和伪类的区别？
   选择器的优先级是如何计算的？
3. 什么是 CSS 继承？哪些属性能继承，哪些不能？

- dpi 怎么计算 ？
- 1px ？
- 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例？
- line-height: 2; 和 line-height: 200%; 有什么区别?
- 让一个元素“看不见”有几种方式？有什么区别？

2. 单行文本溢出加 ... 如何实现？
   浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响？
3. 清除浮动指什么？如何清除浮动？两种以上方法
4. 有几种定位方式？分别是如何实现定位的？参考点是什么？使用场景是什么？
5. z-index 有什么作用？如何使用？
6. BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明。
7. 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例？

- CSS3 Animation 渲染？ css3 动画
- 水平居中 垂直居中

- 常见兼容性问题？
  - 火狐浏览器的事件 event
- flex 布局常见的效果？

js 严格模式

- 0.2+0.1==0.3
- JavaScript 定义了几种数据类型？哪些是原始类型？哪些是复杂类型？null 是对象吗？
- 箭头函数？的 this
- Object.defineProperty 与 proxy 的区别
- null 和 undefined 有什么区别么
- Flex 实现两列布局 - flex-basis ？
- 事件委托有什么优点（
- target/currentTarget/relateTarget

### promise

Promise 对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。

### flex

设为 flex 属性之后，子元素的哪些属性会失效
float、clear 和 vertical-align

### 定位

绝对定位

一旦给元素加上 absolute 或 float 就相当于给元素加上了 display:block
absolute 元素覆盖正常文档流内元素（不用设 z-index，自然覆盖）
可以减少重绘和回流的开销（如 absolute+ top:-9999em，或 absolute + visibility:hidden，将动画效果放到 absolute 元素中）

属性介绍

static，默认值。位置设置为 static 的元素，它始终会处于文档流给予的位置。
inherit，规定应该从父元素继承 position 属性的值。但是任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。
fixed，生成绝对定位的元素。默认情况下，可定位于相对于浏览器窗口的指定坐标。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。不论窗口滚动与否，元素都会留在那个位置。但当祖先元素具有 transform 属性且不为 none 时，就会相对于祖先元素指定坐标，而不是浏览器窗口。
absolute，生成绝对定位的元素，相对于距该元素最近的已定位的祖先元素进行定位。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。
relative，生成相对定位的元素，相对于该元素在文档中的初始位置进行定位。通过 “left”、”top”、”right” 以及 “bottom” 属性来设置此元素相对于自身位置的偏移。

### 首屏加速

Vue-Router 路由懒加载（利用 Webpack 的代码切割）
使用 CDN 加速，将通用的库从 vendor 进行抽离
Nginx 的 gzip 压缩
Vue 异步组件
服务端渲染 SSR
如果使用了一些 UI 库，采用按需加载
Webpack 开启 gzip 压缩
如果首屏为登录页，可以做成多入口
Service Worker 缓存文件处理
使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

- 前端浏览器输入 URL 后发生什么

### 性能优化

- 图片懒加载
- 合并 http 请求

### 其他

- url 渲染的整个过程
- 浏览器强缓存和协商缓存的理解
  - expires 时间点
  - cache-control: max-age=3600
  - 优先级： cache-control > expires > ETag (If-None-match) > last-modified (If-Modified-Since)

### CORS (Cross Origin Resource Sharing)

Access-Control-Allow-Origin
Access-Control-Allow-Credentials
Methods
Headers

简单请求
非简单请求

### 25.说说浏览器和 Node 事件循环的区别

其中一个主要的区别在于浏览器的 event loop 和 nodejs 的 event loop 在处理异步事件的顺序是不同的,nodejs 中有 micro event;其中 Promise 属于 micro event 该异步事件的处理顺序就和浏览器不同.nodejs V11.0 以上 这两者之间的顺序就相同了.

为楼上补充一个例子

原文出自[liubasara 的个人博客](https://blog.liubasara.info/#/post/分享node与浏览器关于eventLoop的异同的一个小例子)

```js
function test() {
  console.log('start');
  setTimeout(() => {
    console.log('children2');
    Promise.resolve().then(() => {
      console.log('children2-1');
    });
  }, 0);
  setTimeout(() => {
    console.log('children3');
    Promise.resolve().then(() => {
      console.log('children3-1');
    });
  }, 0);
  Promise.resolve().then(() => {
    console.log('children1');
  });
  console.log('end');
}

test();

// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)
// start
// end
// children1
// children2
// children3
// children2-1
// children3-1

// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)
// start
// end
// children1
// children2
// children2-1
// children3
// children3-1
```

### 28.cookie 和 token 都存放在 header 中，为什么不会劫持 token？

1. 首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；
2. CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token

### 22.介绍下重绘和回流（Repaint & Reflow），以及如何进行优化

#### 1. 浏览器渲染机制

- 浏览器采用流式布局模型（`Flow Based Layout`）
- 浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了渲染树（`Render Tree`）。
- 有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
- 由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，**但`table`及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一**。

#### 2. 重绘

由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如`outline`, `visibility`, `color`、`background-color`等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。

#### 3. 回流

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。

```js
<body>
  <div class="error">
    <h4>我的组件</h4>
    <p>
      <strong>错误：</strong>错误的描述…
    </p>
    <h5>错误纠正</h5>
    <ol>
      <li>第一步</li>
      <li>第二步</li>
    </ol>
  </div>
</body>
```

在上面的 HTML 片段中，对该段落(`` 标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（`div.error`和`body` – 视浏览器而定）。此外， ``和``也会有简单的回流，因为其在 DOM 中在回流元素之后。**大部分的回流将导致页面的重新渲染。**

**回流必定会发生重绘，重绘不一定会引发回流。**

#### 4. 浏览器优化

现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你**获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值**。

主要包括以下属性或方法：

- `offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`
- `scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`
- `clientTop`、`clientLeft`、`clientWidth`、`clientHeight`
- `width`、`height`
- `getComputedStyle()`
- `getBoundingClientRect()`

所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。

#### 5. 减少重绘与回流

1. CSS

   - **使用 `transform` 替代 `top`**

   - **使用 `visibility` 替换 `display: none`** ，因为前者只会引起重绘，后者会引发回流（改变了布局

   - **避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

   - **尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。

   - **避免设置多层内联样式**，CSS 选择符**从右往左**匹配查找，避免节点层级过多。

     ```js
     <div>
       <a> <span></span> </a>
     </div>
     <style>
       span {
         color: red;
       }
       div > a > span {
         color: red;
       }
     </style>
     ```

     对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 `span` 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 `span` 标签，然后找到 `span` 标签上的 `a` 标签，最后再去找到 `div` 标签，然后给符合这种条件的 `span` 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写**过于具体**的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证**层级扁平**。

   - **将动画效果应用到`position`属性为`absolute`或`fixed`的元素上**，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 `requestAnimationFrame`，详见[探讨 requestAnimationFrame](https://github.com/LuNaHaiJiao/blog/issues/30)。

   - **避免使用`CSS`表达式**，可能会引发回流。

   - **将频繁重绘或者回流的节点设置为图层**，图层能够阻止该节点的渲染行为影响别的节点，例如`will-change`、`video`、`iframe`等标签，浏览器会自动将该节点变为图层。

   - **CSS3 硬件加速（GPU 加速）**，使用 css3 硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘 。但是对于动画的其它属性，比如`background-color`这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

2. JavaScript

   - **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
   - **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
   - **避免频繁读取会引发回流/重绘的属性**，如果确实需要多次使用，就用一个变量缓存起来。
   - **对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流。
