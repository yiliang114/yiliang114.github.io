---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

## 浏览器的事件

### 事件冒泡中 ​this 和 event.target 的区别?

js 中事件是会冒泡的，所以 this 是可以变化的，但 event.target 不会变化，它永远是直接接受事件的目标 DOM 元素；

### js 如何自定义事件？

1. 使用 new Event()
   获取不到 event.detail

```js
let btn = document.querySelector('#btn');
let ev = new Event('alert', {
  bubbles: true, //事件是否冒泡;默认值false
  cancelable: true, //事件能否被取消;默认值false
  composed: false,
});
btn.addEventListener(
  'alert',
  function(event) {
    console.log(event.bubbles); //true
    console.log(event.cancelable); //true
    console.log(event.detail); //undefined
  },
  false,
);
btn.dispatchEvent(ev);
```

2. 使用 createEvent('CustomEvent') (DOM3)

要创建自定义事件，可以调用 createEvent('CustomEvent')，返回的对象有 initCustomEvent 方法，接受以下四个参数:

type: 字符串，表示触发的事件类型，如此处的'alert'
bubbles: 布尔值： 表示事件是否冒泡
cancelable: 布尔值，表示事件是否可以取消
detail: 任意值，保存在 event 对象的 detail 属性中

```js
let btn = document.querySelector('#btn');
let ev = btn.createEvent('CustomEvent');
ev.initCustomEvent('alert', true, true, 'button');
btn.addEventListener(
  'alert',
  function(event) {
    console.log(event.bubbles); //true
    console.log(event.cancelable); //true
    console.log(event.detail); //button
  },
  false,
);
btn.dispatchEvent(ev);
```

3. 使用 new customEvent() (DOM4)
   使用起来比 createEvent('CustomEvent') 更加方便

```js
var btn = document.querySelector('#btn');
/*
 * 第一个参数是事件类型
 * 第二个参数是一个对象
 */
var ev = new CustomEvent('alert', {
  bubbles: 'true',
  cancelable: 'true',
  detail: 'button',
});
btn.addEventListener(
  'alert',
  function(event) {
    console.log(event.bubbles); //true
    console.log(event.cancelable); //true
    console.log(event.detail); //button
  },
  false,
);
btn.dispatchEvent(ev);
```

扩展： 自定义非 DOM 事件(观察者模式)
EventTarget 类型有一个单独的属性 handlers，用于存储事件处理程序（观察者）。
addHandler() 用于注册给定类型事件的事件处理程序；
fire() 用于触发一个事件；
removeHandler() 用于注销某个事件类型的事件处理程序

```js
function EventTarget() {
  this.handlers = {};
}

EventTarget.prototype = {
  constructor: EventTarget,
  addHandler: function(type, handler) {
    if (typeof this.handlers[type] === 'undefined') {
      this.handlers[type] = [];
    }
    this.handlers[type].push(handler);
  },
  fire: function(event) {
    if (!event.target) {
      event.target = this;
    }
    if (this.handlers[event.type] instanceof Array) {
      const handlers = this.handlers[event.type];
      handlers.forEach(handler => {
        handler(event);
      });
    }
  },
  removeHandler: function(type, handler) {
    if (this.handlers[type] instanceof Array) {
      const handlers = this.handlers[type];
      for (var i = 0, len = handlers.length; i < len; i++) {
        if (handlers[i] === handler) {
          break;
        }
      }
      handlers.splice(i, 1);
    }
  },
};
//使用
function handleMessage(event) {
  console.log(event.message);
}
//创建一个新对象
var target = new EventTarget();
//添加一个事件处理程序
target.addHandler('message', handleMessage);
//触发事件
target.fire({ type: 'message', message: 'Hi' }); //Hi
//删除事件处理程序
target.removeHandler('message', handleMessage);
//再次触发事件，没有事件处理程序
target.fire({ type: 'message', message: 'Hi' });
```

### onchange 是怎么触发的？

当 input 捕获到焦点后，系统储存当前值，当 input 焦点离开后，判断当前值与之前存储的值是否不等，如果为 true 则触发 onchange 事件。非 ie 敲回车也可以实现触发

### 事件、IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？

1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
2. 事件处理机制：IE 是事件冒泡、firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；
3. ev.stopPropagation();注意旧 ie 的方法 ev.cancelBubble = true;

## 事件概念

### JavaScript 实现异步编程的方法？

- 回调函数
- 事件监听
- 发布/订阅
- Promises 对象
- Async 函数[ES7]

### 异步任务

- setTimeOut、setInterval
- DOM 事件
- Promise

### 关于 setTimeOut、setImmediate、process.nextTick()的比较

#### setTimeout()

将事件插入到了事件队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。
当主线程时间执行过长，无法保证回调会在事件指定的时间执行。
浏览器端每次 setTimeout 会有 4ms 的延迟，当连续执行多个 setTimeout，有可能会阻塞进程，造成性能问题。

#### setImmediate()

事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行。和 setTimeout(fn,0)的效果差不多。
服务端 node 提供的方法。浏览器端最新的 api 也有类似实现:window.setImmediate,但支持的浏览器很少。

#### process.nextTick()

插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。
大致流程：当前”执行栈”的尾部–>下一次 Event Loop（主线程读取”任务队列”）之前–>触发 process 指定的回调函数。
服务器端 node 提供的办法。用此方法可以用于处于异步延迟的问题。
可以理解为：此次不行，预约下次优先执行。

### 介绍 DOM0，DOM2，DOM3 事件处理方式区别

- DOM0 级事件处理方式：
  - `btn.onclick = func;`
  - `btn.onclick = null;`
- DOM2 级事件处理方式：
  - `btn.addEventListener('click', func, false);`
  - `btn.removeEventListener('click', func, false);`
  - `btn.attachEvent("onclick", func);`
  - `btn.detachEvent("onclick", func);`
- DOM3 级事件处理方式：
  - `eventUtil.addListener(input, "textInput", func);`
  - `eventUtil` 是自定义对象，`textInput` 是 DOM3 级事件

### 在一个 DOM 上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？

- 该 DOM 上的事件如果被触发，会执行两次（执行次数等于绑定次数）
- 如果该 DOM 是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获
- 如果该 DOM 是处于事件流中的非目标元素，则先执行捕获，后执行冒泡

### 事件的代理/委托

- 事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件
  - 优点：
    - 可以减少事件注册，节省大量内存占用
    - 可以将事件应用于动态添加的子元素上
  - 缺点：
    使用不当会造成事件在不应该触发时触发
  - 示例：

```
ulEl.addEventListener('click', function(e){
    var target = event.target || event.srcElement;
    if(!!target && target.nodeName.toUpperCase() === "LI"){
        console.log(target.innerHTML);
    }
}, false);
```

### W3C 事件的 target 与 currentTarget 的区别？

- target 只会出现在事件流的目标阶段
- currentTarget 可能出现在事件流的任何阶段
- 当事件流处在目标阶段时，二者的指向相同
- 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)

### 如何派发事件(dispatchEvent)？（如何进行事件广播？）

- W3C: 使用 dispatchEvent 方法
- IE: 使用 fireEvent 方法

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return !element.dispatchEvent(mockEvent);
  }
};
```

**DOM 事件模型**

> `DOM`事件模型讲的就是**捕获和冒泡**，一般人都能回答出来。

- 捕获：从上往下。
- 冒泡：从下（目标元素）往上。

**DOM 事件流**

> `DOM`事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。

**完整的事件流，分三个阶段：**

1. 捕获：从 `window` 对象传到 目标元素。
2. 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。
3. 冒泡：从**目标元素**传到 `Window` 对象。

![](http://img.smyhvae.com/20180306_1058.png)

![](http://img.smyhvae.com/20180204_1218.jpg)

**描述 DOM 事件捕获的具体流程**

> 很少有人能说完整。

**捕获的流程**

![](http://img.smyhvae.com/20180306_1103.png)

**说明**：捕获阶段，事件依次传递的顺序是：`window` --> `document` --> `html`--> `body` --> 父元素、子元素、目标元素。

- PS1：第一个接收到事件的对象是 **window**（有人会说`body`，有人会说`html`，这都是错误的）。
- PS2：`JS`中涉及到`DOM`对象时，有两个对象最常用：`window`、`doucument`。它们俩也是最先获取到事件的。

代码如下：

```js
window.addEventListener(
  'click',
  function() {
    alert('捕获 window');
  },
  true,
);

document.addEventListener(
  'click',
  function() {
    alert('捕获 document');
  },
  true,
);

document.documentElement.addEventListener(
  'click',
  function() {
    alert('捕获 html');
  },
  true,
);

document.body.addEventListener(
  'click',
  function() {
    alert('捕获 body');
  },
  true,
);

fatherBox.addEventListener(
  'click',
  function() {
    alert('捕获 father');
  },
  true,
);

childBox.addEventListener(
  'click',
  function() {
    alert('捕获 child');
  },
  true,
);
```

**补充一个知识点：**

> 在 `js`中：

- 如果想获取 `body` 节点，方法是：`document.body`；
- 但是，如果想获取 `html`节点，方法是`document.documentElement`。

**冒泡的流程**

> 与捕获的流程相反

**Event 对象的常见 api 方法**

> 用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过`Event`对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：

**方法一**

```js
event.preventDefault();
```

- 解释：阻止默认事件。
- 比如，已知`<a>`标签绑定了 click 事件，此时，如果给`<a>`设置了这个方法，就阻止了链接的默认跳转。

**方法二：阻止冒泡**

> 这个在业务中很常见。

> 有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件`A`，单击父元素做事件 B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件`A`。这个时候，就要用到阻止冒泡了。

> `w3c`的方法：（火狐、谷歌、`IE11`）

```js
event.stopPropagation();
```

> `IE10`以下则是：

```js
event.cancelBubble = true;
```

> 兼容代码如下：

```js
box3.onclick = function(event) {
  alert('child');

  //阻止冒泡
  event = event || window.event;

  if (event && event.stopPropagation) {
    event.stopPropagation();
  } else {
    event.cancelBubble = true;
  }
};
```

> 上方代码中，我们对`box3`进行了阻止冒泡，产生的效果是：事件不会继续传递到 `father`、`grandfather`、`body`了。

**方法三：设置事件优先级**

```js
event.stopImmediatePropagation();
```

这个方法比较长，一般人没听说过。解释如下：

> 比如说，我用`addEventListener`给某按钮同时注册了事件`A`、事件`B`。此时，如果我单击按钮，就会依次执行事件 A 和事件`B`。现在要求：单击按钮时，只执行事件 A，不执行事件`B`。该怎么做呢？这是时候，就可以用到`stopImmediatePropagation`方法了。做法是：在事件 A 的响应函数中加入这句话。

> 大家要记住 `event` 有这个方法。

**属性 4、属性 5（事件委托中用到）**

```js
event.currentTarget; //当前所绑定的事件对象。在事件委托中，指的是【父元素】。
event.target; //当前被点击的元素。在事件委托中，s
```

上面这两个属性，在事件委托中经常用到。

> **总结**：上面这几项，非常重要，但是容易弄混淆。

**自定义事件**

> 自定义事件的代码如下：

```js
var myEvent = new Event('clickTest');
element.addEventListener('clickTest', function() {
  console.log('smyhvae');
});

//元素注册事件
element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest
```

> 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：

```js
var myEvent = new Event('clickTest');

element.addEventListener('clickTest', function() {
  console.log('smyhvae');
});

setTimeout(function() {
  element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest
}, 1000);
```

### IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？

IE 只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获。

阻止冒泡：

- 取消默认操作
  - w3c 的方法是 e.preventDefault()
  - IE 则是使用 e.returnValue = false;
- return false
  - javascript 的 return false 只会阻止默认行为
  - 是用 jQuery 的话则既阻止默认行为又防止对象冒泡。
- 阻止冒泡
  - w3c 的方法是 e.stopPropagation()
  - IE 则是使用 e.cancelBubble = true

```js
function stopHandler(event)
  window.event
  ? window.event.cancelBubble = true
  : event.stopPropagation();
}
```

### 简要介绍事件代理，以及什么时候使用，事件代理发生在事件处理流程的哪个阶段，有什么好处？

事件代理就是说我们将事件添加到本来要添加事件的父节点，将事件委托给父节点来触发处理函数，这通常会在
这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加
点击事件，这时可以使用事件代理，通过判断 e.target.nodeName 来判断发生的具体元素，从而判断是否是在
列表项中触发，这样的好处是可以减少事件绑定，同时动态的 DOM 结构仍然可以监听。事件代理发生在冒泡阶段。

### addEventListener 有哪些参数？

有三个参数，第一个是事件的类型，第二个是事件的回调函数，第三个是一个表示事件是冒泡阶段还是捕获阶段捕获的布尔值，true 表示捕获，false 表示冒泡

- browser Event
  ![](http://media.zhijianzhang.cn//file/2018/11/121062e1d2054e9d942cebe57ca14ea6_image.png)

  ```js
  window.event; // 事件什么时候能够使用 ？
  ```

### 浏览器事件代理机制的原理是什么？

事件代理又称为事件委托，在祖先级 DOM 元素绑定一个事件，当触发子孙级 DOM 元素的事件时，利用事件冒泡的原理来触发绑定在祖先级 DOM 的事件。因为事件会从目标元素一层层冒泡至 document 对象

为什么要事件代理？

1. 添加到页面上的事件数量会影响页面的运行性能，如果添加的事件过多，会导致网页的性能下降。采用事件代理的方式，可以大大减少注册事件的个数。
   事件代理的当时，某个子孙元素是动态增加的，不需要再次对其进行事件绑定。
2. 不用担心某个注册了事件的 DOM 元素被移除后，可能无法回收其事件处理程序，我们只要把事件处理程序委托给更高层级的元素，就可以避免此问题

当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。

```js
var delegate = function(client, clientMethod) {
  return function() {
    return clientMethod.apply(client, arguments);
  };
};
var agentMethod = delegate(client, clientMethod);
agentMethod();
```

事件绑定和普通事件有什么区别
IE 和 DOM 事件流的区别

- 什么是事件循环 (event loop)？
  - 请问调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？

### 说说事件流吧

事件流分为两种，捕获事件流和冒泡事件流。
捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点。
冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点。

DOM 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段。
