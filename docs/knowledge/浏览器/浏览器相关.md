---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### input 输入框的事件， blur focus change input keyup 等

### 一个图片 url 访问后直接下载是怎么样实现的

### 实现顶面的局部刷新

### 一个图片列表，一张一张加载，检测到上一张加载完成后再切换下一张

### formdata 的了解

### 简述如何实现一个模块加载器,实现类似 require.js 的基本功能(实现的思路)

### Post 一个 file 的时候 file 放在哪的?

### 为何你会使用 `load` 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？

### HTMLEncode 通常在哪个阶段做,可以被破解吗?

### 请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别？

### div 两个 button div 上事件代理，如何判断点击的是哪一个 button

### 原生 JS 的 window.onload 与 Jquery 的\$(document).ready(function(){})有什么不同？如何用原生 JS 实现 Jq 的 ready 方法？

window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。

\$(document).ready()是 DOM 结构绘制完毕后就执行，不必等到加载完毕。

- 传递函数给 whenReady()
- 当文档解析完毕且为操作准备就绪时，函数作为 document 的方法调用

  ```js
  var whenReady = (function() {
    //这个函数返回 whenReady()函数
    var funcs = []; //当获得事件时，要运行的函数
    var ready = false; //当触发事件处理程序时,切换为 true
    //当文档就绪时,调用事件处理程序
    function handler(e) {
      if (ready) return; //确保事件处理程序只完整运行一次

      //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好
      if (e.type === 'onreadystatechange' && document.readyState !== 'complete') {
        return;
      }

      //运行所有注册函数
      //注意每次都要计算funcs.length
      //以防这些函数的调用可能会导致注册更多的函数
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].call(document);
      }
      //事件处理函数完整执行,切换ready状态, 并移除所有函数
      ready = true;
      funcs = null;
    }
    //为接收到的任何事件注册处理程序
    if (document.addEventListener) {
      document.addEventListener('DOMContentLoaded', handler, false);
      document.addEventListener('readystatechange', handler, false); //IE9+
      window.addEventListener('load', handler, false);
    } else if (document.attachEvent) {
      document.attachEvent('onreadystatechange', handler);
      window.attachEvent('onload', handler);
    }
    //返回whenReady()函数
    return function whenReady(fn) {
      if (ready) {
        fn.call(document);
      } else {
        funcs.push(fn);
      }
    };
  })();
  ```

  如果上述代码十分难懂，下面这个简化版：

```js
function ready(fn) {
  if (document.addEventListener) {
    //标准浏览器
    document.addEventListener(
      'DOMContentLoaded',
      function() {
        //注销事件, 避免反复触发
        document.removeEventListener('DOMContentLoaded', arguments.callee, false);
        fn(); //执行函数
      },
      false,
    );
  } else if (document.attachEvent) {
    //IE
    document.attachEvent('onreadystatechange', function() {
      if (document.readyState == 'complete') {
        document.detachEvent('onreadystatechange', arguments.callee);
        fn(); //函数执行
      }
    });
  }
}
```

### JavaScript 的数据类型有哪些？如何准确的检测数据类型？symbol 是什么？有什么作用？

### document 中的`load`事件和`DOMContentLoaded`事件之间的区别是什么？

当初始的 HTML 文档被完全加载和解析完成之后，`DOMContentLoaded`事件被触发，而无需等待样式表、图像和子框架的完成加载。

`window`的`load`事件仅在 DOM 和所有相关资源全部完成加载后才会触发。

### 为什么要使用`load`事件？这个事件有什么缺点吗？你知道一些代替方案吗，为什么使用它们？

在文档装载完成后会触发`load`事件。此时，在文档中的所有对象都在 DOM 中，所有图像、脚本、链接和子框架都完成了加载。

DOM 事件`DOMContentLoaded`将在页面的 DOM 构建完成后触发，但不要等待其他资源完成加载。如果在初始化之前不需要装入整个页面，这个事件是使用首选。

### 为什么 JS 要放到 body 尾部？

如果 JS 需要绑定操作 DOM，那么放在 header 中如果处理不当就不会绑定到 DOM

**JS 引擎是独立于渲染引擎存在的。**我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。

浏览器之所以让 JS 阻塞其它的活动，是因为它不知道 JS 会做什么改变，担心如果不阻止后续的操作，会造成混乱。

结论：

- 如果 JS 在 header 中，浏览器会阻塞并等待 JS 加载完毕并执行
- 如果 JS 在 body 尾部，览器会进行一次提前渲染，从而提前首屏出现时间

### Javascript 无阻塞加载具体方式

- **将脚本放在底部。**`<link>`还是放在`head`中，用以保证在`js`加载前，能加载出正常显示的页面。`<script>`标签放在`</body>`前。
- **成组脚本**：由于每个`<script>`标签下载时阻塞页面解析过程，所以限制页面的`<script>`总数也可以改善性能。适用于内联脚本和外部脚本。

* **非阻塞脚本**：等页面完成加载后，再加载`js`代码。也就是，在`window.onload`事件发出后开始下载代码。
  （1）`defer`属性：支持 IE4 和`fierfox3.5`更高版本浏览器
  （2）动态脚本元素：文档对象模型（DOM）允许你使用 js 动态创建`HTML`的几乎全部文档内容。代码如下：

<br>

```html
<script>
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src = 'file.js';
  document.getElementsByTagName('head')[0].appendChild(script);
</script>
```

此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程。即使在 head 里（除了用于下载文件的 http 链接）。

### js 如何判断网页中图片加载成功或者失败

使用 onload 事件运行加载成功，使用 onerror 事件判断失败
