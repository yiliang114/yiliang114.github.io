---
title: '浏览器储存'
date: '2020-10-25'
draft: true
tags:
  - 浏览器
  - 前端
---

## Cookie

cookie 的跨域共享不是无条件的，即：请求和响应的 IP 完全不相同时，无法实现 cookie 共享，这就相当于 A 网站不能访问 B 网站的 cookie 一个道理。当请求发起方和接收方的域名（IP）完全一致，端口号不同时，浏览器是可以携带 cookie 的，也就是：服务器能接收到前端所传来的 cookie。

服务器通过设置`set-cookie`这个响应头，将 cookie 信息返回给浏览器，浏览器将响应头中的 cookie 信息保存在本地，当下次向服务器发送 HTTP 请求时，浏览器会自动将保存的这些 cookie 信息添加到请求头中。

通过 cookie，服务器就会识别出浏览器，从而保证返回的数据是这个用户的。

- 通过`set-cookie`设置
- 下次请求会自动带上
- 键值对，可设置多个

生命周期为只在设置的 cookie 过期之前一直有效，即使窗口或浏览器关闭。存储大小为 4k 左右，再长了会被截断。有个数限制（各个浏览器不同），一般不能超过 20 个。与服务器端通信：每次都会携带在 http 头中，**如果使用 cookie 保存过多数据就会带来性能问题。**

cookie 无法设置除当前域名或者其父域名之外的其他 domain。这个是浏览器出于对 cookie 的保护造成的，也就是 cookie 无法跨域设置。对于子域名也有如下规则，当前域名只能设置当前域名以及他的父域名，不能设置子域名。

### 属性

- max-age
  - 过期时间有多长
  - 默认在浏览器关闭时失效
- expires
  - 到哪个时间点过期
- secure
  - 表示这个 cookie 只会在 https 的时候才会发送
- HttpOnly
  - 设置后无法通过在 js 中使用 document.cookie 访问
  - 保障安全，防止攻击者盗用用户 cookie
- domain
  - 表示该 cookie 对于哪个域是有效的。

### 优点

极高的扩展性和可用性

1. 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。
2. 通过加密和安全传输技术（SSL），减少 cookie 被破解的可能性。
3. 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。
4. 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie。

### 缺点

`cookie`虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。

1. `Cookie`数量的限制。每个特定的域名下最多生成的个数有限制。 IE6 或更低版本最多 20 个 cookie, IE7 和之后的版本最后可以有 50 个 cookie, Firefox 最多 50 个 cookie, chrome 和 Safari 没有做硬性限制。
2. `IE`和`Opera` 会清理近期最少使用的`cookie`，`Firefox`会随机清理`cookie`。
3. `Cookie`长度的限制。每个 cookie 长度不能超过 4KB，否则会被截掉。
4. 安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。
5. 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。

### js 操作 cookie

domain 的设置，有两点要注意：

1. 在 setCookie 中省略 domain 参数，那么 domain 默认为当前域名。
2. domain 参数可以设置父域名以及自身，但不能设置其它域名，包括子域名，否则 cookie 不起作用。

那么 cookie 的作用域：cookie 的作用域是 domain 本身以及 domain 下的所有子域名。

```js
// 创建cookie
function setCookie(name, value, expires, path, domain, secure) {
  var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value);
  if (expires instanceof Date) {
    cookieText += '; expires=' + expires;
  }
  if (path) {
    cookieText += '; path=' + path;
  }
  if (domain) {
    cookieText += '; domain=' + domain;
  }
  if (secure) {
    cookieText += '; secure';
  }
  document.cookie = cookieText;
}
// 获取cookie
function getCookie(name) {
  var cookieName = encodeURIComponent(name) + '=';
  var cookieStart = document.cookie.indexOf(cookieName);
  var cookieValue = null;
  if (cookieStart > -1) {
    var cookieEnd = document.cookie.indexOf(';', cookieStart);
    if (cookieEnd == -1) {
      cookieEnd = document.cookie.length;
    }
    cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));
  }
  return cookieValue;
}
// 删除 cookie 方法  直接设置 0 的时间
function unsetCookie(name) {
  document.cookie = name + '= ; expires=' + new Date(0);
}
```

## Session

session 应用场景: 一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了 session。

- 存放在服务器的一种用来存放用户数据的类似 HashTable 的结构
- 浏览器第一次发送请求时，服务器自动生成了 HashTable 和 SessionID 来唯一标识这个 hash 表，并将 sessionID 存放在 cookie 中通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的 sessionID 随着 cookie 发送到服务器上，服务器从请求中提取 sessionID，并和保存的所有 sessionID 进行对比，找到这个用户对应的 hash 表。
  - 一般这个值是有时间限制的，超时后销毁，默认 30min
- 当用户在应用程序的 web 页面间挑转时，存储在 session 对象中的变量不会丢失而是在整个用户会话中一直存在下去。
- session 依赖于 cookie，因为 sessionID 是存放在 cookie 中的。

## 对比

### Cookie 和 Session 的区别

1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。
2. cookie 不是很安全，可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session， 容易伪造，不如 session 安全。
3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。
4. session 会消耗大量服务器资源，cookie 在每次 HTTP 请求中都会带上，影响网络性能。
5. 域的支持范围不一样，比方说 a.com 的 Cookie 在 a.com 下都能用，而 www.a.com 的 session 在 api.a.com 下都不能用。
6. 单个 cookie 保存的数据不能超过 4k，很多浏览器都限制一个站点最多保存 20 个 cookie。但是 session 没有限制。

### web storage 和 Cookie 的区别

`web storage`的概念和`cookie`相似，区别是它是为了更大容量存储设计的。

1. `cookie`的大小是受限的
2. 并且每次你请求一个新的页面的时候`cookie`都会被发送过去，这样无形中浪费了带宽
3. 另外`cookie`还需要指定作用域，不可以跨域调用。
4. 除此之外，`web storage`拥有`setItem,getItem,removeItem,clear`等方法，`localStorage`和`sessionStorage`都具有相同的操作方法，例如`setItem、getItem`和`removeItem`等，不像`cookie`需要前端开发者自己封装`setCookie，getCookie`。
5. 但是`cookie`也是不可以或缺的：`cookie`的作用是与服务器进行交互，作为`HTTP`规范的一部分而存在 ，而`web storage`仅仅是为了在本地“存储”数据而生。
6. 浏览器的支持除了`IE７`及以下不支持外，其他标准浏览器都完全支持(ie 及 FF 需在 web 服务器里运行)，值得一提的是 IE 总是办好事，例如 IE7、IE6 中的`userData`其实就是`javascript`本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持`web storage`。

### cookie 和 token 都存放在 header 中，为什么不会劫持 token？

1. 攻击者通过 xss 拿到用户的 cookie 然后就可以伪造 cookie 了。
2. 或者通过 csrf 在同个浏览器下面通过浏览器会自动带上 cookie 的特性
   在通过 用户网站-攻击者网站-攻击者请求用户网站的方式 浏览器会自动带上 cookie 但是 token 不会被浏览器带上 问题 2 解决
3. token 是放在 jwt 里面下发给客户端的 而且不一定存储在哪里 不能通过 document.cookie 直接拿到，通过 jwt+ip 的方式 可以防止 被劫持 即使被劫持 也是无效的 jwt
