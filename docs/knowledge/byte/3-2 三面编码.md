---
title: 算法编码
date: 2020-12-16
draft: true
---

手写快排，时间复杂度，优化
手写实现 jsonp
websocket 握手过程
promise 手写
promise.all 手写
事件中心 bus 手写
两个链表的第一个公共结点
异步调度器 Scheduler
js 实现带并发限制的调度器，其实就是使用 promise 限制并发
移动端适配方案
如何提升移动端用户的使用体验，让用户能更快的看到页面
客户端 mock 怎么支持【描述】客户端 => 协议转换服务 => 中转服务 => mock 服务（接入 mockjs）
怎么 mock 真数据，我需要真的 id 怎么办，除了写死【描述】反向抓包，无需自己填充数据。或者全链路监控里面捞出一个 id
什么情况用 ts、什么时候不用【描述】公共组件、库一定要，不重要的业务代码、节奏快的业务代码不用
自动化测试设计思路【描述】用例、断言、输出结果
项目开发流程、生命周期【举例】
在一个无序数组中找到第二大的数
webpack 打包产物是怎样的，到底是为了什么，优化了什么，为什么要合并文件？
代码题，思路是将一个嵌套的数组用深度遍历和广度遍历分别写出来

## 防抖、节流

```js
function debounce(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = null;
    }, delay);
  };
}
```

```js
function throttle(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    }
  };
}
```

## 深拷贝

### 1. JSON.parse JSON.stringify

简单的做法：`JSON.parse(JSON.stringify(obj))`， 但是该方法也是有局限性的：

1. 会忽略`undefined`, `symbol`, 函数
2. 不能解决循环引用的对象 （会报错）

### 2. MessageChannel

如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 `MessageChannel`。 这种方法有局限性，当属性值是函数的时候，会报错。

```js
function structuralClone(obj) {
  return new Promise(resolve => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = ev => resolve(ev.data);
    port1.postMessage(obj);
  });
}

var obj = {
  a: 1,
  b: {
    c: 2,
  },
};

obj.b.d = obj.b;

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () => {
  const clone = await structuralClone(obj);
  console.log(clone);
};
test();
```

### 3. for 循环深拷贝

```js
// 判断属性值类型是原始类型和引用类型
function isObj(obj) {
  return typeof obj === 'object' && obj !== null;
}

function deepClone(obj, map = new WeakMap()) {
  // 解决环的情况
  if (map.has(obj)) return map.get(obj);
  // 数组 or 对象
  let cloneObj = Array.isArray(obj) ? [] : {};
  map.set(obj, cloneObj);
  // for-in 会遍历原型链上的属性
  for (let key in obj) {
    // 需要判断是否是原型链上的属性，不是原型链才拷贝
    if (obj.hasOwnProperty(key)) {
      // 原始类型直接赋值（注意 null）
      cloneObj[key] = isObj(obj[key]) ? deepClone(obj[key], map) : obj[key];
    }
  }
  return cloneObj;
}
```

## 手写 call、apply 及 bind 函数

```js
Function.prototype.myCall = function(context) {
  context = context || window;
  // 通过将函数挂载到 context 对象上来使得 this 改变
  context.fn = this;
  const args = [...arguments].slice(1);
  const result = context.fn(...args);
  delete context.fn;
  return result;
};
```

```js
Function.prototype.myApply = function(context) {
  context = context || window;
  context.fn = this;
  let result;
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

bind 实现

`bind` 的实现对比其他两个函数略微地复杂了一点，因为 `bind` 需要返回一个函数，需要判断一些边界问题，以下是 `bind` 的实现

```js
Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
  }
  const that = this;
  const args = [...arguments].slice(1);
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    // 通过 `new` 的方式，对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况我们需要忽略传入的 `this`
    if (this instanceof F) {
      return new that(...args, ...arguments);
    }
    return that.apply(context, args.concat(...arguments));
  };
};
```

## 数组去重（对象、非对象）

```js
// set 去重
[...new Set(arr)];

// 利用 indexOf 去重
const newArr = arr.filter((item, index, arr) => index === arr.indexOf(item));

// 利用对象去重
let objA = {};
const newArrA = arr.filter((item, index, arr) => (objA.hasOwnProperty(item) ? false : (objA[item] = true)));
```

### 数组对象去重

```js
function removeDuplication(arr = [], key = '') {
  if (!key) return Array.from(new Set(arr));
  const map = {};
  return arr.reduce((result, next) => {
    map[next[key]] ? '' : (map[next[key]] = true && result.push(next));
    return result;
  }, []);
}
```

## 实现 flatten 扁平化函数

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组。

**竟然原生就有这个 flat 函数，用来拍平数组**。flat 函数的参数是层级。Infinity 无限大。 会拍平数组中的所有数组值。

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b);
```

自己实现:

```js
const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
```

```js
function flatten(arr) {
  let temp = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      temp.push(...flatten(item));
    } else {
      temp.push(item);
    }
  });
  return temp;
}
```

递归实现

```js
function flatten(arr, result = []) {
  arr.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
}
```

### 有层级的数组扁平化

```js
function flatten(arr, deep) {
  if (!deep) return arr;
  let temp = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      temp.push(...flatten(item, --deep));
    } else {
      temp.push(item);
    }
  });
  return temp;
}
```

## 给出数组超过半数的数字，不存在的话输出没有（要求时间复杂度最低）

```js
function moreThanHalfNum(numbers) {
  var obj = {};
  var len = numbers.length;
  numbers.forEach(function(s) {
    if (obj[s]) {
      obj[s]++;
    } else {
      obj[s] = 1;
    }
  });

  for (var i in obj) {
    if (obj[i] > Math.floor(len / 2)) {
      return i;
    }
  }
  return 0;
}
```

## 实现一下 curry（柯里化）

柯里化好处：

1. 保留上一步的传参，能够进行延迟计算
2. 优雅的写法，允许你写出来的代码更干净、更有表达力。

```js
function curry(fn, arr = []) {
  return fn.length === arr.length
    ? fn.apply(null, arr)
    : function(...args) {
        return curry(fn, arr.concat(args));
      };
}

const curry = (fn, arr = []) => (fn.length === arr.length ? fn(...arr) : (...args) => curry(fn, [...arr, ...args]));
```

实现加法函数使得 add(2)(3)和 add(2,3)都输出 5

```js
function add() {
  let args = [...arguments];
  let addFun = function() {
    args.push(...arguments);
    return addFun;
  };
  addFun.valueOf = addFun.toString = function() {
    return args.reduce((a, b) => {
      return a + b;
    }, 0);
  };
  return addFun;
}
```

### add 柯里化函数

用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数

```js
add(2, 5); // 7
add(2)(5); // 7
```

实现

```js
function add() {
  var args = Array.prototype.slice.call(arguments);
  var fn = function() {
    var fn_args = Array.prototype.slice.call(arguments);
    return add.apply(null, args.concat(fn_args));
  };
  // 返回指定对象的原始值。 不加这个的话，最终返回的是一个函数，无法最终拿到结果
  fn.valueOf = function() {
    return args.reduce(function(a, b) {
      return a + b;
    });
  };
  return fn;
}
```

## 实现一个 EventEmitter 类

```js
function EventEmitter() {
  this.callbacksMap = {};
}

EventEmitter.prototype.on = function(type, handler) {
  const callbacks = this.callbacksMap[type];
  if (!callbacks) {
    this.callbacksMap[type] = [handler];
  } else {
    callbacks.push(handler);
  }
  return this;
};

EventEmitter.prototype.off = function(type, handler) {
  const list = this.callbacksMap[type] || [];

  for (let i = list.length; i >= 0; --i) {
    if (!handler || list[i] === handler) {
      list.splice(i, 1);
    }
  }

  return this;
};

EventEmitter.prototype.emit = function(type, data) {
  const list = this.callbacksMap[type];

  if (list) {
    for (let i = 0, len = list.length; i < len; ++i) {
      list[i].call(this, data);
    }
  }
};

EventEmitter.prototype.once = function(type, handler) {
  const self = this;

  function wrapper() {
    handler.apply(self, arguments);
    self.off(type, wrapper);
  }
  this.on(type, wrapper);
  return this;
};
```

## 解析 url

写一段匹配 URL 的正则，包括协议、域名、端口、path、hash、querystring

### 解析一个参数

```js
function getQueryString(name) {
  const reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
  const r = window.location.search.slice(1).match(reg);
  if (r != null) {
    return r[2];
  }
  return null;
}
```

### url 所有参数转化为一个对象

```js
var parseQueryString = function(search) {
  if (!search) return {};
  const regExp = /([^&=]+)=([\w\W]*?)(&|$)/g;
  const ret = {};
  search = search[0] === '?' ? search.slice(1) : search;
  while ((result = regExp.exec(search)) != null) {
    ret[result[1]] = result[2];
  }
  return ret;
};
```

## 手写 ajax

手写的 ajax 是否兼容 IE ， IE 下面的 ajax 与普通浏览器的 ajax 对象不一样

```js
function ajax(url, cb) {
  let xhr;
  // 创建 XMLHttpRequest 对象
  if (window.XMLHttpRequest) {
    // `XMLHttpRequest`只有在高级浏览器中才支持. 非 IE 内核
    xhr = new XMLHttpRequest();
  } else {
    // IE内核
    xhr = ActiveXObject('Microsoft.XMLHTTP');
  }
  // 绑定 onreadystatechange 事件
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      //  获取异步调用返回的数据
      cb(xhr.responseText);
    }
  };
  // 向服务器发送请求. 第三个参数表示是否异步
  xhr.open('GET', url, true);
  xhr.send();
}
```

## 实现 destructuringArray 方法

```js
// destructuringArray([1,[2,4],3], "[a,[b],c]");
// result: { a:1, b:2, c:3 }
```

```js
const destructuringArray = (value, keys) => {
  const obj = {};
  // "[a,[b],c]".replace(/\w+/g, '"$&"')
  const arr = JSON.parse(keys.replace(/\w+/g, '"$&"'));
  const iterate = (value, keys) => {
    keys.forEach((item, index) => {
      if (Array.isArray(item)) iterate(value[index], item);
      else obj[item] = value[index];
    });
  };
  iterate(value, arr);
  return obj;
};
```

## reduce 实现 map

```js
Array.prototype.map = function(callback) {
  const arr = this;
  return arr.reduce((acc, cur, i) => {
    acc.push(callback(cur, i, arr));
    return acc;
  }, []);
};
```

```js
const map = function(fn, context) {
  const arr = Array.prototype.slice.call(this);
  return arr.reduce((pre, cur, index) => {
    return [...pre, fn.call(context, cur, index, this)];
  }, []);
};
```

## sleep 函数

```js
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
```

## 手写 promise

```js
const PENDING = 'pending';
const RESOLVED = 'resolved';
const REJECTED = 'rejected';

function MyPromise(fn) {
  const that = this;
  that.state = PENDING;
  that.value = null;
  that.resolvedCallbacks = [];
  that.rejectedCallbacks = [];

  function resolve(value) {
    if (that.state === PENDING) {
      that.state = RESOLVED;
      that.value = value;
      that.resolvedCallbacks.forEach(cb => cb(that.value));
    }
  }

  function reject(value) {
    if (that.state === PENDING) {
      that.state = REJECTED;
      that.value = value;
      that.rejectedCallbacks.forEach(cb => cb(that.value));
    }
  }

  try {
    fn(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

MyPromise.prototype.then = function(onFulfilled, onRejected) {
  return new MyPromise((resolve, reject) => {
    const that = this;
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : r => {
            throw r;
          };
    if (that.state === PENDING) {
      that.resolvedCallbacks.push(onFulfilled);
      that.rejectedCallbacks.push(onRejected);
    }
    if (that.state === RESOLVED) {
      onFulfilled(that.value);
      resolve(that.value);
    }
    if (that.state === REJECTED) {
      onRejected(that.value);
      reject(that.value);
    }
  });
};
```

## 实现 Promise.all(list, limit)

1. js 实现带并发限制的调度器，其实就是使用 promise 限制并发
2. 实现一个可以控制请求并发数的最高效的发送请求功能。
3. 手动控制并发请求 fetchWithLimit。 手动控制并发请求 fetchWithLimit 尽量快的实现

控制一下子发出的请求个数。异步请求控制并发 LimitPromise

```js
function PromiseLimit(funcArray, limit = 5) {
  let i = 0;
  // promise 存储
  const result = [];
  // 执行存储
  const executing = [];
  const queue = function() {
    // 边界处理, funcArray 为空数组
    if (i === funcArray.length) return Promise.all(executing);
    // 一个 promise
    const p = funcArray[i++]();
    // 最终返回的 promise 队列
    result.push(p);
    // 在 p 执行结束之后，将 e 从 executing 数组中取出
    const e = p.then(() => executing.splice(executing.indexOf(e), 1));
    // 执行中的 promise 队列
    executing.push(e);
    // 如果个数到了 limit， 先 race 等待执行结束，再执行 queue 添加一个 promise
    if (executing.length >= limit) {
      return Promise.race(executing).then(
        () => queue(),
        e => Promise.reject(e),
      );
    }
    // 如果个数还没到，则直接执行 queue() 函数添加 promise
    return Promise.resolve().then(() => queue());
  };
  return queue().then(() => Promise.all(result));
}
```

## 实现一个并发限制功能。

```js
function asyncPool(poolLimit, array, iteratorFn) {
  let i = 0;
  const ret = [];
  const executing = [];
  const enqueue = function() {
    if (i === array.length) {
      return Promise.resolve();
    }
    const item = array[i++];
    const p = Promise.resolve().then(() => iteratorFn(item, array));
    ret.push(p);
    const e = p.then(() => executing.splice(executing.indexOf(e), 1));
    executing.push(e);
    let r = Promise.resolve();
    if (executing.length >= poolLimit) {
      r = Promise.race(executing);
    }
    return r.then(() => enqueue());
  };
  return enqueue().then(() => Promise.all(ret));
}
```

## 实现 Promise.retry(promiseFn, times)

fetch 兼容超时重传, 可以设置时间间隔和次数。

```js
Promise.retry = function(promiseFn, times = 3) {
  return new Promise(async (resolve, reject) => {
    while (times--) {
      try {
        var ret = await promiseFn();
        resolve(ret);
        break;
      } catch (error) {
        if (!times) reject(error);
      }
    }
  });
};

function getProm() {
  const n = Math.random();
  return new Promise((resolve, reject) => {
    setTimeout(() => (n > 0.9 ? resolve(n) : reject(n)), 1000);
  });
}

Promise.retry(getProm);
```

## 用 promise 实现一个请求超时功能

```js
function promiseWithTimeout(url, timeout = 3000) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(data => data.json())
      .then(data => resolve(data)); // fetch 先得到结果就 resolve
    setTimeout(() => reject(Error('time is out!')), timeout); // 时间到了还没 fetch 到就 reject
  });
}
```

## 千分位

```js
function test1(num) {
  var str = +num + '';
  var len = str.length;
  if (len <= 3) return str;
  num = '';
  while (len > 3) {
    len -= 3;
    num = ',' + str.substr(len, 3) + num;
  }
  return str.substr(0, len) + num;
}

function test2(num) {
  // ?= 正向匹配:匹配位置
  // ?! 正向不匹配:排除位置
  var str = (+num).toString();
  var reg = /(?=(?!\b)(\d{3})+$)/g;
  return str.replace(reg, ',');
}
```

### 千分位

如 12000000.11 转化为 12,000,000.11

```js
function commafy(num) {
  const val = Math.abs(num);
  const isPositive = num === val;
  const result =
    val &&
    val.toString().replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2) {
      return $2 + ',';
    });
  // return isPositive ? result : `-${result}`;
  return result;
}
```

### 实现千分位标注位

考虑小数、负数和整数三种情况。

`sep`参数是自定义的分隔符，默认是`,`

```js
/**
 * 实现千分位标注位
 * @param {*} str 待标注的字符串
 * @param {*} sep 标注符号
 */
const addSeparator = (str = '', sep = ',') => {
  str += '';
  const arr = str.split('.'),
    re = /(\d+)(\d{3})/;

  let integer = arr[0],
    decimal = arr.length <= 1 ? '' : `.${arr[1]}`;

  while (re.test(integer)) {
    integer = integer.replace(re, '$1' + sep + '$2');
  }

  return integer + decimal;
};

console.log(addSeparator(-10000.23)); // -10,000.23
console.log(addSeparator(100)); // 100
console.log(addSeparator(1234, ';')); // 1;234
```

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

### 格式化金钱，每千分位加逗号

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

## 异步加法

假设有一台本地机器，无法做加减乘除运算（包括位运算），因此无法执行 a + b、a+ = 1 这样的 JS 代码，然后我们提供一个服务器端的 HTTP API，可以传两个数字类型的参数，响应结果是这两个参数的和，这个 HTTP API 的 JS SDK（在本地机器上运行）的使用方法如下：

```js
function add(a, b, time = 1000) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(a + b);
    }, Math.floor(Math.random() * 1000));
  });
}

// 要求 sum 能在最短的时间里返回以上结果
async function sum() {
  console.time('sum');
  function queue(nums) {
    let len = nums.length;
    if (len === 0) return Promise.resolve(0);
    if (len === 1) return Promise.resolve(nums[0]);

    const result = [];
    let executing = [];

    while (len >= 2) {
      result.push([nums[len - 1], nums[len - 2]]);
      len = len - 2;
    }

    if (len === 1) {
      executing.push(Promise.resolve(nums[0]));
    }
    executing = [...executing, ...result.map((item, index) => add(...item, index / 2 === 0 ? 1000 : 2000))];
    return Promise.all(executing).then(data => queue(data));
  }
  const result = await queue([...arguments]);
  console.timeEnd('sum');
  console.log(result);
  return result;
}

async function sum1(...nums) {
  console.time('sum1');
  // 主运行队列
  let executing = [];
  // 副运行队列
  let executingCopy = [];

  function queue() {
    let len = nums.length;
    if (len === 0) return Promise.resolve(0);
    if (len === 1) return Promise.resolve(nums[0]);

    const result = [];
    while (len >= 2) {
      result.push([nums[len - 1], nums[len - 2]]);
      len = len - 2;
    }

    if (len === 1) {
      executingCopy.push(nums[0]);
    }

    executing = result.map((item, index) => {
      const p = add(...item, index / 2 === 0 ? 1000 : 2000).then(data => {
        executing.splice(executing.indexOf(p), 1);
        return data;
      });
      return p;
    });

    function loop() {
      return Promise.race(executing).then(data => {
        executingCopy.push(data);
        // 副队列满 2 个，创建一个新的 promise 加入主队列
        if (executingCopy.length >= 2) {
          const a = executingCopy.shift();
          const b = executingCopy.shift();
          bool = !bool;
          const p = add(a, b, bool ? 1000 : 2000).then(data => {
            executing.splice(executing.indexOf(p), 1);
            return data;
          });
          executing.push(p);
        }
        // 退出条件：主队列执行完毕，副队列只剩最后一个结果
        if (!executing.length) {
          return executingCopy[0];
        }
        return loop();
      });
    }

    return loop();
  }

  const result = await queue([...arguments]);
  console.timeEnd('sum1');
  console.log(result);
  return result;
}

(async () => {
  await sum(1, 4, 6, 9, 2, 4);
  await sum1(1, 4, 6, 9, 2, 4);
  await sum(3, 4, 9, 2, 5, 3, 2, 1, 7);
  await sum1(3, 4, 9, 2, 5, 3, 2, 1, 7);
  await sum(1, 6, 0, 5);
  await sum1(1, 6, 0, 5);
})();
```

## a~z 有 26 个字母，按照 1~26 编码，现在给定一个数字字符串，输出所有可能的解码结果，如：输入 1234，输出 ['axd', 'abcd', 'lcd']

```js
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  if (s.charAt(0) == '0') return;

  const chars = s.split();
  return decode(chars, chars.length - 1);
};

function decode(chars, index) {
  //  处理到了第一个字符,只能有一种解码方法，返回  1
  if (index <= 0) return 1;

  let count = 0;

  const curr = chars[index];
  const prev = chars[index - 1];

  //  当前字符比  “0”  大，则直接利用它之前的字符串所求得的结果
  if (curr > '0') {
    count = decode(chars, index - 1);
  }

  //  由前一个字符和当前字符所构成的数字，值必须要在  1  到  26  之间，否则无法进行解码
  if (prev == '1' || (prev == '2' && curr <= '6')) {
    count += decode(chars, index - 2);
  }

  return count;
}
```

## 顺序发送 4 个请求 a，b，c，d，要求按照顺序输出

顺序发送 4 个请求 a，b，c，d，要求按照顺序输出，即如果先返回 b，则不输出，再返回 a，输出 a，b

```js
function getData(urls) {
  return new Promise((resolve, reject) => {
    const res = [],
      len = urls.length;
    urls.forEach((url, i) => {
      fetch('http://localhost:8080' + url)
        .then(data => data.json())
        .then(data => {
          res[i] = { data, printed: false }; // 将数据放入缓存数组
          let flag = true;
          for (let j = 0; j < len && flag; j += 1) {
            if (res[j]) {
              // 如果标志为 j 的有返回值，则继续
              if (!res[j].printed) {
                console.log(res[j].data);
                res[j].printed = true;
                j === len - 1 && resolve(res.map(o => o.data));
              }
            } else {
              // 无返回值，则跳出
              flag = false;
            }
          }
        }, reject);
    });
  });
}

const listPromise = getData(['/data.json', '/data2.json', '/data3.json', '/data4.json']);
listPromise.then(res => console.log(res));
```

## JS 实现一个带并发限制的异步调度器 Scheduler

完善代码中 Scheduler 类，使得以下程序能正确输出。

```js
// JS实现一个带并发限制的异步调度器Scheduler，
// 保证同时运行的任务最多有两个。
// 完善代码中Scheduler类，
// 使得以下程序能正确输出

class Scheduler {
  constructor() {
    this.count = 2;
    this.queue = [];
    this.run = [];
  }

  add(task) {
    // ...
  }
}

const timeout = time =>
  new Promise(resolve => {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler();
const addTask = (time, order) => {
  scheduler.add(() => timeout(time)).then(() => console.log(order));
};

addTask(1000, '1');
addTask(500, '2');
addTask(300, '3');
addTask(400, '4');
// output: 2 3 1 4

// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进队
// 800ms时，3完成，输出3，任务4进队
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4
```

别人的解答：

```js
class Scheduler {
  constructor(count) {
    this.count = 2;
    this.queue = [];
    this.run = [];
  }

  add(task) {
    this.queue.push(task);
    return this.schedule();
  }

  schedule() {
    if (this.run.length < this.count && this.queue.length) {
      const task = this.queue.shift();
      const promise = task().then(() => {
        this.run.splice(this.run.indexOf(promise), 1);
      });
      this.run.push(promise);
      return promise;
    } else {
      return Promise.race(this.run).then(() => this.schedule());
    }
  }
}
```

## 写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串

```js
function isAN(number) {
  return /^d+$/.test(number);
}
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
let multiply = function(num1 = '', num2 = '') {
  //判断输入是不是数字
  if (isAN(num1) || isAN(num2)) return '';
  let len1 = num1.length,
    len2 = num2.length;
  let ans = [];

  //这里倒过来遍历很妙,不需要处理进位了
  for (let i = len1 - 1; i >= 0; i--) {
    for (let j = len2 - 1; j >= 0; j--) {
      let index1 = i + j,
        index2 = i + j + 1;
      let mul = num1[i] * num2[j] + (ans[index2] || 0);
      // 当前位
      ans[index1] = Math.floor(mul / 10) + (ans[index1] || 0);
      // 进位
      ans[index2] = mul % 10;
    }
  }

  //去掉前置 0
  let result = ans.join('').replace(/^0+/, '');

  //不要转成数字判断，否则可能会超精度！
  return !result ? '0' : result;
};
```

## 大数相加

1000000000 + 1000000000 允许返回字符串。处理大数。大数问题其实就是通过字符串来处理，从后往前加，然后处理进位的问题。

```js
function add(a, b) {
  //取两个数字的最大长度
  let maxLength = Math.max(a.length, b.length);
  //用 0 去补齐长度
  a = a.padStart(maxLength, 0); //"0009007199254740991"
  b = b.padStart(maxLength, 0); //"1234567899999999999"
  // 定义加法过程中需要用到的变量
  let t = 0;
  let f = 0; // 进位
  let sum = '';
  for (let i = maxLength - 1; i >= 0; i--) {
    t = parseInt(a[i]) + parseInt(b[i]) + f;
    // Math.floor 向下取整。 Math.ceil 向上取整。
    f = Math.floor(t / 10);
    sum = (t % 10) + sum;
  }
  if (f == 1) {
    sum = '1' + sum;
  }
  return sum;
}
```

## 加法函数

写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3

```js
function accAdd(arg1, arg2) {
  var r1, r2, m;
  try {
    r1 = arg1.toString().split('.')[1].length;
  } catch (e) {
    r1 = 0;
  }
  try {
    r2 = arg2.toString().split('.')[1].length;
  } catch (e) {
    r2 = 0;
  }
  // 计算出一个倍数。看小数点后面的值的长度
  m = Math.pow(10, Math.max(r1, r2));
  // 先乘这个倍数，再除以这个倍数
  return (arg1 * m + arg2 * m) / m;
}
var result = accAdd(0.1, 0.2);
console.log(result); // 0.3
```

自定义处理函数，放大指定的位数，最后再缩小。

```js
// f代表需要计算的表达式，digit代表小数位数
Math.formatFloat = function(f, digit) {
  // Math.pow(指数，幂指数)
  var m = Math.pow(10, digit);
  // Math.round（） 四舍五入
  return Math.round(f * m, 10) / m;
};
console.log(Math.formatFloat(0.3 * 8, 1)); // 2.4
console.log(Math.formatFloat(0.35 * 8, 2)); // 2.8
```

### js 浮点数运算不精确如何解决?

### 实现一个判断变量类型的函数

```js
function getType(obj) {
  // 分开判断引用类型和基本类型
  return typeof obj === 'object'
    ? Object.prototype.toString
        .call(obj)
        .slice(8, -1)
        .toLowerCase()
    : typeof obj;
}
```

### 二进制相加，给两字符串求值

### 对输入的字符串：去除其中的字符'b'；去除相邻的'a'和'c'。 'aabcd' -> 'ad' 'aaabbccc' -> '' 不允许使用类似 string.replace 函数。要求时间、空间复杂度尽量优化

### js 中处理大数。如果后端传给前端一个很大的数，前端会怎么样，该怎么处理？

### 找出两个有序数组中的重复项，分析时间和空间复杂度

### 实现 toFix 函数

### atoi 把任意进制的数转为十进制的数。 需要考虑负数。

### 实现一个 promiseify 方法，将 callback 风格调用转成 promise 调用方式

### 工厂生产了十批原件，其中有一批是次品。正常的原件每个重量都是 100 克，次品的是 99 克。现在给你一个秤，要求只称一次，怎么确定哪批原件是次品。

### 比较版本号

```js
var compareVersion = function(version1, version2) {
  const arr1 = version1.split('.');
  const arr2 = version2.split('.');

  let len = Math.max(arr1.length, arr2.length);

  for (let i = 0; i < len; i++) {
    let data1 = 0,
      data2 = 0;

    if (i < arr1.length) {
      data1 = parseInt(arr1[i]);
    }
    if (i < arr2.length) {
      data2 = parseInt(arr2[i]);
    }

    if (data1 < data2) {
      return -1;
    } else if (data1 > data2) {
      return 1;
    }
  }
  return 0;
};
```

### 实现一个构造函数，new 的时候每次加 1

## 原生 js 实现 MVVM

```js
<span id="box">
  <h1 id="text"></h1>
  <input type="text" id="input" oninput="inputChange(event)" />
  <button id="button" onclick="clickChange()">
    Click me
  </button>
</span>
```

```js
const input = document.getElementById('input');
const text = document.getElementById('text');
const button = document.getElementById('button');
const data = {
  value: '',
};
function defineProperty(obj, attr) {
  let val;
  Object.defineProperty(obj, attr, {
    set(newValue) {
      console.log('set');
      if (val === newValue) {
        return;
      }
      val = newValue;
      input.value = newValue;
      text.innerHTML = newValue;
    },
    get() {
      console.log('get');
      return val;
    },
  });
}
defineProperty(data, 'value');
function inputChange(event) {
  data.value = event.target.value;
}

function clickChange() {
  data.value = 'hello';
}
```

## 手写 JSONP

jsonp 原理：因为 jsonp 发送的并不是 ajax 请求，其实是动态创建 script 标签
script 标签是没有同源限制的，把 script 标签的 src 指向请求的服务端地址。

```js
function jsonp(url, data = {}, callback = 'callback') {
  //处理json对象，拼接url
  data.callback = callback;
  let params = [];
  for (let key in data) {
    params.push(key + '=' + data[key]);
  }
  let script = document.createElement('script');
  script.src = url + '?' + params.join('&');
  document.body.appendChild(script);

  //返回Promise
  return new Promise((resolve, reject) => {
    window[callback] = data => {
      try {
        resolve(data);
      } catch (e) {
        reject(e);
      } finally {
        //移除 script 元素
        script.parentNode.removeChild(script);
        console.log(script);
      }
    };
  });
}

//请求数据
jsonp(
  'http://photo.sina.cn/aj/index',
  {
    page: 1,
    cate: 'recommend',
  },
  'jsonCallback',
).then(data => {
  console.log(data);
});
```

### Jsonp 方案需要服务端怎么配合 ?

## 用两个栈实现队列

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

### 思路

一个栈用来存储插入队列数据，一个栈用来从队列中取出数据。从第一个栈向第二个栈转移数据的过程中：数据的性质已经从后入先出变成了先入先出。

```js
var CQueue = function() {
  this.outStack = [];
  this.inStack = [];
};

/**
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
  if (value) {
    // 新插入队列的数据都放在 inStack
    this.inStack.push(value);
  }
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
  const { outStack, inStack } = this;
  //  如果 outStack 为空，那么将 inStack 中的元素都转移过来
  if (!outStack.length) {
    while (inStack.length) {
      outStack.push(inStack.pop());
    }
  }
  return !outStack.length ? -1 : outStack.pop();
};
```

## js 实现一个拖拽？

首先是三个事件，分别是 mousedown，mousemove，mouseup
当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。

clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：
鼠标移动时候的坐标-鼠标按下去时候的坐标。

也就是说定位信息为：

鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.

还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left
以及 top 等等值。
div:

```html
<div class="drag" style="left:0;top:0;width:100px;height:100px">按住拖动</div>

<style>
  .drag {
    background-color: skyblue;
    position: absolute;
    line-height: 100px;
    text-align: center;
  }
</style>
```

js:

```js
// 获取DOM元素
let dragDiv = document.getElementsByClassName('drag')[0];
// 鼠标按下事件 处理程序
let putDown = function(event) {
  dragDiv.style.cursor = 'pointer';
  let offsetX = parseInt(dragDiv.style.left); // 获取当前的x轴距离
  let offsetY = parseInt(dragDiv.style.top); // 获取当前的y轴距离
  let innerX = event.clientX - offsetX; // 获取鼠标在方块内的x轴距
  let innerY = event.clientY - offsetY; // 获取鼠标在方块内的y轴距
  // 按住鼠标时为div添加一个border
  dragDiv.style.borderStyle = 'solid';
  dragDiv.style.borderColor = 'red';
  dragDiv.style.borderWidth = '3px';
  // 鼠标移动的时候不停的修改div的left和top值
  document.onmousemove = function(event) {
    dragDiv.style.left = event.clientX - innerX + 'px';
    dragDiv.style.top = event.clientY - innerY + 'px';
    // 边界判断
    if (parseInt(dragDiv.style.left) <= 0) {
      dragDiv.style.left = '0px';
    }
    if (parseInt(dragDiv.style.top) <= 0) {
      dragDiv.style.top = '0px';
    }
    if (parseInt(dragDiv.style.left) >= window.innerWidth - parseInt(dragDiv.style.width)) {
      dragDiv.style.left = window.innerWidth - parseInt(dragDiv.style.width) + 'px';
    }
    if (parseInt(dragDiv.style.top) >= window.innerHeight - parseInt(dragDiv.style.height)) {
      dragDiv.style.top = window.innerHeight - parseInt(dragDiv.style.height) + 'px';
    }
  };
  // 鼠标抬起时，清除绑定在文档上的mousemove和mouseup事件
  // 否则鼠标抬起后还可以继续拖拽方块
  document.onmouseup = function() {
    document.onmousemove = null;
    document.onmouseup = null;
    // 清除border
    dragDiv.style.borderStyle = '';
    dragDiv.style.borderColor = '';
    dragDiv.style.borderWidth = '';
  };
};
// 绑定鼠标按下事件
dragDiv.addEventListener('mousedown', putDown, false);
```

## 需要通过 threshold 参数控制调用函数频率

```js
const yourFunction = function(func, threshold) {
  // 请实现
};
const triggerSearch = yourFunction(val => {
  const { onSearch } = this.props;
  onSearch(val);
}, 300);
triggerSearch(searchText);
```

实现

```js
const yourFunction = function(func, threshold) {
  let timeOut;
  return function() {
    if (!timeOut) {
      timeOut = setTimeout(() => {
        timeOut = null;
        func.apply(this, arguments);
      }, threshold);
    }
  };
};

const triggerSearch = yourFunction(val => {
  const { onSearch } = this.props;
  onSearch(val);
}, 300);
```

## 事件触发器

兼容所有浏览器

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return element.dispatchEvent(mockEvent);
  }
};
```

## 代码中 a 在什么情况下会打印 1？

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

考察隐式转换,重写 toString 方法即可

```js
var a = {
  i: 1,
  toString() {
    return a.i++;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```

```js
let a = {
  i: 1,
  valueOf() {
    return a.i++;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

```js
var a = [1, 2, 3];
a.join = a.shift;
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

```js
let a = { [Symbol.toPrimitive]: (i => () => ++i)(0) };
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

## 实现 (5).add(3).minus(2) 功能

```js
Number.prototype.add = function(value) {
  let number = parseFloat(value);
  if (typeof number !== 'number' || Number.isNaN(number)) {
    throw new Error('请输入数字或者数字字符串～');
  }
  return this + number;
};
Number.prototype.minus = function(value) {
  let number = parseFloat(value);
  if (typeof number !== 'number' || Number.isNaN(number)) {
    throw new Error('请输入数字或者数字字符串～');
  }
  return this - number;
};
```

## 要求设计 LazyMan 类，实现以下功能

```js
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony')
  .sleep(10)
  .eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony')
  .eat('lunch')
  .sleep(10)
  .eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony')
  .eat('lunch')
  .eat('dinner')
  .sleepFirst(5)
  .sleep(10)
  .eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

答案：

```js
class LazyManClass {
  constructor(name) {
    this.taskList = [];
    this.name = name;
    console.log(`Hi I am ${this.name}`);
    setTimeout(() => {
      this.next();
    }, 0);
  }
  eat(name) {
    var that = this;
    var fn = (function(n) {
      return function() {
        console.log(`I am eating ${n}`);
        that.next();
      };
    })(name);
    this.taskList.push(fn);
    return this;
  }
  sleepFirst(time) {
    var that = this;
    var fn = (function(t) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${t}秒...`);
          that.next();
        }, t * 1000);
      };
    })(time);
    this.taskList.unshift(fn);
    return this;
  }
  sleep(time) {
    var that = this;
    var fn = (function(t) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${t}秒...`);
          that.next();
        }, t * 1000);
      };
    })(time);
    this.taskList.push(fn);
    return this;
  }
  next() {
    var fn = this.taskList.shift();
    fn && fn();
  }
}
function LazyMan(name) {
  return new LazyManClass(name);
}
LazyMan('Tony')
  .eat('lunch')
  .eat('dinner')
  .sleepFirst(5)
  .sleep(4)
  .eat('junk food');
```

## 实现一个持续的动画效果

js 定时器实现

```js
var e = document.getElementById('e');
var flag = true;
var left = 0;
setInterval(() => {
  left == 0 ? (flag = true) : left == 100 ? (flag = false) : '';
  flag ? (e.style.left = ` ${left++}px`) : (e.style.left = ` ${left--}px`);
}, 1000 / 60);
```

js API requestAnimationFrame 实现

```js
//兼容性处理
window.requestAnimFrame = (function() {
  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
    }
  );
})();

var e = document.getElementById('e');
var flag = true;
var left = 0;

function render() {
  left == 0 ? (flag = true) : left == 100 ? (flag = false) : '';
  flag ? (e.style.left = ` ${left++}px`) : (e.style.left = ` ${left--}px`);
}

(function animloop() {
  render();
  requestAnimFrame(animloop);
})();
```

优势：

浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果
解决毫秒的不精确性
避免过度渲染（渲染频率太高、tab 不可见暂停等等）
注：requestAnimFrame 和 定时器一样也头一个类似的清除方法 cancelAnimationFrame

css 实现：

```css
.test {
  animation: mymove 5s infinite;
  @keyframes mymove {
    from {
      top: 0px;
    }
    to {
      top: 200px;
    }
  }
}
```

## 实现函数字符串转对象

```
'a.b.c'
=>
a: {
    b: {
        c: null
    }
}
```

## 输入字符串输出二维数组

```
`
12312

1  3
12 3
`
=>
[
    ['12312'],
    ['13'],
    ['123']
]
```

```js
function handler(str = '') {
  return str
    .split('\n')
    .filter(Boolean)
    .map(val => val.replace(/\s/g, ''));
}
```

## 十六进制转十进制

```js
// 10进制转16进制
function handler(params) {
  typeof params == 'string' ? (params = Number(params)) : '';
  console.log(params.toString(16)); //a8
}
handler('168');

// 16进制转10进制
function handler2(params) {
  console.log(Number('0x' + params)); //168
}
handler2('a8');

// 16进制转10进制
function handler3(params) {
  console.log(parseInt(params, 16)); //168
}
handler3('a8');
```

## 实现 36 进制转换

```js
function getNums36() {
  var nums36 = [];
  for (var i = 0; i < 36; i++) {
    if (i >= 0 && i <= 9) {
      nums36.push(i);
    } else {
      nums36.push(String.fromCharCode(i + 87));
    }
  }
  return nums36;
}

//十进制数转成36进制
function scale36(n) {
  var arr = [];
  var nums36 = getNums36();
  while (n) {
    var res = n % 36;
    //作为下标，对应的36进制数，转换成
    arr.unshift(nums36[res]);
    //去掉个位
    n = parseInt(n / 36);
  }
  return arr.join('');
}
```

## 原题

### 两数之和 twoSum

```js
function twoSum(nums = [], target) {
  const map = {};
  for (const num of nums) {
    const tmp = target - num;
    if (map[tmp] !== undefined) return [num, tmp];
    map[num] = true;
  }
}
```

### 三数之和 3Sum

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：

```js
[
  [-1, 0, 1],
  [-1, -1, 2],
];
```

#### 思路

我们采用`分治`的思想. 想要找出三个数相加等于 0，我们可以数组依次遍历，每一项 a[i]我们都认为它是最终能够用组成 0 中的一个数字，那么我们的目标就是找到剩下的元素(除 `a[i]`)两个相加等于 `-a[i]`.

- 排序之后，用双指针
- 分治

#### 代码

```js
var threeSum = function(nums) {
  // 先排序
  nums.sort(function(a, b) {
    return a - b;
  });

  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const sum = nums[i] + nums[j];
      const bs = binarySearch(nums, -sum, 0, nums.length - 1);
      if (bs != null && bs != i && bs != j) {
        let mArr = [nums[i], nums[j], nums[bs]].sort(function(a, b) {
          return a - b;
        });
        if (!has(ans, mArr)) {
          ans.push(mArr);
        }
      }
    }
  }
  return ans;
};

// 在数组中从 left 开始 right 结束，找到某个值
function binarySearch(arr, val, left, right) {
  if (left > right) return null;
  let mid = left + parseInt((right - left) / 2);
  if (val < arr[mid]) {
    return binarySearch(arr, val, left, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, right);
  } else {
    return mid;
  }
}

// 判断结果数组是否一致
function has(arr, target) {
  for (let cur of arr) {
    let isEqual = true;
    for (let i = 0; i < target.length; i++) {
      if (cur[i] != target[i]) {
        isEqual = false;
      }
    }
    if (isEqual) return true;
  }
  return false;
}
```

### [19].删除链表的倒数第 n 个节点 Remove-Nth-Node-From-End-of-List

```html
Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes
1->2->3->5.
```

#### 思路

双指针，指针 A 先移动 n 次， 指针 B 再开始移动。当 A 到达 null 的时候， 指针 b 的位置正好是倒数 n

#### 代码

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let dummy = new ListNode(0);
  dummy.next = head;
  let fast = dummy;
  let slow = dummy;

  for (let i = 1; i <= n + 1; i++) {
    fast = fast.next;
  }
  while (fast != null) {
    fast = fast.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return dummy.next;
};
```

### [20].有效的括号 validParentheses

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true

#### 思路

使用栈, 遍历输入字符串, 如果当前字符为左半边括号时，则将其压入栈中, 如果遇到右半边括号时，分类讨论：

1. 如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环
2. 若此时栈为空，则直接返回 false
3. 若不为对应的左半边括号，反之返回 false

#### 代码

```js
var isValid = function(s) {
  let valid = true;
  const stack = [];
  const hashmap = {
    '{': '}',
    '[': ']',
    '(': ')',
  };

  for (let i in s) {
    const v = s[i];
    if (['(', '[', '{'].indexOf(v) > -1) {
      stack.push(v);
    } else {
      const peak = stack.pop();
      if (v !== hashmap[peak]) {
        return false;
      }
    }
  }

  if (stack.length > 0) return false;

  return valid;
};
```

```js
// 最高赞
var isValid = function(s) {
  var st = [];
  for (var l of s)
    if ((i = '({[]})'.indexOf(l)) > -1)
      if (st[st.length - 1] + i === 5)
        // 相加为 5 则意味着匹配上了。 另 length-- 操作直接删除了顶部元素
        st.length--;
      else st.push(i);
  return st.length === 0;
};
```

```js
console.log(isValid('()[]{}'));
console.log(isValid('[()][]{}'));
console.log(isValid('(])'));
```

### [21].合并两个有序链表 merge-two-sorted-lists

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

### [22].括号匹配 Generate-Parentheses

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

For example, given n = 3, a solution set is:
[
"((()))",
"(()())",
"(())()",
"()(())",
"()()()"
]

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  var ans = [];
  helper(ans, '', 0, 0, n);
  return ans;
};

function helper(ans, str, left, right, n) {
  if (right === n) ans.push(str);
  if (left < n) {
    helper(ans, str + '(', left + 1, right, n);
  }
  if (right < left) {
    helper(ans, str + ')', left, right + 1, n);
  }
}
```

```js
let result = [];

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  dfs(n, 1, 1, '(');
  return result;
};

function dfs(n, sum, used, s) {
  if (s.length == 2 * n) {
    result.push(s);
    return;
  }
  if (sum == 0) {
    dfs(n, sum + 1, used + 1, s + '(');
  } else if (sum == n || used == n) {
    dfs(n, sum - 1, used, s + ')');
  } else {
    dfs(n, sum + 1, used + 1, s + '(');
    dfs(n, sum - 1, used, s + ')');
  }
}
```

### [23].合并 K 个升序链表 merge-k-sorted-lists

[link](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```

#### 关键点解析

这道题目是合并 k 个已排序的链表，号称 leetcode 目前`最难`的链表题。

- 分治
- 合并排序(merge sort)

当 k=1 的时候，直接返回结果；当 k=2 的时候，把这两个链表归并。当 k=3 的时候，我们可以把它们分成两组，分别归并完毕后再进行最后的归并操作，如下。

![](http://s0.lgstatic.com/i/image2/M01/91/50/CgotOV2InqWAExguACYe_inhacY345.gif)

上述做法运用了典型的分治思想，非常类似归并排序操作。

**时间复杂度**：O(nk×log(k))。
**空间复杂度**：O(1)。因为不像最小堆解法那样需要维护一个额外的数据结构。

#### 代码

```js
var mergeKLists = function(lists) {
  const len = lists.length;
  if (!len) return null;
  if (len === 1) return lists[0];
  if (len === 2) return mergeTwoLists(...lists);

  const mid = len >> 1;
  const result = mergeTwoLists(mergeKLists(lists.slice(0, mid)), mergeKLists(lists.slice(mid)));
  return result;
};

function mergeTwoLists(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

##### 解题思路二：最小堆法

面对 k 个排好序的链表时，最小的那个数肯定是从这 k 个链表的头里面选出来。

那么，第二小的如何选择？例如，有下面 k 个链表。 ![](http://s0.lgstatic.com/i/image2/M01/91/30/CgoB5l2InqSAHLY0ACSlxIOkYh0731.gif)

1.  把最小的 1 从所有的 k 个链表头里选出来之后，把 1 从链表里删掉。

2.  下一个最小的数，还是从所有的 k 个链表头里选出来。

3.  以此类推，每一轮都比较 k 个新的链表头的大小，得出最后的结果。

上述操作的时间复杂度是 O(k)。而针对找出最小的数，可以使用最小堆来提高效率。时间复杂度计算如下。

1.  对 k 个链表头创建一个大小为 k 的最小堆，在第 2 课中提到创建一个大小为 k 的最小堆所需的时间是 O(k)；

2.  从堆里取出最小的数，都是 O(lg(k))；

3.  若每个链表的平均长度为 n，一共有 nk 个元素，即用大小为 k 的最小堆去过滤 nk 个元素；

4.  整体的时间复杂度就是 O(nk×log(k))。

维护这个大小为 k 的最小堆，直到遍历完所有 k 个链表里的所有元素。

**代码实现**

public ListNode mergeKLists(ListNode\[\] lists) {
    //利用一个空的链表头方便插入节点。
    ListNode fakeHead = new ListNode(0), p = fakeHead;
    int k = lists.length;

//  定义一个最小堆来保存  k  个链表节点；将  k  个链表的头放入到最小堆里。
    PriorityQueue<ListNode> heap =
        new PriorityQueue<>(k, new Comparator<ListNode>() {
            public int compare(ListNode a, ListNode b) {
                return a.val - b.val;
            }
        });

//  从最小堆里将当前最小的节点取出，插入到结果链表中。
    for (int i = 0; i < k; i++) {
        if (lists\[i\] != null) {
            heap.offer(lists\[i\]);
        }
    }

while (!heap.isEmpty()) {
        ListNode node = heap.poll();

p.next = node;
        p = p.next;

//  如果发现该节点后面还有后续节点，将后续节点加入到最小堆里。
        if (node.next != null) {
            heap.offer(node.next);
        }
    }
    return fakeHead.next;

}

### [24].交换链表中的相邻结点 swapPairs

```html
Given 1->2->3->4, you should return the list as 2->1->4->3.
```

题目要求：不能修改结点的 val 值，O(1) 空间复杂度。

```js
var swapPairs = function(head) {
  const dummy = new ListNode(0);
  dummy.next = head;

  let pre = dummy,
    cur = dummy.next,
    next = null;
  // 仍然存在两个节点
  while (cur && cur.next) {
    next = cur.next.next;
    cur.next.next = cur;

    // 首先需要保证前面能链接上
    pre.next = cur.next;
    cur.next = next;

    pre = cur;
    cur = next;
  }
  return dummy.next;
};
```

```js
var swapPairs = function(head) {
  if (head === null || head.next === null) {
    return head;
  }
  // 相当于先拿两个节点进行处理
  const newHead = head.next;
  head.next = swapPairs(newHead.next);
  newHead.next = head;
  return newHead;
};
```

### [25].K 个一组翻转链表 reverseKGroup

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：

- 你的算法只能使用常数的额外空间。
- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：

给定这个链表：`1->2->3->4->5`

当 k=2 时，应当返回：`2->1->4->3->5`

当 k=3 时，应当返回：`3->2->1->4->5`

解题思路

这道题考察了两个知识点：

1.  对链表翻转算法是否熟悉
2.  对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif)

1.  将 curr 指向的下一节点保存到 next 指针；
2.  curr 指向 prev，一起前进一步；
3.  重复之前步骤，直到 k 个元素翻转完毕；
4.  当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。

**注意**：这道题是“LeetCode 第 24 题，两个一组翻转链表“的扩展，即当 k 等于 2 时，第 25 题就变成了第 24 题。

## 排序

### 冒泡排序(稳定)

原地排序、稳定排序。每次两两比较，大的放到后面。每一次遍历都会将最后一位“就位”。

- 最好 O(n)
- 最坏 O(n^2)
- 平均 O(n^2)

```js
function sort(arr = []) {
  const len = arr.length;
  // 外层，需要遍历的次数
  for (let i = 0; i < len - 1; i++) {
    // 内层，每次比较
    for (let j = i + 1; j < len; j++) {
      if (arr[i] > arr[j]) {
        // 大的放到后面
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  }
  return arr;
}
```

### 选择排序(不稳定)

选择排序，从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。

原地排序；不稳定排序

复杂度：

- 最好 O(n^2)
- 最坏 O(n^2)
- 平均 O(n^2)

```js
function sort(arr) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    let min = i;
    // 找到第 n 个最小值。 在 arr[i + 1, arr.length - 1] 中找最小值索引， i+1 代表有序的下一个数，我们默认第一个元素是最小的
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) min = j;
    }
    // 每次循环， a[i] 位都将是未选择出的数据中的最小值
    if (min !== i) {
      [arr[i], arr[min]] = [arr[min], arr[i]];
    }
  }
  return arr;
}
```

### 快速排序(不稳定)

时间复杂度 O(nlogn)

```js
function swap(a, i, j) {
  let temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}

function quickSort(arr, start = 0, end = arr.length - 1) {
  if (arr && arr.length < 2) return arr;
  if (start >= end) return;

  let target = arr[start],
    i = start,
    j = end;

  while (i < j) {
    while (target <= a[j] && i < j) j--;
    while (target >= a[i] && i < j) i++;

    if (i < j) swap(arr, i, j);
  }

  // i === j
  swap(arr, start, i);
  quickSort(arr, start, i - 1);
  quickSort(arr, i + 1, end);

  return arr;
}
```

## 二分查找

非递归版本：

```js
const binarySearch = (arr, target) => {
  let i = 0,
    j = arr.length - 1;
  while (i <= j) {
    let mid = i + ((j - i) >> 1);
    if (target === arr[mid]) return mid;
    if (target < arr[mid]) {
      j = mid - 1;
    } else {
      i = mid + 1;
    }
  }
  return -1;
};
```

递归版本：

```js
const binarySearch = (a, left, right, key) => {
  const mid = (left + right) >> 1;
  if (a[mid] === key) return mid;
  if (a[mid] > key) return binarySearch(a, left, mid - 1, key);
  if (a[mid] < key) return binarySearch(a, mid + 1, right, key);
};
```

## 斐波那契

时间复杂度 O(n) 空间复杂度 O(1)

```js
var fib = function(n) {
  if (n < 2) return n;
  let i = 0,
    j = 1;
  while (n > 1) {
    [i, j] = [j, i + j];
    n--;
  }
  return j;
};
new Array(10).fill(0).forEach((item, index) => console.log(fib(index)));
```

## 字符串/数组

两数之和：找出数组中两个元素的和为 target 的组合
三数之和

给定两个无重复升序数组，求合并之后数组。如给定 m={1,2,3},n{2,4,5},则应输出{1,2,3,4,5}
合并乱序区间
两个无序数组合并成一个有序数组，问时间复杂度。 延伸：快排和冒泡排序的时间复杂度，使用场景
合并 k 个有序数组
数组中的第 K 个最大元素
在一个无序数组中找到第二大的数

回文字符串，字符串中最长回文子串
字符串中的第一个唯一字符
找出字符串中第一个不重复的字符
给定一个字符串，找出其中无重复字符的最长子字符串长度 ![](https://pic4.zhimg.com/80/v2-d8136dca742eb7560c23d1a39e99e86b_1440w.jpg) ![](https://pic1.zhimg.com/80/v2-291f6f8dcd093229bb7d0a9102c826dc_1440w.jpg)

给一数组和一数字，求数组中出现次数大于数组长度除该数字的项？
数组中数字出现的次数 https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/

实现一个 match 函数 判断 `()()()[] => true` , `{{[(){}[]}}=>true , {{{[]][]}}}[] =>false`
数组顺时针螺旋遍历
搜索旋转排序数组

剑指 Offer 39. 数组中出现次数超过一半的数字
剑指 Offer 50. 第一个只出现一次的字符 45° 打印矩阵，回形打印矩阵

### 实现 reduce

```js
function reduce(array, fn, value) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    value = fn(value, current, i, array);
  }
  return value;
}
```

### 整数数组的最大子串和

```js
// 求整数数组的最大子串和，如 [-23, 17, -7, 11, -2, 1, -34] 的最大子串和是21，对应子串是 [17, -7, 11]
function maxSeqSum(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const len = arr.length;
  let maxSum = arr[0];
  let seqSum = arr[0];
  for (let i = 1; i < len; i++) {
    if (seqSum <= 0) {
      seqSum = arr[i];
    } else {
      seqSum += arr[i];
    }
    if (seqSum > maxSum) {
      maxSum = seqSum;
    }
  }
  return maxSum;
}
```

### 合并两个有序数组

```js
function mergeSortedArray(arrA, arrB) {
  var result = [];
  var i = 0,
    j = 0,
    targetLen = arrA.length,
    toolLen = arrB.length;

  while (i < targetLen && j < toolLen) {
    if (arrA[i] < arrB[j]) {
      result.push(arrA[i++]);
    } else {
      result.push(arrB[j++]);
    }
  }

  while (i < targetLen) {
    result.push(arrA[i++]);
  }
  while (j < toolLen) {
    result.push(arrB[j++]);
  }
  return result;
}
```

### 查找第 K 大的数

```js
function findKMax(a, k) {
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  let len = a.length - key;

  while (len !== k) {
    if (len > k) {
      key = partition(a, key + 1, right);
    } else {
      key = partition(a, left, key - 1);
    }
    len = a.length - key;
  }

  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让 key 为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把 key 现在所在的下标返回
}
```

### 最长无重复子串

```js
var lengthOfLongestSubstring = function(s = '') {
  let start = 0,
    longestLen = 0;
  const map = {};

  for (let i = 0; i < s.length; i++) {
    const val = s[i];

    if (val in map && map[val] >= start) {
      // 旧节点往后移一位
      start = map[val] + 1;
      map[val] = i;
    } else {
      map[val] = i;
      longestLen = Math.max(longestLen, i + 1 - start);
    }
  }
  return longestLen;
};
```

### 洗牌算法 shuffle

算法思想就是 从原始数组中随机抽取一个新的元素到新数组中

```js
function shuffle(arr) {
  var result = [],
    random;
  while (arr.length > 0) {
    random = Math.floor(Math.random() * arr.length);
    result.push(arr[random]);
    arr.splice(random, 1);
  }
  return result;
}
```

## 链表

实现一个函数，将输入的数组转为链表，并实现一个方法向链表指定位置插入值
环形链表
从排好序的两个链表中，找到相同的节点，并输出链表
面试题 02.07. 链表相交

### 反转链表

```js
// 递归
var reverseList = function(head) {
  let reverse = (prev, curr) => {
    if (!curr) {
      return prev;
    }
    let next = curr.next;
    curr.next = prev;
    return reverse(curr, next);
  };
  return reverse(null, head);
};
```

```js
// 迭代
var reverseList = function(head) {
  let prev = null;
  let curr = head;
  while (curr != null) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
};
```

### 合并两个排序的链表

合并 2 个有序单链表成为 1 个新的有序单链表

#### 思路分析

准备一个指针`node`，假设指向两个链表的中节点的指针分别是：`p1`和`p2`。

1. 比较`p1`和`p2`的`value`大小

- 如果，p1.value 小于 p2.value, node.next 指向 p1, p1 向后移动
- 否则，node.next 指向 p2, p2 向后移动

2. 重复第 1 步，直到其中一个链表遍历完
3. 跳出循环，将 node.next 指向未遍历完的链表的剩余部分

整个过程的时间复杂度是 O(N), 空间复杂度是 O(1)

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

### 两个链表的第一个公共结点

#### 思路一：栈实现

在第一个公共节点前的节点都是不相同的，因此只要倒序遍历两个链表，找出最后一个出现的相同节点即可。

因为链表不能倒序遍历，所以借助栈实现。

```js
/**
 * 思路一：利用栈实现
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method1(list1, list2) {
  const stack1 = [],
    stack2 = [];

  let node = list1;
  while (node) {
    stack1.push(node);
    node = node.next;
  }

  node = list2;
  while (node) {
    stack2.push(node);
    node = node.next;
  }

  node = null;
  while (stack1.length && stack2.length) {
    let top1 = stack1.pop(),
      top2 = stack2.pop();
    if (top1 === top2) {
      node = top1;
    } else {
      break;
    }
  }

  return node;
}
```

#### 思路二：快慢指针

假设链表 A 长度大于链表 B 长度，它们的长度差为 diff。

让 A 的指针先移动 diff 的位移，然后 A 和 B 的指针再同时向后移动，每次比较节点，选出第一个出现的相同节点。

```js
/**
 * 思路二：快慢指针
 *
 * @param {Node} list1
 * @param {Node} list2
 */
function method2(list1, list2) {
  let length1 = 0,
    length2 = 0;

  let node = list1;
  while (node) {
    ++length1;
    node = node.next;
  }

  node = list2;
  while (node) {
    ++length2;
    node = node.next;
  }

  let diff = Math.abs(length1 - length2),
    longList = null,
    shortList = null;
  if (length1 > length2) {
    longList = list1;
    shortList = list2;
  } else {
    longList = list2;
    shortList = list1;
  }

  while (diff > 0) {
    longList = longList.next;
    --diff;
  }

  while (longList && shortList) {
    if (longList === shortList) {
      return longList;
    }
    longList = longList.next;
    shortList = shortList.next;
  }

  return null;
}
```

#### 思路三： 另一种快慢指针

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```js
function findFirstCommonNode(pHead1, pHead2) {
  const len1 = getLinkLength(pHead1),
    len2 = getLinkLength(pHead2);

  let pLong = pHead1,
    pShort = pHead2,
    lenGap = len1 - len2;
  if (len1 < len2) {
    pLong = pHead2;
    pShort = pHead1;
    lenGap = len2 - len1;
  }
  while (lenGap--) {
    pLong = pLong.next;
  }
  while (pLong !== null) {
    // pLong,pShort一起跑
    if (pLong.val === pShort.val) {
      return pLong;
    }
    pLong = pLong.next;
    pShort = pShort.next;
  }
  return null;
}

function getLinkLength(pHead) {
  let length = 0;
  while (pHead !== null) {
    pHead = pHead.next;
    length++;
  }
  return length;
}
```

### 判断链表是否存在环

使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。

```js
/**
 * 哈希表 Set add has 来查询
 * 牺牲了空间换时间
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let set = new Set();
  // 停止条件： 1. Set 判断出有环 2. 无环，正常结束
  while (head != null) {
    if (set.has(head)) {
      return true;
    } else {
      set.add(head);
    }
    head = head.next;
  }
  return false;
};
```

```js
/**
 * 快慢指针。 如果有环，快指针一定能追上慢指针
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  if (head === null) return false;
  if (head.next === null) return false;

  let fast = head.next;
  let slow = head;

  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    // 快指针一次移动两个
    const next = fast.next;
    fast = next && next.next;
  }

  return false;
};
```

### 回文链表

请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用  O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

快慢指针，起初都指向表头，快指针一次走两步，慢指针一次走一步，遍历结束时：

要么，slow 正好指向中间两个结点的后一个。
要么，slow 正好指向中间结点。
用 prev 保存 slow 的前一个结点，通过 prev.next = null 断成两个链表。

将后半段链表翻转，和前半段从头比对。空间复杂度降为 O(1)。

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
  let fast = head,
    slow = head;
  while (fast != null && fast.next !== null) {
    // 慢指针一次走一步
    slow = slow.next;
    // 快指针一次走两步
    fast = fast.next.next;
  }
  slow = reverseList(slow);
  // slow 一定比 head 要短，所以不用判读较长的链表的情况
  while (slow != null) {
    if (slow.val != head.val) return false;
    slow = slow.next;
    head = head.next;
  }
  return true;
};

var reverseList = function(head) {
  let ans = null,
    cur = head;
  while (cur != null) {
    let nextTmp = cur.next;
    cur.next = ans;
    ans = cur;
    cur = nextTmp;
  }
  return ans;
};
```

## 二叉树

### 二叉树前中后遍历

#### 递归

前序

```js
const res = [];
var inorderTraversal = function(root) {
  if (root === null) return;
  // 中-左-右
  res.push(root);
  inorderTraversal(root.left);
  inorderTraversal(root.right);
  return res;
};
```

中序

```js
const res = [];
var inorderTraversal = function(root) {
  if (root === null) return;
  // 左-中-右
  inorderTraversal(root.left);
  res.push(root);
  inorderTraversal(root.right);
  return res;
};
```

后序

```js
const res = [];
var inorderTraversal = function(root) {
  if (root === null) return;
  // 左-右-中
  inorderTraversal(root.left);
  inorderTraversal(root.right);
  res.push(root);
  return res;
};
```

#### 非递归

前序遍历

```js
function preorderTraversal(root) {
  if (!root) return null;
  const ret = [];
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    ret.push(node.val);
    // 先右后左，保证左子树先遍历
    stack.push(node.right);
    stack.push(node.left);
  }
  return ret;
}
```

中序遍历

```js
// 迭代
var inorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根.
  while (root || stack.length) {
    if (root) {
      // 先往左，迭代存入所有的根
      stack.push(root);
      root = root.left;
    } else {
      // 拿出根之后，先压入左值
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};
```

后序遍历

```js
function postOrderTraversal(root) {
  if (!root) return null;
  const ret = [];
  const stack = [root];
  while (stack.length) {
    const node = stack.pop();
    if (node == null) continue;
    ret.push(node.val);
    stack.push(node.left);
    stack.push(node.right);
  }
  return ret.reverse();
}
```

### 二叉树层次遍历

层次遍历二叉树

树的遍历有几种方式，实现下层次遍历

二叉树深度优先遍历(递归、非递归)
二叉树广度优先遍历(递归、非递归)

### 二叉搜索树中第 K 小的元素

```js
let kthSmallest = function(root, k) {
  let res = null;
  let inOrderTraverseNode = function(node) {
    if (node !== null && k > 0) {
      // 先遍历左子树
      inOrderTraverseNode(node.left);
      // 然后根节点
      if (--k === 0) {
        res = node.val;
        return;
      }
      // 再遍历右子树
      inOrderTraverseNode(node.right);
    }
  };
  inOrderTraverseNode(root);
  return res;
};
```

### 合并二叉树

```js
/**
 * 递归思想
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
  if (t1 === null) return t2;
  if (t2 === null) return t1;
  t1.val += t2.val;
  t1.left = mergeTrees(t1.left, t2.left);
  t1.right = mergeTrees(t1.right, t2.right);
  return t1;
};
```

### 翻转二叉树

```js
var mirrorTree = function(root) {
  if (root === null) {
    return null;
  }
  // 交换左右节点
  let left = root.left;
  root.left = root.right;
  root.right = left;
  // 继续处理左右子树
  if (root.left) {
    mirrorTree(root.left);
  }
  if (root.right) {
    mirrorTree(root.right);
  }
  return root;
};
```

### [104].二叉树的最大深度 Maximum Depth of Binary Tree

```js
/**
 * 递归
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (root == null) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### [105].从前序与中序遍历序列构造二叉树

> 剑指 offer 7 重建二叉树

```js
/**
 * 根据前序遍历和中序遍历重构二叉树
 * @param {Array} preorder
 * @param {Array} inorder
 * @return {Node}
 */
var buildTree = function(preorder, inorder) {
  if (!preorder.length || !inorder.length) return null;
  // 前序的第一个值为根节点
  const headValue = preorder[0];
  // 前序第一个是根节点，也是中序左右子树的分割点
  // 通过变量 index 可以确定在 前序遍历 / 中序遍历中 确定 左 / 右子树的长度
  const index = inorder.findIndex(val => val === headValue);
  if (index === -1) return null;

  // 递归左右子树的前序、中序
  const left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));
  const right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));
  return new TreeNode(headValue, left, right);
};
```

### 求根节点到叶节点数字之和

```js
var sumNumbers = function(root, t = 0) {
  if (!root) return 0;
  if (!root.left && !root.right) return t + root.val;
  t = (t + root.val) * 10;
  return sumNumbers(root.left, t) + sumNumbers(root.right, t);
};
```

### 和为 n 的二叉树路径

找到二叉树路径和为 n 的路径

给一个二叉树和一个值，问是否有一条路径上的值相加等于该值的，有就返回 true，没有就返回 false
蛇形二叉树
求二叉树每层的最大节点

二叉树中的所有路径
二叉树中和为某一值的路径
给定一个二叉树, 找到该树中两个指定节点间的最短距离

平衡二叉树
路径总和
路径总和 II
剑指 Offer 28. 对称的二叉树
剑指 Offer 55 - I. 二叉树的深度前中后序知道其二还原二叉树

### 路径总和

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
//  根节点到叶子节点 的路径 DFS ===> 前序遍历
var hasPathSum = function(root, targetSum) {
  if (dfs(root, targetSum)) {
    return true;
  }
  return false;
  function dfs(root, targetSum) {
    // 递归base case===>边界处理
    if (!root) {
      return false;
    }
    //  递归base case===>正确结果的处理
    targetSum = targetSum - root.val;
    if (targetSum === 0 && !root.left && !root.right) {
      return true;
    }
    if (dfs(root.left, targetSum)) {
      return true;
    }
    if (dfs(root.right, targetSum)) {
      return true;
    }
  }
};
```

### 剑指 Offer 32 - I. 从上到下打印二叉树

```js
var levelOrder = function(root) {
  const res = [];
  function traversal(root, depth) {
    if (root !== null) {
      if (!res[depth]) {
        res[depth] = [];
      }
      traversal(root.left, depth + 1);
      res[depth].push(root.val);
      traversal(root.right, depth + 1);
    }
  }
  traversal(root, 0);
  return res;
};
```

## 动态规划

### 爬楼梯(经典 DP）

```js
// 时间复杂度 O(n) 空间复杂度 O(1)
function fib(n) {
  if (n < 3) return 1;
  let f = 0,
    s = 1;
  while (--n) {
    // s += f; // f + s
    // f = s - f; // 旧 s 值
    [f, s] = [s, f + s];
  }
  return s;
}
```

## 回溯

剑指 Offer 38. 字符串的排列

## 找到所有出现两次的元素

不用到任何额外空间并在 O(n)时间复杂度: 原地哈希

```js
var findDuplicates = function(nums) {
  const res = [];

  for (const num of nums) {
    const absNum = Math.abs(num);
    if (nums[absNum - 1] < 0) {
      res.push(absNum);
    } else {
      nums[absNum - 1] *= -1;
    }
  }

  return res;
};
```

## 编写一个树的深度优先遍历函数（节点最深的最先访问到，依次类推），满足以下测试用例

```js
// 假设树的结构如下：
const tree = [
  {
    id: 1,
    name: '张三',
    children: [
      {
        id: 2,
        name: '李四',
        children: [
          {
            id: 5,
            name: '张五',
          },
        ],
      },
    ],
  },
  {
    id: 6,
    name: '玛丽',
  },
];

//测试用例：
//1. 生成一棵新树，姜将所有节点的id,加1
console.log(
  treeMap(tree, node => {
    let newNode = { ...node };
    newNode.id = node.id + 1;
    return newNode;
  }),
);
//打印的新树，应该与tree的结构一致，只是每个id自增1，老的tree，应该没有任何改动
//2.打印每个节点的id
treeMap(tree, node => {
  console.log(node.id);
  return node;
});
//应打印顺序应该是：5,2,1,6
//3. 对于非法输入，应直接返回第一个入参
console.log(treeMap(null)); //输出null
console.log(treeMap(tree, true /*不是函数*/)); //输出tree
```

## 实现一个 getIntersection 函数，可获取多个区间的交集

```js
function intersection(left, right) {
  let seen = left.reduce((seen, item) => {
    seen[item] = true;
    return seen;
  }, {});

  return right.reduce((result, current) => {
    if (current in seen) {
      return result.concat(current);
    }
    seen[current] = true;
    return result;
  }, []);
}
```

## 老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。

目标是尽量让更多的孩子满意。 如孩子的要求是 1, 3, 5, 4, 2，饼干是 1, 1，
最多能让 1 个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是 7, 6, 5，最多能
让 2 个孩子满足。

## 给定一个正整数数列 a, 对于其每个区间, 我们都可以计算一个 X 值;

X 值的定义如下: 对于任意区间, 其 X 值等于区间内最小的那个数乘上区间内所有数和;
现在需要你找出数列 a 的所有区间中, X 值最大的那个区间;
如数列 a 为: 3 1 6 4 5 2; 则 X 值最大的区间为 6, 4, 5, X = 4 \* (6+4+5) = 60;
