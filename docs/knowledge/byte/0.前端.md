---
title: 字节前端准备-基础
date: 2021-03-04
draft: true
---

# 基础知识

## 继承

### new

new 做了什么事情。new 一个构造函数，如果构造函数返回 return {}、return null，会出现什么情况

1. new 关键字会首先创建一个空对象
2. 将这个空对象的原型对象指向构造函数的原型属性，从而继承原型上的方法
3. 将 this 指向这个空对象，执行构造函数中的代码，以获取私有属性
4. 如果构造函数返回了一个对象 res，就将该返回值 res 返回，如果返回值不是对象，就将创建的对象返回

### 继承

JS 继承的 6 种方法:

1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 寄生继承
5. 拷贝继承
6. Class 继承

## this

1. this 指针的指向 四种调用，箭头函数，再说了一下 call 改变指针的实现思路。
2. call/apply/bind
3. 函数柯里化(JS 中 bind 函数和数组的 reduce 方法用到了函数柯里化。)

使用 `use strict` 的时候，this 的值应该为 undefined

## 0.1 + 0.2 === 0.3

JS 中的 number 类型是浮点类型。计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数，但不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差.

为了解决这个问题可以使用 toFixed()。 `console.log(0.1)` 是因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程。

## instanceof 原理

`instanceof` 可以准确的判断复杂数据类型，但是不能正确判断基本数据类型。`instanceof`是通过原型链来进行判断的，所以只要不断地通过访问`__proto__`，就可以拿到构造函数的原型`prototype`, 直到`null`停止。

`instanceof`的**原理**：判断实例对象的`__proto__`属性，和构造函数的`prototype`属性，是否为同一个引用（是否指向同一个地址）。

```js
function instanceof(left, right) {
  // 获得类型的显示原型
  let prototype = right.prototype;
  // 获得对象的隐式原型
  left = left.__proto__;
  // 判断对象的类型是否等于类型的原型
  while (true) {
    // 直到对象原型为 `null`，因为原型链最终为 `null`
    if (left === null) return false;
    if (prototype === left) return true;
    left = left.__proto__;
  }
}
```

`instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

```js
const Person = function() {};
const p1 = new Person();
p1 instanceof Person; // true

const str = 'hello world';
str instanceof String; // false

const str1 = new String('hello world');
str1 instanceof String; // true
```

比如说：

`foo instanceof Foo`的结果为 true，因为`foo.__proto__ === Foo.prototype`为`true`。

**`foo instanceof Object`的结果也为 true**，为`Foo.prototype.__proto__ === Object.prototype`为`true`。

> 所以不能轻易的说：`foo` 一定是 由`Object`创建的实例`。这句话是错误的。

### 判断对象是哪个类的直接实例

已知 A 继承了 B，B 继承了 C。怎么判断 a 是由 A**直接生成**的实例，还是 B 直接生成的实例呢？还是 C 直接生成的实例呢？

> 分析：这就要用到原型的`constructor`属性了。

`foo.__proto__.constructor === M`的结果为`true`，但是 `foo.__proto__.constructor === Object`的结果为`false`。

所以，用 `constructor`判断就比用 `instanceof`判断，更为严谨。

```js
function A() {}
const a = new A();
a.__proto__ === A.prototype; // true
A.prototype.constructor === A; // true
a.__proto__.constructor === A; // true
a.constructor === A; // true
A.constructor === Function; // true
```

## ES6

### es6 特性

Class，模块化，箭头操作符，let/const 块作用域，字符串模板，解构，参数默认值/不定参数/拓展参数, Map/Set, Promise

### var、let 和 const 区别

1. var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会
2. var 定义的变量会提升， 而 let 和 const 定义的变量不会
3. let 和 const 是 JS 中的块级作用域
4. 同一作用域下 let 和 const 不允许重复声明(会抛出错误)
5. let 和 const 定义的变量在定义语句之前，如果使用会抛出错误(形成了暂时性死区)，而 var 不会。
6. const 声明一个只读的常量。一旦声明，常量的值就不能改变(如果声明是一个对象，那么不能改变的是对象的引用地址)

### 箭头函数与普通函数的区别？

箭头函数是普通函数的简写，和普通函数相比区别：

1. 箭头函数没有属于自己的 this，arguments。函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，它会从自己的作用域链的上一层继承 this（因此无法使用 apply/call/bind 进行绑定 this 值）。call 和 apply 方法只有参数，没有作用域
   1. function 传统定义的函数，this 指向随着调用环境的改变而改变，而箭头 函数中的指向则是固定不变，一直指向定义环境的。箭头函数在定义之后，this 就不会发生改变了。
2. 普通 function 的声明在变量提升中是最高的，箭头函数没有函数提升
3. 箭头函数不可以使用 arguments 对象,，该对象在函数体内不存在，如果要用，可以用 rest 参数代替
4. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数
5. 不绑定 super 和 new.target
6. 箭头函数不能作为构造函数，不能被 new，没有 prototype

## Promise

1. promise 与 generator 的区别
2. promise 的几个 api，手写 promise。 promise 如何退出请求，用 race 实现。
3. Promise 的执行题
4. then 第二个参数与 catch 的区别
5. 用 promise 实现一个请求超时功能
6. promise.then().then() ，promise.catch().then() ok 不？ promise 其他东西
7. 实现一个 Promise.all
8. promise.all 和 promise.race 介绍（手写）
9. 实现 Promise.all, Promise.allSettled

## Proxy 与 Object.defineProperty

5.  聊聊 Proxy。Proxy 和 Object.defineProperty。 defineProperty 有什么缺点？为什么用 Proxy，对 Proxy 了解多少？

## 事件

### 事件流

事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。

### 事件代理

target 和 currentTarget

### Event Loop

宏任务和微任务

eventloop 判断输出 说了下 node 环境（版本不同还有区别）的和浏览器环境的输出，结果相同

## 模块化

1. **立即执行函数**：在一个单独的函数作用域中执行代码，避免变量冲突。
2. **CommonJs**：同步加载，主要用在服务器端 node 。输出的是值拷贝。 正是因为是值拷贝，所以可能会存在性能问题。
3. **AMD**：异步加载。`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
4. **CMD**：异步加载。`seajs` 在推广过程中对模块定义的规范化产出，支持动态引入依赖文件延迟执行，推崇依赖就近。
5. **UMD**：兼容 AMD 和 commonJS 规范的同时，还兼容全局引用的方式。能够运行在浏览器或服务器环境。
6. **ES6 Module**：ES6 模块。模块输出的是一个值的引用，编译时输出接口。

### ES Module 与 CommonJS 的区别

1. ES Module 是值的引用，CommonJS 是值的拷贝。
2. ES Module 编译时就能确定模块的依赖关系，以及输入和输出的变量，输出接口，CommonJS 运行时加载。require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。
3. ES Module 是异步导入，因为用于浏览器避免对渲染有影响。 CommonJS 是同步导入，因为用于服务端，同步导入会很快。
4. ES6 Module 的 this 是 undefined， CommonJs 的 this 是当前模块，

### UMD

UMD 的实现很简单：

1. 先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。
2. 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。
3. 前两个都不存在，则将模块公开到全局（window 或 global）。

# CSS

## 盒模型

盒模型包含： 内容(content)、填充(padding)、边界(margin)、 边框(border)。

有两种盒模型， IE 盒子模型、标准 W3C 盒子模型；

区 别： IE 盒子模型的 content 部分把 border 和 padding 计算了进去;

box-sizing 的默认属性是 content-box。

```css
/* 设置当前盒子为 标准盒模型（默认） */
box-sizing: content-box;

/* 设置当前盒子为 IE盒模型 */
box-sizing: border-box;
```

## 其他基础

1. 单位 rem 的理解
2. display:none, visibility:hidden, opactiy:0 的区别。
3. 行内元素/块状元素
4. Sass/Less/postcss

## Flex

1. flex 布局，有哪些属性。 flex: 1 flex-basic 是什么含义

## Position

1. static 默认值。遵循常规流。
2. relative 相对定位。遵循常规流。相对于元素本身定位，不会使元素脱离文档流，会占据原来的位置，不设置偏移量时没有任何影响。
3. absolute 绝对定位。脱离文档流，相对于第一个 position 的属性值为非 static 的父元素来进行偏移，如果找不到就相对窗口定位。
4. fixed 固定定位。相对于窗口进行定位。
5. sticky 粘性定位。像是 relative 和 fixed 的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如 fixed。该属性的表现是现实中你见到的吸附效果。
6. center 与 absolute 一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。
7. page 与 absolute 一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个 absolute 模式。

绝对定位是相对于最近的已经定位的祖先元素，没有则相对于 body，绝对定位脱离文档流，而相对定位是相对于元素在文档中的初始位置，并且相对定位的元素仍然占据原有的空间。

## BFC

只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。

1. 层叠上下文 bfc. BFC 与 IFC 的区别. 如何形成 BFC.BFC 会与 float 元素相互覆盖吗？为什么？举例说明
2. marigin 塌陷是什么
3. 定位 position bfc ? margin 合并，清除浮动

## 伪类和伪元素

伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素

伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如 `:visited`，`:active`；后者包含那些满足一定逻辑条件的 DOM 树中的元素，比如 `:first-child`，`:first-of-type`。

伪元素为 DOM 树没有定义的虚拟元素。比如 `::before` 表示选择元素内容的之前内容，`::selection` 表示选择元素被选中的内容。

## 渲染、绘制相关

1. css3 用过哪一些？border-radius、transition
2. 重绘回流。 怎样移动一个标签却不导致重排？transform
3. 单行文本溢出，多行文本溢出的代码实现
4. css 绘制三角形
5. lineheight 属性 1.5 和 150%区别
6. 实现一个模态窗口，要从窗口下面向上弹的动画
7. CSS 性能优化（较难，需要一定知识深度和广度）

## 布局

1.  基本布局，居中/常见布局
2.  垂直、水平居中定位的几种方式
3.  css 实现这样一个布局： 无论外层容器宽高如何变化，内层始终相对于外层容器垂直居中，左右各相距 20px，同时内层的高度始终为自身宽度的 50%。（至少写一种，说出实现多种）
4.  实现左边固定,右边自适应的布局
5.  三栏布局 右侧固定左侧和中间自适应
6.  实现固定宽高比(width: height = 4: 3)的 div，怎么设置
7.  css div 垂直水平居中，并完成 div 高度永远是宽度的一半（宽度可以不指定）
8.  实现一个 div 相对视口居中
9.  header 头部固定，剩下 body 占满全部高，超出就上下滚动，如何实现 ？

# 浏览器

html5 的标签有哪些？说一下怎么用的？
V8 内存回收机制。 关键词：老生代，新生代。引用计数、标记清理
回流重绘，为什么用 transform 写动画不用 position top left
js 脚本加载问题，async、defer 问题: 如果依赖其他脚本和 DOM 结果，使用 defer. 如果与 DOM 和其他脚本依赖不强时，使用 async

# 移动端

1. 移动端适配方案
2. 1px retina 屏幕的处理

# 框架

## MVVM/MVC

### 虚拟 dom

对虚拟 Dom 的理解

#### Diff

Diff 过程。Vue 的 Dom diff 的实现。 完全比较两个 Dom 树和只比较同层节点的算法复杂度各是多少？Dom diff 具体流程是怎么样的，内部细节能说一下么

#### for 循环与 Key

## vue

1. vue 是怎么解析模板的？
2. 生命周期
3. 组件通信
4. computed/watch 原理. computed 和 watch 的差异
5. React Hoc/Vue mixin
6. vue3.0 的新特性，了解 compose api 和 react hooks 的区别
7. vue-router 的原理， hashchange 和 pushState
8. vue 事件修饰符，原生 dom 事件，捕获
9. vue 自定义事件会冒泡吗
10. vue 事件是冒泡阶段还是捕获阶段触发
11. vue 中 next-tick 的作用与大概实现原理 ？
12. vue 按需加载的方式有几种，是哪几种 ？

### vue react omi 的区别

### 双向绑定

angular 的脏检查和 vue 的双向数据绑定有什么区别？
Object.defineProperty 的几个属性

### 实现一个 vue 的双向绑定

```js
class Observer {
  constructor(data) {
    // 遍历参数data的属性,给添加到this上
    for (let key of Object.keys(data)) {
      if (typeof data[key] === 'object') {
        data[key] = new Observer(data[key]);
      }
      Object.defineProperty(this, key, {
        enumerable: true,
        configurable: true,
        get() {
          console.log('你访问了' + key);
          return data[key]; // 中括号法可以用变量作为属性名,而点方法不可以;
        },
        set(newVal) {
          console.log('你设置了' + key);
          console.log('新的' + key + '=' + newVal);
          if (newVal === data[key]) {
            return;
          }
          data[key] = newVal;
        },
      });
    }
  }
}

const obj = {
  name: 'app',
  age: '18',
  a: {
    b: 1,
    c: 2,
  },
};
const app = new Observer(obj);
app.age = 20;
console.log(app.age);
app.newPropKey = '新属性';
console.log(app.newPropKey);
```

```js
const obj = {
  name: 'app',
  age: '18',
  a: {
    b: 1,
    c: 2,
  },
};
const p = new Proxy(obj, {
  get(target, propKey, receiver) {
    console.log('你访问了' + propKey);
    return Reflect.get(target, propKey, receiver);
  },
  set(target, propKey, value, receiver) {
    console.log('你设置了' + propKey);
    console.log('新的' + propKey + '=' + value);
    Reflect.set(target, propKey, value, receiver);
  },
});
p.age = '20';
console.log(p.age);
p.newPropKey = '新属性';
console.log(p.newPropKey);
```

## vue2 与 vue3 的差别

## 开源

generateVuex
omiv.omi
为 omiv 提交了什么内容的代码
cli 具体做了什么，模板是你写的么？ 有哪些功能
封了什么组件，拿一个说说

## 模态弹框处理 modal 组件

https://zhuanlan.zhihu.com/p/144802918

# 网络

## 网络过程

1. url 过程。浏览器渲染（从输入 url 到页面渲染的完成过程）
2. CDN 原理。关键词：DNS 查询，负载均衡
3. DNS
4. TCP 三次握手 四次挥手

## http

1. http 报文头部有哪些字段?有什么意义?
2. http 请求方法， post 与 get 的区别
3. 状态码
4. Content-Type 有哪些
5. x-www-urlecoded-form 和 application/json 在 post 中的区别
6. 文件上传的字符编码类型，之间的区别以及为什么会这样，form 表单默认是谁

## http2 及以上

1.  http/https/http2 特性和优缺点。 http2 关键词：信道复用，server push

## https

1. https 原理：对话过程，以及加密方式
2. https 中间被篡改了怎么识别？
3. https 的原理，以及握手的过程。 对 HTTPS 的理解。HTTPS 密钥的交换过程，HTTPS 绝对安全吗？ HTTPS 欺骗是怎么实现的？
4. 使用 https 也不安全，响应数据中途被修改了，比如说非会员被改成了会员，那你要怎么解决？
5. 中间人劫持，怎么防止。x-frame-option?白屏的喔，怎么办？也不一定嵌入 iframe 啊，可以嵌入脚本、图片，怎么阻止
   1. x-frame-option、重定向、https，请求前加密（https、加密代理）、请求中规避（请求拆包）、请求后弥补（前端做一些逻辑）。嵌入非 iframe 的，如果已经突破了前面两关，走前端逻辑：触发 DOMNodeInserted、DOMContentLoaded、DOMAttrModified 事件。或者是给能 src 的标签加上自己的 data-xx 属性标记区分。

## 缓存

浏览器缓存机制有两种，一种为强缓存，一种为协商缓存。

- 强缓存 200 from cached, 内存，disk
  - 直接从浏览器缓存中读取，不去后台查询是否过期
  - `Expires` 过期时间，值是时间点。缺陷是必须保证服务端时间和客户端时间严格同步。
  - `Cache-Control:max-age=3600` 过期秒数（优先级更高）。解决了客户端和服务端时间必须同步的问题。
- 协商缓存 304 Not Modified
  - 每次使用缓存之前先去后台确认一下
  - `Last-Modified` `If-Modified-Since` 上次修改时间。 值是二进制时间
  - `ETag` `If-None-Match` 值是 hash 唯一标识串

对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。
对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存。

## 跨域

## 应用

1. 跨域 ,跨域的实现方式 cors。 jsonp 原理和实现？
2. cookie 属性。 怎么禁止 js 访问 cookie
3. cookie,session,localstorage,sessionstorage 有什么区别
4. xhr，fetch，axios 的区别
5. tcp 和 udp 的区别以及应用场景
6. TCP 为什么是可靠的？［因为它有 ACK］
7. 那 tpc 和 udp 相比的话，udp 有什么好处？虽然不可靠，但是为什么还有很多基于 udp 的协议［因为 upd 报文小，udp 头部 8 个字节，tcp 头部 20 个字节，而且有些协议也不需要太可靠。］

## 网络分层

OSI 七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

TCP/IP 五层模型：应用层、传输层、网络层、数据链路层、物理层

# 工程化

## webpack

1. webpack 原理以及一些概念
2. webpack 的问题，简述了一下 webpack 的构建过程（不全，主要是 webpack 生命周期忘了）
3. webpack 懂吧？说下用过的 loader 和 plugin
4. webpack 的时候提到了 happypack 和 treeshaking
5. webpack 怎么优化
6. webpack loader/plugin hmr tree-sharking
7. webpack rollup parcel esbuild 等
8. webpack loader 和插件的原理
9. webpack-dev-server hmr 原理
10. DLLPlugin 原理，为什么不直接使用压缩版本的 js
11. HMR 热更替原理
    1. 浏览器是如何更新的
    2. 如何做到页面不刷新也就就自动更新的
    3. webpack-dev-server webapck-dev-middleware
12. tree sharking

## babel

1. babel transform,stage, polyfill, plugin
2. babel 插件写过么？
3. AST

## 其他

1. axios 怎么封装的

# 监控

1. 监控的实现，和错误收集方式
2. 监控做了哪些事情
3. 监控，错误上报 异常排查。
4. 异常监控有哪些，都需要怎么捕获

# 性能优化

如何解决页面卡顿（前端性能优化是一个永恒的话题，综合性很高的一个问题，尽可能回答）
首屏加载优化， 通过哪些指标去衡量性能优化的
你认为 webpack 哪里打包慢
webpack 编译加速 ？关键词：dll、多线程
假如现在，我说有一个页面打开有点慢，交给你来负责优化，你的思路和做法是什么？
前端优化的指标有哪些，通过什么手段获取？
懒加载、虚拟列表的原理
如何实现 list 的无限滚动（节流？）
前端性能优化 对用户来说首批加载时间，srr 服务端渲染，pwa 缓存，懒加载（异步加载 import 函数，图片滚动渲染），预加载（dns 缓存，proload），http 请求合并。 其实还有很多例如：雪碧图等但是当时忘了。
为什么多域名部署:http1 和浏览器的问题，同一时间 6 个连接
TTFB 慢了，如果不加缓存，以前可能是骨架屏，现在直接白屏
出现异常不好定位调试.为了缓存，带权限接口与非权限接口有可能需要剥离
happypack 原理 【多进程打包 又讲了下进程和线程的区别】
你觉得 CommonJS 为什么不能做 Tree-Shaking ?
ESModule 既然是编译时加载，那它可以做到运行时加载吗，想过这个问题吗？(愣了一会，说 webpack 有动态 import 的方式)
单元测试、e2e 测试

角度：

1. 打包优化
2. 网络优化
3. 代码优化

# 前端安全

## XSS 跨站脚本攻击 Cross Site Scripting

1. 反射型：发出请求时，`XSS`代码出现在`url`中，`XSS`代码随响应内容一起传回给浏览器，最后浏览器解析执行`XSS`代码。
2. 存储型：存储型`XSS`和反射型`XSS`的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交 XSS 代码。

危害：

1. 盗用`Cookie`
2. 破坏页面的正常结构，插入广告等恶意内容

XSS 防御：

1. 使用 encodeURIComponent 转义字符(encode)
2. 设置 Cookie 为 HttpOnly
3. CSP 内容安全策略。HTTP Header 中的 `Content-Security-Policy`，只允许加载本站资源或者只允许 https 的图片等。

## CSRF 跨站请求伪造 Cross Site Request Forge

CSRF 是一种跨站请求伪造，冒充用户发起请求。简单点说，CSRF 就是利用用户的登录态发起恶意请求。

跨站请求伪造。条件：

1. 用户在 A 网站确实登录过。
2. A 网站接口存在漏洞，会下发登录态。

防御：

1. token 验证
2. 隐藏令牌：把 `token` 隐藏在 `http` 的 `head`头中
3. Referer 验证（页面来源验证）

## CSRF 和 XSS 的区别

**区别一：**

- `CSRF`：需要用户先登录网站`A`，获取 `cookie`
- `XSS`：不需要登录。

**区别二：（原理的区别）**

- `CSRF`：是利用网站`A`本身的漏洞，去请求网站`A`的`api`。
- `XSS`：是向网站 `A` 注入 `JS`代码，然后执行 `JS` 里的代码，篡改网站`A`的内容。

# 设计模式

1. 单例模式: 很常用，比如全局缓存、全局状态管理等等这些只需要一个对象。在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex
2. 工厂模式: 一个 Class 中包含另一个实现复杂的 Class。 起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。
3. 适配器模式: 用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。例如 Vue 中的 Computed 做的事情。
4. 代理模式: 代理是为了控制对对象的访问，不让外部直接访问到对象。
5. 发布-订阅模式: Vue 的双向绑定。
6. 观察者模式: Vue 的事件。

# 问题排查

如果你发现有个网站你突然打不开了，有哪些可能。（发挥想象，断网啊，DNS 解析出现问题，代理服务器出现问题，流量被劫持了等等）

# 其他

手写继承 ß
instanceof 实现原理
promise 限制并发数
箭头函数跟普通函数的区别
flex 1 全写
vue 双向绑定原理
https 实现原理（越详细越好）
node 进程之间如何通讯
graghgl 如何优化请求速度
node 跟浏览器的 event loop 区别
浏览器渲染也页面过程
如何性能优化
CDN 优化有哪些
webpack 插件原理，如何写一个插件
缓存有哪些，区别是什么
手写 bind、reduce
防抖截流
遍历树，求树的最大层数。求某层最多的节点数
node 开启进程的方法有哪些，区别是什么
node 如何部署的
node check 阶段做了什么，触发了什么事件
前端模块化的理解
node 如何处理错误的
隐式转换
数字在计算机怎么储存的
webpack 优化
webpack 的 require 是如何查找依赖的
webpack 如何实现动态加载
给你一个项目，从头开始你怎么考虑
工作流做了哪些事情
如何提升效率与性能
未来的规划是什么
跨域有哪些
网络安全
链表与数组的区别
变量提升 let const var 区别
链表如何遍历
script 标签中 async 跟 defer 的区别
