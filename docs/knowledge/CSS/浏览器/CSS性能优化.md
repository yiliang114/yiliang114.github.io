---
title: 浏览器
date: 2020-11-21
draft: true
---

### css sprite 是什么,有什么优缺点

概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。

将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background- repeat，background-position 的组合进行背景定位。利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能；CSS Sprites 能减少图片的字节。

CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的"background-image"，"background-repeat"，"background-position" 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是 6 个。

- CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。
- CSS Sprites 为一些大型的网站节约了带宽，让提高了用户的加载速度和用户体验，不需要加载更多的图片。

#### 优点：

减少 HTTP 请求数，极大地提高页面加载速度
增加图片信息重复度，提高压缩比，减少图片大小
更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

- 减少加载多张图片的 HTTP 请求数（一张雪碧图只需要一个请求）。但是对于 HTTP2 而言，加载多张图片不再是问题。
- 提前加载资源，防止在需要时才在开始下载引发的问题，比如只出现在`:hover`伪类中的图片，不会出现闪烁。

#### 缺点：

图片合并麻烦
维护麻烦，修改一个图片可能需要从新布局整个图片，样式

### css 合并方法

避免使用 @import 引入多个 css 文件，可以使用 CSS 工具将 CSS 合并为一个 CSS 文件，例如使用 Sass\Compass 等

### base64 的原理及优缺点

优点可以加密，减少了 http 请求
缺点是需要消耗 CPU 进行编解码

### CSS 优化、提高性能的方法有哪些？

- 多个 css 合并，尽量减少 HTTP 请求
- 将 css 文件放在页面最上面
- 移除空的 css 规则
- 避免使用 CSS 表达式
- 选择器优化嵌套，尽量避免层级过深
- 充分利用 css 继承属性，减少代码量
- 抽象提取公共样式，减少代码量
- 属性值为 0 时，不加单位
- 属性值为小于 1 的小数时，省略小数点前面的 0
- css 雪碧图
- css 压缩与合并、Gzip 压缩
- css 文件放在 head 里、不要用@import
- 尽量用缩写、避免用滤镜、合理使用选择器
- 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；
- 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；
- 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;
- 使用预处理工具或构建工具（gulp 对 css 进行语法检查、自动补前缀、打包压缩、自动优雅降级）；
- 样式是：从右向左的解析一个选择器
- ID 最快，Universal 最慢 有四种类型的 key selector，解析速度由快到慢依次是：ID、class、tag 和 universal
- 不要 tag-qualify （永远不要这样做 ul#main-navigation { } ID 已经是唯一的，不需要 Tag 来标识，这样做会让选择器变慢。）
- 后代选择器最糟糕（换句话说，下面这个选择器是很低效的： html body ul li a { }）
- 想清楚你为什么这样写
- CSS3 的效率问题（CSS3 选择器（比如 :nth-child）能够漂亮的定位我们想要的元素，又能保证我们的 CSS 整洁易读。但是这些神奇的选择器会浪费很多的浏览器资源。）
- 我们知道#ID 速度是最快的，那么我们都用 ID，是不是很快。但是我们不应该为了效率而牺牲可读性和可维护性
- 避免过度约束
- 避免后代选择符
- 避免链式选择符
- 使用紧凑的语法
- 避免不必要的命名空间
- 避免不必要的重复
- 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么
- 避免！important，可以选择其他选择器
- 尽可能的精简规则，你可以合并不同类里的重复规则

### 编写高效的 CSS 应该注意什么？

首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。

原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。

搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。

### 如何使用 CSS 实现硬件加速？

硬件加速是指通过创建独立的复合图层，让 GPU 来渲染这个图层，从而提高性能，
一般触发硬件加速的 CSS 属性有 transform、opacity、filter，为了避免 2D 动画在
开始和结束的时候的 repaint 操作，一般使用 tranform:translateZ(0)

### 重绘和回流（重排）是什么，如何避免？

DOM 的变化影响到了元素的几何属性（宽高）,浏览器重新计算元素的几何属性，其他元素的几何属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分重新绘制到屏幕上的过程称为重绘。

引起重排的原因有

1. 添加或者删除可见的 DOM 元素
2. 元素位置、尺寸、内容改变
3. 浏览器页面初始化
4. 浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排，减少

重绘和重排的方法：

1. 不在布局信息改变时做 DOM 查询
2. 使用 cssText 或者 className 一次性改变属性
3. 使用 fragment
4. 对于多次重排的元素，如动画，使用绝对定位脱离文档流，让他的改变不影响到其他元素

### base64 的使用

- 写入 CSS， 减少 HTTP 请求
- 适用于小图片
- base64 的体积约为原图 4/3

### 1000-div 问题

一次性插入 1000 个 div，如何优化插入的性能

- 使用 Fragment

```js
var fragment = document.createDocumentFragment();
fragment.appendChild(elem);
```

- 向 1000 个并排的 div 元素中，插入一个平级的 div 元素，如何优化插入的性能

  - 先 display:none 然后插入 再 display:block
  - 赋予 key，然后使用 virtual-dom，先 render，然后 diff，最后 patch
  - 脱离文档流，用 GPU 去渲染，开启硬件加速
