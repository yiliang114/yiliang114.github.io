---
title: 浏览器
date: 2020-11-21
draft: true
---

### css sprite 是什么,有什么优缺点

概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。

优点：

1. 减少 HTTP 请求数，极大地提高页面加载速度
2. 增加图片信息重复度，提高压缩比，减少图片大小
3. 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

缺点：

1. 图片合并麻烦
2. 维护麻烦，修改一个图片可能需要从新布局整个图片，样式

### css 合并方法

避免使用 @import 引入多个 css 文件，可以使用 CSS 工具将 CSS 合并为一个 CSS 文件，例如使用 Sass\Compass 等

### base64 的原理及优缺点

优点可以加密，减少了 http 请求
缺点是需要消耗 CPU 进行编解码

- 写入 CSS， 减少 HTTP 请求
- 适用于小图片
- base64 的体积约为原图 4/3

### CSS 优化、提高性能的方法有哪些？

- 多个 css 合并，尽量减少 HTTP 请求
- 将 css 文件放在页面最上面
- 移除空的 css 规则
- 避免使用 CSS 表达式
- 选择器优化嵌套，尽量避免层级过深
- 充分利用 css 继承属性，减少代码量
- 抽象提取公共样式，减少代码量
- 属性值为 0 时，不加单位
- 属性值为小于 1 的小数时，省略小数点前面的 0
- css 雪碧图
- css 压缩与合并、Gzip 压缩
- css 文件放在 head 里、不要用@import
- 尽量用缩写、避免用滤镜、合理使用选择器
- 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；
- 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；
- 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;
- 使用预处理工具或构建工具（gulp 对 css 进行语法检查、自动补前缀、打包压缩、自动优雅降级）；
- 样式是：从右向左的解析一个选择器
- ID 最快，Universal 最慢 有四种类型的 key selector，解析速度由快到慢依次是：ID、class、tag 和 universal
- 不要 tag-qualify （永远不要这样做 ul#main-navigation { } ID 已经是唯一的，不需要 Tag 来标识，这样做会让选择器变慢。）
- 后代选择器最糟糕（换句话说，下面这个选择器是很低效的： html body ul li a { }）
- 想清楚你为什么这样写
- CSS3 的效率问题（CSS3 选择器（比如 :nth-child）能够漂亮的定位我们想要的元素，又能保证我们的 CSS 整洁易读。但是这些神奇的选择器会浪费很多的浏览器资源。）
- 我们知道#ID 速度是最快的，那么我们都用 ID，是不是很快。但是我们不应该为了效率而牺牲可读性和可维护性
- 避免过度约束
- 避免后代选择符
- 避免链式选择符
- 使用紧凑的语法
- 避免不必要的命名空间
- 避免不必要的重复
- 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么
- 避免！important，可以选择其他选择器
- 尽可能的精简规则，你可以合并不同类里的重复规则

### 编写高效的 CSS 应该注意什么？

首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。

原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。

搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。

### 1000-div 问题

一次性插入 1000 个 div，如何优化插入的性能

- 使用 Fragment

```js
var fragment = document.createDocumentFragment();
fragment.appendChild(elem);
```

- 向 1000 个并排的 div 元素中，插入一个平级的 div 元素，如何优化插入的性能

  - 先 display:none 然后插入 再 display:block
  - 赋予 key，然后使用 virtual-dom，先 render，然后 diff，最后 patch
  - 脱离文档流，用 GPU 去渲染，开启硬件加速
