---
title: engineering
date: 2020-11-21
draft: true
---

### 工程化

- webpack 与 Rollup 的区别
- webpack 的工作原理。打包，sourcemap 等处理。
- webpack 的工作原理
- vue-loader css-loader style-loader file-loader 等基本 loader 的原理
- babel 具体做的事情，babel 几个不同插件的有什么不同的作用，register-babel jsx-babel 等
- rollup 是用来干什么的，与 webpack 的区别， pracel 有没有使用过。
- 前端工程化方面做了哪些东西
- 优化 webpack 打包时间：

  1.  hipack 插件？
  2.  使用 dll 插件优化打包时间
  3.  将变动很少的模块划分出 webpack 的主 bundlejs

- 前端工程化的理解、如何自己实现一个文件打包，比如一个 JS 文件里同时又 ES5 和 ES6 写的代码，如何编译兼容他们
- 前端怎么实现模块化
- 模块化工具的特点
- build 环境下一般会对输出的 js 文件再进一步所压缩处理（但是会丢失 sourcemap， 线上出问题无法及时定位）， 同时会去 console 提升性能，去 console 可以使用 webpack 插件或者自行封装一个根据环境变量决定是否输出的 log 方法
- 对 webpack,gulp，grunt 等有没有了解?对比。
- webpack 的入口文件怎么配置，多个入口怎么分割。
- webpack 的 loader 和 plugins 的区别
- gulp 的具体使用。
- 前端工程化的理解、如何自己实现一个文件打包，比如一个 JS 文件里同时又 ES5 和 ES6 写的代码，如何编译兼容他们

### Eslint 的配置

为了遵循代码规范，使用 eslint 是必不可少的，配置 eslint 有两种方式
第一：使用 eslintrc.js 配置文件

```js
// 安装
npm install eslint --save

// 生成文件
npx eslint --init

// 安装 'babel-eslint',并在eslintrc.js中配置
    "parser": 'babel-eslint',
```

第二：通过 eslint-loader 的配置

```js
// 安装
npm install eslint-loader --save-dev
// module中配置
              {
			test: /\.js$/,
			exclude: /node_modules/,
			use: ['babel-loader', {
				loader: 'eslint-loader',
				options: {
					fix: true // 较为简单的错误可以自动帮助修复
				}
			}

// devserver中配置
		overlay: true, // eslint报错时会在屏幕提示
```

为了提升团队的代码规范，也可以通过 git 的钩子，在代码提交时就对代码作出 eslint 检查

### babel-profilly 和 babel-transform-runtime 的区别

一、babel-polyfill
由于 babel 默认只转换新的 JavaScript 语法，但对于一些新的 API 是不进行转化的（比如内建的 Promise、WeakMap，静态方法如 Array.from 或者 Object.assign），那么为了能够转化这些东西，我们就需要使用 babel-polyfill 这个插件
由于 babel-polyfill 是个运行时垫片，所以需要声明在 dependencies 而非 devDependencies 里
二、babel-plugin-transform-runtime
由于使用 babel-polyfill，会产生以下问题：
1）babel-polyfill 会将需要转化的 API 进行直接转化，这就导致用到这些 API 的地方会存在大量的重复代码
2）babel-polyfill 是直接在全局作用域里进行垫片，所以会污染全局作用域
所以，babel 同时提供了 babel-plugin-transform-runtime 这一插件，它的好处在于：
1）需要用到的垫片，会使用引用的方式引入，而不是直接替换，避免了垫片代码的重复
2）由于使用引用的方式引入，所以不会直接污染全局作用域。这就对于库和工具的开发带来了好处
但是 babel-plugin-transform-runtime 仍然不能单独作用。因为有一些静态方法，如"foobar".includes("foo")仍然需要引入 babel-polyfill 才能使用

### 何为 AST

抽象语法树 (Abstract Syntax Tree)，是将代码逐字母解析成 树状对象 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础

### babel 编译原理

babylon 将 ES6/ES7 代码解析成 AST
babel-traverse 对 AST 进行遍历转译，得到新的 AST
新 AST 通过 babel-generator 转换成 ES5
或者：

1. 它就是个编译器，输入语言是 ES6+，编译目标语言是 ES5
1. babel 官方工作原理
1. 解析：将代码字符串解析成抽象语法树
1. 变换：对抽象语法树进行变换操作
1. 再建：根据变换后的抽象语法树再生成代码字符串

### babel、babel-polyfill 的区别

babel-polyfill：模拟一个 es6 环境，提供内置对象如 Promise 和 WeakMap
引入 babel-polyfill 全量包后文件会变得非常大。它提供了诸如 Promise，Set 以及 Map 之类的内置插件，这些将污染全局作用域,可以编译原型链上的方法。
babel-plugin-transform-runtime & babel-runtime：转译器将这些内置插件起了别名 core-js，这样你就可以无缝的使用它们，并且无需使用 polyfill。但是无法编译原型链上的方法

runtime 编译器插件做了以下三件事：

1. 当你使用 generators/async 函数时，自动引入 babel-runtime/regenerator 。
1. 自动引入 babel-runtime/core-js 并映射 ES6 静态方法和内置插件。
1. 移除内联的 Babel helper 并使用模块 babel-runtime/helpers 代替。

### gulp 和 webpack 区别

#### gulp、grunt

gulp 和 grunt 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 gulp 执行这些 task，从而构建项目的整个前端开发流程。

PS：简单说就一个 Task Runner

#### webpack

webpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。

PS：webpack is a module bundle

#### 相同功能

- 文件合并与压缩（css）
- 文件合并与压缩（js）
- sass/less 预编译
- 启动 server
- 版本控制

#### 两者区别

虽然都是前端自动化构建工具，但看他们的定位就知道不是对等的。

gulp 严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。

webpack 更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。

#### 总结

gulp 应该与 grunt 比较，而 webpack 应该与 browserify（网上太多资料就这么说，这么说是没有错，不过单单这样一句话并不能让人清晰明了）。

gulp 与 webpack 上是互补的，还是可替换的，取决于你项目的需求。如果只是个 vue 或 react 的单页应用，webpack 也就够用；如果 webpack 某些功能使用起来麻烦甚至没有（雪碧图就没有），那就可以结合 gulp 一起用

### 工程化能做的事情

工程化这一块，是个人比较感兴趣的一个方向。自己也做过一些实践，但是只能说是工程化中的冰山一角。
抛砖引玉，提一些我们可以探讨的点。

1. 前端项目标准？
   表现为库的选择？文件划分目录的规定？pc、mobile 多端实践？ssr 方案集成？
2. 组件库集成？
   组件库建设的目的？npm 包的发布？
3. 脚手架工具？
   webpack 编译优化？webpack 打包构建优化？自我脚手架的工具使用？
4. git 提交规范 commit-msg？代码检查规范 eslint？
5. 前端性能监控？前端异常监控？前端用户埋点 sdk？
6. rap？jenkins？

### webpack 热更新原理

### treeshaking 原理
