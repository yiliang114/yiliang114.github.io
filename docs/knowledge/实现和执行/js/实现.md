---
title: 类型转换
date: '2020-11-02'
draft: true
---

### 取数组的最大值（ES5、ES6)

```js
// ES5 的写法
Math.max.apply(null, [14, 3, 77, 30]);

// ES6 的写法
Math.max(...[14, 3, 77, 30]);

// reduce
[14, 3, 77, 30].reduce((accumulator, currentValue) => {
  return (accumulator = accumulator > currentValue ? accumulator : currentValue);
});

let arr = [12, 3, 77, 30].sort((a, b) => b - a);
arr[0];
```

### 改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。

```js
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

1.利用块作用域

```js
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

2.利用函数自执行

```js
for (var i = 0; i < 10; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j);
    }, 1000);
  })(i);
}
```

3.利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    i => {
      console.log(i);
    },
    1000,
    i,
  );
}
```

4.很多其它的方案只是把 console.log(i) 放到一个函数里面，因为 setTimeout 函数的第一个参数只接受函数以及字符串，如果是 js 语句的话，js 引擎应该会自动在该语句外面包裹一层函数

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    (i => {
      console.log(i);
    })(i),
    1000,
  );
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    (() => {
      console.log(i);
    })(),
    1000,
  );
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(console.log(i), 1000);
}
```

5.原理：利用 eval 或者 new Function 执行字符串，然后执行过程同方法四

```js
for (var i = 0; i < 10; i++) {
  setTimeout(eval('console.log(i)'), 1000);
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(new Function('i', 'console.log(i)')(i), 1000);
}
```

### 怎么计算在一个页面上的停留时间

1. websocket，前端开个长连接，后台统计长连接时间。
2. ajax 轮询，隔几秒发一个查询，后台记录第一与最后一个查询间隔时间。
3. 关闭窗口或者跳转的时候会触发 window.onbeforeunload 函数，可以在该函数中做处理（有兼容性问题）；统计完数据记录到本地 cookies 中，一段时间后统一发送

### 如何实现文件断点续传

断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。

首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。

因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。

前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。

当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。 有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。

只要用 slice 方法就可以了

```js
var packet = file.slice(start, end);
```

参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块

如

```js
file.slice(0, 1000);
file.slice(1000, 2000);
file.slice(2000, 3000);
// ......
```

在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。 如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。

### 如何处理不让别人盗用你的图片，访问你的服务器资源

http header, 对 refer 做判断看来源是不是自己的网站，如果不是就拒绝
通过 session 校验，如果不通过特定服务生成 cookie 和 session 就不能请求得到资源

### 在一个 UI 李有 10 个 li，实现点击对应的 li，输出对应的下标

```js
function eve() {
  ul.onclick = function (eve) {
    if (eve.target.tagName.toLowerCase() === 'li') {
      console.log(eve.target.innerHTML);
    }
  };
}
```

### 写一个函数实现`n!`

> 实现阶乘，最开始我只想到了递归的方式。还一开始写的有问题，后来修改了才没问题的。

#### 递归方式

```js
function factorial(n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

#### while 循环方式

```js
function factorial(n) {
  var result = 1;

  while (n > 1) {
    result = result * n;
    n--;
  }
  return result;
}
```

### 写一个函数递归调用的例子

> 我写的是!n

```js
function fn(n) {
  if (n <= 1) {
    return n;
  } else {
    return n * fn(n - 1);
  }
}
```

### 实现 (5).add(3).minus(2) 功能。

例： 5 + 3 - 2，结果为 6

```js
Number.prototype.add = function (n) {
  return this.valueOf() + n;
};
Number.prototype.minus = function (n) {
  return this.valueOf() - n;
};
```

### 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

```js
const find = (S, T) => {
  if (S.length < T.length) return -1;
  for (let i = 0; i < S.length; i++) {
    if (S.slice(i, i + T.length) === T) return i;
  }
  return -1;
};
```

### 为什么普通 `for` 循环的性能远远高于 `forEach` 的性能，请解释其中的原因。

- for 循环没有任何额外的函数调用栈和上下文；
- forEach 函数签名实际上是

```js
array.forEach(function(currentValue, index, arr), thisValue)
```

它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；

### 编程题

url 有三种情况

>

```js
https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=&local_province_id=33
https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800&local_province_id=33
https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800,700&local_province_id=33
```

> 匹配 elective 后的数字输出（写出你认为的最优解法）:

```js
[] || ['800'] || ['800', '700'];
```

```js
function getUrlValue(url) {
  if (!url) return;
  let res = url.match(/(?<=elective=)(\d+(,\d+)*)/);
  return res ? res[0].split(',') : [];
}
```

### 考虑到性能问题，如何快速从一个巨大的数组中随机获取部分元素。

比如有个数组有 100K 个元素，从中不重复随机选取 10K 个元素。

由于随机从 100K 个数据中随机选取 10k 个数据，可采用统计学中随机采样点的选取进行随机选取，如在 0-50 之间生成五个随机数，然后依次将每个随机数进行加 50 进行取值，性能应该是最好的。

### 请评价以下事件监听器代码并给出改进意见

```js
if (window.addEventListener) {
  var addListener = function (el, type, listener, useCapture) {
    el.addEventListener(type, listener, useCapture);
  };
} else if (document.all) {
  addListener = function (el, type, listener) {
    el.attachEvent('on' + type, function () {
      listener.apply(el);
    });
  };
}
```

作用：浏览器功能检测实现跨浏览器 DOM 事件绑定

优点：

1. 测试代码只运行一次，根据浏览器确定绑定方法
2. 通过`listener.apply(el)`解决 IE 下监听器 this 与标准不一致的地方
3. 在浏览器不支持的情况下提供简单的功能，在标准浏览器中提供捕获功能

缺点：

1. document.all 作为 IE 检测不可靠，应该使用 if(el.attachEvent)
2. addListener 在不同浏览器下 API 不一样
3. `listener.apply`使 this 与标准一致但监听器无法移除
4. 未解决 IE 下 listener 参数 event。 target 问题

改进:

```js
var addListener;

if (window.addEventListener) {
  addListener = function (el, type, listener, useCapture) {
    el.addEventListener(type, listener, useCapture);
    return listener;
  };
} else if (window.attachEvent) {
  addListener = function (el, type, listener) {
    // 标准化this，event，target
    var wrapper = function () {
      var event = window.event;
      event.target = event.srcElement;
      listener.call(el, event);
    };

    el.attachEvent('on' + type, wrapper);
    return wrapper;
    // 返回wrapper。调用者可以保存，以后remove
  };
}
```
