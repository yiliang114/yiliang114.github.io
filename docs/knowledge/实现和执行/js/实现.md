---
title: 类型转换
date: '2020-11-02'
draft: true
---

### 取数组的最大值（ES5、ES6)

```js
// ES5 的写法
Math.max.apply(null, [14, 3, 77, 30]);

// ES6 的写法
Math.max(...[14, 3, 77, 30]);

// reduce
[14, 3, 77, 30].reduce((accumulator, currentValue) => {
  return (accumulator = accumulator > currentValue ? accumulator : currentValue);
});

let arr = [12, 3, 77, 30].sort((a, b) => b - a);
arr[0];
```

### 改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。

```js
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

1.利用块作用域

```js
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

2.利用函数自执行

```js
for (var i = 0; i < 10; i++) {
  (function(j) {
    setTimeout(() => {
      console.log(j);
    }, 1000);
  })(i);
}
```

3.利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    i => {
      console.log(i);
    },
    1000,
    i,
  );
}
```

4.很多其它的方案只是把 console.log(i) 放到一个函数里面，因为 setTimeout 函数的第一个参数只接受函数以及字符串，如果是 js 语句的话，js 引擎应该会自动在该语句外面包裹一层函数

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    (i => {
      console.log(i);
    })(i),
    1000,
  );
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    (() => {
      console.log(i);
    })(),
    1000,
  );
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(console.log(i), 1000);
}
```

5.原理：利用 eval 或者 new Function 执行字符串，然后执行过程同方法四

```js
for (var i = 0; i < 10; i++) {
  setTimeout(eval('console.log(i)'), 1000);
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(new Function('i', 'console.log(i)')(i), 1000);
}
```

### 怎么计算在一个页面上的停留时间

1. websocket，前端开个长连接，后台统计长连接时间。
2. ajax 轮询，隔几秒发一个查询，后台记录第一与最后一个查询间隔时间。
3. 关闭窗口或者跳转的时候会触发 window.onbeforeunload 函数，可以在该函数中做处理（有兼容性问题）；统计完数据记录到本地 cookies 中，一段时间后统一发送

### 如何实现文件断点续传

断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。

首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。

因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。

前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。

当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。 有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。

只要用 slice 方法就可以了

```js
var packet = file.slice(start, end);
```

参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块

如

```js
file.slice(0, 1000);
file.slice(1000, 2000);
file.slice(2000, 3000);
// ......
```

在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。 如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。

### 如何处理不让别人盗用你的图片，访问你的服务器资源

http header, 对 refer 做判断看来源是不是自己的网站，如果不是就拒绝
通过 session 校验，如果不通过特定服务生成 cookie 和 session 就不能请求得到资源

### 在一个 UI 李有 10 个 li，实现点击对应的 li，输出对应的下标

```js
function eve() {
  ul.onclick = function(eve) {
    if (eve.target.tagName.toLowerCase() === 'li') {
      console.log(eve.target.innerHTML);
    }
  };
}
```

### 写一个函数实现`n!`

> 实现阶乘，最开始我只想到了递归的方式。还一开始写的有问题，后来修改了才没问题的。

#### 递归方式

```js
function factorial(n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

#### while 循环方式

```js
function factorial(n) {
  var result = 1;

  while (n > 1) {
    result = result * n;
    n--;
  }
  return result;
}
```

### 写一个函数递归调用的例子

> 我写的是!n

```js
function fn(n) {
  if (n <= 1) {
    return n;
  } else {
    return n * fn(n - 1);
  }
}
```
