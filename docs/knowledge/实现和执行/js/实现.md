---
title: 类型转换
date: '2020-11-02'
draft: true
---

### 取数组的最大值（ES5、ES6)

```js
// ES5 的写法
Math.max.apply(null, [14, 3, 77, 30]);

// ES6 的写法
Math.max(...[14, 3, 77, 30]);

// reduce
[14, 3, 77, 30].reduce((accumulator, currentValue) => {
  return (accumulator = accumulator > currentValue ? accumulator : currentValue);
});

let arr = [12, 3, 77, 30].sort((a, b) => b - a);
arr[0];
```

### 改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法。

```js
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

1.利用块作用域

```js
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

2.利用函数自执行

```js
for (var i = 0; i < 10; i++) {
  (function(j) {
    setTimeout(() => {
      console.log(j);
    }, 1000);
  })(i);
}
```

3.利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    i => {
      console.log(i);
    },
    1000,
    i,
  );
}
```

4.很多其它的方案只是把 console.log(i) 放到一个函数里面，因为 setTimeout 函数的第一个参数只接受函数以及字符串，如果是 js 语句的话，js 引擎应该会自动在该语句外面包裹一层函数

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    (i => {
      console.log(i);
    })(i),
    1000,
  );
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    (() => {
      console.log(i);
    })(),
    1000,
  );
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(console.log(i), 1000);
}
```

5.原理：利用 eval 或者 new Function 执行字符串，然后执行过程同方法四

```js
for (var i = 0; i < 10; i++) {
  setTimeout(eval('console.log(i)'), 1000);
}
```

```js
for (var i = 0; i < 10; i++) {
  setTimeout(new Function('i', 'console.log(i)')(i), 1000);
}
```

### 写出你能想到的数组去重

1.set 去重

```js
[...new Set(arr)];
```

2.利用 indexOf 去重

```js
const newArr = arr.filter((item, index, arr) => index === arr.indexOf(item));
```

```js
let newArrB = [];
arr.forEach(item => (newArrB.indexOf(item) === -1 ? newArrB.push(item) : ''));
```

3.利用对象去重

```js
let objA = {};
const newArrA = arr.filter((item, index, arr) => (objA.hasOwnProperty(item) ? false : (objA[item] = true)));
```

4.双重循环去重

```js
function removeDuplicatedItem(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1); //console.log(arr[j]);
        j--;
      }
    }
  }
  return arr;
}
```

5.利用 sort()加前后比较去重

```js
const newArrC = arr.sort().filter((item, index, arr) => item !== arr[index + 1]);
```

### 如何在页面上实现一个圆形的可点击区域？

1. map+area 或者 svg
2. border-radius
3. 纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等

### 怎么计算在一个页面上的停留时间

1. websocket，前端开个长连接，后台统计长连接时间。
2. ajax 轮询，隔几秒发一个查询，后台记录第一与最后一个查询间隔时间。
3. 关闭窗口或者跳转的时候会触发 window.onbeforeunload 函数，可以在该函数中做处理（有兼容性问题）；统计完数据记录到本地 cookies 中，一段时间后统一发送

### 二维码怎么工作的，扫描 pc 端的二维码，怎么让 pc 端登录

pc 端随机生成一个含有唯一 uid 的二维码，并与服务器建立一个长连接；
手机扫描二维码，解析出二维码中的 uid，并把这个 uid 和手机端的用户密码进行绑定，上传给服务器；
服务器获得客户端信息之后，pc 端的长连接轮询操作会获得该消息，显示该账号的信息；
pc 端会再开一个长连接与手机端保持通信，等待手机端确认登陆后，获得服务器授权的 token，就可以在 pc 端登陆进行正常通信了

### 一个图片 url 访问后直接下载怎样实现？

请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http 头，决定用户下载行为的参数
下载的情况下：

```js
1. x-oss-object-type:
        Normal
2. x-oss-request-id:
        598D5ED34F29D01FE2925F41
3. x-oss-storage-class:
        Standard
```

HTTP 头，添加头名称 Content-Disposition 值 attachment 或者对存放 txt 文件的目录设置

### input 搜索如何防抖，如何处理中文输入

通过 compositionstart & compositionend 做的中文输入处理

```html
<input
  ref="input"
  @compositionstart="handleComposition"
  @compositionupdate="handleComposition"
  @compositionend="handleComposition"
/>
```

1. compositionstart 事件触发于一段文字的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）
2. 每打一个拼音字母，触发 compositionupdate，最后将输入好的中文填入 input 中时触发 compositionend,
   触发 compositionstart 时，文本框会填入 “虚拟文本”（待确认文本），同时触发 input 事件.
3. 填入实际内容后（已确认文本）,触发 compositionend,所以这里如果不想触发 input 事件的话就得设置一个 bool 变量来控制。

### 如何实现文件断点续传

断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。

首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。

因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。

前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。

当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。

只要用 slice 方法就可以了

var packet = file.slice(start, end);
参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块

如

file.slice(0,1000);
file.slice(1000,2000);
file.slice(2000,3000);
// ......
在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。

### 如何处理不让别人盗用你的图片，访问你的服务器资源

http header, 对 refer 做判断看来源是不是自己的网站，如果不是就拒绝
通过 session 校验，如果不通过特定服务生成 cookie 和 session 就不能请求得到资源

### 请写一个简单的幻灯效果页面

- 如果不使用 JS 来完成，可以加分。

```html
<!DOCTYPE htm l>
<html>
  <head>
    <style>
      img {
        display: none;
        width: 100px;
        height: 100px;
      }
      input:checked + img {
        display: block;
      }
      input {
        position: absolute;
        left: -9999px;
      }
      label {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="cont">
      <input id="img1" name="img" type="radio" checked="checked" />
      <img src="a.png" />
      <input id="img2" name="img" type="radio" />
      <img src="b.png" />
    </div>
    <div id="nav">
      <label for="img1">第一张</label>
      <label for="img2">第二张</label>
    </div>
  </body>
</html>
```

可以这样写，但是不能支持所有浏览器。

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      #cont {
        position: relative;
        height: 100px;
      }
      img {
        position: absolute;
        width: 100px;
        height: 100px;
        z-index: 1;
      }
      img:first-child,
      img:target {
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <div id="cont">
      <img id="img1" src="a.jpg" />
      <img id="img2" src="b.jpg" />
    </div>
    <div>
      <a href="#img1">one</a>
      <a href="#img2">two</a>
    </div>
  </body>
</html>
```

### 如何实现一个前端模板引擎？

### 用 js 实现一个九九乘法口诀表

```js
const MAX_WIDTH = 7;
let table = '';
for (let rhs = 1; rhs <= 9; rhs++) {
  for (let lhs = 1; lhs <= 9; lhs++) {
    if (lhs <= rhs) table += `${lhs}*${rhs}=${lhs * rhs}`.padEnd(MAX_WIDTH);
  }
  table += '\n';
}
console.log(table);
```

### 怎么实现从一个 DIV 左上角到右下角的移动，有哪些方法，都怎么实现？

### 如何取出一个数组里的图片并按顺序显示出来？

```js
var arr = [
  {
    src: 'images/favicon.ico',
    name: '1',
  },
  {
    src: 'images/苹果.png',
    name: '2',
  },
  {
    src: 'images/外星人.png',
    name: '3',
  },
  {
    src: 'images/柠檬.png',
    name: '4',
  },
];
var imgdiv = document.getElementById('imgdiv');

for (var i = 0; i < arr.length; i++) {
  (function(i) {
    // 创建元素
    var img = document.createElement('img');
    // 设置元素的属性
    img.id = 'img' + i;
    img.className = 'images';
    img.setAttribute('new_class', 'new_class');
    img.setAttribute('src', arr[i].src);
    // 挂载到父节点上
    imgdiv.appendChild(img);
  })(i);
}
```

### 在一个 UI 李有 10 个 li，实现点击对应的 li，输出对应的下标

```js
function eve() {
  ul.onclick = function(eve) {
    if (eve.target.tagName.toLowerCase() === 'li') {
      console.log(eve.target.innerHTML);
    }
  };
}
```

### 用 js 创建 10 个 a 标签，点击弹出对应的序号（考察作用域）

```js
var i;
for (i = 0; i < 10; i++) {
  (function(i) {
    var a = document.createElement('a');
    a.innerHTML = i + '<br>';
    a.addEventLister('click', function(e) {
      e.preventDefault();
      alert(i);
    });
    document.body.appendChild(a);
  })(i);
}
```

### 找出数组中的相同数据（多种方式）

### 编写一个元素拖拽的插件

### 字符串实现倒序

使用最简单的 JS 操作就可以完成。下面是简单的实现 code：

```js
function reverseString(str) {
  var strArray = str.split(''); // 使用空字符串来分割成字符数组
  return strArray.reverse().join(''); // 反转并连接
}
reverseString('hello');
```

### 如何利用 JS 生成一个 table？

- 首先是用 createElement 创建一个 table，再用 setAttribute 设置 table 的属性，
- 然后用 for 循环设置 tr 和 td 的内容，用 appendChild 拼接内容，设置 td 的时候还用到 innerHTML 和 style.padding。

### 实现预加载一张图片，加载完成后显示在网页中并设定其高度为 50px，宽度为 50px

- 先 new Image()获取一个图片对象，然后在图片对象的 onload 中设置宽度和高度。查看在线代码。

### 假设有一个 4 行 tr 的 table，将 table 里面 tr 顺序颠倒

1. 先是通过 table.tBodies[0].rows 获取到当前 tbody 中的行，接下来是两种方法处理。获取到的行没
   有 reverse 这个方法。
2. 第一种是将这些行 push 到另外一个数组中
3. 第二种是用 Array.prototype.slice.call()将那些行变成数组，
4. 接着用 reverse 倒叙，table 再 appendChild。查看在线代码。
5. 这里我有个疑问，就是在 appendChild 的时候，并不是在最后把列加上，而是做了替换操作？

### 模拟一个 HashTable 类，一个类上注册四个方法：包含有 add、remove、contains、length 方法

- 先是在构造函数中定义一个数组，然后用 push 模拟 add，splice 模拟 remove。
- 四个方法都放在了 prototype 上面。查看在线代码。

### js 实现的页面下拉加载

https://www.jianshu.com/p/a523d356aa75

### JS 实现无限分页加载——原理图解

https://www.cnblogs.com/xing901022/p/5052780.html

### 实现预加载一张图片，加载完成后显示在网页中并设定其高度为 50px，宽度为 50px；

### 实现效果，点击容器内的图标，图标边框变成 border 1px solid red，点击空白处重置。

```js
const box = document.getElementById('box');
function isIcon(target) {
  return target.className.includes('icon');
}

box.onclick = function(e) {
  e.stopPropagation();
  const target = e.target;
  if (isIcon(target)) {
    target.style.border = '1px solid red';
  }
};
const doc = document;
doc.onclick = function(e) {
  const children = box.children;
  for (let i = 0; i < children.length; i++) {
    if (isIcon(children[i])) {
      children[i].style.border = 'none';
    }
  }
};
```

### js 实现 css 的:hover 效果

### （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生 JS）

回答出概念即可，下面是几个要点

给需要拖拽的节点绑定 mousedown, mousemove, mouseup 事件
mousedown 事件触发后，开始拖拽
mousemove 时，需要通过 event.clientX 和 clientY 获取拖拽位置，并实时更新位置
mouseup 时，拖拽结束
需要注意浏览器边界的情况

### 写一个函数实现`n!`

> 实现阶乘，最开始我只想到了递归的方式。还一开始写的有问题，后来修改了才没问题的。

#### 递归方式

```js
function factorial(n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

#### while 循环方式

```js
function factorial(n) {
  var result = 1;

  while (n > 1) {
    result = result * n;
    n--;
  }
  return result;
}
```

### 写一个函数递归调用的例子

> 我写的是!n

```js
function fn(n) {
  if (n <= 1) {
    return n;
  } else {
    return n * fn(n - 1);
  }
}
```

### 写出下列代码的运行结果：

```js
var a = 1;
function main() {
  alert(a); // undefined
  var a = 2;
  alert(this.a); // 1 // 这个地方我写错了，为什么呢
  alert(a); // 2
}
main();
```

### 参数传递中引用和复制的区别？

> JavaScript 的值类型和引用类型
> 值类型：

- Number
- Boolean
- null
- undefined

> 引用类型：

- 对象
- 数组
- 函数

值传参针对的是基本类型。值传参可以理解为复制变量值。基本类型复制后俩个变量完全独立，之后任何一方改变都不会影响另一方。

引用传参针对的是引用类型，引用类型复制的是引用（即指针），之后的任何一方改变都会映射到另一方。

> 一个面试题目

```js
function main() {
  var re = [];
  test(re);
  console.log(re); // ?
}

function test(re) {
  re = re.concat([1, 2, 3]);
}

main();
```

> 这个应该输出`[]`才对。
> ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。**但是如果传递的是对象，即使这个变量是按值传递的， obj 也会按引用来访问同一个对象。**
> 对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。
> **保存对象的变量，它里面装的值是这个对象在堆内存中的地址。so => 在函数内部的对象改变了，函数外部的对象也会跟随着一起变**

### 给一个字符串，找到里面重复最多的字符？

```js
function findMax(str) {
  var map = {},
    max = { num: 0 };

  for (var i in str) {
    if (map[str[i]]) {
      map[str[i]]++;
    } else {
      map[str[i]] = 1;
    }

    if (map[str[i]] > max.num) {
      max.num = map[str[i]];
      max.key = str[i];
    }
  }
  console.log(`max num is ${max.num}, and the key is ${max.key}`);
  // 打印出来所有值的重复次数
  for (var key in map) {
    console.log(`${key} copied is ${map[key]}`);
  }
}
```

### 一个列表很长，如何自己实现一个滚动条？

- css 方式

```js
<div style="width:260px;height:120px; overflow:scroll; border:1px solid;">
  这里是你要显示的内容,当内容很多时，会出现滚动条。这个属性定义溢出元素内容区的内容会如何处理。如果值为
  scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。
</div>
```

- js 方式

通过鼠标的按下事件（onmousedown）和 JS 滚轮事件(mousewheel-非火狐/DOMMouseScroll-火狐浏览器)来改变 top 即可。

下面是一个具体的实现:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>标题</title>
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <style>
      * {
        margin: 0;
        padding: 0;
        list-style: none;
      }

      body {
        height: 2000px;
      }

      .box1 {
        width: 320px;
        height: 400px;
        background: #ccc;
        overflow: hidden;
        overflow-y: scroll;
        margin: 20px 0 0 100px;
      }

      .con1 {
        font-size: 18px;
      }

      #out {
        width: 320px;
        height: 400px;
        background: url(bg1.png) 0 0 repeat-x;
        position: absolute;
        left: 500px;
        top: 20px;
        overflow: hidden;
      }

      #con {
        width: 280px;
        padding: 5px;
        font-size: 18px;
        position: absolute;
        left: 0px;
        top: 0px;
      }

      #box {
        width: 30px;
        height: 400px;
        position: absolute;
        right: 0;
        top: 0;
      }

      #drag {
        width: 30px;
        height: 53px;
        /* background: url(icon2.png) 0 0 no-repeat; */
        background-color: slategray;
        position: absolute;
        left: 0px;
        top: 0px;
      }
    </style>
  </head>

  <body>
    <div class="box1">
      <p class="con1">
        据新华社电中航工业、国机集团等8家央企6日在京签约，在重要项目、科技转化等相关领域开展重组合作整合，这将成为央企间产业联合协作的新典范，也将开启央企间产业重组合作整合的新阶段。
        相关合作内容包括：中航工业和国机集团共同发展八万吨模锻压机项目；中航工业将房地产业务全部划转保利集团，中核建设和中国一重在高温气冷堆主设备制造领域合作，兵器工业、兵器装备、中国国新对北方公司进行股权重组。
        国务院国资委主任肖亚庆在6日参加中央企业产业合作座谈会上表示，下一步，国资委政策将加码推动央企产业重组步伐，通过业务整合、资产重组、股权合作、资产置换、无偿划转、协议转让、战略联盟、联合开发等多途径，加快央企间产业重组合作整合。
        肖亚庆同时清晰地勾勒出国企改革兼并重组“路线图”：通过产业重组，在突破关键技术、掌握核心资源，打造知名品牌等方面，实现产业重组合作“一加一大于二”的效果。肖亚庆同时透露，目前部分央企在牵头技术创新战略联盟、设立创新投资基金、构建创新孵化平台等方面，取得了重大突破。据统计，央企牵头国家及地方技术创新联盟141个，50多家中央企业共发起和参与基金179只，构建面向社会的创新孵化平台57个，创业创新平台27个。
        “此次集中签约，意味着央企重组的重心开始向资本、项目、产业板块等内部要素转移。”中国企业研究院首席研究员李锦说，未来，央企间产业重组合作整合将被更快地推进，央企内部的各种要素将被再次优化。
      </p>
    </div>

    <div id="out">
      <div id="con">
        据新华社电中航工业、国机集团等8家央企6日在京签约，在重要项目、科技转化等相关领域开展重组合作整合，这将成为央企间产业联合协作的新典范，也将开启央企间产业重组合作整合的新阶段。
        相关合作内容包括：中航工业和国机集团共同发展八万吨模锻压机项目；中航工业将房地产业务全部划转保利集团，中核建设和中国一重在高温气冷堆主设备制造领域合作，兵器工业、兵器装备、中国国新对北方公司进行股权重组。
        国务院国资委主任肖亚庆在6日参加中央企业产业合作座谈会上表示，下一步，国资委政策将加码推动央企产业重组步伐，通过业务整合、资产重组、股权合作、资产置换、无偿划转、协议转让、战略联盟、联合开发等多途径，加快央企间产业重组合作整合。
        肖亚庆同时清晰地勾勒出国企改革兼并重组“路线图”：通过产业重组，在突破关键技术、掌握核心资源，打造知名品牌等方面，实现产业重组合作“一加一大于二”的效果。肖亚庆同时透露，目前部分央企在牵头技术创新战略联盟、设立创新投资基金、构建创新孵化平台等方面，取得了重大突破。据统计，央企牵头国家及地方技术创新联盟141个，50多家中央企业共发起和参与基金179只，构建面向社会的创新孵化平台57个，创业创新平台27个。
        “此次集中签约，意味着央企重组的重心开始向资本、项目、产业板块等内部要素转移。”中国企业研究院首席研究员李锦说，未来，央企间产业重组合作整合将被更快地推进，央企内部的各种要素将被再次优化。
      </div>
      <div id="box">
        <p id="drag"></p>
      </div>
    </div>
    <script>
      var out = document.getElementById('out');
      var con = document.getElementById('con');
      var box = document.getElementById('box');
      var drag = document.getElementById('drag');
      drag.onmousedown = function(ev) {
        var e = ev || window.event;
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
        var d_bkt = e.clientY - drag.offsetTop;
        document.onmousemove = function(ev) {
          var e = ev || window.event;
          var top = e.clientY - d_bkt;
          if (top <= 0) {
            top = 0;
          }
          if (top >= box.clientHeight - drag.clientHeight) {
            top = box.clientHeight - drag.clientHeight;
          }
          var scale = top / (box.clientHeight - drag.clientHeight);
          var cony = scale * (con.clientHeight - out.clientHeight);
          drag.style.top = top + 'px';
          con.style.top = -cony + 'px';
          console.log(top);
        };
        document.onmouseup = function() {
          document.onmousemove = null;
        };
      };
      var str = window.navigator.userAgent.toLowerCase();
      if (str.indexOf('firefox') != -1) {
        //火狐浏览器
        out.addEventListener(
          'DOMMouseScroll',
          function(e) {
            e.preventDefault(); //阻止窗口默认的滚动事件
            if (e.detail < 0) {
              var t = con.offsetTop + 20;
              if (t >= 0) {
                t = 0;
              }
              if (t <= -(con.clientHeight - out.clientHeight)) {
                t = -(con.clientHeight - out.clientHeight);
              }
              var scale = t / (con.clientHeight - out.clientHeight);
              var top = scale * (box.clientHeight - drag.clientHeight);
              con.style.top = t + 'px';
              drag.style.top = -top + 'px';
            }
            if (e.detail > 0) {
              var t = con.offsetTop - 20;
              if (t >= 0) {
                t = 0;
              }
              if (t <= -(con.clientHeight - out.clientHeight)) {
                t = -(con.clientHeight - out.clientHeight);
              }
              var scale = t / (con.clientHeight - out.clientHeight);
              var top = scale * (box.clientHeight - drag.clientHeight);
              con.style.top = t + 'px';
              drag.style.top = -top + 'px';
            }
          },
          false,
        );
      } else {
        //非火狐浏览器
        out.onmousewheel = function(ev) {
          var e = ev || window.event;
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          if (e.wheelDelta > 0) {
            var t = con.offsetTop + 20;
            if (t >= 0) {
              t = 0;
            }
            if (t <= -(con.clientHeight - out.clientHeight)) {
              t = -(con.clientHeight - out.clientHeight);
            }
            var scale = t / (con.clientHeight - out.clientHeight);
            var top = scale * (box.clientHeight - drag.clientHeight);
            con.style.top = t + 'px';
            drag.style.top = -top + 'px';
          }
          if (e.wheelDelta < 0) {
            var t = con.offsetTop - 20;
            if (t >= 0) {
              t = 0;
            }
            if (t <= -(con.clientHeight - out.clientHeight)) {
              t = -(con.clientHeight - out.clientHeight);
            }
            var scale = t / (con.clientHeight - out.clientHeight);
            var top = scale * (box.clientHeight - drag.clientHeight);
            con.style.top = t + 'px';
            drag.style.top = -top + 'px';
          }
        };
      }
    </script>
  </body>
</html>
```

### 简单点的，一个`div`方块如何移动？css3 方式，js 方式呢？用 js 如何实现 1s 动一下的效果?

- CSS3 的动画效果:animation

> animation-name 规定需要绑定到选择器的 keyframe 名称</br>
> animation-duration 规定完成动画所花费的时间，以秒或毫秒计</br>
> animation-timing-function 规定动画的速度曲线</br>
> animation-delay 规定在动画开始之前的延迟</br>
> animation-iteration-count 规定动画应该播放的次数</br>
> animation-direction 规定是否应该轮流反向播放动画。</br>

- js 方式实现

```html
<html>
  <head>
    <style>
      .container {
        border: 1px solid red;
        width: 100px;
        height: 100px;
        position: relative;
      }
    </style>
    <script>
      function init() {
        var div = document.getElementsByClassName('container')[0];
        for (var i = 0; i < 11; i++) {
          (function(j) {
            setTimeout(function() {
              div.style.top = j * 10 + 'px';
              div.style.left = j * 10 + 'px';
            }, j * 1000);
          })(i);
        }
      }
    </script>
  </head>
  <body>
    <div class="container">
      一个可以移动的方框
    </div>
  </body>
</html>
```

### 拖拽实现

### 其他

- 若干个数字，如何选出最大的五个
- 如何实现一个性能优化后的 slider
- 如何实现一个搜索高亮的文件树
- 用原生 js 实现一个弹框
- 知道页面上某一个点的坐标，如何获取该坐标上的所有元素
- 一个简单的 DSL 的 compiler 实现
- js 实现 css 的 hover 效果
- 如何实现拖拽的功能
- 手写生成 10 个 20 - 50 之间的随机数， 存在数组中
- 找出 n 个数中第 k 大的数，这个很简单，剑指 offer 上的原题，通过剪枝的快速排序或者堆排序都可以解决。
- 再一大堆数中找出最大的 20 个数;
- 输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26
- 轮播图的实现，以及轮播图组件开发，轮播 10000 张图片过程
- 编写一个拖拽的插件 （vue）
- 页面大量图片，如何优化加载，优化用户体验
