---
title: 代码题 1
date: '2020-11-02'
draft: true
---

### setTimeout

```js
console.log('one');
setTimeout(function() {
  console.log('two');
}, 0);
console.log('three');
// one
// three
// two
```

### 变量作用域

```js
var foo = 'Hello';
(function() {
  var bar = ' World';
  alert(foo + bar);
})();
alert(foo + bar);

// "Hello World" 和 ReferenceError: bar is not defined
```

### ['1', '2', '3'].map(parseInt)

map 会给函数传递 3 个参数： (elem, index, array) 而 parseInt 接收两个参数(sting, radix)，其中 radix 代表进制。省略 radix 或 radix = 0，则数字将以十进制解析。 因此，map 遍历 ["1", "2", "3"]，相应 parseInt 接收参数如下

```js
parseInt('1', 0); // 1
parseInt('2', 1); // NaN
parseInt('3', 2); // NaN
```

因为二进制里面，没有数字 3,导致出现超范围的 radix 赋值和不合法的进制解析，才会返回 NaN 所以["1", "2", "3"].map(parseInt) 答案也就是：[1, NaN, NaN]

### class 构造函数执行的顺序

```js
class B {
  b = console.log('1');
  constructor() {
    console.log('2');
  }
}

class A extends B {
  a = console.log('3');
  constructor() {
    super();
    console.log('4');
  }
}

new A();
new B();

// 也就是说 constructor 前面的属性赋值比 constructor 构造函数执行的时间早
// 1234
```

### `foo.x`的值是什么？

```js
var foo = { n: 1 };
var bar = foo;
foo.x = foo = { n: 2 };
// foo.x = (foo = {n:2}); =>  {n:1}.x = ( {n:1} = {n:2} );  R.H.S. foo={n:2}
// console.log(foo.x); //Result undefined
// console.log(foo); //Result {n:2}
// console.log(bar); //Result {n:1, x: {n:2}}
// Result = undefined
```

### 获取对象深度

空对象当作一级，属性值为数组则不向下查找

```js
// 递归，深度优先遍历
function getObjectDeep(obj, arr = []) {
  var count = 0;
  obj && arr.indexOf(obj) === -1 && arr.push(obj);
  if (obj && !Array.isArray(obj) && typeof obj === 'object') {
    count = 1;
    var result = Object.keys(obj).map(function(item) {
      if (typeof obj[item] === 'object' && arr.indexOf(obj[item]) === -1) {
        // 防止循环引用
        arr.push(obj[item]);
        return 1 + getObjectDeep(obj[item], arr);
      } else {
        return 1;
      }
    });
    for (var i = 0; i < result.length; i++) {
      if (count < result[i]) {
        count = result[i];
      }
    }
  }
  return count;
}

// 非递归，宽度优先遍历
function getObjectDeep(obj) {
  var count = 0;
  var queueObj = [obj];
  var arrs = [obj]; // 防止循环引用
  var last = obj; // 当前层级最后一个

  var checkObj = function(param) {
    return param !== null && param !== undefined && !Array.isArray(param) && typeof param === 'object';
  };

  if (checkObj(obj)) {
    while (queueObj.length) {
      var currentObj = queueObj.shift();
      Object.keys(currentObj).forEach(function(item) {
        if (checkObj(currentObj[item]) && arrs.indexOf(currentObj[item]) === -1) {
          arrs.push(currentObj[item]);
          queueObj.push(currentObj[item]);
        }
      });
      if (currentObj === last) {
        count += 1;
        last = queueObj.length ? queueObj[queueObj.length - 1] : null;
      }
    }
  }

  return count;
}
```

### 实现下面这道题中的 machine 函数

```js
function machine() {}
machine('ygy').execute();
// start ygy
machine('ygy')
  .do('eat')
  .execute();
// start ygy
// ygy eat
machine('ygy')
  .wait(5)
  .do('eat')
  .execute();
// start ygy
// wait 5s（这里等待了5s）
// ygy eat
machine('ygy')
  .waitFirst(5)
  .do('eat')
  .execute();
// wait 5s
// start ygy
// ygy eat
```

```js
function machine() {
  var txt = arguments[0];
  return new Job(txt);
}

function Job(name) {
  this.name = name;
  this.fn = Promise.resolve();
  this.jobs = [{ fn: () => console.log('start ', this.name) }];
}

Job.prototype.execute = function() {
  this.jobs.forEach(
    job =>
      (this.fn = this.fn.then(() => {
        return new Promise(resolve => {
          setTimeout(() => {
            resolve(job.fn());
          }, job.time || 0);
        });
      })),
  );
};
Job.prototype.do = function(str) {
  this.jobs.push({ fn: () => console.log(`${this.name} ${str}`) });
  return this;
};
Job.prototype.wait = function(num) {
  this.jobs.push({ fn: () => console.log(`wait ${num}s`), time: num * 1000 });
  return this;
};

Job.prototype.waitFirst = function(num) {
  this.jobs.unshift({
    fn: () => console.log(`wait ${num}s`),
    time: num * 1000,
  });
  return this;
};

// 关注点分离
function machine() {
  var txt = arguments[0];
  return new Job(txt);
}

function Job(name) {
  this.name = name;
  this.jobs = [new JobItem(() => console.log('start ', this.name))];
}

function JobItem(fn, time) {
  this.fn = fn;
  this.time = time || 0;
}

function defer(job) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(job.fn());
    }, job.time || 0);
  });
}

Job.prototype.execute = async function() {
  while (this.jobs.length) {
    const job = this.jobs.shift();
    await defer(job);
  }
};
Job.prototype.do = function(str) {
  this.jobs.push(new JobItem(() => console.log(`${this.name} ${str}`)));
  return this;
};
Job.prototype.wait = function(num) {
  this.jobs.push(new JobItem(() => console.log(`wait ${num}s`), num * 1000));
  return this;
};

Job.prototype.waitFirst = function(num) {
  this.jobs.unshift(new JobItem(() => console.log(`wait ${num}s`), num * 1000));
  return this;
};
```

### 函数组合运行

说明：实现一个方法，可将多个函数方法按从左到右的方式组合运行。 如 composeFunctions(fn1,fn2,fn3,fn4)等价于 fn4(fn3(fn2(fn1))。
实例：

```js
const add = x => x + 1;
const multiply = (x, y) => x * y;
const multiplyAdd = composeFunctions(multiply, add);
multiplyAdd(3, 4); // 返回 13
```

```js
function composeFunctions() {
  var slice = Array.prototype.slice;
  var fnArgs = slice.call(arguments, 0);
  return function() {
    var args = slice.call(arguments, 0);
    if (fnArgs.length === 1) {
      return fnArgs[0].apply(this, args);
    }
    return fnArgs.reduce(function(fn1, fn2) {
      return fn2(fn1.apply(this, args));
    });
  };
}
```

### 将给定元素插入到从小到大排序数组的合适位置，并返回插入值下标，如果数组中已存在该值，则直接返回该值下标。

```js
function insert(arr, num) {
  if (arr && Array.isArray(arr)) {
    var left = 0;
    var right = arr.length - 1;
    var mid = 0;
    while (left <= right) {
      mid = Math.floor((left + right) / 2);
      if (num > arr[mid]) {
        left = mid + 1;
      } else if (num < arr[mid]) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    arr.splice(left, 0, num);
    return left;
  }
  return -1;
}
```

### 数字千分位

如 12000000.11 转化为 12,000,000.11

```js
function commafy(num) {
  return (
    num &&
    num.toString().replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2) {
      return $2 + ',';
    })
  );
}
```

### 创建一个循环，从 1 迭代到 100，`3`的倍数时输出 "fizz"，`5`的倍数时输出 "buzz"，同时为`3`和`5`的倍数时输出 "fizzbuzz"。

```js
for (let i = 1; i <= 100; i++) {
  let f = i % 3 == 0,
    b = i % 5 == 0;
  console.log(f ? (b ? 'FizzBuzz' : 'Fizz') : b ? 'Buzz' : i);
}
```

### 打印一个对象

```js
let description = '';
for (let i in this.questionsForm) {
  let property = this.questionsForm[i];
  description += i + ' = ' + property + '\n';
}
console.log(description);
```

### 写一个方法 region()，获取数字的区间

```js
function region(num1, num2) {
  var min = Math.min(num1, num2),
    max = Math.max(num1, num2),
    ret = [];
  for (++min; min < max; ) {
    ret.push(min++);
  }
  if (num1 > num2) return ret.reverse().join();

  return ret.join();
}
```

### 写一个方法，为元素添加 class？

```js
function addClass(elem, className) {
  if (!elem) return;
  var reClass = new RegExp('\\b' + className + '\\b');
  !reClass.test(elem.className) && (elem.className += ' ' + className);
}
```

### 请将数组的日期从前到后排序

```js
function sortDate(arr) {
  return arr.sort(function(date1, date2) {
    // 统一转换成 yyyy/MM/dd 的格式，兼容IE，否则 new Date 返回 NaN
    date1 = date1.replace('-', '/');
    date2 = date2.replace('-', '/');
    return new Date(date1).getTime() - new Date(date2).getTime();
  });
}
```

### 写一个 getStyle()函数，获取 div 的边框粗细，并兼容所有浏览器

```js
function getStyle(elem, cssArr) {
  if (elem && elem.nodeType) {
    // border-top -> borderTop
    cssArr = typeof cssArr === 'string' ? camelCase(cssArr) : '';

    // 优先获取
    if (elem.style[cssArr]) return elem.style[cssArr];
    // for IE
    else if (elem.currentStyle) return elem.currentStyle[cssArr];
    // for w3c
    else if (document.defaultView && document.defaultView.getComputedStyle) {
      // borderTop -> border-top
      cssArr = cssArr.replace(/([A-Z])/g, '-$1').toLowerCase();

      var style = document.defaultView.getComputedStyle(elem, '');
      return style && style.getPropertyValue(cssArr);
    }
  }
  return null;
}
```

### 116.输出以下代码运行结果

```js
1 + '1';
2 * '2'[(1, 2)] + [2, 1];
'a' + +'b';
```

'11'
4
'1,22,1'
'aNaN'

//"a" + + "b"其实可以理解为
// + "b" -> NaN
//“a”+NaN

### 33.下面的代码打印什么内容，为什么？

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

针对这题，在知乎上看到别人的回答说：

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。
2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。
3. IIFE 中的函数是函数表达式，而不是函数声明。

实际上，有点类似于以下代码，但不完全相同，因为使用 const 不管在什么模式下，都会 TypeError 类型的错误

```js
const foo = (function() {
  foo = 10;
  console.log(foo);
})(foo)(); // Uncaught TypeError: Assignment to constant variable.
```

我的理解是，b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."
例如下面的：

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

### 76.输出以下代码运行结果

```js
// example 1
var a={}, b='123', c=123;
a[b]='b';
a[c]='c';
// 输出 c
console.log(a[b]);

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';
a[c]='c';
console.log(a[b]);

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c';
console.log(a[b]);
```

### 41.下面代码输出什么

```js
var a = 10;
(function() {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5
