---
title: 代码题 1
date: '2020-11-02'
draft: true
---

### class 构造函数执行的顺序

```js
class B {
  b = console.log('1');
  constructor() {
    console.log('2');
  }
}

class A extends B {
  a = console.log('3');
  constructor() {
    super();
    console.log('4');
  }
}

new A();
new B();

// 也就是说 constructor 前面的属性赋值比 constructor 构造函数执行的时间早
// 1234
```

### `foo.x`的值是什么？

```js
var foo = { n: 1 };
var bar = foo;
foo.x = foo = { n: 2 };
// foo.x = (foo = {n:2}); =>  {n:1}.x = ( {n:1} = {n:2} );  R.H.S. foo={n:2}
// console.log(foo.x); //Result undefined
// console.log(foo); //Result {n:2}
// console.log(bar); //Result {n:1, x: {n:2}}
// Result = undefined
```

### 获取对象深度

空对象当作一级，属性值为数组则不向下查找

```js
// 递归，深度优先遍历
function getObjectDeep(obj, arr = []) {
  var count = 0;
  obj && arr.indexOf(obj) === -1 && arr.push(obj);
  if (obj && !Array.isArray(obj) && typeof obj === 'object') {
    count = 1;
    var result = Object.keys(obj).map(function (item) {
      if (typeof obj[item] === 'object' && arr.indexOf(obj[item]) === -1) {
        // 防止循环引用
        arr.push(obj[item]);
        return 1 + getObjectDeep(obj[item], arr);
      } else {
        return 1;
      }
    });
    for (var i = 0; i < result.length; i++) {
      if (count < result[i]) {
        count = result[i];
      }
    }
  }
  return count;
}

// 非递归，宽度优先遍历
function getObjectDeep(obj) {
  var count = 0;
  var queueObj = [obj];
  var arrs = [obj]; // 防止循环引用
  var last = obj; // 当前层级最后一个

  var checkObj = function (param) {
    return param !== null && param !== undefined && !Array.isArray(param) && typeof param === 'object';
  };

  if (checkObj(obj)) {
    while (queueObj.length) {
      var currentObj = queueObj.shift();
      Object.keys(currentObj).forEach(function (item) {
        if (checkObj(currentObj[item]) && arrs.indexOf(currentObj[item]) === -1) {
          arrs.push(currentObj[item]);
          queueObj.push(currentObj[item]);
        }
      });
      if (currentObj === last) {
        count += 1;
        last = queueObj.length ? queueObj[queueObj.length - 1] : null;
      }
    }
  }

  return count;
}
```

### 函数组合运行

说明：实现一个方法，可将多个函数方法按从左到右的方式组合运行。 如 composeFunctions(fn1,fn2,fn3,fn4)等价于 fn4(fn3(fn2(fn1))。
实例：

```js
const add = x => x + 1;
const multiply = (x, y) => x * y;
const multiplyAdd = composeFunctions(multiply, add);
multiplyAdd(3, 4); // 返回 13
```

```js
function composeFunctions() {
  var slice = Array.prototype.slice;
  var fnArgs = slice.call(arguments, 0);
  return function () {
    var args = slice.call(arguments, 0);
    if (fnArgs.length === 1) {
      return fnArgs[0].apply(this, args);
    }
    return fnArgs.reduce(function (fn1, fn2) {
      return fn2(fn1.apply(this, args));
    });
  };
}
```

### 千分位

如 12000000.11 转化为 12,000,000.11

```js
function commafy(num) {
  return (
    num &&
    num.toString().replace(/(\d)(?=(\d{3})+\.)/g, function ($1, $2) {
      return $2 + ',';
    })
  );
}
```

### 变量提升

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

针对这题，在知乎上看到别人的回答说：

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。
2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。
3. IIFE 中的函数是函数表达式，而不是函数声明。

实际上，有点类似于以下代码，但不完全相同，因为使用 const 不管在什么模式下，都会 TypeError 类型的错误

```js
const foo = (function () {
  foo = 10;
  console.log(foo);
})(foo)(); // Uncaught TypeError: Assignment to constant variable.
```

我的理解是，b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."
例如下面的：

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

### 对象属性

```js
// example 1
var a={}, b='123', c=123;
a[b]='b';
a[c]='c';
// 输出 c
console.log(a[b]);

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';
a[c]='c';
console.log(a[b]);

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c';
console.log(a[b]);
```

### 变量提升

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5
