---
title: 类型转换
date: '2020-11-02'
draft: true
---

### 用 Array 的 reduce 方法实现 map 方法（头条一面）

### 合并数组中相邻且重复的元素

说明：请实现一个函数 merge，传入一个数组，合并数组中【相邻且重复】的元素。
实例：

```js
merge([3, 2, 2, 4, 5, 5, 6, 2, 1]); // 输出[3,2,4,5,6,2,1]
merge([3, 2, 3]); // 输出[3,2,3]
merge([2, 2, 3]); // 输出[2,3]
```

```js
function fn(arr) {
  var ret = [];
  if (!Array.isArray(arr) || arr.length === 0) {
    return ret;
  }
  for (var i = 0; i < arr.length; i++) {
    if (ret[ret.length - 1] !== arr[i]) {
      ret.push(arr[i]);
    }
  }
  return ret;
}
```

### 给出数组超过半数的数字，不存在的话输出没有（要求时间复杂度最低）

```js
function moreThanHalf(arr) {
  if (arr && Array.isArray(arr)) {
    var times = (result = index = 0);
    for (; index < arr.length; index++) {
      if (times === 0) {
        result = arr[index];
        times++;
      } else if (result !== arr[index]) {
        times--;
      } else {
        times++;
      }
    }
    if (times) {
      times = index = 0;
      for (; index < arr.length; index++) {
        if (result === arr[index]) {
          times++;
        }
      }
      if (times > arr.length / 2) {
        return result;
      }
    }
  }
  return '没有';
}
```

### 为数组写一个检测是否包含值方法：contains()

```js
if (!Array.prototype.contains) {
  Array.prototype.contains = function(value) {
    for (var i = 0, len = this.length, item; i < len; i++) {
      item = this[i];
      if (item === value) {
        return true;
      }
    }
    return false;
  };
}
```

## 扁平化

### 实现 flatten 函数

```js
let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]];
```

迭代实现

```js
function flatten(arr) {
  let arrs = [...arr];
  let newArr = [];
  while (arrs.length) {
    let item = arrs.shift();
    if (Array.isArray(item)) {
      arrs.unshift(...item);
    } else {
      newArr.push(item);
    }
  }
  return newArr;
}
```

递归实现

```js
function flatten(arr) {
  let arrs = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      arrs.push(...flatten(item));
    } else {
      arrs.push(item);
    }
  });
  return arrs;
}
```

字符串转换

```js
arr.join(',').split(',').map(item => Number(item)))
```

使用 Generator 实现数组 flatten:

```js
function* flat(arr) {
  for (let item of arr) {
    if (Array.isArray(item)) {
      yield* flat(item); //Generator委托
    } else {
      yield item;
    }
  }
}
function flatten(arr) {
  let result = [];
  for (let val of flat(arr)) {
    result.push(val);
  }
  return result;
}
let arr1 = [1, [2, 3, [4, 5], 6], [7]];
console.log(flatten(arr1)); //[1, 2, 3, 4, 5, 6, 7]
```

```js
const spreadableSymbol = Symbol.isConcatSpreadable;
const isFlattenable = value => {
  return (
    Array.isArray(value) ||
    (typeof value == 'object' && value !== null && Object.prototype.toString.call(value) === '[object Arguments]') ||
    !!(spreadableSymbol && value && value[spreadableSymbol])
  );
};

/**
 * flatten的基本实现，具体可以参考lodash库的flatten源码
 * @param array 需要展开的数组
 * @param depth 展开深度
 * @param predicate 迭代时需要调用的函数
 * @param isStrict 限制通过`predicate`函数检查的值
 * @param result 初始结果值
 * @returns {Array} 返回展开后的数组
 */
function flatten(array, depth, predicate, isStrict, result) {
  predicate || (predicate = isFlattenable);
  result || (result = []);

  if (array == null) {
    return result;
  }

  for (const value of array) {
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        flatten(value, depth - 1, predicate, isStrict, result);
      } else {
        result.push(...value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

flatten([1, 2, 3, [4, 5, [6]]], 2);
// [1, 2, 3, 4, 5, 6]
```

### 扁平化多维数组

1. 老方法

```js
var result = [];
function unfold(arr) {
  for (var i = 0; i < arr.length; i++) {
    if (typeof arr[i] == 'object' && arr[i].length > 1) {
      unfold(arr[i]);
    } else {
      result.push(arr[i]);
    }
  }
}
var arr = [1, 3, 4, 5, [6, [0, 1, 5], 9], [2, 5, [1, 5]], [5]];
unfold(arr);
```

2. 使用 tostring

```js
var c = [1, 3, 4, 5, [6, [0, 1, 5], 9], [2, 5, [1, 5]], [5]];
var b = c.toString().split(',');
```

3. 使用 es6 的 reduce 函数

```js
var arr = [1, 3, 4, 5, [6, [0, 1, 5], 9], [2, 5, [1, 5]], [5]];
const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
var result = flatten(arr);
```
