---
title: 类型转换
date: '2020-11-02'
draft: true
---

### 用 Array 的 reduce 方法实现 map 方法（头条一面）

### 合并数组中相邻且重复的元素

说明：请实现一个函数 merge，传入一个数组，合并数组中【相邻且重复】的元素。
实例：

```js
merge([3, 2, 2, 4, 5, 5, 6, 2, 1]); // 输出[3,2,4,5,6,2,1]
merge([3, 2, 3]); // 输出[3,2,3]
merge([2, 2, 3]); // 输出[2,3]
```

```js
function fn(arr) {
  var ret = [];
  if (!Array.isArray(arr) || arr.length === 0) {
    return ret;
  }
  for (var i = 0; i < arr.length; i++) {
    if (ret[ret.length - 1] !== arr[i]) {
      ret.push(arr[i]);
    }
  }
  return ret;
}
```

### 给出数组超过半数的数字，不存在的话输出没有（要求时间复杂度最低）

```js
function moreThanHalf(arr) {
  if (arr && Array.isArray(arr)) {
    var times = (result = index = 0);
    for (; index < arr.length; index++) {
      if (times === 0) {
        result = arr[index];
        times++;
      } else if (result !== arr[index]) {
        times--;
      } else {
        times++;
      }
    }
    if (times) {
      times = index = 0;
      for (; index < arr.length; index++) {
        if (result === arr[index]) {
          times++;
        }
      }
      if (times > arr.length / 2) {
        return result;
      }
    }
  }
  return '没有';
}
```

### 为数组写一个获取索引方法：indexOf()

```js
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(value) {
    for (var i = 0, len = this.length, item; i < len; i++) {
      item = this[i];
      if (item === value) {
        return i;
      }
    }
    return -1;
  };
}
```

### 为数组写一个检测是否包含值方法：contains()

```js
if (!Array.prototype.contains) {
  Array.prototype.contains = function(value) {
    for (var i = 0, len = this.length, item; i < len; i++) {
      item = this[i];
      if (item === value) {
        return true;
      }
    }
    return false;
  };
}
```

### 为数组写一个去重方法：unique()

```js
if (!Array.prototype.unique) {
  Array.prototype.unique = function(value) {
    var newArr = [],
      done = {};
    for (var i = 0, len = this.length, item; i < len; i++) {
      item = this[i];
      if (!done[item]) {
        newArr.push(item);
        done[item] = true;
      }
    }
    return newArr;
  };
}
```

## 数组去重

以下是数组去重的三种方法：

```js
Array.prototype.unique1 = function() {
  var n = []; //一个新的临时数组

  for (
    var i = 0;
    i < this.length;
    i++ //遍历当前数组
  ) {
    //如果当前数组的第i已经保存进了临时数组，那么跳过，

    //否则把当前项push到临时数组里面

    if (n.indexOf(this[i]) == -1) n.push(this[i]);
  }

  return n;
};

Array.prototype.unique2 = function() {
  var n = {},
    r = []; //n为hash表，r为临时数组

  for (var i = 0; i < this.length; i++) {
    //遍历当前数组

    if (!n[this[i]]) {
      //如果hash表中没有当前项

      n[this[i]] = true; //存入hash表

      r.push(this[i]); //把当前数组的当前项push到临时数组里面
    }
  }
  return r;
};

Array.prototype.unique3 = function() {
  var n = [this[0]]; //结果数组

  for (
    var i = 1;
    i < this.length;
    i++ //从第二项开始遍历
  ) {
    //如果当前数组的第i项在当前数组中第一次出现的位置不是i，

    //那么表示第i项是重复的，忽略掉。否则存入结果数组

    if (this.indexOf(this[i]) == i) n.push(this[i]);
  }

  return n;
};
```

### 数组去重

```js
let a = [1,3,2,4,5,1,2,4,2,5,6,2,3,2,1,4]
// 1. Set 去重
Array.from(new Set(a))
[...new Set(a)]

// 2. filter indexOf
a.filter((item, index) => a.indexOf(item) === index)

// 3. map 缓存
const map = {}, arr = []
for(let i = 0;i < a.length ; i++) {
  if(map[a[i]] === undefined) {
    arr.push(a[i])
  }
}

// 4. sort 排序 删除相邻相同元素
a = a.sort((a, b) => a - b)
for(let i = 1;i < a.length ; i++) {
  if(a[i] === a[i - 1]) {
    a.splice(i, 1)
    i--
  }
}

// 5.
```

### 数组去重

首先问：`["a", "b", "c", "d", "d", "f", "a","f", "g"]`这个数组去重?

> 以下两种是我当时的答案

> 第一种方式是：es6 的 Set,可以直接去重

```js
[...new Set([1, 1, 21, 5, 4, 4, 4, 4])];

//或者

Array.from(new Set([1, 2, 3, 3, 4, 5, 5]));
```

> 第二种方式是：for 循环，对象存放，这是最快的

```js
function deleteDuplicates(arr) {
  var newArr = [];
  var map = {}; //哈希表
  arr.forEach(item => {
    if (!map[item]) {
      newArr.push(item);
      map[item] = 1;
    }
  });
  return newArr;
}
```

> 但从耗时的角度来讲，这是最优的一种解决方式。但是从内存占用角度来说，这并不是最优的，因为多了一个 hash 表。这就是所谓的空间换时间

> 现在看来，还有其他的解决方案:
> 第三种，数组下标判断法.
> JS 引擎在实现 `indexOf()`的时候会遍历数组直到找到目标为止，此函数会浪费掉很多时间。所有这两种方式都不是最优的解决方式

```js
function deleteDuplicates(arr) {
  var newArr = [];
  arr.forEach((item, index) => {
    if (arr.indexOf(item) === index) {
      newArr.push(item);
    }
  });
  return newArr;
}
```

> 第四种，遍历数组法

```js
function deleteDuplicates(arr) {
  var newArr = [];
  arr.forEach((item, index) => {
    if (newArr.indexOf(item) === -1) {
      newArr.push(item);
    }
  });
  return newArr;
}
```

> 第五种，先排序，再比较相邻的值

```js
function dd(arr) {
  var n = [];
  var newA = arr.sort((a, b) => {
    return a.charCodeAt() - b.charCodeAt();
  });

  for (var i = 0; i < newA.length; i++) {
    if (newA[i] !== n[n.length - 1]) {
      n.push(newA[i]);
    }
  }
  return n;
}
```

> 这个方法的思路是先把数组排序，然后比较相邻的两个值。排序的时候用的 JS 原生的 sort()方法，JS 引擎内部应该是用的快速排序吧。这种方式比使用 indexOf()的一般姿势要快，比使用 hash 表的最快姿势要慢，但是占用内存要少

根据你的答案，会问你，for 循环复杂度是多少？

> 时间复杂度：O(n^2)？得去看看《算法》

有没有更高效的做法？

>

然后问一个延伸问题：[0,1,2,3,...9999]这样的一个数组，如何打乱它？

### js 数组去重

```js
Array.prototype.rmRepeat = function() {
  var res = [],
    hash = {};
  var len = this.length;
  for (var i = 0; i < len; i++) {
    if (!hash.hasOwnProperty('_' + this[i])) {
      hash['_' + this[i]] = 1;
      res.push(this[i]);
    }
  }
  return res;
};
```

## 扁平化

### 完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组

如：[1, [2, [ [3, 4], 5], 6]] => [1, 2, 3, 4, 5, 6]

```js
var data = [1, [2, [[3, 4], 5], 6]];
function flat(data, result) {
  var i, d, len;
  for (i = 0, len = data.length; i < len; ++i) {
    d = data[i];
    if (typeof d === 'number') {
      result.push(d);
    } else {
      flat(d, result);
    }
  }
}

var result = [];
flat(data, result);

console.log(result);
```

### 数组扁平化

数组扁平化是指将一个多维数组变为一维数组

```js
[1, [2, 3, [4, 5]]]------ > [1, 2, 3, 4, 5];
```

递归法：

```js
function flatten(arr) {
  let res = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      res = res.concat(flatten(item));
    } else {
      res.push(item);
    }
  });
  return res;
}
```

### 使用迭代的方式实现 flatten 函数

```js
let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]];
```

迭代实现

```js
function flatten(arr) {
  let arrs = [...arr];
  let newArr = [];
  while (arrs.length) {
    let item = arrs.shift();
    if (Array.isArray(item)) {
      arrs.unshift(...item);
    } else {
      newArr.push(item);
    }
  }
  return newArr;
}
```

递归实现

```js
function flatten(arr) {
  let arrs = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      arrs.push(...flatten(item));
    } else {
      arrs.push(item);
    }
  });
  return arrs;
}
```

字符串转换

```js
arr.join(',').split(',').map(item => Number(item)))
```

使用 Generator 实现数组 flatten:

```js
function* flat(arr) {
  for (let item of arr) {
    if (Array.isArray(item)) {
      yield* flat(item); //Generator委托
    } else {
      yield item;
    }
  }
}
function flatten(arr) {
  let result = [];
  for (let val of flat(arr)) {
    result.push(val);
  }
  return result;
}
let arr1 = [1, [2, 3, [4, 5], 6], [7]];
console.log(flatten(arr1)); //[1, 2, 3, 4, 5, 6, 7]
```

```js
const spreadableSymbol = Symbol.isConcatSpreadable;
const isFlattenable = value => {
  return (
    Array.isArray(value) ||
    (typeof value == 'object' && value !== null && Object.prototype.toString.call(value) === '[object Arguments]') ||
    !!(spreadableSymbol && value && value[spreadableSymbol])
  );
};

/**
 * flatten的基本实现，具体可以参考lodash库的flatten源码
 * @param array 需要展开的数组
 * @param depth 展开深度
 * @param predicate 迭代时需要调用的函数
 * @param isStrict 限制通过`predicate`函数检查的值
 * @param result 初始结果值
 * @returns {Array} 返回展开后的数组
 */
function flatten(array, depth, predicate, isStrict, result) {
  predicate || (predicate = isFlattenable);
  result || (result = []);

  if (array == null) {
    return result;
  }

  for (const value of array) {
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        flatten(value, depth - 1, predicate, isStrict, result);
      } else {
        result.push(...value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

flatten([1, 2, 3, [4, 5, [6]]], 2);
// [1, 2, 3, 4, 5, 6]
```

### 扁平化多维数组

1. 老方法

```js
var result = [];
function unfold(arr) {
  for (var i = 0; i < arr.length; i++) {
    if (typeof arr[i] == 'object' && arr[i].length > 1) {
      unfold(arr[i]);
    } else {
      result.push(arr[i]);
    }
  }
}
var arr = [1, 3, 4, 5, [6, [0, 1, 5], 9], [2, 5, [1, 5]], [5]];
unfold(arr);
```

2. 使用 tostring

```js
var c = [1, 3, 4, 5, [6, [0, 1, 5], 9], [2, 5, [1, 5]], [5]];
var b = c.toString().split(',');
```

3. 使用 es6 的 reduce 函数

```js
var arr = [1, 3, 4, 5, [6, [0, 1, 5], 9], [2, 5, [1, 5]], [5]];
const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
var result = flatten(arr);
```
