---
title: 手写前端代码
date: 2020-12-16
draft: true
---

## 防抖、节流

```js
function debounce(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

```js
function throttle(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        fn.apply(this, args);
      }, delay);
    }
  };
}
```

## 拷贝函数

### 浅拷贝

- `Object.assign`
- 展开运算符 `...`
- for 循环方式， 手动复制属性

### 深拷贝

#### 1. JSON.parse JSON.stringify

简单的做法：`JSON.parse(JSON.stringify(obj))`， 但是该方法也是有局限性的：

- 会忽略`undefined`
- 会忽略`symbol`
- 会忽略函数
- 不能解决循环引用的对象 （会报错）

#### 2. MessageChannel

如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 `MessageChannel`。 这种方法有局限性，当属性值是函数的时候，会报错。

```js
function structuralClone(obj) {
  return new Promise(resolve => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = ev => resolve(ev.data);
    port1.postMessage(obj);
  });
}

var obj = {
  a: 1,
  b: {
    c: 2,
  },
};

obj.b.d = obj.b;

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () => {
  const clone = await structuralClone(obj);
  console.log(clone);
};
test();
```

#### 3. for 循环深拷贝

```js
// 判断属性值类型是原始类型和引用类型
function isObj(obj) {
  return typeof obj === 'object' && obj !== null;
}

// TODO: 考虑 正则，Date这种类型的数据 ?
function deepClone(obj, map = new WeakMap()) {
  // 解决环的情况
  if (map.has(obj)) return map.get(obj);
  // 数组 or 对象
  let cloneObj = Array.isArray(obj) ? [] : {};
  map.set(obj, cloneObj);
  // for-in 会遍历原型链上的属性
  for (let key in obj) {
    // 需要判断是否是原型链上的属性，不是原型链才拷贝
    if (obj.hasOwnProperty(key)) {
      // 原始类型直接赋值（注意 null）
      cloneObj[key] = isObj(obj[key]) ? deepClone(obj[key], map) : obj[key];
    }
  }
  return cloneObj;
}
```

## 解析 url

### 解析一个参数

```js
function getQueryString(name) {
  const reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
  const r = window.location.search.slice(1).match(reg);
  if (r != null) {
    return r[2];
  }
  return null;
}
```

### url 所有参数转化为一个对象

```js
var parseQueryString = function(search) {
  if (!search) return {};
  const regExp = /([^&=]+)=([\w\W]*?)(&|$)/g;
  const ret = {};
  search = search[0] === '?' ? search.slice(1) : search;
  while ((result = regExp.exec(search)) != null) {
    ret[result[1]] = result[2];
  }
  return ret;
};
```

## 实现一个 EventEmitter 类

```js
function EventEmitter() {
  this.callbacksMap = {};
}

EventEmitter.prototype.on = function(type, handler) {
  const callbacks = this.callbacksMap[type];
  if (!callbacks) {
    this.callbacksMap[type] = [handler];
  } else {
    callbacks.push(handler);
  }
  return this;
};

EventEmitter.prototype.off = function(type, handler) {
  const list = this.callbacksMap[type] || [];

  for (let i = list.length; i >= 0; --i) {
    if (!handler || list[i] === handler) {
      list.splice(i, 1);
    }
  }

  return this;
};

EventEmitter.prototype.emit = function(type, data) {
  const list = this.callbacksMap[type];

  if (list) {
    for (let i = 0, len = list.length; i < len; ++i) {
      list[i].call(this, data);
    }
  }
};

EventEmitter.prototype.once = function(type, handler) {
  const self = this;

  function wrapper() {
    handler.apply(self, arguments);
    self.off(type, wrapper);
  }
  this.on(type, wrapper);
  return this;
};

const evt = new EventEmitter();

evt.on('haha', () => {
  console.log('haha1');
});

function haha2() {
  console.log('haha2');
}

evt.on('haha', haha2);

evt.emit('haha');

evt.once('haha', () => {
  console.log('haha3');
});

evt.emit('haha');
evt.emit('haha');

evt.off('haha', haha2);
evt.emit('haha');

evt.off('haha');
evt.emit('haha');
```

## 数组去重（对象、非对象）

```js
// set 去重
[...new Set(arr)];

// 利用 indexOf 去重
const newArr = arr.filter((item, index, arr) => index === arr.indexOf(item));

// 利用对象去重
let objA = {};
const newArrA = arr.filter((item, index, arr) => (objA.hasOwnProperty(item) ? false : (objA[item] = true)));

// 双重循环去重
```

### 数组对象去重

```js
function removeDuplication(arr = [], key = '') {
  if (!key) return Array.from(new Set(arr));
  const map = {};
  return arr.reduce((result, next) => {
    map[next[key]] ? '' : (map[next[key]] = true && result.push(next));
    return result;
  }, []);
}
```

## 实现 flatten 扁平化函数

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
  return a - b;
});
```

**竟然原生就有这个 flat 函数，用来拍平数组**
flat 函数的参数是层级。Infinity 无限大。 会拍平数组中的所有数组值。

```js
function flatten(arr) {
  let temp = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      temp.push(...flatten(item));
    } else {
      temp.push(item);
    }
  });
  return temp;
}
```

递归实现

```js
function flatten(arr, result = []) {
  arr.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
}
```

使用 es6 的 reduce 函数

```js
const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
```

### 有层级的数组扁平化

```js
function flatten(arr, deep) {
  if (!deep) return arr;
  let temp = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      temp.push(...flatten(item, --deep));
    } else {
      temp.push(item);
    }
  });
  return temp;
}
```

## 大数相加

1000000000 + 1000000000 允许返回字符串。处理大数。大数问题其实就是通过字符串来处理，从后往前加，然后处理进位的问题。

```js
function add(a, b) {
  //取两个数字的最大长度
  let maxLength = Math.max(a.length, b.length);
  //用 0 去补齐长度
  a = a.padStart(maxLength, 0); //"0009007199254740991"
  b = b.padStart(maxLength, 0); //"1234567899999999999"
  // 定义加法过程中需要用到的变量
  let t = 0;
  let f = 0; // 进位
  let sum = '';
  for (let i = maxLength - 1; i >= 0; i--) {
    t = parseInt(a[i]) + parseInt(b[i]) + f;
    // Math.floor 向下取整。 Math.ceil 向上取整。
    f = Math.floor(t / 10);
    sum = (t % 10) + sum;
  }
  if (f == 1) {
    sum = '1' + sum;
  }
  return sum;
}
```

## 加法函数

写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3

```js
function accAdd(arg1, arg2) {
  var r1, r2, m;
  try {
    r1 = arg1.toString().split('.')[1].length;
  } catch (e) {
    r1 = 0;
  }
  try {
    r2 = arg2.toString().split('.')[1].length;
  } catch (e) {
    r2 = 0;
  }
  // 计算出一个倍数。看小数点后面的值的长度
  m = Math.pow(10, Math.max(r1, r2));
  // 先乘这个倍数，再除以这个倍数
  return (arg1 * m + arg2 * m) / m;
}
var result = accAdd(0.1, 0.2);
console.log(result); // 0.3
```

### js 浮点数运算不精确 如何解决?

## 手写 call、apply 及 bind 函数

```js
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  context = context || window;
  // 通过将函数挂载到 context 对象上来使得 this 改变
  context.fn = this;
  const args = [...arguments].slice(1);
  const result = context.fn(...args);
  delete context.fn;
  return result;
};
```

```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  context = context || window;
  context.fn = this;
  let result;
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

bind 实现

`bind` 的实现对比其他两个函数略微地复杂了一点，因为 `bind` 需要返回一个函数，需要判断一些边界问题，以下是 `bind` 的实现

```js
Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  const that = this;
  const args = [...arguments].slice(1);
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new that(...args, ...arguments);
    }
    return that.apply(context, args.concat(...arguments));
  };
};
```

以下是对实现的分析：

- 前几步和之前的实现差不多，就不赘述了
- `bind` 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 `new` 的方式，我们先来说直接调用的方式
- 对于直接调用来说，这里选择了 `apply` 的方式实现，但是对于参数需要注意以下情况：因为 `bind` 可以实现类似这样的代码 `f.bind(obj, 1)(2)`，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 `args.concat(...arguments)`
- 最后来说通过 `new` 的方式，在之前的章节中我们学习过如何判断 `this`，对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况我们需要忽略传入的 `this`

```js
Function.prototype.bind = function(oThis) {
  if (typeof this !== 'function') {
    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
      // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
      // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
      return fToBind.apply(
        this instanceof fNOP && oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments)),
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
```

## 手写的 ajax

手写的 ajax 是否兼容 IE ， IE 下面的 ajax 与普通浏览器的 ajax 对象不一样

```js
function ajax(url, cb) {
  let xhr;
  // 创建 XMLHttpRequest 对象
  if (window.XMLHttpRequest) {
    // `XMLHttpRequest`只有在高级浏览器中才支持. 非 IE 内核
    xhr = new XMLHttpRequest();
  } else {
    // IE内核
    xhr = ActiveXObject('Microsoft.XMLHTTP');
  }
  // 绑定 onreadystatechange 事件
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      //  获取异步调用返回的数据
      cb(xhr.responseText);
    }
  };
  // 向服务器发送请求
  xhr.open('GET', url, true);
  xhr.send();
}
```

## 手写 promise

```js
const PENDING = 'pending';
const RESOLVED = 'resolved';
const REJECTED = 'rejected';

function MyPromise(fn) {
  const that = this;
  that.state = PENDING;
  that.value = null;
  that.resolvedCallbacks = [];
  that.rejectedCallbacks = [];

  function resolve(value) {
    if (that.state === PENDING) {
      that.state = RESOLVED;
      that.value = value;
      that.resolvedCallbacks.map(cb => cb(that.value));
    }
  }

  function reject(value) {
    if (that.state === PENDING) {
      that.state = REJECTED;
      that.value = value;
      that.rejectedCallbacks.map(cb => cb(that.value));
    }
  }

  try {
    fn(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

MyPromise.prototype.then = function(onFulfilled, onRejected) {
  return new MyPromise((resolve, reject) => {
    const that = this;
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : r => {
            throw r;
          };
    if (that.state === PENDING) {
      that.resolvedCallbacks.push(onFulfilled);
      that.rejectedCallbacks.push(onRejected);
    }
    if (that.state === RESOLVED) {
      onFulfilled(that.value);
      resolve(that.value);
    }
    if (that.state === REJECTED) {
      onRejected(that.value);
      reject(that.value);
    }
  });
};
```

## 原生 js 实现 MVVM

```js
<span id="box">
  <h1 id="text"></h1>
  <input type="text" id="input" oninput="inputChange(event)" />
  <button id="button" onclick="clickChange()">
    Click me
  </button>
</span>
```

```js
const input = document.getElementById('input');
const text = document.getElementById('text');
const button = document.getElementById('button');
const data = {
  value: '',
};
function defineProperty(obj, attr) {
  let val;
  Object.defineProperty(obj, attr, {
    set(newValue) {
      console.log('set');
      if (val === newValue) {
        return;
      }
      val = newValue;
      input.value = newValue;
      text.innerHTML = newValue;
    },
    get() {
      console.log('get');
      return val;
    },
  });
}
defineProperty(data, 'value');
function inputChange(event) {
  data.value = event.target.value;
}

function clickChange() {
  data.value = 'hello';
}
```

## sleep 函数

```js
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
async function output() {
  let out = await sleep(1000);
  console.log(1);
  return out;
}
output();
```

```js
async function sleep(time) {
  // 这里是实现
  return new Promise(res => {
    setTimeout(() => {
      res();
    }, time);
  });
}
console.log(1);
await sleep(3000);
console.log(2);
```

### js 实现一个拖拽？

首先是三个事件，分别是 mousedown，mousemove，mouseup
当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。

clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：
鼠标移动时候的坐标-鼠标按下去时候的坐标。

也就是说定位信息为：

鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.

还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left
以及 top 等等值。
div:

```html
<div class="drag" style="left:0;top:0;width:100px;height:100px">按住拖动</div>

<style>
  .drag {
    background-color: skyblue;
    position: absolute;
    line-height: 100px;
    text-align: center;
  }
</style>
```

js:

```js
// 获取DOM元素
let dragDiv = document.getElementsByClassName('drag')[0];
// 鼠标按下事件 处理程序
let putDown = function(event) {
  dragDiv.style.cursor = 'pointer';
  let offsetX = parseInt(dragDiv.style.left); // 获取当前的x轴距离
  let offsetY = parseInt(dragDiv.style.top); // 获取当前的y轴距离
  let innerX = event.clientX - offsetX; // 获取鼠标在方块内的x轴距
  let innerY = event.clientY - offsetY; // 获取鼠标在方块内的y轴距
  // 按住鼠标时为div添加一个border
  dragDiv.style.borderStyle = 'solid';
  dragDiv.style.borderColor = 'red';
  dragDiv.style.borderWidth = '3px';
  // 鼠标移动的时候不停的修改div的left和top值
  document.onmousemove = function(event) {
    dragDiv.style.left = event.clientX - innerX + 'px';
    dragDiv.style.top = event.clientY - innerY + 'px';
    // 边界判断
    if (parseInt(dragDiv.style.left) <= 0) {
      dragDiv.style.left = '0px';
    }
    if (parseInt(dragDiv.style.top) <= 0) {
      dragDiv.style.top = '0px';
    }
    if (parseInt(dragDiv.style.left) >= window.innerWidth - parseInt(dragDiv.style.width)) {
      dragDiv.style.left = window.innerWidth - parseInt(dragDiv.style.width) + 'px';
    }
    if (parseInt(dragDiv.style.top) >= window.innerHeight - parseInt(dragDiv.style.height)) {
      dragDiv.style.top = window.innerHeight - parseInt(dragDiv.style.height) + 'px';
    }
  };
  // 鼠标抬起时，清除绑定在文档上的mousemove和mouseup事件
  // 否则鼠标抬起后还可以继续拖拽方块
  document.onmouseup = function() {
    document.onmousemove = null;
    document.onmouseup = null;
    // 清除border
    dragDiv.style.borderStyle = '';
    dragDiv.style.borderColor = '';
    dragDiv.style.borderWidth = '';
  };
};
// 绑定鼠标按下事件
dragDiv.addEventListener('mousedown', putDown, false);
```

### 实现 destructuringArray 方法，达到如下效果

```js
// destructuringArray( [1,[2,4],3], "[a,[b],c]" );
// result
// { a:1, b:2, c:3 }
```

实现：

```js
destructuringArray = (value, keys) => {
  let obj = {};
  // "[a,[b],c]".replace(/\w+/g, '"$&"')
  let arr = JSON.parse(keys.replace(/\w+/g, '"$&"'));
  console.log(arr);
  const iterate = (value, keys) => {
    keys.forEach((item, index) => {
      if (Array.isArray(item)) iterate(value[index], item);
      else obj[item] = value[index];
    });
  };
  iterate(value, arr);
  console.log(obj);
  return obj;
};
```

### 需要通过 threshold 参数控制调用函数频率

```js
const yourFunction = function(func, threshold) {
  // 请实现
};
const triggerSearch = yourFunction(val => {
  const { onSearch } = this.props;
  onSearch(val);
}, 300);
triggerSearch(searchText);
```

实现

```js
const yourFunction = function(func, threshold) {
  let timeOut;
  return function() {
    if (!timeOut) {
      timeOut = setTimeout(() => {
        timeOut = null;
        func.apply(this, arguments);
      }, threshold);
    }
  };
};

const triggerSearch = yourFunction(val => {
  const { onSearch } = this.props;
  onSearch(val);
}, 300);
```

## 手写 JSONP

jsonp 原理：因为 jsonp 发送的并不是 ajax 请求，其实是动态创建 script 标签
script 标签是没有同源限制的，把 script 标签的 src 指向请求的服务端地址。

```js
function jsonp(url, data = {}, callback = 'callback') {
  //处理json对象，拼接url
  data.callback = callback;
  let params = [];
  for (let key in data) {
    params.push(key + '=' + data[key]);
  }
  let script = document.createElement('script');
  script.src = url + '?' + params.join('&');
  document.body.appendChild(script);

  //返回Promise
  return new Promise((resolve, reject) => {
    window[callback] = data => {
      try {
        resolve(data);
      } catch (e) {
        reject(e);
      } finally {
        //移除 script 元素
        script.parentNode.removeChild(script);
        console.log(script);
      }
    };
  });
}

//请求数据
jsonp(
  'http://photo.sina.cn/aj/index',
  {
    page: 1,
    cate: 'recommend',
  },
  'jsonCallback',
).then(data => {
  console.log(data);
});
```

### Jsonp 方案需要服务端怎么配合 ?

## 用两个栈实现队列

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

### 思路

一个栈用来存储插入队列数据，一个栈用来从队列中取出数据。从第一个栈向第二个栈转移数据的过程中：数据的性质已经从后入先出变成了先入先出。

```js
var CQueue = function() {
  this.outStack = [];
  this.inStack = [];
};

/**
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
  if (value) {
    // 新插入队列的数据都放在 inStack
    this.inStack.push(value);
  }
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
  const { outStack, inStack } = this;
  //  如果 outStack 为空，那么将 inStack 中的元素都转移过来
  if (!outStack.length) {
    while (inStack.length) {
      outStack.push(inStack.pop());
    }
  }
  return !outStack.length ? -1 : outStack.pop();
};
```

## 低优先级

### 事件触发器

兼容所有浏览器

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return element.dispatchEvent(mockEvent);
  }
};
```

### 千分位

```js
function test1(num) {
  var str = +num + '';
  var len = str.length;
  if (len <= 3) return str;
  num = '';
  while (len > 3) {
    len -= 3;
    num = ',' + str.substr(len, 3) + num;
  }
  return str.substr(0, len) + num;
}

function test2(num) {
  // ?= 正向匹配:匹配位置
  // ?! 正向不匹配:排除位置
  var str = (+num).toString();
  var reg = /(?=(?!\b)(\d{3})+$)/g;
  return str.replace(reg, ',');
}
```

#### 千分位

如 12000000.11 转化为 12,000,000.11

```js
function commafy(num) {
  const val = Math.abs(num);
  const isPositive = num === val;
  const result =
    val &&
    val.toString().replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2) {
      return $2 + ',';
    });
  // return isPositive ? result : `-${result}`;
  return result;
}
```

#### 实现千分位标注位

考虑小数、负数和整数三种情况。

`sep`参数是自定义的分隔符，默认是`,`

```js
/**
 * 实现千分位标注位
 * @param {*} str 待标注的字符串
 * @param {*} sep 标注符号
 */
const addSeparator = (str = '', sep = ',') => {
  str += '';
  const arr = str.split('.'),
    re = /(\d+)(\d{3})/;

  let integer = arr[0],
    decimal = arr.length <= 1 ? '' : `.${arr[1]}`;

  while (re.test(integer)) {
    integer = integer.replace(re, '$1' + sep + '$2');
  }

  return integer + decimal;
};

console.log(addSeparator(-10000.23)); // -10,000.23
console.log(addSeparator(100)); // 100
console.log(addSeparator(1234, ';')); // 1;234
```

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

#### 格式化金钱，每千分位加逗号

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

### 代码中 a 在什么情况下会打印 1？

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

考察隐式转换,重写 toString 方法即可

```js
var a = {
  i: 1,
  toString() {
    return a.i++;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```

```js
let a = {
  i: 1,
  valueOf() {
    return a.i++;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

```js
var a = [1, 2, 3];
a.join = a.shift;
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

```js
let a = { [Symbol.toPrimitive]: (i => () => ++i)(0) };
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

### 实现 (5).add(3).minus(2) 功能

```js
Number.prototype.add = function(value) {
  let number = parseFloat(value);
  if (typeof number !== 'number' || Number.isNaN(number)) {
    throw new Error('请输入数字或者数字字符串～');
  }
  return this + number;
};
Number.prototype.minus = function(value) {
  let number = parseFloat(value);
  if (typeof number !== 'number' || Number.isNaN(number)) {
    throw new Error('请输入数字或者数字字符串～');
  }
  return this - number;
};
console.log((5).add(3).minus(2));
```

### 要求设计 LazyMan 类，实现以下功能

```js
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony')
  .sleep(10)
  .eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony')
  .eat('lunch')
  .sleep(10)
  .eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony')
  .eat('lunch')
  .eat('dinner')
  .sleepFirst(5)
  .sleep(10)
  .eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

答案：

```js
class LazyManClass {
  constructor(name) {
    this.taskList = [];
    this.name = name;
    console.log(`Hi I am ${this.name}`);
    setTimeout(() => {
      this.next();
    }, 0);
  }
  eat(name) {
    var that = this;
    var fn = (function(n) {
      return function() {
        console.log(`I am eating ${n}`);
        that.next();
      };
    })(name);
    this.taskList.push(fn);
    return this;
  }
  sleepFirst(time) {
    var that = this;
    var fn = (function(t) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${t}秒...`);
          that.next();
        }, t * 1000);
      };
    })(time);
    this.taskList.unshift(fn);
    return this;
  }
  sleep(time) {
    var that = this;
    var fn = (function(t) {
      return function() {
        setTimeout(() => {
          console.log(`等待了${t}秒...`);
          that.next();
        }, t * 1000);
      };
    })(time);
    this.taskList.push(fn);
    return this;
  }
  next() {
    var fn = this.taskList.shift();
    fn && fn();
  }
}
function LazyMan(name) {
  return new LazyManClass(name);
}
LazyMan('Tony')
  .eat('lunch')
  .eat('dinner')
  .sleepFirst(5)
  .sleep(4)
  .eat('junk food');
```

### 实现一个持续的动画效果

js 定时器实现

```js
var e = document.getElementById('e');
var flag = true;
var left = 0;
setInterval(() => {
  left == 0 ? (flag = true) : left == 100 ? (flag = false) : '';
  flag ? (e.style.left = ` ${left++}px`) : (e.style.left = ` ${left--}px`);
}, 1000 / 60);
```

js API requestAnimationFrame 实现

```js
//兼容性处理
window.requestAnimFrame = (function() {
  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
    }
  );
})();

var e = document.getElementById('e');
var flag = true;
var left = 0;

function render() {
  left == 0 ? (flag = true) : left == 100 ? (flag = false) : '';
  flag ? (e.style.left = ` ${left++}px`) : (e.style.left = ` ${left--}px`);
}

(function animloop() {
  render();
  requestAnimFrame(animloop);
})();
```

优势：

浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果
解决毫秒的不精确性
避免过度渲染（渲染频率太高、tab 不可见暂停等等）
注：requestAnimFrame 和 定时器一样也头一个类似的清除方法 cancelAnimationFrame

css 实现：

```css
.test {
  animation: mymove 5s infinite;
  @keyframes mymove {
    from {
      top: 0px;
    }
    to {
      top: 200px;
    }
  }
}
```

### 实现函数字符串转对象

```
'a.b.c'
=>
a: {
    b: {
        c: null
    }
}
```

### 输入字符串输出二维数组

```
`
12312

1  3
12 3
`
=>
[
    ['12312'],
    ['13'],
    ['123']
]
```

```js
function handler(str = '') {
  return str
    .split('\n')
    .filter(Boolean)
    .map(val => val.replace(/\s/g, ''));
}
```

## 总结

```js
// 使用箭头函数缩减代码
// 处理输入，可以用.map，需要注意其所有参数
// 此外其他迭代方法也需要掌握。
let line = readline().split(' ');
line = line.map(e => parseInt(e, 10));

// 去重
arr = [...new Set(arr)];
// 升序,排序可以用sort，默认是字典序,并且可以根据需要定制，需要深入掌握
arr.sort((a, b) => a - b);
// 迭代输出
arr.forEach(i => console.log(i));
// 求最大值，使用扩展运算符...
max = Math.max.call(...arr);
// 复制数组
arr2 = [...arr1];
arr2 = arr.concat();
arr2 = arr.slice();

// 善用解构
// 变量赋值
const [a, b, c, d, e] = [1, 2, 3, 4, 5]; // a=1,b=2,c=3,d=4,e=5
// 交换变量值
let x = 1,
  y = 2;
[x, y] = [y, x];
// 题外话：字符串中的字符是无法交换的
let str = 'ab';
[str[0], str[1]] = [str[1], str[0]]; // 无效，"ab"
// 不过可以将字符串拆成字符数组后就可以交换了
str = str.split(''); // ["a","b"]
[str[0], str[1]] = [str[1], str[0]]; // ["b","a"]

// 善用位操作符
// 求数组一半长度
halfLen = a.length >> 1;

// 不过需要注意右移运算符>>优先级别加号+还低，例如
console.log(3 + ((5 - 3) >> 1)); // 2
console.log(3 + ~~((5 - 3) / 2)); // 4

// 因此在于其他操作符号想结合时候可以适当增加括号,例如求中位
mid = left + ((right - left) >> 1);
mid = left + ~~((right - left) / 2);
// 不建议使用mid = (left + right)>>1;，因为加号操作可能造成溢出

// ~~等价于Math.floor(),|0 也等价于Math.floor()
halfLen = ~~(a.length / 2);
halfLen = (a.length / 2) | 0;

// 判断奇偶
evenNum & (1 === 0); // 偶数
oddNum & (1 === 1); // 奇数

// 善用异或
5 ^ (5 === 0);
5 ^ 5 ^ 6 ^ 6 ^ (7 === 7);

// 判断数是否是2的幂次方
num & (num - 1 === 0);

// 翻转数的第K位
num ^= 1 << k;

// 将第K位设为0
num &= ~(1 << k);

// 将第K位设为1
num |= 1 << K;

// 判断第K位是否为0
num & (1 << k === 0);
```
