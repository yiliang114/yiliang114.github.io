---
title: 手写前端代码
date: 2020-12-16
draft: true
---

## 手写前端代码

### 数组去重（对象、非对象）

1. set 去重

```js
[...new Set(arr)];
```

2. 利用 indexOf 去重

```js
const newArr = arr.filter((item, index, arr) => index === arr.indexOf(item));
```

```js
let newArrB = [];
arr.forEach(item => (newArrB.indexOf(item) === -1 ? newArrB.push(item) : ''));
```

3. 利用对象去重

```js
let objA = {};
const newArrA = arr.filter((item, index, arr) => (objA.hasOwnProperty(item) ? false : (objA[item] = true)));
```

4. 双重循环去重

```js
function removeDuplicatedItem(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1); //console.log(arr[j]);
        j--;
      }
    }
  }
  return arr;
}
```

5. 利用 sort()加前后比较去重

```js
const newArrC = arr.sort().filter((item, index, arr) => item !== arr[index + 1]);
```

### 大数相加

### url 解析

### 深拷贝

```js
function assignDeep(target, ...sources) {
  for (let source of sources) {
    for (let key in source) {
      if (isObject(source[key])) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        assignDeep(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}

function isObject(a) {
  return typeof a === 'object' && a !== null;
}
```

### 防抖、节流

有立即执行和非立即执行版。lodash 的话， debounce 第三个参数给一个对象，{ leading: true }, 表示立即执行版本。

#### debounce

```js
// 非最好
function debounce(fn, delay = 0) {
  // keep track of the last call to the debounced function
  let last = {
    time: null,
    timerId: null,
  };

  // return a debounced version of fn
  return () => {
    let time = Date.now();

    // if the debounced function was called again before the delay elapsed,
    // cancel the timer (started in the previous call) that would have called
    // fn, and start a new timer.
    if (last.time && time - last.time < delay) {
      clearTimeout(last.timerId);
    }

    // start a timer to call fn after the given delay
    last = {
      time,
      timerId: setTimeout(fn, delay),
    };
  };
}
```

#### throttle and debounce

```js
// 节流throttle，多次触发但只执行一部分，(恒时间间距执行)
function throttle(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    if (!timer) {
      timer = setTimeout(function() {
        timer = null;
        method.apply(ctx, args);
      }, threshold);
    }
  };
}

// 防抖debounce, 多次触发但只执行一次，(时间差大于阈值才执行)
function debounce(method, threshold, ctx) {
  let timer = null;
  return function() {
    const args = [].slice.call(arguments);
    timer && clearTimeout(timer);
    timer = setTimeout(function() {
      method.apply(ctx, args);
    }, threshold);
  };
}

// 轮循函数
// usage: wait(fn.bind(ctx, ...args), 10000);
function wait(fn, timeout, tick) {
  timeout = timeout || 5000;
  tick = tick || 250;
  var timeoutTimer = null;
  var execTimer = null;

  return new Promise(function(resolve, reject) {
    timeoutTimer = setTimeout(function() {
      clearTimeout(execTimer);
      reject(new Error('polling fail because timeout'));
    }, timeout);

    tickHandler(fn);

    function tickHandler(fn) {
      var ret = fn();
      if (!ret) {
        execTimer = setTimeout(function() {
          tickHandler(fn);
        }, tick);
      } else {
        clearTimeout(timeoutTimer);
        resolve();
      }
    }
  });
}

var n = 1;
wait(
  function() {
    console.log(n++);
    return n > 10;
  },
  2000,
  300,
)
  .then(function() {
    console.log('===== end ====');
  })
  .catch(function(err) {
    console.error('error', err);
  });
```

### Event Class

```js
const Noop = () => {};

class EventEmitter {
  constructor() {
    this.events = [];
  }

  on(event, handler = Noop) {
    if (typeof this.events[event] === 'undefined') {
      this.events[event] = [handler];
    } else {
      this.events[event].push(handler);
    }
  }

  once(event, handler = Noop) {
    const once = `once_${event}`;
    if (typeof this.events[once] === 'undefined') {
      this.events[once] = [handler];
    } else {
      this.events[once].push(handler);
    }
  }

  emit(event, args) {
    const once = `once_${event}`;
    if (typeof this.events[once] !== 'undefined') {
      this.events[once].forEach(handler => {
        handler(args);
      });
      delete this.events[`once_${event}`];
    }
    if (typeof this.events[event] !== 'undefined') {
      this.events[event].forEach(handler => {
        handler(args);
      });
    }
  }

  off(event, handler) {
    if (typeof this.events[event] !== 'undefined') {
      if (!!handler) {
        const index = this.events[event].indexOf(handler);
        this.events[event].splice(index, 1);
      } else {
        delete this.events[event];
      }
    }
  }
}

function test() {
  const eh = new EventEmitter();

  const firstHd = str => {
    console.log('first greet: ', str);
  };

  eh.on('greet', firstHd);

  eh.on('greet', str => {
    console.log('second greet: ', str);
  });

  eh.on('bye', name => {
    console.log(name + ', goodbye!');
  });

  eh.once('break', str => {
    console.log(`once break: ${str}`);
  });
  eh.on('break', str => {
    console.log(`on break: ${str}`);
  });

  console.log('======  start  ======');
  eh.emit('greet', 'Green');
  eh.emit('bye', 'Mark');
  eh.emit('break', 'Jack');
  eh.emit('break', 'Tony');

  console.log('======  removeListener  ======');
  eh.off('bye');
  eh.emit('bye', 'Mark');

  eh.off('greet', firstHd);
  eh.emit('greet', 'Green');
}

test();
```

### 实现一个 Event 类

继承自此类的对象都会拥有两个方法 on,off,once 和 trigger

```js
function Event() {
  if (!(this instanceof Event)) {
    return new Event();
  }
  this._callbacks = {};
}
Event.prototype.on = function(type, handler) {
  this_callbacks = this._callbacks || {};
  this._callbacks[type] = this.callbacks[type] || [];
  this._callbacks[type].push(handler);

  return this;
};

Event.prototype.off = function(type, handler) {
  var list = this._callbacks[type];

  if (list) {
    for (var i = list.length; i >= 0; --i) {
      if (list[i] === handler) {
        list.splice(i, 1);
      }
    }
  }

  return this;
};

Event.prototype.trigger = function(type, data) {
  var list = this._callbacks[type];

  if (list) {
    for (var i = 0, len = list.length; i < len; ++i) {
      list[i].call(this, data);
    }
  }
};

Event.prototype.once = function(type, handler) {
  var self = this;

  function wrapper() {
    handler.apply(self, arguments);
    self.off(type, wrapper);
  }
  this.on(type, wrapper);
  return this;
};
```

### 手动撸个 call/apply/bind

> 感谢 [@purain](https://github.com/purain) 的指正，`call` 和 `apply` 更完美的实现要借助 `Symbol`。具体请看[Issue](https://github.com/dongyuanxin/blog/issues/57)

#### 实现 call

来看下`call`的原生表现形式：

```js
function test(arg1, arg2) {
  console.log(arg1, arg2);
  console.log(this.a, this.b);
}

test.call(
  {
    a: 'a',
    b: 'b',
  },
  1,
  2,
);
```

好了，开始手动实现我们的`call2`。在实现的过程有个关键：

**如果一个函数作为一个对象的属性，那么通过对象的`.`运算符调用此函数，`this`就是此对象**

```js
let obj = {
  a: 'a',
  b: 'b',
  test: function(arg1, arg2) {
    console.log(arg1, arg2);
    // this.a 就是 a; this.b 就是 b
    console.log(this.a, this.b);
  },
};

obj.test(1, 2);
```

知道了实现关键，下面就是我们模拟的`call`：

```js
Function.prototype.call2 = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }

  // 默认上下文是window
  context = context || window;
  // 保存默认的fn
  const { fn } = context;

  // 前面讲的关键，将函数本身作为对象context的属性调用，自动绑定this
  context.fn = this;
  const args = [...arguments].slice(1);
  const result = context.fn(...args);

  // 恢复默认的fn
  context.fn = fn;
  return result;
};

// 以下是测试代码
function test(arg1, arg2) {
  console.log(arg1, arg2);
  console.log(this.a, this.b);
}

test.call2(
  {
    a: 'a',
    b: 'b',
  },
  1,
  2,
);
```

#### 实现 apply

`apply`和`call`实现类似，只是传入的参数形式是数组形式，而不是逗号分隔的参数序列。

因此，借助 es6 提供的`...`运算符，就可以很方便的实现数组和参数序列的转化。

```js
Function.prototype.apply2 = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }

  context = context || window;
  const { fn } = context;

  context.fn = this;
  let result;
  if (Array.isArray(arguments[1])) {
    // 通过...运算符将数组转换为用逗号分隔的参数序列
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }

  context.fn = fn;
  return result;
};

/**
 * 以下是测试代码
 */

function test(arg1, arg2) {
  console.log(arg1, arg2);
  console.log(this.a, this.b);
}

test.apply2(
  {
    a: 'a',
    b: 'b',
  },
  [1, 2],
);
```

#### 实现 bind

`bind`的实现有点意思，它有两个特点：

- 本身返回一个新的函数，所以要考虑`new`的情况
- 可以“保留”参数，内部实现了参数的拼接

```js
Function.prototype.bind2 = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }

  const that = this;
  // 保留之前的参数，为了下面的参数拼接
  const args = [...arguments].slice(1);

  return function F() {
    // 如果被new创建实例，不会被改变上下文！
    if (this instanceof F) {
      return new that(...args, ...arguments);
    }

    // args.concat(...arguments): 拼接之前和现在的参数
    // 注意：arguments是个类Array的Object, 用解构运算符..., 直接拿值拼接
    return that.apply(context, args.concat(...arguments));
  };
};

/**
 * 以下是测试代码
 */

function test(arg1, arg2) {
  console.log(arg1, arg2);
  console.log(this.a, this.b);
}

const test2 = test.bind2(
  {
    a: 'a',
    b: 'b',
  },
  1,
); // 参数 1

test2(2); // 参数 2
```

### 实现深拷贝函数

实现一个对象的深拷贝函数，需要考虑对象的元素类型以及对应的解决方案：

- 基础类型：这种最简单，直接赋值即可
- 对象类型：递归调用拷贝函数
- 数组类型：这种最难，因为数组中的元素可能是基础类型、对象还可能数组，因此要专门做一个函数来处理数组的深拷贝

```js
/**
 * 数组的深拷贝函数
 * @param {Array} src
 * @param {Array} target
 */
function cloneArr(src, target) {
  for (let item of src) {
    if (Array.isArray(item)) {
      target.push(cloneArr(item, []));
    } else if (typeof item === 'object') {
      target.push(deepClone(item, {}));
    } else {
      target.push(item);
    }
  }
  return target;
}

/**
 * 对象的深拷贝实现
 * @param {Object} src
 * @param {Object} target
 * @return {Object}
 */
function deepClone(src, target) {
  const keys = Reflect.ownKeys(src);
  let value = null;

  for (let key of keys) {
    value = src[key];

    if (Array.isArray(value)) {
      target[key] = cloneArr(value, []);
    } else if (typeof value === 'object') {
      // 如果是对象而且不是数组, 那么递归调用深拷贝
      target[key] = deepClone(value, {});
    } else {
      target[key] = value;
    }
  }

  return target;
}
```

这段代码是不是比网上看到的多了很多？因为考虑很周全，请看下面的测试用例：

```js
// 这个对象a是一个囊括以上所有情况的对象
let a = {
  age: 1,
  jobs: {
    first: 'FE',
  },
  schools: [
    {
      name: 'shenda',
    },
    {
      name: 'shiyan',
    },
  ],
  arr: [
    [
      {
        value: '1',
      },
    ],
    [
      {
        value: '2',
      },
    ],
  ],
};

let b = {};
deepClone(a, b);

a.jobs.first = 'native';
a.schools[0].name = 'SZU';
a.arr[0][0].value = '100';

console.log(a.jobs.first, b.jobs.first); // output: native FE
console.log(a.schools[0], b.schools[0]); // output: { name: 'SZU' } { name: 'shenda' }
console.log(a.arr[0][0].value, b.arr[0][0].value); // output: 100 1
console.log(Array.isArray(a.arr[0])); // output: true
```

看到测试用例，应该会有人奇怪为什么最后要输出`Array.isArray(a.arr[0])`。这主要是因为网上很多实现方法没有针对 array 做处理，直接将其当成 object，**这样拷贝后虽然值没问题，但是 array 的元素会被转化为 object**。这显然是错误的做法。

而上面所说的深拷贝函数就解决了这个问题。

### 基于 ES5/ES6 实现“双向绑定”

要想实现，就要先看看什么是“双向数据绑定”，它和“单向数据绑定”有什么区别？这样才能知道要实现什么效果嘛。

**双向绑定**：视图（View）的变化能实时让数据模型（Model）发生变化，而数据的变化也能实时更新到视图层。

**单向数据绑定**：只有从数据到视图这一方向的关系。

#### ES5 的 Object.defineProperty

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script>
      const obj = {
        value: '',
      };

      function onKeyUp(event) {
        obj.value = event.target.value;
      }

      // 对 obj.value 进行拦截
      Object.defineProperty(obj, 'value', {
        get: function() {
          return value;
        },
        set: function(newValue) {
          value = newValue;
          document.querySelector('#value').innerHTML = newValue; // 更新视图层
          document.querySelector('input').value = newValue; // 数据模型改变
        },
      });
    </script>
  </head>
  <body>
    <p>值是：<span id="value"></span></p>
    <input type="text" onkeyup="onKeyUp(event)" />
  </body>
</html>
```

#### ES6 的 Proxy

随着，vue3.0 放弃支持了 IE 浏览器。而且`Proxy`兼容性越来越好，能支持 13 种劫持操作。

因此，vue3.0 选择使用`Proxy`来实现双向数据绑定，而不再使用`Object.defineProperty`。

```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script>
    const obj = {}

    const newObj = new Proxy(obj, {
      get: function(target, key, receiver) {
        return Reflect.get(target, key, receiver)
      },
      set: function(target, key, value, receiver) {
        if(key === 'value') {
          document.querySelector('#value').innerHTML = value
          document.querySelector('input').value = value
        }
        return Reflect.set(target, key, value, receiver)
      }
    })

    function onKeyUp(event) {
      newObj.value = event.target.value
    }

  </script>
</head>
<body>
  <p>
    值是：<span id="value"></span>
  </p>
  <input type="text" onkeyup="onKeyUp(event)">
</body>
</html>
```

### instanceof 原理与实现

`instanceof`是通过原型链来进行判断的，所以只要不断地通过访问`__proto__`，就可以拿到构造函数的原型`prototype`。直到`null`停止。

```js
/**
 * 判断left是不是right类型的对象
 * @param {*} left
 * @param {*} right
 * @return {Boolean}
 */
function instanceof2(left, right) {
  let prototype = right.prototype;

  // 沿着left的原型链, 看看是否有何prototype相等的节点
  left = left.__proto__;
  while (1) {
    if (left === null || left === undefined) {
      return false;
    }
    if (left === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}

/**
 * 测试代码
 */

console.log(instanceof2([], Array)); // output: true

function Test() {}
let test = new Test();
console.log(instanceof2(test, Test)); // output: true
```

### 实现支持绑定、解绑和派发的事件类

**实现思路**：这里涉及了“订阅/发布模式”的相关知识。参考`addEventListener(type, func)`和`removeEventListener(type, func)`的具体效果来实现即可。

```js
// 数组置空：
// arr = []; arr.length = 0; arr.splice(0, arr.length)
class Event {
  constructor() {
    this._cache = {};
  }

  // 注册事件：如果不存在此种type，创建相关数组
  on(type, callback) {
    this._cache[type] = this._cache[type] || [];
    let fns = this._cache[type];
    if (fns.indexOf(callback) === -1) {
      fns.push(callback);
    }
    return this;
  }

  // 触发事件：对于一个type中的所有事件函数，均进行触发
  trigger(type, ...data) {
    let fns = this._cache[type];
    if (Array.isArray(fns)) {
      fns.forEach(fn => {
        fn(...data);
      });
    }
    return this;
  }

  // 删除事件：删除事件类型对应的array
  off(type, callback) {
    let fns = this._cache[type];
    // 检查是否存在type的事件绑定
    if (Array.isArray(fns)) {
      if (callback) {
        // 卸载指定的回调函数
        let index = fns.indexOf(callback);
        if (index !== -1) {
          fns.splice(index, 1);
        }
      } else {
        // 全部清空
        fns = [];
      }
    }
    return this;
  }
}

// 以下是测试函数

const event = new Event();
event
  .on('test', a => {
    console.log(a);
  })
  .trigger('test', 'hello');
```

### 合集

**手写事件侦听器，并要求兼容浏览器**

```js
var eventUtil = {
  getEvent: function(event) {
    return event || window.event;
  },

  getTarget: function(event) {
    return event.target || event.srcElement;
  },

  addListener: function(element, type, hander) {
    if (element.addEventListener) {
      element.addEventListener(type, hander, false);
    } else if (element.attachEvent) {
      element.attachEvent('on' + type, hander);
    } else {
      element['on' + type] = hander;
    }
  },

  removeListener: function(element, type, hander) {
    if (element.removeEventListener) {
      element.removeEventListener(type, hander, false);
    } else if (element.deattachEvent) {
      element.detachEvent(type, hander);
    } else {
      element['on' + type] = null;
    }
  },

  preventDefault: function(event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  },

  stopPropagation: function(event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  },
};

// 调用
(function() {
  var btn = document.getElementById('btn');
  var link = document.getElementsByTagName('a')[0];

  eventUtil.addListener(btn, 'click', function(event) {
    var event = eventUtil.getEvent(event);
    var target = eventUtil.getTarget(event);
    alert(event.type);
    alert(target);
    eventUtil.stopPropagation(event);
  });

  eventUtil.addListener(link, 'click', function(event) {
    alert('prevent default event');
    var event = eventUtil.getEvent(event);
    eventUtil.preventDefault(event);
  });

  eventUtil.addListener(document.body, 'click', function() {
    alert('click body');
  });
})();
```

**手写事件模型**

```js
var Event = (function() {
  var list = {},
    bind,
    trigger,
    remove;
  bind = function(key, fn) {
    if (!list[key]) {
      list[key] = [];
    }
    list[key].push(fn);
  };
  trigger = function() {
    var key = Array.prototype.shift.call(arguments);
    var fns = list[key];
    if (!fns || fns.length === 0) {
      return false;
    }
    for (var i = 0, fn; (fn = fns[i++]); ) {
      fn.apply(this, arguments);
    }
  };
  remove = function(key, fn) {
    var fns = list[key];
    if (!fns) {
      return false;
    }
    if (!fn) {
      fns & (fns.length = 0);
    } else {
      for (var i = fns.length - 1; i >= 0; i--) {
        var _fn = fns[i];
        if (_fn === fn) {
          fns.splice(i, 1);
        }
      }
    }
  };
  return {
    bind: bind,
    trigger: trigger,
    remove: remove,
  };
})();

// 调用
Event.bind('Hit', function() {
  console.log('bind event');
}); // 绑定事件
Event.trigger('Hit', function() {
  console.log('trigger event');
}); // 触发事件
```

**手写事件代理，并要求兼容浏览器**

```js
function delegateEvent(parentEl, selector, type, fn) {
  var handler = function(e) {
    var e = e || window.event;
    var target = e.target || e.srcElement;
    if (matchSelector(target, selector)) {
      if (fn) {
        fn.call(target, e);
      }
    }
  };
  if (parentEl.addEventListener) {
    parentEl.addEventListener(type, handler);
  } else {
    parentEl.attachEvent('on' + type, handler);
  }
}
/**
 * support #id, tagName, .className
 */
function matchSelector(ele, selector) {
  // if use id
  if (selector.charAt(0) === '#') {
    return ele.id === selector.slice(1);
  }
  // if use class
  if (selector.charAt(0) === '.') {
    return (' ' + ele.className + ' ').indexOf(' ' + selector.slice(1) + ' ') != -1;
  }
  // if use tagName
  return ele.tagName.toLowerCase() === selector.toLowerCase();
}

// 调用
var box = document.getElementById('box');
delegateEvent(box, 'a', 'click', function() {
  console.log(this.href);
});
```

**手写事件触发器，并要求兼容浏览器**

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return element.dispatchEvent(mockEvent);
  }
};
```

**手写 Function.bind 函数**

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      throw new TypeError("'this' is not function");
    }

    // bind's default arguments, array without first element
    // first part arguments for the function
    var aBindArgs = Array.prototype.slice.call(arguments, 1);
    var fToBind = this; // the function will be binding
    var fNOP = function() {};
    var fBound = function() {
      // target this will be binding
      var oThis = this instanceof fNOP ? this : oThis || this;
      // last part arguments for the function
      var aCallArgs = Array.prototype.slice.call(arguments);
      // complete arguments for the function
      var aFuncArgs = aBindArgs.concat(aCallArgs);
      return fToBind.apply(oThis, aFuncArgs);
    };

    // fBound extends fToBind
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

// 调用
var add = function(a, b, c) {
  return a + b + c;
};
var newAdd = add.bind(null, 1, 2);
var result = newAdd(3);
```

**手写数组快速排序**

```js
var quickSort = function(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0];
  var left = [];
  var right = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
};

// 调用
quickSort([9, 4, 2, 8, 1, 5, 3, 7]);
```

**手写数组冒泡排序**

```js
var bubble = function(arr) {
  var maxIndex = arr.length - 1,
    temp,
    flag;
  for (var i = maxIndex; i > 0; i--) {
    flag = true;
    for (var j = 0; j < i; j++) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        flag = false;
      }
    }
    if (!flag) {
      break;
    }
  }
  return arr;
};
// 调用
var arr = bubble([13, 69, 28, 93, 55, 75, 34]);
```

**将 url 的查询参数解析成字典对象**

```js
function parseQuery(url) {
  url = url == null ? window.location.href : url;
  var search = url.substring(url.lastIndexOf('?') + 1);
  var hash = {};
  var reg = /([^?&=]+)=([^?&=]*)/g;
  search.replace(reg, function(match, $1, $2) {
    var name = decodeURIComponent($1);
    var val = decodeURIComponent($2);
    hash[name] = String(val);
    return match;
  });
  return hash;
}
```

**用 JS 实现千位分隔符**

```js
function test1(num) {
  var str = +num + '';
  var len = str.length;
  if (len <= 3) return str;
  num = '';
  while (len > 3) {
    len -= 3;
    num = ',' + str.substr(len, 3) + num;
  }
  return str.substr(0, len) + num;
}

function test2(num) {
  // ?= 正向匹配:匹配位置
  // ?! 正向不匹配:排除位置
  var str = (+num).toString();
  var reg = /(?=(?!\b)(\d{3})+$)/g;
  return str.replace(reg, ',');
}
```
