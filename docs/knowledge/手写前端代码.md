---
title: 手写前端代码
date: 2020-12-16
draft: true
---

## 数组去重（对象、非对象）

1. set 去重

```js
[...new Set(arr)];
```

2. 利用 indexOf 去重

```js
const newArr = arr.filter((item, index, arr) => index === arr.indexOf(item));
```

```js
let newArrB = [];
arr.forEach(item => (newArrB.indexOf(item) === -1 ? newArrB.push(item) : ''));
```

3. 利用对象去重

```js
let objA = {};
const newArrA = arr.filter((item, index, arr) => (objA.hasOwnProperty(item) ? false : (objA[item] = true)));
```

4. 双重循环去重

```js
function removeDuplicatedItem(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1); //console.log(arr[j]);
        j--;
      }
    }
  }
  return arr;
}
```

5. 利用 sort()加前后比较去重

```js
const newArrC = arr.sort().filter((item, index, arr) => item !== arr[index + 1]);
```

## url 解析

### 解析一个参数

```js
function getQueryString(name) {
  const reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
  const r = window.location.search.slice(1).match(reg);
  if (r != null) {
    return r[2];
  }
  return null;
}
```

### url 所有参数转化为一个对象

```js
var parseQueryString = function(search) {
  if (!search) return {};
  const regExp = /([^&=]+)=([\w\W]*?)(&|$)/g;
  const ret = {};
  search = search[0] === '?' ? search.slice(1) : search;
  while ((result = regExp.exec(search)) != null) {
    ret[result[1]] = result[2];
  }
  return ret;
};
```

## 大数相加

```js
function add(a, b) {
  //取两个数字的最大长度
  let maxLength = Math.max(a.length, b.length);
  //用 0 去补齐长度
  a = a.padStart(maxLength, 0); //"0009007199254740991"
  b = b.padStart(maxLength, 0); //"1234567899999999999"
  // 定义加法过程中需要用到的变量
  let t = 0;
  let f = 0; // 进位
  let sum = '';
  for (let i = maxLength - 1; i >= 0; i--) {
    t = parseInt(a[i]) + parseInt(b[i]) + f;
    // 向上取整
    f = Math.floor(t / 10);
    sum = (t % 10) + sum;
  }
  if (f == 1) {
    sum = '1' + sum;
  }
  return sum;
}
```

## 深拷贝

```js
function assignDeep(target, ...sources) {
  for (let source of sources) {
    for (let key in source) {
      if (isObject(source[key])) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        assignDeep(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}

function isObject(a) {
  return typeof a === 'object' && a !== null;
}
```

## 防抖、节流

```js
function debounce(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

```js
function throttle(fn, delay) {
  delay = delay || 500;
  let timer;
  return function() {
    let args = arguments;
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        fn.apply(this, args);
      }, delay);
    }
  };
}
```

## Event Class

```js
const Noop = () => {};

class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, handler = Noop) {
    const { events } = this;
    if (!events[event]) {
      events[event] = [handler];
    } else {
      events[event].push(handler);
    }
  }

  once(event, handler = Noop) {
    const once = `once_${event}`;
    if (typeof this.events[once] === 'undefined') {
      this.events[once] = [handler];
    } else {
      this.events[once].push(handler);
    }
  }

  emit(event, args) {
    const once = `once_${event}`;
    if (typeof this.events[once] !== 'undefined') {
      this.events[once].forEach(handler => {
        handler(args);
      });
      delete this.events[`once_${event}`];
    }
    if (typeof this.events[event] !== 'undefined') {
      this.events[event].forEach(handler => {
        handler(args);
      });
    }
  }

  off(event, handler) {
    if (typeof this.events[event] !== 'undefined') {
      if (!!handler) {
        const index = this.events[event].indexOf(handler);
        this.events[event].splice(index, 1);
      } else {
        delete this.events[event];
      }
    }
  }
}

function test() {
  const eh = new EventEmitter();

  const firstHd = str => {
    console.log('first greet: ', str);
  };

  eh.on('greet', firstHd);

  eh.on('greet', str => {
    console.log('second greet: ', str);
  });

  eh.on('bye', name => {
    console.log(name + ', goodbye!');
  });

  eh.once('break', str => {
    console.log(`once break: ${str}`);
  });
  eh.on('break', str => {
    console.log(`on break: ${str}`);
  });

  console.log('======  start  ======');
  eh.emit('greet', 'Green');
  eh.emit('bye', 'Mark');
  eh.emit('break', 'Jack');
  eh.emit('break', 'Tony');

  console.log('======  removeListener  ======');
  eh.off('bye');
  eh.emit('bye', 'Mark');

  eh.off('greet', firstHd);
  eh.emit('greet', 'Green');
}

test();
```

## 实现一个 Event 类

继承自此类的对象都会拥有两个方法 on,off,once 和 trigger

```js
function Event() {
  if (!(this instanceof Event)) {
    return new Event();
  }
  this._callbacks = {};
}
Event.prototype.on = function(type, handler) {
  this_callbacks = this._callbacks || {};
  this._callbacks[type] = this.callbacks[type] || [];
  this._callbacks[type].push(handler);

  return this;
};

Event.prototype.off = function(type, handler) {
  var list = this._callbacks[type];

  if (list) {
    for (var i = list.length; i >= 0; --i) {
      if (list[i] === handler) {
        list.splice(i, 1);
      }
    }
  }

  return this;
};

Event.prototype.trigger = function(type, data) {
  var list = this._callbacks[type];

  if (list) {
    for (var i = 0, len = list.length; i < len; ++i) {
      list[i].call(this, data);
    }
  }
};

Event.prototype.once = function(type, handler) {
  var self = this;

  function wrapper() {
    handler.apply(self, arguments);
    self.off(type, wrapper);
  }
  this.on(type, wrapper);
  return this;
};
```

## 实现 vue 中的 on,emit,off,once，手写代码

```js
// 参照 vue 源码实现
var EventEmitter = function() {
  this._events = {};
};
EventEmitter.prototype.on = function(event, cb) {
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.on(event[i], cb);
    }
  } else {
    (this._events[event] || (this._events[event] = [])).push(cb);
  }
  return this;
};
EventEmitter.prototype.once = function(event, cb) {
  function on() {
    this.off(event, cb);
    cb.apply(this, arguments);
  }
  on.fn = cb;
  this.on(event, on);
  return this;
};
EventEmitter.prototype.off = function(event, cb) {
  if (!arguments.length) {
    this._events = Object.create(null);
    return this;
  }
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.off(event[i], cb);
    }
    return this;
  }
  if (!cb) {
    this._events[event] = null;
    return this;
  }
  if (cb) {
    let cbs = this._events[event];
    let i = cbs.length;
    while (i--) {
      if (cb === cbs[i] || cb === cbs[i].fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return this;
  }
};
EventEmitter.prototype.emit = function(event) {
  let cbs = this._events[event];
  let args = Array.prototype.slice.call(arguments, 1);
  if (cbs) {
    for (let i = 0, l = cbs.length; i < l; i++) {
      cbs[i].apply(this, args);
    }
  }
};
```

## 事件触发器

兼容所有浏览器

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return element.dispatchEvent(mockEvent);
  }
};
```

## 千分位

```js
function test1(num) {
  var str = +num + '';
  var len = str.length;
  if (len <= 3) return str;
  num = '';
  while (len > 3) {
    len -= 3;
    num = ',' + str.substr(len, 3) + num;
  }
  return str.substr(0, len) + num;
}

function test2(num) {
  // ?= 正向匹配:匹配位置
  // ?! 正向不匹配:排除位置
  var str = (+num).toString();
  var reg = /(?=(?!\b)(\d{3})+$)/g;
  return str.replace(reg, ',');
}
```

### 千分位

如 12000000.11 转化为 12,000,000.11

```js
function commafy(num) {
  return (
    num &&
    num.toString().replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2) {
      return $2 + ',';
    })
  );
}
```

### 实现千分位标注位

考虑小数、负数和整数三种情况。

`sep`参数是自定义的分隔符，默认是`,`

```js
/**
 * 实现千分位标注位
 * @param {*} str 待标注的字符串
 * @param {*} sep 标注符号
 */
const addSeparator = (str = '', sep = ',') => {
  str += '';
  const arr = str.split('.'),
    re = /(\d+)(\d{3})/;

  let integer = arr[0],
    decimal = arr.length <= 1 ? '' : `.${arr[1]}`;

  while (re.test(integer)) {
    integer = integer.replace(re, '$1' + sep + '$2');
  }

  return integer + decimal;
};

console.log(addSeparator(-10000.23)); // -10,000.23
console.log(addSeparator(100)); // 100
console.log(addSeparator(1234, ';')); // 1;234
```

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

### 格式化金钱，每千分位加逗号

```js
function format(str) {
  let s = '';
  let count = 0;
  for (let i = str.length - 1; i >= 0; i--) {
    s = str[i] + s;
    count++;
    if (count % 3 == 0 && i != 0) {
      s = ',' + s;
    }
  }
  return s;
}
function format(str) {
  return str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');
}
```

## 手写 promise
