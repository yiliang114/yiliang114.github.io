---
layout: CustomPages
title: LeetCode 题解
date: 2020-11-21
aside: false
draft: true
---

## 1. 找出两个链表的交点 intersection-of-two-linked-lists

[160. Intersection of Two Linked Lists (Easy)](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

找到两个单链表相交的起始节点。

注意：

1. 如果两个链表没有交点，返回 null.
2. 在返回结果后，两个链表仍须保持原有的结构。
3. 可假定整个链表结构中没有循环。
4. 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

#### 思路

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。

如果只是判断是否存在交点，那么就是另一个问题，即 [编程之美 3.6]() 的问题。有两种解法：

- 把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；
- 或者直接比较两个链表的最后一个节点是否相同。

#### Code

```js
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  if (headA === null || headB === null) return null;
  let lenA = 0;
  let lenB = 0;

  let curA = headA;
  let curB = headB;

  while (curA) {
    curA = curA.next;
    lenA += 1;
  }
  while (curB) {
    curB = curB.next;
    lenB += 1;
  }

  const gap = Math.abs(lenA - lenB);
  let cur = 0;
  curA = headA;
  curB = headB;

  // 先直接向前移动差距的格数
  if (lenA > lenB) {
    while (cur < gap) {
      cur++;
      curA = curA.next;
    }
  } else {
    while (cur < gap) {
      cur++;
      curB = curB.next;
    }
  }

  while (curA !== curB) {
    curA = curA.next;
    curB = curB.next;
  }

  return curA;
};
```

## 2. 链表反转 reverse-linked-list

[206. Reverse Linked List (Easy)](https://leetcode-cn.com/problems/reverse-linked-list/description/)

Example:

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL

[图解](https://pic.leetcode-cn.com/1610611577-YLqsOS-01.001.01.png)

```js
// 递归
var reverseList = function(head) {
  let reverse = (prev, curr) => {
    if (!curr) {
      return prev;
    }
    let next = curr.next;
    curr.next = prev;
    return reverse(curr, next);
  };
  return reverse(null, head);
};
```

```js
// 迭代
var reverseList = function(head) {
  let prev = null;
  let curr = head;
  while (curr != null) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
};
```

## 3. 归并两个有序的链表

[21. Merge Two Sorted Lists (Easy)](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/)

### [21].合并两个有序链表 merge-two-sorted-lists

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

## 4. 从有序链表中删除重复节点

[83. Remove Duplicates from Sorted List (Easy)](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

## 5. 删除链表的倒数第 n 个节点

[19. Remove Nth Node From End of List (Medium)](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/)

## 6. 交换链表中的相邻结点

[24. Swap Nodes in Pairs (Medium)](https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/)

## 7. 链表求和

[445. Add Two Numbers II (Medium)](https://leetcode-cn.com/problems/add-two-numbers-ii/description/)

## 8. 回文链表

[234. Palindrome Linked List (Easy)](https://leetcode-cn.com/problems/palindrome-linked-list/description/)

题目要求：以 O(1) 的空间复杂度来求解。

切成两半，把后半段反转，然后比较两半是否相等。

```java
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) return true;
    ListNode slow = head, fast = head.next;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    if (fast != null) slow = slow.next;  // 偶数节点，让 slow 指向下一个节点
    cut(head, slow);                     // 切成两个链表
    return isEqual(head, reverse(slow));
}

private void cut(ListNode head, ListNode cutNode) {
    while (head.next != cutNode) {
        head = head.next;
    }
    head.next = null;
}

private ListNode reverse(ListNode head) {
    ListNode newHead = null;
    while (head != null) {
        ListNode nextNode = head.next;
        head.next = newHead;
        newHead = head;
        head = nextNode;
    }
    return newHead;
}

private boolean isEqual(ListNode l1, ListNode l2) {
    while (l1 != null && l2 != null) {
        if (l1.val != l2.val) return false;
        l1 = l1.next;
        l2 = l2.next;
    }
    return true;
}
```

## 9. 分隔链表

[725. Split Linked List in Parts(Medium)](https://leetcode-cn.com/problems/split-linked-list-in-parts/description/)

```html
Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] Explanation: The
input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the
later parts.
```

题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。

```java
public ListNode[] splitListToParts(ListNode root, int k) {
    int N = 0;
    ListNode cur = root;
    while (cur != null) {
        N++;
        cur = cur.next;
    }
    int mod = N % k;
    int size = N / k;
    ListNode[] ret = new ListNode[k];
    cur = root;
    for (int i = 0; cur != null && i < k; i++) {
        ret[i] = cur;
        int curSize = size + (mod-- > 0 ? 1 : 0);
        for (int j = 0; j < curSize - 1; j++) {
            cur = cur.next;
        }
        ListNode next = cur.next;
        cur.next = null;
        cur = next;
    }
    return ret;
}
```

## 10. 链表元素按奇偶聚集

[328. Odd Even Linked List (Medium)](https://leetcode-cn.com/problems/odd-even-linked-list/description/)

```html
Example: Given 1->2->3->4->5->NULL, return 1->3->5->2->4->NULL.
```

```java
public ListNode oddEvenList(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode odd = head, even = head.next, evenHead = even;
    while (even != null && even.next != null) {
        odd.next = odd.next.next;
        odd = odd.next;
        even.next = even.next.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
}
```
