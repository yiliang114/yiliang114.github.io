---
title: LeetCode-合集 0-100
date: 2020-09-04
aside: false
draft: true
---

### [1].两数之和 twoSum

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

```js
// 80 ms	39.8 MB
var twoSum = function(nums = [], target) {
  const map = {};
  for (let i = 0; i < nums.length; i++) {
    if (map[target - nums[i]] !== undefined) {
      return [map[target - nums[i]], i];
    }
    map[nums[i]] = i;
  }
};
```

```js
// 76 ms	39.8 MB
var twoSum = function(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i];
    }
    map.set(nums[i], i);
  }
};
```

事实证明，{} 与 Map 的存取速度差不多

### [2].两数相加 addTwoNumbers

给出两个非空的`链表`用来表示两个非负的整数。其中，它们各自的位数是按照**逆序**的方式存储的，并且它们的每个节点只能存储一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

#### 思路

设立一个表示进位的变量 carried，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上 carried 后的值作为一个新节点到新链表后面。

本题链表是逆序的，而 [445].两数相加 II 给的两个链表是顺序的。

#### 代码

```js
var addTwoNumbers = function(l1, l2) {
  // 新创建一个头结点
  const head = new ListNode(0);
  let cur = head;
  // 进位
  let curry = 0;

  while (l1 || l2) {
    const sum = curry + ((l1 && l1.val) || 0) + ((l2 && l2.val) || 0);
    curry = parseInt(sum / 10);

    cur.next = new ListNode(sum % 10);
    // 往后移动
    cur = cur.next;
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }
  // 最后需要创建的一位
  if (curry != 0) {
    cur.next = new ListNode(curry);
  }
  // 第一位初始 0 不能算
  return head.next;
};
```

### [3].无重复字符的最长子串

#### 思路

1. 用一个 hashmap 记录出现过并且没有被删除的字符
2. 用一个滑动窗口记录当前 index 开始的最大的不重复的字符序列
3. 重复 1,2 ，直到左边索引无法再移动；
4. 用 res 去记录目前位置最大的长度，每次滑动窗口更新就去决定是否需要更新 res

```js
var lengthOfLongestSubstring = function(s) {
  const hashmap = {}; // 记录已经出现过的 charactor
  let res = 0;
  let slidingWindow = [];

  for (let c of s) {
    if (hashmap[c]) {
      // 已经出现过了, 则删除
      const delIndex = slidingWindow.findIndex(_c => _c === c);

      for (let i = 0; i < delIndex; i++) {
        hashmap[slidingWindow[i]] = false;
      }

      slidingWindow = slidingWindow.slice(delIndex + 1).concat(c);
    } else {
      // 新字符.
      // push 函数执行之后返回数组的长度
      if (slidingWindow.push(c) > res) {
        // 记录滑动窗口的长度
        res = slidingWindow.length;
      }
    }
    // 新字符在 map 中进行标注
    hashmap[c] = true;
  }
  return res;
};
```

```js
var lengthOfLongestSubstring = function(s) {
  let start = 0,
    longestLength = 0;
  // map 是记录字符串的位置的，不是标记是否出现过
  const map = {};
  for (let i = 0; i < s.length; i++) {
    const val = s[i];
    // = 的情况是用于连续两个相同的字符串
    if (val in map && map[val] >= start) {
      start = i + 1;
      map[val] = i;
    } else {
      map[val] = i;
      longestLength = Math.max(longestLength, i + 1 - start);
    }
  }
  return longestLength;
};
```

```js
var lengthOfLongestSubstring = function(s) {
  let res = '';
  let l = 0;
  for (let i = 0; i < s.length; i++) {
    if (res.includes(s[i])) {
      res = res.slice(res.indexOf(s[i]) + 1);
    }
    res += s[i];
    l = Math.max(res.length, l);
  }
  return l;
};
```

### [4].寻找两个有序数组的中位数 median-of-two-sorted-arrays

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)) 。
你可以假设 nums1 和 nums2 不会同时为空。

示例 1:
nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0

示例 2:
nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3) / 2 = 2.5

#### 实现思路

先排除空数组的情况
数组从小到大排序
取小数组的中间值
取大数组的索引 = 总中间值-小数组中间值
循环直到符合条件
如果都不符合条件，那么说明中间值在两个数组的左边或者右边

由于要求中位数，即 k = (m+n) / 2，k1 = k / 2，k2 = k / 2，每次都能将一半的数排除，即问题的规模减小一半，因此，算法复杂度就类似二分搜索，复杂度就是 log(k)，即  O(log((m+n) / 2))。

#### Code

```js
//  ??? 二分查找
//  24% 16%
var findMedianSortedArrays = function(nums1, nums2) {
  // 合并数组
  let nums = [...nums1, ...nums2];

  // 排序(有时间复杂度要求，那应该是要快排或者归并排序了)
  nums = nums.sort((a, b) => a - b);

  // 计算中位数
  const length = nums.length;
  return length % 2 === 0 ? (nums[length / 2] + nums[length / 2 - 1]) / 2 : nums[parseInt(length / 2)];
};
```

```js
// 竟然可以用这种方式。。。
function findKth(nums1, nums2, k) {
  if (nums1.length === 0) return nums2[k - 1];
  if (nums2.length === 0) return nums1[k - 1];
  if (k == 1) return Math.min(nums1[0], nums2[0]);
  let i = Math.min(k >> 1, nums1.length);
  let j = Math.min(k >> 1, nums2.length);
  if (nums1[i - 1] > nums2[j - 1]) {
    return findKth(nums1, nums2.slice(j), k - j);
  }

  return findKth(nums1.slice(i), nums2, k - i);
}

var findMedianSortedArrays = function(nums1, nums2) {
  // 1
  // 2 3 4 5
  const m = nums1.length,
    n = nums2.length;
  return (findKth(nums1, nums2, (m + n + 1) >> 1) + findKth(nums1, nums2, (m + n + 2) >> 1)) / 2.0;
};
```

```js
function kth(arr1, s1, n1, arr2, s2, n2, k) {
  if (k < 1 || k > n1 + n2) return -1;

  if (n1 > n2) {
    return kth(arr2, s2, n2, arr1, s1, n1, k);
  }

  if (n1 === 0) {
    return arr2[s2 + k - 1];
  }

  if (k === 1) {
    return arr1[s1] < arr2[s2] ? arr1[s1] : arr2[s2];
  }

  var newK = k >> 1;

  if (n1 < newK) {
    newK = n1;
  }

  if (arr1[s1 + newK - 1] < arr2[s2 + newK - 1]) {
    return kth(arr1, s1 + newK, n1 - newK, arr2, s2, n2, k - newK);
  } else {
    return kth(arr1, s1, n1, arr2, s2 + newK, n2 - newK, k - newK);
  }
}
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  var n1 = nums1.length;
  var n2 = nums2.length;

  var mid = Math.floor((n1 + n2) / 2);
  if ((n1 + n2) % 2 === 0) {
    return (kth(nums1, 0, n1, nums2, 0, n2, mid) + kth(nums1, 0, n1, nums2, 0, n2, mid + 1)) / 2;
  } else {
    return kth(nums1, 0, n1, nums2, 0, n2, mid + 1);
  }
};

console.log(findMedianSortedArrays([1, 3, 4], [2, 5]));
console.log(findMedianSortedArrays([1, 3, 4], [2, 5, 6]));
```

```js
var findMedianSortedArrays = function(nums1, nums2) {
  if (nums1.length == 0 || nums2.length == 0) {
    if ((nums1.length + nums2.length) % 2 == 1) {
      const index = parseInt((nums1.length + nums2.length) / 2);
      return nums2.length == 0 ? nums1[index] : nums2[index];
    } else {
      let nums = nums2.length == 0 ? nums1 : nums2;
      const index = nums.length / 2;
      return (nums[index - 1] + nums[index]) / 2;
    }
  }

  if (nums1.length > nums2.length) {
    swap(nums1, nums2);
  }
  const M = nums1.length,
    N = nums2.length;
  let min = 0,
    max = M,
    half = parseInt((M + N + 1) / 2); // 连个数组合并的中间值
  while (min <= max) {
    let i = parseInt((min + max) / 2); // nums1 的索引值
    let j = half - i; // num2 的索引值
    if (i < max && nums2[j - 1] > nums1[i]) {
      min++;
    } else if (i > min && nums1[i - 1] > nums2[j]) {
      max--;
    } else {
      let maxLeft = 0;
      if (i == 0) {
        maxLeft = nums2[j - 1];
      } else if (j == 0) {
        maxLeft = nums1[i - 1];
      } else {
        maxLeft = Math.max(nums1[i - 1], nums2[j - 1]);
      }
      if ((M + N) % 2 == 1) {
        return maxLeft;
      }
      let minRight = 0;
      if (i == M) {
        minRight = nums2[j];
      } else if (j == N) {
        minRight = nums1[i];
      } else {
        minRight = Math.min(nums1[i], nums2[j]);
      }
      return (maxLeft + minRight) / 2;
    }
  }
  return 0;
};

function swap(a, b) {
  let tmp = a;
  a = b;
  b = tmp;
}

const nums1 = [4, 5];
const nums2 = [1, 2, 3];
findMedianSortedArrays(nums1, nums2);
```

### [5].最长回文子串 longest-palindromic-substring

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"

#### 思路

解决这类问题的核心思想就是两个字 “延伸”（extend），具体来说

- 如果一个字符串是回文串，那么在它左右分别加上一个相同的字符，那么它一定还是一个回文串
- 如果一个字符串不是回文串，或者在回文串左右分别加不同的字符，得到的一定不是回文串

事实上，上面的分析已经建立了大问题和小问题之间的关联，
基于此，我们可以建立动态规划模型。

我们可以用 `dp[i][j]` 表示 s 中从 i 到 j(包括 i 和 j)是否可以形成回文，状态转移方程只是将上面的描述转化为代码即可：

```js
// 左右分别加 1
if (s[i] === s[j] && dp[i + 1][j - 1]) {
  dp[i][j] = true;
}
```

base case 就是一个字符(轴对称点是本身)，或者两个字符(轴对称点是介于两者之间的虚拟点)。

#### 代码

```js
// done
var longestPalindrome = function(s) {
  if (!s || s.length === 0) return '';
  let res = s[0];
  const dp = [];

  // 倒着遍历简化操作， 这么做的原因是 dp[i][..] 依赖于 dp[i + 1][..]
  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = [];
    for (let j = i; j < s.length; j++) {
      // 同一位字符串 必然 true
      if (j - i === 0) dp[i][j] = true;
      // special case 1: 相邻两位字符串相同，或者 ABA 形式的字符串都是回文串
      else if (j - i < 3 && s[i] === s[j]) dp[i][j] = true;
      // special case 2
      else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        // state transition
        dp[i][j] = true;
      }

      if (dp[i][j] && j - i + 1 > res.length) {
        // update res
        res = s.slice(i, j + 1);
      }
    }
  }
  return res;
};
```

```js
// 滑动窗口思想 ？
var longestPalindrome = function(str) {
  const n = str.length;
  if (n < 2) return str;
  let s = 0,
    e = 0;
  // 表示子串是否是回文串
  let dp = [0];
  for (let j = 0; j < n; ++j) {
    for (let i = 0; i < j; ++i) {
      if (!(dp[i] = dp[i + 1] || str[i] != str[j]) && e - s <= j - i) {
        (s = i)((e = j));
      }
    }
  }
  return str.substr(s, e - s + 1);
};
```

```js
var longestPalindrome = function(s) {
  var len = s.length,
    isPal = [],
    max = 1,
    start = 0,
    end = 0,
    i,
    j;

  for (i = 0; i < len; i++) {
    isPal.push(new Array(len));
    isPal[i][i] = true;
  }

  for (i = len - 1; i >= 0; i--) {
    for (j = i + 1; j < len; j++) {
      if (s.charAt(i) === s.charAt(j) && (j === i + 1 || isPal[i + 1][j - 1])) {
        isPal[i][j] = true;

        if (j - i + 1 > max) {
          start = i;
          end = j;
          max = j - i + 1;
        }
      }
    }
  }

  return s.substring(start, end + 1);
};
```

用 `dp[i][j]` 表示子串 i 到 j 是否是回文，使用动态规划求解：

```js
var longestPalindromeSubstring = function(s) {
  var n = s.length;
  var res = '';
  var dp = [];
  // 默认全赋值 -1
  while (dp.push(new Array(n).fill(-1)) < n);
  console.log(dp);

  // 反过来循环，是因为 dp[i][j] 依赖 dp[i + 1][j]
  for (var i = n - 1; i >= 0; i--) {
    for (var j = i; j < n; j++) {
      // j - i < 3 也就是说只考虑，3 次循环 ??
      dp[i][j] = s[i] === s[j] && (j - i < 3 || dp[i + 1][j - 1]);
      if (dp[i][j] === undefined) {
        console.log(i, j, s[i], s[j], dp[i + 1][j - 1]);
      }
      // 如果是回文，才进行截取
      if (dp[i][j]) {
        var tmp = s.substring(i, j + 1);
        if (tmp.length > res.length) res = tmp;
      }
    }
  }
  return res;
};

console.log('longestPalindromeSubstring', longestPalindromeSubstring('babad'));
console.log('longestPalindromeSubstring', longestPalindromeSubstring(''));
console.log('longestPalindromeSubstring', longestPalindromeSubstring('a'));
console.log('longestPalindromeSubstring', longestPalindromeSubstring('aabbbbbb'));
```

### [10].正则表达式匹配 Regular-Expression-Matching

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  let dp = [];
  for (let i = 0; i <= s.length; i++) {
    let child = [];
    for (let j = 0; j <= p.length; j++) {
      child.push(false);
    }
    dp.push(child);
  }
  dp[s.length][p.length] = true;

  for (let i = s.length; i >= 0; i--) {
    for (let j = p.length - 1; j >= 0; j--) {
      let first_match = i < s.length && (p[j] == s[i] || p[j] == '.');
      if (j + 1 < p.length && p[j + 1] == '*') {
        dp[i][j] = dp[i][j + 2] || (first_match && dp[i + 1][j]);
      } else {
        dp[i][j] = first_match && dp[i + 1][j + 1];
      }
    }
  }
  console.log(dp);
  return dp[0][0];
};

console.log(isMatch('aab', 'c*a*b'));

/**
先设定右下角为 false

[
    true, false, true, false, false, false,
    true, false, true, false, false, false,
    true, false, true, false, true, false,
    false, false, false, false, false, true
]
 */
```

### [11].盛最多水的容器 Container-With-Most-Water

#### 思路

符合直觉的解法是，我们可以对两两进行求解，计算可以承载的水量。 然后不断更新最大值，最后返回最大值即可。
这种解法，需要两层循环，时间复杂度是 O(n^2)

eg:

```js
// 这个解法比较暴力，效率比较低
// 时间复杂度是O(n^2)
let max = 0;
for (let i = 0; i < height.length; i++) {
  for (let j = i + 1; j < height.length; j++) {
    const currentArea = Math.abs(i - j) * Math.min(height[i], height[j]);
    if (currentArea > max) {
      max = currentArea;
    }
  }
}
return max;
```

> 这种符合直觉的解法有点像冒泡排序， 大家可以稍微类比一下

那么有没有更加优的解法呢？我们来换个角度来思考这个问题，上述的解法是通过两两组合，这无疑是完备的，
那我门是否可以先计算长度为 n 的面积，然后计算长度为 n-1 的面积，... 计算长度为 1 的面积。 这样去不断更新最大值呢？
很显然这种解法也是完备的，但是似乎时间复杂度还是 O(n ^ 2), 不要着急。

考虑一下，如果我们计算 n-1 长度的面积的时候,是直接直接排除一半的结果的。

如图：

比如我们计算 n 面积的时候，假如左侧的线段高度比右侧的高度低，那么我们通过左移右指针来将长度缩短为 n-1 的做法是没有意义的，
因为`新的形成的面积变成了(n-1) * heightOfLeft 这个面积一定比刚才的长度为n的面积nn * heightOfLeft 小`

也就是说最大面积`一定是当前的面积或者通过移动短的线段得到`。

#### 关键点解析

- 双指针优化时间复杂度

#### 代码

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  if (!height || height.length <= 1) return 0;

  // 双指针来进行优化
  // 时间复杂度是O(n)
  let leftPos = 0;
  let rightPos = height.length - 1;
  let max = 0;
  while (leftPos < rightPos) {
    const currentArea = Math.abs(leftPos - rightPos) * Math.min(height[leftPos], height[rightPos]);
    if (currentArea > max) {
      max = currentArea;
    }
    // 更新小的
    if (height[leftPos] < height[rightPos]) {
      leftPos++;
    } else {
      // 如果相等就随便了
      rightPos--;
    }
  }

  return max;
};
```

```js
var maxArea = function(height) {
  var len = height.length,
    left = 0,
    right = len - 1,
    max = 0;

  while (left < right) {
    max = Math.max(max, (right - left) * Math.min(height[left], height[right]));

    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return max;
};
```

```js
/**
 * @param {number[]} height
 * @return {number}
 */
export default function maxArea(height) {
  let width = height.length - 1;
  let lo = 0;
  let hi = height.length - 1;
  let max = 0;
  while (lo < hi) {
    const loVal = height[lo];
    const hiVal = height[hi];
    max = Math.max(max, width * Math.min(hiVal, loVal));
    if (loVal < hiVal) {
      lo++;
    } else {
      hi--;
    }
    width--;
  }
  return max;
}
```

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  let maxArea = 0;
  let left = 0,
    right = height.length - 1;
  while (left < right) {
    maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return maxArea;
};

const arr = [3, 4, 6, 2, 8, 4, 3, 1, 3, 4, 4];
console.log(maxArea(arr));
```

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var dp = [0];
  var max = 0;
  for (var i = 1; i < height.length; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      var v = (i - j) * Math.min(height[i], height[j]);
      dp[i] = Math.max(dp[i], v);
    }
    max = Math.max(max, dp[i]);
  }
  // console.log(dp, max);
  return max;
};

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  var i = 0;
  var j = height.length - 1;
  var max = 0;
  while (i < j) {
    max = Math.max(max, Math.min(height[i], height[j]) * (j - i));
    if (height[i] < height[j]) i++;
    else j--;
  }
  return max;
};

console.log(maxArea([3, 5, 1, 9]));
```

### [14].最长公共前缀 Longest-Common-Prefix

```js
var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  if (strs.length === 1) return strs[0];
  const first = strs[0];
  for (let i = 0; i < first.length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[j][i] !== strs[0][i]) return strs[0].slice(0, i);
    }
  }
  return first;
};

console.log(longestCommonPrefix(['flower', 'flow', 'flight']));
console.log(longestCommonPrefix(['dog', 'racecar', 'car']));
console.log(longestCommonPrefix(['c', 'c']));
```

### [15].三数之和 3Sum

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：

```js
[
  [-1, 0, 1],
  [-1, -1, 2],
];
```

#### 思路

我们采用`分治`的思想. 想要找出三个数相加等于 0，我们可以数组依次遍历，每一项 a[i]我们都认为它是最终能够用组成 0 中的一个数字，那么我们的目标就是找到剩下的元素(除 `a[i]`)两个相加等于 `-a[i]`.

- 排序之后，用双指针
- 分治

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  // 先排序
  nums.sort(function(a, b) {
    return a - b;
  });

  let ans = [];
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      const sum = nums[i] + nums[j];
      const bs = binarySearch(nums, -sum, 0, nums.length - 1);
      if (bs != null && bs != i && bs != j) {
        let mArr = [nums[i], nums[j], nums[bs]].sort(function(a, b) {
          return a - b;
        });
        if (!has(ans, mArr)) {
          ans.push(mArr);
        }
      }
    }
  }
  return ans;
};

// 在数组中从 left 开始 right 结束，找到某个值
function binarySearch(arr, val, left, right) {
  if (left > right) return null;
  let mid = left + parseInt((right - left) / 2);
  if (val < arr[mid]) {
    return binarySearch(arr, val, left, mid - 1);
  } else if (val > arr[mid]) {
    return binarySearch(arr, val, mid + 1, right);
  } else {
    return mid;
  }
}

// 判断结果数组是否一致
function has(arr, target) {
  for (let cur of arr) {
    let isEqual = true;
    for (let i = 0; i < target.length; i++) {
      if (cur[i] != target[i]) {
        isEqual = false;
      }
    }
    if (isEqual) return true;
  }
  return false;
}
```

### [17].电话号码的字母组合

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

```js
// 执行用时 98.90% 内存消耗 44.83%

function gen(digits = [], result = [], map) {
  if (!digits) return [];
  if (digits.length === 1) return map[digits];
  const [first, ...rest] = digits;
  result = gen(rest, result, map);
  return map[first]
    .map(digit => {
      return result.map(dig => `${digit}${dig}`);
    })
    .flat(Infinity);
}

// 执行用时 87.% 内存消耗 80%
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  const map = {
    '2': ['a', 'b', 'c'],
    '3': ['d', 'e', 'f'],
    '4': ['g', 'h', 'i'],
    '5': ['j', 'k', 'l'],
    '6': ['m', 'n', 'o'],
    '7': ['p', 'q', 'r', 's'],
    '8': ['t', 'u', 'v'],
    '9': ['w', 'x', 'y', 'z'],
  };
  return gen(digits, [], map);
};

console.log(letterCombinations('23'));
console.log(letterCombinations('234'));
```

### [19].删除链表的倒数第 n 个节点 Remove-Nth-Node-From-End-of-List

```html
Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes
1->2->3->5.
```

#### 思路

双指针，指针 A 先移动 n 次， 指针 B 再开始移动。当 A 到达 null 的时候， 指针 b 的位置正好是倒数 n

#### 代码

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let dummy = new ListNode(0);
  dummy.next = head;
  let fast = dummy;
  let slow = dummy;

  for (let i = 1; i <= n + 1; i++) {
    fast = fast.next;
  }
  while (fast != null) {
    fast = fast.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return dummy.next;
};
```

### [20].有效的括号 validParentheses

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true

#### 思路

使用栈, 遍历输入字符串, 如果当前字符为左半边括号时，则将其压入栈中, 如果遇到右半边括号时，分类讨论：

1. 如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环
2. 若此时栈为空，则直接返回 false
3. 若不为对应的左半边括号，反之返回 false

#### 代码

```js
var isValid = function(s) {
  let valid = true;
  const stack = [];
  const hashmap = {
    '{': '}',
    '[': ']',
    '(': ')',
  };

  for (let i in s) {
    const v = s[i];
    if (['(', '[', '{'].indexOf(v) > -1) {
      stack.push(v);
    } else {
      const peak = stack.pop();
      if (v !== hashmap[peak]) {
        return false;
      }
    }
  }

  if (stack.length > 0) return false;

  return valid;
};
```

```js
// 最高赞
var isValid = function(s) {
  var st = [];
  for (var l of s)
    if ((i = '({[]})'.indexOf(l)) > -1)
      if (st[st.length - 1] + i === 5)
        // 相加为 5 则意味着匹配上了。 另 length-- 操作直接删除了顶部元素
        st.length--;
      else st.push(i);
  return st.length === 0;
};
```

```js
console.log(isValid('()[]{}'));
console.log(isValid('[()][]{}'));
console.log(isValid('(])'));
```

### [21].合并两个有序链表 merge-two-sorted-lists

```js
/**
 * 递归形式。 很好理解，但是性能不算特别好
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

```js
// 性能会比递归形式好一些
var mergeTwoLists = function(l1, l2) {
  let current = new ListNode();
  const dummy = current;

  while (l1 || l2) {
    if (!l1) {
      current.next = l2;
      return dummy.next;
    } else if (!l2) {
      current.next = l1;
      return dummy.next;
    }

    if (l1.val <= l2.val) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }

    current = current.next;
  }

  return dummy.next;
};
```

### [22].括号匹配 Generate-Parentheses

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

For example, given n = 3, a solution set is:
[
"((()))",
"(()())",
"(())()",
"()(())",
"()()()"
]

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  var ans = [];
  helper(ans, '', 0, 0, n);
  return ans;
};

function helper(ans, str, left, right, n) {
  if (right === n) ans.push(str);
  if (left < n) {
    helper(ans, str + '(', left + 1, right, n);
  }
  if (right < left) {
    helper(ans, str + ')', left, right + 1, n);
  }
}
```

```js
let result = [];

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
  dfs(n, 1, 1, '(');
  return result;
};

function dfs(n, sum, used, s) {
  if (s.length == 2 * n) {
    result.push(s);
    return;
  }
  if (sum == 0) {
    dfs(n, sum + 1, used + 1, s + '(');
  } else if (sum == n || used == n) {
    dfs(n, sum - 1, used, s + ')');
  } else {
    dfs(n, sum + 1, used + 1, s + '(');
    dfs(n, sum - 1, used, s + ')');
  }
}
```

### [23].合并 K 个升序链表 merge-k-sorted-lists

[link](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```

#### 关键点解析

这道题目是合并 k 个已排序的链表，号称 leetcode 目前`最难`的链表题。

- 分治
- 合并排序(merge sort)

当 k=1 的时候，直接返回结果；当 k=2 的时候，把这两个链表归并。当 k=3 的时候，我们可以把它们分成两组，分别归并完毕后再进行最后的归并操作，如下。

![](http://s0.lgstatic.com/i/image2/M01/91/50/CgotOV2InqWAExguACYe_inhacY345.gif)

上述做法运用了典型的分治思想，非常类似归并排序操作。

**时间复杂度**：O(nk×log(k))。
**空间复杂度**：O(1)。因为不像最小堆解法那样需要维护一个额外的数据结构。

#### 代码

```js
var mergeKLists = function(lists) {
  const len = lists.length;
  if (!len) return null;
  if (len === 1) return lists[0];
  if (len === 2) return mergeTwoLists(...lists);

  const mid = len >> 1;
  const result = mergeTwoLists(mergeKLists(lists.slice(0, mid)), mergeKLists(lists.slice(mid)));
  return result;
};

function mergeTwoLists(l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  // 排序插入
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

##### 解题思路二：最小堆法 TODO:

面对 k 个排好序的链表时，最小的那个数肯定是从这 k 个链表的头里面选出来。

那么，第二小的如何选择？例如，有下面 k 个链表。 ![](http://s0.lgstatic.com/i/image2/M01/91/30/CgoB5l2InqSAHLY0ACSlxIOkYh0731.gif)

1.  把最小的 1 从所有的 k 个链表头里选出来之后，把 1 从链表里删掉。

2.  下一个最小的数，还是从所有的 k 个链表头里选出来。

3.  以此类推，每一轮都比较 k 个新的链表头的大小，得出最后的结果。

上述操作的时间复杂度是 O(k)。而针对找出最小的数，可以使用最小堆来提高效率。时间复杂度计算如下。

1.  对 k 个链表头创建一个大小为 k 的最小堆，在第 2 课中提到创建一个大小为 k 的最小堆所需的时间是 O(k)；

2.  从堆里取出最小的数，都是 O(lg(k))；

3.  若每个链表的平均长度为 n，一共有 nk 个元素，即用大小为 k 的最小堆去过滤 nk 个元素；

4.  整体的时间复杂度就是 O(nk×log(k))。

维护这个大小为 k 的最小堆，直到遍历完所有 k 个链表里的所有元素。

**代码实现**

public ListNode mergeKLists(ListNode\[\] lists) {
    //利用一个空的链表头方便插入节点。
    ListNode fakeHead = new ListNode(0), p = fakeHead;
    int k = lists.length;

//  定义一个最小堆来保存  k  个链表节点；将  k  个链表的头放入到最小堆里。
    PriorityQueue<ListNode> heap =
        new PriorityQueue<>(k, new Comparator<ListNode>() {
            public int compare(ListNode a, ListNode b) {
                return a.val - b.val;
            }
        });

//  从最小堆里将当前最小的节点取出，插入到结果链表中。
    for (int i = 0; i < k; i++) {
        if (lists\[i\] != null) {
            heap.offer(lists\[i\]);
        }
    }

while (!heap.isEmpty()) {
        ListNode node = heap.poll();

p.next = node;
        p = p.next;

//  如果发现该节点后面还有后续节点，将后续节点加入到最小堆里。
        if (node.next != null) {
            heap.offer(node.next);
        }
    }
    return fakeHead.next;

}

### [24].交换链表中的相邻结点 swapPairs

```html
Given 1->2->3->4, you should return the list as 2->1->4->3.
```

题目要求：不能修改结点的 val 值，O(1) 空间复杂度。

```js
var swapPairs = function(head) {
  const dummy = new ListNode(0);
  dummy.next = head;

  let pre = dummy,
    cur = dummy.next,
    next = null;
  // 仍然存在两个节点
  while (cur && cur.next) {
    next = cur.next.next;
    cur.next.next = cur;

    // 首先需要保证前面能链接上
    pre.next = cur.next;
    cur.next = next;

    pre = cur;
    cur = next;
  }
  return dummy.next;
};
```

```js
var swapPairs = function(head) {
  if (head === null || head.next === null) {
    return head;
  }
  // 相当于先拿两个节点进行处理
  const newHead = head.next;
  head.next = swapPairs(newHead.next);
  newHead.next = head;
  return newHead;
};
```

### [25].K 个一组翻转链表 reverseKGroup

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：

- 你的算法只能使用常数的额外空间。
- 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：

给定这个链表：`1->2->3->4->5`

当 k=2 时，应当返回：`2->1->4->3->5`

当 k=3 时，应当返回：`3->2->1->4->5`

解题思路

这道题考察了两个知识点：

1.  对链表翻转算法是否熟悉
2.  对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示。

![](http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif)

1.  将 curr 指向的下一节点保存到 next 指针；
2.  curr 指向 prev，一起前进一步；
3.  重复之前步骤，直到 k 个元素翻转完毕；
4.  当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。

**注意**：这道题是“LeetCode 第 24 题，两个一组翻转链表“的扩展，即当 k 等于 2 时，第 25 题就变成了第 24 题。

### [30].串联所有单词的子串

```js
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
  const result = [];
  // [1]. 算出子串
  const sub = getSubStr(words);
  console.log(sub);
  for (let i = 0; i < sub.length; i++) {
    const index = s.indexOf(sub[i]);
    if (index !== -1) {
      result.push(index);
    }
  }
  return result;
};

function getSubStr(arr) {
  if (arr.length < 2) return arr;
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const sub = getSubStr(arr.slice(1));
    for (let j = 0; j < sub.length; j++) {
      if (i !== j) {
        result.push(`${arr[i]}${sub[j]}`);
      }
    }
  }
  return result;
}

console.log(findSubstring('barfoothefoobarman', ['foo', 'bar']));
console.log(findSubstring('wordgoodgoodgoodbestword', ['word', 'good', 'best', 'word']));
```

### [31].next-permutation

```
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```

#### 思路

符合直觉的方法是我们按顺序求出所有的排列，如果当前排列等于 nums，那么我直接取下一个
但是这种做法不符合 constant space 要求(题目要求直接修改原数组),时间复杂度也太高，为 O(n!),肯定不是合适的解。

这种题目比较抽象，写几个例子通常会帮助理解问题的规律。我找了几个例子，其中蓝色背景表示的是当前数字找下一个更大排列的时候`需要改变的元素`.

我们不难发现，蓝色的数字都是从后往前第一个不递增的元素，并且我们的下一个更大的排列
只需要改变蓝色的以及之后部分即可，前面的不需要变。

那么怎么改变蓝色的以及后面部分呢？为了使增量最小，
由于前面我们观察发现，其实剩下的元素从左到右是递减的，而我们想要变成递增的，我们只需要不断交换首尾元素即可。

另外我们也可以以回溯的角度来思考这个问题，让我们先回溯一次：

这个时候可以选择的元素只有 2，我们无法组成更大的排列，我们继续回溯，直到如图：

我们发现我们可以交换 4 或者 2 实现变大的效果，但是要保证变大的幅度最小(下一个更大)，
我们需要选择最小的，由于之前我们发现后面是从左到右递减的，显然就是交换最右面大于 1 的。

之后就是不断交换使之幅度最小：

#### 关键点解析

- 写几个例子通常会帮助理解问题的规律
- 在有序数组中首尾指针不断交换位置即可实现 reverse
- 找到从右边起`第一个大于nums[i]的`，并将其和 nums[i]进行交换

#### 代码

```js
function reverseRange(A, i, j) {
  while (i < j) {
    const temp = A[i];
    A[i] = A[j];
    A[j] = temp;
    i++;
    j--;
  }
}
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  // 时间复杂度O(n) 空间复杂度O(1)
  if (nums == null || nums.length <= 1) return;

  let i = nums.length - 2;
  // 从后往前找到第一个降序的,相当于找到了我们的回溯点
  while (i > -1 && nums[i + 1] <= nums[i]) i--;

  // 如果找了就swap
  if (i > -1) {
    let j = nums.length - 1;
    // 找到从右边起第一个大于nums[i]的，并将其和nums[i]进行交换
    // 因为如果交换的数字比nums[i]还要小肯定不符合题意
    while (nums[j] <= nums[i]) j--;
    const temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
  }

  // 最后我们只需要将剩下的元素从左到右，依次填入当前最小的元素就可以保证是大于当前排列的最小值了
  // [i + 1, A.length -1]的元素进行反转

  reverseRange(nums, i + 1, nums.length - 1);
};
```

```js
var nextPermutation = function(nums) {
  if (nums.length < 2) return;
  var peak = nums.length - 1;
  for (var i = peak - 1; nums[i] >= nums[peak]; peak = i--);

  if (peak !== 0) {
    var swapIndex = findSwap(nums, peak, nums.length - 1, peak - 1);
    if (swapIndex !== -1) {
      swap(nums, peak - 1, swapIndex);
    }
  }

  reverse(nums, peak, nums.length - 1);
};

function findSwap(nums, s, e, target) {
  for (var i = e; i >= s; i--) {
    if (nums[i] > nums[target]) return i;
  }
  return -1;
}

function swap(nums, s, e) {
  var t = nums[s];
  nums[s] = nums[e];
  nums[e] = t;
}
function reverse(nums, s, e) {
  // var len = e - s;
  for (var i = 0; i < Math.ceil((e - s) / 2); i++) {
    swap(nums, s + i, e - i);
  }
  // return nums;
}

// console.log(reverse([1, 2, 3, 4, 5], 0, 4));
// console.log(reverse([1, 2, 3, 4, 5], 3, 4));
// console.log(reverse([1, 2, 3, 4, 5], 2, 3));
// console.log(reverse([1, 2, 3, 4, 5], 1, 1));
// console.log(reverse([1, 2, 3, 4, 5], 1, 4));

// var nums = [1, 2, 5, 4, 3];
// console.log(nums);
// nextPermutation(nums);
// console.log(nums);
//
console.log('====');

var nums = [2, 3, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [1, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);

console.log('====');

var nums = [3, 2, 1];
console.log(nums);
nextPermutation(nums);
console.log(nums);
```

```js
function findMinHeightTrees(n, edges) {
  if (n === 2) return edges[0];
  const adj = new Array(n);
  for (let i = 0; i < n; i++) {
    adj[i] = new Set();
  }
  for (const edge of edges) {
    const [a, b] = edge;
    adj[a].add(b);
    adj[b].add(a);
  }
  const ans = new Set();
  for (let i = 0; i < n; i++) {
    ans.add(i);
  }
  // Find leaves and add them to queue
  const queue = [];
  const a = [];
  for (let i = 0; i < n; i++) {
    if (adj[i].size === 1) {
      a.push(i);
    }
  }
  queue.push(a);

  // While set has more than two nodes, remove them
  while (queue.length) {
    const nodes = queue.shift();
    const b = [];
    for (const node of nodes) {
      ans.delete(node);
      // delete the edges from the current node to other nodes
      for (const child of adj[node]) {
        adj[child].delete(node);
        adj[node].delete(child);
        if (adj[child].size === 1) {
          b.push(child);
        }
      }
    }
    if (ans.size < 3) break;
    if (b.length) queue.push(b);
  }

  return Array.from(ans);
}
```

### [32].longest-valid-parentheses

```
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

#### 思路(动态规划)

所有的动态规划问题, 首先需要解决的就是如何寻找合适的子问题.
该题需要我们找到最长的有效括号对, 我们首先想到的就是定义**dp[i]为前 i 个字符串的最长有效括号对长度**, 但是随后我们会发现, 这样的定义, 我们无法找到 dp[i]和 dp[i-1]的任何关系.
所以, 我们需要重新找一个新的定义: 定义**dp[i]为以第 i 个字符结尾的最长有效括号对长度**. 然后, 我们通过下面这个例子找一下 dp[i]和 dp[i-1]之间的关系.

从上面的例子我们可以观察出一下几点结论(**描述中 i 为图中的 dp 数组的下标, 对应 s 的下标应为 i-1, 第 i 个字符的 i 从 1 开始**).

1. base case: 空字符串的最长有效括号对长度肯定为 0, 即: dp[0] = 0;
2. s 的第**1**个字符结尾的最长有效括号对长度为 0, s 的第**2**个字符结尾的最长有效括号对长度也为 0, 这个时候我们可以得出结论: 最长有效括号对不可能以'('结尾, 即: dp[1] = d[2] = 0;
3. 当 i 等于 3 时, 我们可以看出 dp[2]=0, dp[3]=2, 因为第 2 个字符(**s[1]**)和第 3 个字符(**s[2]**)是配对的;
   当 i 等于 4 时, 我们可以看出 dp[3]=2, dp[4]=4, 因为我们配对的是第 1 个字符(**s[0]**)和第 4 个字符(**s[3]**);
   因此, 我们可以得出结论: 如果第**i**个字符和第<strong>i-1-dp[i-1]</strong>个字符是配对的, 则 dp[i] = dp[i-1] + 2, 其中: i-1-dp[i-1] >= 1, 因为第 0 个字符没有任何意义;
4. 根据第 3 条规则来计算的话, 我们发现 dp[5]=0, dp[6]=2, 但是显然, dp[6]应该为 6 才对, 但是我们发现可以将"(())"和"()"进行拼接, 即: dp[i] += dp[i-dp[i]], 即: dp[6] = 2 + dp[6-2] = 2 + dp[4] = 6

根据以上规则, 我们求解 dp 数组的结果为: [0, 0, 0, 2, 4, 0, 6, 0], 其中最长有效括号对的长度为 6. 以下为图解:

#### 关键点解析

1. 第 3 点特征, 需要检查的字符是 s[i-1]和 s[i-2-dp[i-1]], 根据定义可知: i-1 >= dp[i-1], 但是 i-2 不一定大于 dp[i-1], 因此, 需要检查越界;
2. 第 4 点特征最容易遗漏, 还有就是不需要检查越界, 因为根据定义可知: i >= dp[i], 所以 dp[i-dp[i]]的边界情况是 dp[0];

```js
/**
 * https://leetcode-cn.com/problems/longest-valid-parentheses/description/
 * Difficulty:Hard
 *
 * Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.
 * For "(()", the longest valid parentheses substring is "()", which has length = [2].
 * Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = [4].
 */

/**
 * 使用栈解决
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
  var stack = [];
  for (var i = 0; i < s.length; i++) {
    if (s[i] === '(') stack.push(i);
    else {
      if (stack.length && s[stack[stack.length - 1]] === '(') stack.length--;
      else stack.push(i);
    }
  }

  if (!stack.length) return s.length;
  var longest = 0;
  var end = s.length;
  var start = 0;
  while (stack.length) {
    start = stack[stack.length - 1];
    stack.length--;
    longest = Math.max(longest, end - start - 1);
    end = start;
  }
  longest = Math.max(longest, end);
  return longest;
};

console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('())'), 2);
console.log(longestValidParentheses('(()'), 2);
console.log(longestValidParentheses('))()())((())))'), 6);
console.log(longestValidParentheses('()'), 2);
console.log(longestValidParentheses('('), 0);
console.log(longestValidParentheses(')()()))()()())'), 6);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('()(()'), 2);
console.log(longestValidParentheses('(()'), 2);
```

### [33].旋转数组中搜索 Search-in-Rotated-Sorted-Array

```
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

```

#### 思路

先找出 mid，然后根据 mid 来判断，mid 是在有序的部分还是无序的部分

假如 mid 小于 start，则 mid 一定在右边有序部分。
假如 mid 大于等于 start， 则 mid 一定在左边有序部分。

#### 关键点解析

- 二分法
- 找出有序区间，然后根据 target 是否在有序区间舍弃一半元素

#### 代码

```js
// 时间复杂度：O(logn)
// 空间复杂度：O(1)
var search = function(nums, target) {
  let start = 0;
  let end = nums.length - 1;

  while (start <= end) {
    const mid = start + ((end - start) >> 1);
    if (nums[mid] === target) return mid;

    // ️注意这里的等号
    if (nums[mid] >= nums[start]) {
      // [start, mid]有序
      // target 在 [start, mid] 之间

      // 其实 target 不可能等于 nums[mid]， 但是为了对称，我还是加上了等号
      if (target >= nums[start] && target <= nums[mid]) {
        end = mid - 1;
      } else {
        //target 不在 [start, mid] 之间
        start = mid + 1;
      }
    } else {
      // [mid, end]有序
      // target 在 [mid, end] 之间
      if (target >= nums[mid] && target <= nums[end]) {
        start = mid + 1;
      } else {
        // target 不在 [mid, end] 之间
        end = mid - 1;
      }
    }
  }

  return -1;
};
```

### [34].在排序数组中查找元素的第一个和最后一个位置 find-first-and-last-position-of-element-in-sorted-array

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。

示例 1:
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]

#### 思路

在二分搜索里，比较难的是判断逻辑，对这道题来说，什么时候知道这个位置是不是 8 第一次以及最后出现的地方呢？

把第一次出现的地方叫下边界(lower bound)，把最后一次出现的地方叫上边界(upper bound)。

那么成为 8 的下边界的条件应该有两个。

- 8 的左边有数，那么该数必须小于 8；
- 8 的左边没有数，即 8 是数组的第一个数。

而成为 8 的上边界的条件也应该有两个。

- 8 的右边有数，那么该数必须大于 8；
- 8 的右边没有数，即 8 是数组的最后一个数。

#### 代码

```js
var searchRange = function(nums, target) {
  // 升序， 并且对时间复杂度有要求是 O(logn) 只能是 二分搜索
  let start = 0,
    end = nums.length - 1,
    mid;
  // 需要给 = ，处理 length === 1 的情况
  while (start <= end) {
    mid = start + ((end - start) >> 1);
    let left = (right = 0);
    if (nums[mid] === target) {
      // 如果找到相等的值，分别往前，往后寻找
      while (nums[mid - left] === target) left++;
      while (nums[mid + right] === target) right++;
      return [mid - left + 1, mid + right - 1];
    } else if (nums[mid] > target) {
      end = mid - 1;
    } else if (nums[mid] < target) {
      start = mid + 1;
    }
  }

  return [-1, -1];
};
```

### [39].combination-sum

给定一个无重复元素的数组  candidates  和一个目标数  target ，找出  candidates  中所有可以使数字和为  target  的组合。candidates  中的数字可以无限制重复被选取。

```
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

说明：

- 所有数字(包括  target)都是正整数。
- 解集不能包含重复的组合。

#### 思路

这道题目是求集合，并不是`求极值`，因此动态规划不是特别切合，因此我们需要考虑别的方法。这种题目其实有一个通用的解法，就是回溯法。

#### 关键点解析

- 回溯法
- backtrack 解题公式

回溯法。

1.  从一个空的集合开始，小心翼翼地往里面添加元素。
2.  每次添加，检查一下当前的总和是否等于给定的目标。
3.  如果总和已经超出了目标，说明没有必要再尝试其他的元素了，返回并尝试其他的元素；
4.  如果总和等于目标，就把当前的组合添加到结果当中，表明我们找到了一种满足要求的组合，同时返回，并试图寻找其他的集合。

#### 代码

在主函数里：

1.  定义一个 results 数组用来保存最终的结果；
2.  调用函数 backtracking，并将初始的情况以及 results 传递进去，这里的初始情况就是从第一个元素开始尝试，而且初始的子集为空。

在 backtracking 函数里：

1.  检查当前的元素总和是否已经超出了目标给定的值，每添加进一个新的元素时，就将它从目标总和中减去；
2.  如果总和已经超出了目标给定值，就立即返回，去尝试其他的数值；
3.  如果总和刚好等于目标值，就把当前的子集添加到结果中。

在循环体内：

1.  每次添加了一个新的元素，立即递归调用 backtracking，看是否找到了合适的子集
2.  递归完毕后，要把上次尝试的元素从子集里删除，这是最重要的。

以上，就完成了回溯。

提示：这是一个最经典的回溯的题目，麻雀虽小，但五脏俱全。它完整地体现了回溯算法的各个阶段。

```js
function backtrack(list, tempList, nums, remain, start) {
  if (remain < 0) return;
  else if (remain === 0) return list.push([...tempList]);
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, remain - nums[i], i); // 数字可以重复使用， i + 1代表不可以重复利用
    tempList.pop();
  }
}
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  const list = [];
  backtrack(
    list,
    [],
    candidates.sort((a, b) => a - b),
    target,
    0,
  );
  return list;
};
```

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  var res = [];
  var temp = [];
  helper(res, temp, candidates, target, 0);
  return res;
};

function helper(res, temp, candidates, target, start) {
  if (target === 0) {
    res.push([...temp]);
    return;
  }

  for (var i = start; i < candidates.length; i++) {
    if (candidates[i] <= target) {
      temp.push(candidates[i]);
      helper(res, temp, candidates, target - candidates[i], i);
      temp.length -= 1;
    }
  }
}

console.log(combinationSum([1, 2, 3, 5, 6, 7], 7));
console.log(combinationSum([7, 2, 3, 5, 6, 1], 7));
```

### [42].接雨水 trapping-rain-water

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```
Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

```

#### 关键点解析

- 建模 `h[i] = Math.min(左边柱子最大值, 右边柱子最大值)`(h 为下雨之后的水位)

#### 代码

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  let max = 0;
  let volumn = 0;
  const leftMax = [];
  const rightMax = [];

  for (let i = 0; i < height.length; i++) {
    leftMax[i] = max = Math.max(height[i], max);
  }

  max = 0;

  for (let i = height.length - 1; i >= 0; i--) {
    rightMax[i] = max = Math.max(height[i], max);
  }

  for (let i = 0; i < height.length; i++) {
    volumn = volumn + Math.min(leftMax[i], rightMax[i]) - height[i];
  }

  return volumn;
};
```

### [46].全排列 permutations

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

```
Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

```

#### 代码

```js
function backtrack(list, tempList, nums) {
  if (tempList.length === nums.length) return list.push([...tempList]);
  for (let i = 0; i < nums.length; i++) {
    if (tempList.includes(nums[i])) continue;
    tempList.push(nums[i]);
    backtrack(list, tempList, nums);
    tempList.pop();
  }
}
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const list = [];
  backtrack(list, [], nums);
  return list;
};
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  result = [];
  nums.sort(function(a, b) {
    return a - b;
  });
  find(nums, []);
  return result;
};

let result = [];

function find(nums, templateList) {
  if (nums.length == 0) {
    result.push(templateList.slice());
  }
  for (let i = 0; i < nums.length; i++) {
    templateList.push(nums[i]);
    let copy = nums.slice();
    copy.splice(i, 1);
    find(copy, templateList);
    templateList.pop();
  }
}

permute([1, 2, 3]);
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  if (!nums.length) return [];
  var res = [[]];
  for (var i = 0; i < nums.length; i++) {
    var len = res.length;
    for (var j = 0; j < len; j++) {
      var oldArr = res.shift();
      for (var k = 0; k <= oldArr.length; k++) {
        var newArr = oldArr.slice();
        newArr.splice(k, 0, nums[i]);
        res.push(newArr);
      }
    }
  }
  return res;
};
console.log(permute([1, 2, 3]));
```

### [48].旋转图像 rotate-image

给定一个 n × n 的二维矩阵  matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

```
Example 1:

Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

#### 思路

这道题目让我们 in-place，也就说空间复杂度要求 O(1)，如果没有这个限制的话，很简单。

通过观察发现，我们只需要将第 i 行变成第 n - i - 1 列， 因此我们只需要保存一个原有矩阵，然后按照这个规律一个个更新即可。

代码：

```js
var rotate = function(matrix) {
  // 时间复杂度O(n^2) 空间复杂度O(n)
  const oMatrix = JSON.parse(JSON.stringify(matrix)); // clone
  const n = oMatrix.length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      matrix[j][n - i - 1] = oMatrix[i][j];
    }
  }
};
```

如果要求空间复杂度是 O(1)的话，我们可以用一个 temp 记录即可，这个时候就不能逐个遍历了。
比如遍历到 1 的时候，我们把 1 存到 temp，然后更新 1 的值为 7。 1 被换到了 3 的位置，我们再将 3 存到 temp，依次类推。
但是这种解法写起来比较麻烦，这里我就不写了。

事实上有一个更加巧妙的做法，我们可以巧妙地利用对称轴旋转达到我们的目的，如图，我们先进行一次以对角线为轴的翻转，然后
再进行一次以水平轴心线为轴的翻转即可。

这种做法的时间复杂度是 O(n^2) ，空间复杂度是 O(1)

#### 关键点解析

- 矩阵旋转操作

#### 代码

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  // 时间复杂度O(n^2) 空间复杂度O(1)

  // 做法： 先沿着对角线翻转，然后沿着水平线翻转
  const n = matrix.length;
  function swap(arr, [i, j], [m, n]) {
    const temp = arr[i][j];
    arr[i][j] = arr[m][n];
    arr[m][n] = temp;
  }
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i; j++) {
      swap(matrix, [i, j], [n - j - 1, n - i - 1]);
    }
  }

  for (let i = 0; i < n / 2; i++) {
    for (let j = 0; j < n; j++) {
      swap(matrix, [i, j], [n - i - 1, j]);
    }
  }
};
```

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
  matrix.reverse();
  for (let i = 0; i < matrix.length; i++) {
    for (let j = i + 1; j < matrix[0].length; j++) {
      let tmp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = tmp;
    }
  }
};

rotate([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]);
```

### [49].group-anagrams

```
Given an array of strings, group anagrams together.

Example:

Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
```

#### 思路

一个简单的解法就是遍历数组，然后对每一项都进行排序，然后将其添加到 hashTable 中，最后输出 hashTable 中保存的值即可。

这种做法空间复杂度 O(n)， 假设排序算法用的快排，那么时间复杂度为 O(n \* klogk), n 为数组长度，k 为字符串的平均长度

代码：

```js
var groupAnagrams = function(strs) {
  const hashTable = {};

  function sort(str) {
    return str
      .split('')
      .sort()
      .join('');
  }

  // 这个方法需要排序，因此不是很优，但是很直观，容易想到
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    const key = sort(str);
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

下面我们介绍另外一种方法，我们建立一个 26 长度的 counts 数组(如果区分大小写，我们可以建立 52 个，如果支持其他字符依次类推)。
然后我们给每一个字符一个固定的数组下标，然后我们只需要更新每个字符出现的次数。 最后形成的 counts 数组如果一致，则说明他们可以通过
交换顺序得到。这种算法空间复杂度 O(n), 时间复杂度 O(n \* k), n 为数组长度，k 为字符串的平均长度.

#### 关键点解析

- 桶排序

#### 代码

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  // 类似桶排序

  let counts = [];
  const hashTable = {};
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    counts = Array(26).fill(0);
    for (let j = 0; j < str.length; j++) {
      counts[str[j].charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }
    const key = counts.join('');
    if (!hashTable[key]) {
      hashTable[key] = [str];
    } else {
      hashTable[key].push(str);
    }
  }

  return Object.values(hashTable);
};
```

```js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
  const a = 'a'.charCodeAt();
  let map = new Map();
  for (let i = 0; i < strs.length; i++) {
    let charArr = createArr();
    for (let j = 0; j < strs[i].length; j++) charArr[strs[i].charCodeAt(j) - a]++;
    let key = charArr.join('');
    if (map.has(key)) {
      map.get(key).push(strs[i]);
    } else {
      map.set(key, [strs[i]]);
    }
  }
  const ans = [];
  for (let value of map.values()) {
    ans.push(value);
  }
  return ans;
};

function createArr() {
  let i = 0;
  let arr = [];
  while (i < 26) {
    arr.push(0);
    i++;
  }
  return arr;
}

groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']);
```

### [51].N 皇后 N-Queens

在 `n*n` 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解。

一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。

45 度对角线标记数组的长度为 `2 * n - 1`，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c。

135 度对角线标记数组的长度也是 `2 * n - 1`，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)。

```js
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
  var ret = [];
  var board = [];
  for (var i = 0; i < n; i++) {
    board.push(new Array(n).fill('.'));
  }
  helper(board, 0, ret);
  return ret;
};

function helper(board, col, ret) {
  if (col === board.length) {
    ret.push(construct(board));
  } else {
    for (var i = 0; i < board.length; i++) {
      if (check(board, i, col)) {
        board[i][col] = 'Q';
        helper(board, col + 1, ret);
        board[i][col] = '.';
      }
    }
  }
}

function check(board, x, y) {
  for (var i = 0; i < board.length; i++) {
    for (var j = 0; j < y; j++) {
      if (board[i][j] === 'Q' && (i === x || i + j === x + y || i + y === j + x)) return false;
    }
  }
  return true;
}
function construct(board) {
  return board.map(arr => arr.join(''));
}
console.log(solveNQueens(4));
```

### [53].最大子序和 Maximum-Subarray

```
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
```

#### 思路

这道题求解连续最大子序列和，以下从时间复杂度角度分析不同的解题思路。

###### 解法一 - 暴力解

一般情况下，先从暴力解分析，然后再进行一步步的优化。

**原始暴力解：**(超时)

求子序列和，那么我们要知道子序列的首尾位置，然后计算首尾之间的序列和。用 2 个 for 循环可以枚举所有子序列的首尾位置。
然后用一个 for 循环求解序列和。这里时间复杂度太高，`O(n^3)`.

###### 复杂度分析

- 时间复杂度 `O(n^3) - n 是数组长度`
- 空间复杂度 `O(1)`

###### 解法二 - 前缀和 + 暴力解

**优化暴力解：** (震惊，居然 AC 了)

在暴力解的基础上，用前缀和我们可以优化到暴力解`O(n^2)`, 这里以空间换时间。
这里可以使用原数组表示`prefixSum`, 省空间。

求序列和可以用前缀和(`prefixSum`) 来优化，给定子序列的首尾位置`(l, r),`
那么序列和 `subarraySum=prefixSum[r] - prefixSum[l - 1];`
用一个全局变量`maxSum`, 比较每次求解的子序列和，`maxSum = max(maxSum, subarraySum)`.

###### 复杂度分析

- 时间复杂度 `O(n^2) - n 是数组长度`
- 空间复杂度 `O(n) - prefixSum 数组空间为n`

> 如果用更改原数组表示前缀和数组，空间复杂度降为`O(1)`

但是时间复杂度还是太高，还能不能更优化。答案是可以，前缀和还可以优化到`O(n)`.

###### 解法三 - 优化前缀和

我们定义函数`S(i)` ，它的功能是计算以 `0(包括 0)`开始加到 `i(包括 i)`的值。

那么 `S(j) - S(i - 1)` 就等于 从 `i` 开始(包括 i)加到 `j`(包括 j)的值。

我们进一步分析，实际上我们只需要遍历一次计算出所有的 `S(i)`, 其中 `i = 0,1,2....,n-1。`
然后我们再减去之前的`S(k)`,其中 `k = 0，1，i - 1`，中的最小值即可。 因此我们需要
用一个变量来维护这个最小值，还需要一个变量维护最大值。

###### 复杂度分析

- 时间复杂度 `O(n) - n 是数组长度`
- 空间复杂度 `O(1)`

###### 解法四 - 分治法

我们把数组`nums`以中间位置(`m`)分为左(`left`)右(`right`)两部分. 那么有，
`left = nums[0]...nums[m - 1]` 和 `right = nums[m + 1]...nums[n-1]`

最大子序列和的位置有以下三种情况：

1. 考虑中间元素`nums[m]`, 跨越左右两部分，这里从中间元素开始，往左求出后缀最大，往右求出前缀最大, 保持连续性。
2. 不考虑中间元素，最大子序列和出现在左半部分，递归求解左边部分最大子序列和
3. 不考虑中间元素，最大子序列和出现在右半部分，递归求解右边部分最大子序列和

分别求出三种情况下最大子序列和，三者中最大值即为最大子序列和。

举例说明，如下图：

###### 复杂度分析

- 时间复杂度 `O(nlogn) - n 是数组长度`
- 空间复杂度 `O(logn)` - 因为调用栈的深度最多是 logn。

###### 解法五 - 动态规划

动态规划的难点在于找到状态转移方程，

`dp[i] - 表示到当前位置 i 的最大子序列和`

状态转移方程为：
`dp[i] = max(dp[i - 1] + nums[i], nums[i])`

初始化：`dp[0] = nums[0]`

从状态转移方程中，我们只关注前一个状态的值，所以不需要开一个数组记录位置所有子序列和，只需要两个变量，

`currMaxSum - 累计最大和到当前位置i`

`maxSum - 全局最大子序列和`:

- `currMaxSum = max(currMaxSum + nums[i], nums[i])`
- `maxSum = max(currMaxSum, maxSum)`

如图：

###### 复杂度分析

- 时间复杂度 `O(n) - n 是数组长度`
- 空间复杂度 `O(1)`

#### 关键点分析

1. 暴力解，列举所有组合子序列首尾位置的组合，求解最大的子序列和, 优化可以预先处理，得到前缀和
2. 分治法，每次从中间位置把数组分为左右中三部分， 分别求出左右中(这里中是包括中间元素的子序列)最大和。对左右分别深度递归，三者中最大值即为当前最大子序列和。
3. 动态规划，找到状态转移方程，求到当前位置最大和。

#### 代码

###### 解法二 - 前缀和 + 暴力

```js
function LSS(list) {
  const len = list.length;
  let max = -Number.MAX_VALUE;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum = 0;
    for (let j = i; j < len; j++) {
      sum += list[j];
      if (sum > max) {
        max = sum;
      }
    }
  }

  return max;
}
```

###### 解法三 - 优化前缀和

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  let min = 0;
  let sum = 0;
  for (let i = 0; i < len; i++) {
    sum += list[i];
    if (sum - min > max) max = sum - min;
    if (sum < min) {
      min = sum;
    }
  }

  return max;
}
```

###### 解法四 - 分治法

```js
function helper(list, m, n) {
  if (m === n) return list[m];
  let sum = 0;
  let lmax = -Number.MAX_VALUE;
  let rmax = -Number.MAX_VALUE;
  const mid = ((n - m) >> 1) + m;
  const l = helper(list, m, mid);
  const r = helper(list, mid + 1, n);
  for (let i = mid; i >= m; i--) {
    sum += list[i];
    if (sum > lmax) lmax = sum;
  }

  sum = 0;

  for (let i = mid + 1; i <= n; i++) {
    sum += list[i];
    if (sum > rmax) rmax = sum;
  }

  return Math.max(l, r, lmax + rmax);
}

function LSS(list) {
  return helper(list, 0, list.length - 1);
}
```

###### 解法五 - 动态规划

用 `dp[n`] 表示元素 n 作为末尾的连续序列的最大和，容易想到状态转移方程为`dp[n] = max(dp[n-1] + num[n], num[n])`，从第 1 个元素开始，自顶向上求解。类似前一个问题，这个问题当中，求解 `dp[i]` 只依赖 `dp[i-1]`，因此可以使用变量来存储，

```js
function LSS(list) {
  const len = list.length;
  let max = list[0];
  for (let i = 1; i < len; i++) {
    list[i] = Math.max(0, list[i - 1]) + list[i];
    if (list[i] > max) max = list[i];
  }

  return max;
}
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// 典型的动态规划 dp[i] = max(dp[i-1] + num[i], dp[i-2])
var maxSubArray = function(nums) {
  if (nums.length < 2) return nums.length === 0 ? 0 : nums[0];
  let max = nums[0];
  for (let i = 1; i < nums.length; i++) {
    // 跟 nums[i] 比较的话， nums[i] 更大表示选取当前值，否则就不选
    // sums[i] = Math.max(sums[i - 1] + nums[i], nums[i])
    // 或者换一种想法就是，判断前一次的结果是否大于 0
    // 大于的话加上当前位置的值，就是最长序列
    // 否则的话，加上前面的和只会更小，也就是只取当前位置为一个新数组
    nums[i] = nums[i] + Math.max(nums[i - 1], 0);
    if (nums[i] > max) {
      max = nums[i];
    }
  }
  return max;
};

console.log(maxSubArray([-2, 1, -3, 4]));
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

```js
/**
 *
 * https://discuss.leetcode-cn.com/topic/6413/dp-solution-some-thoughts
 *
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  var dp = [];
  var max = (dp[0] = nums[0]);

  for (var i = 1; i < nums.length; i++) {
    dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
    max = Math.max(dp[i], max);
  }

  return max;
};

/**
 * @param nums
 * @returns {*}
 */
var maxSubArray = function(nums) {
  var max = nums[0];
  var sum = nums[0];

  for (var i = 1; i < nums.length; i++) {
    sum = sum > 0 ? sum + nums[i] : nums[i];
    max = Math.max(sum, max);
  }
  return max;
};

console.log(maxSubArray([1, 1, 1]) == 3);
console.log(maxSubArray([-1, -1, -1]) == -1);
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6);
console.log(maxSubArray([-2, -1]) == -1);
console.log(maxSubArray([-1]) == -1);
console.log(maxSubArray([-1, 0]) == 0);
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let count = nums[0],
    maxCount = nums[0];
  for (let i = 1; i < nums.length; i++) {
    count = Math.max(count + nums[i], nums[i]);
    maxCount = Math.max(maxCount, count);
  }
  return maxCount;
};

console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
```

### [55].jump-game

```
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.

```

#### 思路

这道题目是一道典型的`回溯`类型题目。
思路就是用一个变量记录当前能够到达的最大的索引，我们逐个遍历数组中的元素去更新这个索引。
变量完成判断这个索引是否大于数组下表即可。

#### 关键点解析

- 建模 (记录和更新当前位置能够到达的最大的索引即可)

#### 代码

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
  let max = 0; // 能够走到的数组下标

  for (let i = 0; i < nums.length; i++) {
    if (max < i) return false; // 当前这一步都走不到，后面更走不到了
    max = Math.max(nums[i] + i, max);
  }

  return max >= nums.length - 1;
};
```

### [62].矩阵的总路径数 unique-paths

一个机器人位于一个 m x n  网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。

#### 思路

很容易看出，由于机器人只能右移动和下移动，因此第 `[i, j]` 个格子的总数应该等于 `[i - 1, j] + [i, j - 1]`， 因为第 `[i,j]` 个格子一定是从左边或者上面移动过来的。

#### 关键点

- 空间复杂度可以进一步优化到 O(n), 这会是一个考点
- 基本动态规划问题

#### 代码

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const dp = Array(n).fill(1);

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[j] = dp[j] + dp[j - 1];
    }
  }
  console.log(dp);
  return dp[n - 1];
};

console.log(uniquePaths(3, 2));
```

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
  const dp = new Array(m).fill(new Array(n));

  for (let i = 0; i < n; i++) {
    dp[0][i] = 1;
  }
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1;
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
};
console.log(uniquePaths(3, 2));
```

### [64].最小路径和 Minimum-Path-Sum

```html
[[1,3,1], [1,5,1], [4,2,1]] Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.
```

题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。

#### Code

```js
// 这是最基础的动态规划题目。 不过是二维的。
// dp[i][j]代表从(0, 0)走到(i, j)的最小路径和则
// dp[0][i]来自第一行的累加
// dp[i][0]来自第一列的累加
// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + c[i][j]
// (来自当前位置的走法无非向下或向右，选两者中代价最小的)
/**
 * 二维数组
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
  var m = grid.length;
  var n = grid[0].length;
  var dp = [];
  while (dp.push(new Array(n + 1).fill(Number.MAX_VALUE)) <= m);

  dp[0][1] = 0;
  dp[1][0] = 0;

  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      dp[i][j] = grid[i - 1][j - 1] + Math.min(dp[i][j - 1], dp[i - 1][j]);
    }
  }

  return dp[m][n];
};
```

```js
/**
 * 一维数组
 * @param {number[][]} grid
 * @return {number}
 */
function minPathSum(grid) {
  if (grid.length == 0 || grid[0].length == 0) {
    return 0;
  }
  const m = grid.length,
    n = grid[0].length;
  const dp = new Array(n + 1).fill(0);

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (j == 0) {
        dp[j] = dp[j]; // 只从上侧走到该位置
      } else if (i == 0) {
        dp[j] = dp[j - 1]; // 只从左侧走到该位置
      } else {
        dp[j] = Math.min(dp[j - 1], dp[j]);
      }
      // 累加当前走的值
      dp[j] += grid[i][j];
    }
  }
  console.log(dp);
  return dp[n - 1];
}
console.log(
  minPathSum([
    [1, 1],
    [2, 2],
  ]),
  minPathSum([
    [1, 3],
    [2, 2],
  ]),
);
```

### [66].加一

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
示例 1:
输入: [1, 2, 3]
输出: [1, 2, 4]
解释: 输入数组表示数字 123。
示例 2:
输入: [4, 3, 2, 1]
输出: [4, 3, 2, 2]
解释: 输入数组表示数字 4321。

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
  let shouldAddOne = true;
  for (let i = digits.length - 1; i >= 0; i--) {
    if (shouldAddOne) {
      if (digits[i] === 9) {
        digits[i] = 0;
        shouldAddOne = true;
      } else {
        digits[i] += 1;
        shouldAddOne = false;
      }
    }
  }
  if (shouldAddOne) {
    digits.unshift(1);
  }

  return digits;
};

[[1, 2, 3], [4, 3, 2, 1], [9]].forEach(elm => {
  console.log(plusOne(elm));
});
```

### [67].二进制求和

```js
// Given two binary strings, return their sum (also a binary string).

// The input strings are both non-empty and contains only characters 1 or [0].

// Example 1:

// Input: a = "11", b = "1"
// Output: "100"
// Example 2:

// Input: a = "110", b = "111"
// Output: "1101"

// 二进制求和
// 给定两个二进制字符串，返回他们的和(用二进制表示)。

// 输入为非空字符串且只包含数字 1 和 0。

// 示例 1:

// 输入: a = "11", b = "1"
// 输出: "100"
// 示例 2:

// 输入: a = "110", b = "111"
// 输出: "1101"

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
export default function addBinary(a, b) {
  let i = a.length - 1;
  let j = b.length - 1;
  const ans = [];
  let carry = 0;
  while (j >= 0 || i >= 0 || carry) {
    let sum = carry;
    if (i >= 0) {
      sum += parseInt(a[i], 10);
      i--;
    }
    if (j >= 0) {
      sum += parseInt(b[j], 10);
      j--;
    }
    carry = sum > 1 ? 1 : 0;
    ans.push(sum % 2);
  }
  return ans.reverse().join('');
}
```

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary1 = function(a, b) {
  let c = 0;
  let aLen = a.length;
  let bLen = b.length;
  let ans = '';
  for (var i = 0; i < Math.max(aLen, bLen); i++) {
    var ai = i < aLen ? parseInt(a[aLen - i - 1]) : 0;
    var bi = i < bLen ? parseInt(b[bLen - i - 1]) : 0;

    var sum = ai + bi + c;
    // console.log(ai, bi, c);
    if (sum < 2) {
      ans = sum + ans;
      c = 0;
    } else {
      ans = sum - 2 + ans;
      c = 1;
    }
  }
  if (c) {
    ans = 1 + ans;
  }

  return ans;
};

console.log(addBinary1('111', '1'));
```

```js
/*
 * [67] 二进制求和
 */
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */

function getLastChar(str) {
  if (str) {
    return str[str.length - 1];
  }
  return 0;
}

function advance(str) {
  if (str) {
    return str.slice(0, -1);
  }
}
var addBinary = function(a, b) {
  let result = [],
    carry = 0; // 进位
  while (a || b || carry) {
    let valueA = parseInt(getLastChar(a)),
      valueB = parseInt(getLastChar(b));

    const needCarry = valueA + valueB + carry > 1;

    result.push(needCarry ? valueA + valueB + carry - 2 : valueA + valueB + carry);

    a = advance(a);
    b = advance(b);

    carry = needCarry ? 1 : 0;
  }

  return result.reverse().join('');
};

console.log(addBinary('111', '1'));
console.log(addBinary('1', '1'));
```

### [69].x 的平方根

实现  int sqrt(int x)  函数。计算并返回  x  的平方根，其中  x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

主要是二分搜索的思想，以及 `**` 这个幂乘方法。

```js
var mySqrt = function(x) {
  let left = 1,
    right = x,
    mid;
  let result;

  while (left <= right) {
    // 向下取整
    mid = left + ((right - left) >> 1);
    result = mid ** 2;

    if (result > x) {
      right = mid - 1;
    } else if (result < x) {
      left = mid + 1;
    } else return mid;
  }

  return right;
};
```

### [70].爬楼梯 Climbing-Stairs

斐波那契数列 n 往后推了 1 项.

```js
var climbStairs = function(n) {
  let dp = new Array(n);
  dp[0] = 1;
  dp[1] = 2;
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n - 1];
};
```

```js
var climbStairs = function(n) {
  return fib(n + 1);
};

var fib = function(n) {
  // 前一个值和后一个值
  let f = 0,
    g = 1;
  while (n--) {
    g += f; // g 是往后多算了一位的。
    f = g - f;
  }
  return f;
};
```

### [76].最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"

```js
function minWindow(s, t) {
  var ans = '';

  // [1]. process hashmap
  var map = {};
  t.split('').forEach(ch => (map[ch] = (map[ch] || 0) + 1));
  var count = Object.keys(map).length;

  // [2]. traverse s to find boundaries
  // both l & r are inclusive
  var l = 0;
  var r = -1;

  while (r < s.length) {
    if (count === 0) {
      // good condition
      // l~r contains t

      // update ans
      if (!ans || r - l + 1 < ans.length) {
        ans = s.slice(l, r + 1);
      }

      // get rid of curr ch and then move l
      if (map[s[l]] !== undefined) {
        map[s[l]]++;
      }
      if (map[s[l]] > 0) {
        count++;
      }
      l++;
    } else {
      // bad condition
      // l~r doesn't contain t

      // move r and add new ch
      r++;
      if (map[s[r]] !== undefined) {
        map[s[r]]--;
      }
      if (map[s[r]] === 0) {
        count--;
      }
    }
  }
  return ans;
}
```

### [78].子集

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  if (nums.length === 0) return [];
  const length = nums.length;
  const result = [];
};

function select(n, nums = []) {
  if (n === 0) return [];

  for (let i = 0; i < nums.length; i++) {}
}
```

```js
// 78. Subsets

// Given a set of distinct integers, nums, return all possible subsets (the power set).

// Note: The solution set must not contain duplicate subsets.

// Example:

// Input: nums = [1,2,3]
// Output:
// [
//   [3],
//   [1],
//   [2],
//   [1,2,3],
//   [1,3],
//   [2,3],
//   [1,2],
//   []
// ]
const subsetsAux = (nums, prev, start, res) => {
  if (start === nums.length || start === prev.length) {
    res.push(prev);
    return res;
  }
  const remove = [];
  for (let i = 0; i < prev.length; i++) {
    if (start === i) {
      continue;
    }
    remove.push(prev[i]);
  }
  subsetsAux(nums, [...prev], start + 1, res);
  subsetsAux(nums, [...remove], start, res);
  return res;
};

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
export default function subsets(nums) {
  const res = [];
  return subsetsAux(nums, [...nums], 0, res);
}
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
  let list = [];
  nums.sort();
  backtrack(list, new Array(), nums, 0);
  return list;
};

function backtrack(list, tempList, nums, start) {
  list.push(tempList.slice());
  for (let i = start; i < nums.length; i++) {
    tempList.push(nums[i]);
    backtrack(list, tempList, nums, i + 1);
    tempList.pop();
  }
}

subsets([1, 2, 3]);

/**
 *
 * 1
 * 1 2
 * 1 2 3
 * 1 3
 * 2
 * 2 3
 * 3
 */
```

### [79].word-search

```
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

#### 思路

在 2D 表中搜索是否有满足给定单词的字符组合，要求所有字符都是相邻的(方向不限). 题中也没有要求字符的起始和结束位置。

在起始位置不确定的情况下，扫描二维数组，找到字符跟给定单词的第一个字符相同的，四个方向(上，下，左，右)分别 DFS 搜索，
如果任意方向满足条件，则返回结果。不满足，回溯，重新搜索。

举例说明：如图二维数组，单词："SEE"

```
1. 扫描二维数组，找到board[1,0] = word[0]，匹配单词首字母。
2. 做DFS(上，下，左，右 四个方向)

如下图：
```

起始位置(1，0)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1，0)为已经访问过，board[1][0] = '*'
2. 上(0，0)字符为 'A' 不匹配,
3. 下(2，0)字符为 'A'，不匹配,
4. 左(-1，0)超越边界，不匹配,
5. 右(1，1)字符 'F'，不匹配

如下图：
```

由于从起始位置 DFS 都不满足条件，所以

```
1. 回溯，标记起始位置(1，0)为未访问。board[1][0] = 'S'.
2. 然后继续扫描二维数组，找到下一个起始位置(1，3)

如下图：
```

起始位置(1，3)，判断相邻的字符是否匹配单词下一个字符 `E`.

```
1. 标记当前字符(1, 3)为已经访问过，board[1][3] = '*'
2. 上(0，3)字符为 'E', 匹配, 继续DFS搜索(参考位置为(0，3)位置DFS搜索步骤描述)
3. 下(2，3)字符为 'E'，匹配, #2匹配，先进行#2 DFS搜索，由于#2 DFS搜索没有找到与单词匹配，继续DFS搜索(参考位置为(2，3)DFS搜索步骤描述)
4. 左(1，2)字符为 'C'，不匹配,
5. 右(1，4)超越边界，不匹配

如下图：
```

位置(0，3)满足条件，继续 DFS，判断相邻的字符是否匹配单词下一个字符 `E`

```
1. 标记当前字符(0，3)为已经访问过，board[0][3] = '*'
2. 上 (-1，3)超越边界，不匹配
3. 下(1，3)已经访问过，
4. 左(0，2)字符为 'C'，不匹配
5. 右(1，4)超越边界，不匹配

如下图
```

从位置(0，3)DFS 不满足条件，继续位置(2，3)DFS 搜索

```
1. 回溯，标记起始位置(0，3)为未访问。board[0][3] = 'E'.
2. 回到满足条件的位置(2，3)，继续DFS搜索，判断相邻的字符是否匹配单词下一个字符 'E'
3. 上 (1，3)已访问过
4. 下(3，3)超越边界，不匹配
5. 左(2，2)字符为 'E'，匹配
6. 右(2，4)超越边界，不匹配

如下图：
```

单词匹配完成，满足条件，返回 `True`.

###### 复杂度分析

- 时间复杂度 `O(m*n) - m 是二维数组行数， n 是二维数组列数`
- 空间复杂度 `O(1) - 这里在原数组中标记当前访问过，没有用到额外空间`

> **注意**：如果用 Set 或者是 boolean[][]来标记字符位置是否已经访问过，需要额外的空间 `O(m*n)`.

#### 关键点分析

- 遍历二维数组的每一个点，找到起始点相同的字符，做 DFS
- DFS 过程中，要记录已经访问过的节点，防止重复遍历，这里(Java Code 中)用 `*` 表示当前已经访问过，也可以用 Set 或者是 boolean[][]数组记录访问过的节点位置。
- 是否匹配当前单词中的字符，不符合回溯，这里记得把当前 `*` 重新设为当前字符。如果用 Set 或者是 boolean[][]数组，记得把当前位置重设为没有访问过。

#### 代码

```js
function DFS(board, row, col, rows, cols, word, cur) {
  // 边界检查
  if (row >= rows || row < 0) return false;
  if (col >= cols || col < 0) return false;

  const item = board[row][col];

  if (item !== word[cur]) return false;

  if (cur + 1 === word.length) return true;

  // 如果你用hashmap记录访问的字母， 那么你需要每次backtrack的时候手动清除hashmap，并且需要额外的空间
  // 这里我们使用一个little trick

  board[row][col] = null;

  // 上下左右
  const res =
    DFS(board, row + 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row - 1, col, rows, cols, word, cur + 1) ||
    DFS(board, row, col - 1, rows, cols, word, cur + 1) ||
    DFS(board, row, col + 1, rows, cols, word, cur + 1);

  board[row][col] = item;

  return res;
}
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  if (word.length === 0) return true;
  if (board.length === 0) return false;

  const rows = board.length;
  const cols = board[0].length;

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const hit = DFS(board, i, j, rows, cols, word, 0);
      if (hit) return true;
    }
  }
  return false;
};
```

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
  for (let y = 0; y < board.length; y++) {
    for (let x = 0; x < board[0].length; x++) {
      if (find(board, word, y, x, 0)) return true;
    }
  }
  return false;
};

function find(board, word, y, x, d) {
  if (d == word.length) return true;
  if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false;
  if (board[y][x] != word[d]) return false;
  let tmp = board[y][x];
  board[y][x] = '*';
  let exist =
    find(board, word, y, x + 1, d + 1) ||
    find(board, word, y, x - 1, d + 1) ||
    find(board, word, y + 1, x, d + 1) ||
    find(board, word, y - 1, x, d + 1);
  board[y][x] = tmp;
  return exist;
}

exist(
  [
    ['C', 'A', 'A'],
    ['A', 'A', 'A'],
    ['B', 'C', 'D'],
  ],
  'AAB',
);

//     // board 二维数组，word 查找的单词
//     public boolean exist(char[][] board, String word) {
//     char[] w = word.toCharArray();// 转为字符数组
//     for (int y = 0; y < board.length; y++) {
//         for (int x = 0; x < board[y].length; x++) {
//             // 遍历二维数组去求是否存在
//             if (exist(board, y, x, w, 0)) return true;
//         }
//     }
//     return false;
// }

//     // board 二位数组，第 x 列 第 y 行，查找的单词字符数组，i 是单词字符数组索引值
//     private boolean exist(char[][] board, int y, int x, char[] word, int i) {
//     if (i == word.length) return true; // 完全匹配，返回 true
//     if (y < 0 || x < 0 || y == board.length || x == board[y].length) return false; // x、y超出矩阵边界，返回 false
//     if (board[y][x] != word[i]) return false; // 字符不匹配，返回 false
//     board[y][x] ^= 256; // 按位异或，先将当前字符转为另外的字符，避免获取重复数值
//     boolean exist = exist(board, y, x + 1, word, i + 1)
//         || exist(board, y, x - 1, word, i + 1)
//         || exist(board, y + 1, x, word, i + 1)
//         || exist(board, y - 1, x, word, i + 1);
//     board[y][x] ^= 256; // 恢复当前值
//     return exist;
// }
```

### [83].从有序链表中删除重复节点

[83. Remove Duplicates from Sorted List (Easy)](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```html
Given 1->1->2, return 1->2. Given 1->1->2->3->3, return 1->2->3.
```

### [84].求解直方图里最大的矩形区域 largest-rectangle-in-histogram

堆栈

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  // 木桶原理
  // 暴力求解法 时间复杂度O(n^2) 空间复杂度O(1)
  // if (heights.length === 1) return heights[0];
  // let min = null;
  // let max = 0;
  // for (let i = 0; i < heights.length; i++) {
  //   min = heights[i];
  //   for (let j = i; j < heights.length; j++) {
  //     min = Math.min(min, heights[j]);
  //     max = Math.max((j - i + 1) * min, max);
  //   }
  // }
  // return max;
  // 上面的暴力求解，其实可以做一个小优化，就是通过取局部最大值来减少一部分重复计算，但是时间复杂度还是O(n^2)
  // 关键点： [1]. 单调栈(Monotone Stack),线性复杂度,因为所有元素只会进入栈一次，并且出栈后再也不会进栈了 [2].如果用暴力求解的话，你要会找出所有组合的方法(大部分题目都是两两组合，如果是任意组合的情况，暴力的话复杂度是2^n，
  // 这种情况，暴力求解通常不不取，需要考虑别的思路)
  // 当前题目就是两两组合 ，时间复杂度是O(n^2)，在可以接受的范围
  // 社区中流行的一种解法: 单调栈,  在这里我们需要使用单调递增栈
  // 时间复杂度O(n) 空间复杂度O(n)
  // const ascStack = [];
  // let max = 0;
  // heights.push(0); // hack, 为了使最后一个柱子也参与运算
  // for (let i = 0; i < heights.length; i++) {
  //   let p = i;
  //   while (
  //     ascStack.length > 0 &&
  //     heights[i] < heights[ascStack[ascStack.length - 1]]
  //   ) {
  //     // 由于是递增栈， height[p]一定是最小的，一定是短板
  //     p = ascStack.pop();
  //     max = Math.max(max, heights[p] * (ascStack.length === 0 ? i : i - p));
  //   }
  //   ascStack.push(i);
  // }
  // return max;
  // 相关题目： 雨水收集
  // 直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高
};
```

```js
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  let maxArea = 0;
  for (let i = 0; i < heights.length; i++) {
    let l = i,
      r = i,
      height = heights[i];
    while (l > 0) {
      if (heights[l - 1] >= height) {
        l--;
      } else {
        break;
      }
    }
    while (r < heights.length - 1) {
      if (heights[r + 1] >= height) {
        r++;
      } else {
        break;
      }
    }
    maxArea = Math.max(maxArea, (r - l + 1) * height);
  }
  return maxArea;
};

largestRectangleArea([2, 1, 5, 6, 2, 3]);
```

### [85].Maximal-Rectangle

```js
/**
 * https://leetcode-cn.com/problems/maximal-rectangle/description/
 * Difficulty:Hard
 * Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
 * For example, given the following matrix:
 *
 * 1 0 1 0 0
 * 1 0 1 1 1
 * 1 1 1 1 1
 * 1 0 0 1 0
 *
 * Return [6].
 *
 */

/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
  var m = matrix.length;
  if (!m) return 0;
  var n = matrix[0].length;
  if (!n) return 0;

  var dp = [];
  while (dp.push(new Array(n + 1).fill([0, 0])) <= m);
  var max = 0;
  for (var i = 1; i <= m; i++) {
    for (var j = 1; j <= n; j++) {
      if (matrix[i - 1][j - 1] != 0) {
        dp[i][j] = [1, 1];
        var top = dp[i - 1][j];
        var left = dp[i][j - 1];
        if (top[0] * top[1] === 0) {
          dp[i][j] = [1, left[1] + 1];
        } else if (left[0] * left[1] === 0) {
          dp[i][j] = [top[0] + 1, 1];
        } else {
          var x1 = top[0] + 1;
          var y1 = Math.min(top[1], left[1] + 1);
          var p1 = x1 * y1;

          var x2 = Math.min(left[0], top[0] + 1);
          var y2 = left[1] + 1;
          var p2 = x2 * y2;

          if (p1 >= p2) {
            dp[i][j] = [x1, y1];
          } else {
            dp[i][j] = [x2, y2];
          }
        }

        max = Math.max(max, dp[i][j][0] * dp[i][j][1]);
      }
    }
  }

  // for (var i = 0; i < matrix.length; i++) {
  //     console.log(matrix[i].split(''));
  // }
  // console.log('======================');
  //
  // for (var i = 1; i < dp.length; i++) {
  //     console.log(dp[i].slice(1).join(' | '));
  // }

  return max;
};

// console.log(maximalRectangle([
//     [1, 0, 1, 0, 0],
//     [1, 0, 1, 1, 1],
//     [1, 1, 1, 1, 1],
//     [1, 0, 0, 1, 0],
// ]));

// console.log(maximalRectangle(
//     ["1100", "1111", "11111", "1010"]
// ));

console.log(maximalRectangle(['10', '110', '11', '10']));
```

### [88].归并两个有序数组

[88. Merge Sorted Array (Easy)](https://leetcode-cn.com/problems/merge-sorted-array/)

```html
Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]
```

题目描述：把归并结果存到第一个数组上。

需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。

```js
var merge = function(nums1, m, nums2, n) {
  let k = m + n - 1,
    i = m - 1,
    j = n - 1;
  // nums2 数组循环完了就结束
  while (j >= 0) {
    // 末尾开始比较
    nums1[i] >= nums2[j] ? (nums1[k--] = nums1[i--]) : (nums1[k--] = nums2[j--]);
  }
};
```

### [91].解码的方法

一条包含字母  `A - Z`  的消息通过以下方式进行了编码：

```

'A' -> 1
'B' -> 2
'Z' -> 26

```

给定一个只包含数字的非空字符串，请计算解码方法的总数。

#### 解题思路

1.  就例题中的第二个例子，给定编码后的消息是字符串“226”，如果对其中“22”的解码有 m 种可能，那么，加多一个“6”在最后，相当于在最终解密出来的字符串里多了一个“F”字符而已，总体的解码还是只有 m 种。

2.  对于“6”而言，如果它的前面是”1”或者“2”，那么它就有可能是“16”，“26”，所以还可以再往前看一个字符，发现它是“26”。而前面的解码组合是 k 个，那么在这 k 个解出的编码里，添加一个“Z”，所以总的解码个数就是 m+k。

#### Code

```js
function numDecodings(s) {
  if (s.charAt(0) == '0') return;

  const chars = s.split();
  return decode(chars, chars.length - 1);
}

// 字符串转换成字符数组，利用递归函数  decode，从最后一个字符向前递归
function decode(chars, index) {
  //  处理到了第一个字符,只能有一种解码方法，返回  1
  if (index <= 0) return 1;

  let count = 0;

  const curr = chars[index];
  const prev = chars[index - 1];

  //  当前字符比  “0”  大，则直接利用它之前的字符串所求得的结果
  if (curr > '0') {
    count = decode(chars, index - 1);
  }

  //  由前一个字符和当前字符所构成的数字，值必须要在  1  到  26  之间，否则无法进行解码
  if (prev == '1' || (prev == '2' && curr <= '6')) {
    count += decode(chars, index - 2);
  }

  return count;
}
```

### [94].二叉树的中序遍历 binary-tree-inorder-traversal

中序遍历的顺序为： 左-根-右

```js
// 迭代: 栈实现
var inorderTraversal = function(root) {
  if (!root) return [];
  const stack = [root];
  const ret = [];
  let left = root.left;

  let item = null; // stack 中弹出的当前项

  // 左树压入栈中。
  while (left) {
    stack.push(left);
    left = left.left;
  }

  // stack 末尾是最左下的节点
  while ((item = stack.pop())) {
    ret.push(item.val);
    let t = item.right;

    while (t) {
      stack.push(t);
      t = t.left;
    }
  }

  return ret;
};
```

```js
// 迭代
var inorderTraversal = function(root) {
  const stack = [],
    res = [];
  // stack 用来存储根.
  while (root || stack.length) {
    if (root) {
      // 先往左，迭代存入所有的根
      stack.push(root);
      root = root.left;
    } else {
      // 拿出根之后，先压入左值
      root = stack.pop();
      res.push(root.val);
      root = root.right;
    }
  }
  return res;
};
```

```js
// 递归
const res = [];
var inorderTraversal = function(root) {
  if (root === null) return;
  // 左-中-右
  inorderTraversal(root.left);
  res.push(root);
  inorderTraversal(root.right);
  return res;
};
```

### [96].不同的二叉搜索树 Unique-Binary-Search-Trees

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

```
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

```js
/**
 * G(n): the number of unique BST for a sequence of length n.
 * F(i, n), 1 <= i <= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.
 *
 * G(n) = F(1, n) + F(2, n) + ... + F(n, n).
 * G(0)=1, G(1)=[1].
 *
 * F(i, n) = G(i-1) * G(n-i)    1 <= i <= n
 * G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)
 *
 *
 *
 */

/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  var dp = [1, 1];

  for (var i = 2; i <= n; i++) {
    dp[i] = 0;
    for (var j = 0; j < i; j++) {
      dp[i] += dp[j] * dp[i - j - 1];
    }
  }
  return dp[n];
};
```

### [98].验证二叉搜索树 validate-binary-search-tree

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例  1:

输入:

```
    2
   / \
  1   3
```

输出: true
示例  2:

输入:

```
    5
   / \
  1   4
     / \
    3   6
```

输出: false
解释: 输入为: `[5,1,4,null,null,3,6]`。根节点的值为 5 ，但是其右子节点值为 4 。

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

const binSearch = (tree, val) => {
  if (tree === null) return false;
  if (tree.val === val) return true;
  return val > tree.val ? binSearch(tree.right, val) : binSearch(tree.left, val);
};

const traverseAndValidate = (root, tree) => {
  if (tree === null || root === null) return true;
  if (!binSearch(root, tree.val)) return false;
  return traverseAndValidate(root, tree.left) && traverseAndValidate(root, tree.right);
};

export default function isValidBST(root) {
  const values = [];
  // BFS
  const queue = [];
  if (root) queue.push(root);
  while (queue.length) {
    const item = queue.shift();
    values.push(item.val);
    if (item.left) queue.push(item.left);
    if (item.right) queue.push(item.right);
  }
  // Validate if BST has duplicates (BST does not allow duplicates)
  const set = new Set(values);
  if (set.size !== values.length) return false;
  return traverseAndValidate(root, root);
}
```

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
let isValid = true;

var isValidBST = function(root) {
  if (root == null) return true;
  helper(root);
  return isValid;
};

function helper(node) {
  if (node == null) return;
  if (node.left != null) {
    if (node.left.val > node.val) {
      isValid = false;
      return;
    }
    helper(node.left);
  }
  if (node.right != null) {
    if (node.right.val < node.val) {
      isValid = false;
      return;
    }
    helper(node.right);
  }
}
```

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  return validate(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
};

const validate = (node, min, max) => {
  if (!node) {
    return true;
  }

  if (node.val < min || node.val > max) {
    return false;
  }

  return validate(node.left, min, node.val - 1) && validate(node.right, node.val + 1, max);
};
```

### [100].相同的树

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```js
var isSameTree = function(p, q) {
  function traversal(root1, root2) {
    // 两个都是空树，判定为一样
    if (root1 === null && root2 === null) return true;
    // 一个未空树，另一个不是，自然不同
    else if ((root1 === null && root2 !== null) || (root1 !== null && root2 === null)) {
      return false;
    } else {
      // 接着判定树的值、左树以及右树
      return root1.val === root2.val && traversal(root1.left, root2.left) && traversal(root1.right, root2.right);
    }
  }
  return traversal(p, q);
};
```
