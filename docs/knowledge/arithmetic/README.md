---
layout: CustomPages
title: 算法
date: 2020-10-22
aside: false
draft: true
---

<!-- https://juejin.cn/post/6847009772500156429 -->

## 高频题

- 冒泡排序
- 快速排序
- 回文字符串
- 两数之和、k sum
- 大数相加
- 二分查找
- 二叉树前中后遍历
- 二叉树层次遍历
- 二叉树深度优先遍历(递归、非递归)
- 二叉树广度优先遍历(递归、非递归)
- 和为 n 的二叉树路径
- 二叉树深度
- 二叉树是否对称
- 寻找两个二叉树节点的第一个公共父节点。先说思路再写代码，写完之后问了我下复杂度
- 什么是完全二叉树，节点个数
- 链表反转
- 链表是否为环
- 16 进制转 10 进制
- 括号的判断。（栈）
- 两个链表的第一个公共结点
- 数组顺时针螺旋遍历
- 二分搜索、查找， 时间复杂度咋样

## 知识点梳理

- 常见的数据结构
  - 栈、队列、链表
  - 集合、字典、散列集
- 常见算法
  - 递归
  - 排序
  - 枚举
- 算法复杂度分析
- 算法思维
  - 分治
  - 贪心
  - 动态规划
- 高级数据结构
  - 树、图
  - 深度优先和广度优先搜索

## 前端常遇见的数据结构问题

- 简单数据结构(必须理解掌握)
  - 有序数据结构:栈、队列、链表，有序数据结构省空间(存储空间小)
  - 无序数据结构:集合、字典、散列表，无序数据结构省时间(读取时间快)
- 复杂数据结构
  - 树、堆
  - 图

常用和高级数据结构、排序、递归和回溯、优先搜索、动态规划、贪婪与二分搜索.

## 算法技巧

### 基础

1. 快排
2. 二分搜索

#### 快排和二分查找

### 链表

#### 5 个常见的操作

1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第 n 个结点
5. 求链表的中间结点
6. 链表相交判断，找到相交的点。

### 树

1. 先序遍历、前序遍历、后续遍历
2. 还原树结构
3. 完全二叉树、搜索树。 以及一些公式等
4. 二叉树的之字形层序遍历

#### 二叉树的非递归中序遍历

几种遍历方式。

### 矩阵

1. L 型数据遍历

### 统计次数

1. 一个 int 整型数组 如何找出出现次数最多的数字 要求空间复杂度最小？

### 位运算

位运算在算法中很有用，速度可以比四则运算快很多。

在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式

- 十进制 `33` 可以看成是 `32 + 1` ，并且 `33` 应该是六位二进制的(因为 `33` 近似 `32`，而 `32` 是 2 的五次方，所以是六位)，那么 十进制 `33` 就是 `100001` ，只要是 2 的次方，那么就是 1 否则都为 0
- 那么二进制 `100001` 同理，首位是 `2^5` ，末位是 `2^0` ，相加得出 33

#### 左移 <<

```js
10 << 1; // -> 20
```

左移就是将二进制全部往左移动，`10` 在二进制中表示为 `1010` ，左移一位后变成 `10100` ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 `a * (2 ^ b)`

#### 算数右移 >>

```js
10 >> 1; // -> 5
```

算数右移就是将二进制全部往右移动并去除多余的右边，`10` 在二进制中表示为 `1010` ，右移一位后变成 `101` ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 `int v = a / (2 ^ b)`

右移很好用，比如可以用在二分算法中取中间值

```js
13 >> 1; // -> 6
```

#### 按位操作

**按位与**

每一位都为 1，结果才为 1

```js
8 & 7; // -> 0
// 1000 & 0111 -> 0000 -> 0
```

**按位或**

其中一位为 1，结果就是 1

```js
8 | 7; // -> 15
// 1000 | 0111 -> 1111 -> 15
```

**按位异或**

每一位都不同，结果才为 1

```js
8 ^ 7; // -> 15
8 ^ 8; // -> 0
// 1000 ^ 0111 -> 1111 -> 15
// 1000 ^ 1000 -> 0000 -> 0
```

从以上代码中可以发现按位异或就是不进位加法

**面试题**：两个数不使用四则运算得出和

这道题中可以按位异或，因为按位异或就是不进位加法，`8 ^ 8 = 0` 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 `a + b = (a ^ b) + ((a & b) << 1)` ，然后通过迭代的方式模拟加法

```js
function sum(a, b) {
  if (a == 0) return b;
  if (b == 0) return a;
  let newA = a ^ b;
  let newB = (a & b) << 1;
  return sum(newA, newB);
}
```

### 堆

- 查找最大的 K 个数

### 其他

1. 移动零（双指针）
2. 两数之和
3. 扑克牌排列组合
