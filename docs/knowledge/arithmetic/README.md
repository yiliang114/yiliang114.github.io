---
title: 算法
date: 2020-10-22
aside: false
draft: true
---

<!-- https://juejin.cn/post/6847009772500156429 -->

## 高频题

- 冒泡排序
- 快速排序
- 回文字符串
- 两数之和、k sum
- 大数相加
- 二分查找
- 二叉树前中后遍历
- 二叉树层次遍历
- 二叉树深度优先遍历(递归、非递归)
- 二叉树广度优先遍历(递归、非递归)
- 和为 n 的二叉树路径
- 二叉树深度
- 二叉树是否对称
- 寻找两个二叉树节点的第一个公共父节点。先说思路再写代码，写完之后问了我下复杂度
- 什么是完全二叉树，节点个数
- 链表反转
- 链表是否为环
- 16 进制转 10 进制
- 括号的判断。（栈）
- 两个链表的第一个公共结点
- 数组顺时针螺旋遍历
- 二分搜索、查找， 时间复杂度咋样

## 知识点梳理

- 常见的数据结构
  - 栈、队列、链表
  - 集合、字典、散列集
- 常见算法
  - 递归
  - 排序
  - 枚举
- 算法复杂度分析
- 算法思维
  - 分治
  - 贪心
  - 动态规划
- 高级数据结构
  - 树、图
  - 深度优先和广度优先搜索

## 前端常遇见的数据结构问题

- 简单数据结构(必须理解掌握)
  - 有序数据结构:栈、队列、链表，有序数据结构省空间(存储空间小)
  - 无序数据结构:集合、字典、散列表，无序数据结构省时间(读取时间快)
- 复杂数据结构
  - 树、堆
  - 图

常用和高级数据结构、排序、递归和回溯、优先搜索、动态规划、贪婪与二分搜索.

## 大厂常考算法合集

### 字节

<!-- https://leetcode-cn.com/explore/interview/card/bytedance/242/string/ -->

### 阿里

比较版本号 compare-version-numbers 中等
两数之和 two-sum 简单
二分查找 binary-search 简单
二叉树的中序遍历 binary-tree-inorder-traversal 中等
二叉树的层序遍历 binary-tree-level-order-traversal 中等
爬楼梯 climbing-stairs 简单
判断子序列 is-subsequence 简单
二叉搜索树中的搜索 search-in-a-binary-search-tree 简单
三数之和 3sum 中等
翻转字符串里的单词 reverse-words-in-a-string 中等
在排序数组中查找元素的第一个和最后一个位置 find-first-and-last-position-of-element-in-sorted-array 中等
压缩字符串 string-compression 中等
相交链表 intersection-of-two-linked-lists 简单
合并区间 merge-intervals 中等
有效的括号 valid-parentheses 简单
无重复字符的最长子串 longest-substring-without-repeating-characters 中等
最长公共子序列 longest-common-subsequence 中等
青蛙跳台阶问题 qing-wa-tiao-tai-jie-wen-ti-lcof 简单
最长不含重复字符的子字符串 zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof 中等
矩形重叠 rectangle-overlap 简单
K 个一组翻转链表 reverse-nodes-in-k-group 困难

### 快手

合并两个有序数组 merge-sorted-array 简单
反转链表 reverse-linked-list 简单
整数反转 reverse-integer 简单
全排列 permutations 中等
平衡二叉树 balanced-binary-tree 简单
无重复字符的最长子串 longest-substring-without-repeating-characters 中等
打乱数组 shuffle-an-array 中等
爬楼梯 climbing-stairs 简单
两数之和 two-sum 简单
字符串相加 add-strings 简单
相交链表 intersection-of-two-linked-lists 简单
最小路径和 minimum-path-sum 中等
二叉树的最大深度 maximum-depth-of-binary-tree 简单
二叉树的层序遍历 binary-tree-level-order-traversal 中等
2 的幂 power-of-two 简单
买卖股票的最佳时机 best-time-to-buy-and-sell-stock 简单
多数元素 majority-element 简单
二分查找 binary-search 简单
斐波那契数 fibonacci-number 简单
斐波那契数列 fei-bo-na-qi-shu-lie-lcof 简单

### 合集

121: 买卖股票的最佳时机 (简单) >50 次
2: 两数相加 (中等) >50 次
20: 有效的括号 (简单) >50 次
3: 无重复字符的最长子串 (中等) >50 次
25: K 个一组翻转链表 (困难) >50 次
42: 接雨水 (困难) >50 次
200: 岛屿数量 (中等) >50 次
146: LRU 缓存机制 (中等) 10~50 次
206: 反转链表 (简单) 10~50 次
4: 寻找两个正序数组的中位数 (困难) 10~50 次
53: 最大子序和 (简单) 10~50 次
236: 二叉树的最近公共祖先 (中等) 10~50 次
1: 两数之和 (简单) 10~50 次
300: 最长递增子序列 (中等) 10~50 次
124: 二叉树中的最大路径和 (困难) 10~50 次
14: 最长公共前缀 (简单) 10~50 次
21: 合并两个有序链表 (简单) 10~50 次
15: 三数之和 (中等) 10~50 次
215: 数组中的第 K 个最大元素 (中等) 10~50 次
41: 缺失的第一个正数 (困难) 10~50 次
23: 合并 K 个升序链表 (困难) 10~50 次
72: 编辑距离 (困难) 10~50 次
33: 搜索旋转排序数组 (中等) 10~50 次
239: 滑动窗口最大值 (困难) 10~50 次
46: 全排列 (中等) 10~50 次
141: 环形链表 (简单) 10~50 次
17: 电话号码的字母组合 (中等) 10~50 次
415: 字符串相加 (简单) 10~50 次
5: 53.1% (中等) 10~50 次
76: 最小覆盖子串 (困难) 10~50 次
70: 爬楼梯 (简单) 10~50 次
283: 移动零 (简单) 10~50 次
122: 买卖股票的最佳时机 II (简单) 10~50 次
102: 二叉树的层序遍历 (中等) 10~50 次
148: 排序链表 (中等) 10~50 次
221: 最大正方形 (中等) 10~50 次
543: 二叉树的直径 (简单) 10~50 次
143: 重排链表 (中等) 10~50 次
11: 盛最多水的容器 (中等) 10~50 次
297: 二叉树的序列化与反序列化 (困难) 10~50 次
123: 买卖股票的最佳时机 III (困难) 10~50 次
64: 最小路径和 (中等) 10~50 次
100: 相同的树 (简单) 10~50 次
54: 螺旋矩阵 (中等) 10~50 次
153: 寻找旋转排序数组中的最小值 (中等) 10~50 次
55: 跳跃游戏 (中等) 10~50 次
92: 反转链表 II (中等) 10~50 次
160: 相交链表 (简单) 10~50 次

## 常见

找最长子字符串

```
string s1807 = "x1807";
for (int i = 0; i < s.length(); i++)
{
    for (int j = 1; j < 5; j++)
    {
        if (s[i] == s1807[j])
        {
            dp[i + 1][j] = max(dp[i][j - 1], dp[i][j]) + 1;
        }
        else
        {
            dp[i + 1][j] = dp[i][j];
        }
    }
}
```

背包问题
由序列化先序遍历求中序遍历

## 算法技巧

### 基础

1. 快排
2. 二分搜索

### 链表

#### 5 个常见的操作

1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第 n 个结点
5. 求链表的中间结点
6. 链表相交判断，找到相交的点。

### 树

1. 先序遍历、前序遍历、后续遍历
2. 还原树结构
3. 完全二叉树、搜索树。 以及一些公式等
4. 二叉树的之字形层序遍历

#### 树的遍历

1. 前序遍历(Preorder Traversal)： 中 -> 左 -> 右。 应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。
2. 中序遍历(Inorder Traversal)：左 -> 中 -> 右。应用场景：最常见的是二叉搜索树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。
3. 后序遍历(Postorder Traversal)：左 -> 右 -> 中。应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。

练习一道经典的 LeetCode 第 250 题，在一棵二叉树里，统计有多少棵子树，要求子树里面的元素拥有相同的数字。

#### 二叉树的非递归中序遍历

几种遍历方式。

### 矩阵

1. L 型数据遍历

### 统计次数

1. 一个 int 整型数组 如何找出出现次数最多的数字 要求空间复杂度最小？

### 位运算

位运算在算法中很有用，速度可以比四则运算快很多。

在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式

- 十进制 `33` 可以看成是 `32 + 1` ，并且 `33` 应该是六位二进制的(因为 `33` 近似 `32`，而 `32` 是 2 的五次方，所以是六位)，那么 十进制 `33` 就是 `100001` ，只要是 2 的次方，那么就是 1 否则都为 0
- 那么二进制 `100001` 同理，首位是 `2^5` ，末位是 `2^0` ，相加得出 33

#### 左移 <<

```js
10 << 1; // -> 20
```

左移就是将二进制全部往左移动，`10` 在二进制中表示为 `1010` ，左移一位后变成 `10100` ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 `a * (2 ^ b)`

#### 算数右移 >>

```js
10 >> 1; // -> 5
```

算数右移就是将二进制全部往右移动并去除多余的右边，`10` 在二进制中表示为 `1010` ，右移一位后变成 `101` ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 `int v = a / (2 ^ b)`

右移很好用，比如可以用在二分算法中取中间值

```js
13 >> 1; // -> 6
```

#### 按位操作

**按位与**

每一位都为 1，结果才为 1

```js
8 & 7; // -> 0
// 1000 & 0111 -> 0000 -> 0
```

**按位或**

其中一位为 1，结果就是 1

```js
8 | 7; // -> 15
// 1000 | 0111 -> 1111 -> 15
```

**按位异或**

每一位都不同，结果才为 1

```js
8 ^ 7; // -> 15
8 ^ 8; // -> 0
// 1000 ^ 0111 -> 1111 -> 15
// 1000 ^ 1000 -> 0000 -> 0
```

从以上代码中可以发现按位异或就是不进位加法

**面试题**：两个数不使用四则运算得出和

这道题中可以按位异或，因为按位异或就是不进位加法，`8 ^ 8 = 0` 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 `a + b = (a ^ b) + ((a & b) << 1)` ，然后通过迭代的方式模拟加法

```js
function sum(a, b) {
  if (a == 0) return b;
  if (b == 0) return a;
  let newA = a ^ b;
  let newB = (a & b) << 1;
  return sum(newA, newB);
}
```

### 堆

- 查找最大的 K 个数

### 其他

1. 移动零（双指针）
2. 两数之和
3. 扑克牌排列组合

## 基础算法

### 快排

O(nlogn)

```js
function swap(a, i, j) {
  let temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}

function quickSort(arr, start = 0, end = arr.length - 1) {
  if (arr && arr.length < 2) return arr;
  if (start >= end) return;

  let target = arr[start],
    i = start,
    j = end;

  while (i < j) {
    while (target <= a[j] && i < j) j--;
    while (target >= a[i] && i < j) i++;

    if (i < j) swap(arr, i, j);
  }

  // i === j
  swap(arr, start, i);
  quickSort(arr, start, i - 1);
  quickSort(arr, i + 1, end);

  return arr;
}
```

### 其他排序算法和复杂度

### 十六进制转十进制

### 爬楼梯问题(经典 DP）

### 请使用 JavaScript 编写一个树的深度优先遍历函数（节点最深的最先访问到，依次类推），满足以下测试用例

```js
// 假设树的结构如下：
const tree = [
    {
        id: 1,
        name: '张三',
        children: [
            {
                id: 2,
                name: '李四',
                children: [
                    {
                        id: 5,
                        name: '张五'
                    }
                ]
            }
        ]
    }，
    {
        id: 6,
        name: '玛丽'
    }
]

//测试用例：
//1. 生成一棵新树，姜将所有节点的id,加1
console.log(treeMap(tree, node => {
    let newNode = { ...node }
    newNode.id = node.id + 1
    return newNode
}))
//打印的新树，应该与tree的结构一致，只是每个id自增1，老的tree，应该没有任何改动
//2.打印每个节点的id
treeMap(tree, node => {
    console.log(node.id)
    return node
});
//应打印顺序应该是：5,2,1,6
//3. 对于非法输入，应直接返回第一个入参
console.log(treeMap(null)) //输出null
console.log(treeMap(tree,true/*不是函数*/))  //输出tree
```

### 请使用 JavaScript 实现一个 getIntersection 函数，可获取多个区间的交集，规则如下

```js
function compa(a, b) {
  if (a instanceof Array && b instanceof Array && a.length != 0 && b.length != 0) {
    let a1 = a.sort();
    let b1 = b.sort();
    if (typeof a1[0] == 'number' && typeof a1[1] == 'number' && typeof b1[0] == 'number' && typeof b1[1] == 'number') {
      let arr = [];
      if (b1[0] >= a1[0] && b1[0] <= a1[1]) {
        arr.push(b1[0]);
        if (b1[1] <= a1[1]) {
          arr.push(b1[1]);
        } else {
          arr.push(a1[1]);
        }
        return arr;
      } else {
        if (b1[0] <= a1[0] && b1[1] >= a1[0]) {
          arr.push(a1[0]);
          if (b1[1] >= a1[1]) {
            arr.push(a1[1]);
          } else {
            arr.push(b1[1]);
          }
          return arr;
        } else {
          return null;
        }
      }
    } else {
      return null;
    }
  } else {
    if (a == null && b != null) {
      if (typeof b[0] == 'number' && typeof b[1] == 'number') {
        return b;
      } else {
        return null;
      }
    } else if (a != null && b == null) {
      if (typeof a[0] == 'number' && typeof a[1] == 'number') {
        return a;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
}
function getIntersection(...arg) {
  let a = [];
  for (let i = 0; i < arg.length; i += 2) {
    if (i == 0) {
      a = compa(arg[i], arg[i + 1]);
    } else {
      if (a == null) {
        return null;
      } else {
        a = compa(a, arg[i]);
      }
    }
  }
}

getIntersection([1, 4], [3, 5]); // return [3,4]
getIntersection([5, 2], [4, 9], [3, 6]); //return [4,5]
getIntersection([1, 7], [8, 9]); //return null
getIntersection(['x', 7], [4, 9]); //return null
getIntersection([1, 2]); //return [1,2]
getIntersection([1, 2], [2, 3]); //return [2,2]
```
