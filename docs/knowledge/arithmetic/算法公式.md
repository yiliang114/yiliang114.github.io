---
layout: CustomPages
title: 算法公式
date: 2020-11-29
aside: false
draft: true
---

## String

### 回文

#### 回文判断

```js
var isPalindrome = function(s) {
  // \w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
  s = s.replace(/[^\w]/g, '').toLowerCase();
  return (
    s
      .split('')
      .reverse()
      .join('') === s
  );
};
```

#### 回文数

转成字符串方式 (感觉这样会比较快)

1. 负数都是非回文数，10 的整数倍不是回文。
2. 将数字转为字符串，再逆序排列字符串。两者比较，相等就是回文数。

直接操作整数方式

1. 复制 x 到 temp;
2. 取 temp 末尾数字，方式为 temp 与 10 的求余；组成新数 reverse;
3. 每取完一位,temp 缩小 10 倍并且去掉小数。
4. reverse 要`先扩大十倍`再加上取下来的数
5. 当 temp === 0 时，表示已经取完；reverse 与 x 比较

```js
/**
 * @param {number} x
 * @return {boolean}
 * 转成字符串
 */
var isPalindrome = function(x) {
  if (x < 0) return false;
  if (x === 0) return true;
  if (x % 10 === 0) return false;
  const str = x + '';
  const reverse = str
    .split('')
    .reverse()
    .join('');
  return str === reverse;
};

/**
 * 性能比字符串翻转好的多
 * @param {number} x
 * @return {boolean}
 * 不转成字符串
 */
var isPalindrome = function(x) {
  if (x < 0) return false;
  if (x === 0) return true;
  if (x % 10 === 0) return false;
  let temp = x;
  let reverse = 0;
  while (temp > 0) {
    let num = temp % 10;
    temp = (temp - num) / 10; // 或 temp = (temp / 10) >> 0,去除小数位
    reverse = reverse * 10 + num;
  }
  return x === reverse;
};
```

### 二分查找

在计算 mid 时不能使用 `mid = (i + j) / 2` 这种方式，因为 `i + j` 可能会导致加法溢出，应该使用 `mid = i + (i - j) / 2`

非递归版本：

```js
const binarySearch = (arr, target) => {
  let i = 0,
    j = arr.length - 1;
  while (i <= j) {
    let mid = i + ((j - i) >> 1);
    if (target === arr[mid]) return mid;
    if (target < arr[mid]) {
      j = mid - 1;
    } else {
      i = mid + 1;
    }
  }
  return -1;
};
```

递归版本：

```js
const binarySearch = (a, left, right, key) => {
  const mid = (left + right) >> 1;
  if (a[mid] === key) return mid;
  if (a[mid] > key) return binarySearch(a, left, mid - 1, key);
  if (a[mid] < key) return binarySearch(a, mid + 1, right, key);
};
```

### 洗牌算法 shuffle

#### Fisher-Yates

其算法思想就是 从原始数组中随机抽取一个新的元素到新数组中

1. 从还没处理的数组（假如还剩 n 个）中，产生一个[0, n]之间的随机数 random
1. 从剩下的 n 个元素中把第 random 个元素取出到新数组中
1. 删除原数组第 random 个元素
1. 重复第 2 3 步直到所有元素取完
1. 最终返回一个新的打乱的数组

```js
function shuffle(arr) {
  var result = [],
    random;
  while (arr.length > 0) {
    random = Math.floor(Math.random() * arr.length);
    result.push(arr[random]);
    arr.splice(random, 1);
  }
  return result;
}
```

#### other

```js
[1, 2, 3, 4, 5, 6].sort(function() {
  return 0.5 - Math.random();
});
```

#### Knuth-Durstenfeld shuffle

Fisher-Yates 洗牌算法的一个变种是 Knuth Shuffle

每次从未处理的数组中随机取一个元素，然后把该元素放到数组的尾部，即数组的尾部放的就是已经处理过的元素，这是一种原地打乱的算法，每个元素随机概率也相等，时间复杂度从 Fisher 算法的 O(n2)提升到了 O(n)

1. 选取数组(长度 n)中最后一个元素(arr[length-1])，将其与 n 个元素中的任意一个交换，此时最后一个元素已经确定
1. 选取倒数第二个元素(arr[length-2])，将其与 n-1 个元素中的任意一个交换
1. 重复第 1 2 步，直到剩下 1 个元素为止

```js
function shuffle(arr) {
  let n = arr.length,
    random;
  while (0 != n) {
    random = (Math.random() * n--) >>> 0; // 无符号右移位运算符向下取整
    [arr[n], arr[random]] = [arr[random], arr[n]]; // ES6的结构赋值实现变量互换
  }
  return arr;
}
```

## 斐波那契

```js
var fib = function(n) {
  if (n < 2) return n;
  let i = 0,
    j = 1;
  // 0 1 已经存在了。。。
  while (n > 1) {
    [i, j] = [j, (i + j) % 1000000007];
    n--;
  }
  return j;
};
```

## 二分查找

```js
const binarySearch = (arr, target) => {
  let i = 0,
    j = arr.length - 1;
  while (i <= j) {
    let mid = i + ((j - i) >> 1);
    if (target === arr[mid]) return mid;
    if (target < arr[mid]) {
      j = mid - 1;
    } else {
      i = mid + 1;
    }
  }
  return -1;
};
```

## 数组

### 求数组里面最大连续项的和

```js
// [1, -2, 3, 4, -1, 5];
function getMaxSum(arr) {
  let dp = new Array(arr.length).fill(0);

  dp[0] = arr[0];
  let maxSum = 0;

  for (let i = 1; i < arr.length; i++) {
    dp[i] = Math.max(arr[i], dp[i - 1] + arr[i]);

    if (dp[i] > maxSum) {
      maxSum = dp[i];
    }
  }
  return maxSum;
}

console.log(getMaxSum([1, -2, 3, 4, -1, 5]));
```

### 数组全排列

递归: 当前数组的全排列 = 当前数组任一元素 + 当前数组剩余元素的全排列

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    if(nums.length === 1) return [nums];
    var res = [];
    for(var i = 0; i < nums.length; i++){
        var res1 = permute(nums.slice(0,i).concat(nums.slice(i+1,nums.length)));
        res1.forEach((item) => {
            res.push([nums[i]].concat(item));
        })
    }
    return res;
};

作者：leoren
链接：https://leetcode-cn.com/problems/permutations/solution/javascript-di-gui-dang-qian-shu-zu-de-quan-pai-lie/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 树 Tree

### 遍历方式

先序遍历：若二叉树非空，访问根结点，遍历左子树，遍历右子树。
中序遍历：若二叉树非空，遍历左子树；访问根结点；遍历右子树。
后序遍历：若二叉树非空，遍历左子树；遍历右子树；访问根结点。

### 介绍二叉搜索树的特点

## 链表 Linked

### 实现一个 LRU 缓存函数

LRU（Least recently used，最近最少使用）算法。该算法的观点是，最近被访问的数据那么它将来访问的概率就大，缓存满的时候，优先淘汰最无人问津者。

算法实现思路：基于一个双链表的数据结构，在没有满员的情况下，新来的 k-v 放在链表的头部，以后每次获取缓存中的 k-v 时就将该 k-v 移到最前面，缓存满的时候优先淘汰末尾的。

```js
var LinkNode = function(key, value) {
  this.key = key;
  this.value = value;
  this.next = null;
  this.pre = null;
};
var DoubleLinkedList = function() {
  this.size = 0;
  this.head = new LinkNode();
  this.tail = new LinkNode();
  this.head.next = this.tail;
  this.tail.pre = this.head;
};

DoubleLinkedList.prototype.addNode = function(node) {
  if (!(node instanceof LinkNode)) throw new Error('param must be a LinkNode');
  // 插入节点时，使用尾插法。这里可以利用双向链表一直在尾结点前驱插入节点。
  const preNode = this.tail.pre;
  const nextNode = this.tail.pre.next;
  node.pre = preNode;
  node.next = nextNode;
  preNode.next = node;
  nextNode.pre = node;
  this.size++;
};

DoubleLinkedList.prototype.deleteNode = function(node) {
  if (!(node instanceof LinkNode)) throw new Error('param must be a LinkNode');
  // 将刚刚访问过的节点插入到链表最后一位。
  const preNode = node.pre;
  const nextNode = node.next;
  preNode.next = nextNode;
  nextNode.pre = preNode;
  this.size--;
};

DoubleLinkedList.prototype.refreshList = function(node) {
  this.deleteNode(node);
  this.addNode(node);
};

/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
  this.maxSize = capacity;
  this.map = new Map();
  this.doubleLinkedList = new DoubleLinkedList();
};

/**
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if (this.map.get(key) === undefined) return -1;
  const curNode = this.map.get(key);
  this.doubleLinkedList.refreshList(curNode);
  return curNode.value;
};

/**
 * @param {number} key
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  const newNode = new LinkNode(key, value);
  //  如果key已经存在，则变更其值
  if (this.map.get(key)) {
    this.doubleLinkedList.refreshList(this.map.get(key));
    return (this.map.get(key).value = value);
  }
  if (this.map.size < this.maxSize) {
    this.doubleLinkedList.addNode(newNode);
  } else {
    // 需要清理链表中的首元节点,并将新节点插入到尾部
    const firstNode = this.doubleLinkedList.head.next;
    this.doubleLinkedList.deleteNode(firstNode);
    this.doubleLinkedList.addNode(newNode);
    // 同时需要清理掉散列表中的key
    this.map.delete(firstNode.key);
  }
  this.map.set(key, newNode);
};
```

### 链表翻转

### 链表是否有环

## DP

## 排序

介绍冒泡排序，选择排序，冒泡排序如何优化
