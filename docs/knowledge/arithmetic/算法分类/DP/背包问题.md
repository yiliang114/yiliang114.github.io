---
layout: CustomPages
title: 动态规划-DP-背包问题
date: 2020-11-14
aside: false
draft: true
---

## 背包问题

### 0-1 背包

在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 `dp[i-1][j]` 也可以表示 dp[i][j]。此时，

因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。

```js
function knapsack(weights = [], values = [], W) {
  // 初始值需要赋值为 0
  const dp = new Array(W + 1).fill(0);
  const N = weights.length;
  for (let i = 1; i <= N; i++) {
    let w = weights[i - 1],
      v = values[i - 1];
    for (let j = W; j >= 1; j--) {
      if (j >= w) {
        dp[j] = Math.max(dp[j], dp[j - w] + v);
      }
    }
  }
  console.log(dp);
  return dp[W];
}
```

**无法使用贪心算法的解释**

0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.

| id  | w   | v   | v/w |
| --- | --- | --- | --- |
| 0   | 1   | 6   | 6   |
| 1   | 2   | 10  | 5   |
| 2   | 3   | 12  | 4   |

**变种**

- 完全背包：物品数量为无限个

- 多重背包：物品数量有限制

- 多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制

- 其它：物品之间相互约束或者依赖

### 01 背包问题

有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci ，得到的 价值是 Wi。
求解将哪些物品装入背包可使价值总和最大。

`F[i, v] = max{ F[i − 1, v], F[i − 1, v − Ci ] + Wi }`

```js
/**
 * @param Cost
 * @param Worth
 * @param V
 * @returns {*}
 */
function pack(Cost, Worth, V) {
  var n = Cost.length;
  var dp = [];
  while (dp.push(new Array(V + 1).fill(0)) < n + 1);

  for (var i = 1; i < n + 1; i++) {
    for (var j = 1; j < V + 1; j++) {
      dp[i][j] = dp[i - 1][j];
      if (j > Cost[i - 1]) {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - Cost[i - 1]] + Worth[i - 1]);
      }
    }
  }

  for (var i = 1; i < dp.length; i++) {
    console.log(dp[i].slice(1));
  }
  console.log(dp);
  return dp[n][V];
}

console.log(pack([5, 4, 7, 2, 6], [12, 3, 10, 3, 6], 15));
```

### 02

```js
/**
 * 2 完全背包问题
 * 有 N 种物品和一个容量为 V 的背包，
 * 每种物品都有无限件可用。放入第 i 种物品 的费用是 Ci，价值是 Wi。
 * 求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。
 *
 * F[i, v] = max{F[i − 1, v − k*Ci ] + k*Wi | 0 ≤ k*Ci ≤ v}
 *
 * @param Cost
 * @param Worth
 * @param V
 */
function pack(Cost, Worth, V) {
  var n = Cost.length;
  var dp = [];
  while (dp.push(new Array(V + 1).fill(0)) < n + 1);

  for (var i = 1; i < n + 1; i++) {
    for (var v = 1; v < V + 1; v++) {
      var c = Cost[i - 1];
      var w = Worth[i - 1];
      var count = Math.floor(v / c);
      var max = 0;
      for (var t = 0; t <= count; t++) {
        var newV = dp[i - 1][v - t * c] + t * w;
        if (newV > max) max = newV;
      }
      dp[i][v] = max;
    }
  }

  for (var i = 1; i < dp.length; i++) {
    console.log(dp[i].slice(1));
  }

  return dp[n][V];
}

console.log(pack([3, 2, 1], [7, 3, 1], 16));
console.log(pack([3, 2, 1], [7, 3, 1], 17));
console.log(pack([5, 4, 7, 2, 6], [12, 3, 10, 3, 6], 15));
console.log(pack([5, 4, 7, 2, 6], [12, 3, 10, 3, 6], 17));
```

### 03

```js
/**
 * 3 多重背包问题
 * 有 N 种物品和一个容量为 V 的背包。
 * 第 i 种物品最多有 Mi 件可用，每件耗费的 空间是 Ci ，价值是 Wi 。
 * 求解将哪些物品装入背包可使这些物品的耗费的空间总和不超 过背包容量，且价值总和最大。
 *
 * F[i，v] = max{F[i − 1, v − k∗Ci ] + k∗Wi | 0 ≤ k ≤ Mi }
 *
 * @param Cost
 * @param Worth
 * @param Much
 * @param V
 */
function pack(Cost, Worth, Much, V) {
  var n = Cost.length;
  var dp = [];
  while (dp.push(new Array(V + 1).fill(0)) < n + 1);

  for (var i = 1; i < n + 1; i++) {
    for (var v = 1; v < V + 1; v++) {
      var c = Cost[i - 1];
      var w = Worth[i - 1];
      var count = Math.min(Math.floor(v / c), Much[i - 1]);
      var max = 0;
      for (var t = 0; t <= count; t++) {
        var newV = dp[i - 1][v - t * c] + t * w;
        if (newV > max) max = newV;
      }
      dp[i][v] = max;
    }
  }

  for (var i = 1; i < dp.length; i++) {
    console.log(dp[i].slice(1));
  }

  return dp[n][V];
}

console.log(pack([5, 4, 7, 2, 6], [12, 3, 10, 3, 6], [2, 2, 1, 2, 7], 15));
console.log(pack([5, 4, 7, 2, 6], [12, 3, 10, 3, 6], [3, 2, 1, 2, 7], 15));
console.log(pack([5, 4, 7, 2, 6], [12, 3, 10, 3, 6], [3, 2, 1, 2, 7], 17));
```

### 0 - 1 背包问题

给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。

定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：

- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。
- 第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。

第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大

```js
/**
 * @param {*} w 物品重量
 * @param {*} v 物品价值
 * @param {*} C 总容量
 * @returns
 */
function knapsack(w, v, C) {
  let length = w.length;
  if (length === 0) return 0;

  // 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量
  // 第二维中的元素代表背包物品总价值
  let array = new Array(length).fill(new Array(C + 1).fill(null));

  // 完成底部子问题的解
  for (let i = 0; i <= C; i++) {
    // 对照表格第一行， array[0] 代表物品 1
    // i 代表剩余总容量
    // 当剩余总容量大于物品 1 的重量时，记录下背包物品总价值，否则价值为 0
    array[0][i] = i >= w[0] ? v[0] : 0;
  }

  // 自底向上开始解决子问题，从物品 2 开始
  for (let i = 1; i < length; i++) {
    for (let j = 0; j <= C; j++) {
      // 这里求解子问题，分别为不放当前物品和放当前物品
      // 先求不放当前物品的背包总价值，这里的值也就是对应表格中上一行对应的值
      array[i][j] = array[i - 1][j];
      // 判断当前剩余容量是否可以放入当前物品
      if (j >= w[i]) {
        // 可以放入的话，就比大小
        // 放入当前物品和不放入当前物品，哪个背包总价值大
        array[i][j] = Math.max(array[i][j], v[i] + array[i - 1][j - w[i]]);
      }
    }
  }
  return array[length - 1][C];
}
```

#### 1. 划分数组为和相等的两部分

[416. Partition Equal Subset Sum (Medium)](https://leetcode-cn.com/problems/partition-equal-subset-sum/description/)

```html
Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

可以看成一个背包大小为 sum/2 的 0-1 背包问题。

```java
public boolean canPartition(int[] nums) {
    int sum = computeArraySum(nums);
    if (sum % 2 != 0) {
        return false;
    }
    int W = sum / 2;
    boolean[] dp = new boolean[W + 1];
    dp[0] = true;
    for (int num : nums) {                 // 0-1 背包一个物品只能用一次
        for (int i = W; i >= num; i--) {   // 从后往前，先计算 dp[i] 再计算 dp[i-num]
            dp[i] = dp[i] || dp[i - num];
        }
    }
    return dp[W];
}

private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}
```

#### 2. 改变一组数的正负号使得它们的和为一给定数

[494. Target Sum (Medium)](https://leetcode-cn.com/problems/target-sum/description/)

```html
Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5 Explanation: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 =
3 +1+1+1+1-1 = 3 There are 5 ways to assign symbols to make the sum of nums be target 3.
```

该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。

可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：

```html
sum(P) - sum(N) = target sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N) 2 * sum(P) = target + sum(nums)
```

因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。

```java
public int findTargetSumWays(int[] nums, int S) {
    int sum = computeArraySum(nums);
    if (sum < S || (sum + S) % 2 == 1) {
        return 0;
    }
    int W = (sum + S) / 2;
    int[] dp = new int[W + 1];
    dp[0] = 1;
    for (int num : nums) {
        for (int i = W; i >= num; i--) {
            dp[i] = dp[i] + dp[i - num];
        }
    }
    return dp[W];
}

private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}
```

DFS 解法：

```java
public int findTargetSumWays(int[] nums, int S) {
    return findTargetSumWays(nums, 0, S);
}

private int findTargetSumWays(int[] nums, int start, int S) {
    if (start == nums.length) {
        return S == 0 ? 1 : 0;
    }
    return findTargetSumWays(nums, start + 1, S + nums[start])
            + findTargetSumWays(nums, start + 1, S - nums[start]);
}
```

#### 3. 01 字符构成最多的字符串

[474. Ones and Zeroes (Medium)](https://leetcode-cn.com/problems/ones-and-zeroes/description/)

```html
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3 Output: 4 Explanation: There are totally 4 strings can
be formed by the using of 5 0s and 3 1s, which are "10","0001","1","0"
```

这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。

```java
public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0) {
        return 0;
    }
    int[][] dp = new int[m + 1][n + 1];
    for (String s : strs) {    // 每个字符串只能用一次
        int ones = 0, zeros = 0;
        for (char c : s.toCharArray()) {
            if (c == '0') {
                zeros++;
            } else {
                ones++;
            }
        }
        for (int i = m; i >= zeros; i--) {
            for (int j = n; j >= ones; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }
    return dp[m][n];
}
```

#### 4. 找零钱的最少硬币数

[322. Coin Change (Medium)](https://leetcode-cn.com/problems/coin-change/description/)

#### 5. 找零钱的硬币数组合

[518\. Coin Change 2 (Medium)](https://leetcode-cn.com/problems/coin-change-2/description/)

```
Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

完全背包问题，使用 dp 记录可达成目标的组合数目。

```java
public int change(int amount, int[] coins) {
    if (amount == 0 || coins == null || coins.length == 0) {
        return 0;
    }
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    return dp[amount];
}
```

#### 6. 字符串按单词列表分割

[139. Word Break (Medium)](https://leetcode-cn.com/problems/word-break/description/)

```html
s = "leetcode", dict = ["leet", "code"]. Return true because "leetcode" can be segmented as "leet code".
```

dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。

该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 "leetcode"：

```html
["lee", "tc", "cod"]
```

求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。

```java
public boolean wordBreak(String s, List<String> wordDict) {
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    for (int i = 1; i <= n; i++) {
        for (String word : wordDict) {   // 对物品的迭代应该放在最里层
            int len = word.length();
            if (len <= i && word.equals(s.substring(i - len, i))) {
                dp[i] = dp[i] || dp[i - len];
            }
        }
    }
    return dp[n];
}
```

#### 7. 组合总和

[377. Combination Sum IV (Medium)](https://leetcode-cn.com/problems/combination-sum-iv/description/)

```html
nums = [1, 2, 3] target = 4 The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2)
(3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7.
```

涉及顺序的完全背包。

```java
public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] maximum = new int[target + 1];
    maximum[0] = 1;
    Arrays.sort(nums);
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.length && nums[j] <= i; j++) {
            maximum[i] += maximum[i - nums[j]];
        }
    }
    return maximum[target];
}
```

### 0-1 背包问题

能不能运用贪婪算法去解决？

有三种策略：

1.  选取价值最大的物品

2.  选择重量最轻的物品

3.  选取价值/重量比最大的物品

**策略 1**：每次尽可能选择价值最大的，行不通。举例说明如下。

物品有：A B C

重量分别是：25, 10, 10

价值分别是：100，80，80

根据策略，首先选取物品 A，接下来就不能再去选其他物品，但是，如果选取 B 和 C，结果会更好。

**策略 2**：每次尽可能选择轻的物品，行不通。举例说明如下。

物品有：A B C

重量分别为：25, 10, 10

价值分别为：100, 5, 5

根据策略，首先选取物品 B 和 C，接下来就不能选 A，但是，如果选 A，价值更大。

**策略 3**：每次尽可能选价值/重量比最大的，行不通。举例说明如下。

物品有：A B C

重量是：25, 10, 10

价值是：25, 10, 10

根据策略，三种物品的价值/重量比都是一样，如果选 A，答案不对，应该选 B 和 C。

由上，贪婪算法总是做出在当前看来是最好的选择。即，它不从整体的角度去考虑，仅仅对局部的最优解感兴趣。因此，只有当那些局部最优策略能产生全局最优策略的时候，才能用贪婪算法。
