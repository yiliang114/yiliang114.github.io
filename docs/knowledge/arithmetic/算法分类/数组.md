---
layout: CustomPages
title: 数组
date: 2020-11-29
aside: false
draft: true
---

### 实现 reduce

```js
function reduce(array, fn, value) {
  for (let i = 0; i < array.length; i++) {
    let current = array[i];
    value = fn(value, current, i, array);
  }
  return value;
}
```

### 实现异步 reduce

```js
let reduceAsync = async (array, fn, value) => {
  for (let a of array) {
    value = fn(value, await a());
  }
  return value;
};
```

### 取交集

```js
function intersection(left, right) {
  let seen = left.reduce((seen, item) => {
    seen[item] = true;
    return seen;
  }, {});

  return right.reduce((result, current) => {
    if (current in seen) {
      return result.concat(current);
    }
    seen[current] = true;
    return result;
  }, []);
}
```

### 合并两个有序数组

```js
function mergeSortedArray(arrA, arrB) {
  var result = [];
  var i = 0,
    j = 0,
    targetLen = arrA.length,
    toolLen = arrB.length;
  while (i < targetLen && j < toolLen) {
    if (arrA[i] < arrB[j]) {
      result.push(arrA[i++]);
    } else {
      result.push(arrB[j++]);
    }
  }
  while (i < targetLen) {
    result.push(arrA[i++]);
  }
  while (j < toolLen) {
    result.push(arrB[j++]);
  }
  return result;
}
```

### 整数数组的最大子串和

```js
// 求整数数组的最大子串和，如 [-23, 17, -7, 11, -2, 1, -34] 的最大子串和是21，对应子串是 [17, -7, 11]
function maxSeqSum(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const len = arr.length;
  let maxSum = arr[0];
  let seqSum = arr[0];
  for (let i = 1; i < len; i++) {
    if (seqSum <= 0) {
      seqSum = arr[i];
    } else {
      seqSum += arr[i];
    }
    if (seqSum > maxSum) {
      maxSum = seqSum;
    }
  }
  return maxSum;
}
```

### 查找第 K 大的数

```js
function findKMax(a, k) {
  // 查找第 K大的数
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  let len = a.length - key;
  while (len !== k) {
    if (len > k) {
      key = partition(a, key + 1, right);
    } else {
      key = partition(a, left, key - 1);
    }
    len = a.length - key;
  }
  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让key为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果key小于a[right]，则right递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果key大于a[left]，则left递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把key现在所在的下标返回
}
const arr = [5, 4, 3, 2, 1, 6];
const KMax = findKMax(arr, 1);
console.log(KMax);
```

### 查找第 K 小的数

```js
function findKMin(a, k) {
  // 查找第 K 小的数
  const left = 0,
    right = a.length - 1;
  let key = partition(a, left, right);
  while (key !== k - 1) {
    if (key > k - 1) {
      key = partition(a, left, key - 1);
    } else {
      key = partition(a, key + 1, right);
    }
  }
  return a[key];
}

function partition(a, left, right) {
  const key = a[left]; // 一开始让 key 为第一个数
  while (left < right) {
    // 扫描一遍
    while (key <= a[right] && left < right) {
      // 如果 key 小于 a[right]，则 right 递减，继续比较
      right--;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
    while (key >= a[left] && left < right) {
      // 如果 key 大于 a[left]，则 left 递增，继续比较
      left++;
    }
    [a[left], a[right]] = [a[right], a[left]]; // 交换
  }
  return left; // 把 key 现在所在的下标返回
}
const arr = [5, 4, 3, 2, 1, 6];
const KMin = findKMin(arr, 2);
console.log(KMin);
```

### 给定一个整数数组，求其中三个整数的最大乘积

```js
var unsortedArray = [-10, 7, 29, 30, 5, -10, -70];

computeProduct(unsortedArray); // 21000

function sortIntegers(a, b) {
  return a - b;
}

// Greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)
function computeProduct(unsorted) {
  var sortedArray = unsorted.sort(sortIntegers),
    product1 = 1,
    product2 = 1,
    array_n_element = sortedArray.length - 1;

  // Get the product of three largest integers in sorted array
  for (var x = array_n_element; x > array_n_element - 3; x--) {
    product1 = product1 * sortedArray[x];
  }

  product2 = sortedArray[0] * sortedArray[1] * sortedArray[array_n_element];

  if (product1 > product2) return product1;

  return product2;
}
```

### 数组-连续-求和

已知未排序的数组包含(n-1)个 n 个连续数字(定义了边界)，请在 O(n)时间中找到缺失的数字

```js
// The output of the function should be 8
var arrayOfIntegers = [2, 5, 1, 4, 9, 6, 3, 7];
var upperBound = 9;
var lowerBound = 1;

findMissingNumber(arrayOfIntegers, upperBound, lowerBound); // 8

function findMissingNumber(arrayOfIntegers, upperBound, lowerBound) {
  // Iterate through array to find the sum of the numbers
  var sumOfIntegers = 0;
  for (var i = 0; i < arrayOfIntegers.length; i++) {
    sumOfIntegers += arrayOfIntegers[i];
  }

  // Find theoretical sum of the consecutive numbers using a variation of Gauss Sum.
  // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2];
  // N is the upper bound and M is the lower bound

  upperLimitSum = (upperBound * (upperBound + 1)) / 2;
  lowerLimitSum = (lowerBound * (lowerBound - 1)) / 2;

  theoreticalSum = upperLimitSum - lowerLimitSum;

  return theoreticalSum - sumOfIntegers;
}
```
