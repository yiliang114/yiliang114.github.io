---
title: 字节前端准备
date: 2021-03-04
draft: true
---

# 基础

## 基础知识

1. 闭包
2. 有哪些数据类型？ ES6 新增了哪些数据类型
3. set 和 map 区别？set 放 NaN 会有几个？NaN 全等于 NaN 吗？答不全等，问那为什么 set 里面只能放一个 ？
4. 执行上下文/作用域链/
5. 原型链
6. 继承
7. 创建对象的方式
8. 判断数组的几种方法？js 基本数据类型和引用类型的区别，怎么判断，为什么不一样，基本数据类型是怎么存储的
9. 0.1 + 0.2 === 0.3 嘛?为什么?
10. es6 特性
11. 箭头函数和普通函数有什么区别？
12. let/const/var 有什么区别
13. 模块化
14. 装饰器
15. this 指针的指向 四种调用，箭头函数，再说了一下 call 改变指针的实现思路。
16. call/apply/bind
17. 事件机制/Event Loop
18. 宏任务和微任务
19. 浏览器缓存
20. 函数柯里化(JS 中 bind 函数和数组的 reduce 方法用到了函数柯里化。)
21. 原型链
22. typeof 的结果
23. instanceof 原理
24. new 做了什么事情。new 一个构造函数，如果构造函数返回 return {}、return null，会出现什么情况
25. 箭头函数的特点
26. Symbol 用来干什么，有哪些特征？
27. 如何判断一个对象是不是空对象？
28. Number() 的存储空间是多大，如果后台发送了一个超过最大字节的数字怎们办
29. 聊聊 Proxy
30. eventloop 判断输出 说了下 node 环境（版本不同还有区别）的和浏览器环境的输出，结果相同
31. 类数组怎么转换为数组？ [...arguments] Array.from(arguments)
32. arr = Array.from({ length: 2 }).fill({ a: 1 }) 输出什么，from()功能，注意点
33. for 循环中的 var 、let 与 const 区别，比如 for( const i = 0; i< 3; i++ ){ console.log(i); } 会输出什么结果 ？（看试题给结果，分析过程）。
34. Proxy 和 Object.defineProperty。 defineProperty 有什么缺点？为什么用 Proxy，对 Proxy 了解多少？
35. 模块化介绍(commnjs amd cmd umd export)
36. Number() 的存储空间是多大? Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。

### 原型链

```js
var a = { x: 1 };
var b = a;
a = a.x = { x: 1 };
console.log(a); // {x:1}
console.log(b); // {x:{x:1}}
```

### === 与 ==

```js
undefined === undefined; // true
null == undefined; // true
NaN === NaN; // false
NaN == NaN; // false
```

### this

使用 `use strict` 的时候，this 的值应该为 undefined

### 判断数组的方式

1. Object.prototype.toString.call()
2. instanceof
3. Array.isArray()

### Promise

1. promise 与 generator 的区别
2. promise 的几个 api，手写 promise。 promise 如何退出请求，用 race 实现。
3. Promise 的执行题
4. then 第二个参数与 catch 的区别
5. 用 promise 实现一个请求超时功能
6. promise.then().then() ，promise.catch().then() ok 不？ promise 其他东西
7. 实现一个 Promise.all
8. promise.all 和 promise.race 介绍（手写）
9. 实现 Promise.all, Promise.allSettled

## CSS

1. 盒模型
2. 单位 rem 的理解
3. display:none, visibility:hidden, opactiy:0 的区别。
4. position sticky 的理解？
5. 行内元素/块状元素
6. flex 布局，有哪些属性。 flex: 1 flex-basic 是什么含义
7. 1px retina 屏幕的处理
8. Sass/Less
9. 居中/常见布局
10. 层叠上下文 bfc. BFC 与 IFC 的区别. 如何形成 BFC.BFC 会与 float 元素相互覆盖吗？为什么？举例说明
11. 垂直、水平居中定位的几种方式
12. 基本布局
13. 重绘回流。 怎样移动一个标签却不导致重排？transform
14. 定位 position bfc ? margin 合并，清除浮动
15. 垂直、水平居中
16. less/postcss
17. 实现一个 div 相对视口居中
18. marigin 塌陷是什么
19. css div 垂直水平居中，并完成 div 高度永远是宽度的一半（宽度可以不指定）
20. css3 用过哪一些？border-radius、transition
21. 实现一个模态窗口，要从窗口下面向上弹的动画
22. 单行文本溢出，多行文本溢出的代码实现
23. CSS 性能优化（较难，需要一定知识深度和广度）
24. css 绘制三角形
25. css 实现这样一个布局： 无论外层容器宽高如何变化，内层始终相对于外层容器垂直居中，左右各相距 20px，同时内层的高度始终为自身宽度的 50%。（至少写一种，说出实现多种）
26. 实现左边固定,右边自适应的布局
27. header 头部固定，剩下 body 占满全部高，超出就上下滚动，如何实现 ？
28. lineheight 属性 1.5 和 150%区别
29. 三栏布局 右侧固定左侧和中间自适应
30. 实现固定宽高比(width: height = 4: 3)的 div，怎么设置
31. 伪类和伪元素

### 说说 position 的属性都有哪些，区别是什么？

1. position: relative;相对定位

相对于元素本身定位，不会使元素脱离文档流，会占据原来的位置，不设置偏移量时没有任何影响。

2. position: absolute;绝对定位

会使元素脱离文档流，不占据文档位置，改变元素特性，使内联元素有块级元素特性，相对于离元素最近的一个具有定位属性的元素来进行偏移，如果找不到就相对窗口定位。

3. position: fixed;固定定位

相对于窗口进行定位，当窗口大小改变也是相对于改变后的窗口进行对位。

4. position:static：默认值

默认布局。元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

5. position: sticky 粘性定位（当时这个没有回答上）

粘性定位，基于用户滚动的位置，当页面滚动超出目标区域时，就会表现向固定定位一样撵上去。

这个属性至此我还未使用过，待会就去试试怎么用。

其实我查了一下，position 还有两个属性，但是是继承和设置默认值，用的很少，这里也就不多说了，感兴趣可以自己去查一下。

## 浏览器

html5 的标签有哪些？说一下怎么用的？
事件流:事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。
事件是如何实现的， 几种类型？
事件代理
V8 内存回收机制。 关键词：老生代，新生代。引用计数、标记清理
前端安全：关键词：xss，csrf。xss 及防御，关键词：储存型、反射型、dom 型
如何解决页面卡顿（前端性能优化是一个永恒的话题，综合性很高的一个问题，尽可能回答）
浏览器从输入 url 到页面渲染的整个流程（同样是一个很综合的问题，有很多细节值得深入理解）
浏览器如何构建和渲染页面
click DOM 节点的 inner 与 outer 的执行机制，考查事件冒泡与事件捕获 （看试题给结果，分析过程）
回流重绘，为什么用 transform 写动画不用 position top left
js 脚本加载问题，async、defer 问题: 如果依赖其他脚本和 DOM 结果，使用 defer. 如果与 DOM 和其他脚本依赖不强时，使用 async
首屏加载优化， 通过哪些指标去衡量性能优化的
浏览器渲染（从输入 url 到页面渲染的完成过程）

## 移动端

移动端适配方案
如何提升移动端用户的使用体验，让用户能更快的看到页面

## 框架

2. MVVM/MVC 虚拟节点 Diff 过程 for 循环与 Key
3. vue react omi 的区别
4. vue 是怎么解析模板的？
5. 对虚拟 Dom 的理解
6. 双向绑定， angular 的脏检查和 vue 的双向数据绑定有什么区别？
7. 生命周期
8. 组件通信
9. omi/omiv
10. computed/watch 原理. computed 和 watch 的差异
11. React Hoc/Vue mixin
12. router 原理
13. vue2 与 vue3 的差别。
14. vue3.0 的新特性，了解 compose api 和 react hooks 的区别
15. vue 的响应式原理
16. vue-router 的原理， hashchange 和 pushState
17. Object.defineProperty 的几个属性
18. Vue 的 Dom diff 的实现。 完全比较两个 Dom 树和只比较同层节点的算法复杂度各是多少？Dom diff 具体流程是怎么样的，内部细节能说一下么
19. vue 事件修饰符，原生 dom 事件，捕获
20. vue 自定义事件会冒泡吗
21. vue 事件是冒泡阶段还是捕获阶段触发
22. vue 中 next-tick 的作用与大概实现原理 ？
23. vue 按需加载的方式有几种，是哪几种 ？

### 实现一个 vue 的双向绑定

```js
class Observer {
  constructor(data) {
    // 遍历参数data的属性,给添加到this上
    for (let key of Object.keys(data)) {
      if (typeof data[key] === 'object') {
        data[key] = new Observer(data[key]);
      }
      Object.defineProperty(this, key, {
        enumerable: true,
        configurable: true,
        get() {
          console.log('你访问了' + key);
          return data[key]; // 中括号法可以用变量作为属性名,而点方法不可以;
        },
        set(newVal) {
          console.log('你设置了' + key);
          console.log('新的' + key + '=' + newVal);
          if (newVal === data[key]) {
            return;
          }
          data[key] = newVal;
        },
      });
    }
  }
}

const obj = {
  name: 'app',
  age: '18',
  a: {
    b: 1,
    c: 2,
  },
};
const app = new Observer(obj);
app.age = 20;
console.log(app.age);
app.newPropKey = '新属性';
console.log(app.newPropKey);
```

```js
const obj = {
  name: 'app',
  age: '18',
  a: {
    b: 1,
    c: 2,
  },
};
const p = new Proxy(obj, {
  get(target, propKey, receiver) {
    console.log('你访问了' + propKey);
    return Reflect.get(target, propKey, receiver);
  },
  set(target, propKey, value, receiver) {
    console.log('你设置了' + propKey);
    console.log('新的' + propKey + '=' + value);
    Reflect.set(target, propKey, value, receiver);
  },
});
p.age = '20';
console.log(p.age);
p.newPropKey = '新属性';
console.log(p.newPropKey);
```

### 开源

generateVuex
omiv.omi
为 omiv 提交了什么内容的代码
cli 具体做了什么，模板是你写的么？ 有哪些功能
封了什么组件，拿一个说说

### 模态弹框处理 modal 组件

https://zhuanlan.zhihu.com/p/144802918

## 网络

1. url 过程
2. CDN 原理。关键词：DNS 查询，负载均衡
3. DNS
4. TCP
5. tcp 三次握手
6. http 报文头部有哪些字段?有什么意义?
7. http 请求方法， post 与 get 的区别
8. 状态码
9. Content-Type 有哪些
10. http/https/http2 特性和优缺点。 http2 关键词：信道复用，server push
11. https 的原理，以及握手的过程。 对 HTTPS 的理解。HTTPS 密钥的交换过程，HTTPS 绝对安全吗？ HTTPS 欺骗是怎么实现的？
12. 使用 https 也不安全，响应数据中途被修改了，比如说非会员被改成了会员，那你要怎么解决？
13. http 缓存.http 缓存有哪些，具体值的含义
14. 跨域 ,跨域的实现方式 cors。 jsonp 原理和实现？
15. cookie 属性。 怎么禁止 js 访问 cookie
16. cookie,session,localstorage,sessionstorage 有什么区别
17. xhr，fetch，axios 的区别
18. tcp 和 udp 的区别以及应用场景
19. 中间人劫持，怎么防止。x-frame-option?白屏的喔，怎么办？也不一定嵌入 iframe 啊，可以嵌入脚本、图片，怎么阻止【描述】
    1. x-frame-option、重定向、https，请求前加密（https、加密代理）、请求中规避（请求拆包）、请求后弥补（前端做一些逻辑）。嵌入非 iframe 的，如果已经突破了前面两关，走前端逻辑：触发 DOMNodeInserted、DOMContentLoaded、DOMAttrModified 事件。或者是给能 src 的标签加上自己的 data-xx 属性标记区分。
20. x-www-urlecoded-form 和 application/json 在 post 中的区别
21. 文件上传的字符编码类型，之间的区别以及为什么会这样，form 表单默认是谁
22. TCP 为什么是可靠的？［因为它有 ACK］
23. 那 tpc 和 udp 相比的话，udp 有什么好处？虽然不可靠，但是为什么还有很多基于 udp 的协议［因为 upd 报文小，udp 头部 8 个字节，tcp 头部 20 个字节，而且有些协议也不需要太可靠。］
24. 网络分层
25. https 中间被篡改了怎么识别？

### 网络分层

OSI 七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

TCP/IP 五层模型：应用层、传输层、网络层、数据链路层、物理层

## 工程化

1. webpack 原理以及一些概念
2. webpack 的问题，简述了一下 webpack 的构建过程（不全，主要是 webpack 生命周期忘了）
3. webpack 懂吧？说下用过的 loader 和 plugin
4. webpack 的时候提到了 happypack 和 treeshaking
5. webpack 怎么优化
6. webpack loader/plugin hmr tree-sharking
7. webpack rollup parcel esbuild 等
8. babel transform,stage, polyfill, plugin
9. DLLPlugin 原理，为什么不直接使用压缩版本的 js

10. babel 插件写过么？
11. AST
12. HMR 热更替原理
    1. 浏览器是如何更新的
    2. 如何做到页面不刷新也就就自动更新的
    3. webpack-dev-server webapck-dev-middleware
13. tree sharking

### webpack

webpack loader 和插件的原理
webpack
webpack-dev-server hmr 原理
axios 怎么封装的

## 监控

监控的实现，和错误收集方式
监控做了哪些事情
监控，错误上报 异常排查。
异常监控有哪些，都需要怎么捕获

## 性能优化

你认为 webpack 哪里打包慢
webpack 编译加速 ？关键词：dll、多线程
假如现在，我说有一个页面打开有点慢，交给你来负责优化，你的思路和做法是什么？
前端优化的指标有哪些，通过什么手段获取？
懒加载、虚拟列表的原理
如何实现 list 的无限滚动（节流？）
前端性能优化 对用户来说首批加载时间，srr 服务端渲染，pwa 缓存，懒加载（异步加载 import 函数，图片滚动渲染），预加载（dns 缓存，proload），http 请求合并。 其实还有很多例如：雪碧图等但是当时忘了。
为什么多域名部署【描述】:http1 和浏览器的问题，同一时间 6 个连接
TTFB 慢了，如果不加缓存，以前可能是骨架屏，现在直接白屏
出现异常不好定位调试.为了缓存，带权限接口与非权限接口有可能需要剥离
happypack 原理 【多进程打包 又讲了下进程和线程的区别】
你觉得 CommonJS 为什么不能做 Tree-Shaking ?
ESModule 既然是编译时加载，那它可以做到运行时加载吗，想过这个问题吗？(愣了一会，说 webpack 有动态 import 的方式)

角度：

1. 打包优化
2. 网络优化
3. 代码优化

## Node

说说你对 Node 运维的了解
容灾
分别讲讲 restful 和 graphQL 及其优缺点

# 计算机基础

1. 设计模式
2. 数据结构
3. 基础算法
4. 安全
5. 单元测试、e2e 测试【描述】
6. 客户端 mock 怎么支持【描述】【举例】:客户端 => 协议转换服务 => 中转服务 => mock 服务（接入 mockjs）
7. cjs 实现 esm【伪代码】: 参考 webpack 把 esmodule 的 import 转成 wepack_require 的样子

其他：

1. 进程与线程关系
2. sort()是内部使用了什么算法 时间复杂度是多少 indexOf()的时间复杂度是多少

# 新技术

service worker 和 web worker 是由来干什么的？
微前端
数据可视化
页面适配的方法有哪些？怎么判断设备类型
http 缓存、离线包原理、移动端首屏幕加载速度优化、webview 冷启动、预热【描述】
websocket 握手过程

# 编码

## 手写前端

1. url 解析
2. 深拷贝
3. destructuringArray
4. 手写 call apply 以及 bind
5. 实现一个判断变量类型的函数
6. 发布、订阅：实现一个类可以完成事件 on, once, trigger, off
7. 实现千分位
8. 二分搜索
9. 快排
10. 树的几种遍历
11. 链表翻转，检查环
12. 手写防抖节流
13. 实现原生 ajax
14. 给一数组和一数字，求数组中出现次数大于数组长度除该数字的项？
15. 二进制相加，给两字符串求值
16. 使用 JS 实现一个 repeat 方法 log 4 次 hello world, 每次间隔 3 秒
17. 不能使用全局变量实现调用 a()三次得到 1，2，1......重复，使用了闭包存一个 boolean 值
18. 实现 function(func, times, wait ){}，传入 func 每隔 wait 时间，执行一次，执行 times 次
19. 对输入的字符串：去除其中的字符'b'；去除相邻的'a'和'c'。 'aabcd' -> 'ad' 'aaabbccc' -> '' 不允许使用类似 string.replace 函数。要求时间、空间复杂度尽量优化
20. 实现一个联想搜索组件

21. 实现一个 sleep 函数
22. 写出一个正则匹配出图片的后缀,匹配以`.jpg`或者`.png`结尾的链接
    ```js
    var str = '[https://happy.com/img/like.png](https://happy.com/img/like.png)';
    var reg = /\.(png|jpg)$/;
    ```
23. js 实现带并发限制的调度器，其实就是使用 promise 限制并发
24. 工厂生产了十批原件，其中有一批是次品。正常的原件每个重量都是 100 克，次品的是 99 克。现在给你一个秤，要求只称一次，怎么确定哪批原件是次品。
25. 写一段匹配 URL 的正则，包括协议、域名、端口、path、hash、querystring
26. 实现一个可以控制请求并发数的最高效的发送请求功能。
27. 给 10 亿的数据的 url 去重，思路（现场写部分代码）
28. 数组去重、扁平化、柯里化
29. 如果后端传给前端一个很大的数，前端会怎么样，该怎么处理？
30. js 中处理大数
31. 找出两个有序数组中的重复项，分析时间和空间复杂度
32. 手动控制并发请求 fetchWithLimit。 手动控制并发请求 fetchWithLimit 尽量快的实现
33. 数组去重，es5 实现，区分数字和字符串
34. 实现一个函数，将输入的数组转为链表，并实现一个方法向链表指定位置插入值
35. 两个无序数组合并成一个有序数组，问时间复杂度。 延伸：快排和冒泡排序的时间复杂度，使用场景
36. 实现 toFix 函数
37. 实现 ajax，至少实现 get 和 post 方法。这里深挖了 get 和 post 具体的传参方式以及 ajax 中具体是如何实现的
38. 实现一个模态框组件，用 vue 和 react 均可(要能传递确定取消事件函数，有遮罩，居中)
39. fetch 兼容超时重传
40. atoi 把任意进制的数转为十进制的数。 需要考虑负数。
41. 实现一个 promiseify 方法，将 callback 风格调用转成 promise 调用方式

### reduce 实现 map

```js
Array.prototype.map = function(callback) {
  var arr = this;
  return arr.reduce((acc, cur, i) => {
    acc.push(callback(cur, i, arr));
    return acc;
  }, []);
};
var m = [1, 2, 3, 4, 54].map(function(v, i, arr) {
  return v * v;
});
console.log(m);
```

### a~z 有 26 个字母，按照 1~26 编码，现在给定一个数字字符串，输出所有可能的解码结果，如：输入 1234，输出 ['axd', 'abcd', 'lcd']

leetcode 原题

### 顺序发送 4 个请求 a，b，c，d，要求按照顺序输出

顺序发送 4 个请求 a，b，c，d，要求按照顺序输出，即如果先返回 b，则不输出，再返回 a，输出 a，b

```js
function getData(urls) {
  return new Promise((resolve, reject) => {
    const res = [],
      len = urls.length;
    urls.forEach((url, i) => {
      fetch('http://localhost:8080' + url)
        .then(data => data.json())
        .then(data => {
          res[i] = { data, printed: false }; // 将数据放入缓存数组
          let flag = true;
          for (let j = 0; j < len && flag; j += 1) {
            if (res[j]) {
              // 如果标志为 j 的有返回值，则继续
              if (!res[j].printed) {
                console.log(res[j].data);
                res[j].printed = true;
                j === len - 1 && resolve(res.map(o => o.data));
              }
            } else {
              // 无返回值，则跳出
              flag = false;
            }
          }
        }, reject);
    });
  });
}

const listPromise = getData(['/data.json', '/data2.json', '/data3.json', '/data4.json']);
listPromise.then(res => console.log(res));
```

### 用 promise 实现一个请求超时功能

```js
function promiseWithTimeout(url, timeout = 3000) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(data => data.json())
      .then(data => resolve(data)); // fetch 先得到结果就 resolve
    setTimeout(() => reject(Error('time is out!')), timeout); // 时间到了还没 fetch 到就 reject
  });
}

promiseWithTimeout('http://localhost:8080/data.json')
  .then(data => console.log(data))
  .catch(err => console.error(err));

// server.js 测试
const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors({ origin: '*' }));

app.use('/data.json', (req, res) => {
  setTimeout(() => res.end(JSON.stringify({ a: 1 })), Math.floor(Math.random() * 6 * 1000));
});

app.listen(8080, () => console.log('the app is running at http://localhost:8080'));
```

### 实现一下 curry（柯里化）

```js
function curry(fn, arr = []) {
  return fn.length === arr.length
    ? fn.apply(null, arr)
    : function(...args) {
        return curry(fn, arr.concat(args));
      };
}

const curry = (fn, arr = []) => (fn.length === arr.length ? fn(...arr) : (...args) => curry(fn, [...arr, ...args]));
```

实现加法函数使得 sum(2)(3)和 sum(2,3)都输出 5

### JS 实现一个带并发限制的异步调度器 Scheduler

完善代码中 Scheduler 类，使得以下程序能正确输出。

```js
// JS实现一个带并发限制的异步调度器Scheduler，
// 保证同时运行的任务最多有两个。
// 完善代码中Scheduler类，
// 使得以下程序能正确输出

class Scheduler {
  constructor() {
    this.count = 2;
    this.queue = [];
    this.run = [];
  }

  add(task) {
    // ...
  }
}

const timeout = time =>
  new Promise(resolve => {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler();
const addTask = (time, order) => {
  scheduler.add(() => timeout(time)).then(() => console.log(order));
};

addTask(1000, '1');
addTask(500, '2');
addTask(300, '3');
addTask(400, '4');
// output: 2 3 1 4

// 一开始，1、2两个任务进入队列
// 500ms时，2完成，输出2，任务3进队
// 800ms时，3完成，输出3，任务4进队
// 1000ms时，1完成，输出1
// 1200ms时，4完成，输出4
```

别人的解答：

```js
class Scheduler {
  constructor(count) {
    this.count = 2;
    this.queue = [];
    this.run = [];
  }

  add(task) {
    this.queue.push(task);
    return this.schedule();
  }

  schedule() {
    if (this.run.length < this.count && this.queue.length) {
      const task = this.queue.shift();
      const promise = task().then(() => {
        this.run.splice(this.run.indexOf(promise), 1);
      });
      this.run.push(promise);
      return promise;
    } else {
      return Promise.race(this.run).then(() => this.schedule());
    }
  }
}
```

### 实现一个并发限制功能。

```js
function asyncPool(poolLimit, array, iteratorFn) {
  let i = 0;
  const ret = [];
  const executing = [];
  const enqueue = function() {
    if (i === array.length) {
      return Promise.resolve();
    }
    const item = array[i++];
    const p = Promise.resolve().then(() => iteratorFn(item, array));
    ret.push(p);
    const e = p.then(() => executing.splice(executing.indexOf(e), 1));
    executing.push(e);
    let r = Promise.resolve();
    if (executing.length >= poolLimit) {
      r = Promise.race(executing);
    }
    return r.then(() => enqueue());
  };
  return enqueue().then(() => Promise.all(ret));
}
```

### 写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串

### 大数相乘

### 其他

函数式编程
函数的柯里化
设计模式

## 算法

### 分类

#### 排序

手写 快排，选择排序
解释一下快排，用的什么思想，时间复杂度怎么计算的
冒泡排序
快速排序

#### 字符串/数组

数组中数字出现的次数 https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/
最长无重复子串 我这个算法思路没问题，但是实操的时候紧张错误百出，经过指导最后写出来了。
斐波那契实现，复杂度， 斐波那契递归时间复杂度（O(2^N)）
数组乱序:洗牌算法
两数之和：找出数组中两个元素的和为 target 的组合
实现一个 match 函数 判断 `()()()[] => true` , `{{[(){}[]}}=>true , {{{[]][]}}}[] =>false`
数组顺时针螺旋遍历
给定两个无重复升序数组，求合并之后数组。如给定 m={1,2,3},n{2,4,5},则应输出{1,2,3,4,5}
回文字符串
两数之和、k sum
大数相加
16 进制转 10 进制
在一个无序数组中找到第二大的数
数组中第 K 大元素 （快排，我先说思路然后问了下时间复杂度，然后写
合并乱序区间
给定一个字符串，找出其中无重复字符的最长子字符串长度 ![](https://pic4.zhimg.com/80/v2-d8136dca742eb7560c23d1a39e99e86b_1440w.jpg) ![](https://pic1.zhimg.com/80/v2-291f6f8dcd093229bb7d0a9102c826dc_1440w.jpg)
数组中第 k 个最大元素
找出字符串中第一个不重复的字符
字符串中最长回文子串
数组区间
二分查找
两数之和
三数之和
搜索旋转排序数组
数组中的第 K 个最大元素
字符串中的第一个唯一字符
剑指 Offer 39. 数组中出现次数超过一半的数字
剑指 Offer 50. 第一个只出现一次的字符 45° 打印矩阵，回形打印矩阵

#### 链表

两个有序链表和并成一个有序链表
反转链表(原地)
合并单链表
两个链表的第一个公共结点
判断单向链表是否有环
从排好序的两个链表中，找到相同的节点，并输出链表
链表反转
合并两个已排序的链表：递归解法、迭代解法
环形链表
回文链表
剑指 Offer 24. 反转链表
剑指 Offer 25. 合并两个排序的链表
剑指 Offer 52. 两个链表的第一个公共节点
面试题 02.07. 链表相交

#### 栈/队列

基本计算器
基本计算器 II
用队列实现栈
剑指 Offer 09. 用两个栈实现队列

#### 二叉树

树的遍历有几种方式，实现下层次遍历
二叉树的后序遍历（非递归解法要掌握）
二叉树的前、中、后序遍历的顺序。实现中序遍历，我用的递归，又问不用递归怎么解决
判断对称二叉树
给一个二叉树和一个值，问是否有一条路径上的值相加等于该值的，有就返回 true，没有就返回 false
蛇形二叉树
层次遍历二叉树
找到二叉树路径和为 n 的路径
求二叉树深度
二叉树中序遍历
树的遍历有几种方式，实现下层次遍历
判断对称二叉树
求二叉树每层的最大节点
构造一棵二叉树
一层循环实现层序遍历
二叉树先序中序 生成后序
二叉树中的所有路径
二叉树中和为某一值的路径
给定一个二叉树, 找到该树中两个指定节点间的最短距离

二叉树前中后遍历
二叉树层次遍历
二叉树深度优先遍历(递归、非递归)
二叉树广度优先遍历(递归、非递归)
和为 n 的二叉树路径
二叉树深度
二叉树是否对称
对称二叉树
平衡二叉树
路径总和
路径总和 II
翻转二叉树
合并二叉树
剑指 Offer 28. 对称的二叉树
剑指 Offer 32 - I. 从上到下打印二叉树
剑指 Offer 55 - I. 二叉树的深度前中后序知道其二还原二叉树

#### 动态规划

给你一道算法题，盛水最多的容器
爬楼梯
编辑距离
买卖股票的最佳时机
买卖股票的最佳时机 II
买卖股票的最佳时机 III
剑指 Offer 19. 正则表达式匹配

#### 回溯

剑指 Offer 38. 字符串的排列

#### 其他

实现一个构造函数，new 的时候每次加 1
实现 36 进制转换
虎吃羊问题。100 只虎 1 只羊，老虎吃了羊就会变羊。第一只羊会不会死。 答：不会，动态规划问题。偶数不会吃羊，奇数会吃
给你 1 亿个数字，找出最大的前 1K 个，如何优化效率比较高
版本号比较排序

### 找到所有出现两次的元素。你可以不用到任何额外空间并在 O(n)时间复杂度内解决这个问题吗？

输入:

[4,3,2,7,8,2,3,1]

输出:

[2,3]

这种题，其实看见不用空间、o(n)时间，通常潜台词就是，用原地哈希来做。做过这题的肯定是秒杀，没做过的慌得一逼，我当时就是没做过的。遍历的时候把数字放到 index 下（比如数字 4 放在数组的第 4 个位置），如果发现后面的数的 n,arr[n]已经满足了 arr[n] === n 那就结果算一个。lc 标准答案：和我交换位置不一样，lc 的是让那个数变成负数，如果后面发现 arr[n]是负数那就算一个，比我的交换 index 简单很多。

### 老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。 目标是尽量让更多的孩子满意。 如孩子的要求是 1, 3, 5, 4, 2，饼干是 1, 1， 最多能让 1 个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是 7, 6, 5，最多能 让 2 个孩子满足。

### 给定一个正整数数列 a, 对于其每个区间, 我们都可以计算一个 X 值; X 值的定义如下: 对于任意区间, 其 X 值等于区间内最小的那个数乘上区间内所有数和; 现在需要你找出数列 a 的所有区间中, X 值最大的那个区间; 如数列 a 为: 3 1 6 4 5 2; 则 X 值最大的区间为 6, 4, 5, X = 4 \* (6+4+5) = 60;

# 项目

1. low code。数据应用工厂具体做的是什么？ 有什么难点？怎么实现的？
2. 数据资产平台。 大数据的流程。
3. 性能优化
4. 工程化、流程化

## 流程

做的项目流程是怎样的
如何规划一个项目功能

## 推动

如何推动 eslint 的落地
流水线是如何做的？

# 业务面

### 对 b 和 c 端业务对理解【描述】

简单来说，b 端 ui 要求低、架构复杂；c 端 ui 要求高、架构简单。详细的点，引申出去还有很多很多。

### tob 业务架构设计、技术选型【举例】

先出结构图、流程图，再给出表结构设计，确定了方案，组件、模块划分。技术选型一般就是三大框架+配套的标准 ui 了，如 vue 与 ele-ui，react 与 antd，加上状态管理、路由等。如果复杂的混杂多项目多系统，使用微前端，spa 或者 iframe 两种取其一，如果没有历史包袱可选 spa、如果有历史包袱使用 iframe 嵌入，但需要和其他前端进行对协议（前端和前端联调 😊）这里可以讲 20 分钟

# 反问

1. 业务具体的分布
2. 有幸能过之后，公司会有怎样的安排
3. 对于刚刚的面试，面试官觉得我有哪些地方不足，或者说可以改进的地方
