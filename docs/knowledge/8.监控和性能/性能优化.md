---
title: 性能优化
date: 2020-11-21
draft: true
---

## 性能优化

1. 减少页面体积，提升网络加载
2. 优化页面渲染

## 具体内容

### 基础指标

- 网络部分
  - 尽量减少 HTTP 请求数
    - 合并文件、雪碧图、小图 Base64，图片小于 30k 的图片直接做成 base64；
  - 减少 DNS 查找
    - 开启 DNS 预解析
  - 使用 CDN 静态资源服务器
- 缓存
  - 添上协商缓存、强缓存等形式
  - 使用外链的方式引入 JS 和 CSS（缓存）
- 内容部分
  - 按需加载组件
  - 预加载组件
- JS 部分
  - 把脚本放在底部， 加快渲染页面
  - 将脚本成组打包，减少请求
  - 使用非阻塞方式下载 js 脚本， 异步加载等。通过 preload prefetch 优化加载资源的时间
    - 动态脚本加载： 使用 JS 创建一个 script 标签再插入到页面中
    - defer（IE）：整个 HTML**解析完**后才会执行，如果是多个，按照加载顺序依次执行
    - async： **加载完**之后立即执行，如果是多个，执行和加载顺序无关
  - 大的文件使用 code split 进行切割，按需加载 js 文件
  - 合并 DOM 插入,DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。
  - 事件节流
- 图片部分
  - 选用合适的图片格式
  - 图片按需加载
- 组件的按需加载，接口按需请求，code split
- cookie
  - 给 cookie 减肥
    - 清除不必要的 cookie
    - cookie 尽可能小
    - 设置好合适的域
    - 合适的有效期
  - 把静态资源放在不含 cookie 的域下。当浏览器发送对静态图像的请求时，cookie 也会一起发送，而服务器根本不需要这些 cookie。
- 服务器
  - 开启 Gzip 等压缩。差不多能压缩 1/4 的体积。
- webpack 开启 tree-shaking 减少代码体积
  - vue 中 code spilt ，路由懒加载。
- 资源压缩合并，减少 HTTP 请求，开启 gzip 压缩
- 非核心代码的异步加载

  - 异步加载方式
    - 动态脚本加载
    - defer
    - async
  - 异步加载的区别
    - defer 是 HTML 解析完之后才会执行，如果是多个按照循序依次执行
    - async 是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关，哪一个先加载完毕先执行

- 利用浏览器缓存
- 使用 CDN
- DNS 预解析(啥叫预解析？ 很多浏览器中（打开）的 a 标签的预解析开关，但是对于 https 的链接，默认是关闭的，打开的话提升性能)

  - http-equiv="x-dns-prefetch-control" content="on"
  - rel="dns-prefetch"

- 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
- 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 base64 的方式写入文件中
- 按照路由拆分代码，实现按需加载
- 给打包出来的文件名添加哈希，实现浏览器缓存文件

### 预渲染

> 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

- 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

### 代码层面

- 防抖
- 节流

### 对组件库的优化

- 提供按需加载
- 图片、样式等走 cdn，懒加载等
- table list 海量数据，虚拟列表
- 页面加载海量数据
  - https://juejin.im/post/5ae17a386fb9a07abc299cdd

### webpack code split

![image](https://user-images.githubusercontent.com/11473889/109128661-a9080780-778a-11eb-8e34-3d93864be75d.png)

外部引入 cdn 的形式总体上还是会减小包的大小的。

#### 步骤

1. 拆包 code split。 ant d 的 icon 拆分， 按需加载。
2. sentry 日志上报，@sentry/webpack-plugin 上传 bundle.js 的 source map

   1. 背景： ant d 以及内部自己的组件库一开始没有考虑按需加载，所以尽管做了 code split 之后，app.js 还是很大，gzip 之后，虽然小了很多（需要配合 nginx 做 gzip 解包）所以 vue.config.js 中打开 sourcemap 开关之后 build 将很慢很慢。这里首要的工作是处理拆包，后续上传 sourcemap 配置告警即可。

3. 组件库的按需加载。
4. 懒加载。 路由，图片，区块，请求 （与图片类似）

##### 组件库如何做按需加载

1. `babel-plugin-import`
2. es module 形式

### performance API 指标

## 必提

1. webpack 拆包拆成 CDN
2. 前端缓存
3. gzip
   1. TODO: 原理

## 实施

性能优化的标准中提到的都是单个点，性能优化项目具体实施起来，应该按照下面步骤推进:

1. 建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过 程消耗时间记录下来
2. 分析耗时较长时间段原因，寻找优化点，确定优化目标
3. 开始优化
4. 通过数据收集平台记录优化效果
5. 不断调整优化点和预期目标，循环 2~4 步骤

## 性能优化

- 懒加载的原理
- 大数据列表的虚拟列表原理
- 懒加载的原理,vue-lazy 的原理
- 首屏时间如何计算，数据如何上报？
- 如何分析页面性能？
- performance API 的哪些指标？
- ...
- 把脚本放在底部， 加快渲染页面
- 文件名添加哈希， http 强缓存静态文件
- 按需加载组件
- 资源压缩合并，减少 HTTP 请求，开启 gzip 压缩
- 清除不必要的 cookie， 设置好合适的域
- 把静态资源放在不含 cookie 的域下
- 非核心代码的异步加载
- DNS 预解析 ？？？

#### 懒加载的原理

#### 虚拟大列表的处理

#### code split

1. vue-router 中的通过 webpack 的 `() => import` or `require.ensure` API 能够自动进行代码分割
2. 通过 analyzer 进行分析 js 包的大小，webpack 中的 externals 能够拆分包，通过外链 cdn 的形式引入

#### 首屏时间

如何计算？

#### 页面性能

如何分析页面性能？

performance API 的哪些指标？

### code split

1. vue-router 中的通过 webpack 的 `() => import` or `require.ensure` API 能够自动进行代码分割
2. 通过 analyzer 进行分析 js 包的大小，webpack 中的 externals 能够拆分包，通过外链 cdn 的形式引入
