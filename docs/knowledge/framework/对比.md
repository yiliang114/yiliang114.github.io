---
layout: CustomPages
title: framework
date: 2020-11-21
aside: false
draft: true
---

### Vue 和 React 之间的区别

1. Vue 的表单可以使用 `v-model` 支持双向绑定，相比于 React 来说开发上更加方便，当然了 `v-model` 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。
2. 改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用 `setState` 来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用 setState 来改变状态，并且使用这个 API 也有一些坑点。
3. React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因，这在后续的章节中会讲到。
4. React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 `render` 函数就能在浏览器中运行。
5. 在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。
6. 在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。

### React 与 Vue 区别

- 上手
  - vue - easy 官方做了很多,CSS script
  - react ，上手偏难，
- 数据绑定
  - vue model 双向的
  - react 是单向的
- 模板
  - vue H5 模板
  - react JSX
- api
  - vue 多，计算属性，watch 这种神器
  - react 少，更多功能留给社区，比如写个函数还有 bind 以下
- 应用
  - vue 适合面向用户的，复杂度稍低一些的
  - react 复杂的
- 测试
  - react 函数式编程利于测试

### 与 Vue.js 相比，React 有哪些优势?

与 Vue.js 相比，React 具有以下优势：

- 在大型应用程序开发中提供更大的灵活性。
- 更容易测试。
- 更适合创建移动端应用程序。
- 提供更多的信息和解决方案。

### React 和 Angular 有什么区别?

| React                                                                  | Angular                                                                                         |
| ---------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| React 是一个库，只有 View 层                                           | Angular 是一个框架，具有完整的 MVC 功能                                                         |
| React 可以处理服务器端的渲染                                           | AngularJS 仅在客户端呈现，但 Angular 2 及更高版本可以在服务器端渲染                             |
| React 在 JS 中使用看起来像 HTML 的 JSX，这可能令人困惑                 | Angular 遵循 HTML 的模板方法，这使得代码更短且易于理解                                          |
| React Native 是一种 React 类型，它用于构建移动应用程序，它更快，更稳定 | Ionic，Angular 的移动 app 相对原生 app 来说不太稳定和慢                                         |
| 在 Reac t 中，数据只以单一方向传递，因此调试很容易                     | 在 Angular 中，数据以两种方式传递，即它在子节点和父节点之间具有双向数据绑定，因此调试通常很困难 |

### vue 和 react 区别

- 相同点：都支持 `ssr`，都有 `vdom`，组件化开发，实现 `webComponents` 规范，数据驱动等
- 不同点：`vue` 是双向数据流（当然为了实现单数据流方便管理组件状态，`vuex` 便出现了），`react` 是单向数据流。`vue`的 `vdom` 是追踪每个组件的依赖关系，不会渲染整个组件树，`react` 每当应该状态被改变时，全部子组件都会 `re-render`

### react 与 vue 的适用场景，是如何选择的。

### 单项数据流和双向数据流区别？

> 经常看见在 vue 或者 angular 的介绍里说自己的特色是双向数据绑定，而在看 react 的介绍中，说自己的优势和特色是单向数据绑定。 这两个截然不同的机制，为什么又都能自圆其说呢？在同一个时代里怎么建立统一的理解？还是说两种机制有各自适合的最佳场景？

一般来说，非 UI 控件不存在双向的，只有单向数据流。UI 控件才有双向的数据流问题。

单项绑定使得数据流也是单向的，对于复杂应用来说这是实施统一的状态管理（如 redux）的前提。

双向绑定在一些需要实时反应用户输入的场合会非常方便（eg. 多级联动菜单）。但通常认为复杂应用中这种便利比不上引入状态管理带来的优势。

#### 二者的差异

#### 原理

**双向数据绑定和单向数据绑定的差异在于：双向数据绑定是把数据变更的操作隐藏的框架内部，调用者并不会直接感知。**

单向绑定相对应的似的数据流也是单向的，而在践行单向数据流的 flux 的设计框架（redux 是其一个具体实现）中实现中，其实不过是在全局搞了一个单例的事件分发器（dispatcher）,开发者必须显示的通过这个统一的时间机制来做数据变更通知。

其实这种方式跟框架对 UI 控件上实现双向绑定的方式是一样的。**底层都是事件机制**。

> 假设在双向绑定的应用中，我们有办法 hack 进框架对 UI 控件 自动绑定的事件 listener 或 数据 watcher，然后加上类似 dispatcher 的逻辑，双向绑定背后的状态变化我们一样可以管理起来，一样可以享用单向数据流才有的收益。

> 单向绑定中如果我们做进一步的封装，把 action 和 dispatcher 都隐藏在框架内部，最后就变成。如果再进一步，把相互手动通知机制再隐藏起来，就变成![sx2](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/sx2.jpg)sx

其实单双向绑定在一定程度上来说是可以转化的。只不过是框架封装程度上的差异，本质是可以相互转化的。

#### 优缺点

#### 单向绑定

##### 优点

- 单向绑定可以相应的带来单向数据流，这样的好处是所有的状态变化都是可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，没有“暗箱操作”。
- 组件数据只有唯一的入口和出口，使得程序更加直观更容易理解，有利于应用的可维护性。

##### 缺点

- 代码量会相应的上升，数据的流转过程变长，从而出现很多类似的样板代码。
- 由于对应用状态独立管理的严格要求（单一的全局 store）,在处理局部状态较多的场景时，会显得啰嗦以及繁琐。

#### 双向绑定

##### 优点

- 在表单交互较多的情况下，会简化大量业务无关的代码。

##### 缺点

- 由于都是“暗箱操作”，我们无法追踪局部状态的变化（虽然大部分情况下我们并不关心），潜在的行为太多也增加了出错时 debug 的难度。
- 由于组件数据变化来源入口变的可能不止一个，新手很容易将数据流转方向弄的紊乱，如果再缺乏一些“管制”手段，最后就很容易一处错误操作造成应用雪崩。

#### 适用场景

由以上的优缺点，我们可以得出单向绑定和双向绑定在功能上基本是互补的。

在 UI 控件中（通常是类表单操作），我们会使用双向的方式绑定数据；而其他场景则统一采用单向的方式构建应用。

#### Vue 与 Angular 以及 React 的区别？

（版本在不断更新，以下的区别有可能不是很正确。我工作中只用到 vue，对 angular 和 react 不怎么熟） 1.与 AngularJS 的区别
相同点：
都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。

不同点：
AngularJS 的学习成本高，比如增加了 Dependency Injection 特性，而 Vue.js 本身提供的 API 都比较简单、直观；在性能上，AngularJS 依赖对数据做脏检查，所以 Watcher 越多越慢；Vue.js 使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。

2.与 React 的区别
相同点：
React 采用特殊的 JSX 语法，Vue.js 在组件开发中也推崇编写.vue 特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数 AJAX，Route 等功能到核心包，而是以插件的方式加载；在组件开发中都支持 mixins 的特性。
不同点：
React 采用的 Virtual DOM 会对渲染出来的结果做脏检查；Vue.js 在模板中提供了指令，过滤器等，可以非常方便，快捷地操作 Virtual DOM。

1. vue 中的 MVVM 模式即 Model-View-ViewModel。Vue 是以数据为驱动的，Vue 自身将 DOM 和数据进行绑定，一旦创建绑定，DOM 和数据将保持同步，每当数据发生变化，DOM 会跟着变化。ViewModel 是 Vue 的核心，它是 Vue 的一个实例。Vue 实例时作用域某个 HTML 元素上的，这个 HTML 元素可以是 body，也可以是某个 id 所指代的元素。DOM Listeners 和 Data Bindings 是实现双向绑定的关键。DOM Listeners 监听页面所有 View 层 DOM 元素的变化，当发生变化，Model 层的数据随之变化；Data Bindings 监听 Model 层的数据，当数据发生变化，View 层的 DOM 元素随之变化。2. v-show 指令，v-if 的区别条件渲染指令，与 v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于 HTML 代码中；而只有当 v-if 的值为 true，元素才会存在于 HTML 代码中。v-show 指令只是设置了元素 CSS 的 style 值 3.  如何让 css 只在当前组件中起作用在每一个 vue 组件中都可以定义各自的 css，js，如果希望组件内写的 css 只对当前组件起作用，只需要在 style 中写入 scoped，即：<style scoped></style>复制代码 4.  指令 keep-alive 在 vue-router 写着 keep-alive，keep-alive 的含义：如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令<component :is='curremtView' keep-alive></component>5. Vuejs 组件 vuejs 构建组件使用 Vue.component('componentName',{
   /_component_/
   })；
   // 这里注意一点，组件要先注册再使用
   Vue.component('mine',{
   template:'#mineTpl',
   props:['name','title','city','content']
   });
   var v=new Vue({
   el:'#vueInstance',
   data:{
   name:'zhang',
   title:'this is title',
   city:'Beijing',
   content:'these are some desc about Blog'
   }
   });复制代码 6.  路由嵌套路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转 router-view 本身就是将组件渲染到该位置，想要进行页面跳转，就要将页面渲染到根组件，在起始配置路由时候写到：var App = Vue.extend({ root });
   router.start(App,'#app');复制代码这里首先将根组件注册进来，用于将路由中配置好的各个页面渲染出来，然后将根组件挂载到与#app 匹配的元素上。7.  指令 v-el 的使用有时候我们想就像使用 jquery 那样去访问一个元素，此时就可以使用 v-el 指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。注意HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。示例<span v-el:msg>hello</span>
   <span v-el:other-msg>world</span>
   this.$els.msg.textContent //-> "hello"
this.$els.otherMsg.textContent// -> "world"
   this.\$els.msg//-><span>hello</span>复制代码 8. vue.js 中使用事件名在 vuejs 中，我们经常要绑定一些事件，有时候给 DOM 元素绑定，有时候给组件绑定。绑定事件在 HTML 中用 v-on:click-"event",这时 evet 的名字不要出现大写，因为在 1.x 中不区分大小写，所以如果我们在 HTML 写 v-on:click="myEvent"而在 js 中写 myEvent 就出错误，所以在 vuejs 的 1.x 绑定事件时候，要尽量避免使用大写字母。在 2.0 中没有该限制！9. Vue.js 是什么 Vue.js（是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件 10. VueJS 特性：I: MVVM 模式（数据变量（model）发生改变 视图（view）也改变， 视图（view）改变，数据变量（model）也发生改变）使用 MVVM 模式有几大好处：　　 1. 低耦合。View 可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。　　 2. 可重用性。可以把一些视图的逻辑放在 ViewModel 里面，让很多 View 重用这段视图逻辑。　　 3. 独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。　　 4. 可测试性。可以针对 ViewModel 来对界面(View)进行测试 II: 组件化 III 指令系统 IIII: vue2.0 开始支持虚拟 domvue1.0 是操作的是真的 dom 元素而不是虚拟的虚拟 dom:可以提升页面的刷新速度虚拟 DOM 有利也有弊。A：大小

- 其中之一就是更多的功能意味着代码包中更多行的代码。幸运的是，Vue.js 2.0 依旧比 较小（当前版本 21.4kb），并且也正在删除很多东西。B: 内存 -同样，虚拟 DOM 需要将现有的 DOM 拷贝后保存在内存中，这是一个在 DOM 更新速度和内存使用中的权衡。C: 并不适用所有情况 -如果虚拟 DOM 可以一次性进行批量的修改是非常好的。但是如果是单独的、稀少的更新呢？这样的任何 DOM 更新都将会使虚拟 DOM 带来无意义的预计算 11. Vue.js 特点简洁：页面由 HTML 模板+Json 数据+Vue 实例组成数据驱动：自动计算属性和追踪依赖的模板表达式组件化：用可复用、解耦的组件来构造页面轻量：代码量小，不依赖其他库快速：精确有效批量 DOM 更新模板友好：可通过 npm，bower 等多种方式安装，很容易融入 12. Vue.js 和 AngularJS 之间的区别是什么? 下面是一些选择 Vue 而不是 Angular 的可能原因；Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织你的应用程序，而不是任何时候都必须遵循
  Angular 制定的规则。它仅仅是一个视图层，所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在结合其他库方面它给了你更大的的空间，但相应，你也需要做更多的架构决策。例如，Vue.js 核心默认不包含路由和 ajax 功能，并且通常假定你在用应用中使用了一个外部的模块构建系统。这可能是最重要的区别在 API 和内部设计方面，Vue.js 比 Angular 简单得多, 因此你可以快速地掌握它的全部特性并投入开发。Vue.js 拥有更好的性能，因为它不使用脏检查。当 watcher 越来越多时, Angular 会变得越来越慢，因为作用域内的每一次数据变更，所有的 watcher
  都需要被重新求值。Vue 则根本没有这个问题，因为它采用的是基于依赖追踪的观察系统，所以所有的数据变更触发都是独立的，除非它们之间有明确的依赖关系。Vue.js 中指令和组件的概念区分得更为清晰。指令只负责封装 DOM 操作，而组件代表一个自给自足的独立单元
  —— 它拥有自己的视图和数据逻辑。在 Angular 中它们两者间有不少概念上的混淆。 13. Vue.js 和 React.js 有什么区别?React.js 和 Vue.js 确实有一些相似——它们都提供数据驱动、可组合搭建的视图组件。然而，它们的内部实现是完全不同的。React 是基于 Virtual DOM——一种在内存中描述 DOM 树状态的数据结构。React 中的数据通常被看作是不可变的，而 DOM 操作则是通过 Virtual DOM 的 diff 来计算的。与之相比，Vue.js 中的数据默认是可变的，而数据的变更会直接出发对应的 DOM 更新。相比于 Virtual DOM，Vue.js 使用实际的 DOM 作为模板，并且保持对真实节点的引用来进行数据绑定。Virtual DOM 提供了一个函数式的描述视图的方法，这很 cool。因为它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图通与数据的同步。它也开辟了 JavaScript 同构应用的可能性。实话实说，我自己对 React 的设计理念也是十分欣赏的。但 React 有一个问题就是组件的逻辑和视图结合得非常紧密。对于部分开发者来说，他们可能觉得这是个优点，但对那些像我一样兼顾设计和开发的人来说，还是更偏好模板，因为模板能让我们更好地在视觉上思考设计和 CSS。JSX 和
  JavaScript 逻辑的混合干扰了我将代码映射到设计的思维过程。相反，Vue.js 通过在模板中加入一个轻量级的 DSL (指令系统)，换来一个依旧直观的模板，且能够将逻辑封装进指令和过滤器中。

React 的另一个问题是：由于 DOM 更新完全交由
Virtual DOM 管理，当你真的想要自己控制 DOM 是就有点棘手了（虽然理论上你可以，但这样做时你本质上在对抗 React 的设计思想）。对于需要复杂时间控制的动画来说这就变成了一项很讨人厌的限制。在这方面，Vue.js 允许更多的灵活性，并且有不少用 Vue.js 构建的富交互实例 14. 请详细说下你对 Vue 生命周期的理解？总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在15. 组件之间如何传值？父组件与子组件传值：Props子组件向父组件传递数据: 子组件通过$emit 方法传递参数,触发父组件 event16. vue-router 有哪几种导航钩子?全局导航钩子 router.beforeEach(to, from, next),router.beforeResolve(to, from, next),router.afterEach(to, from ,next)组件内钩子 beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave 单独路由独享组件 beforeEnter17. vue 的双向绑定的原理是什么 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。18. vuex 的 mutation 和 action 的特性是什么？有什么区别？mutation 用于修改 state 的数据，是同步的。action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态 action 可以包含任意异步操作 19. 写 React / Vue 项目时为什么要在组件中写 key，其作用是什么?在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 Diff 算法中 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。20. computed 和 watched 的区别：computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。

https://juejin.im/post/5cc913b26fb9a031f525d36e
https://juejin.im/post/59ffb4b66fb9a04512385402
https://blog.csdn.net/RedaTao/article/details/80617514
https://yq.aliyun.com/articles/613427
https://cloud.tencent.com/developer/article/1145420
https://www.jianshu.com/p/e54a9a34a773
https://www.cnblogs.com/DCL1314/p/8135502.html

vue 原理： https://www.zhihu.com/people/hoholoving/activities

### Vue vs React

- 设计理念
- 概念堆砌
- SSR 支持
- API 设计
- 生态成熟度
- 模板渲染
- 数据流
- HOC vs mixins
- 数据变化原理
- 组件通信
- App 支持
- 构建工具
- 上手成本
- 开发效率
- 维护难度

### 23.介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景

发布-订阅模式就好像报社， 邮局和个人的关系，报纸的订阅和分发是由邮局来完成的。报社只负责将报纸发送给邮局。
观察者模式就好像 个体奶农和个人的关系。奶农负责统计有多少人订了产品，所以个人都会有一个相同拿牛奶的方法。奶农有新奶了就负责调用这个方法。

### 24.聊聊 Redux 和 Vuex 的设计思想

https://zhuanlan.zhihu.com/p/53599723

### 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

#### key 的作用是什么？

我重新梳理了一下文字，可能这样子会更好理解一些。

key 是给每一个 vnode 的唯一 id,可以`依靠key`,更`准确`, 更`快`的拿到 oldVnode 中对应的 vnode 节点。

##### 1. 更准确

因为带 key 就不是`就地复用`了，在 sameNode 函数 `a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。

##### 2. 更快

利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map 会比遍历更快。)

#### 完整

能提高 diff 效率其实是不准确的。

见[vue/patch.js](https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L424)，在不带 key 的情况下，判断[sameVnode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L35)时因为 a.key 和 b.key 都是 undefined，**对于列表渲染**来说已经可以判断为相同节点然后调用 patchVnode 了，实际根本不会进入到答主给的 else 代码，也就无从谈起“带 key 比不带 key 时 diff 算法更高效”了。

然后，官网推荐推荐的使用 key，应该理解为“使用唯一 id 作为 key”。因为 index 作为 key，和不带 key 的效果是一样的。index 作为 key 时，每个列表项的 index 在变更前后也是一样的，都是直接判断为 sameVnode 然后复用。

说到底，key 的作用就是更新组件时**判断两个节点是否相同**。相同就复用，不相同就删除旧的创建新的。

正是因为带唯一 key 时每次更新都不能找到可复用的节点，不但要销毁和创建 vnode，在 DOM 里添加移除节点对性能的影响更大。所以会才说“不带 key 可能性能更好”。看下面这个实验，渲染 10w 列表项，带唯一 key 与不带 key 的时间对比：

不使用 key 的情况：

```
<li v-for="item in list">{{ item.text }}</li>
```

[![image](https://user-images.githubusercontent.com/23716085/53108518-22543a80-3572-11e9-83b2-16b4aab7cdb9.png)](https://user-images.githubusercontent.com/23716085/53108518-22543a80-3572-11e9-83b2-16b4aab7cdb9.png)

使用 id 作为 key 的情况：

```
<li v-for="item in list" :key="item.id">{{ n.text }}</li>
```

[![image](https://user-images.githubusercontent.com/23716085/53108768-88d95880-3572-11e9-9f29-0082bf89eb3a.png)](https://user-images.githubusercontent.com/23716085/53108768-88d95880-3572-11e9-9f29-0082bf89eb3a.png)

list 构造：

```
  const list1 = []
  const list2 = []
  for (let i = 0; i <= 100000; i++) {
    list1.push({
      id: i,
      text: i
    })
    list2.push({
      id: i * 2,
      name: 100000 - i
    })
  }
```

因为不带 key 时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改 DOM 文本内容而不是移除/添加节点，这就是文档中所说的“刻意依赖默认行为以获取性能上的提升”。

既然如此，为什么还要建议带 key 呢？因为这种模式只适用于渲染简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。

举个例子：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过 tab 切换“娱乐新闻”或是“社会新闻”。

不带 key 属性的情况下，在“娱乐新闻”下选中第二项然后切换到“社会新闻”，"社会新闻"里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上新闻 id 作为唯一 key，那么每次渲染列表时都会完全替换所有组件，使其拥有正确状态。

这只是个简单的例子，实际应用会更复杂。带上唯一 key 虽然会增加开销，但是对于用户来说基本感受不到差距，而且能保证组件状态正确，这应该就是为什么推荐使用唯一 id 作为 key 的原因。至于具体怎么使用，就要根据实际情况来选择了。

以上个人见解，如有误望指正。

### 29.聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的

VM 主要做了两件微小的事情：

- **从 M 到 V 的映射（Data Binding）**，这样可以大量节省你人肉来 update View 的代码
- **从 V 到 M 的事件监听（DOM Listeners）**，这样你的 Model 会随着 View 触发事件而改变

**1、M 到 V 实现**

做到这件事的第一步是形成类似于：

```js
// template
var tpl = '<p>{{ text }}</p>';
// data
var data = {
  text: 'This is some text',
};
// magic process
template(tpl, data); // '<p>This is some text</p>'
```

中间的 magic process 是模板引擎所做的事情，已经有非常多种模板引擎可供选择

- [JavaScript templates](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/JavaScript_templates)

当然你比较喜欢造轮子的话也可以自己实现一个

- [JavaScript template engine in just 20 lines](https://link.zhihu.com/?target=http%3A//krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line)
- [一个 JavaScript 模板引擎的实现](https://link.zhihu.com/?target=http%3A//kyleslight.net/article/27)

无论是 Angular 的 \$scope，React 的 state 还是 Vue 的 data 都提供了一个较为核心的 model 对象用来保存模型的状态；它们的模板引擎稍有差别，不过大体思路相似；拿到渲染后的 string 接下来做什么不言而喻了（中间还有很多处理，例如利用 model 的 diff 来最小量更新 view ）。

但是仅仅是这样并不够，我们需要知道什么时候来更新 view（ 即 render ），一般来说主要的 VM 做了以下几种选择：

- VM 实例初始化时
- model 动态修改时

其中初始化拿到 model 对象然后 render 没什么好讲的；model 被修改的时候如何监听属性的改变是一个问题，目前有以下几种思路：

- 借助于 Object 的 observe 方法
- 自己在 set，以及数组的常用操作里触发 change 事件
- 手动 setState()，然后在里面触发 change 事件

知道了触发 render 的时机以及如何 render，一个简单的 M 到 V 映射就实现了。

**2、V 到 M 实现**

从 V 到 M 主要由两类（ 虽然本质上都是监听 DOM ）构成，一类是用户自定义的 listener， 一类是 VM 自动处理的含有 value 属性元素的 listener

第一类类似于你在 Vue 里用 v-on 时绑定的那样，VM 在实例化得时候可以将所有用户自定义的 listener 一次性代理到根元素上，这些 listener 可以访问到你的 model 对象，这样你就可以在 listener 中改变 model

第二类类似于对含有 v-model 与 value 元素的自动处理，我们期望的是例如在一个输入框内

```js
<input type="text" v-model="message" />
```

输入值，那么我与之对应的 model 属性 message 也会随之改变，相当于 VM 做了一个默认的 listener，它会监听这些元素的改变然后自动改变 model，具体如何实现相信你也明白了
