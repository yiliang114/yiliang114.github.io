---
layout: CustomPages
title: Vue vs React
date: 2020-11-21
aside: false
draft: true
---

### Vue 和 React 之间的区别

1. 数据绑定 Vue 双向绑定， React 单向数据流。
2. Vue 默认使用 template 模板，React 使用 JSX。
3. 改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用 `setState` 来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。
4. React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因。
5. React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 `render` 函数就能在浏览器中运行。
6. React 相较于 Vue 来说上手成本略高， 例如 JSX 之类的概念。vue 简单很多，官方做了做了很多 CSS script 编译

#### React 优势

- 在大型应用程序开发中提供更大的灵活性。
- 更容易测试。
- 更适合创建移动端应用程序。
- 提供更多的信息和解决方案。

### React 与 Vue 区别

- api
  - Vue 多，计算属性，watch 这种神器
  - React 少，更多功能留给社区，比如写个函数还有 bind 以下
- 应用
  - Vue 适合面向用户的，复杂度稍低一些的
  - React 复杂的
- 测试
  - React 函数式编程利于测试

### Vue 和 React 区别

- 相同点：都支持 `ssr`，都有 `vdom`，组件化开发，实现 `webComponents` 规范，数据驱动等
- 不同点：`Vue` 是双向数据流（当然为了实现单数据流方便管理组件状态，`vuex` 便出现了），`React` 是单向数据流。`Vue`的 `vdom` 是追踪每个组件的依赖关系，不会渲染整个组件树，`React` 每当应该状态被改变时，全部子组件都会 `re-render`

### 单向数据流和双向数据流区别？

> 经常看见在 Vue 或者 angular 的介绍里说自己的特色是双向数据绑定，而在看 React 的介绍中，说自己的优势和特色是单向数据绑定。 这两个截然不同的机制，为什么又都能自圆其说呢？在同一个时代里怎么建立统一的理解？还是说两种机制有各自适合的最佳场景？

一般来说，非 UI 控件不存在双向的，只有单向数据流。UI 控件才有双向的数据流问题。

单向绑定使得数据流也是单向的，对于复杂应用来说这是实施统一的状态管理（如 redux）的前提。

双向绑定在一些需要实时反应用户输入的场合会非常方便（eg. 多级联动菜单）。但通常认为复杂应用中这种便利比不上引入状态管理带来的优势。

#### 二者的差异

#### 原理

**双向数据绑定和单向数据绑定的差异在于：双向数据绑定是把数据变更的操作隐藏的框架内部，调用者并不会直接感知。**

单向绑定相对应的似的数据流也是单向的，而在践行单向数据流的 flux 的设计框架（redux 是其一个具体实现）中实现中，其实不过是在全局搞了一个单例的事件分发器（dispatcher）,开发者必须显示的通过这个统一的时间机制来做数据变更通知。

其实这种方式跟框架对 UI 控件上实现双向绑定的方式是一样的。**底层都是事件机制**。

> 假设在双向绑定的应用中，我们有办法 hack 进框架对 UI 控件 自动绑定的事件 listener 或 数据 watcher，然后加上类似 dispatcher 的逻辑，双向绑定背后的状态变化我们一样可以管理起来，一样可以享用单向数据流才有的收益。

> 单向绑定中如果我们做进一步的封装，把 action 和 dispatcher 都隐藏在框架内部，最后就变成。如果再进一步，把相互手动通知机制再隐藏起来，就变成![sx2](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/sx2.jpg)sx

其实单双向绑定在一定程度上来说是可以转化的。只不过是框架封装程度上的差异，本质是可以相互转化的。

#### 优缺点

#### 单向绑定

##### 优点

- 单向绑定可以相应的带来单向数据流，这样的好处是所有的状态变化都是可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，没有“暗箱操作”。
- 组件数据只有唯一的入口和出口，使得程序更加直观更容易理解，有利于应用的可维护性。

##### 缺点

- 代码量会相应的上升，数据的流转过程变长，从而出现很多类似的样板代码。
- 由于对应用状态独立管理的严格要求（单一的全局 store）,在处理局部状态较多的场景时，会显得啰嗦以及繁琐。

#### 双向绑定

##### 优点

- 在表单交互较多的情况下，会简化大量业务无关的代码。

##### 缺点

- 由于都是“暗箱操作”，我们无法追踪局部状态的变化（虽然大部分情况下我们并不关心），潜在的行为太多也增加了出错时 debug 的难度。
- 由于组件数据变化来源入口变的可能不止一个，新手很容易将数据流转方向弄的紊乱，如果再缺乏一些“管制”手段，最后就很容易一处错误操作造成应用雪崩。

#### 适用场景

由以上的优缺点，我们可以得出单向绑定和双向绑定在功能上基本是互补的。

在 UI 控件中（通常是类表单操作），我们会使用双向的方式绑定数据；而其他场景则统一采用单向的方式构建应用。

#### Vue 与 Angular 以及 React 的区别？

（版本在不断更新，以下的区别有可能不是很正确。我工作中只用到 vue，对 angular 和 React 不怎么熟） 1.与 AngularJS 的区别
相同点：
都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。

不同点：
AngularJS 的学习成本高，比如增加了 Dependency Injection 特性，而 Vue.js 本身提供的 API 都比较简单、直观；在性能上，AngularJS 依赖对数据做脏检查，所以 Watcher 越多越慢；Vue.js 使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。

2.与 React 的区别
相同点：
React 采用特殊的 JSX 语法，Vue.js 在组件开发中也推崇编写.Vue 特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数 AJAX，Route 等功能到核心包，而是以插件的方式加载；在组件开发中都支持 mixins 的特性。
不同点：
React 采用的 Virtual DOM 会对渲染出来的结果做脏检查；Vue.js 在模板中提供了指令，过滤器等，可以非常方便，快捷地操作 Virtual DOM。

1. Vue 中的 MVVM 模式即 Model-View-ViewModel。Vue 是以数据为驱动的，Vue 自身将 DOM 和数据进行绑定，一旦创建绑定，DOM 和数据将保持同步，每当数据发生变化，DOM 会跟着变化。ViewModel 是 Vue 的核心，它是 Vue 的一个实例。Vue 实例时作用域某个 HTML 元素上的，这个 HTML 元素可以是 body，也可以是某个 id 所指代的元素。DOM Listeners 和 Data Bindings 是实现双向绑定的关键。DOM Listeners 监听页面所有 View 层 DOM 元素的变化，当发生变化，Model 层的数据随之变化；Data Bindings 监听 Model 层的数据，当数据发生变化，View 层的 DOM 元素随之变化。2. v-show 指令，v-if 的区别条件渲染指令，与 v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于 HTML 代码中；而只有当 v-if 的值为 true，元素才会存在于 HTML 代码中。v-show 指令只是设置了元素 CSS 的 style 值 3.  如何让 css 只在当前组件中起作用在每一个 Vue 组件中都可以定义各自的 css，js，如果希望组件内写的 css 只对当前组件起作用，只需要在 style 中写入 scoped，即：<style scoped></style>复制代码 4.  指令 keep-alive 在 Vue-router 写着 keep-alive，keep-alive 的含义：如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令<component :is='curremtView' keep-alive></component>5. Vuejs 组件 vuejs 构建组件使用 Vue.component('componentName',{
   /_component_/
   })；
   // 这里注意一点，组件要先注册再使用
   Vue.component('mine',{
   template:'#mineTpl',
   props:['name','title','city','content']
   });
   var v=new Vue({
   el:'#vueInstance',
   data:{
   name:'zhang',
   title:'this is title',
   city:'Beijing',
   content:'these are some desc about Blog'
   }
   });复制代码 6.  路由嵌套路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转 router-view 本身就是将组件渲染到该位置，想要进行页面跳转，就要将页面渲染到根组件，在起始配置路由时候写到：var App = Vue.extend({ root });
   router.start(App,'#app');复制代码这里首先将根组件注册进来，用于将路由中配置好的各个页面渲染出来，然后将根组件挂载到与#app 匹配的元素上。7.  指令 v-el 的使用有时候我们想就像使用 jquery 那样去访问一个元素，此时就可以使用 v-el 指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。注意HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。示例<span v-el:msg>hello</span>
   <span v-el:other-msg>world</span>
   this.$els.msg.textContent //-> "hello"
this.$els.otherMsg.textContent// -> "world"
   this.\$els.msg//-><span>hello</span>复制代码 8. Vue.js 中使用事件名在 vuejs 中，我们经常要绑定一些事件，有时候给 DOM 元素绑定，有时候给组件绑定。绑定事件在 HTML 中用 v-on:click-"event",这时 evet 的名字不要出现大写，因为在 1.x 中不区分大小写，所以如果我们在 HTML 写 v-on:click="myEvent"而在 js 中写 myEvent 就出错误，所以在 vuejs 的 1.x 绑定事件时候，要尽量避免使用大写字母。在 2.0 中没有该限制！9. Vue.js 是什么 Vue.js（是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件 10. VueJS 特性：I: MVVM 模式（数据变量（model）发生改变 视图（view）也改变， 视图（view）改变，数据变量（model）也发生改变）使用 MVVM 模式有几大好处：　　 1. 低耦合。View 可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。　　 2. 可重用性。可以把一些视图的逻辑放在 ViewModel 里面，让很多 View 重用这段视图逻辑。　　 3. 独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。　　 4. 可测试性。可以针对 ViewModel 来对界面(View)进行测试 II: 组件化 III 指令系统 IIII: vue2.0 开始支持虚拟 domvue1.0 是操作的是真的 dom 元素而不是虚拟的虚拟 dom:可以提升页面的刷新速度虚拟 DOM 有利也有弊。A：大小

- 其中之一就是更多的功能意味着代码包中更多行的代码。幸运的是，Vue.js 2.0 依旧比 较小（当前版本 21.4kb），并且也正在删除很多东西。B: 内存 -同样，虚拟 DOM 需要将现有的 DOM 拷贝后保存在内存中，这是一个在 DOM 更新速度和内存使用中的权衡。C: 并不适用所有情况 -如果虚拟 DOM 可以一次性进行批量的修改是非常好的。但是如果是单独的、稀少的更新呢？这样的任何 DOM 更新都将会使虚拟 DOM 带来无意义的预计算 11. Vue.js 特点简洁：页面由 HTML 模板+Json 数据+Vue 实例组成数据驱动：自动计算属性和追踪依赖的模板表达式组件化：用可复用、解耦的组件来构造页面轻量：代码量小，不依赖其他库快速：精确有效批量 DOM 更新模板友好：可通过 npm，bower 等多种方式安装，很容易融入 12. Vue.js 和 AngularJS 之间的区别是什么? 下面是一些选择 Vue 而不是 Angular 的可能原因；Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织你的应用程序，而不是任何时候都必须遵循
  Angular 制定的规则。它仅仅是一个视图层，所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在结合其他库方面它给了你更大的的空间，但相应，你也需要做更多的架构决策。例如，Vue.js 核心默认不包含路由和 ajax 功能，并且通常假定你在用应用中使用了一个外部的模块构建系统。这可能是最重要的区别在 API 和内部设计方面，Vue.js 比 Angular 简单得多, 因此你可以快速地掌握它的全部特性并投入开发。Vue.js 拥有更好的性能，因为它不使用脏检查。当 watcher 越来越多时, Angular 会变得越来越慢，因为作用域内的每一次数据变更，所有的 watcher
  都需要被重新求值。Vue 则根本没有这个问题，因为它采用的是基于依赖追踪的观察系统，所以所有的数据变更触发都是独立的，除非它们之间有明确的依赖关系。Vue.js 中指令和组件的概念区分得更为清晰。指令只负责封装 DOM 操作，而组件代表一个自给自足的独立单元
  —— 它拥有自己的视图和数据逻辑。在 Angular 中它们两者间有不少概念上的混淆。 13. Vue.js 和 React.js 有什么区别?React.js 和 Vue.js 确实有一些相似——它们都提供数据驱动、可组合搭建的视图组件。然而，它们的内部实现是完全不同的。React 是基于 Virtual DOM——一种在内存中描述 DOM 树状态的数据结构。React 中的数据通常被看作是不可变的，而 DOM 操作则是通过 Virtual DOM 的 diff 来计算的。与之相比，Vue.js 中的数据默认是可变的，而数据的变更会直接出发对应的 DOM 更新。相比于 Virtual DOM，Vue.js 使用实际的 DOM 作为模板，并且保持对真实节点的引用来进行数据绑定。Virtual DOM 提供了一个函数式的描述视图的方法，这很 cool。因为它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图通与数据的同步。它也开辟了 JavaScript 同构应用的可能性。实话实说，我自己对 React 的设计理念也是十分欣赏的。但 React 有一个问题就是组件的逻辑和视图结合得非常紧密。对于部分开发者来说，他们可能觉得这是个优点，但对那些像我一样兼顾设计和开发的人来说，还是更偏好模板，因为模板能让我们更好地在视觉上思考设计和 CSS。JSX 和
  JavaScript 逻辑的混合干扰了我将代码映射到设计的思维过程。相反，Vue.js 通过在模板中加入一个轻量级的 DSL (指令系统)，换来一个依旧直观的模板，且能够将逻辑封装进指令和过滤器中。

React 的另一个问题是：由于 DOM 更新完全交由
Virtual DOM 管理，当你真的想要自己控制 DOM 是就有点棘手了（虽然理论上你可以，但这样做时你本质上在对抗 React 的设计思想）。对于需要复杂时间控制的动画来说这就变成了一项很讨人厌的限制。在这方面，Vue.js 允许更多的灵活性，并且有不少用 Vue.js 构建的富交互实例 14. 请详细说下你对 Vue 生命周期的理解？总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 Vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在15. 组件之间如何传值？父组件与子组件传值：Props子组件向父组件传递数据: 子组件通过$emit 方法传递参数,触发父组件 event16. Vue-router 有哪几种导航钩子?全局导航钩子 router.beforeEach(to, from, next),router.beforeResolve(to, from, next),router.afterEach(to, from ,next)组件内钩子 beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave 单独路由独享组件 beforeEnter17. Vue 的双向绑定的原理是什么 Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。18. vuex 的 mutation 和 action 的特性是什么？有什么区别？mutation 用于修改 state 的数据，是同步的。action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态 action 可以包含任意异步操作 19. 写 React / Vue 项目时为什么要在组件中写 key，其作用是什么?在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 Diff 算法中 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。20. computed 和 watched 的区别：computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。

### React 和 Vue 对比

相同点:

数据驱动视图，提供响应式的视图组件
都有 Virtual DOM，组件化开发，通过 props 参数进行父子组件数据的传递，都实现 webComponents 规范
数据流动单向
都支持服务端渲染
都有支持 native 的方案，React 的 React native，Vue 的 weex
不同点：

社区：React 社区还是要比 vue 大很多；

开发模式：React 在 view 层侵入性还是要比 Vue 大很多的,React 严格上只针对 MVC 的 view 层，Vue 则是 MVVM 模式的一种实现；

数据绑定：Vue 有实现了双向数据绑定，React 数据流动是单向的

数据渲染：对于大规模数据渲染，React 要比 Vue 更快，渲染机制启动时候要做的工作比较多；

数据更新方面：Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。React 在复杂的应用里有两个选择:

(1). 手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render。 (2).Components 尽可能都用 pureRenderMixin，然后采用 redux 结构 + Immutable.js；

开发风格的偏好：React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即"all in js"；Vue 进阶之后推荐的是使用 webpack + vue-loader 的单文件组件格式，即 html,css,js 写在同一个文件；

使用场景：React 配合 Redux 架构适合超大规模多人协作的复杂项目;Vue 则适合小快灵的项目。对于需要对 DOM 进行很多自定义操作的项目，Vue 的灵活性优于 React；

Vue 要比 React 更好上手，具体可能体现在很多人不熟悉 React 的 JSX 语法和函数式编程的思想，以及想要发挥出 React 的最大威力需要学习它一系列生态的缘故；

Vue 着重提高开发效率,让前端程序员更快速方便的开发应用。React 着重于变革开发思想，提升前端程序员编程的深度与创造力,让前端工程师成为真正的程序员而不是 UI 的构建者；

### react 和 vue 更新机制的区别

React 组件的属性

React 是一个单纯的 view 层框架,官方推荐使用 JSX 预发来维护组件的状态.通过 Props 和 state 来共同决定组件的表现.

- Props
  正如 prop 的英文意思属性一样,Props 中的数据主要用来定义和描述组件的属性,该数据是由父组件在声明 React 组件的时候设置,就好比我们给一个 img 标签设置一个 src 属性一样,我们可以给自定义的 React 组件设置许多属性. 这些属性定义了 React 组件的表现形式,父组件可以通过修改 Props 中的属性来控制子组件的表现.
- state
  同样的,state 表示状态,那么 state 中的数据主要用来控制组件内部的状态. 也就是说组件内部的变化,不需要同外部有交互的数据,都可以有组件自己通过 state 来控制.
  React 虚拟树更新原则

React 中应用虚拟 DOM 来更新快速更新 DOM,那么更新虚拟 DOM 的原则主要是以下几种:

- 不同元素
  如果更新前后是两种不同类型的 DOM 元素,那就没什么说的,直接销毁原来的节点,创建新的节点.(比如原来是 div,更新为 span)在这个过程中,原来节点的 componentWillUnmount 函数被触犯, 新节点的 componentWillMount 和 componentDidMount 依次被触发. 需要特别指出的是,当前更新节点的所有子节点都会被销毁重建,而不管子节点是否有更新. 简单的来说,就是根变了,那么这个根上的所有叶子都要更新了.
- 相同元素,不同属性
  当节点类型没有发生变化,而只是熟悉变化的话,React 就智能多了,只会更新变化的部分. 好比是一个元素有多个 CSS 样式,如果只变化了一个样式,那么 React 也只更新一个. 当元素不是叶子节点的时候,也就是一个组件元素的时候,会继续深入的去比较子元素来更新子元素.
- 子元素变动.
  当子元素有变动的时候,React 会更新子元素.
  子元素的变动指的是资源的类型/属性/位置等的变动. 类型和属性的变动会触发更新,这个比较好理解.子元素的位置变动,指的是如果一个资源原来在第一位,更新后到第二位了,React 会认为这是一种变动,从而触发更新.
- key 属性的重要作用
  这样看起来 React 也没有那么智能.那么这个时候就要引入一个很重要的 key 属性.React 通过给子组件一个 key 属性.来唯一标识一个子组件,如果更新前后的组件 key 值一样,并且除了位置之外其他属性没有变化,那么就不会触发更新.

Vue 的数据

Vue 是一个传统意义上的 mvc 模型.通过实例化一个 vue 对象来绑定 dom 和 data 的关系,也就是绑定 view 和 model.通过对 model 中每个属性添加反射来完成监视器的注册. 当 model 中的数据模型变化时,watcher 会重新计算,从而引发 view 层的更新.

这也就是理解了为什么 Vue 是单向数据流了

Vue 的更新.

上面提到,vue 的更新是 model 中数据的变化引发在初始化时注入的 watcher 的变化,从而引起 view 层的更新.只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。

根据以上特点,我们知道 vue 中的组件更新是有 model 数据的更新引起的,因为 view 和 model 在初始化时已经完成绑定,所以当 model 发生变化时,哪些 view 需要变化已经很明确了,所以就不需要像 React 那般去判断比对了
