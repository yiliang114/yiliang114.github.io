---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### React 是什么？

- React 不是 MV\* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层
- React 主要的原理：

  - 虚拟 DOM + diff 算法 -> 不直接操作 DOM 对象
  - Components 组件 -> Virtual DOM 的节点
  - State 触发视图的渲染 -> 单向数据绑定
  - React 解决方案：React + Redux + react-router + Fetch + webpack

#### React 的优点是什么?

使用 `Virtual DOM` 提高应用程序的性能。
JSX 使代码易于读写。
它支持在客户端和服务端渲染。
易于与框架（Angular，Backbone）集成，因为它只是一个视图库。
使用 Jest 等工具轻松编写单元与集成测试。

#### React 的局限性是什么?

React 只是一个视图库，而不是一个完整的框架。
对于 Web 开发初学者来说，有一个学习曲线。
将 React 集成到传统的 MVC 框架中需要一些额外的配置。
代码复杂性随着内联模板和 JSX 的增加而增加。
如果有太多的小组件可能增加项目的庞大和复杂。

### 使用 React 有何优点

- JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的
- 支持服务端渲染，可改进 SEO 和性能
- 易于测试
- React 只关注 View 层，所以可以和其它任何框架(如 Backbone.js, Angular.js)一起使用

### 什么是 JSX?

JSX 是 ECMAScript 一个类似 XML 的语法扩展。基本上，它只是为 `React.createElement()` 函数提供语法糖，从而让在我们在 JavaScript 中，使用类 HTML 模板的语法，进行页面描述。

在下面的示例中，`<h1>` 内的文本标签会作为 JavaScript 函数返回给渲染函数。

```jsx
class App extends React.Component {
  render() {
    return (
      <div>
        <h1>{'Welcome to React world!'}</h1>
      </div>
    );
  }
}
```

以上示例 render 方法中的 JSX 将会被转换为以下内容：

```js
React.createElement('div', null, React.createElement('h1', null, 'Welcome to React world!'));
```

编译函数

```js
/** @jsx h */
```

jsx 文件顶部可以指定 pragma, 默认情况下是 `React.createElement` 这也就是为什么，js 文件中需要默认引入 react 的原因。
指定 h 函数。

https://zhuanlan.zhihu.com/p/28035334

### JSX 如何防止注入攻击?

React DOM 会在渲染 JSX 中嵌入的任何值之前对其进行转义。因此，它确保你永远不能注入任何未在应用程序中显式写入的内容。

```js
const name = response.potentiallyMaliciousInput;
const element = <h1>{name}</h1>;
```

这样可以防止应用程序中的 XSS（跨站点脚本）攻击。

### 何为纯函数(pure function)

一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。

### 除了在构造函数中绑定 `this`，还有其它方式吗

你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。

### 怎么用 React.createElement 重写下面的代码

Question：

```js
const element = <h1 className="greeting">Hello, world!</h1>;
```

Answer：

```js
const element = React.createElement('h1', { className: 'greeting' }, 'Hello, world!');
```

### 为什么不能直接更新状态?

如果你尝试直接改变状态，那么组件将不会重新渲染。

```js
//Wrong
this.state.message = 'Hello world';
```

正确方法应该是使用 `setState()` 方法。它调度组件状态对象的更新。当状态更改时，组件通将会重新渲染。

```js
//Correct
this.setState({ message: 'Hello World' });
```

**注意：** 你可以在 `constructor` 中或使用最新的 JavaScript 类属性声明语法直接设置状态对象。

### 在 React 中如何校验 props 属性?

当应用程序以开发模式运行的时，React 将会自动检查我们在组件上设置的所有属性，以确保它们具有正确的类型。如果类型不正确，React 将在控制台中生成警告信息。由于性能影响，它在生产模式下被禁用。使用 `isRequired` 定义必填属性。

预定义的 prop 类型：

`PropTypes.number`
`PropTypes.string`
`PropTypes.array`
`PropTypes.object`
`PropTypes.func`
`PropTypes.node`
`PropTypes.element`
`PropTypes.bool`
`PropTypes.symbol`
`PropTypes.any`

我们可以为 `User` 组件定义 `propTypes`，如下所示：

```jsx
import React from 'react';
import PropTypes from 'prop-types';

class User extends React.Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number.isRequired,
  };

  render() {
    return (
      <>
        <h1>{`Welcome, ${this.props.name}`}</h1>
        <h2>{`Age, ${this.props.age}`}</h2>
      </>
    );
  }
}
```

**注意:** 在 React v15.5 中，_PropTypes_ 从 `React.PropTypes` 被移动到 `prop-types` 库中。

### 在 React v16 中的错误边界是什么?

错误边界是在其子组件树中的任何位置捕获 JavaScript 错误、记录这些错误并显示回退 UI 而不是崩溃的组件树的组件。

如果一个类组件定义了一个名为 `componentDidCatch(error, info)` 或 `static getDerivedStateFromError()` 新的生命周期方法，则该类组件将成为错误边界：

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  componentDidCatch(error, info) {
    // You can also log the error to an error reporting service
    logErrorToMyService(error, info);
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return <h1>{'Something went wrong.'}</h1>;
    }
    return this.props.children;
  }
}
```

之后，将其作为常规组件使用：

```jsx
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

### 静态类型检查推荐的方法是什么?

通常，我们使用 PropTypes 库（在 React v15.5 之后 `React.PropTypes` 被移动到了 `prop-types` 包中），在 React 应用程序中执行类型检查。对于大型项目，建议使用静态类型检查器，比如 Flow 或 TypeScript，它们在编译时执行类型检查并提供 auto-completion 功能。

### 在渲染方法中使用箭头函数好么?

是的，你可以用。它通常是向回调函数传递参数的最简单方法。但在使用时需要优化性能。

```js
class Foo extends Component {
  handleClick() {
    console.log('Click happened');
  }
  render() {
    return <button onClick={() => this.handleClick()}>Click Me</button>;
  }
}
```

**注意：** 组件每次渲染时，在 render 方法中的箭头函数都会创建一个新的函数，这可能会影响性能。

### 支持 React 应用程序的浏览器有哪一些?

React 支持所有流行的浏览器，包括 Internet Explorer 9 和更高版本，但旧版本的浏览器（如 IE 9 和 IE 10）需要一些 polyfill。如果你使用 **es5-shim and es5-sham** polyfill，那么它甚至支持不支持 ES5 方法的旧浏览器。

### 如何防止函数被多次调用?

如果你使用一个事件处理程序，如 **onClick or onScroll** 并希望防止回调被过快地触发，那么你可以限制回调的执行速度。

这可以通过以下可能的方式实现：

**Throttling:** 基于时间的频率进行更改。例如，它可以使用 lodash 的 _.throttle 函数。
**Debouncing:** 在一段时间不活动后发布更改。例如，可以使用 lodash 的 _.debounce 函数。
**RequestAnimationFrame throttling:** 基于 requestAnimationFrame 的更改。例如，可以使用 raf-schd。

> 注意：_.debounce， _.throttle 和 raf-schd 都提供了一个 cancel 方法来取消延迟回调。所以需要调用 componentWillUnmount，或者对代码进行检查来保证在延迟函数有效期间内组件始终挂载。

### `react-dom` 中 render 方法的目的是什么?

此方法用于将 React 元素渲染到所提供容器中的 DOM 结构中，并返回对组件的引用。如果 React 元素之前已被渲染到容器中，它将对其执行更新，并且只在需要时改变 DOM 以反映最新的更改。

```js
ReactDOM.render(element, container[, callback])
```

如果提供了可选的回调函数，该函数将在组件被渲染或更新后执行。

### Immutable 详解

Javascript 中的对象一般是可变的（mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如`f00 = {a:1};bar = foo; bar.a = 2;`你会发现，此时`foo.a`也被改成了`2`。 虽然这样可以节约内存，但当应用复杂后，这就造成了非常大的隐患，`Mutable`带来的优点变得得不偿失。

为了解决这个问题，一般的做法是使用`shallowCopy`(浅拷贝)或`deepCopy`（深拷贝）来避免被修改，但这样做又造成了 CPU 和内存的浪费。

Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。

Immutable 实现的原理是**Persistent Data Structure**(持久化数据结构)，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有的节点都复制一遍带来的性能损耗，Immutable 使用了**Stryctural Sharing**（结构共享），即如果对象中的一个节点发生变化

### React 绑定 this

为什么要主动绑定 this ？

### 什么是 "key" 属性，在元素数组中使用它们有什么好处?

`key` 是一个特殊的字符串属性，你在创建元素数组时需要包含它。_Keys_ 帮助 React 识别哪些项已更改、添加或删除。

我们通常使用数据中的 IDs 作为 _keys_:

```jsx
const todoItems = todos.map(todo => <li key={todo.id}>{todo.text}</li>);
```

在渲染列表项时，如果你没有稳定的 IDs，你可能会使用 _index_ 作为 _key_：

```jsx
const todoItems = todos.map((todo, index) => <li key={index}>{todo.text}</li>);
```

**注意：**

由于列表项的顺序可能发生改变，因此并不推荐使用 _indexes_ 作为 _keys_。这可能会对性能产生负面影响，并可能导致组件状态出现问题。
如果将列表项提取为单独的组件，则在列表组件上应用 _keys_ 而不是 `li` 标签。
如果在列表项中没有设置 `key` 属性，在控制台会显示警告消息。

### createElement 和 cloneElement 有什么区别?

JSX 元素将被转换为 `React.createElement()` 函数来创建 React 元素，这些对象将用于表示 UI 对象。而 `cloneElement` 用于克隆元素并传递新的属性。

### 在 React 中的提升状态是什么?

当多个组件需要共享相同的更改数据时，建议将共享状态提升到最接近的共同祖先。这意味着，如果两个子组件共享来自其父组件的相同数据，则将状态移动到父组件，而不是在两个子组件中维护局部状态。

### 什么是上下文（Context）?

_Context_ 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递`props`。比如，需要在应用中许多组件需要访问登录用户信息、地区偏好、UI 主题等。

```jsx
// 创建一个 theme Context,  默认 theme 的值为 light
const ThemeContext = React.createContext('light');

function ThemedButton(props) {
  // ThemedButton 组件从 context 接收 theme
  return <ThemeContext.Consumer>{theme => <Button {...props} theme={theme} />}</ThemeContext.Consumer>;
}

// 中间组件
function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class App extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}
```

### 每次组件渲染时调用函数的常见错误是什么?

你需要确保在将函数作为参数传递时未调用该函数。

```jsx
render() {

// Wrong: handleClick is called instead of passed as a reference!
return <button onClick={this.handleClick()}>{'Click Me'}</button>
}
```

相反地，传递函数本身应该没有括号：

```jsx
render() {

// Correct: handleClick is passed as a reference!
return <button onClick={this.handleClick}>{'Click Me'}</button>
}
```

### 为什么有组件名称要首字母大写?

这是必要的，因为组件不是 DOM 元素，它们是构造函数。 此外，在 JSX 中，小写标记名称是指 HTML 元素，而不是组件。

### 为什么 React 使用 `className` 而不是 `class` 属性?

`class` 是 JavaScript 中的关键字，而 JSX 是 JavaScript 的扩展。这就是为什么 React 使用 `className` 而不是 `class` 的主要原因。传递一个字符串作为 `className` 属性。

```jsx
render() {

return <span className={'menu navigation-menu'}>{'Menu'}</span>
}
```

在实际项目中，我们经常使用[classnames](https://github.com/JedWatson/classnames)来方便我们操作`className`。

### 什么是 Fragments ?

它是 React 中的常见模式，用于组件返回多个元素。_Fragments_ 可以让你聚合一个子元素列表，而无需向 DOM 添加额外节点。

```jsx
render() {

return (
<React.Fragment>
<ChildA />
<ChildB />
<ChildC />
</React.Fragment>
)
}
```

以下是简洁语法，但是在一些工具中还不支持：

```jsx
class Test {
  render() {
    return (
      <ChildA>
        <ChildA />
        <ChildB />
        <ChildC />
      </ChildA>
    );
  }
}
```

> 译注：`React 16` 以前，`render` 函数的返回必须有一个根节点，否则报错。

### 为什么使用 Fragments 比使用容器 div 更好?

通过不创建额外的 DOM 节点，Fragments 更快并且使用更少的内存。这在非常大而深的节点树时很有好处。
一些 CSS 机制如*flex box*和*CSS Grid*具有特殊的父子关系，如果在中间添加 div 将使得很难保持所需的结构。
在 DOM 审查器中不会那么的杂乱。

### 在 React 中什么是 Portal ?

_Portal_ 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。

```js
ReactDOM.createPortal(child, container);
```

第一个参数是任何可渲染的 React 子节点，例如元素，字符串或片段。第二个参数是 DOM 元素。

### 客户端渲染与服务端渲染

客户端渲染即普通的 React 项目渲染方式。
客户端渲染流程：

1. 浏览器发送请求
2. 服务器返回 HTML
3. 浏览器发送 bundle.js 请求
4. 服务器返回 bundle.js
5. 浏览器执行 bundle.js 中的 React 代码

CSR 带来的问题：

1. 首屏加载时间过长
2. SEO 不友好

因为时间在往返的几次网络请求中就耽搁了，而且因为 CSR 返回到页面的 HTML 中没有内容，就只有一个 root 空元素，页面内容是靠 js 渲染出来的，爬虫在读取网页时就抓不到信息，所以 SEO 不友好

SSR 带来的问题：

1. React 代码在服务器端执行，很大的消耗了服务器的性能

### React 同构时页面加载流程

1. 服务端运行 React 代码渲染出 HTML
2. 浏览器加载这个无交互的 HTML 代码
3. 浏览器接收到内容展示
4. 浏览器加载 JS 文件
5. JS 中 React 代码在浏览器中重新执行

### react 的 class 组件为什么需要在开头 import react？ 去掉能不能跑？

### 在 React 中 registerServiceWorker 的用途是什么?

默认情况下，React 会为你创建一个没有任何配置的 service worker。Service worker 是一个 Web API，它帮助你缓存资源和其他文件，以便当用户离线或在弱网络时，他/她仍然可以在屏幕上看到结果，因此，它可以帮助你建立更好的用户体验，这是你目前应该了解的关于 Service worker 的内容。

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(<App />, document.getElementById('root'));
registerServiceWorker();
```

### React memo 函数是什么?

当类组件的输入属性相同时，可以使用 **pureComponent** 或 **shouldComponentUpdate** 来避免组件的渲染。现在，你可以通过把函数组件包装在 **React.memo** 中来实现相同的功能。

```jsx
const MyComponent = React.memo(function MyComponent(props) {
  /* only rerenders if props change */
});
```

### React lazy 函数是什么?

使用 React.lazy 函数允许你将动态导入的组件作为常规组件进行渲染。当组件开始渲染时，它会自动加载包含 OtherComponent 的包。它必须返回一个 Promise，该 Promise 解析后为一个带有默认导出 React 组件的模块。

```jsx
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}
```

**注意：** React.lazy 和 Suspense 还不能用于服务端渲染。如果要在服务端渲染的应用程序中进行代码拆分，我们仍然建议使用 React Loadable。

### 如何在 React 类中使用类字段声明语法?

使用类字段声明可以使 React 类组件更加简洁。你可以在不使用构造函数的情况下初始化本地状态，并通过使用箭头函数声明类方法，而无需额外对它们进行绑定。让我们以一个 counter 示例来演示类字段声明，即不使用构造函数初始化状态且不进行方法绑定：

```jsx
class Counter extends Component {
  state = { value: 0 };

  handleIncrement = () => {
    this.setState(prevState => ({
      value: prevState.value + 1,
    }));
  };

  handleDecrement = () => {
    this.setState(prevState => ({
      value: prevState.value - 1,
    }));
  };

  render() {
    return (
      <div>
        {this.state.value}

        <button onClick={this.handleIncrement}>+</button>
        <button onClick={this.handleDecrement}>-</button>
      </div>
    );
  }
}
```

### React 其他

- 为什么要绑定 this
- setState 是同步还是异步，立即获取值的操作
- 自定义事件原理， 冒泡、捕获
- hooks
- diff 原理
- fiber
- mobx content 以及 redux 几种状态管理的区别

#### 主要

- 异步渲染
- 事件系统
- fiber

### react 面试题

- mixin、hoc、render props、react-hooks 的优劣如何？
- 你是如何理解 fiber 的?
- 你对 Time Slice 的理解?
- react-redux 是如何工作的?
- redux 与 mobx 的区别?
- redux 异步中间件之间的优劣?
- redux 中如何进行异步操作?
- React 如何进行组件/逻辑复用?
  https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/### guide/react.md
