---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 什么是 React?

[React](https://reactjs.org/) 是一个**开源前端 JavaScript 库**，用于构建用户界面，尤其是单页应用程序。它用于处理网页和移动应用程序的视图层。React 是由 Facebook 的软件工程师 Jordan Walke 创建的。在 2011 年 React 应用首次被部署到 Facebook 的信息流中，之后于 2012 年被应用到 Instagram 上。

### React 的优点是什么?

使用 _Virtual DOM_ 提高应用程序的性能。
JSX 使代码易于读写。
它支持在客户端和服务端渲染。
易于与框架（Angular，Backbone）集成，因为它只是一个视图库。
使用 Jest 等工具轻松编写单元与集成测试。

### React 的局限性是什么?

React 只是一个视图库，而不是一个完整的框架。
对于 Web 开发初学者来说，有一个学习曲线。
将 React 集成到传统的 MVC 框架中需要一些额外的配置。
代码复杂性随着内联模板和 JSX 的增加而增加。
如果有太多的小组件可能增加项目的庞大和复杂。

### 何为 JSX

JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React "元素"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。

### 什么是 JSX?

JSX 是 ECMAScript 一个类似 XML 的语法扩展。基本上，它只是为 `React.createElement()` 函数提供语法糖，从而让在我们在 JavaScript 中，使用类 HTML 模板的语法，进行页面描述。

在下面的示例中，`<h1>` 内的文本标签会作为 JavaScript 函数返回给渲染函数。

```jsx
class App extends React.Component {
  render() {
    return (
      <div>
        <h1>{'Welcome to React world!'}</h1>
      </div>
    );
  }
}
```

以上示例 render 方法中的 JSX 将会被转换为以下内容：

```js
React.createElement('div', null, React.createElement('h1', null, 'Welcome to React world!'));
```

### JSX

```
/** @jsx h */
```

jsx 文件顶部可以指定 pragma, 默认情况下是 `React.createElement` 这也就是为什么，js 文件中需要默认引入 react 的原因。
指定 h 函数。
https://zhuanlan.zhihu.com/p/28035334

### 何为纯函数(pure function)

一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。

### 什么原因会促使你脱离 create-react-app 的依赖

当你想去配置 webpack 或 babel presets。

### 除了在构造函数中绑定 `this`，还有其它方式吗

你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。

### 怎么用 React.createElement 重写下面的代码

Question：

```js
const element = <h1 className="greeting">Hello, world!</h1>;
```

Answer：

```js
const element = React.createElement('h1', { className: 'greeting' }, 'Hello, world!');
```

### 何为 `Children`

在 JSX 表达式中，一个开始标签(比如`<a>`)和一个关闭标签(比如`</a>`)之间的内容会作为一个特殊的属性`props.children`被自动传递给包含着它的组件。

这个属性有许多可用的方法，包括 `React.Children.map`，`React.Children.forEach`， `React.Children.count`， `React.Children.only`，`React.Children.toArray`。

### 在 React 中，何为 state

State 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。

### 使用箭头函数(arrow functions)的优点是什么

- 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值(在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。
- 简单：箭头函数易于阅读和书写
- 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 `this` 的值

### React 的主要特点是什么?

React 的主要特性有：

- 考虑到真实的 DOM 操作成本很高，它使用 VirtualDOM 而不是真实的 DOM。
- 支持服务端渲染。
- 遵循单向数据流或数据绑定。
- 使用可复用/可组合的 UI 组件开发视图。

### 元素和组件有什么区别?

一个 _Element_ 是一个简单的对象，它描述了你希望在屏幕上以 DOM 节点或其他组件的形式呈现的内容。_Elements_ 在它们的属性中可以包含其他 _Elements_。创建一个 React 元素是很轻量的。一旦元素被创建后，它将不会被修改。

React Element 的对象表示如下：

```js
const element = React.createElement('div', { id: 'login-btn' }, 'Login');
```

上面的 `React.createElement()` 函数会返回一个对象。

```
{
  type: 'div',
  props: {
    children: 'Login',
    id: 'login-btn'
  }
}
```

最后使用 `ReactDOM.render()` 方法渲染到 DOM：

```html
<div id="login-btn">Login</div>
```

而一个组件可以用多种不同方式声明。它可以是一个含有 `render()` 方法的类。或者，在简单的情况中，它可以定义为函数。无论哪种情况，它都将 props 作为输入，并返回一个 JSX 树作为输出：

```jsx
const Button = ({ onLogin }) => <div id={'login-btn'} onClick={onLogin} />;
```

然后 JSX 被转换成 `React.createElement()` 函数：

```js
const Button = ({ onLogin }) => React.createElement('div', { id: 'login-btn', onClick: onLogin }, 'Login');
```

### React 的状态是什么?

组件的状态是一个对象，它包含某些信息，这些信息可能在组件的生命周期中发生更改。我们应该尽量使状态尽可能简单，并尽量减少有状态组件的数量。让我们创建一个包含消息状态的 User 组件：

```js
class User extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      message: 'Welcome to React world',
    };
  }

  render() {
    return (
      <div>
        <h1>{this.state.message}</h1>
      </div>
    );
  }
}
```

![state](images/state.jpg)

状态（State）与属性（Props）类似，但它是私有的，完全由组件控制。也就是说，除了它所属的组件外，任何组件都无法访问它。

### React 中的 props 是什么?

Props 是组件的输入。它们是单个值或包含一组值的对象，这些值在创建时使用类似于 HTML 标记属性的命名约定传递给组件。它们是从父组件传递到子组件的数据。

Props 的主要目的是提供以下组件功能：

将自定义数据传递到组件。
触发状态更改。
在组件的 `render()` 方法中通过 `this.props.reactProp` 使用。

例如，让我们使用 `reactProp` 属性创建一个元素：

```jsx
<Element reactProp={'1'} />
```

然后，`reactProp` 将成为附加到 React props 对象的属性，该对象最初已存在于使用 React 库创建的所有组件上。

```
props.reactProp
```

### 状态和属性有什么区别?

state 和 props 都是普通的 JavaScript 对象。虽然它们都保存着影响渲染输出的信息，但它们在组件方面的功能不同。Props 以类似于函数参数的方式传递给组件，而状态则类似于在函数内声明变量并对它进行管理。

States vs Props

| Conditions           | States | Props |
| -------------------- | ------ | ----- |
| 可从父组件接收初始值 | 是     | 是    |
| 可在父组件中改变其值 | 否     | 是    |
| 在组件内设置默认值   | 是     | 是    |
| 在组件内可改变       | 是     | 否    |
| 可作为子组件的初始值 | 是     | 是    |

### 我们为什么不能直接更新状态?

如果你尝试直接改变状态，那么组件将不会重新渲染。

```js
//Wrong
this.state.message = 'Hello world';
```

正确方法应该是使用 `setState()` 方法。它调度组件状态对象的更新。当状态更改时，组件通将会重新渲染。

```js
//Correct
this.setState({ message: 'Hello World' });
```

**注意：** 你可以在 _constructor_ 中或使用最新的 JavaScript 类属性声明语法直接设置状态对象。

### 在 React 中如何校验 props 属性?

当应用程序以开发模式运行的时，React 将会自动检查我们在组件上设置的所有属性，以确保它们具有正确的类型。如果类型不正确，React 将在控制台中生成警告信息。由于性能影响，它在生产模式下被禁用。使用 `isRequired` 定义必填属性。

预定义的 prop 类型：

`PropTypes.number`
`PropTypes.string`
`PropTypes.array`
`PropTypes.object`
`PropTypes.func`
`PropTypes.node`
`PropTypes.element`
`PropTypes.bool`
`PropTypes.symbol`
`PropTypes.any`

我们可以为 `User` 组件定义 `propTypes`，如下所示：

```jsx
import React from 'react';
import PropTypes from 'prop-types';

class User extends React.Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number.isRequired,
  };

  render() {
    return (
      <>
        <h1>{`Welcome, ${this.props.name}`}</h1>
        <h2>{`Age, ${this.props.age}`}</h2>
      </>
    );
  }
}
```

**注意:** 在 React v15.5 中，_PropTypes_ 从 `React.PropTypes` 被移动到 `prop-types` 库中。

### 在 React v16 中的错误边界是什么?

错误边界是在其子组件树中的任何位置捕获 JavaScript 错误、记录这些错误并显示回退 UI 而不是崩溃的组件树的组件。

如果一个类组件定义了一个名为 `componentDidCatch(error, info)` 或 `static getDerivedStateFromError()` 新的生命周期方法，则该类组件将成为错误边界：

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  componentDidCatch(error, info) {
    // You can also log the error to an error reporting service
    logErrorToMyService(error, info);
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return <h1>{'Something went wrong.'}</h1>;
    }
    return this.props.children;
  }
}
```

之后，将其作为常规组件使用：

```jsx
<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

### 在 React v15 中如何处理错误边界?

React v15 使用 `unstable_handleError` 方法为错误边界提供了非常基础的支持。已在 React v16 中，将其重命名为`componentDidCatch`。

### 静态类型检查推荐的方法是什么?

通常，我们使用 PropTypes 库（在 React v15.5 之后 `React.PropTypes` 被移动到了 `prop-types` 包中），在 React 应用程序中执行类型检查。对于大型项目，建议使用静态类型检查器，比如 Flow 或 TypeScript，它们在编译时执行类型检查并提供 auto-completion 功能。

### 简要介绍一下 key 以及它的作用

在 react 中我们渲染一个列表的时候，我们需要为每一个列表项指定一个唯一的 key，当没有指定 key 时，会收到一个 warning，
如果指定的 key 不唯一，只会渲染第一个指定唯一的 key 的那个元素，使用 key 可以使得 DOM diff 更加高效，避免不必要的
列表项更新

### React 是什么？

- React 不是 MV\* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层
- React 主要的原理：

  - 虚拟 DOM + diff 算法 -> 不直接操作 DOM 对象
  - Components 组件 -> Virtual DOM 的节点
  - State 触发视图的渲染 -> 单向数据绑定
  - React 解决方案：React + Redux + react-router + Fetch + webpack

### Real DOM 和 Virtual DOM 有什么区别?

以下是 Real DOM 和 Virtual DOM 之间的主要区别：

| Real DOM                          | Virtual DOM                   |
| --------------------------------- | ----------------------------- |
| 更新速度慢                        | 更新速度快                    |
| DOM 操作非常昂贵                  | DOM 操作非常简单              |
| 可以直接更新 HTML                 | 你不能直接更新 HTML           |
| 造成太多内存浪费                  | 更少的内存消耗                |
| 如果元素更新了，创建新的 DOM 节点 | 如果元素更新，则更新 JSX 元素 |

### 你最喜欢的 React 技术栈是什么?

尽管技术栈因开发人员而异，但最流行的技术栈用于 React boilerplate 项目代码中。它主要使用 redux 和 redux saga 进行状态管理和具有副作用的异步操作，使用 react-router 进行路由管理，使用 styled-components 库开发 React 组件，使用 axios 调用 REST api，以及其他支持的技术栈，如 webpack、reseselect、esnext、babel 等。

你可以克隆 [https://github.com/react-boilerplate/react-boilerplate](https://github.com/react-boilerplate/react-boilerplate) 并开始开发任何新的 React 项目。

### 什么是 windowing 技术?

Windowing 是一种技术，它在任何给定时间只呈现一小部分行，并且可以显著减少重新呈现组件所需的时间以及创建的 DOM 节点的数量。如果应用程序呈现长的数据列表，则建议使用此技术。react-window 和 react-virtualized 都是常用的 windowing 库，它提供了几个可重用的组件，用于显示列表、网格和表格数据。

### 你如何在 JSX 中打印 falsy 值?

Falsy 值比如 false，null，undefined 是有效的子元素，但它们不会呈现任何内容。如果仍要显示它们，则需要将其转换为字符串。我们来举一个如何转换为字符串的例子：

```js
<div>My JavaScript variable is {String(myVariable)}.</div>
```

### 如何防止函数被多次调用?

如果你使用一个事件处理程序，如 **onClick or onScroll** 并希望防止回调被过快地触发，那么你可以限制回调的执行速度。

这可以通过以下可能的方式实现：

**Throttling:** 基于时间的频率进行更改。例如，它可以使用 lodash 的 _.throttle 函数。
**Debouncing:** 在一段时间不活动后发布更改。例如，可以使用 lodash 的 _.debounce 函数。
**RequestAnimationFrame throttling:** 基于 requestAnimationFrame 的更改。例如，可以使用 raf-schd。

> 注意：_.debounce， _.throttle 和 raf-schd 都提供了一个 cancel 方法来取消延迟回调。所以需要调用 componentWillUnmount，或者对代码进行检查来保证在延迟函数有效期间内组件始终挂载。

### JSX 如何防止注入攻击?

React DOM 会在渲染 JSX 中嵌入的任何值之前对其进行转义。因此，它确保你永远不能注入任何未在应用程序中显式写入的内容。

```js
const name = response.potentiallyMaliciousInput;
const element = <h1>{name}</h1>;
```

这样可以防止应用程序中的 XSS（跨站点脚本）攻击。

### 如何更新已渲染的元素?

通过将新创建的元素传递给 ReactDOM 的 render 方法，可以实现 UI 更新。例如，让我们举一个滴答时钟的例子，它通过多次调用 render 方法来更新时间：

```js
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);
```

### 如何将参数传递给事件处理程序?

在迭代或循环期间，向事件处理程序传递额外的参数是很常见的。这可以通过箭头函数或绑定方法实现。让我们以网格中更新的用户详细信息为例：

```js
<button onClick={(e) => this.updateUser(userId, e)}>Update User details</button>
<button onClick={this.updateUser.bind(this, userId)}>Update User details</button>
```

在这两种方法中，合成参数 e 作为第二个参数传递。你需要在箭头函数中显式传递它，并使用 bind 方法自动转发它。

### 如何防止组件渲染?

你可以基于特定的条件通过返回 null 值来阻止组件的渲染。这样它就可以有条件地渲染组件。

```js
function Greeting(props) {
  if (!props.loggedIn) {
    return null;
  }

  return <div className="greeting">welcome, {props.name}</div>;
}
```

```js
class User extends React.Component {
  constructor(props) {
    super(props);
    this.state = {loggedIn: false, name: 'John'};
  }

  render() {
   return (
       <div>
         //Prevent component render if it is not loggedIn
         <Greeting loggedIn={this.state.loggedIn} />
         <UserDetails name={this.state.name}>
       </div>
   );
  }
```

在上面的示例中，greeting 组件通过应用条件并返回空值跳过其渲染部分。

### 用于表单处理的流行选择是什么?

Formik 是一个用于 React 的表单库，它提供验证、跟踪访问字段和处理表单提交等解决方案。具体来说，你可以按以下方式对它们进行分类：

获取表单状态输入和输出的值。
表单验证和错误消息。
处理表单提交。

它用于创建一个具有最小 API 的可伸缩、性能良好的表单助手，以解决令人讨厌的问题。

### 如何将事件处理程序传递给组件?

可以将事件处理程序和其他函数作为属性传递给子组件。它可以在子组件中使用，如下所示：

```
<button onClick={this.handleClick}>
```

### 在渲染方法中使用箭头函数好么?

是的，你可以用。它通常是向回调函数传递参数的最简单方法。但在使用时需要优化性能。

```js
class Foo extends Component {
  handleClick() {
    console.log('Click happened');
  }
  render() {
    return <button onClick={() => this.handleClick()}>Click Me</button>;
  }
}
```

**注意：** 组件每次渲染时，在 render 方法中的箭头函数都会创建一个新的函数，这可能会影响性能。

### 支持 React 应用程序的浏览器有哪一些?

React 支持所有流行的浏览器，包括 Internet Explorer 9 和更高版本，但旧版本的浏览器（如 IE 9 和 IE 10）需要一些 polyfill。如果你使用 **es5-shim and es5-sham** polyfill，那么它甚至支持不支持 ES5 方法的旧浏览器。

### 在定义类组件时，什么是必须的方法?

在类组件中 render() 方法是唯一需要的方法。也就是说，对于类组件，除了 render() 方法之外的所有方法都是可选的。

### render 方法可能返回的类型是什么?

以下列表是 render 方法返回的类型：

**React elements:** 用于告诉 React 如何渲染 DOM 节点。它包括 HTML 元素，如 `<div />` 和用户定义的元素。
**Arrays and fragments:** 以数组的形式返回多个元素和包装多个元素的片段。
**Portals:** 将子元素渲染到不同的 DOM 子树中。
**String and numbers:** 在 DOM 中将字符串和数字都作为文本节点进行呈现。
**Booleans or null:** 不会渲染任何内容，但这些类型用于有条件地渲染内容。

### 构造函数的主要目的是什么?

使用构造函数主要有两个目的：

通过将对象分配给 this.state 来初始化本地状态。
用于为组件实例绑定事件处理方法。

例如，下面的代码涵盖了上述两种情况：

```js
constructor(props) {
  super(props);
  // Don't call this.setState() here!
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}
```

### 是否必须为 React 组件定义构造函数?

不，这不是强制的。也就是说，如果你不需要初始化状态且不需要绑定方法，则你不需要为 React 组件实现一个构造函数。

### 什么是默认属性?

defaultProps 被定义为组件类上的属性，用于设置组件类默认的属性值。它只适用于 undefined 的属性，而不适用于 null 属性。例如，让我们为按钮组件创建默认的 color 属性：

```js
class MyButton extends React.Component {
  // ...
}

MyButton.defaultProps = {
  color: 'red',
};
```

如果未设置 props.color，则会使用默认值 `red`。 也就是说，每当你试图访问 color 属性时，它都使用默认值。

```js
render() {
   return <MyButton /> ; // props.color will be set to red
 }
```

**注意：** 如果你提供的是 null 值，它会仍然保留 null 值。

### 其他

- 更新机制
- 什么是 Fiber 以及作用
- React 实现路更新任务的调度，如何实现的
- 合成事件

https://segmentfault.com/a/1190000016885832
https://juejin.im/post/5b2215f76fb9a00e8f795cd1
https://juejin.im/post/5bca74cfe51d450e9163351b

https://www.geekjc.com/post/5cabf9368024b76bc346b06f
https://wuxinhua.com/2018/03/17/The-questions-about-react-and-redux-in-interview/
https://github.com/penouc/blog/issues/3
http://blog.weber.pub/archives/83.html
https://www.jianshu.com/p/b8ab4f1293eb
https://blog.fundebug.com/2019/05/31/almost-all-react-interview-questions/

react 中介绍 webpack 与 Rollup 的区别： http://www.sosout.com/2018/08/12/react-source-analysis.html
