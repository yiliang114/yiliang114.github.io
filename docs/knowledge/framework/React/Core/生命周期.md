---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

# React 生命周期分析

在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题。

在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 `state`，那么调用栈可能会很长

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-042522.png)

调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生。

Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-042523.png)

对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画。

对于异步渲染，现在渲染有两个阶段：`reconciliation` 和 `commit` 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。

**Reconciliation** 阶段

- `componentWillMount`
- `componentWillReceiveProps`
- `shouldComponentUpdate`
- `componentWillUpdate`

**Commit** 阶段

- `componentDidMount`
- `componentDidUpdate`
- `componentWillUnmount`

因为 `reconciliation` 阶段是可以被打断的，所以 `reconciliation` 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。所以对于 `reconciliation` 阶段调用的几个函数，除了 `shouldComponentUpdate` 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。

`getDerivedStateFromProps` 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用

```js
class ExampleComponent extends React.Component {
  // Initialize state in constructor,
  // Or with a property initializer.
  state = {};

  static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.someMirroredValue !== nextProps.someValue) {
      return {
        derivedData: computeDerivedState(nextProps),
        someMirroredValue: nextProps.someValue,
      };
    }

    // Return null to indicate no change to state.
    return null;
  }
}
```

`getSnapshotBeforeUpdate` 用于替换 `componentWillUpdate` ，该函数会在 `update` 后 DOM 更新前被调用，用于读取最新的 DOM 数据。

## V16 生命周期函数用法建议

```js
class ExampleComponent extends React.Component {
  // 用于初始化 state
  constructor() {}
  // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用
  // 因为该函数是静态函数，所以取不到 `this`
  // 如果需要对比 `prevProps` 需要单独在 `state` 中维护
  static getDerivedStateFromProps(nextProps, prevState) {}
  // 判断是否需要更新组件，多用于组件性能优化
  shouldComponentUpdate(nextProps, nextState) {}
  // 组件挂载后调用
  // 可以在该函数中进行请求或者订阅
  componentDidMount() {}
  // 用于获得最新的 DOM 数据
  getSnapshotBeforeUpdate() {}
  // 组件即将销毁
  // 可以在此处移除订阅，定时器等等
  componentWillUnmount() {}
  // 组件销毁后调用
  componentDidUnMount() {}
  // 组件更新后调用
  componentDidUpdate() {}
  // 渲染组件函数
  render() {}
  // 以下函数不建议使用
  UNSAFE_componentWillMount() {}
  UNSAFE_componentWillUpdate(nextProps, nextState) {}
  UNSAFE_componentWillReceiveProps(nextProps) {}
}
```

### react 生命周期函数

一、初始化阶段：

- getDefaultProps
  - 获取实例的默认属性
- getInitialState
  - 获取每个实例的初始化状态
- componentWillMount
  - 组件即将被装载、渲染到页面上
  - 多用于根组件中的应用程序配置
- render
  - 组件在这里生成虚拟的 DOM 节点
- componentDidMount
  - 组件真正在被装载之后
  - 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据（发送请求）；如果需要设置事件监听，也可以在这完成

二、运行中状态：

- componentWillReceiveProps
  - 组件将要接收到属性的时候调用
- shouldComponentUpdate
  - 是一个改善性能的地方，组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）
- componentWillUpdate
  - 组件即将更新不能修改属性和状态
- render
  - 组件重新描绘
- componentDidUpdate
  - 组件已经更新
  - 响应 prop 或 state 的改变

三、销毁阶段：

- componentWillUnmount
  - 组件即将销毁
  - 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器

### react 生命周期中，最适合与服务端进行数据交互的是哪个函数

`componentDidMount`：在这个阶段，**实例和 dom 已经挂载完成，可以进行相关的 dom 操作**。

# 生命周期

组件本质上是一个状态机，输入确定，输出就一定确定。

组件内部有状态和属性，属性是父组件传递给子组件的，而状态是组件内部维护的一些数据，当状态发生变化时，组件也会进行更新。所以可以理解成一个 state 对应一个 render 结果。

状态发生转换的时候，会触发不同的钩子函数，从而让开发者有机会做出响应。

## 初始化

初始化出实例，这个阶段主要进行一些初始的状态设置、以及渲染，完成之后就可以让用户使用。

钩子函数：

- getDefaultProps 获取实例的默认属性
- getInitialState 获取实例的初始化状态
- componentWillMount 装载。组件即将被装载
- render 生成虚拟 dom 节点，再由 react 将虚拟的 dom 节点渲染成真正的 dom 节点，并放置在页面中
- componentDidMount 组件已经被装载

组件的第一个实例才会调用 getDefaultProps，第二个实例开始就会从 getInitialState 开始调用。同一个组件的实例的默认属性都是一样的。

## 运行中

大多数时候处于运行中。

钩子函数：

- componentWillReceiveProps
- shouldComponentUpdate
- componentWillUpdate
- render
- componentDidUpdate

### 组件生命周期的不同阶段是什么?

    组件生命周期有三个不同的生命周期阶段：

    **Mounting:** 组件已准备好挂载到浏览器的 DOM 中. 此阶段包含来自 `constructor()`, `getDerivedStateFromProps()`, `render()`, 和 `componentDidMount()` 生命周期方法中的初始化过程。

    **Updating:** 在此阶段，组件以两种方式更新，发送新的属性并使用 `setState()` 或 `forceUpdate()` 方法更新状态. 此阶段包含 `getDerivedStateFromProps()`, `shouldComponentUpdate()`, `render()`, `getSnapshotBeforeUpdate()` 和 `componentDidUpdate()` 生命周期方法。

    **UnMounting:** 在这个最后阶段，不需要组件，它将从浏览器 DOM 中卸载。这个阶段包含 `componentWillUnmount()` 生命周期方法。

    值得一提的是，在将更改应用到 DOM 时，React 内部也有阶段概念。它们按如下方式分隔开：

    **Render** 组件将会进行无副作用渲染。这适用于纯组件（Pure Component），在此阶段，React 可以暂停，中止或重新渲染。

    **Pre-commit** 在组件实际将更改应用于 DOM 之前，有一个时刻允许 React 通过`getSnapshotBeforeUpdate()`捕获一些 DOM 信息（例如滚动位置）。

    **Commit** React 操作 DOM 并分别执行最后的生命周期： `componentDidMount()` 在 DOM 渲染完成后调用, `componentDidUpdate()` 在组件更新时调用,  `componentWillUnmount()` 在组件卸载时调用。
    React 16.3+ 阶段 (也可以看[交互式版本](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/))

    ![phases 16.3+](images/phases16.3.jpg)

    React 16.3 之前

    ![phases 16.2](images/phases.png)

### React 生命周期方法有哪些?

    React 16.3+

    - **getDerivedStateFromProps:** 在调用`render()`之前调用，并在 *每次* 渲染时调用。 需要使用派生状态的情况是很罕见得。值得阅读 [如果你需要派生状态](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html).
    - **componentDidMount:** 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。
    - **shouldComponentUpdate:** 确定组件是否应该更新。 默认情况下，它返回`true`。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回`false`值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。
    - **getSnapshotBeforeUpdate:** 在最新的渲染输出提交给 DOM 前将会立即调用，这对于从 DOM 捕获信息（比如：滚动位置）很有用。
    - **componentDidUpdate:** 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果`shouldComponentUpdate()`返回`false`，则不会触发。
    - **componentWillUnmount** 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。

    Before 16.3

    - **componentWillMount:** 在组件`render()`前执行，用于根组件中的应用程序级别配置。应该避免在该方法中引入任何的副作用或订阅。
    - **componentDidMount:** 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。
    - **componentWillReceiveProps:** 在组件接收到新属性前调用，若你需要更新状态响应属性改变（例如，重置它），你可能需对比`this.props`和`nextProps`并在该方法中使用`this.setState()`处理状态改变。
    - **shouldComponentUpdate:** 确定组件是否应该更新。 默认情况下，它返回`true`。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回`false`值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。
    - **componentWillUpdate:** 当`shouldComponentUpdate`返回`true`后重新渲染组件之前执行，注意你不能在这调用`this.setState()`
    - **componentDidUpdate:** 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果`shouldComponentUpdate()`返回`false`，则不会触发。
    - **componentWillUnmount:** 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。

### 在 mounting 阶段生命周期方法的执行顺序是什么?

    在创建组件的实例并将其插入到 DOM 中时，将按以下顺序调用生命周期方法。

    `constructor()`
    `static getDerivedStateFromProps()`
    `render()`
    `componentDidMount()`

### 在 React v16 中，哪些生命周期方法将被弃用?

    以下生命周期方法将成为不安全的编码实践，并且在异步渲染方面会更有问题。

    `componentWillMount()`
    `componentWillReceiveProps()`
    `componentWillUpdate()`

    从 React v16.3 开始，这些方法使用 `UNSAFE_` 前缀作为别名，未加前缀的版本将在 React v17 中被移除。

### 生命周期方法 `getDerivedStateFromProps()` 的目的是什么?

    新的静态 `getDerivedStateFromProps()` 生命周期方法在实例化组件之后以及重新渲染组件之前调用。它可以返回一个对象用于更新状态，或者返回 `null` 指示新的属性不需要任何状态更新。

    ```js
    class MyComponent extends React.Component {
      static getDerivedStateFromProps(props, state) {
        // ...
      }
    }
    ```

    此生命周期方法与 `componentDidUpdate()` 一起涵盖了 `componentWillReceiveProps()` 的所有用例。

### 生命周期方法 `getSnapshotBeforeUpdate()` 的目的是什么?

    新的 `getSnapshotBeforeUpdate()` 生命周期方法在 DOM 更新之前被调用。此方法的返回值将作为第三个参数传递给`componentDidUpdate()`。

    ```js
    class MyComponent extends React.Component {
      getSnapshotBeforeUpdate(prevProps, prevState) {
        // ...
      }
    }
    ```

    此生命周期方法与 `componentDidUpdate()` 一起涵盖了 `componentWillUpdate()` 的所有用例。

## react 生命周期函数

**初始化阶段**

- `getDefaultProp`s:获取实例的默认属性
- `getInitialState`:获取每个实例的初始化状态
- `componentWillMount`：组件即将被装载、渲染到页面上
- `render`:组件在这里生成虚拟的 DOM 节点
- `omponentDidMount`:组件真正在被装载之后

**运行中状态**

- `componentWillReceiveProps`:组件将要接收到属性的时候调用
- `shouldComponentUpdate`:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止`render`调用，后面的函数不会被继续执行了）
- `componentWillUpdate`:组件即将更新不能修改属性和状态
- `render`:组件重新描绘
- `componentDidUpdate`:组件已经更新

**销毁阶段**

- `componentWillUnmount`:组件即将销毁

## react 性能优化是哪个周期函数

> shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能

### 简要介绍一下 React 组件的生命周期

React 的组件在第一次挂载的时候回首先获得父组件传递的 props，接着获取初始的 state 值，接着经历挂载
阶段的三个生命周期函数也就是 ComponentWillMount、render、ComponentDidMount，这三个函数
分别代表着组件将会挂载、组件渲染、组件挂载完毕三个阶段。在组件挂载完成之后，组件的 props 和 state 的任一
改变都会导致组件进入更新状态，在组件更新阶段如果是 props 改变，则进入 ComponentWillReceiveProps 函数，
接着进入 ComponetShouldUpdate 进行判定是否需要更新，如果是 state 的改变则直接进入 ComponentShouldUpdate
判定，这个默认是 true，当判定不需要更新的话，组件继续运行，需要更新则依次进入 ComponentWillUpdate、render、
ComponentDidUpdate 三个生命周期函数，依次代表着组件将要更新、组件在渲染、组件更新完毕。当组件卸载时，会首先
进入生命周期函数 ComponentWillUnmount，之后才进行卸载。如下图：
![](./react1.png)

### 在实际开发中 shouldComponentUpdate 有什么作用

## 在生命周期中的哪一步你应该发起 AJAX 请求

> 我们应当将 AJAX 请求放到 `componentDidMount` 函数中执行，主要原因有下

- React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。
- 如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了 setState 函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题

## shouldComponentUpdate 的作用

> shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新

### react 生命周期

![生命周期](http://7xlivs.com1.z0.glb.clouddn.com/2017/03/09/%E4%BB%8E%E4%B8%80%E4%B8%AA%20CRUD%20%E4%B8%8A%E6%89%8B%20React%20%E5%92%8C%20AntD/React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

组件的[生命周期](https://link.zhihu.com/?target=https%3A//facebook.github.io/react/docs/working-with-the-browser.html%23component-lifecycle)分成三个状态：

> Mounting：已插入真实 DOMUpdating：正在被重新渲染 UnMounting：已移出真实 DOM

React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。

> componentWillMount()componentDidMount()componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState)componentWillUnmount()

此外，React 还提供两种特殊状态的处理函数。

> componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用

### react 的异步操作到底应该放在哪一个生命周期函数

https://segmentfault.com/q/1010000008133309

### 在 `componentWillMount()` 方法中使用 `setState()` 好吗?

    建议避免在 `componentWillMount()` 生命周期方法中执行异步初始化。在 mounting 发生之前会立即调用 `componentWillMount()`，且它在 `render()` 之前被调用，因此在此方法中更新状态将不会触发重新渲染。应避免在此方法中引入任何副作用或订阅操作。我们需要确保对组件初始化的异步调用发生在 `componentDidMount()` 中，而不是在 `componentWillMount()` 中。

    ```jsx
    componentDidMount() {
      axios.get(`api/todos`)
        .then((result) => {
          this.setState({
            messages: [...result.data]
          })
        })
    }
    ```

### 如果在初始状态中使用 props 属性会发生什么?

    如果在不刷新组件的情况下更改组件上的属性，则不会显示新的属性值，因为构造函数函数永远不会更新组件的当前状态。只有在首次创建组件时才会用 props 属性初始化状态。

    以下组件将不显示更新的输入值：

    ```jsx
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)

        this.state = {
          records: [],
          inputValue: this.props.inputValue
        };
      }

      render() {
        return <div>{this.state.inputValue}</div>
      }
    }
    ```

    在 render 方法使用使用 props 将会显示更新的值：


    ```jsx
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)

        this.state = {
          record: []
        }
      }

      render() {
        return <div>{this.props.inputValue}</div>
      }
    }
    ```

### 为什么不能在 componentWillUnmount 中调用 setState() 方法?

     不应在 componentWillUnmount() 中调用 setState()，因为一旦卸载了组件实例，就永远不会再次装载它。

### 您能描述一下 componentDidCatch 生命周期方法签名吗?

     在后代层级的组件抛出错误后，将调用**componentDidCatch**生命周期方法。该方法接收两个参数：

     error: - 抛出的错误对象
     info: - 具有 componentStack 键的对象，包含有关哪个组件引发错误的信息。

     方法结构如下：

     ```js
     componentDidCatch(error, info)
     ```

### 如何确保钩子遵循正确的使用规则?

     React 团队发布了一个名为**eslint-plugin-react-hooks**的 ESLint 插件，它实施了这两个规则。您可以使用以下命令将此插件添加到项目中，

     ```shell
     npm install eslint-plugin-react-hooks@next
     ```

     并在您的 ESLint 配置文件中应用以下配置：
     ```js
     // Your ESLint configuration
     {
       "plugins": [
         // ...
         "react-hooks"
       ],
       "rules": {
         // ...
         "react-hooks/rules-of-hooks": "error"
       }
     }
     ```

     **注意：** 此插件在 Create React App 已经默认配置。

### 如何发起 AJAX 调用以及应该在哪些组件生命周期方法中进行 AJAX 调用?

     你可以使用 AJAX 库，如 Axios，jQuery AJAX 和浏览器内置的 `fetch` API。你应该在 `componentDidMount()` 生命周期方法中获取数据。这样当获取到数据的时候，你就可以使用 `setState()` 方法来更新你的组件。

     例如，从 API 中获取员工列表并设置本地状态：

     ```jsx
     class MyComponent extends React.Component {
       constructor(props) {
         super(props)
         this.state = {
           employees: [],
           error: null
         }
       }

       componentDidMount() {
         fetch('https://api.example.com/items')
           .then(res => res.json())
           .then(
             (result) => {
               this.setState({
                 employees: result.employees
               })
             },
             (error) => {
               this.setState({ error })
             }
           )
       }

       render() {
         const { error, employees } = this.state
         if (error) {
           return <div>Error: {error.message}</div>;
         } else {
           return (
             <ul>
               {employees.map(item => (
                 <li key={employee.name}>
                   {employee.name}-{employees.experience}
                 </li>
               ))}
             </ul>
           )
         }
       }
     }
     ```

## 生命周期

在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题，关于 Fiber 的内容将会在下一章节中讲到。

在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 `state`，那么调用栈可能会很长

![img](./images/164358b0310f476c.jpg)

调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生。

Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。

![img](./images/164358f89595d56f.jpg)

对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画。

对于异步渲染，现在渲染有两个阶段：`reconciliation` 和 `commit` 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。

**Reconciliation** 阶段

- `componentWillMount`
- `componentWillReceiveProps`
- `shouldComponentUpdate`
- `componentWillUpdate`

**Commit** 阶段

- `componentDidMount`
- `componentDidUpdate`
- `componentWillUnmount`

因为 Reconciliation 阶段是可以被打断的，所以 Reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。由此对于 Reconciliation 阶段调用的几个函数，除了 `shouldComponentUpdate` 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。

`getDerivedStateFromProps` 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用

```
class ExampleComponent extends React.Component {
  // Initialize state in constructor,
  // Or with a property initializer.
  state = {};

  static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.someMirroredValue !== nextProps.someValue) {
      return {
        derivedData: computeDerivedState(nextProps),
        someMirroredValue: nextProps.someValue
      };
    }

    // Return null to indicate no change to state.
    return null;
  }
}
```

`getSnapshotBeforeUpdate` 用于替换 `componentWillUpdate` ，该函数会在 `update` 后 DOM 更新前被调用，用于读取最新的 DOM 数据。

## 组件生命周期

### react16 前的生命周期

在 react16 的之前生命周期其实主要分为四个阶段：组件初始化、组件挂载、组件更新、组件卸载。
![image.png](https://camo.githubusercontent.com/3633f99bf7e88c34bd65c50b9661fc505d1ae3d7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3231383736372f313535333833383237323930332d62636162313861342d376332352d343663612d386635322d3733356234353663303766622e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d343632266e616d653d696d6167652e706e67266f726967696e4865696768743d393234266f726967696e57696474683d323030302673697a653d323236373338267374617475733d646f6e652677696474683d31303030)

#### 组件初始化阶段

##### constructor

在该阶段组件中的构造方法 constructor() 接受 props 接收父组件传下来的 props。还可以在 constructor() 内部定义定义 this.state 的初始内容。注意：在组件中写了 constructor 方法就必须在里面使用 super()，并且应在其他语句之前前调用  super(props)。否则，this.props  在构造函数中可能会出现未定义的 bug。

```js
 constructor(props) {
  super(props)
  console.log(this.props) // 在内部可以使用props
  this.state = {
    //定义state初始值
  }
}
```

#### 组件挂载阶段

##### componentWillMount

在组件将要挂载到 DOM 前调用，只会被调用一次，在该方法中修改 state 的值，并不会引起组件重新渲染。(数据请求等异步操作不建议写在该方法内，异步操作可能阻塞 UI)。

```js
componentWillMount(){}
```

##### render()

该函数会创建一个虚拟 DOM，用来表示组件的输出。只能通过 this.props 和 this.state 访问数据，且不能在里面执行 this.setState 更该组件状态。在 render 中可以返回 null、false 或者任何 React 组件，只能出现一个顶级组件，不能返回一组元素(在 react16 中有所改善，可以返回一组元素或单个字符串)。

```js
Render(){
	return (
  		// react组件
  )
}
```

##### componentDidMount

组件挂载到 Dom 后调用，且只调用一次。此时组件已经生成对应的 DOM 结构，可以在该函数中通过 ReactDOM.findDOMNode()访问到真实的 DOM 或者通过 this.refs.[refName] 属性获取真实 DOM 。(数据请求等异步操作建议写在该方法内)

```js
componentDidMount() {
  // 进行异步数据请求或者获取dom
}
```

#### 组件更新阶段

##### componentWillReceiveProps

该函数接受一个参数 nextProps,当父组件重传 props 时会调用。拿到新的 props 与旧的 props 来比较是否变化，若变化可以通过 this.setState 更新 state。当然也可以不比较新旧 props 值直接更新 state。

```js
componentWillReceiveProps(nextProps) {
  // 示例
  if (nextProps.state !== this.props.state) {
     this.setState({
       state: nextProps.state
     });
  }
}
```

> 官方提示：在 componentWillReceiveProps 中调用  this.setState()  将不会引起第二次渲染。

由于每次子组件接收到新的 props，都会重新渲染一次，除非你使用 shouldComponentUpdate 来阻止重新渲染，但是你可以 componentWillReceiveProps 中根据新的 props 更新 state，虽然更新 state 也会触发一次重新渲染，但并不会触发额外的 render。

##### shouldComponentUpdate(nextProps,nextState)

该函数是唯一可以控制组件渲染的生命周期。如果 props 和 state 的改变不需要重新渲染组件。则可以在该函数内返回 false，阻止组件的重新渲染。为了优化组件性能，减少组件的不必要渲染。

```js
shouldComponentUpdate(nextProps, nextState){
  // return true 更新组件
  // return false 则不更新组件
}
```

##### componentWillUpdate(nextProps,nextState)

shouldComponentUpdate 方法返回 true 后，在组件即将进行重新渲染前调用该函数(注意不要里面去更新 props 或者 state，会导致组件进入死循环),在这之后会调用 render 方法进行重新渲染。

```js
componentWillUpdate(nextProps,nextState) {
  // 不要在此处更新props或state
}
```

##### componentDidUpdate(prevProps,prevState)

组件被重新渲染后该方法会被调用，可以拿到更新前的 props 和 state 。除了首次渲染时调用的 componentDidMount，之后每次渲染都会调用该函数。和 componentDidMount 类似的是可以在这里操作更新后的 DOM。

```js
componentDidUpdate(prevProps,prevState) {}
```

#### 组件卸载阶段

##### componentWillUnmount

该函数在组件卸载前被调用，可以在执行一些清理工作，比如清除组件中使用的定时器或者事件监听器，以避免引起内存泄漏。

```js
componentWillUnmount() {
  // 清除定时器或事件监听器
}
```

### react16 的生命周期

react16 的生命周期新引入了三个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate，componentDidCatch,弃用的三个生命周期函数：componentWillMount、componentWillReceivePorps，componentWillUpdate。其他的生命周期功能与前面介绍的相同。

##### getDerivedStateFromProps(props, state)

该函数在组件挂载阶段和后续更新阶段调用，根据 props 和 state 两个参数，计算出预期的状态改变，返回一个对象表示新的 state 进行更新；如果不需要更新，返回 null 即可。该函数用来替代 componentWillReceiveProps。

```js
static getDerivedStateFromProps(props, state) {
  //根据props和state计算出预期的状态改变，返回结果会被送给setState
}
```

##### getSnapshotBeforeUpdate(prevProps, prevState)

该函数在 render 之后被调用，可以读取但无法使用 DOM 的时候。它使得组件能在发生更改之前从 DOM 中捕获一些信息(例如，滚动位置)。返回值将作为 componentDidUpdate 的第三个参数。该函数配合 componentDidUpdate, 可以替代 componentWillUpdate。

```js
  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log('getSnapshotBeforeUpdate');
    return 'react16';
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log('snapshot = ', snapshot);
  }
```

##### static getDerivedStateFromError()

此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state。

```
  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染可以显降级 UI
    return { hasError: true };
  }
```

##### componentDidCatch(error，info)

任何一处的 javascript 会触发该函数。

```
componentDidCatch(error, info) {
  // 获取到javascript错误
}
```

### 总结

react16 更新后的生命周期可以总结为：

##### 组件挂载阶段

- constructor
- getDerivedStateFromProps
- render
- componentDidMount

##### 组件更新阶段

- getDerivedStateFromProps
- shouldComponentUpdate
- render
- getSnapshotBeforeUpdate
- componentDidUpdate

##### 组件卸载阶段

- componentWillUnmount

![image.png](https://camo.githubusercontent.com/b34e031d6d8cee6068cb2ad23cc6d847126fc968/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323031392f706e672f3231383736372f313535333833383539323333392d61666463626466642d626366382d343834662d626162372d6262393663363734383431632e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d373833266e616d653d696d6167652e706e67266f726967696e4865696768743d31353636266f726967696e57696474683d323831362673697a653d323639393931267374617475733d646f6e652677696474683d31343038)![image](https://user-images.githubusercontent.com/21194931/55275775-13f1ff00-5326-11e9-9399-946de9d083ec.png)

- 图片来自http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

参考链接：

- [react 官方文档](https://reactjs.org/docs/react-component.html)

### 组件无法访问生命周期的方法

因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。无状态组件只能访问输入的 props，同样的 props 会得到同样的渲染结果，不会有副作用.
无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来 React 也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。

### 补充一点

无状态组件内部其实是可以使用 ref 功能的，虽然不能通过 this.refs 访问到，但是可以通过将 ref 内容保存到无状态组件内部的一个本地变量中获取到。
例如下面这段代码可以使用 ref 来获取组件挂载到 dom 中后所指向的 dom 元素：

```
function TestComp(props){
    let ref;
    return (<div>
        <div ref={(node) => ref = node}>
            ...
        </div>
    </div>)
}
```

### 使用 unstable_renderSubtreeIntoContainer 这个不稳定 api 来实现

```js
// App.jsx
class App extends Component {
  render() {
    return (
      <B>
        <A>
          <C></C>
        </A>
      </B>
    );
  }
}

// B组件
export default class B extends Component {
  render() {
    return (
      <div>
        b组件
        <div>{this.props.children}</div>
      </div>
    );
  }
}

// C.jsx
export default class C extends Component {
  render() {
    return <div>c组件</div>;
  }
}
```

a 组件实现

```js
// A组件
export default class A extends Component {
  componentDidMount() {
    this.parentElement = ReactDOM.findDOMNode(this).parentElement;
    this.renderChild();
  }
  componentDidUpdate() {
    this.renderChild();
  }
  renderChild() {
    const renderACom = (
      <div>
        {this.render()}
        {this.props.children}
      </div>
    );
    ReactDOM.unstable_renderSubtreeIntoContainer(this, renderACom, this.parentElement);
  }
  render() {
    return <div>a组件</div>;
  }
}
```

### createPortal

```js
export default class A extends Component {
  componentDidMount() {
    this.forceUpdate();
  }
  render() {
    const renderACom = (
      <div>
        <div>a组件</div>
        {this.props.children}
      </div>
    );
    if (!ReactDOM.findDOMNode(this)) {
      return <div></div>;
    }
    return ReactDOM.createPortal(renderACom, ReactDOM.findDOMNode(this).parentElement);
  }
}
```

### react 组件的优化

react 组件优化手段

- 尽量多使用无状态函数构建组件
- 拆分组件为子组件，对组件做更细粒度的控制
- 运用 PureRender，对变更做出最少的渲染即 PureComponent
- 使用 shouldComponentUpdate
- 运用 immutable

### react 事件机制

其实 React 事件并没有原生的绑定在真实的 DOM 上，而是使用了行为委托方式实现事件机制。
React 会将所有的事件都绑定在最外层(document)，使用统一的事件监听，并在冒泡阶段处理事件，当挂载或者卸载组件时，只需要在通过的在统一的事件监听位置增加或者删除对象，因此可以提高效率。
而是在基于 Virtual DOM 的基础上实现了合成事件(SyntheticEvent)
因此在事件层次上具有浏览器兼容性，与原生的浏览器事件一样拥有同样的接口

- 使用事件委托技术进行事件代理，React 组件上声明的事件最终都转化为 DOM 原生事件，绑定到了 document 这个 DOM 节点上。从而减少了内存开销。
- 自身实现了一套事件冒泡机制，以队列形式，从触发事件的组件向父组件回溯，调用在 JSX 中绑定的 callback。因此我们也没法用 event.stopPropagation() 来停止事件传播，应该使用 React 定义的 event.preventDefault()。
- 所有事件绑定在 document 上
- 所以事件触发的都是 ReactEventListener 的 dispatch 方法

### Fiber

Fiber 是对 React 核心算法的重构，2 年重构的产物就是 Fiber reconciler
核心目标：扩大其适用性，包括动画，布局和手势。分为 5 个具体目标

- 把可中断的工作拆分成小任务
- 对正在做的工作调整优先次序、重做、复用上次（做了一半的）成果
- 在父子任务之间从容切换（yield back and forth），以支持 React 执行过程中的布局刷新
- 支持 render()返回多个元素
- 更好地支持 error boundary

Fiber 的关键特性如下:

- 增量渲染（把渲染任务拆分成块，匀到多帧）
- 更新时能够暂停，终止，复用渲染任务
- 给不同类型的更新赋予优先级
- 并发方面新的基础能力

增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用。这种策略叫做 cooperative scheduling（合作式调度），操作系统的 3 种任务调度策略之一（Firefox 还对真实 DOM 应用了这项技术）

### react 有什么坑点

1. JSX 做表达式判断时候，需要强转为 boolean 类型
2. 尽量不要在 componentWillReviceProps 里使用 setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃。(实际不是 componentWillReviceProps 会无限重渲染，而是 componentDidUpdate)
3. 给组件添加 ref 时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的 prop 处理，让 ref 属性接受到新函数的时候，react 内部会先清空 ref，也就是会以 null 为回调参数先执行一次 ref 这个 props，然后在以该组件的实例执行一次 ref，所以用匿名函数做 ref 的时候，有的时候去 ref 赋值后的属性会取到 null
4. 遍历子节点的时候，不要用 index 作为组件的 key 进行传入

## createStore.js

createStore 是 redux 中一个非常重要的 API，createStore 会生成一个 store，维护一个状态树，里面是全局的 state,

```js
store = createStore(reducer, preloadedState, enhancer);
```

createStore 接受三个参数，分别为 reducer 纯函数，初始状态，增强器（即 applyMiddleware()返回的东西以及其他的中间件）用法如下：

```
const enhancer = compose(
    applyMiddleware(sagaMiddleware),
    composeWithDevTools()
);
```

createStore 生成的 store 提供了 dispath,subscribe,getState,replaceReducer,observable 等方法，接下来逐一分析。

```js
export default function createStore(reducer, preloadedState, enhancer) {
  // 判断接受的参数个数，来指定 reducer 、 preloadedState 和 enhancer
  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  let currentReducer = reducer; // 存储当前的reducer
  let currentState = preloadedState; // 存储当前的状态
  let currentListeners = []; // 储存当前的监听函数列表
  let nextListeners = currentListeners; // 储存下一个监听函数列表
  let isDispatching = false; //是否在执行reducer
}
```

首先判定参数个数，分别指定三个参数，接着判断 enhancer 是否存在并且为函数则调用 enhancer，并且终止当前函数执行，前面的判断基本上是对三个参数对判断。接下来是对当前状态及 reducer 的存储。

### getState

```js
// 接上述代码，这里不在重复
function getState() {
  if (isDispatching) {
    throw new Error(
      'You may not call store.getState() while the reducer is executing. ' +
        'The reducer has already received the state as an argument. ' +
        'Pass it down from the top reducer instead of reading it from the store.',
    );
  }

  return currentState;
}
```

这里判断是否在执行 reducer，返回当前的最新状态 state.

### dispatch

```js
function dispatch(action) {
  if (!isPlainObject(action)) {
    throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
  }

  if (typeof action.type === 'undefined') {
    throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
  }

  if (isDispatching) {
    throw new Error('Reducers may not dispatch actions.');
  }

  try {
    isDispatching = true;
    currentState = currentReducer(currentState, action);
  } finally {
    isDispatching = false;
  }

  const listeners = (currentListeners = nextListeners);
  for (let i = 0; i < listeners.length; i++) {
    const listener = listeners[i];
    listener();
  }

  return action;
}
```

dispatch 接受一个参数 action，action 是把数据从应用传到 store 的有效载荷,它是 store 数据的唯一来源,action 包含 type 和 payload,payload 表示最新的状态 state，type 代表操作类型。传入 action 后会首先运行 reducer，reducer 接收 action 和当前状态 state,reducer 只判断 type 属性来返回最新的 state。
dispatch 还会触发整个监听函数列表，所以最后整个监听函数列表都会按顺序执行一遍。dispatch 返回值就是传入的 action。

### subscribe

```js
function ensureCanMutateNextListeners() {
  if (nextListeners === currentListeners) {
    nextListeners = currentListeners.slice();
  }
}
```

ensureCanMutateNextListeners 会根据当前的监听函数列表生成下一个监听函数列表。

```
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.')
    }

    if (isDispatching) {
      throw new Error(
        'You may not call store.subscribe() while the reducer is executing. ' +
          'If you would like to be notified after the store has been updated, subscribe from a ' +
          'component and invoke store.getState() in the callback to access the latest state. ' +
          'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
      )
    }

    let isSubscribed = true

    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      if (isDispatching) {
        throw new Error(
          'You may not unsubscribe from a store listener while the reducer is executing. ' +
            'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'
        )
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
    }
  }
```

subscribe 会接受一个 listener 函数，首先运行 ensureCanMutateNextListeners 生成下一个监听列表，然后向列表中添加进新的监听函数 listenner,subscribe 的返回值是一个 unsubscribe，是一个解绑函数，调用该解绑函数，会将已经添加的监听函数删除，该监听函数处于一个闭包之中，会一直存在，所以在解绑函数中能删除该监听函数。这就是 redux 精妙之处。

### replaceReducer

```js
function replaceReducer(nextReducer) {
  if (typeof nextReducer !== 'function') {
    throw new Error('Expected the nextReducer to be a function.');
  }

  currentReducer = nextReducer;
  dispatch({ type: ActionTypes.REPLACE });
}
```

顾名思义 replaceReducer 的意思就是替换掉 reducer，replaceReducer 接受一个 reducer 替换的当前的 reducer，之后立即执行 dispatch({ type: ActionTypes.INIT }) ，用来初始化 store 的状态。
replaceReducer 的使用场景，分别是：

> 1.当你的程序要进行代码分割的时候 2.当你要动态的加载不同的 reducer 的时候 3.当你要实现一个实时 reloading 机制的时候

### observable

该方法并不是暴露给使用者的，一般用于内部，在测试的时候会用到，这里不深究。

[redux 源码分析(二) ](https://github.com/LuoShengMen/StudyNotes/issues/170)

### 聊聊 Redux 和 Vuex 的设计思想

Redux vs VUEX 对比分析
store 和 state 是最基本的概念，VUEX 没有做出改变。其实 VUEX 对整个框架思想并没有任何改变，只是某些内容变化了名称或者叫法，通过改名，以图在一些细节概念上有所区分。

VUEX 弱化了 dispatch 的存在感。VUEX 认为状态变更的触发是一次“提交”而已，而调用方式则是框架提供一个提交的 commit API 接口。

VUEX 取消了 Redux 中 Action 的概念。不同于 Redux 认为状态变更必须是由一次"行为"触发，VUEX 仅仅认为在任何时候触发状态变化只需要进行 mutation 即可。Redux 的 Action 必须是一个对象，而 VUEX 认为只要传递必要的参数即可，形式不做要求。

VUEX 也弱化了 Redux 中的 reducer 的概念。reducer 在计算机领域语义应该是"规约"，在这里意思应该是根据旧的 state 和 Action 的传入参数，"规约"出新的 state。在 VUEX 中，对应的是 mutation，即"转变"，只是根据入参对旧 state 进行"转变"而已。

总的来说，VUEX 通过弱化概念，在任何东西都没做实质性削减的基础上，使得整套框架更易于理解了。
另外 VUEX 支持 getter，运行中是带缓存的，算是对提升性能方面做了些优化工作，言外之意也是鼓励大家多使用 getter。

[详解](https://www.jianshu.com/p/e0987169de96)

### redux 如何更新组件

```js
store.subscribe(() => this.setState({ count: store.getState() }));
```

subscribe 中添加回调监听函数，当 dispatch 触发的时候，会执行 subscribe listeners 中的函数。

subscribe 负责监听改变

### redux 为什么要把 reducer 设计成纯函数

先看源码

```js
  ...
    let hasChanged = false
    const nextState = {}
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
```

这一段 const nextStateForKey = reducer(previousStateForKey, action)代码通过 reducer 返回的 state,然后通过 hasChanged = hasChanged || nextStateForKey !== previousStateForKey 来比较新旧两个对象是否一致，此比较法 �，比较的是两个对象的 � 存储位置，也就是浅比较法,如果当 reduxer 返回旧的 state,redux 认为没有改变，页面也就不会更新

为什么要这么做？
因为比较两个 javascript 对象中所有的属性是否 � 完全相同，� 唯一的办法就是深比较，然而，深比较在真实的应用中代码是非常大的，非常耗性能的，需要比较的 � 次数特别多，所以一个有效的解决方案就是做一个 � 规定，当无论发生任何变化时，开发者都要 � 返回一个新的对象，没有变化时，开发者返回就的对象，这也就是 redux 为什么要把 reducer 设计成纯函数的原因

### redux-saga
