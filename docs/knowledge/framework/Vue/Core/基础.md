---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 为什么 filter 里的 this 绑定的不是 Vue 实例，而是 Window 对象

Vue https://juejin.im/post/5cbd2623f265da03ba0e2aab

### vue 父子组件的标签一些特殊的地方

- class 值是不用传的，所以会存在一个样式泄漏的问题
- 普通的 click 事件也不需要子组件内部去做特殊处理，在父组件里使用子组件时，直接用 @click 就会透传

### vue 的 h 函数

render 函数中的参数

### 子组件几个事件的差别

```js
this.$emit('update:value', this.visible);
this.$emit('change', this.visible);
```

### vue 全局和单个组件获取配置信息

#### 获取全局注册的组件

```js
Vue.options.components;
```

#### 获取当前组件注册的组件

```js
this.$options.components;
```

### proxy 代理？

### vue 如何优化首屏加载速度？

### vm 实例属性

- `vm._renderProxy`
- `vm.$createElement`
- `vm._vnode`

```js
// render.js/initRender()
// 父 vnode
const parentVnode = (vm.$vnode = options._parentVnode);
```

```js
// init.js/initMixin()
// 实例本身，循环引用
vm._renderProxy = vm;
```

```js
// lifecycle.js/mountComponent()
// 渲染组件的容器 dom， 一般来说是值都是根节点的渲染 dom
vm.$el = el;
```

实例 template 节点转化成的渲染函数： `vm.$options.render`

```js
// entry-runtime-with-compiler.js
// 能够将 template 节点编译成 render 函数的函数
Vue.compile = compileToFunctions;
```

### 总结

#### 基础

1. Vue 思想
2. Vue 内部运行机制
3. Vue 事件绑定
4. Watch 和 Computed
5. Vue 生命周期
6. Vue 组件及通讯
7. Vue 动画
8. 插槽
9. 自定义指令

#### 进阶

1. Vue-cli 搭建项目与项目结构分析
2. 路由搭建，router 的常用操作
3. vuex 的使用
4. hooks 的应用

#### 源码分析

1. 响应式原理
2. vue 生命钩子函数执行分析
3. vue 模板编译、渲染函数原理分析
4. 了解 Vue3 吗，相对于 Vue2 做了哪些优化

### vue style 样式穿透

原理

https://segmentfault.com/a/1190000017508285

### 实现 vue 中的 on,emit,off,once，手写代码

```js
// 参照 vue 源码实现
var EventEmitter = function() {
  this._events = {};
};
EventEmitter.prototype.on = function(event, cb) {
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.on(event[i], cb);
    }
  } else {
    (this._events[event] || (this._events[event] = [])).push(cb);
  }
  return this;
};
EventEmitter.prototype.once = function(event, cb) {
  function on() {
    this.off(event, cb);
    cb.apply(this, arguments);
  }
  on.fn = cb;
  this.on(event, on);
  return this;
};
EventEmitter.prototype.off = function(event, cb) {
  if (!arguments.length) {
    this._events = Object.create(null);
    return this;
  }
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      this.off(event[i], cb);
    }
    return this;
  }
  if (!cb) {
    this._events[event] = null;
    return this;
  }
  if (cb) {
    let cbs = this._events[event];
    let i = cbs.length;
    while (i--) {
      if (cb === cbs[i] || cb === cbs[i].fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return this;
  }
};
EventEmitter.prototype.emit = function(event) {
  let cbs = this._events[event];
  let args = Array.prototype.slice.call(arguments, 1);
  if (cbs) {
    for (let i = 0, l = cbs.length; i < l; i++) {
      cbs[i].apply(this, args);
    }
  }
};
```

### Vue 的父组件和子组件生命周期钩子执行顺序是什么

父组建： beforeCreate -> created -> beforeMount
子组件： -> beforeCreate -> created -> beforeMount -> mounted
父组件： -> mounted
总结：从外到内，再从内到外

### vue 怎么实现页面的权限控制

利用 vue-router 的 beforeEach 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。
