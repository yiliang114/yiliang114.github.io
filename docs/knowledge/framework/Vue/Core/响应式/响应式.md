---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 如何处理 data 中的属性是一个对象 or 数组，仅仅改变其属性的属性是如何被监听的？

### v-bind 和 v-model 的区别

1.v-bind 用来绑定数据和属性以及表达式，缩写为'：'
2.v-model 使用在表单中，实现双向数据绑定的，在表单元素外使用不起作用

### vue 的双向绑定的原理是什么(常考)

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：
第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化

第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:

- 在自身实例化时往属性订阅器(dep)里面添加自己
- 自身必须有一个 update()方法
- 待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。

第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。

### Vue 实现数据双向绑定的原理：Object.defineProperty

vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty（）来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

vue 的数据双向绑定 将 MVVM 作为数据绑定的入口，整合 Observer，Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，通过 Compile 来解析编译模板指令（vue 中是用来解析 {{}}），最终利用 watcher 搭起 observer 和 Compile 之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据 model 变更双向绑定效果。

js 实现简单的双向绑定

```html
<body>
  <div id="app">
    <input type="text" id="txt" />
    <p id="show"></p>
  </div>
</body>
<script type="text/javascript">
  var obj = {};
  Object.defineProperty(obj, 'txt', {
    get: function() {
      return obj;
    },
    set: function(newValue) {
      document.getElementById('txt').value = newValue;
      document.getElementById('show').innerHTML = newValue;
    },
  });
  document.addEventListener('keyup', function(e) {
    obj.txt = e.target.value;
  });
</script>
```

### 响应式原理

Vue 内部使用了 `Object.defineProperty()` 来实现数据响应式，通过这个函数可以监听到 `set` 和 `get` 的事件。

```
var data = { name: 'yiliang114' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```

以上代码简单的实现了如何监听数据的 `set` 和 `get` 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。

```
<div>
    {{name}}
</div>
```

在解析如上模板代码时，遇到 `{{name}}` 就会进行依赖收集。

接下来我们先来实现一个 `Dep` 类，用于解耦属性的依赖收集和派发更新操作。

```
// 通过 Dep 解耦属性的依赖和更新操作
class Dep {
  constructor() {
    this.subs = []
  }
  // 添加依赖
  addSub(sub) {
    this.subs.push(sub)
  }
  // 更新
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null
```

以上的代码实现很简单，当需要依赖收集的时候调用 `addSub`，当需要派发更新的时候调用 `notify`。

接下来我们先来简单的了解下 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 `Object.defineProperty()`，然后实例化 `Watcher`，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。

因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。

```
class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
```

以上就是 `Watcher` 的简单实现，在执行构造函数的时候将 `Dep.target` 指向自身，从而使得收集到了对应的 `Watcher`，在派发更新的时候取出对应的 `Watcher` 然后执行 `update` 函数。

接下来，需要对 `defineReactive` 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。

```js
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val);
  let dp = new Dep();
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value');
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target);
      }
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log('change value');
      val = newVal;
      // 执行 watcher 的 update 方法
      dp.notify();
    },
  });
}
```

以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。

现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。

```js
var data = { name: 'yiliang114' };
observe(data);
function update(value) {
  document.querySelector('div').innerText = value;
}
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update);
// update Dom innerText
data.name = 'yyy';
```

### Object.defineProperty 的缺陷

以上已经分析完了 Vue 的响应式原理，接下来说一点 `Object.defineProperty` 中的缺陷。

如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 `Object.defineProperty` 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。

对于第一个问题，Vue 提供了一个 API 解决

```js
export function set(target: Array<any> | Object, key: any, val: any): any {
  // 判断是否为数组且下标是否有效
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 调用 splice 函数触发派发更新
    // 该函数已被重写
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  // 判断 key 是否已经存在
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  const ob = (target: any).__ob__;
  // 如果对象不是响应式对象，就赋值返回
  if (!ob) {
    target[key] = val;
    return val;
  }
  // 进行双向绑定
  defineReactive(ob.value, key, val);
  // 手动派发更新
  ob.dep.notify();
  return val;
}
```

对于数组而言，Vue 内部重写了以下函数实现派发更新

```js
// 获得数组原型
const arrayProto = Array.prototype;
export const arrayMethods = Object.create(arrayProto);
// 重写以下函数
const methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
methodsToPatch.forEach(function(method) {
  // 缓存原生函数
  const original = arrayProto[method];
  // 重写函数
  def(arrayMethods, method, function mutator(...args) {
    // 先调用原生函数获得结果
    const result = original.apply(this, args);
    const ob = this.__ob__;
    let inserted;
    // 调用以下几个函数时，监听新数据
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    // 手动派发更新
    ob.dep.notify();
    return result;
  });
});
```

### 数据双向绑定原理：常见数据绑定的方案

- `Object.defineProperty（vue）`：劫持数据的 `getter` 和 `setter`
- 脏值检测：通过特定事件进行轮循
  发布/订阅模式：通过消息发布并将消息进行订阅

### Vue 的双向绑定

```html
<input type="checkbox" class="tc-15-checkbox" v-model="isNeed" />
```

`v-model` 不要跟 `@input` 同时使用，会有延迟的，也就是说 `@input` 获取 `v-model` 的值不是实时的。

https://segmentfault.com/q/1010000005725541

两种解决办法：

```html
<input type="checkbox" class="tc-15-checkbox" v-model="needComform" @change="onchange" >开启自动回复</input>
```

```js
onchange() {
  console.log("needComform", this.needComform);
  this.setDetail({
    target: "valid",
    value: this.needComform ? 1 : 0
  });
  // setTimeout(() => {
  //   console.log("needComform", this.needComform);
  //   this.setDetail({
  //     target: "valid",
  //     value: this.needComform ? 1 : 0
  //   });
  // }, 0);
},
```

### 如何处理 data 中的属性是一个对象 or 数组，仅仅改变其属性的属性是如何被监听的？

### Vue 的响应式原理中 Object.defineProperty 有什么缺陷？

为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？

1. Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
2. Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。
3. Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

### Vue 的父组件和子组件生命周期钩子执行顺序是什么

父组建： beforeCreate -> created -> beforeMount
子组件： -> beforeCreate -> created -> beforeMount -> mounted
父组件： -> mounted
总结：从外到内，再从内到外

### vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？

说一下我个人理解，先说结论，可以使用

事件代理作用主要是 2 个

1. 将事件处理程序代理到父节点，减少内存占用率
2. 动态生成子节点时能自动绑定事件处理程序到父节点

这里我生成了十万个 span 节点，通过 performance monitor 来监控内存占用率和事件监听器的数量，对比以下 3 种情况

1. 不使用事件代理，每个 span 节点绑定一个 click 事件，并指向同一个事件处理程序

```html
<div>
  <span v-for="(item,index) of 100000" :key="index" @click="handleClick">
    {{item}}
  </span>
</div>
```

1. 不使用事件代理，每个 span 节点绑定一个 click 事件，并指向不同的事件处理程序

```html
<div>
  <span v-for="(item,index) of 100000" :key="index" @click="function () {}">
    {{item}}
  </span>
</div>
```

1. 使用事件代理

```html
<div @click="handleClick">
  <span v-for="(item,index) of 100000" :key="index"> {{item}} </span>
</div>
```

[![image](https://user-images.githubusercontent.com/39046570/59992198-235ebb00-967d-11e9-9b17-a7b1c6f761a9.png)](https://user-images.githubusercontent.com/39046570/59992198-235ebb00-967d-11e9-9b17-a7b1c6f761a9.png)

[![image](https://user-images.githubusercontent.com/39046570/59992186-13df7200-967d-11e9-9bb2-f6d5335a9583.png)](https://user-images.githubusercontent.com/39046570/59992186-13df7200-967d-11e9-9bb2-f6d5335a9583.png)

[![image](https://user-images.githubusercontent.com/39046570/59992179-0cb86400-967d-11e9-91bf-421ee14a94e3.png)](https://user-images.githubusercontent.com/39046570/59992179-0cb86400-967d-11e9-91bf-421ee14a94e3.png)

可以看到使用事件代理无论是监听器数量和内存占用率都比前两者要少

同时对比 3 个图中监听器的数量以及我以往阅读 vue 源码的过程中，并没有发现 vue 会自动做事件代理，但是一般给 v-for 绑定事件时，都会让节点指向同一个事件处理程序（第二种情况可以运行，但是 eslint 会警告），一定程度上比每生成一个节点都绑定一个不同的事件处理程序性能好，但是监听器的数量仍不会变，所以使用事件代理会更好一点

### vue 渲染大量数据时应该怎么优化？

Object.freeze 冻结对象，不让 vue 劫持. 以及使用 虚拟列表

### vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？

首页白屏的原因：
单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的 js 文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏

解决办法：

优化 webpack 减少模块打包体积，code-split 按需加载
服务端渲染，在服务端事先拼装好首页所需的 html
首页加 loading 或 骨架屏 （仅仅是优化体验）

### 为什么 for 循环嵌套顺序会影响性能？

```js
var t1 = new Date().getTime();
for (let i = 0; i < 100; i++) {
  for (let j = 0; j < 1000; j++) {
    for (let k = 0; k < 10000; k++) {}
  }
}
var t2 = new Date().getTime();
console.log('first time', t2 - t1);

for (let i = 0; i < 10000; i++) {
  for (let j = 0; j < 1000; j++) {
    for (let k = 0; k < 100; k++) {}
  }
}
var t3 = new Date().getTime();
console.log('two time', t3 - t2);
```

应该是第一个时间少一点，比如，按照每次循环判断来说 （初始化 自增次数类似）

1. i 会循环 100 次，判断 i<100 100 次
   j 会循环 100 _ 1000 次，判断 j<100 100 _ 1000 次
   k 会循环 100 _ 1000 _ 10000 次，判断 k<100 100 _ 1000 _ 10000 次

2. i 会循环 10000 次，判断 i<100 10000 次
   j 会循环 10000 _ 1000 次，判断 j<100 10000 _ 1000 次
   k 会循环 100 _ 1000 _ 10000 次， 判断 k<100 100 _ 1000 _ 10000 次

虽然判断 k<100 的次数都是一样的 但是前面两种判断就不一样了，由此可以看见时间长短。

### webpack 打包 vue 速度太慢怎么办？

1.使用`webpack-bundle-analyzer`对项目进行模块分析生成 report，查看 report 后看看哪些模块体积过大，然后针对性优化，比如我项目中引用了常用的 UI 库 element-ui 和 v-charts 等

2.配置 webpack 的`externals`，官方文档的解释：防止将某些`import`的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖。
所以，可以将体积大的库分离出来：

```
// ...
externals: {
    'element-ui': 'Element',
    'v-charts': 'VCharts'
}
```

3.然后在`main.js`中移除相关库的 import

4.在`index.html`模板文件中，添加相关库的`cdn`引用，如：

```html
<script src="https://unpkg.com/element-ui@2.10.0/lib/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/v-charts/lib/index.min.js"></script>
```

经过以上的处理，再尝试编译打包，会发现速度快了一些。
有什么更好的方式或不对的地方欢迎指出

### vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法

对于这些变异方法 vue 做了包裹，在原型上进行了拦截，调用原生的数组方法后，还会执行发布和变更的操作来触发视图的更新。

### 在 Vue 中，子组件为何不可以修改父组件传递的 Prop

如果修改了，Vue 是如何监控到属性的修改并给出警告的。

1. 子组件为何不可以修改父组件传递的 Prop
   单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。
2. 如果修改了，Vue 是如何监控到属性的修改并给出警告的。

```js
if (process.env.NODE_ENV !== 'production') {
  var hyphenatedKey = hyphenate(key);
  if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
    warn('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.', vm);
  }
  defineReactive$$1(props, key, value, function() {
    if (!isRoot && !isUpdatingChildComponent) {
      warn(
        'Avoid mutating a prop directly since the value will be ' +
          'overwritten whenever the parent component re-renders. ' +
          "Instead, use a data or computed property based on the prop's " +
          'value. Prop being mutated: "' +
          key +
          '"',
        vm,
      );
    }
  });
}
```

在 initProps 的时候，在 defineReactive 时通过判断是否在开发环境，如果是开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 中被修改，如果不是，说明此修改来自子组件，触发 warning 提示。

需要特别注意的是，当你从子组件修改的 prop 属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此 key 时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改 object 的属性时不会触发提示，并且会修改父组件数据源的数据。

### javascript 实现数据双向绑定的三种方式小结

http://www.techweb.com.cn/network/system/2017-08-08/2570103.shtml

本篇文章主要介绍了 javascript 实现数据双向绑定的三种方式小结，前端的视图层和数据层有时需要实现双向绑定，目前实现数据双向绑定主要有三种，有兴趣的可以了解一下。

**前端数据的双向绑定方法**

前端的视图层和数据层有时需要实现双向绑定(two-way-binding)，例如 mvvm 框架，数据驱动视图，视图状态机等，研究了几个目前主流的数据双向绑定框架，总结了下。目前实现数据双向绑定主要有以下三种。

**1、手动绑定**

比较老的实现方式，有点像观察者编程模式，主要思路是通过在数据对象上定义 get 和 set 方法(当然还有其它方法)，调用时手动调用 get 或 set 数据，改变数据后出发 UI 层的渲染操作；以视图驱动数据变化的场景主要应用与 input、select、textarea 等元素，当 UI 层变化时，通过监听 dom 的 change，keypress，keyup 等事件来出发事件改变数据层的数据。整个过程均通过函数调用完成。

```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>data-binding-method-set</title>
</head>
<body>
  <input q-value="value" type="text" id="input">
  <div q-text="value" id="el"></div>
  <script>
    var elems = [document.getElementById('el'), document.getElementById('input')];

    var data = {
      value: 'hello!'
    };

    var command = {
      text: function(str){
        this.innerHTML = str;
      },
      value: function(str){
        this.setAttribute('value', str);
      }
    };

    var scan = function(){
      /**
       * 扫描带指令的节点属性
       */
      for(var i = 0, len = elems.length; i < len; i++){
        var elem = elems[i];
        elem.command = [];
        for(var j = 0, len1 = elem.attributes.length; j < len1; j++){
          var attr = elem.attributes[j];
          if(attr.nodeName.indexOf('q-') >= 0){
            /**
             * 调用属性指令，这里可以使用数据改变检测
             */
            command[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]);
            elem.command.push(attr.nodeName.slice(2));
          }
        }
      }
    }

    /**
     * 设置数据后扫描
     */
    function mvSet(key, value){
      data[key] = value;
      scan();
    }
    /**
     * 数据绑定监听
     */
    elems[1].addEventListener('keyup', function(e){
      mvSet('value', e.target.value);
    }, false);

    scan();

    /**
     * 改变数据更新视图
     */
    setTimeout(function(){
      mvSet('value', 'fuck');
    },1000)

  </script>
</body>
</html>
```

**2、脏检查机制**

以典型的 mvvm 框架 angularjs 为代表，angular 通过检查脏数据来进行 UI 层的操作更新。关于 angular 的脏检测，有几点需要了解些： - 脏检测机制并不是使用定时检测。 - 脏检测的时机是在数据发生变化时进行。 - angular 对常用的 dom 事件，xhr 事件等做了封装， 在里面触发进入 angular 的 digest 流程。 - 在 digest 流程里面， 会从 rootscope 开始遍历， 检查所有的 watcher。 （关于 angular 的具体设计可以看其他文档，这里只讨论数据绑定），那我们看下脏检测该如何去做：主要是通过设置的数据来需找与该数据相关的所有元素，然后再比较数据变化，如果变化则进行指令操作

```js
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>data-binding-drity-check</title>
</head>

<body>
  <input q-event="value" ng-bind="value" type="text" id="input">
  <div q-event="text" ng-bind="value" id="el"></div>
  <script>

  var elems = [document.getElementById('el'), document.getElementById('input')];

  var data = {
    value: 'hello!'
  };

  var command = {
    text: function(str) {
      this.innerHTML = str;
    },
    value: function(str) {
      this.setAttribute('value', str);
    }
  };

  var scan = function(elems) {
    /**
     * 扫描带指令的节点属性
     */
    for (var i = 0, len = elems.length; i < len; i++) {
      var elem = elems[i];
      elem.command = {};
      for (var j = 0, len1 = elem.attributes.length; j < len1; j++) {
        var attr = elem.attributes[j];
        if (attr.nodeName.indexOf('q-event') >= 0) {
          /**
           * 调用属性指令
           */
          var dataKey = elem.getAttribute('ng-bind') || undefined;
          /**
           * 进行数据初始化
           */
          command[attr.nodeValue].call(elem, data[dataKey]);
          elem.command[attr.nodeValue] = data[dataKey];
        }
      }
    }
  }

  /**
   * 脏循环检测
   * @param {[type]} elems [description]
   * @return {[type]}    [description]
   */
  var digest = function(elems) {
    /**
     * 扫描带指令的节点属性
     */
    for (var i = 0, len = elems.length; i < len; i++) {
      var elem = elems[i];
      for (var j = 0, len1 = elem.attributes.length; j < len1; j++) {
        var attr = elem.attributes[j];
        if (attr.nodeName.indexOf('q-event') >= 0) {
          /**
           * 调用属性指令
           */
          var dataKey = elem.getAttribute('ng-bind') || undefined;

          /**
           * 进行脏数据检测，如果数据改变，则重新执行指令，否则跳过
           */
          if(elem.command[attr.nodeValue] !== data[dataKey]){

            command[attr.nodeValue].call(elem, data[dataKey]);
            elem.command[attr.nodeValue] = data[dataKey];
          }
        }
      }
    }
  }

  /**
   * 初始化数据
   */
  scan(elems);

  /**
   * 可以理解为做数据劫持监听
   */
  function $digest(value){
    var list = document.querySelectorAll('[ng-bind='+ value + ']');
    digest(list);
  }

  /**
   * 输入框数据绑定监听
   */
  if(document.addEventListener){
    elems[1].addEventListener('keyup', function(e) {
      data.value = e.target.value;
      $digest(e.target.getAttribute('ng-bind'));
    }, false);
  }else{
    elems[1].attachEvent('onkeyup', function(e) {
      data.value = e.target.value;
      $digest(e.target.getAttribute('ng-bind'));
    }, false);
  }

  setTimeout(function() {
    data.value = 'fuck';
    /**
     * 这里问啥还要执行$digest这里关键的是需要手动调用$digest方法来启动脏检测
     */
    $digest('value');
  }, 2000)

  </script>
</body>
</html>
```

**3、前端数据劫持(Hijacking)**

第三种方法则是 avalon 等框架使用的数据劫持方式。基本思路是使用 Object.defineProperty 对数据对象做属性 get 和 set 的监听，当有数据读取和赋值操作时则调用节点的指令，这样使用最通用的=等号赋值就可以了。具体实现如下：

```js
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>data-binding-hijacking</title>
</head>

<body>
  <input q-value="value" type="text" id="input">
  <div q-text="value" id="el"></div>
  <script>


  var elems = [document.getElementById('el'), document.getElementById('input')];

  var data = {
    value: 'hello!'
  };

  var command = {
    text: function(str) {
      this.innerHTML = str;
    },
    value: function(str) {
      this.setAttribute('value', str);
    }
  };

  var scan = function() {
    /**
     * 扫描带指令的节点属性
     */
    for (var i = 0, len = elems.length; i < len; i++) {
      var elem = elems[i];
      elem.command = [];
      for (var j = 0, len1 = elem.attributes.length; j < len1; j++) {
        var attr = elem.attributes[j];
        if (attr.nodeName.indexOf('q-') >= 0) {
          /**
           * 调用属性指令
           */
          command[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]);
          elem.command.push(attr.nodeName.slice(2));

        }
      }
    }
  }

  var bValue;
  /**
   * 定义属性设置劫持
   */
  var defineGetAndSet = function(obj, propName) {
    try {
      Object.defineProperty(obj, propName, {

        get: function() {
          return bValue;
        },
        set: function(newValue) {
          bValue = newValue;
          scan();
        },

        enumerable: true,
        configurable: true
      });
    } catch (error) {
      console.log("browser not supported.");
    }
  }
  /**
   * 初始化数据
   */
  scan();

  /**
   * 可以理解为做数据劫持监听
   */
  defineGetAndSet(data, 'value');

  /**
   * 数据绑定监听
   */
  if(document.addEventListener){
    elems[1].addEventListener('keyup', function(e) {
      data.value = e.target.value;
    }, false);
  }else{
    elems[1].attachEvent('onkeyup', function(e) {
      data.value = e.target.value;
    }, false);
  }

  setTimeout(function() {
    data.value = 'fuck';
  }, 2000)
  </script>
</body>

</html>
```

但值得注意的是 defineProperty 支持 IE8 以上的浏览器，这里可以使用**defineGetter** 和 **defineSetter** 来做兼容但是浏览器兼容性的原因，直接用 defineProperty 就可以了。至于 IE8 浏览器仍需要使用其它方法来做 hack。如下代码可以对 IE8 进行 hack，defineProperty 支持 IE8。例如使用 es5-shim.js 就可以了。（IE8 以下浏览器忽略）

### 请简单实现双向数据绑定 mvvm

```html
<input id="input" />
```

```js
const data = {};
const input = document.getElementById('input');
Object.defineProperty(data, 'text', {
  set(value) {
    input.value = value;
    this.value = value;
  },
});
input.onchange = function(e) {
  data.text = e.target.value;
};
```

### 脏数据检测

当触发了指定事件后会进入脏数据检测，这时会调用 `$digest` 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 `$watch` 函数，然后再次调用 `$digest` 循环直到发现没有变化。循环至少为二次 ，至多为十次。

脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。

### 数据劫持

- `Vue` 内部使用了 `Object.defineProperty()` 来实现双向绑定，通过这个函数可以监听到 `set` 和 `get`的事件

```js
var data = { name: 'yiliang114' };
observe(data);
let name = data.name; // -> get value
data.name = 'yyy'; // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return;
  }
  Object.keys(data).forEach(key => {
    defineReactive(data, key, data[key]);
  });
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value');
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log('change value');
      val = newVal;
    },
  });
}
```

> 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅

```html
<div>
  {{name}}
</div>
```

> 在解析如上模板代码时，遇到 `{{name}}` 就会给属性 `name` 添加发布订阅

```js
// 通过 Dep 解耦
class Dep {
  constructor() {
    this.subs = [];
  }
  addSub(sub) {
    // sub 是 Watcher 实例
    this.subs.push(sub);
  }
  notify() {
    this.subs.forEach(sub => {
      sub.update();
    });
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null;

function update(value) {
  document.querySelector('div').innerText = value;
}

class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this;
    this.cb = cb;
    this.obj = obj;
    this.key = key;
    this.value = obj[key];
    Dep.target = null;
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key];
    // 调用 update 方法更新 Dom
    this.cb(this.value);
  }
}
var data = { name: 'yiliang114' };
observe(data);
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update);
// update Dom innerText
data.name = 'yyy';
```

> 接下来,对 defineReactive 函数进行改造

```js
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val);
  let dp = new Dep();
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value');
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target);
      }
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log('change value');
      val = newVal;
      // 执行 watcher 的 update 方法
      dp.notify();
    },
  });
}
```

> 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加

### 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的

- viewmodel 将 el 指向的模板转换成（一个东西） | string-loader 将引入到模块中 html 变成字符串
- 利用模板引擎将数据渲染上去，如果有指令，对指令进行处理，如@click 就会给指定的按钮绑点击事件
- 渲染之后的那个东西转成字符串放入到页面中

> 结论: 视图产生用户操作，viewmodel 就能马上得知, 因为 viewmodel 将自己作用范围的视图做了编译/rerender 等处理，并且根据指令来操作了 dom
> 所以被重新渲染到页面中的视图已经与 viewmodel 做了某些程度的绑定

[详解](https://www.jianshu.com/p/4cfbeddc5db6)

### 在 Vue 中子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的

子组件为何不可以修改父组件传递的 Prop
单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。
如果修改了，Vue 是如何监控到属性的修改并给出警告的。

```js
if (process.env.NODE_ENV !== 'production') {
  var hyphenatedKey = hyphenate(key);
  if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
    warn('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.', vm);
  }
  defineReactive$$1(props, key, value, function() {
    if (!isRoot && !isUpdatingChildComponent) {
      warn(
        'Avoid mutating a prop directly since the value will be ' +
          'overwritten whenever the parent component re-renders. ' +
          "Instead, use a data or computed property based on the prop's " +
          'value. Prop being mutated: "' +
          key +
          '"',
        vm,
      );
    }
  });
}
```

在 initProps 的时候，在 defineReactive 时通过判断是否在开发环境，如果是开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 中被修改，如果不是，说明此修改来自子组件，触发 warning 提示。

需要特别注意的是，当你从子组件修改的 prop 属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此 key 时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改 object 的属性时不会触发提示，并且会修改父组件数据源的数据。

### Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty

Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；

Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。
[Proxy 与 Object.defineProperty 的对比](https://github.com/LuoShengMen/StudyNotes/issues/455)

### Proxy 相比于 defineProperty 的优势

[Proxy 与 Object.defineProperty 的对比](https://github.com/LuoShengMen/StudyNotes/issues/455)

### vue 双向绑定原理

vue 的数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
直接通过代码来看，首先初始化了一个 vue 实例，并打印出 options 中声明的 data 值：

```js
var vm = new Vue({
  data: {
    obj: {
      a: 1,
    },
  },
  created: function() {
    console.log(this.obj);
  },
});
```

打印的结果如下：

![image.png](https://img.hacpai.com/file/2019/04/image-085db5b8.png)

在 options 的 data 中声明的 a 属性具有 get 和 set 方法，这是 vue 在初始化的时候通过 `Object.defineProperty()` 函数来实现数据劫持的。顾名思义就是在这个属性被 set 和 get 的时候都会触发这里声明的 get 和 set 方法。

##### MVVM

model view 以及 ViewModel. 包括两个方面，数据改变更新视图，视图变化更新数据。

###### data 改变如何更新 view

这里触发的事件流程是这样的：

1. 属性变化
2. 因为 data 中的属性都被 vue 通过 `Object.defineProperty()` 函数添加了 get 和 set 函数，所以其实 data 改变了是会被 Object.defineProperty 监听到的
3. 执行 set 方法来更新视图

###### 实现过程

我们知道数据双向绑定，首先要通过对数据进行劫持监听，所以我们需要设置几个监听器 Observer，用来监听所有的属性。如果属性发生变化了，就需要告诉订阅者 Watcher 看是否需要进行更新视图。 因为订阅者可能有很多个（简单说就是多个视图中都用到了某一个 data 属性），所以我们需要有一个消息订阅器 Dep 来专门收集这些订阅者，并在监听器 Observer 和 订阅者 Watcher 之间进行统一管理。接着我们还需要一个指令解析器 Compile，对每个节点元素进行扫描和解析，将相关指令初始化成为一个订阅者 Watcher， 并替换模板数据或者绑定相对应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

步骤如下：

1. 实现一个监听器 Observer 用来劫持并监听所有属性，如果有变动，就通知订阅者。
2. 实现一个订阅者 Watcher， 可以收到属性变化的通知并执行相应的函数，从而更新视图。
3. 实现一个解释器 Compile 可以扫描和解析每一个节点的相关指令。并根据初始化模板数据以及初始化相应的订阅器。

缺一张流程图。

###### 实现一个 Observer

核心部分就是上面说过的 Object.defineProperty.

### vue 响应式

vue 主要作为 view 部分，主要做了三件事：

- 通过 observer 对数据 data 进行了监听，并且提供订阅某个数据项变化的能力
- 把 template 解析为一段 document fragment 碎片，然后解析其中的指令 directive，得到每个指令所依赖的数据项和其更新的办法，比如`v-text=‘message’`被解析之后依赖的数据项为`this.$data.message` 更新试图的方法为`node.textContent = this.$data.message`
- 通过 watcher 把上述两部分结合起来，把指令中依赖的数据项订阅在 observer 上，这样数据变化时就会触发 observer，进而就能触发数据更新视图的方法，于是就达到了关联的效果。

### 虚拟 dom 的三个步骤

- createElement(): 用 js 对象（虚拟树）描述真实的 dom 对象（真实树）
- diff(oldnode,newNode) 对比新旧两个树的区别
- patch(): 将差异应用到真实树上

### 数据更新的 diff 机制

视图更新效率主要在大列表和深层数据更新这两方面。大多数研究都是对于大列表数据的更新，代码在 directive/repeat.js 中。首先，diff(data,oldvalue)，先比较新旧两个列表的 view model 的数据状态，然后差量更新 dom。第一步，遍历一遍新列表里的每一项，如果该项的 vm 之前就存在，则打一个\_rensed 的标，如果不存在对应的 vm 就创建一个新的。第二部：遍历一遍就得列表的每一项，如果\_rensed 的标没有被打上（其实就是指\_rensed=false）则说明新列表中已经没有它了，就销毁这个 vm。`this.uncacheVm(vm),vm.$destory()`。第三步：整理新的 vm 在试图上的顺序，同时还原之前打上的\_rensed 标，全部赋值为 false。就渲染完成了。

### 组件的 keep-alive

代码在 component.js 中，如果 keep-alive 特性存在，那么组件在重复被创建的时候，会通过缓存机制，快速创建组件，以提升视图更新的性能。

`if(this.keep-alive){var cached = this.cache[id]}`

### 数据监听机制

Object.defineProperty 这个 api，为一个属性设置特殊的 getter 和 setter，然后再 setter 中触发一个函数，就可以达到监听的效果。

### 代码结构

src 里面有 entries 入口，coompiler 编译器，core 里面有 observer cdom instance 之类的代码，server 是服务端渲染相关。

### vue 构造函数

入口： `web-runtime-with-compiler.js` 到`web-runtime.js`,`core/index.js`,`instance/index.js`。`instance/index.js`中声明了 vue 构造方法主要是调用了`vue.prototype._init()`，然后再调用了`initMixin()`,`stateMixin`,`eventsMixin`,`lifeCyleMixin`,`renderMixin`,以 Vue 构造函数为参数调用了 5 个方法，最后导出 vue，主要是在 prototype 上挂载方法和属性。然后又导入 initGlobalAPI 和 isServerRendering 依赖，又将 Vue 作为参数传入给 initGlobalAPI，再挂载上 Vue 版本信息等。initGlobalAPI 的作用是在 Vue 构造函数上挂载静态属性和方法。然后`web-runtime.js`主要是写入并覆盖 Vue.configshuxing ，配置上工具方法，安装 vue 平台的指令和组件，最后声明挂载函数（\$mount）。最后处理的是`web-runtime-with-compiler.js`，做的工作是先缓存一下`mount`函数。然后再 Vue 上挂载 compiler。

总结一下就是 Vue prototype 属性方法挂载是在 instance 中处理的，静态属性方法是在 global-api 中处理的，runtime.js 主要是添加和挂载平台配置的。

### 原理

- 响应式原理
  - 观察者模式
  - computed 原理
  - watch 原理
  - template 编译成 render 原理
  - data 等
- 双向绑定原理
- 指令原理
- 组件间通信的多种方式
- 自定义表单 model
- .sync
- render 函数
- vue 如何实现代码的复用

  - 最基本 utils 函数抽离
  - 公共组件抽离
    - 上述两个都可以通过抽 npm 包或者 submodule 的形式去取得最大限度的复用
  - mixins 组件间的公共 options 抽离
  - extend 组件继承、函数重载等
  - template 部分，插槽

- vuex 的使用场景
- 指令原理

  - v-input
  - v-clickout

- diff 原理
- for 循环为什么要有一个 key 值，以及为什么说不能使用 index 作为 key

### Object.defineProperty

对应专业俗语分别是：

- 数据劫持 / 数据代理
- 依赖收集
- 发布订阅模式

能够将一些对象的属性转为 getter 和 setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

Vue 无法检测到对象属性的添加或删除。Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value)方法向嵌套对象添加响应式属性。

watch 属性，都是一个 new Watcher 实例。

观察一个对象，如果是数组的话，需要往 "push","pop","shift","unshift","splice","sort","reverse" 这些原生数组函数改写，主要是需要在这些函数的内部都调用了依赖的更新通知，这样就会触发视图的更新了。如果是新增属性之类的操作，那就观察一下新增的属性。

进行观察的时候执行 defineReactive 函数，在每一次执行的时候，都是创建一个 Dep 依赖实例， get 属性中 如果存在 Dep.target （也就是响应函数的 watcher 实例）那就执行依赖收集，这个 Dep.target 的收集是在 new Watcher 的时候，new Watcher 第二个参数是一个函数表达值，会被记录下来，表明这是当前响应式的反馈。每一个 watcher 里面有一个依赖数组，dep.depend() 依赖收集就是往 watcher 里依赖项。当然如果添加的属性是一个对象或者数组的话，继续添加依赖，在 watcher 表达式执行完毕之前，会清理掉 Dep.target ，防止会收集到错误的依赖。 然后在属性改变的时候，就会触发 set ，set 中基本上是观察新添加的属性之外最重要的就是 dep.notify 通知操作了。这个操作就是循环收集的所有 watcher ，执行 watcher 的 update 函数， update 函数如果设置了同步执行的话，就是直接重新执行一次表达式； 但是一般情况下，会执行 queueWatcher 将当前的 watcher 推入一个事件缓冲队列 queue 中， 这是通过 nextTick 实现的， 会一次更新队列中的所有 watcher 的表达式。这样就达到了响应式的目的。(队列执行的时候，会根据 watcher.id 进行去重)

### 组件 data 为什么返回函数

组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data。如果单纯的写成对象形式，就使得所有组件实例共用了一份 data，造成了数据污染。

### 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的

VM 主要做了两件微小的事情：

- **从 M 到 V 的映射（Data Binding）**，这样可以大量节省你人肉来 update View 的代码
- **从 V 到 M 的事件监听（DOM Listeners）**，这样你的 Model 会随着 View 触发事件而改变

**1、M 到 V 实现**

做到这件事的第一步是形成类似于：

```js
// template
var tpl = '<p>{{ text }}</p>';
// data
var data = {
  text: 'This is some text',
};
// magic process
template(tpl, data); // '<p>This is some text</p>'
```

中间的 magic process 是模板引擎所做的事情，已经有非常多种模板引擎可供选择

- [JavaScript templates](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/JavaScript_templates)

当然你比较喜欢造轮子的话也可以自己实现一个

- [JavaScript template engine in just 20 lines](https://link.zhihu.com/?target=http%3A//krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line)
- [一个 JavaScript 模板引擎的实现](https://link.zhihu.com/?target=http%3A//kyleslight.net/article/27)

无论是 Angular 的 \$scope，React 的 state 还是 Vue 的 data 都提供了一个较为核心的 model 对象用来保存模型的状态；它们的模板引擎稍有差别，不过大体思路相似；拿到渲染后的 string 接下来做什么不言而喻了（中间还有很多处理，例如利用 model 的 diff 来最小量更新 view ）。

但是仅仅是这样并不够，我们需要知道什么时候来更新 view（ 即 render ），一般来说主要的 VM 做了以下几种选择：

- VM 实例初始化时
- model 动态修改时

其中初始化拿到 model 对象然后 render 没什么好讲的；model 被修改的时候如何监听属性的改变是一个问题，目前有以下几种思路：

- 借助于 Object 的 observe 方法
- 自己在 set，以及数组的常用操作里触发 change 事件
- 手动 setState()，然后在里面触发 change 事件

知道了触发 render 的时机以及如何 render，一个简单的 M 到 V 映射就实现了。

**2、V 到 M 实现**

从 V 到 M 主要由两类（ 虽然本质上都是监听 DOM ）构成，一类是用户自定义的 listener， 一类是 VM 自动处理的含有 value 属性元素的 listener

第一类类似于你在 Vue 里用 v-on 时绑定的那样，VM 在实例化得时候可以将所有用户自定义的 listener 一次性代理到根元素上，这些 listener 可以访问到你的 model 对象，这样你就可以在 listener 中改变 model

第二类类似于对含有 v-model 与 value 元素的自动处理，我们期望的是例如在一个输入框内

```js
<input type="text" v-model="message" />
```

输入值，那么我与之对应的 model 属性 message 也会随之改变，相当于 VM 做了一个默认的 listener，它会监听这些元素的改变然后自动改变 model，具体如何实现相信你也明白了
