---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 取消冒泡事件

```html
<!-- 只需将 click 改成 click.stop -->
<p @click.stop="getEventTar($event)">Test</p>
```

### 阻止默认事件

```html
<!-- 只需将click改成click.prevent -->
<p @click.prevent="getEventTar($event)">Test</p>
```

### 处理 keyup.enter 和 blur 事件冲突的问题

https://blog.csdn.net/userkang/article/details/82755889

### emit

```js
this.$emit('input', val);
```

### vue 的事件更新机制

### 解决 vue 的 enter 和 blur 触发两次的问题

如果没有绑定 blur 事件也可以，会触发默认的 input blur 事件即失去焦点

```html
<input @blur="handleEditConfirm(c.type_id, c.description)" @keyup.enter="$event.target.blur" />
```

### vue @click.native 与 @click 意思就是当你给一个 vue 组件绑定事件时候，要加上 native！如果是普通的 html 元素！就不需要

### @click @click.native @on-click 好像是 qcvue 的事件不是 vue 的。 事件的修饰符是符合进行处理的。

### 解释 vue input 的 input change 事件， keydown keyup focus bulr 事件等等

### vue 是如何实现绑定事件的 ?

### vue 的自定义事件

https://blog.csdn.net/wangchaohpu/article/details/84333362

### vue 的 `$event` 与普通的点击事件， 按钮事件有什么不同？

### vue 的 @ 语法糖 @ 会默认为是 on 开头的事件。。 比如 on-change on-enter 等

### event bus

https://juejin.im/post/5ac2fb886fb9a028b86e328c

### Vue 的数据为什么频繁变化但只会更新一次

Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。
另外，关于 waiting 变量，这是很重要的一个标志位，它保证 flushSchedulerQueue 回调（$nextTick中执行）允许被置入callbacks一次。
因为Vue的事件机制是通过事件队列来调度执行，会等主进程执行空闲后进行调度，所以先会去等待所有的同步代码执行完成之后再去一次更新。这样的性能优势很明显，比如：
现在有这样的一种情况，mounted的时候test的值会被循环执行++1000次。 每次++时，都会根据响应式触发setter->Dep->Watcher->update->run。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个queue队列，在下一个tick（或者是当前tick的微任务阶段）统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick（或者是当前tick的微任务阶段）的时候调用，大大优化了性能。
执行顺序update -> queueWatcher -> 维护观察者队列（重复id的Watcher处理） -> waiting标志位处理（保证需要更新DOM或者Watcher视图更新的方法flushSchedulerQueue只会被推入异步执行的$nextTick 回调数组一次） -> 处理\$nextTick（在为微任务或者宏任务中异步更新 DOM）->

Vue 是异步更新 Dom 的，Dom 的更新放在下一个宏任务或者当前宏任务的末尾（微任务）中进行执行

由于 VUE 的数据驱动视图更新是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。在同一事件循环中的数据变化后，DOM 完成更新，立即执行 nextTick(callback)内的回调。
vue 和 react 一样，对 dom 的修改都是异步的。它会在队列里记录你对 dom 的操作并进行 diff 操作，后一个操作会覆盖前一个，然后更新 dom。

### 异步更新队列

vue 更新 dom 时是异步执行的。数据变化、更新是在主线程中同步执行的；在侦听到数据变化时，watcher 将数据变更存储到异步队列中，当本次数据变化，即主线成任务执行完毕，异步队列中的任务才会被执行（已去重）。

宏事件

- setImmediate
- MessageChannel
- setTimeout
  微事件
- promise

顺序是， promise => setImmediate => MessageChannel => setTimeout

#### 观察对象和观察数组的区别

数组的 api 需要去重写。所以数组一般通过扩展重新赋值，或者使用这些覆盖的 api 变化的时候才可以被更新，否则的话不更新，比如通过下标直接进行更改。

### vue 的事件更新事件

有一个一个的事件队列推入，多次推入，会多次更新。 如果在一个作用域中，同时修改一个值，这样会被合成一个更新，推入事件队列中。

### 事件冒泡

原生的事件可以冒泡，比如 click 事件，如果不主动进行 stop 的话，就会一直往上传。但是貌似自定义事件，并不会冒泡。自定义事件的冒泡和广播的问题，很早就被官方废弃了，主要是因为事件传递的规则让人比较难以琢磨，多层级之间传数据的问题，可以使用 vuex 很好的解决。 父子组件传参的话，可以使用 emit 很好解决。 但是实际上 element 中又实现了已经废弃的 dispatch 和 broadcast api ， 这在组件封装的时候，能够很好地处理数据流。

https://www.cnblogs.com/xxcanghai/p/Vue-kuang-jiaElement-de-shi-jian-chuan-dibroadcast.html
https://www.cnblogs.com/xxcanghai/p/Vue-kuang-jiaElement-de-shi-jian-chuan-dibroadcast.html
