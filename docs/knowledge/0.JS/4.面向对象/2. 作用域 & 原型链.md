---
title: 作用域 & 原型链
date: '2020-10-26'
draft: true
---

## 作用域 & 作用域链

**作用域**

作用域，就是变量或者是函数能作用的范围。JS 没有块级作用域，只有函数和全局作用域。

**作用域链**

当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，找不到就报错，这样由多个执行上下文的变量对象构成的链表就叫做作用域链。简单说，作用域链就是一层一层向父层寻找没有定义的变量。

作用域链的终点是全局对象 window

## 原型 & 原型链

每个 JS 对象都有 `__proto__` 属性，这个属性指向了原型。并且原型也是一个对象。

原型的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型，但是并不是所有函数都具有这个属性，`Function.prototype.bind()` 就没有这个属性。

原型链就是多个对象通过 `__proto__` 的方式连接了起来。

总结起来就是以下几点：

- `Object` 是所有对象的父级，所有对象都可以通过 `__proto__` 找到它
- `Function` 是所有函数的父级，所有函数都可以通过 `__proto__` 找到它
- 函数的 `prototype` 是一个对象
- 对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链

并不是所有函数都有 `prototype` 属性。TODO: 好像只有构造函数有 ？

构造函数默认自带有一个 prototype 属性，这个 prototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数。

同时每一个实例都有一个 `__proto__` 属性（隐式原型）指向这个 prototype 对象。

- JavaScript 的所有对象中都包含了一个 `__proto__` 内部属性，这个属性所对应的就是该对象的原型
- JavaScript 的函数对象，除了原型 `__proto__` 之外，还预置了 prototype 属性
- 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 `__proto__`。

关系：`instance.constructor.prototype = instance.__proto__`

1.  原型对象也是普通的对象，是对象一个自带隐式的 `__proto__` 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
2.  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链

如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念

每个函数都有 `prototype` 属性，除了 `Function.prototype.bind()`，该属性指向原型。

每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 `[[prototype]]`，但是 `[[prototype]]` 是内部属性，我们并不能访问到，所以使用 `_proto_` 来访问。

对象可以通过 `__proto__` 来寻找不属于该对象的属性，`__proto__` 将对象连接起来组成了原型链。原型链的终点是 Object.prototype。

`Object.prototype.__proto__ === null`

### 原型链

几乎所有的 js 对象都是位于原型链顶端的 Object 实例

- 只有构造函数才有 prototype 属性
- 构造函数的 prototype，默认情况下就是一个 new Object()还额外添加了一个 constructor 属性
- 除了 Object.prototype 这个对象，其他所有的对象都会有**proto**属性（函数也是对象）

任何一个实例对象通过原型链可以找到它对应的原型对象，原型对象上面的实例和方法都是实例所共享的。

一个对象在查找以一个方法或属性时，他会先在自己的对象上去找，找不到时，他会沿着原型链依次向上查找。

注意： 函数才有 prototype，实例对象只有有**proto**， 而函数有的**proto**是因为函数是 Function 的实例对象

**原型链的基本原理**：任何一个**实例**，通过原型链，找到它上面的**原型**，该原型对象中的方法和属性，可以被所有的原型实例共享。

> `Object`是原型链的顶端。

- 原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：

**原型链的关键**：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。

- 所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象。
- 所有的函数（除了箭头函数），都有一个 `prototype` 属性，属性值也是一个普通的对象。
- 所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的 `prototype` 属性值。

**注**：ES6 的箭头函数没有 `prototype` 属性，但是有`__proto__`属性。

### 原型、构造函数、实例，以及原型链

![](http://img.smyhvae.com/20180306_1540.png)

> PS：任何一个函数，如果在前面加了`new`，那就是构造函数。

![](http://img.smyhvae.com/20180306_2107.png)

1. 构造函数通过 `new` 生成实例
2. 构造函数也是函数，构造函数的`prototype`指向原型。（所有的函数有`prototype`属性，但实例没有 `prototype`属性）
3. 原型对象中有 `constructor`，指向该原型的构造函数。

> 上面的三行，代码演示：

```js
var Foo = function(name) {
  this.name = name;
};

var fn = new Foo('smyhvae');
```

> 上面的代码中，`Foo.prototype.constructor === Foo`的结果是`true`：

![](http://img.smyhvae.com/20180306_2120.png)

4. 实例的`__proto__`指向原型。也就是说，`Foo.__proto__ === M.prototype`。

> 声明：所有的**引用类型**（数组、对象、函数）都有`__proto__`这个属性。

`Foo.__proto__ === Function.prototype`的结果为 true，说明`Foo`这个普通的函数，是`Function`构造函数的一个实例。

### 要点

- js 中的函数也是对象 (即 (function(){}) instanceof Object == true)
- 所有的对象都有自己的构造函数
- 所有的函数都能当作构造函数, 每个函数都有一个 prototype 属性
- 每个对象都有一个隐藏的 o.**proto**属性指内向它的构造函数的 prototype
- 于是所有的函数的原型都是 Function.prototype (即 (function(){}).**proto** === Function.prototype)
- 访问一个对象的属性时, 如果从这个对象里找不到, 就从 obj.**proto**里找, 再找不到就继续从 obj.**proto**.**proto**里找, 最终会容到达 Object.prototype

### 判断对象是哪个类的直接实例

使用`对象.constructor`直接可判断

### Function.proto(getPrototypeOf)是什么？

```js
Function.__proto__ == Object.prototype; //false
Function.__proto__ == Function.prototype; //true
```

## instanceof

### 分析一个问题

**问题：**已知 A 继承了 B，B 继承了 C。怎么判断 a 是由 A**直接生成**的实例，还是 B 直接生成的实例呢？还是 C 直接生成的实例呢？

> 分析：这就要用到原型的`constructor`属性了。

- `foo.__proto__.constructor === M`的结果为`true`，但是 `foo.__proto__.constructor === Object`的结果为`false`。
- 所以，用 `constructor`判断就比用 `instanceof`判断，更为严谨。

### `instanceof`的原理

- `instanceof`的**作用**：用于判断**实例**属于哪个**构造函数**。
- `instanceof`的**原理**：判断实例对象的`__proto__`属性，和构造函数的`prototype`属性，是否为同一个引用（是否指向同一个地址）。

> - **注意 1**：虽然说，实例是由构造函数 new 出来的，但是实例的`__proto__`属性引用的是构造函数的`prototype`。也就是说，实例的`__proto__`属性与构造函数本身无关。
> - **注意 2**：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找`__proto__`属性。这条链上如果能找到， instanceof 的返回结果也是 true。

比如说：

- `foo instance of Foo`的结果为 true，因为`foo.__proto__ === M.prototype`为`true`。
- **`foo instance of Objecet`的结果也为 true**，为`Foo.prototype.__proto__ === Object.prototype`为`true`。

> 但我们不能轻易的说：`foo` 一定是 由`Object`创建的实例`。这句话是错误的。我们来看下一个问题就明白了。

### instanceof 的原理

instanceof 的原理是什么？

`instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

我们也可以试着实现一下 `instanceof`

```js
function myInstanceof(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null || left === undefined) return false;
    if (prototype === left) return true;
    left = left.__proto__;
  }
}
```

以下是对实现的分析：

- 首先获取类型的原型
- 然后获得对象的原型
- 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`

### instanceof

`instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

我们也可以试着实现一下 `instanceof`

```js
function instanceof(left, right) {
  // 获得类型的原型
  let prototype = right.prototype;
  // 获得对象的原型
  left = left.__proto__;
  // 判断对象的类型是否等于类型的原型
  while (true) {
    if (left === null) return false;
    if (prototype === left) return true;
    left = left.__proto__;
  }
}
```

### instanceof 原理

判断实例对象的**proto**属性与构造函数的 prototype 是不是用一个引用。如果不是，他会沿着对象的**proto**向上查找的，直到顶端 Object。

### instanceof 能正确判断对象的原理是什么？

判断一个对象与构造函数是否在一个原型链上

```js
const Person = function() {};
const p1 = new Person();
p1 instanceof Person; // true

var str = 'hello world';
str instanceof String; // false

var str1 = new String('hello world');
str1 instanceof String; // true
```

### 如何判断一个对象是否属于某个类

```js
if (a instanceof Person) {
  alert('yes');
}
```

### typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？

typeof 对于原始类型来说，除了 null 都可以显示正确的类型

```js
typeof 1; // 'number'
typeof '1'; // 'string'
typeof undefined; // 'undefined'
typeof true; // 'boolean'
typeof Symbol(); // 'symbol'
```

typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型

```js
typeof []; // 'object'
typeof {}; // 'object'
typeof console.log; // 'function'
```

如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 instanceof。

```js
const Person = function() {};
const p1 = new Person();
p1 instanceof Person; // true

var str = 'hello world';
str instanceof String; // false

var str1 = new String('hello world');
str1 instanceof String; // true
```

对于原始类型来说，你想直接通过 instanceof 来判断类型是不行的，当然我们还是有办法让 instanceof 判断原始类型的

```js
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string';
  }
}
console.log('hello world' instanceof PrimitiveString); // true
```

你可能不知道 Symbol.hasInstance 是什么东西，其实就是一个能让我们自定义 instanceof 行为的东西，以上代码等同于 typeof 'hello world' === 'string'，所以结果自然是 true 了。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。

#### instanceof

instanceof 可以准确的判断复杂数据类型，但是不能正确判断基本数据类型

```js
console.log(12 instanceof Number); // false
console.log('22' instanceof String); // false
console.log([] instanceof Array); // true
console.log({ a: 1 } instanceof Object); // true
console.log(true instanceof Boolean); // false
console.log(json instanceof Object); // true
function a() {}
console.log(new Date() instanceof Date); //true
console.log(a instanceof Function); // true
console.log(reg instanceof RegExp); //true
console.log(error instanceof Error); // true
console.log(null instanceof Object); // false
console.log(undefined instanceof Object); // false
```

#### instanceof

用于实例和构造函数的对应。例如判断一个变量是否是数组，使用 typeof 无法判断，但可以使用 [1,2] instanceof Array 来判断，它的构造函数就是 Array. 同理：

```js
function Foo(name) {
  this.name = name;
}
var foo = new Foo('bar');
console.log(foo instanceof Foo); // true
```

## 变量提升

- 在 JavaScript 中，函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部
- 声明语句中的赋值部分并不会被提升，只有名称被提升
- 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明
- 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数
