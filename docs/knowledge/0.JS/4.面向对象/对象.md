---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### Object.create(null) 与 普通的 {} 的区别？

为什么 vue 有些地方需要使用前者，有些地方不需要？

#### Object.create(null) 原理

应该是将原型链最末端的值替换为 null, 普通声明的对象或者函数，原型链的末端是 Object, 有可能原型链上被挂载了其他的属性和函数，这是不想要的。所以这么操作应该是为了排除影响。

### in 和 hasOwnProperty 区别

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果在实例中添加一个与原型中属性同名的属性，则该属性会屏蔽原型中的那个属性。添加的同名属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为`null`，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。

```js
function Person() {}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true

person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true

delete person1.name;
console.log(person1.name); // "Nicholas"
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true
```

`in`操作符只要通过对象能访问到属性就返回`true`。`hasOwnProperty()`只在属性存在于实例中时才返回`true`。

使用`delete`操作符则可以完全删除实例属性，从而让我们能巩固重新访问原型中的属性。

```js
function Person() {
  this.name = 'koewas';
}

// Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
delete person1.name;
console.log(person1.name); // undefined
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // false
```

上面这段代码的 `name` 为实例属性，不属于原型。但却不是私有属性，能被实例访问。

### hasOwnProperty

是不是对象自身下面的属性

```js
var arr = [];
arr.num = 10;
Array.prototype.num2 = 20; //这样写表示所有的数组对象都有了 num2 这个属性

alert(arr.hasOwnProperty('num')); //true 说明num这个属性只属于arr的,是arr独有的
alert(arr.hasOwnProperty('num2')); //false 因为所有的数组对象都拥有了num2,而不仅仅是arr,所以是false
```

### 对象是否存在该属性

```js
'name' in Person;
```

in 缺陷---属性是继承来的时候,仍然返回 true
最好使用 hasOwnProperty()

```js
Person.hasOwnProperty('name');
```

### for in 与 hasOwnProperty 结合使用

与 in 操作符相比，for in 在循环对象的属性时也会遍历原型链，for in 不会读取不可枚举属性，如数组的 length 属性。

```js
for (var i in foo) {
  if (foo.hasOwnProperty(i)) {
    console.log(i);
  }
}
```

推荐在 for in 时，总是使用 hasOwnProperty 进行判断，没人可以保证运行的代码环境是否被污染过。

### 分析下列输出结果

```js
// example 1
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 2
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 3
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

对象键名的转换：

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。
  example 1，c 的键名转换成字符串将 b 键覆盖输出 c
  example 2，任何一个 Symbol 类型的值都是不相等的，所以 b 键和 c 键都不会被覆盖，输出 b
  example 3，对象都会被转换为字符串 [object Object]，因此 c 键会覆盖 b 键，输出 c

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

### Object.defineProperty()

- 对象属性描述符
- configurable
- enumerable
- 数据描述符
  - value
  - writable
- 存取描述符
  - get
  - set

Object.defineProperty(obj, prop, descriptor)用来给对象定义属性,有 value,writable,configurable,enumerable,set/get 等.defineProperty 用于检查某一属性是不是存在于对象本身，继承来的父亲的属性不算．propertyIsEnumerable 用来检测某一属性是否可遍历，也就是能不能用 for..in 循环来取到

### 比较操作符 ===、== 的区别？

- == 相等运算符，比较时会自动进行数据类型转换
- === 严格相等运算符，比较时不进行隐式类型转换

```
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

### 如何防止在 JavaScript 中修改对象 ?

```js
var employee = {
  name: 'yiliang',
};

//Freeze the object
Object.freeze(employee);

// Seal the object
Object.seal(employee);

console.log(Object.isExtensible(employee)); // false
console.log(Object.isSealed(employee)); // true
console.log(Object.isFrozen(employee)); // true

employee.name = 'xyz'; // fails silently unless in strict mode
employee.age = 30; // fails silently unless in strict mode
delete employee.name; // fails silently unless it's in strict mode
```

#### Object.freeze 和 Object.seal 的区别

Object.preventExtension：禁止对象添加新属性并保留已有属性;
Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;
Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。

### 合并两个对象

```js
const merge = (toObj, fromObj) => Object.assign(toObj, fromObj);
```

```js
function merge(toObj, fromObj) {
  // Make sure both of the parameter is an object
  if (typeof toObj === 'object' && typeof fromObj === 'object') {
    for (var pro in fromObj) {
      // Assign only own properties not inherited properties
      if (fromObj.hasOwnProperty(pro)) {
        // Assign property and value
        toObj[pro] = fromObj[pro];
      }
    }
  } else {
    throw 'Merge function can apply only on object';
  }
}
```

### name 的值是多少？

```js
function A(name) {
  this.name = name || 'Tom';
  this.msg = "use 'this.' set in function";
}

function B() {}
B.prototype = A;

var b = new B();

console.log(b.name);
console.log(b.msg);
// A
// undefined
```

#### 分析

`b.name`返回 `A`，是因为`b`上面没有`name`属性，他就会沿着原型链向上查找，然而 `b.__proto__` 为`函数A`，每一个函数都有一个属性为 name，其值是函数的名字。

```js
function abc() {
  /* 这是一个名为'abc'的函数 */
}
abc.name; // -> 'abc'
```

`b.msg` 为什么是`undefined`哪？ 因为`b.__proto__` 是 `函数A`，那怎么修改才能拿到`msg`哪？

```js
B.prototype = new A();
```

修改后的输出：

```
Tom
VM731:12 use 'this.' set in function
```

### 其他

```js
var sinaNews = {
  name: 'sinNewsName',
  test: function() {
    console.log('this.name:', this.name, '//');
  },
};
setTimeout(sinaNews.test, 500); //
```

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // ?
foo(); // ?
```

```js
let arr = [1, 2, 3, 4];
let it1 = arr[Symbol.iterator](); // 遍历器接口
let res = it1.next();
console.log(res);
```

结果是：

```js
{
  done: false,
  value: 1
}
```

### 赋值

#### 函数名与变量名同名

```js
var foo = 1;
function bar() {
  foo = 10;
  return;
  function foo() {}
}
bar();
alert(foo);
```

- 1
- 10
- Function
- undefined
- Error

答案：1，function 的定义会提前到当前作用域之前，所以等同于：

```js
var foo = 1;
function bar() {
  function foo() {}
  foo = 10;
  return;
}
bar();
alert(foo);
```

所以，在 foo=10 的时候，foo 是有定义的，属于局部变量，影响不到外层的 foo。

```js
function bar() {
  return foo;
  foo = 10;
  function foo() {}
  var foo = 11;
}
alert(typeof bar());
```

- number
- function
- undefined
- Error

答案：function，与上题类似，等同于：

```js
function bar() {
  function foo() {}
  return foo;
  foo = 10;
  var foo = 11;
}
alert(typeof bar());
```

在 return 之后声明和赋值的 foo 都无效，所以返回了 function。

补充，这个解答有问题：

> @尤里卡 Eureka：JS 中 function 声明和 var 声明都会被提前，最终得到结果为 function，是因为*名称解析顺序-Name Resolution Order*(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~

```js
function SINA() {
  return 1;
}
var SINA;
console.log(typeof SINA); // function
```

#### 数组长度

```js
var arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr.foo = 'c';
alert(arr.length);
```

答案：2，数组的原型是 Object，所以可以像其他类型一样附加属性，不影响其固有性质。

#### arguments

```js
function foo(a) {
  arguments[0] = 2;
  alert(a);
}
foo(1);
```

答案：2，实参可以直接从 arguments 数组中修改。

### 如何判断一个对象是空的？

- 第一种： `const isEmptyObject = obj => Object.getOwnPropertyNames(obj).length === 0`
- 第二种： `Object.keys(obj).length == 0`
