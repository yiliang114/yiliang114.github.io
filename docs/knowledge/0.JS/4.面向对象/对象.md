---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 语法糖

`var a = {}` 其实是 `var a = new Object()` 的语法糖
`var a = []` 其实是 `var a = new Array()` 的语法糖
`function Foo(){}` 其实是 `var Foo = new Function(){}` 的语法糖

使用 instanceof 判断一个函数是否是一个变量的构造函数

### new String

JS 与其他面向对象语言一样有相应的构造器，比如说，可以通过以下两种方式来创建一个字符串：

```js
var a = 'woot';
var b = new String('woot');
a + b; // => 'wootwoot'
```

然而要是对这两个变量使用 typeof 和 instanceof 操作符，事情就变得有意思了：

```js
typeof a; // string
typeof b; // object
a instanceof String; // false
b instanceof String; // true
```

而事实上，这两个变量值绝对都是货真价实的字符串：

```js
a.substr == b.substr;
```

而且使用 == 操作符判定两者相等，而使用 === 操作符判定时并不相同：

```js
a == b; // true
a === b; // false
```

另外值得注意的是， typeof 不会把 null 识别为类型 null：

```js
typeof null == 'object'; // 很不幸，结果为 true
```

数组也不例外，就算是通过 [] 这种方式定义数组也是如此：

```js
typeof [] == 'object'; // 很不幸，结果为 true
```

#### Object.create(null) 原理

为什么 vue 有些地方需要使用前者，有些地方不需要？

应该是将原型链最末端的值替换为 null, 普通声明的对象或者函数，原型链的末端是 Object, 有可能原型链上被挂载了其他的属性和函数，这是不想要的。所以这么操作应该是为了排除影响。

### 分析下列输出结果

```js
// example 1
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 2
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 3
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

对象键名的转换：

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。
  example 1，c 的键名转换成字符串将 b 键覆盖输出 c
  example 2，任何一个 Symbol 类型的值都是不相等的，所以 b 键和 c 键都不会被覆盖，输出 b
  example 3，对象都会被转换为字符串 [object Object]，因此 c 键会覆盖 b 键，输出 c

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

### 比较操作符 ===、== 的区别？

- == 相等运算符，比较时会自动进行数据类型转换
- === 严格相等运算符，比较时不进行隐式类型转换

```
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

### 如何防止在 JavaScript 中修改对象 ?

```js
var employee = {
  name: 'yiliang',
};

//Freeze the object
Object.freeze(employee);

// Seal the object
Object.seal(employee);

console.log(Object.isExtensible(employee)); // false
console.log(Object.isSealed(employee)); // true
console.log(Object.isFrozen(employee)); // true

employee.name = 'xyz'; // fails silently unless in strict mode
employee.age = 30; // fails silently unless in strict mode
delete employee.name; // fails silently unless it's in strict mode
```

#### Object.freeze 和 Object.seal 的区别

Object.preventExtension：禁止对象添加新属性并保留已有属性;
Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;
Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。

### 合并两个对象

```js
const merge = (toObj, fromObj) => Object.assign(toObj, fromObj);
```

```js
function merge(toObj, fromObj) {
  // Make sure both of the parameter is an object
  if (typeof toObj === 'object' && typeof fromObj === 'object') {
    for (var pro in fromObj) {
      // Assign only own properties not inherited properties
      if (fromObj.hasOwnProperty(pro)) {
        // Assign property and value
        toObj[pro] = fromObj[pro];
      }
    }
  } else {
    throw 'Merge function can apply only on object';
  }
}
```

### name 的值是多少？

```js
function A(name) {
  this.name = name || 'Tom';
  this.msg = "use 'this.' set in function";
}

function B() {}
B.prototype = A;

var b = new B();

console.log(b.name);
console.log(b.msg);
// A
// undefined
```

#### 分析

`b.name`返回 `A`，是因为`b`上面没有`name`属性，他就会沿着原型链向上查找，然而 `b.__proto__` 为`函数A`，每一个函数都有一个属性为 name，其值是函数的名字。

```js
function abc() {
  /* 这是一个名为'abc'的函数 */
}
abc.name; // -> 'abc'
```

`b.msg` 为什么是`undefined`哪？ 因为`b.__proto__` 是 `函数A`，那怎么修改才能拿到`msg`哪？

```js
B.prototype = new A();
```

修改后的输出：

```
Tom
VM731:12 use 'this.' set in function
```

### 赋值

#### 函数名与变量名同名

```js
var foo = 1;
function bar() {
  foo = 10;
  return;
  function foo() {}
}
bar();
alert(foo);
```

- 1
- 10
- Function
- undefined
- Error

答案：1，function 的定义会提前到当前作用域之前，所以等同于：

```js
var foo = 1;
function bar() {
  function foo() {}
  foo = 10;
  return;
}
bar();
alert(foo);
```

所以，在 foo=10 的时候，foo 是有定义的，属于局部变量，影响不到外层的 foo。

```js
function bar() {
  return foo;
  foo = 10;
  function foo() {}
  var foo = 11;
}
alert(typeof bar());
```

- number
- function
- undefined
- Error

答案：function，与上题类似，等同于：

```js
function bar() {
  function foo() {}
  return foo;
  foo = 10;
  var foo = 11;
}
alert(typeof bar());
```

在 return 之后声明和赋值的 foo 都无效，所以返回了 function。

补充，这个解答有问题：

> @尤里卡 Eureka：JS 中 function 声明和 var 声明都会被提前，最终得到结果为 function，是因为*名称解析顺序-Name Resolution Order*(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~

```js
function SINA() {
  return 1;
}
var SINA;
console.log(typeof SINA); // function
```

#### 数组长度

```js
var arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr.foo = 'c';
alert(arr.length);
```

答案：2，数组的原型是 Object，所以可以像其他类型一样附加属性，不影响其固有性质。

#### arguments

```js
function foo(a) {
  arguments[0] = 2;
  alert(a);
}
foo(1);
```

答案：2，实参可以直接从 arguments 数组中修改。

### 如何判断一个对象是空的？

- 第一种： `const isEmptyObject = obj => Object.getOwnPropertyNames(obj).length === 0`
- 第二种： `Object.keys(obj).length == 0`

### 其他

```js
var sinaNews = {
  name: 'sinNewsName',
  test: function() {
    console.log('this.name:', this.name, '//');
  },
};
setTimeout(sinaNews.test, 500); //
```

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // ?
foo(); // ?
```

```js
let arr = [1, 2, 3, 4];
let it1 = arr[Symbol.iterator](); // 遍历器接口
let res = it1.next();
console.log(res);
```

结果是：

```js
{
  done: false,
  value: 1
}
```

### Object.assign() 的模拟实现

1. 判断原生 Object 是否支持该函数，如果不存在的话创建一个函数 assign，并使用 Object.defineProperty 将该函数绑定到 Object 上。
2. 判断参数是否正确（目标对象不能为空，我们可以直接设置{}传递进去,但必须设置值）。
3. 使用 Object() 转成对象，并保存为 to，最后返回这个对象 to。
4. 使用 for..in 循环遍历出所有可枚举的自有属性。并复制给新的目标对象（使用 hasOwnProperty 获取自有属性，即非原型链上的属性）。

实现代码如下，这里为了验证方便，使用 assign2 代替 assign。注意此模拟实现不支持 symbol 属性，因为 ES5 中根本没有 symbol 。

```js
if (typeof Object.assign2 != 'function') {
  // Attention 1
  Object.defineProperty(Object, 'assign2', {
    value: function(target) {
      'use strict';
      if (target == null) {
        // Attention 2
        throw new TypeError('Cannot convert undefined or null to object');
      }

      // Attention 3
      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) {
          // Attention 2
          // Attention 4
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true,
  });
}
```
