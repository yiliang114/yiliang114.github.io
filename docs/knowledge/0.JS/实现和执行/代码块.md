---
title: 代码题 1
date: '2020-11-02'
draft: true
---

### class 构造函数执行的顺序

```js
class B {
  b = console.log('1');
  constructor() {
    console.log('2');
  }
}

class A extends B {
  a = console.log('3');
  constructor() {
    super();
    console.log('4');
  }
}

new A();
new B();

// 也就是说 constructor 前面的属性赋值比 constructor 构造函数执行的时间早
// 1234
```

### `foo.x`的值是什么？

```js
var foo = { n: 1 };
var bar = foo;
foo.x = foo = { n: 2 };
// foo.x = (foo = {n:2}); =>  {n:1}.x = ( {n:1} = {n:2} );  R.H.S. foo={n:2}
// console.log(foo.x); //Result undefined
// console.log(foo); //Result {n:2}
// console.log(bar); //Result {n:1, x: {n:2}}
// Result = undefined
```

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x);
console.log(b.x);
```

输出：

```js
a.x; //  undefined
b.x; //  {n: 2}
```

运算赋优先级问题，此前 a 和 b 都是指向{n:1}，a.x 执行之后 x 值为 undefined，a 和 b 指向{n:1,x:undefined},接下来执行赋值运算，a 指向变更成了{n:2},此时都 a.x= a,实际上是 b.x=a,b 指向了{n:1,x:{n: 2}},此时 a.x 输出 undefined,b.x 输出{n:2}

### 获取对象深度

空对象当作一级，属性值为数组则不向下查找

```js
// 递归，深度优先遍历
function getObjectDeep(obj, arr = []) {
  var count = 0;
  obj && arr.indexOf(obj) === -1 && arr.push(obj);
  if (obj && !Array.isArray(obj) && typeof obj === 'object') {
    count = 1;
    var result = Object.keys(obj).map(function(item) {
      if (typeof obj[item] === 'object' && arr.indexOf(obj[item]) === -1) {
        // 防止循环引用
        arr.push(obj[item]);
        return 1 + getObjectDeep(obj[item], arr);
      } else {
        return 1;
      }
    });
    for (var i = 0; i < result.length; i++) {
      if (count < result[i]) {
        count = result[i];
      }
    }
  }
  return count;
}

// 非递归，宽度优先遍历
function getObjectDeep(obj) {
  var count = 0;
  var queueObj = [obj];
  var arrs = [obj]; // 防止循环引用
  var last = obj; // 当前层级最后一个

  var checkObj = function(param) {
    return param !== null && param !== undefined && !Array.isArray(param) && typeof param === 'object';
  };

  if (checkObj(obj)) {
    while (queueObj.length) {
      var currentObj = queueObj.shift();
      Object.keys(currentObj).forEach(function(item) {
        if (checkObj(currentObj[item]) && arrs.indexOf(currentObj[item]) === -1) {
          arrs.push(currentObj[item]);
          queueObj.push(currentObj[item]);
        }
      });
      if (currentObj === last) {
        count += 1;
        last = queueObj.length ? queueObj[queueObj.length - 1] : null;
      }
    }
  }

  return count;
}
```

### 对象属性名

```js
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
// 输出 c
console.log(a[b]);
```

```js
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
// b
```

```js
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
// c
```

### 函数组合运行 compose

<!-- compose([a, b, c])('参数') => a(b(c('参数'))) -->

说明：实现一个方法，可将多个函数方法按从左到右的方式组合运行。 如 `composeFunctions(fn1,fn2,fn3,fn4)` 等价于 `fn4(fn3(fn2(fn1))`。实例：

```js
const add = x => x + 1;
const multiply = (x, y) => x * y;
const multiplyAdd = composeFunctions(multiply, add);
multiplyAdd(3, 4); // 返回 13
```

```js
function composeFunctions() {
  var slice = Array.prototype.slice;
  var fnArgs = slice.call(arguments, 0);
  return function() {
    var args = slice.call(arguments, 0);
    if (fnArgs.length === 1) {
      return fnArgs[0].apply(this, args);
    }
    return fnArgs.reduce(function(fn1, fn2) {
      return fn2(fn1.apply(this, args));
    });
  };
}
```

```js
function compose(funcs) {
  var len = funcs.length;
  var index = len - 1;

  for (let i = 0; i < len; i++) {
    if (typeof funcs[i] !== 'function') {
      throw new TypeError('Expected a function');
    }
  }

  return function(...args) {
    let result = funcs[index](...args); // 第一次
    while (--index >= 0) {
      result = funcs[index](result);
    }
    return result;
  };
}
```

```js
function mul(x) {
  return function(y) {
    // anonymous function
    return function(z) {
      // anonymous function
      return x * y * z;
    };
  };
}

console.log(mul(2)(3)(4)); // output : 24
console.log(mul(4)(3)(4)); // output : 48
```

```js
// example 1
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 2
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 3
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

对象键名的转换：

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。
  example 1，c 的键名转换成字符串将 b 键覆盖输出 c
  example 2，任何一个 Symbol 类型的值都是不相等的，所以 b 键和 c 键都不会被覆盖，输出 b
  example 3，对象都会被转换为字符串 [object Object]，因此 c 键会覆盖 b 键，输出 c

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

```js
var sinaNews = {
  name: 'sinNewsName',
  test: function() {
    console.log('this.name:', this.name, '//');
  },
};
setTimeout(sinaNews.test, 500); //
```

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // ?
foo(); // ?
```

```js
let arr = [1, 2, 3, 4];
let it1 = arr[Symbol.iterator](); // 遍历器接口
let res = it1.next();
console.log(res);
```

结果是：

```js
{
  done: false,
  value: 1
}
```
