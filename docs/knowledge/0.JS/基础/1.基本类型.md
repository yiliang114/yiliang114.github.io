---
title: JS 基本类型
date: '2020-10-26'
draft: true
---

### 数据类型

7 种原始类型（基本类型）：

1. Boolean
2. String
3. Number
4. Null
5. Undefined
6. Symbol（新定义）
7. BigInt（新定义）

**注意**：原始类型不包含 Object 和 Function

引用类型：

1. Object
2. Array
3. Function
4. String(很多场景下 string 会被强制转化成 String 类型，但其实也是对象类型)

原始类型与引用类型存储的方式也不同，原始数据类型存储在栈中，而引用数据类型存储在堆中。

原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()。此时你肯定会有疑问，这不对呀，明明 '1'.toString() 是可以使用的。其实在这种情况下，'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。

在 JS 中的 number 类型是浮点类型，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3。

### 使用 typeof 能得到哪些类型？

typeof null 的结果是 object, 实际这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

1. boolean
2. number
3. string
4. undefined
5. symbol
6. object
7. function

### undefined, null, not defined 的区别

null 是一个赋值，可以赋值给一个表示该值的变量，它没有价值。undefined 表示已经声明了一个变量，但是还没有定义。null 表示一个对象被定义了，值为“空值”。not defined 表示该值未定义。

```js
console.log(y); // Output: ReferenceError: y is not defined
```

在验证 null 时，一定要使用　=== ，因为 == 无法分别 null 和　 undefined

### == 运算符判断相等的流程是怎样的

对于 `==` 来说，如果对比双方的类型**不一样**的话，就会进行**类型转换**.

**`null` 只和`undefined` 相等，有 `number` 都转 `number`，有 `boolean` 也转 `number`，有 `string` 都转 `string`，对象互相不等，`NaN` 互相不等就可以了**

1. 如果两个值类型相同，按照 `===` 比较方法进行比较
2. 如果类型不同，使用如下规则进行比较
3. 如果其中一个值是 null，另一个是 undefined，它们相等
4. 如果一个值是**数字**另一个是**字符串**，将**字符串转换为数字**进行比较
5. 如果有布尔类型，将**true 转换为 1，false 转换为 0**，然后用 `==` 规则继续比较
6. 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用 `==` 规则继续比较
7. **其他所有情况都认为不相等**

### 0.1 + 0.2 === 0.3

```js
0.1 + 0.2 === 0.3; // false
0.1 + 0.2; // 0.30000000000000004
```

原因：计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数，但不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差. 为了解决这个问题可以使用 toFixed()

```js
// 最简单的解决问题
(0.1 + 0.2).toFixed(10); // 0.3
// 0.1 + 0.2
// 0.8 - 0.2
// 0.1 + 0.7
```

为什么 `console.log(0.1)` 却是正确的呢？因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

```js
console.log(0.100000000000000002); // 0.1
```

### JS 能表示最大的数和最小的数

64 位浮点型，符号位 1 位， 指数位 11 位， 尾数 52 位。在 JavaScript 中，2^53 是最大的值，没有比这更大的值了。

### 类型转换

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

1. 转换为布尔值
1. 转换为数字
1. 转换为字符串

#### 转 Boolean

在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

#### 对象转原始类型

对象在转换类型的时候，会调用内置的 `ToPrimitive` 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
  [Symbol.toPrimitive]() {
    return 2;
  },
};
1 + a; // => 3
```

#### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

1. 运算中其中一方为字符串，那么就会把另一方也转换为字符串
1. 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + '1'; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
- 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
- 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

```js
'a' + +'b'; // -> "aNaN"
```

因为 + 'b' 等于 NaN，所以结果为 "aNaN"，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```js
4 * '3'; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

#### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
1. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
};
a > -1; // true
```

在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。

#### 对象到字符串的转换步骤

1. 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果
2. 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果
3. 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError

#### 对象到数字的转换步骤

1. 如果对象有 valueOf()方法并且返回元素值，javascript 将返回值转换为数字作为结果
2. 否则，如果对象有 toString()并且返回原始值，javascript 将返回结果转换为数字作为结果
3. 否则，throws a TypeError

#### <,>,<=,>=的比较规则

所有比较运算符都支持任意类型，但是**比较只支持数字和字符串**，所以需要执行必要的转换然后进行比较，转换规则如下:

1. 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错
2. 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）
3. 否则，如果有一个操作数不是字符串，**将两个操作数转换为数字**进行比较

#### +运算符工作流程

1. 如果有操作数是对象，转换为原始值
2. 此时如果有**一个操作数是字符串**，其他的操作数都转换为字符串并执行连接
3. 否则：**所有操作数都转换为数字并执行加法**

```js
'100' + 100; // "100100"
100 + '100'; // "100100"
100 + true; // 101
100 + false; // 100
100 + undefined; //NaN
100 + null; // 100
// + 会自动转换后面跟随的值类型
```

### 原始类型转化

当我们对一个“对象”进行数学运算操作时候，会涉及到对象 => 基础数据类型的转化问题。

事实上，当一个对象执行例如加法操作的时候，如果它是原始类型，那么就不需要转换。否则，将遵循以下规则：

1. 调用实例的`valueOf()`方法，如果有返回的是基础类型，停止下面的过程；否则继续
2. 调用实例的`toString()`方法，如果有返回的是基础类型，停止下面的过程；否则继续
3. 都没返回原始类型，就会报错

请看下面的测试代码：

```js
let a = {
  toString: function() {
    return 'a';
  },
};

let b = {
  valueOf: function() {
    return 100;
  },
  toString: function() {
    return 'b';
  },
};

let c = Object.create(null); // 创建一个空对象

console.log(a + '123'); // output: a123
console.log(b + 1); // output: 101
console.log(c + '123'); // 报错
```

除了`valueOf`和`toString`，es6 还提供了`Symbol.toPrimitive`供对象向原始类型转化，并且**它的优先级最高**！！稍微改造下上面的代码：

```js
let b = {
  valueOf: function() {
    return 100;
  },
  toString: function() {
    return 'b';
  },
  [Symbol.toPrimitive]: function() {
    return 10000;
  },
};

console.log(b + 1); // output: 10001
```

最后，其实关于`instanceof`判断是否是某个对象的实例，es6 也提供了`Symbol.hasInstance`接口，代码如下：

```js
class Even {
  static [Symbol.hasInstance](num) {
    return Number(num) % 2 === 0;
  }
}

const Odd = {
  [Symbol.hasInstance](num) {
    return Number(num) % 2 !== 0;
  },
};

console.log(1 instanceof Even); // output: false
console.log(1 instanceof Odd); // output: true
```

### 内存释放

引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收.
