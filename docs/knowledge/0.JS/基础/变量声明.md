---
title: ES6
date: '2020-10-26'
draft: true
---

### var、let 和 const 区别

- var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会
- let 和 const 定义的变量不会出现变量提升，而 var 定义的变量会提升。
- let 和 const 是 JS 中的块级作用域
- 同一作用域下 let 和 const 不允许重复声明(会抛出错误)
- let 和 const 定义的变量在定义语句之前，如果使用会抛出错误(形成了暂时性死区)，而 var 不会。
- const 声明一个只读的常量。一旦声明，常量的值就不能改变(如果声明是一个对象，那么不能改变的是对象的引用地址)

### 变量声明提升

`js` 代码在运行前都会进行 `AST` 解析，函数声明默认会提到当前作用域最前面，变量声明也会进行提升。但赋值不会得到提升。关于 `AST` 解析，这里也可以说是形成词法作用域的主要原因

### 请解释变量提升 hoisting

变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用`var`关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。我们用几个例子来解释一下。

```js
// 用 var 声明得到提升
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// 用 let/const 声明不会提升
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。

```js
// 函数声明
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// 函数表达式
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```

### javascript 变量声明优先级

function 声明的优先级比 var 声明高，也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明，如下：

```js
alert(a); //输出：function a(){ alert('我是函数') }

function a() {
  alert('我是函数');
} //
var a = '我是变量';

alert(a); //输出：'我是变量'
```

这代码等效于：

```js
function a() {
  alert('我是函数');
}
var a; //hoisting
alert(a); //输出：function a(){ alert('我是函数') }
a = '我是变量'; //赋值
alert(a); //输出：'我是变量'
```

这短短的代码里面其实说明了两个问题：

function 声明的优先级高于 var 声明：第一个 alert 输出可以看出 var a;被 function a(){}覆盖掉了。
赋值优先于函数声明：第二个 alert 输出可以看出 a='我是变量'又把 function a(){}覆盖掉了。
把一个变量添加到作用域中除有很多方法，如下：

javascript 语言预定义的，比如说 this,arguments
formal parameter(也就是中文说的形参吧)
var 声明并赋值，比如说 var a = 10;
var 声明不赋值，比如说 var a;
function 声明，比如说 function a(){};
我们来看看他们之间的优先级：

var 声明并赋值优先级高于 function 声明 这个上面已经说了。

function 声明优先级高于 formal parameter

```js
function fnTest(a) {
  alert(a);
  function a() {
    return '我优先';
  }
}
fnTest(100); //:function a(){return "我优先"}。可以看出 function 声明覆盖了`formal parameter`。
// formal parameter 优先级高于预定义变量
function fnTest(arguments) {
  alert(arguments);
}
fnTest(100); //:100。说明`formal parameter`优先级比预定义的 arguments 高
```

对比以下：

```js
function fnTest(a) {
  alert(arguments);
}
fnTest(100); //:[Object Arguments] {0:100,length:1}。当没有冲突时输出便是预定义的 arguments
// formal parameter 优先级高于 var 声明不赋值
function fnTest(a) {
  alert(a);
  var a;
}
fnTest(100); //:100。很明显，不多说
```

预定义变量优先级高于 var 声明不赋值

```js
function fnTest() {
  alert(arguments);
  var arguments;
}
fnTest(); //:[Object Arguments]。不是 undefined，说明 arguments 没有被 var 声明覆盖
// var 声明不赋值优先级高于函数外部作用域的其他所有声明;
function fnTest() {
  alert(fnTest);
  var fnTest;
}
fnTest(); //:undefined。
```

对比如下：

```js
function fnTest() {
  //
  alert(fnTest); //
} //
fnTest(); //输出 function fnTest(){alert(fnTest);}
```

这也正好印证了作用域链查找变量的方式：在局部作用域里查找（若找到则返回，不必往下继续查找） ==> 在上一级作用域里查找... ==> 直到全局作用域（若找不到则返回 typeError）

最后看看下面的综合例子：

```js
function fnTest(arguments) {
  alert(arguments); //function arguments(){return "hello world"}
  var arguments = 99;
  function arguments() {
    return 'hello world';
  }
  alert(arguments); //99
}
fnTest(100);
```

### freeze 冻结对象

有什么办法可以让`const obj = {a: 1};`的值不可变？

> `const foo = Object.freeze({}); foo.prop= 123;` // 不起作用
