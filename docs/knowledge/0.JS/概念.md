---
title: 概念
date: '2020-10-26'
draft: true
---

## 概念

### 什么是 use strict ? 使用它的好处和坏处分别是什么？

'use strict' 是用于对整个脚本或单个函数启用严格模式的语句。严格模式是可选择的一个限制 JavaScript 的变体一种方式。
严格模式 （strict mode） 使得 Javascript 在更严格的条件下运行。设立"严格模式"的目的，主要有以下几个：

1. 使 JS 编码更加规范化的模式，消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;
2. 消除代码运行的一些不安全之处，保证代码运行的安全；
3. 提高编译器效率，增加运行速度；
4. 为未来新版本的 Javascript 做好铺垫。

注：经过测试 IE6,7,8,9 均不支持严格模式。

缺点：

现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间有指示严格模式，反而在压缩后浪费了字节。

#### 优缺点

**优点：**

- 无法再意外创建全局变量。
- 会使引起静默失败（silently fail，即：不报错也没有任何效果）的赋值操抛出异常。
- 试图删除不可删除的属性时会抛出异常（之前这种操作不会产生任何效果）。
- 要求函数的参数名唯一。
- 全局作用域下，`this`的值为`undefined`。
- 捕获了一些常见的编码错误，并抛出异常。
- 禁用令人困惑或欠佳的功能。

**缺点：**

- 缺失许多开发人员已经习惯的功能。
- 无法访问`function.caller`和`function.arguments`。
- 以不同严格模式编写的脚本合并后可能导致问题。

总的来说，我认为利大于弊，我从来不使用严格模式禁用的功能，因此我推荐使用严格模式。

#### 差异

- 不允许不使用 var 关键字去创建全局变量，抛出 ReferenceError
- 不允许对变量使用 delete 操作符，抛 ReferenceError
- 不可对对象的只读属性赋值，不可对对象的不可配置属性使用 delete 操作符，不可为不可拓展的对象添加属性，均抛 TypeError
- 对象属性名必须唯一
- 函数中不可有重名参数
- 在函数内部对修改参数不会反映到 arguments 中
- 淘汰 arguments.callee 和 arguments.caller
- 不可在 if 内部声明函数
- 不能使用 with 语句
- 变量必须声明后再使用
- 不能使用前缀 0 表示八进制数，否则报错
- eval 不会在它的外层作用域引入变量
- 禁止 this 指向全局对象
- 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈
- 增加了保留字（比如 protected、static 和 interface）

### JS 能表示最大的数和最小的数

64 位浮点型，符号位 1 位， 指数位 11 位， 尾数 52 位。在 JavaScript 中，2^53 是最大的值，没有比这更大的值了。

## 定时器函数

- setTimeout 表示间隔一段时间之后执行一次调用
- setInterval 则是每间隔一段时间循环调用
- setImmediate 立即执行函数
- requestAnimationFrame 在浏览器重绘之前执行回调函数（类似 setTimeout 延迟执行）

clearTimeout, clearInterval 函数用来结束尚未执行的 setTimeout 和 setInterval。

内存方面，setTimeout 只需要进入一次队列，不会造成内存溢出；setInterval 因为不计算代码执行时间，有可能同时执行多次代码，导致内存溢出。

### setTimeout 原理

### setTimeout、setInterval、requestAnimationFrame 各有什么特点？

很多人认为 `setTimeout` 是延时多久，那就应该是多久后执行。其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行。

`setInterval` 和 `setTimeout` 一样，不能保证在预期的时间执行任务。

如果有循环定时器的需求，其实完全可以通过 `requestAnimationFrame` 来实现

```js
function setInterval(callback, interval) {
  let timer;
  const now = Date.now;
  let startTime = now();
  let endTime = startTime;
  const loop = () => {
    timer = window.requestAnimationFrame(loop);
    endTime = now();
    if (endTime - startTime >= interval) {
      startTime = endTime = now();
      callback(timer);
    }
  };
  timer = window.requestAnimationFrame(loop);
  return timer;
}

let a = 0;
setInterval(timer => {
  console.log(1);
  a++;
  if (a === 3) cancelAnimationFrame(timer);
}, 1000);
```

首先 `requestAnimationFrame` 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题。

常见的定时器函数有 `setTimeout`、`setInterval`、`requestAnimationFrame`，但 setTimeout、setInterval 并不是到了哪个时间就执行，**而是到了那个时间把任务加入到异步事件队列中**。

因为 JS 是单线程执行的，如果某些同步代码影响了性能，就会导致 setTimeout 不会按期执行。

而 setInterval 可能经过了很多同步代码的阻塞，导致不正确了，可以使用 setTimeout 每次获取 Date 值，计算距离下一次期望执行的时间还有多久来动态的调整。

[requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame) 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题

### 133.用 setTimeout 实现 setInterval，阐述实现的效果与 setInterval 的差异

```js
function mySetInterval() {
  mySetInterval.timer = setTimeout(() => {
    arguments[0]();
    mySetInterval(...arguments);
  }, arguments[1]);
}

mySetInterval.clear = function() {
  clearTimeout(mySetInterval.timer);
};

mySetInterval(() => {
  console.log(11111);
}, 1000);

setTimeout(() => {
  // 5s 后清理
  mySetInterval.clear();
}, 5000);
```

### requestAnimationFrame 的作用及使用，替代 setTimeout 的写法

### setTimeout 和 requestAnimationFrame 的区别

## 数组

### 判断数组的方式

1. Object.prototype.toString.call()
2. instanceof
3. Array.isArray()

性能方面：判断数据 Array.isArray() 性能最好，instanceof 次之，Object.prototype.toString.call() 第三
功能方面：`Object.prototype.toString.call()` 所有的类型都可以判断, 可以理解为是 100% 准确。

`Object.prototype.toString.call()` 能够得到的值, 8 种: number, boolean, string, undefined, symbol, object, function, bigint。

instanceof 只能判断对象原型，原始类型不可以。

```js
[] instanceof Object; // true
```

Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 frames, Array.isArray() 是 ES5 新增的方法，当使用 ie8 的时候就会出现问题。当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。

如果浏览器支持 Array.isArray()可以直接判断否则需进行必要判断

```js
function isArray(value) {
  if (typeof Array.isArray === 'function') {
    return Array.isArray(value);
  } else {
    return Object.prototype.toString.call(value) === '[object Array]';
  }
}
```

#### TODO: Object.prototype.toString.call() 实现原理？

NaN 判断准确么？

#### 2. instanceof

`instanceof` 的内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型，找到返回 `true`，否则返回 `false`。

```js
[] instanceof Array; // true
```

但 `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```js
[] instanceof Object; // true
```

### Array(...)和 Array.of(...) 的区别

Array(...)的作用是接受参数返回一个数组，但是有一个陷阱，如果只传入一个参数，并且这个参数是数 字的话，那么不会构造一个值为这个数字的单个元素的数组，而是构造一个空数组

```js
var a = Array(3);
a.length; // 3
a[0]; // undefined
```

Array.of(..)解决掉了这个陷阱

```js
var b = Array.of(3);
b.length; // 1
b[0]; // 3
var c = Array.of(1, 2, 3);
c.length; // 3
c; // 1,2,3
```

### ['1', '2', '3'].map(parseInt)

map 会给函数传递 3 个参数： (elem, index, array) 而 parseInt 接收两个参数(sting, radix)，其中 radix 代表进制。省略 radix 或 radix = 0，则数字将以十进制解析。 因此，map 遍历 ["1", "2", "3"]，相应 parseInt 接收参数如下

```js
parseInt('1', 0); // 1
parseInt('2', 1); // NaN
parseInt('3', 2); // NaN
```

因为二进制里面，没有数字 3,导致出现超范围的 radix 赋值和不合法的进制解析，才会返回 NaN 所以["1", "2", "3"].map(parseInt) 答案也就是：[1, NaN, NaN]

### Array 对象自带的排序函数 sort 底层是怎么实现的？

长度小于多少的时候采用 ？ 大于多少的时候采用 ？

### 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

[102, 15, 22, 29, 3, 8]

根据 MDN 上对 Array.sort()的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以'102' 会排在 '15' 前面。

### 创建数组的几种方法

有什么不同？数组可以直接通过 length 来指定长度，自动扩展，自动清空。

### 类数组对象转换为数组

类数组对象：只包含使用从零开始，且自然递增的整数做键名，并且定义了 length 表示元素个数的对象，我们就认为他是类数组对象！类数组对象可以进行读写操作和遍历操作。

```js
var arrLike = {
  length: 4,
  2: 'foo',
};
```

要将其转换为真正的数组可以使用各种 Array.prototype 方法(map(..)、indexOf(..) 等)

```js
var arr = Array.prototype.slice.call(arrLike);
var arr2 = arr.slice();
var arr = Array.from(arrLike);
```

常见的类数组:

1. arguments

```js
console.log(Array.isArray(arguments)); //false
console.log(arguments);
//node打印: {}
//chrome打印: Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]
//因为arguments具有Symbol.iterator属性，所以它可以用扩展运算符(...arguments) 或 其他�使用迭代器的方法
```

2. dom 中

```js
//仅限浏览器中
const nodeList = document.querySelectorAll('*');
console.log(Array.isArray(nodeList));
```

3. 字符串 String

```js
const array = Array.from('abc');
console.log(array);
//["a", "b", "c"]
```

4. TypedArray

```js
const typedArray = new Int8Array(new ArrayBuffer(3));
console.log(Array.isArray(typedArray));
//false
```

5. {length:0} 是类数组的特殊情况，转换时可以执行成功，返回空数组[]

```js
console.log(Array.from({ length: 0 }));
//[]
console.log(Array.from(''));
//[]
```

### 清空数组

```js
var ary = [1, 2, 3, 4];
ary.splice(0, ary.length);
console.log(ary); // 输出 []，空数组，即被清空了
```

### 用 Array 的 reduce 方法实现 map 方法（头条一面）

```js
const selfMap2 = function(fn, context) {
  let arr = Array.prototype.slice.call(this);
  // 这种实现方法和循环的实现方法有异曲同工之妙，利用reduce contact起数组中每一项
  // 不过这种有个弊端，会跳过稀疏数组中为空的项
  return arr.reduce((pre, cur, index) => {
    return [...pre, fn.call(context, cur, index, this)];
  }, []);
};
```

### 给出数组超过半数的数字，不存在的话输出没有（要求时间复杂度最低）

```js
function moreThanHalfNum(numbers) {
  // write code here
  var obj = {};
  var len = numbers.length;
  numbers.forEach(function(s) {
    if (obj[s]) {
      obj[s]++;
    } else {
      obj[s] = 1;
    }
  });
  for (var i in obj) {
    if (obj[i] > Math.floor(len / 2)) {
      return i;
    }
  }
  return 0;
}
```

### 取数组的最大值（ES5、ES6)

```js
// ES5 的写法
Math.max.apply(null, [14, 3, 77, 30]);

// ES6 的写法
Math.max(...[14, 3, 77, 30]);

// reduce
[14, 3, 77, 30].reduce((accumulator, currentValue) => {
  return (accumulator = accumulator > currentValue ? accumulator : currentValue);
});

let arr = [12, 3, 77, 30].sort((a, b) => b - a);
arr[0];
```

### 实现 flatten 扁平化函数

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
  return a - b;
});
```

**竟然原生就有这个 flat 函数，用来拍平数组**
flat 函数的参数是层级。Infinity 无限大。 会拍平数组中的所有数组值。

递归实现

```js
function flatten(arr) {
  let temp = [];
  arr.map(item => {
    if (Array.isArray(item)) {
      temp.push(...flatten(item));
    } else {
      temp.push(item);
    }
  });
  return temp;
}
```

使用 es6 的 reduce 函数

```js
const flatten = arr => arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
```

## 对象

### 语法糖

`var a = {}` 其实是 `var a = new Object()` 的语法糖
`var a = []` 其实是 `var a = new Array()` 的语法糖
`function Foo(){}` 其实是 `var Foo = new Function(){}` 的语法糖

使用 instanceof 判断一个函数是否是一个变量的构造函数

### new String

JS 与其他面向对象语言一样有相应的构造器，比如说，可以通过以下两种方式来创建一个字符串：

```js
var a = 'woot';
var b = new String('woot');
a + b; // => 'wootwoot'
```

然而要是对这两个变量使用 typeof 和 instanceof 操作符，事情就变得有意思了：

```js
typeof a; // string
typeof b; // object
a instanceof String; // false
b instanceof String; // true
```

而事实上，这两个变量值绝对都是货真价实的字符串：

```js
a.substr == b.substr;
```

而且使用 == 操作符判定两者相等，而使用 === 操作符判定时并不相同：

```js
a == b; // true
a === b; // false
```

另外值得注意的是， typeof 不会把 null 识别为类型 null：

```js
typeof null == 'object'; // 很不幸，结果为 true
```

数组也不例外，就算是通过 [] 这种方式定义数组也是如此：

```js
typeof [] == 'object'; // 很不幸，结果为 true
```

#### Object.create(null) 原理

为什么 vue 有些地方需要使用前者，有些地方不需要？

应该是将原型链最末端的值替换为 null, 普通声明的对象或者函数，原型链的末端是 Object, 有可能原型链上被挂载了其他的属性和函数，这是不想要的。所以这么操作应该是为了排除影响。

### 比较操作符 ===、== 的区别？

- == 相等运算符，比较时会自动进行数据类型转换
- === 严格相等运算符，比较时不进行隐式类型转换

```js
+0 === -0; //true
NaN === NaN; // false

Object.is(+0, -0); // false
Object.is(NaN, NaN); // true
```

TODO: 强制类型转化的顺序是怎么样的？

### 合并两个对象

```js
const merge1 = (toObj, fromObj) => Object.assign(toObj, fromObj);
function merge2(toObj, fromObj) {
  if (typeof toObj === 'object' && typeof fromObj === 'object') {
    for (var pro in fromObj) {
      if (fromObj.hasOwnProperty(pro)) {
        toObj[pro] = fromObj[pro];
      }
    }
  } else {
    throw 'Merge function can apply only on object';
  }
}
```

### Object.assign() 的模拟实现

1. 判断原生 Object 是否支持该函数，如果不存在的话创建一个函数 assign，并使用 Object.defineProperty 将该函数绑定到 Object 上。
2. 判断参数是否正确（目标对象不能为空，我们可以直接设置{}传递进去,但必须设置值）。
3. 使用 Object() 转成对象，并保存为 to，最后返回这个对象 to。
4. 使用 for..in 循环遍历出所有可枚举的自有属性。并复制给新的目标对象（使用 hasOwnProperty 获取自有属性，即非原型链上的属性）。

实现代码如下，这里为了验证方便，使用 assign2 代替 assign。注意此模拟实现不支持 symbol 属性，因为 ES5 中根本没有 symbol 。

```js
if (typeof Object.assign2 != 'function') {
  // Attention 1
  Object.defineProperty(Object, 'assign2', {
    value: function(target) {
      'use strict';
      if (target == null) {
        // Attention 2
        throw new TypeError('Cannot convert undefined or null to object');
      }

      // Attention 3
      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) {
          // Attention 2
          // Attention 4
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true,
  });
}
```

### 如何判断一个对象是空的？

1. `const isEmptyObject = obj => Object.getOwnPropertyNames(obj).length === 0`
2. `Object.keys(obj).length == 0`

### 如何防止在 JavaScript 中修改对象 ?

```js
var employee = {
  name: 'yiliang',
};

//Freeze the object
Object.freeze(employee);

// Seal the object
Object.seal(employee);

console.log(Object.isExtensible(employee)); // false
console.log(Object.isSealed(employee)); // true
console.log(Object.isFrozen(employee)); // true

employee.name = 'xyz'; // fails silently unless in strict mode
employee.age = 30; // fails silently unless in strict mode
delete employee.name; // fails silently unless it's in strict mode
```

#### Object.freeze 和 Object.seal 的区别

Object.preventExtension：禁止对象添加新属性并保留已有属性;
Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;
Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。

freeze 冻结对象

`const foo = Object.freeze({}); foo.prop= 123;` // 不起作用

## 对象的值判断

### `foo.x`的值是什么？

```js
var foo = { n: 1 };
var bar = foo;
foo.x = foo = { n: 2 };
// foo.x = (foo = {n:2}); =>  {n:1}.x = ( {n:1} = {n:2} );  R.H.S. foo={n:2}
// console.log(foo.x); //Result undefined
// console.log(foo); //Result {n:2}
// console.log(bar); //Result {n:1, x: {n:2}}
// Result = undefined
```

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x);
console.log(b.x);
```

输出：

```js
a.x; //  undefined
b.x; //  {n: 2}
```

运算赋优先级问题，此前 a 和 b 都是指向{n:1}，a.x 执行之后 x 值为 undefined，a 和 b 指向{n:1,x:undefined},接下来执行赋值运算，a 指向变更成了{n:2},此时都 a.x= a,实际上是 b.x=a,b 指向了{n:1,x:{n: 2}},此时 a.x 输出 undefined,b.x 输出{n:2}

### 获取对象深度

空对象当作一级，属性值为数组则不向下查找

```js
// 递归，深度优先遍历
function getObjectDeep(obj, arr = []) {
  var count = 0;
  obj && arr.indexOf(obj) === -1 && arr.push(obj);
  if (obj && !Array.isArray(obj) && typeof obj === 'object') {
    count = 1;
    var result = Object.keys(obj).map(function(item) {
      if (typeof obj[item] === 'object' && arr.indexOf(obj[item]) === -1) {
        // 防止循环引用
        arr.push(obj[item]);
        return 1 + getObjectDeep(obj[item], arr);
      } else {
        return 1;
      }
    });
    for (var i = 0; i < result.length; i++) {
      if (count < result[i]) {
        count = result[i];
      }
    }
  }
  return count;
}

// 非递归，宽度优先遍历
function getObjectDeep(obj) {
  var count = 0;
  var queueObj = [obj];
  var arrs = [obj]; // 防止循环引用
  var last = obj; // 当前层级最后一个

  var checkObj = function(param) {
    return param !== null && param !== undefined && !Array.isArray(param) && typeof param === 'object';
  };

  if (checkObj(obj)) {
    while (queueObj.length) {
      var currentObj = queueObj.shift();
      Object.keys(currentObj).forEach(function(item) {
        if (checkObj(currentObj[item]) && arrs.indexOf(currentObj[item]) === -1) {
          arrs.push(currentObj[item]);
          queueObj.push(currentObj[item]);
        }
      });
      if (currentObj === last) {
        count += 1;
        last = queueObj.length ? queueObj[queueObj.length - 1] : null;
      }
    }
  }

  return count;
}
```

### 对象属性名

```js
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
// 输出 c
console.log(a[b]);
```

```js
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
// b
```

```js
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
// c
```

## 函数

### TODO: 柯里化函数

用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数

```js
add(2, 5); // 7
add(2)(5); // 7
```

基本实现：

```js
function add() {
  let data = Array.prototype.slice.call(arguments);
  if (data.length > 1) {
    return data.reduce((source, item) => source + item, 0);
  } else {
    let sum;
    sum = (sum || 0) + data[0];
    return add.bind(this, sum);
  }
}
```

进化版：

> 当一个对象转换成原始值时，先查看对象是否有 valueOf 方法，如果有并且返回值是一个原始值，
> 那么直接返回这个值，否则没有 valueOf 或返回的不是原始值，那么调用 toString 方法，返回字符串表示

```js
function add() {
  let data = Array.prototype.slice.call(arguments);
  if (data.length > 1) {
    return data.reduce((source, item) => source + item, 0);
  } else {
    let sum = data[0];
    function tmp(b) {
      // 使用闭包
      sum = sum + b;
      return tmp;
    }
    tmp.valueOf = function() {
      return sum;
    };
    tmp.toString = function() {
      return sum + '';
    };
    return tmp;
  }
}
```

老外版本：

```js
const add = (a, b) => {
  if (a && b) return a + b;
  else
    return (buffAdd = b => {
      return a + b;
    });
};
```

参数固定版本：

```js
var curry = function(final, arity) {
  var curried = function() {
    // this是每次的参数列表
    // 每次slice()保证curry后的函数仍然是无状态的
    var new_args = this.slice();
    for (arg_key in arguments) {
      new_args.push(arguments[arg_key]);
    }

    if (new_args.length >= arity) {
      return final.apply(null, new_args);
    } else {
      return curried.bind(new_args);
    }
  };

  return curried.bind([]);
};

var sum4 = function(a, b) {
  return a + b;
};

var add = curry(sum4, sum4.length);

console.log(add(2, 5));
console.log(add(2)(5));
```

最终版

```js
function add() {
  let data = [].concat(Array.prototype.slice.call(arguments));
  function tmp() {
    // 使用闭包
    data = data.concat(Array.prototype.slice.call(arguments));
    return tmp;
  }
  tmp.valueOf = function() {
    return data.reduce((source, item) => source + item, 0);
  };
  tmp.toString = function() {
    return data.reduce((source, item) => source + item, 0);
  };
  return tmp;
}
```

## 函数的执行题

### 函数组合运行 compose

<!-- compose([a, b, c])('参数') => a(b(c('参数'))) -->

说明：实现一个方法，可将多个函数方法按从左到右的方式组合运行。 如 `composeFunctions(fn1,fn2,fn3,fn4)` 等价于 `fn4(fn3(fn2(fn1))`。实例：

```js
const add = x => x + 1;
const multiply = (x, y) => x * y;
const multiplyAdd = composeFunctions(multiply, add);
multiplyAdd(3, 4); // 返回 13
```

```js
function composeFunctions() {
  var slice = Array.prototype.slice;
  var fnArgs = slice.call(arguments, 0);
  return function() {
    var args = slice.call(arguments, 0);
    if (fnArgs.length === 1) {
      return fnArgs[0].apply(this, args);
    }
    return fnArgs.reduce(function(fn1, fn2) {
      return fn2(fn1.apply(this, args));
    });
  };
}
```

```js
function compose(funcs) {
  var len = funcs.length;
  var index = len - 1;

  for (let i = 0; i < len; i++) {
    if (typeof funcs[i] !== 'function') {
      throw new TypeError('Expected a function');
    }
  }

  return function(...args) {
    let result = funcs[index](...args); // 第一次
    while (--index >= 0) {
      result = funcs[index](result);
    }
    return result;
  };
}
```

```js
function mul(x) {
  return function(y) {
    // anonymous function
    return function(z) {
      // anonymous function
      return x * y * z;
    };
  };
}

console.log(mul(2)(3)(4)); // output : 24
console.log(mul(4)(3)(4)); // output : 48
```

```js
// example 1
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 2
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 3
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

对象键名的转换：

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。
  example 1，c 的键名转换成字符串将 b 键覆盖输出 c
  example 2，任何一个 Symbol 类型的值都是不相等的，所以 b 键和 c 键都不会被覆盖，输出 b
  example 3，对象都会被转换为字符串 [object Object]，因此 c 键会覆盖 b 键，输出 c

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

```js
var sinaNews = {
  name: 'sinNewsName',
  test: function() {
    console.log('this.name:', this.name, '//');
  },
};
setTimeout(sinaNews.test, 500); //
```

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // ?
foo(); // ?
```

```js
let arr = [1, 2, 3, 4];
let it1 = arr[Symbol.iterator](); // 遍历器接口
let res = it1.next();
console.log(res);
```

结果是：

```js
{
  done: false,
  value: 1
}
```

### name 的值是多少？

```js
function A(name) {
  this.name = name || 'Tom';
  this.msg = "use 'this.' set in function";
}

function B() {}
B.prototype = A;

var b = new B();
console.log(b.name);
console.log(b.msg);
// A
// undefined
```

每一个函数都有一个属性为 name，其值是函数的名字。

```js
function abc() {
  /* 这是一个名为'abc'的函数 */
}
abc.name; // -> 'abc'
```
