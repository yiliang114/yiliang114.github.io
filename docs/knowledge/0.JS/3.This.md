---
title: This
date: '2020-10-26'
draft: true
---

## This

```js
function foo() {
  console.log(this.a);
}
var a = 1;
foo();

var obj = {
  a: 2,
  foo: foo,
};
obj.foo();

// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况

// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
var c = new foo();
c.a = 3;
console.log(c.a);

// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new
```

以上几种情况明白了，很多代码中的 `this` 应该就没什么问题了，下面让我们看看箭头函数中的 `this`

```js
function a() {
  return () => {
    return () => {
      console.log(this);
    };
  };
}
console.log(a()()());
```

箭头函数其实是没有 `this` 的，这个函数中的 `this` 只取决于他外面的第一个不是箭头函数的函数的 `this`。

### this 的用法以及优先级

this 的四种用法：

1. 单纯的函数调用，这是默认绑定
2. 作为对象方法调用，这是隐式绑定
3. 通过 apply.call.bind 方法调用，这是显示绑定，(call，apply 传参方式不同，都是立即执行，bind 不是立即执行，而是返回一个函数)
4. 通过 new 绑定，最终指向的是 new 出来的对象

优先级： new > 显示 > 隐式 > 默认

### 如果对一个函数进行多次 bind，那么上下文会是什么呢？

```js
let a = {};
let fn = function() {
  console.log(this);
};
fn.bind().bind(a)(); // => ?
```

可以把上述代码转换成另一种形式，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。

```js
// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply();
  }.apply(a);
};
fn2();
```

### 箭头函数中的 this 判断

箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么， 即声明箭头函数处的 this。

```js
let a = {
  b: function() {
    console.log(this);
  },
  c: () => {
    console.log(this);
  },
};

a.b(); // a
a.c(); // window

let d = a.b;
d(); // window
```

## bind, call 和 apply

### call, apply, bind 的区别和作用？

三个函数的作用都是用来动态改变当前函数的 this 指针， 并且三个函数的第一个参数都是新的 this 指向值。

#### 区别：

1. call 和 apply 都是直接执行一个函数，执行过程中遇到 this 就改变为指向的值。
2. bind 是在函数执行之前就已经强行修改了 this 的值，并且最终返回的结果是一个函数，需要手动执行。`call`，`apply` 立即执行。
3. call 与 apply 的区别是 apply 的参数是一个数组，可以是 Array 的实例，也可以是 arguments 对象， call 接受逗号分隔的参数作为后面的参数。而 bind 只有一个 this 参数。一个简单的记忆方法是，从`call`中的 C 联想到逗号分隔（comma-separated），从`apply`中的 A 联想到数组（array）。
4. call 比 apply 的性能要好， 具体为啥暂时不太清楚， 可能需要将数组解构出来传递到执行函数中去吧。

```js
Foo.call(this, name);
Foo.apply(this, [name]);
Foo.bind(this)(name);
```

### 手写 call、apply 及 bind 函数

```js
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  context = context || window;
  // 通过将函数挂载到 context 对象上来使得 this 改变
  context.fn = this;
  const args = [...arguments].slice(1);
  const result = context.fn(...args);
  delete context.fn;
  return result;
};
```

```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  context = context || window;
  context.fn = this;
  let result;
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

bind 实现

`bind` 的实现对比其他两个函数略微地复杂了一点，因为 `bind` 需要返回一个函数，需要判断一些边界问题，以下是 `bind` 的实现

```js
Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  const that = this;
  const args = [...arguments].slice(1);
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new that(...args, ...arguments);
    }
    return that.apply(context, args.concat(...arguments));
  };
};
```

以下是对实现的分析：

- 前几步和之前的实现差不多，就不赘述了
- `bind` 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 `new` 的方式，我们先来说直接调用的方式
- 对于直接调用来说，这里选择了 `apply` 的方式实现，但是对于参数需要注意以下情况：因为 `bind` 可以实现类似这样的代码 `f.bind(obj, 1)(2)`，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 `args.concat(...arguments)`
- 最后来说通过 `new` 的方式，在之前的章节中我们学习过如何判断 `this`，对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况我们需要忽略传入的 `this`

```js
Function.prototype.bind = function(oThis) {
  if (typeof this !== 'function') {
    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
      // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
      // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
      return fToBind.apply(
        this instanceof fNOP && oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments)),
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
```

## 作用域

### 作用域与变量声明提升

- 在 JavaScript 中，函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部
- 声明语句中的赋值部分并不会被提升，只有名称被提升
- 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明
- 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数

### 变量与函数同名的情况

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})(); //[Function b]
```

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。
在严格模式下 b 函数相当于常量，无法进行重新赋值，在非严格模式下函数声明优先变量声明

#### 简单改造下面的代码，使之分别打印 10 和 20

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

- 打印 20

```js
var b = 10;
(function b() {
  var b = 20;
  console.log(b);
})(); // 20 在自执行函数中重新定义一个变量，
```

```js
var b = 10;
(function a() {
  b = 20;
  console.log(b);
})();
```

```js
var b = 10;
(function() {
  b = 20;
  console.log(b);
})();
```

- 打印 10

```js
var b = 10;
(function b() {
  b = 20;
  console.log(window.b);
})();
```

在自执行函数中访问 window，window 中的 b 值为 10 2.

```js
var b = 10;
(function() {
  console.log(b);
  b = 20;
})();
```

```js
var b = 10;
(function b(b) {
  console.log(b);
  b = 20;
})(b);
```

### 作用域

```js
var a = 10;
(function() {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

### 下面的输出是什么？

```js
pi = 0;
radius = 1;
function circum(radius) {
  radius = 3;
  pi = 3.14;
  console.log(2 * pi * radius); // 18.14
  console.log(arguments[0]); // 3
}
circum(2);
console.log(pi); // 3.14
console.log(radius); // 1

// 函数内修改了radius 修改的是形式参数，修改的 pi 是全局的 window or global 中的 pi
```

```js
var pi = 0;
var radius = 1;
function circum(radius) {
  radius = 3;
  pi = 3.14;
  console.log(2 * pi * radius); // 18.84
  console.log(arguments[0]); // 3
}

circum(radius);

console.log(pi); // 3.14
console.log(radius); // 1
```

```js
function foo(a, b) {
  arguments[0] = 9;
  arguments[1] = 99;
  console.log(a, b); //9, 99
}
foo(1, 10);

function foo(a, b) {
  a = 8;
  b = 88;
  console.log(arguments[0], arguments[1]); //8, 88
}
foo(1, 10);

// ES6的默认函数不会改变arguments类数组对象值
function foo(a = 1, b = 10) {
  arguments[0] = 9;
  arguments[1] = 99;
  console.log(a, b); //1, 10
}
foo();

// 实例
function f2(a) {
  console.log(a);
  var a;
  console.log(a);
  console.log(arguments[0]);
}
f2(10);

// 经过变量提升后：
function f2(a) {
  var a;
  console.log(a);
  console.log(a);
  console.log(arguments[0]);
}
f2(10);

// var a会被归纳，由于a已经有值，故不会变为undefined
```

```js
var a = {};
var b = { name: 'ZS' };
var c = {};
c[a] = 'demo1';
c[b] = 'demo2';

console.log(c[a]); // demo2
console.log(c); // Object {[object Object]: "demo2"}
```

c[a]、c[b]隐式的将对象 a，b 使用了 toString（）方法进行了转换，然后再对属性赋值。
即：Object.prototype.toString.call(a) ==> [object Object]
因此，c = { [object Object]: 'demo1'} ==> c = {[object Object]: 'demo2' }

```js
var array1 = Array(3);
array1[0] = 2;
var result = array1.map(elem => '1');

// ['1', empty * 2]
```

```js
var setPerson = function(person) {
  person.name = 'kevin';
  person = { name: 'Nick' };
  console.log(person.name); // Nick
  person.name = 'Jay';
  console.log(person.name); // Jay
};
var person = { name: 'Alan' };
setPerson(person);
console.log(person.name); // Kevin
```

```js
var execFunc = () => console.log('a');
setTimeout(execFunc, 0);
console.log('000');
execFunc = () => console.log('b');

// '000', 'a'
```

`window.setTimeout(hello(userName),3000);`
这将使 hello 函数立即执行，并将'返回值'作为调用句柄传递给 setTimeout 函数

方法 1：
使用'字符串形式'可以达到想要的结果:
`window.setTimeout("hello(userName)",3000);`
但是，此处的 username 变量必须处于全局环境下

```js
// 方法2：
function hello(_name) {
  alert('hello,' + _name);
}
// 创建一个函数，用于返回一个无参数函数
function _hello(_name) {
  return function() {
    hello(_name);
  };
}
window.setTimeout(_hello(userName), 3000);
// 使用_hello(userName)来返回一个不带参数的函数句柄，从而实现了参数传递的功能
```

```js
for (var i = { j: 0 }; i.j < 5; i.j++) {
  (function(i) {
    setTimeout(function() {
      console.log(i.j);
    }, 0);
  })(JSON.parse(JSON.stringify(i)));
}

// 0, 1, 2, 3, 4

for (var i = { j: 0 }; i.j < 5; i.j++) {
  (function(i) {
    setTimeout(function() {
      console.log(i.j);
    }, 0);
  })(i);
}

// 5, 5, 5, 5, 5
```

```js
var name = 'Tom';
(function() {
  if (typeof name == 'undefined') {
    var name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
// Goodbye Jack
```

```js
var name = 'Tom';
(function() {
  if (typeof name == 'undefined') {
    name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

### 下面代码分别输出什么？

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // "this is a 'a'"
foo(); // "TypeError: Cannot read property 'a' of undefined
```

接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么?因为在本 例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。

bar() 调用使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined

### Scopes

```js
function passWordMngr() {
  var password = '12345678';
  this.userName = 'John';
  return {
    pwd: password,
  };
}
// Block End
var userInfo = passWordMngr();
console.log(userInfo.pwd);
console.log(userInfo.userName);
// 12345678 undefined
```

```js
var employeeId = 'aq123';
function Employee() {
  this.employeeId = 'bq1uy';
}
console.log(Employee.employeeId);
// undefined
```

```js
var employeeId = 'aq123';

function Employee() {
  this.employeeId = 'bq1uy';
}
console.log(new Employee().employeeId);
Employee.prototype.employeeId = 'kj182';
Employee.prototype.JobId = '1BJKSJ';
console.log(new Employee().JobId);
console.log(new Employee().employeeId);
// bq1uy 1BJKSJ bq1uy
```

```js
var employeeId = 'aq123';
(function Employee() {
  try {
    throw 'foo123';
  } catch (employeeId) {
    console.log(employeeId);
  }
  console.log(employeeId);
})();
// foo123 aq123
```

```js
// Call, Apply, Bind
(function() {
  var greet = 'Hello World';
  var toGreet = [].filter.call(greet, function(element, index) {
    return index > 5;
  });
  console.log(toGreet);
})();
// [ 'W', 'o', 'r', 'l', 'd' ]
```

```js
var output = (function(x) {
  delete x;
  return x;
})(0);

console.log(output);
// 0
// delete 只能用于删除对象的属性
```

```js
var x = 1;
var output = (function() {
  delete x;
  return x;
})();

console.log(output);
// 1
```

```js
var x = { foo: 1 };
var output = (function() {
  delete x.foo;
  return x.foo;
})();

console.log(output);
// undefined
```

```js
var Employee = {
  company: 'xyz',
};
var emp1 = Object.create(Employee);
delete emp1.company;
console.log(emp1.company);
// xyz
// 会去拿原型链上的属性
```

```js
var strA = 'hi there';
var strB = strA;
strB = 'bye there!';
console.log(strA);
// hi there
```

```js
var objA = { prop1: 42 };
var objB = objA;
objB.prop1 = 90;
console.log(objA);
// {prop1: 90}
```

```js
var objA = { prop1: 42 };
var objB = objA;
objB = {};
console.log(objA);
// {prop1: 42}
```

```js
var arrA = [0, 1, 2, 3, 4, 5];
var arrB = arrA;
arrB[0] = 42;
console.log(arrA);
// [42,1,2,3,4,5]
```

```js
var arrA = [0, 1, 2, 3, 4, 5];
var arrB = arrA.slice();
arrB[0] = 42;
console.log(arrA);
// [0,1,2,3,4,5]
```

```js
var arrA = [{ prop1: 'value of array A!!' }, { someProp: 'also value of array A!' }, 3, 4, 5];
var arrB = arrA;
arrB[0].prop1 = 42;
console.log(arrA);
// [{prop1: 42}, {someProp: "also value of array A!"}, 3,4,5]
```

```js
var arrA = [{ prop1: 'value of array A!!' }, { someProp: 'also value of array A!' }, 3, 4, 5];
var arrB = arrA.slice();
arrB[0].prop1 = 42;
arrB[3] = 20;
console.log(arrA);

// [{prop1: 42}, {someProp: "also value of array A!"}, 3,4,5]
function slice(arr) {
  var result = [];
  for (i = 0; i < arr.length; i++) {
    result.push(arr[i]);
  }
  return result;
}
```

```js
var trees = ['xyz', 'xxxx', 'test', 'ryan', 'apple'];
delete trees[3];
console.log(trees.length);
// 5
```

```js
var bar = true;
console.log(bar + 0);
console.log(bar + 'xyz');
console.log(bar + true);
console.log(bar + false);
// 1, "truexyz", 2, 1
```

```js
var z = 1,
  y = (z = typeof y);
console.log(y);
// undefined
```

```js
// NFE (Named Function Expression)
var foo = function bar() {
  return 12;
};
typeof bar();
// Reference Error
```

```js
bar();
(function abc() {
  console.log('something');
})();
function bar() {
  console.log('bar got called');
}
// bar got called
// something
```

```js
var salary = '1000$';

(function() {
  console.log('Original salary was ' + salary);

  var salary = '5000$';

  console.log('My New Salary ' + salary);
})();
// undefined, 5000$
```

```js
function User(name) {
  this.name = name || 'JsGeeks';
}

var person = (new User('xyz')['location'] = 'USA');
console.log(person);
// USA
```
