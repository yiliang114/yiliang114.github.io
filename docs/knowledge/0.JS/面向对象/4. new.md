---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### new 原理

- 创建一个新对象。
- 这个新对象会被执行[[原型]]连接。
- 将构造函数的作用域赋值给新对象，即 this 指向这个新对象.
- 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。
  字面量创建对象，不会调用 Object 构造函数, 简洁且性能更好;
  new Object() 方式创建对象本质上是方法调用，涉及到在 proto 链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式。
  通过对象字面量定义对象时，不会调用 Object 构造函数

模拟 new 实现：

```js
function Foo(name, age) {
  this.name = name;
  this.age = age;
}

var nar = new Foo('tom', 18);
console.log(nar.name);
function OBK() {
  var obj = new Object(), //从Object.prototype上克隆一个对象
    Constructor = [].shift.call(arguments); //取得外部传入的构造器

  var F = function() {};
  F.prototype = Constructor.prototype;
  obj = new F(); //指向正确的原型

  var ret = Constructor.apply(obj, arguments); //借用外部传入的构造器给obj设置属性

  return typeof ret === 'object' ? ret : obj; //确保构造器总是返回一个对象
}
var bar = OBK(Foo, 'jim', 15);
console.log(bar.age);
```

### new

new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？

在调用 `new` 的过程中会发生以上四件事情：

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 返回新对象

根据以上几个过程，我们也可以试着来自己实现一个 `new`

```js
function create() {
  let obj = {};
  let Con = [].shift.call(arguments);
  obj.__proto__ = Con.prototype;
  let result = Con.apply(obj, arguments);
  return result instanceof Object ? result : obj;
}
```

以下是对实现的分析：

- 创建一个空对象
- 获取构造函数
- 设置空对象的原型
- 绑定 `this` 并执行构造函数
- 确保返回值为对象

对于对象来说，其实都是通过 `new` 产生的，无论是 `function Foo()` 还是 `let a = { b : 1 }` 。

对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。

```js
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 };
// 这个字面量内部也是使用了 new Object()
```
