---
title: 设计模式
date: '2020-10-26'
draft: true
---

<!-- TODO: -->

单例模式、原型模式、工厂模式、观察者模式、策略模式、代理模式

### 单例模式

单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。核心就是保证全局只有一个对象可以访问。

在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex

```js
let Vue; // bind on install

export function install(_Vue) {
  if (Vue && _Vue === Vue) {
    // 如果发现 Vue 有值，就不重新创建实例了
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}
```

```js
const Singleton = function(name) {
  this.name = name;
  this.instance = null;
};

singleton.prototype.getName = function() {
  console.log(this.name);
};

singleton.getInstance = function(name) {
  if (!this.instance) {
    // 关键语句
    this.instance = new Singleton(name);
  }
  return this.instance;
};

// test
const a = singleton.getInstance('a'); // 通过 getInstance 来获取实例
const b = singleton.getInstance('b');
console.log(a === b);
```

### 工厂模式

工厂模式分为好几种，这里就不一一讲解了，以下是一个简单工厂模式的例子

```js
class Man {
  constructor(name) {
    this.name = name;
  }
  alertName() {
    alert(this.name);
  }
}

class Factory {
  static create(name) {
    return new Man(name);
  }
}

Factory.create('yiliang114').alertName();
```

当然工厂模式并不仅仅是用来 new 出**实例**。

可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。

工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。

在 Vue 源码中，你也可以看到工厂模式的使用，比如创建异步组件

```js
export function createComponent(
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag,
): VNode | Array<VNode> | void {
  // 逻辑处理...

  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data,
    undefined,
    undefined,
    undefined,
    context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory,
  );

  return vnode;
}
```

在上述代码中，我们可以看到我们只需要调用 `createComponent` 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。

### 适配器模式

适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。

以下是如何实现适配器模式的例子

```js
class Plug {
  getName() {
    return '港版插头';
  }
}

class Target {
  constructor() {
    this.plug = new Plug();
  }
  getName() {
    return this.plug.getName() + ' 适配器转二脚插头';
  }
}

let target = new Target();
target.getName(); // 港版插头 适配器转二脚插头
```

在 Vue 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 `computed` 来做转换这件事情，这个过程就使用到了适配器模式。

```js
/**
 * Created by lin on 2018/8/17.
 */
// 老接口
const oldCity = (function() {
  return [
    {
      name: 'hangzhou',
      id: 11,
    },
    {
      name: 'jinhua',
      id: 12,
    },
  ];
})();

// 新接口希望是下面形式
// {
//     hangzhou: 11,
//     jinhua: 12
// }

// 这时候就可采用适配者模式
const adaptor = function(oldCity) {
  const obj = {};
  for (const city of oldCity) {
    obj[city.name] = city.id;
  }
  return obj;
};

console.log(adaptor(oldCity));
```

### 代理模式

代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。

在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式。

因为存在太多的 `li`，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。

### 发布-订阅模式

发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。

在 Vue 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 `get` 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。

### TODO: 观察者模式

观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。而 js 中最常见的观察者模式就是事件触发机制。

```js
class EventEmitter {
  constructor() {
    this.eventPool = {
      //  'eventName': []
    };
  }
  listen(eventName, callback) {
    if (this.eventPool[eventName]) {
      if (this.eventPool[eventName].indexOf(callback) === -1) {
        this.eventPool[eventName].push(callback);
      }
    } else {
      this.eventPool[eventName] = [callback];
    }
  }
  // trigger 是有参数的
  trigger(eventName, ...args) {
    if (this.eventPool[eventName]) {
      this.eventPool[eventName].forEach(cb => cb(...args));
    }
  }
  remove(eventName, callback) {
    if (this.eventPool[eventName]) {
      let cbIndex = this.eventPool[eventName].indexOf(callback);
      this.eventPool[eventName].splice(cbIndex, 1);
    }
  }
  once(eventName, callback) {
    this.listen(eventName, function _cb(...args) {
      callback(...args);
      this.remove(eventName, _cb);
    });
  }
}
```
