---
title: 拷贝函数
date: 2020-10-26
draft: true
---

### 浅拷贝

- `Object.assign`
- 展开运算符 `...`
- for 循环方式， 手动复制属性

```js
function shallowCopy(p, c) {
  var c = c || {};
  for (var i = 0; i < p.length; i++) {
    c[i] = p[i];
  }
  return c;
}
```

数组的浅拷贝可以采用 `concat`, `slice` 以及 `...`

### 深拷贝

#### JSON.parse JSON.stringify

简单的做法：`JSON.parse(JSON.stringify(obj))`， 但是该方法也是有局限性的：

- 会忽略`undefined`
- 会忽略`symbol`
- 会忽略函数
- 不能解决循环引用的对象 （会报错）

#### MessageChannel

如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 `MessageChannel`。 这种方法有局限性，当属性值是函数的时候，会报错。

```js
function structuralClone(obj) {
  return new Promise(resolve => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = ev => resolve(ev.data);
    port1.postMessage(obj);
  });
}

var obj = {
  a: 1,
  b: {
    c: 2,
  },
};

obj.b.d = obj.b;

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () => {
  const clone = await structuralClone(obj);
  console.log(clone);
};
test();
```

### 自封装深拷贝

思路：

1. 使用 for-in 遍历对象
2. 因为 for-in 会遍历原型链上的属性，所以需要判断属性是否在原型链上，不是原型链才拷贝
3. 判断属性值类型是原始类型和引用类型
4. 原始类型直接赋值（注意 null）
5. 引用类型判断是对象还是数组，**创建对应的空对象或空数组**，递归调用函数，将值赋值进去
6. 包含环的情况

```js
function clone(obj) {
  var buf;
  if (obj instanceof Array) {
    buf = []; // 创建一个空的数组
    var i = obj.length;
    while (i--) {
      buf[i] = clone(obj[i]);
    }
    return buf;
  } else if (obj instanceof Object) {
    buf = {}; // 创建一个空对象
    for (var k in obj) {
      // 为这个对象添加新的属性
      buf[k] = clone(obj[k]);
    }
    return buf;
  } else {
    return obj;
  }
}
```

```js
function deepClone(origin, target) {
  target = target || {};
  for (let prop in origin) {
    //使用 for-in
    if (origin.hasOwnProperty(prop)) {
      //不是原型链上的
      if (typeof origin[prop] === 'object' && origin[prop]) {
        //是对象
        // 先判断是不是数组
        if (origin[prop] instanceof Array) {
          target[prop] = [];
          deepClone(origin[prop], target[prop]);
        }
        target[prop] = {};
        deepClone(origin[prop], target[prop]);
      } else {
        target[prop] = origin[prop];
      }
    }
  }
  return target;
}
```

```js
/**
 * 判断是否是基本数据类型
 * @param value
 */
function isPrimitive(value) {
  return (
    typeof value === 'string' || typeof value === 'number' || typeof value === 'symbol' || typeof value === 'boolean'
  );
}

/**
 * 判断是否是一个js对象
 * @param value
 */
function isObject(value) {
  return Object.prototype.toString.call(value) === '[object Object]';
}

/**
 * 深拷贝一个值
 * @param value
 */
function cloneDeep(value) {
  // 记录被拷贝的值，避免循环引用的出现
  let memo = {};

  function baseClone(value) {
    let res;
    // 如果是基本数据类型，则直接返回
    if (isPrimitive(value)) {
      return value;
      // 如果是引用数据类型，我们浅拷贝一个新值来代替原来的值
    } else if (Array.isArray(value)) {
      res = [...value];
    } else if (isObject(value)) {
      res = { ...value };
    }

    // 检测我们浅拷贝的这个对象的属性值有没有是引用数据类型。如果是，则递归拷贝
    Reflect.ownKeys(res).forEach(key => {
      if (typeof res[key] === 'object' && res[key] !== null) {
        //此处我们用memo来记录已经被拷贝过的引用地址。以此来解决循环引用的问题
        if (memo[res[key]]) {
          res[key] = memo[res[key]];
        } else {
          memo[res[key]] = res[key];
          res[key] = baseClone(res[key]);
        }
      }
    });
    return res;
  }

  return baseClone(value);
}
```
