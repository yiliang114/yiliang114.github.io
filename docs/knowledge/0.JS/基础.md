---
title: JS 基础
date: '2020-10-26'
draft: true
---

## 基本类型

### 数据类型

7 种原始类型（基本类型）：

1. Boolean
2. String
3. Number
4. Null
5. Undefined
6. Symbol（新定义）
7. BigInt（新定义）

引用类型：

1. Object
2. Array
3. Function
4. String (很多场景下 string 会被强制转化成 String 类型，但其实也是对象类型)

原始类型与引用类型存储的方式也不同，原始数据类型存储在栈中，而引用数据类型存储在堆中。

### 使用 typeof 能得到哪些类型？

1. boolean
2. number
3. string
4. undefined
5. symbol
6. object
7. function

typeof null 的结果是 object, 实际这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

### undefined, null, not defined 的区别

null 是一个赋值，可以赋值给一个表示该值的变量，它没有价值。undefined 表示已经声明了一个变量，但是还没有定义。null 表示一个对象被定义了，值为“空值”。not defined 表示该值未定义。

```js
console.log(y); // Output: ReferenceError: y is not defined
```

在验证 null 时，一定要使用　=== ，因为 == 无法分别 null 和　 undefined

### 0.1 + 0.2 === 0.3

JS 中的 number 类型是浮点类型

```js
0.1 + 0.2 === 0.3; // false
0.1 + 0.2; // 0.30000000000000004
```

原因：计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数，但不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差. 为了解决这个问题可以使用 toFixed()

```js
// 最简单的解决问题
(0.1 + 0.2).toFixed(10); // 0.3
// 0.1 + 0.2
// 0.8 - 0.2
// 0.1 + 0.7
```

为什么 `console.log(0.1)` 却是正确的呢？因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

```js
console.log(0.100000000000000002); // 0.1
```

#### 解决办法

自定义处理函数，放大指定的位数，最后再缩小。

```js
// f代表需要计算的表达式，digit代表小数位数
Math.formatFloat = function(f, digit) {
  // Math.pow(指数，幂指数)
  var m = Math.pow(10, digit);
  // Math.round（） 四舍五入
  return Math.round(f * m, 10) / m;
};
console.log(Math.formatFloat(0.3 * 8, 1)); // 2.4
console.log(Math.formatFloat(0.35 * 8, 2)); // 2.8
```

## 闭包

闭包就是函数中的函数，里面的函数可以访问外面函数的变量。

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。闭包参数和变量不会被垃圾回收机制回收，使用完了后，要立即释放资源，将引用变量指向 null。

### 闭包的使用场景

- 封装变量，收敛权限，模拟私有化。
- cached 对象储存。
- 柯里化参数处理

### 闭包优缺点

闭包封住了变量作用域，有效地防止了全局污染；但同时，它也存在**内存泄漏**的风险：

- 在浏览器端可以通过强制刷新解决，对用户体验影响不大
- 在服务端，由于 node 的内存限制和累积效应，可能会造成进程退出甚至服务器沓机

解决方法是显式对外暴露一个接口，专门用以清理变量。

### 循环中使用闭包解决 `var` 定义函数的问题

```js
for (var i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

解决方法有 3 种

第一种，使用`立即执行函数`方式

```js
for (var i = 1; i < 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

第二种，使用 ES6 的`let`, 因为对于 `let` 来说，他会创建一个块级作用域

```js
for (let i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

相当于

```js
{
  // 形成块级作用域
  let i = 0;
  {
    let ii = i;
    setTimeout(function timer() {
      console.log(ii);
    }, i * 1000);
  }
  i++;
  {
    let ii = i;
  }
  i++;
  {
    let ii = i;
  }
  // ...
}
```

第三种，使用 `setTimeout` 的第三个参数

```js
for (var i = 1; i < 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j);
    },
    i * 1000,
    i,
  );
}
```

## 类型转换

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

1. 转换为布尔值
1. 转换为数字
1. 转换为字符串

#### 转 Boolean

在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

#### 对象转原始类型

对象在转换类型的时候，会调用内置的 `ToPrimitive` 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
  [Symbol.toPrimitive]() {
    return 2;
  },
};
1 + a; // => 3
```

#### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

1. 运算中其中一方为字符串，那么就会把另一方也转换为字符串
1. 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + '1'; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
- 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
- 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

```js
'a' + +'b'; // -> "aNaN"
```

因为 + 'b' 等于 NaN，所以结果为 "aNaN"，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```js
4 * '3'; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

#### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
1. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
};
a > -1; // true
```

在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。

#### 对象到字符串的转换步骤

1. 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果
2. 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果
3. 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError

#### 对象到数字的转换步骤

1. 如果对象有 valueOf()方法并且返回元素值，javascript 将返回值转换为数字作为结果
2. 否则，如果对象有 toString()并且返回原始值，javascript 将返回结果转换为数字作为结果
3. 否则，throws a TypeError

#### <,>,<=,>=的比较规则

所有比较运算符都支持任意类型，但是**比较只支持数字和字符串**，所以需要执行必要的转换然后进行比较，转换规则如下:

1. 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错
2. 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）
3. 否则，如果有一个操作数不是字符串，**将两个操作数转换为数字**进行比较

#### +运算符工作流程

1. 如果有操作数是对象，转换为原始值
2. 此时如果有**一个操作数是字符串**，其他的操作数都转换为字符串并执行连接
3. 否则：**所有操作数都转换为数字并执行加法**

```js
'100' + 100; // "100100"
100 + '100'; // "100100"
100 + true; // 101
100 + false; // 100
100 + undefined; //NaN
100 + null; // 100
// + 会自动转换后面跟随的值类型
```

### 原始类型转化

当我们对一个“对象”进行数学运算操作时候，会涉及到对象 => 基础数据类型的转化问题。

事实上，当一个对象执行例如加法操作的时候，如果它是原始类型，那么就不需要转换。否则，将遵循以下规则：

1. 调用实例的`valueOf()`方法，如果有返回的是基础类型，停止下面的过程；否则继续
2. 调用实例的`toString()`方法，如果有返回的是基础类型，停止下面的过程；否则继续
3. 都没返回原始类型，就会报错

请看下面的测试代码：

```js
let a = {
  toString: function() {
    return 'a';
  },
};

let b = {
  valueOf: function() {
    return 100;
  },
  toString: function() {
    return 'b';
  },
};

let c = Object.create(null); // 创建一个空对象

console.log(a + '123'); // output: a123
console.log(b + 1); // output: 101
console.log(c + '123'); // 报错
```

除了`valueOf`和`toString`，es6 还提供了`Symbol.toPrimitive`供对象向原始类型转化，并且**它的优先级最高**！！稍微改造下上面的代码：

```js
let b = {
  valueOf: function() {
    return 100;
  },
  toString: function() {
    return 'b';
  },
  [Symbol.toPrimitive]: function() {
    return 10000;
  },
};

console.log(b + 1); // output: 10001
```

最后，其实关于`instanceof`判断是否是某个对象的实例，es6 也提供了`Symbol.hasInstance`接口，代码如下：

```js
class Even {
  static [Symbol.hasInstance](num) {
    return Number(num) % 2 === 0;
  }
}

const Odd = {
  [Symbol.hasInstance](num) {
    return Number(num) % 2 !== 0;
  },
};

console.log(1 instanceof Even); // output: false
console.log(1 instanceof Odd); // output: true
```

### js 中的 boolean number 互转

```js
~~false === 0;
~~true === 1;
~~undefined === 0;
~~!undefined === 1;
~~null === 0;
~~!null === 1;
~~'' === 0;
~~!'' === 1;
```

### == 运算符判断相等的流程是怎样的

对于 `==` 来说，如果对比双方的类型**不一样**的话，就会进行**类型转换**.

**`null` 只和`undefined` 相等，有 `number` 都转 `number`，有 `boolean` 也转 `number`，有 `string` 都转 `string`，对象互相不等，`NaN` 互相不等就可以了**

1. 如果两个值类型相同，按照 `===` 比较方法进行比较
2. 如果类型不同，使用如下规则进行比较
3. 如果其中一个值是 null，另一个是 undefined，它们相等
4. 如果一个值是**数字**另一个是**字符串**，将**字符串转换为数字**进行比较
5. 如果有布尔类型，将**true 转换为 1，false 转换为 0**，然后用 `==` 规则继续比较
6. 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用 `==` 规则继续比较
7. **其他所有情况都认为不相等**

## 变量声明

### 赋值

#### 函数名与变量名同名

```js
var foo = 1;
function bar() {
  foo = 10;
  return;
  function foo() {}
}
bar();
alert(foo);
```

- 1
- 10
- Function
- undefined
- Error

答案：1，function 的定义会提前到当前作用域之前，所以等同于：

```js
var foo = 1;
function bar() {
  function foo() {}
  foo = 10;
  return;
}
bar();
alert(foo);
```

所以，在 foo=10 的时候，foo 是有定义的，属于局部变量，影响不到外层的 foo。

```js
function bar() {
  return foo;
  foo = 10;
  function foo() {}
  var foo = 11;
}
alert(typeof bar());
```

- number
- function
- undefined
- Error

答案：function，与上题类似，等同于：

```js
function bar() {
  function foo() {}
  return foo;
  foo = 10;
  var foo = 11;
}
alert(typeof bar());
```

在 return 之后声明和赋值的 foo 都无效，所以返回了 function。

补充，这个解答有问题：

> @尤里卡 Eureka：JS 中 function 声明和 var 声明都会被提前，最终得到结果为 function，是因为*名称解析顺序-Name Resolution Order*(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~

```js
function SINA() {
  return 1;
}
var SINA;
console.log(typeof SINA); // function
```

#### 数组长度

```js
var arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr.foo = 'c';
alert(arr.length);
```

答案：2，数组的原型是 Object，所以可以像其他类型一样附加属性，不影响其固有性质。

#### arguments

```js
function foo(a) {
  arguments[0] = 2;
  alert(a);
}
foo(1);
```

答案：2，实参可以直接从 arguments 数组中修改。

## TODO: 模块化

使用模块化可以给我们带来以下好处

1. 解决命名冲突
2. 提供复用性
3. 提高代码可维护性

实现模块化方式：

1. **立即执行函数**：在一个单独的函数作用域中执行代码，避免变量冲突。
2. **CommonJs**：同步加载，主要用在服务器端 node 。输出的是值拷贝。
3. **AMD**：异步加载。`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
4. **CMD**：异步加载。`seajs` 在推广过程中对模块定义的规范化产出，支持动态引入依赖文件延迟执行，推崇依赖就近。
5. **UMD**：兼容 AMD 和 commonJS 规范的同时，还兼容全局引用的方式。能够运行在浏览器或服务器环境。
6. **ES6 Module**：ES6 模块。模块输出的是一个值的引用，编译时输出接口。

### import 和 require 导入的区别

关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。

### require 有什么性能问题

值拷贝

### UMD

UMD 的实现很简单：

1. 先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。
2. 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。
3. 前两个都不存在，则将模块公开到全局（window 或 global）。

### ES Module 与 CommonJS 的区别

按照 ES Modules 的标准，这里的 index.html 可以直接在浏览器中正常工作，但是对于不支持 ES Modules 标准的浏览器，直接使用就会出现错误，所以我们需要使用 Webpack 这样的工具，将我们这里按照模块化方式拆分的 JS 代码再次打包到一起。

1. ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 模块，运行时加载。
2. CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响。
3. ES6 模块自动采用严格模式，无论模块头部是否写了 "use strict";
4. require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。
5. ES6 模块中顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。
6. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化

## JS 会出现的 Error

### ReferenceError

如果 RHS 查询（取值查询）在所有前台的作用域中找寻不到所需的变量，引擎就会抛出`ReferenceError`异常

没有声明的变量直接使用就会报 ReferenceError 错

```js
console.log(employeeId);
// ReferenceError: employeeId is not defined
```

### Cannot access 'b' before initialization

如果往外寻找变量能够找到，但是因为变量未提升，先使用后声明就会报错。但是如果变量能够提升，就会输出 undefined。

```js
function func() {
  function a() {
    console.log(b);
  }
  a();
  const b = 'bbb';
}
func();
// Cannot access 'b' before initialization
```

```js
var a = 100;
if (1) {
  a = 10;
  // 在当前块作用域中存在 a 使用 let/const 声明的情况下，给 a 赋值 10 时，只会在当前作用域找变量 a，
  // 而这时，还未到声明时候，所以控制台 ReferenceError: Cannot access 'a' before initialization
  let a = 1;
}
```

变量声明会提升， 赋值不会提升。

```js
console.log(employeeId);
var employeeId = '19000';
// undefined

(function() {
  console.log(typeof displayFunc);
  var displayFunc = function() {
    console.log('Hi I am inside displayFunc');
  };
})();
// undefined
```

内外作用域有同名的变量，就近原则。

```js
var employeeId = '1234abe';
(function() {
  console.log(employeeId);
  var employeeId = '122345';
})();
// undefined

var employeeId1 = '1234abe';
(function() {
  console.log(employeeId1);
  var employeeId1 = '122345';
  (function() {
    var employeeId1 = 'abc1234';
  })();
})();
// undefined
```

### TypeError

TypeError: Assignment to constant variable

常量的值在设定之后就不能再更改。

```js
const a = 2;
a = 3; // TypeError: Assignment to constant variable.
```

TypeError`则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。比如视图对一个非函数类型的值进行函数调用，或者引用`null`或`undefined`类型的值中的属性，那么引擎会抛出类型异常，`TypeError`.

## 基础

### ES5

- 基本数据类型，判断数据类型。
- 原型、原型链。 整个完整链路。 instanceof 原理
- 闭包
- 创建对象有几种方法
- 事件冒泡和事件捕获以及事件委托
- 继承的方式， new 做了什么操作。new 生成一个对象的过程和原理
- 作用域和闭包，执行上下文(变量提升)、this、闭包是什么
- this 指向，几种使用场景。改变 this 的方式和优先级
- 事件循环模型，执行栈和任务队列，宏任务、微任务，具体的代码卡死执行
- DOM 事件流，DOM 事件的级别，捕获、冒泡（流程）。事件代理，currentTarget 和 target
- 异步。同步 vs 异步，异步和单线程，前端异步的场景
- 模块化 AMD CMD Commonjs UMD ES Module
- 手写深拷贝函数（包含环的情况）
- 箭头函数与普通函数的区别
- let const var 区别
- 0.1+0.2 等于多少，精度丢失的原因

#### 基本数据类型

7 种。 number, boolean, string, undefined, null, symbol, bigint

typeof 能够得到的值, 8 种: number, boolean, string, undefined, symbol, object, function, bigint

#### JS 事件流

##### DOM 事件流

一个完整的事件流分三个阶段：捕获、目标阶段、冒泡。

##### 事件冒泡和事件捕获

事件流分为：**冒泡**和**捕获**，顺序是先捕获再冒泡。冒泡是目标元素向上，捕获是从上往下。

**事件冒泡**：子元素的触发事件会一直向父节点传递，一直到根结点停止。此过程中，可以在每个节点捕捉到相关事件。可以通过 `stopPropagation` 方法终止冒泡。

**事件捕获**：和“事件冒泡”相反，从根节点开始执行，一直向子节点传递，直到目标节点。

`addEventListener`给出了第三个参数同时支持冒泡与捕获：默认是`false`，事件冒泡；设置为`true`时，是事件捕获。

##### 描述 DOM 事件捕获的具体流程

捕获是从上到下的过程。 第一个接触到的对象是 window, 接着是 document, 再是 html 标签，接着是 body 元素，再一层一层父级元素，最后到目标元素。获取 body 标签 `document.body` ， 或者 html 标签 `document.documentElement`.

##### DOM 事件的级别

**DOM3 级**：增加了很多事件类型
**DOM2 级**：前面说的`addEventListener`，它定义了`DOM`事件流，捕获 + 冒泡。
**DOM0 级**：

- 直接在 html 标签内绑定`on`事件
- 在 JS 中绑定`on`系列事件

**注意**：现在通用`DOM2`级事件，优点如下：

1. 可以绑定 / 卸载事件
2. 支持事件流
3. 冒泡 + 捕获：相当于每个节点同一个事件，至少 2 次处理机会
4. 同一类事件，可以绑定多个函数

##### Event 对象的常见应用

```js
event.preventDefault(); // 阻止默认事件，比如阻止 a 标签的跳转行为
event.stopPropagation(); // 阻止冒泡。

event.stopImmediatePropagation(); // 如果一个对象绑定了两个函数，一般来说两个函数会被依次执行。 如果在回调函数 A 中调用 stopImmediatePropagation 之后就不会再执行回调函数 B 了。

// 事件委托（代理） 只做一次绑定。
event.currentTarget; // 当前绑定事件的元素
event.target; // 当前被点击的元素
```

##### 事件委托和使用

#### Event Loop

##### 单线程

> 题目：讲解下面代码的执行过程和结果。

```js
var a = true;
setTimeout(function() {
  a = false;
}, 100);
while (a) {
  console.log('while执行了');
}
```

这段代码会一直执行并且输出 "while..."。**JS 是单线程的，先跑执行栈里的同步任务，然后再跑任务队列的异步任务**。

##### 执行栈和任务队列

> 题目：说一下 JS 的 Event Loop。

简单总结如下：

1. JS 是单线程的，其上面的所有任务都是在两个地方执行：**执行栈和任务队列**。前者是存放同步任务；后者是异步任务有结果后，就在其中放入一个事件。
2. 当执行栈的任务都执行完了（栈空），js 会读取任务队列，并将可以执行的任务从任务队列丢到执行栈中执行。
3. 这个过程是循环进行，所以称作`Loop`。

##### 微任务和宏任务

异步事件会被放置到对应的宏任务队列或者微任务队列中去，当执行栈为空的时候，主线程会首先查看微任务中的事件，如果微任务不是空的那么执行微任务中的事件，如果没有，则在宏任务中取出最前面的一个事件。把对应的回调加入当前执行栈...如此反复，进入循环。

浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。**宏任务队列可以有多个，微任务队列只有一个**。

- 常见的 macro-task 比如：setTimeout、setInterval、setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。
- 常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5 新特性)、process.nextTick 等。

Node 中的 Event Loop：

分为 6 个阶段，它们会按照**顺序**反复运行。timer, I/O, (idle, prepare), poll(循环 1, 2), check, close callbacks

##### setTimeout

setTimeout 设定为 0ms 会直接执行吗，如果设置为 5s 会一定在 5s 后执行吗

#### 异步 与 Promise

#### 判断数据类型

1. `typeof`
2. `instanceof`
3. `Object.prototype.toString.call()`
4. 对于数组的判断，还可以使用`Array.isArray()`

性能方面：判断数据 Array.isArray() 性能最好，instanceof 次之，Object.prototype.toString.call() 第三
功能方面：`Object.prototype.toString.call()` 所有的类型都可以判断, 可以理解为是 100% 准确。

`Object.prototype.toString.call()` 能够得到的值, 8 种: number, boolean, string, undefined, symbol, object, function, bigint。

#### 其他

- 浅拷贝
- 深拷贝
- 错误监控
- 跨域

### ES6

- 新特性
- var 与 const/let 的区别
- 箭头函数
- 模块化，演进， 几种方式的差别。
- Module
- Class
- Set 和 Map. set、map 介绍；和数组、对象的区别
- Promise. 异步与 Promise，执行顺序问题。异步的演变方式，async await。
- es5 和 es6 继承有哪些不同？

## 变量提升

`js` 代码在运行前都会进行 `AST` 解析，函数声明默认会提到当前作用域最前面，变量声明也会进行提升。使用`var`关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。但赋值不会得到提升。

```js
// 用 var 声明得到提升
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// 用 let/const 声明不会提升
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。

```js
// 函数声明
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// 函数表达式
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```

**变量声明优先级**

- function 声明的优先级高于 var 声明。也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明
- var 声明并赋值或者单纯赋值优先级高于 function 声明优先于函数声明,

总结：

- 在 JavaScript 中，函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部
- 声明语句中的赋值部分并不会被提升，只有名称被提升
- 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明
- 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数

```js
if (!('sina' in window)) {
  var sina = 1;
}
console.log('sina:', sina); // undefined
```

> 由于 JavaScript 在编译阶段会对声明进行提升，所以上述代码会做如下处理：

```js
var sina;
if (!('sina' in window)) {
  sina = 1;
}
console.log('sina:', sina);
```

>  声明被提升后，`window.sina`的值就是 undefined，但是`!("sina" in window)`这段代码的运行结果是`true`，所以`sina = 1;`就不会被执行，所以  本题目的输出结果是`undefined`。

```js
var a = 10;
(function() {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

针对这题，在知乎上看到别人的回答说：

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。
2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。
3. IIFE 中的函数是函数表达式，而不是函数声明。

实际上，有点类似于以下代码，但不完全相同，因为使用 const 不管在什么模式下，都会 TypeError 类型的错误

```js
const foo = (function() {
  foo = 10;
  console.log(foo);
})(foo)(); // Uncaught TypeError: Assignment to constant variable.
```

我的理解是，b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."
例如下面的：

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

### 题目

```js
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}
sayHi();
// undefined 和 ReferenceError
```

```js
let name = 'ConardLi';
{
  console.log(name); // Uncaught ReferenceError: name is not defined
  // Uncaught ReferenceError: Cannot access 'name' before initialization
  let name = 'code秘密花园';
}
```

```js
var employeeId = 'abc123';

function foo() {
  employeeId = '123bcd';
  return;

  function employeeId() {}
}
foo();
console.log(employeeId);
// abc123
```

```js
var employeeId = 'abc123';

function foo() {
  employeeId();
  return;

  function employeeId() {
    console.log(typeof employeeId);
  }
}
foo();
// function
```

```js
// TODO:
function foo() {
  employeeId();
  var product = 'Car';
  return;

  function employeeId() {
    console.log(product);
  }
}
foo();
// undefined
```

```js
// TODO:
(function() {
  var objA = Object.create({
    foo: 'foo',
  });
  var objB = objA;
  objB.foo = 'bar';

  delete objA.foo;
  console.log(objA.foo);
  console.log(objB.foo);
})();
// foo foo
```

```js
(function() {
  var objA = {
    foo: 'foo',
  };
  var objB = objA;
  objB.foo = 'bar';

  delete objA.foo;
  console.log(objA.foo);
  console.log(objB.foo);
})();
// undefined undefined
```

```js
(function() {
  var array = new Array('100');
  console.log(array);
  console.log(array.length);
})();
// ["100"] 1
```

```js
(function() {
  var array1 = [];
  var array2 = new Array(100);
  var array3 = new Array(['1', 2, '3', 4, 5.6]);
  console.log(array1);
  console.log(array2);
  console.log(array3);
  console.log(array3.length);
})();
// [] [] [Array[5]] 1
```

```js
(function() {
  var array = new Array('a', 'b', 'c', 'd', 'e');
  array[10] = 'f';
  delete array[10];
  console.log(array.length);
})();
// 11
```

```js
function funcA() {
  console.log('funcA ', this);
  (function innerFuncA1() {
    console.log('innerFunc1', this);
    (function innerFunA11() {
      console.log('innerFunA11', this);
    })();
  })();
}

console.log(funcA());
// funcA  Window {...}
// innerFunc1 Window {...}
// innerFunA11 Window {...}
```

```js
var obj = {
  message: 'Hello',
  innerMessage: !(function() {
    console.log(this.message);
  })(),
};

console.log(obj.innerMessage);
// undefined
// true
```

```js
var obj = {
  message: 'Hello',
  innerMessage: function() {
    return this.message;
  },
};

console.log(obj.innerMessage());
// Hello
```

```js
var obj = {
  message: 'Hello',
  innerMessage: function() {
    // 直接是 window 调用的该函数
    (function() {
      console.log(this.message);
    })();
  },
};
console.log(obj.innerMessage());
// undefined
```

```js
var obj = {
  message: 'Hello',
  innerMessage: function() {
    var self = this;
    (function() {
      console.log(self.message);
    })();
  },
};
console.log(obj.innerMessage());
// Hello
```

```js
function myFunc(param1, param2) {
  console.log(myFunc.length);
}
console.log(myFunc());
console.log(myFunc('a', 'b'));
console.log(myFunc('a', 'b', 'c', 'd'));
// 2 2 2
```

```js
function myFunc() {
  console.log(arguments.length);
}
console.log(myFunc());
console.log(myFunc('a', 'b'));
console.log(myFunc('a', 'b', 'c', 'd'));
// 0 2 4
```

```js
function Person(name, age) {
  this.name = name || 'John';
  this.age = age || 24;
  this.displayName = function() {
    console.log(this.name);
  };
}

Person.name = 'John';
Person.displayName = function() {
  // this 指向 Person 对象（函数）的函数名： Person
  console.log(this.name);
};

var person1 = new Person('John');
person1.displayName();
Person.displayName();

// John Person
```

### 变量与函数同名的情况

```js
var a = 10;
(function() {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})(); //[Function b]
```

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。
在严格模式下 b 函数相当于常量，无法进行重新赋值，在非严格模式下函数声明优先变量声明

#### 简单改造下面的代码，使之分别打印 10 和 20

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

- 打印 20

```js
var b = 10;
(function b() {
  var b = 20;
  console.log(b);
})(); // 20 在自执行函数中重新定义一个变量，
```

```js
var b = 10;
(function a() {
  b = 20;
  console.log(b);
})();
```

```js
var b = 10;
(function() {
  b = 20;
  console.log(b);
})();
```

- 打印 10

```js
var b = 10;
(function b() {
  b = 20;
  console.log(window.b);
})();
```

在自执行函数中访问 window，window 中的 b 值为 10 2.

```js
var b = 10;
(function() {
  console.log(b);
  b = 20;
})();
```

```js
var b = 10;
(function b(b) {
  console.log(b);
  b = 20;
})(b);
```

### 作用域

```js
var foo = 'Hello';
(function() {
  var bar = ' World';
  alert(foo + bar);
})();
alert(foo + bar);

// "Hello World" 和 ReferenceError: bar is not defined
```

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

// 3 3 3 and 0 1 2
```

```js
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();

// ReferenceError
```

### 构造函数

```js
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
freddie.colorChange('orange');

// TypeError
```

```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
// 非原型链
Person.getFullName = () => this.firstName + this.lastName;

// member.getFullName === undefined
console.log(member.getFullName());

// TypeError
```

```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);

// Person {firstName: "Lydia", lastName: "Hallie"} and undefined
```

```js
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

name.giveLydiaPizza();
('Just give Lydia pizza already!');
```

### 函数

```js
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;

// ["", " is ", " years old"] Lydia 21
```

### 对象

```js
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);

// 456
```

### return value

```js
function getNumber() {
  return 2, 4, 5;
}

var numb = getNumber();
console.log(numb);
// 5 最后一个值就是 return 回的值
```

```js
(function() {
  function sayHello() {
    var name = 'Hi John';
    return;
    {
      fullName: name;
    }
  }
  console.log(sayHello().fullName);
})();
// 需要在同一行
// Uncaught TypeError: Cannot read property 'fullName' of undefined
```

### sort 函数

```js
(function() {
  var arrayNumb = [2, 8, 15, 16, 23, 42];
  arrayNumb.sort();
  console.log(arrayNumb);
})();
// [ 15, 16, 2, 23, 42, 8 ]
```
