---
title: JS 基础
date: '2020-10-26'
draft: true
---

## 基本类型

### 数据类型

7 种原始类型（基本类型）：

1. Boolean
2. String
3. Number
4. Null
5. Undefined
6. Symbol（新定义）
7. BigInt（新定义）

引用类型：

1. Object
2. Array
3. Function
4. String (很多场景下 string 会被强制转化成 String 类型，但其实也是对象类型)

原始类型与引用类型存储的方式也不同，原始数据类型存储在栈中，而引用数据类型存储在堆中。

### 使用 typeof 能得到哪些类型？

1. boolean
2. number
3. string
4. undefined
5. symbol
6. object
7. function

typeof null 的结果是 object, 实际这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

### undefined, null, not defined 的区别

null 是一个赋值，可以赋值给一个表示该值的变量，它没有价值。undefined 表示已经声明了一个变量，但是还没有定义。null 表示一个对象被定义了，值为“空值”。not defined 表示该值未定义。

```js
console.log(y); // Output: ReferenceError: y is not defined
```

在验证 null 时，一定要使用　=== ，因为 == 无法分别 null 和　 undefined

### 0.1 + 0.2 === 0.3

JS 中的 number 类型是浮点类型

```js
0.1 + 0.2 === 0.3; // false
0.1 + 0.2; // 0.30000000000000004
```

原因：计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数，但不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差. 为了解决这个问题可以使用 toFixed()

```js
// 最简单的解决问题
(0.1 + 0.2).toFixed(10); // 0.3
// 0.1 + 0.2
// 0.8 - 0.2
// 0.1 + 0.7
```

为什么 `console.log(0.1)` 却是正确的呢？因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

```js
console.log(0.100000000000000002); // 0.1
```

## 闭包

闭包就是函数中的函数，里面的函数可以访问外面函数的变量。

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。闭包参数和变量不会被垃圾回收机制回收，使用完了后，要立即释放资源，将引用变量指向 null。

### 闭包的使用场景

- 封装变量，收敛权限，模拟私有化。
- cached 对象储存。
- 柯里化参数处理

### 闭包优缺点

闭包封住了变量作用域，有效地防止了全局污染；但同时，它也存在**内存泄漏**的风险：

- 在浏览器端可以通过强制刷新解决，对用户体验影响不大
- 在服务端，由于 node 的内存限制和累积效应，可能会造成进程退出甚至服务器沓机

解决方法是显式对外暴露一个接口，专门用以清理变量。

### 循环中使用闭包解决 `var` 定义函数的问题

```js
for (var i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

解决方法有 3 种

第一种，使用`立即执行函数`方式

```js
for (var i = 1; i < 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

第二种，使用 ES6 的`let`, 因为对于 `let` 来说，他会创建一个块级作用域

```js
for (let i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

相当于

```js
{
  // 形成块级作用域
  let i = 0;
  {
    let ii = i;
    setTimeout(function timer() {
      console.log(ii);
    }, i * 1000);
  }
  i++;
  {
    let ii = i;
  }
  i++;
  {
    let ii = i;
  }
  // ...
}
```

第三种，使用 `setTimeout` 的第三个参数

```js
for (var i = 1; i < 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j);
    },
    i * 1000,
    i,
  );
}
```

## 类型转换

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

1. 转换为布尔值
1. 转换为数字
1. 转换为字符串

#### 转 Boolean

在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

#### 对象转原始类型

对象在转换类型的时候，会调用内置的 `ToPrimitive` 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
  [Symbol.toPrimitive]() {
    return 2;
  },
};
1 + a; // => 3
```

#### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

1. 运算中其中一方为字符串，那么就会把另一方也转换为字符串
1. 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + '1'; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
- 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
- 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

```js
'a' + +'b'; // -> "aNaN"
```

因为 + 'b' 等于 NaN，所以结果为 "aNaN"，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```js
4 * '3'; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

#### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
1. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
};
a > -1; // true
```

在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。

#### 对象到字符串的转换步骤

1. 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果
2. 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果
3. 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError

#### 对象到数字的转换步骤

1. 如果对象有 valueOf()方法并且返回元素值，javascript 将返回值转换为数字作为结果
2. 否则，如果对象有 toString()并且返回原始值，javascript 将返回结果转换为数字作为结果
3. 否则，throws a TypeError

#### <,>,<=,>=的比较规则

所有比较运算符都支持任意类型，但是**比较只支持数字和字符串**，所以需要执行必要的转换然后进行比较，转换规则如下:

1. 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错
2. 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）
3. 否则，如果有一个操作数不是字符串，**将两个操作数转换为数字**进行比较

#### +运算符工作流程

1. 如果有操作数是对象，转换为原始值
2. 此时如果有**一个操作数是字符串**，其他的操作数都转换为字符串并执行连接
3. 否则：**所有操作数都转换为数字并执行加法**

```js
'100' + 100; // "100100"
100 + '100'; // "100100"
100 + true; // 101
100 + false; // 100
100 + undefined; //NaN
100 + null; // 100
// + 会自动转换后面跟随的值类型
```

### 原始类型转化

当我们对一个“对象”进行数学运算操作时候，会涉及到对象 => 基础数据类型的转化问题。

事实上，当一个对象执行例如加法操作的时候，如果它是原始类型，那么就不需要转换。否则，将遵循以下规则：

1. 调用实例的`valueOf()`方法，如果有返回的是基础类型，停止下面的过程；否则继续
2. 调用实例的`toString()`方法，如果有返回的是基础类型，停止下面的过程；否则继续
3. 都没返回原始类型，就会报错

请看下面的测试代码：

```js
let a = {
  toString: function() {
    return 'a';
  },
};

let b = {
  valueOf: function() {
    return 100;
  },
  toString: function() {
    return 'b';
  },
};

let c = Object.create(null); // 创建一个空对象

console.log(a + '123'); // output: a123
console.log(b + 1); // output: 101
console.log(c + '123'); // 报错
```

除了`valueOf`和`toString`，es6 还提供了`Symbol.toPrimitive`供对象向原始类型转化，并且**它的优先级最高**！！稍微改造下上面的代码：

```js
let b = {
  valueOf: function() {
    return 100;
  },
  toString: function() {
    return 'b';
  },
  [Symbol.toPrimitive]: function() {
    return 10000;
  },
};

console.log(b + 1); // output: 10001
```

最后，其实关于`instanceof`判断是否是某个对象的实例，es6 也提供了`Symbol.hasInstance`接口，代码如下：

```js
class Even {
  static [Symbol.hasInstance](num) {
    return Number(num) % 2 === 0;
  }
}

const Odd = {
  [Symbol.hasInstance](num) {
    return Number(num) % 2 !== 0;
  },
};

console.log(1 instanceof Even); // output: false
console.log(1 instanceof Odd); // output: true
```

### js 中的 boolean number 互转

```js
~~false === 0;
~~true === 1;
~~undefined === 0;
~~!undefined === 1;
~~null === 0;
~~!null === 1;
~~'' === 0;
~~!'' === 1;
```

### == 运算符判断相等的流程是怎样的

对于 `==` 来说，如果对比双方的类型**不一样**的话，就会进行**类型转换**.

**`null` 只和`undefined` 相等，有 `number` 都转 `number`，有 `boolean` 也转 `number`，有 `string` 都转 `string`，对象互相不等，`NaN` 互相不等就可以了**

1. 如果两个值类型相同，按照 `===` 比较方法进行比较
2. 如果类型不同，使用如下规则进行比较
3. 如果其中一个值是 null，另一个是 undefined，它们相等
4. 如果一个值是**数字**另一个是**字符串**，将**字符串转换为数字**进行比较
5. 如果有布尔类型，将**true 转换为 1，false 转换为 0**，然后用 `==` 规则继续比较
6. 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用 `==` 规则继续比较
7. **其他所有情况都认为不相等**

## 变量声明

### 变量提升

`js` 代码在运行前都会进行 `AST` 解析，函数声明默认会提到当前作用域最前面，变量声明也会进行提升。使用`var`关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。但赋值不会得到提升。

```js
// 用 var 声明得到提升
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// 用 let/const 声明不会提升
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。

```js
// 函数声明
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// 函数表达式
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```

**变量声明优先级**

- function 声明的优先级高于 var 声明。也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明
- var 声明并赋值或者单纯赋值优先级高于 function 声明优先于函数声明,

### 赋值

#### 函数名与变量名同名

```js
var foo = 1;
function bar() {
  foo = 10;
  return;
  function foo() {}
}
bar();
alert(foo);
```

- 1
- 10
- Function
- undefined
- Error

答案：1，function 的定义会提前到当前作用域之前，所以等同于：

```js
var foo = 1;
function bar() {
  function foo() {}
  foo = 10;
  return;
}
bar();
alert(foo);
```

所以，在 foo=10 的时候，foo 是有定义的，属于局部变量，影响不到外层的 foo。

```js
function bar() {
  return foo;
  foo = 10;
  function foo() {}
  var foo = 11;
}
alert(typeof bar());
```

- number
- function
- undefined
- Error

答案：function，与上题类似，等同于：

```js
function bar() {
  function foo() {}
  return foo;
  foo = 10;
  var foo = 11;
}
alert(typeof bar());
```

在 return 之后声明和赋值的 foo 都无效，所以返回了 function。

补充，这个解答有问题：

> @尤里卡 Eureka：JS 中 function 声明和 var 声明都会被提前，最终得到结果为 function，是因为*名称解析顺序-Name Resolution Order*(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~

```js
function SINA() {
  return 1;
}
var SINA;
console.log(typeof SINA); // function
```

#### 数组长度

```js
var arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr.foo = 'c';
alert(arr.length);
```

答案：2，数组的原型是 Object，所以可以像其他类型一样附加属性，不影响其固有性质。

#### arguments

```js
function foo(a) {
  arguments[0] = 2;
  alert(a);
}
foo(1);
```

答案：2，实参可以直接从 arguments 数组中修改。

## 模块化

使用模块化可以给我们带来以下好处

1. 解决命名冲突
2. 提供复用性
3. 提高代码可维护性

实现模块化方式：

1. **立即执行函数**：在一个单独的函数作用域中执行代码，避免变量冲突。
2. **CommonJs**：同步加载，主要用在服务器端 node 。输出的是值拷贝。
3. **AMD**：异步加载。`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
4. **CMD**：异步加载。`seajs` 在推广过程中对模块定义的规范化产出，支持动态引入依赖文件延迟执行，推崇依赖就近。
5. **UMD**：兼容 AMD 和 commonJS 规范的同时，还兼容全局引用的方式。能够运行在浏览器或服务器环境。
6. **ES6 Module**：ES6 模块。模块输出的是一个值的引用，编译时输出接口。

### UMD

UMD 的实现很简单：

1. 先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。
2. 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。
3. 前两个都不存在，则将模块公开到全局（window 或 global）。

### ES Module 与 CommonJS 的区别

按照 ES Modules 的标准，这里的 index.html 可以直接在浏览器中正常工作，但是对于不支持 ES Modules 标准的浏览器，直接使用就会出现错误，所以我们需要使用 Webpack 这样的工具，将我们这里按照模块化方式拆分的 JS 代码再次打包到一起。

1. ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 模块，运行时加载。
2. CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响。
3. ES6 模块自动采用严格模式，无论模块头部是否写了 "use strict";
4. require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。
5. ES6 模块中顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。
6. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化

## JS 会出现的 Error

### ReferenceError

如果 RHS 查询（取值查询）在所有前台的作用域中找寻不到所需的变量，引擎就会抛出`ReferenceError`异常

没有声明的变量直接使用就会报 ReferenceError 错

```js
console.log(employeeId);
// ReferenceError: employeeId is not defined
```

### Cannot access 'b' before initialization

如果往外寻找变量能够找到，但是因为变量未提升，先使用后声明就会报错。但是如果变量能够提升，就会输出 undefined。

```js
function func() {
  function a() {
    console.log(b);
  }
  a();
  const b = 'bbb';
}
func();
// Cannot access 'b' before initialization
```

```js
var a = 100;
if (1) {
  a = 10;
  // 在当前块作用域中存在 a 使用 let/const 声明的情况下，给 a 赋值 10 时，只会在当前作用域找变量 a，
  // 而这时，还未到声明时候，所以控制台 ReferenceError: Cannot access 'a' before initialization
  let a = 1;
}
```

变量声明会提升， 赋值不会提升。

```js
console.log(employeeId);
var employeeId = '19000';
// undefined

(function() {
  console.log(typeof displayFunc);
  var displayFunc = function() {
    console.log('Hi I am inside displayFunc');
  };
})();
// undefined
```

内外作用域有同名的变量，就近原则。

```js
var employeeId = '1234abe';
(function() {
  console.log(employeeId);
  var employeeId = '122345';
})();
// undefined

var employeeId1 = '1234abe';
(function() {
  console.log(employeeId1);
  var employeeId1 = '122345';
  (function() {
    var employeeId1 = 'abc1234';
  })();
})();
// undefined
```

### TypeError

TypeError: Assignment to constant variable

常量的值在设定之后就不能再更改。

```js
const a = 2;
a = 3; // TypeError: Assignment to constant variable.
```

TypeError`则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。比如视图对一个非函数类型的值进行函数调用，或者引用`null`或`undefined`类型的值中的属性，那么引擎会抛出类型异常，`TypeError`.
