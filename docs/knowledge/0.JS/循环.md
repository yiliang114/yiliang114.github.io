---
title: JS 循环
date: '2020-10-26'
draft: true
---

## for in

```js
const obj = {
  id: 1,
  name: 'yiliang',
  age: 18,
};

for (let key in obj) {
  console.log(key + '---' + obj[key]);
}
```

数组也可以用`for...of`遍历，这极大地方便了数组的取值，且避免了很多程序用`for..in`去遍历数组的恶习

### for in 的缺陷

`for in` 语句用来列举对象的属性(成员)，如下

```js
var obj = {
  name: 'jack',
  getName: function() {
    return this.name;
  },
};
//输出 name,getName
for (var atr in obj) {
  console.log(atr);
}
```

注意了吗，没有输出 obj 的 toString，valueOf 等内置属性（或称内置成员，隐藏属性和预定义属性）。即 `for in` 用来列举对象的显示成员（自定义成员）。

如果重写了内置属性呢，下面就重写 obj 的 toString

```js
var obj = {
  name: 'jack',
  getName: function() {
    return this.name;
  },
  toString: function() {
    return "I'm jack.";
  },
};
for (var atr in obj) {
  console.log(atr);
}
```

会输出什么呢？

1. IE6/7/8 下和没有重写 toString 一样，仍然只输出 name,getName
2. IE9/Firefox/Chrome/Opera/Safari 下则输出 name,getName,toString

如果给内置原型添加属性/方法，那么 for in 时也是可遍历的

```js
Object.prototype.clone = function() {};
var obj = {
  name: 'jack',
  age: 33,
};
// name, age, clone
for (var n in obj) {
  console.log(n);
}
```

给 Object.prototype 添加了方法 clone，for in 时所有浏览器都显示了 clone。

但有时我们为了兼容 ES5 或后续版本，会在不支持 ES5 的浏览器上（IE6/7/8）去扩展内置构造器的原型，这时 for in 在各浏览器中就不同了。如下

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function(scope) {
    var fn = this;
    return function() {
      fn.apply(scope, arguments);
    };
  };
}
function greet(name) {
  console.log(this.greet + ', ' + name);
}
for (var n in greet) {
  console.log(n);
}
```

IE6/7/8 输出了 bind，其它浏览器则无。因为现代浏览器中 bind 是原生支持的，for in 不到，IE6/7/8 则是给 Function.prototype 添加了 bind。

总结下：在跨浏览器的设计中，我们不能依赖于 for in 来获取对象的成员名称，一般使用 hasOwnProperty 来判断下。

### for-in 遍历数组的坏处？

- `for-in`赋给 index 的值不是实际的数字，而是字符串 “0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。
- 作用于数组的 for-in 循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性 myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。

### for-in

- 与

  ```
  for-in
  ```

  区别

  - 有着同`for-in`一样的简洁语法，但没有`for-in`那些缺点、
  - 不同于`forEach()`，它可与`break`、`continue`和`return`配合使用
  - 提供遍历所有数据结构的统一操作接口

> 应用场景

- 改写具有`Iterator接口`的数据结构的`Symbol.iterator`
- 解构赋值：对 Set 进行结构
- 扩展运算符：将部署`Iterator接口`的数据结构转为数组
- yield*：`yield*`后跟一个可遍历的数据结构，会调用其遍历器接口
- 接受数组作为参数的函数：`for-of`、`Array.from()`、`new Set()`、`new WeakSet()`、`new Map()`、`new WeakMap()`、`Promise.all()`、`Promise.race()`

## for of

- 定义：调用`Iterator接口`产生遍历器对象(`for-of`内部调用数据结构的`Symbol.iterator()`)

- 遍历字符串：`for-in`获取`索引`，`for-of`获取`值`(可识别 32 位 UTF-16 字符)

- 遍历数组：`for-in`获取`索引`，`for-of`获取`值`

- 遍历对象：`for-in`获取`键`，`for-of`需自行部署

- 遍历 Set：`for-of`获取`值` => `for (const v of set)`

- 遍历 Map：`for-of`获取`键值对` => `for (const [k, v] of map)`

- 遍历类数组：`包含length的对象`、`Arguments对象`、`NodeList对象`(无`Iterator接口的类数组`可用`Array.from()`转换)

### for of 的原理

`for of` 通过方法调用(遍历器方法)来实现集合的遍历。数组、Maps、Sets 以及其他我们讨论过的对象之间有个共同点：有迭代器方法。

`for of` 工作原理：迭代器(iterator)有一个 next 方法，for 循环会不断调用这个 iterator.next 方法来获取下一个值,直到返回值中的 done 属性为 true 的时候结束循环。

Iterator 的作用有三个：

1. 为各种数据结构， 提供一个统一的、 简便的访问接口。
2. 使得数据结构的成员能够按某种次序排列；
3. ES6 创造了一种新的遍历命令 for...of 循环， Iterator 接口主要供 for...of 消费。

Iterator 的遍历过程是这样的:

4. 创建一个指针对象， 指向当前数据结构的起始位置。 也就是说， 遍历器对象本质上， 就是一个指针对象。
5. 第一次调用指针对象的 next 方法， 可以将指针指向数据结构的第一个成员。
6. 第二次调用指针对象的 next 方法， 指针就指向数据结构的第二个成员。
7. 不断调用指针对象的 next 方法， 直到它指向数据结构的结束位置。

每一次调用 next 方法， 都会返回数据结构的当前成员的信息。 具体来说， 就是返回一个包含 value 和 done 两个属性的对象。 其中， value 属性是当前成员的值， done 属性是一个布尔值， 表示遍历是否结束。

## for in 和 for of 的区别是什么？

for-in 用于遍历对象更好
for-of 用于遍历数组更好

使用 for in 会遍历数组所有的可枚举属性，包括原型。所以**for-in 用于遍历对象更好**。

记住，for in 遍历的是数组的索引（即键名），而 for of 遍历的是数组元素值。

## forEach

forEach（）使用三个参数调用该 函数：数组元素、元素的索引和数组本身。注意: forEach() 对于空数组是不会执行回调函数的。

### foreach 跳出循环

```js
try {
  arr.forEach((item, index) => {
    if (item === 'b') throw new Error('exist');
    console.log(item);
  });
} catch (e) {
  if (e.message == 'exist') throw e;
} finally {
  console.log('done');
}
```

程序最后可以终止退出循环，所以使用 try...catch 通过抛出异常的方式来终止程序继续执行是可行。

#### foreach 不能异步原因

foreach 源码：

```js
// ...

Array.prototype.forEach = function(callback, thisArg) {
  var len = O.length >>> 0;
  k = 0;
  // 7. Repeat, while k < len
  while (k < len) {
    if (k in O) {
      // ...
      callback.call(T, kValue, k, O);
    }
    k++;
  }
};
// ...
```

可以看到代码中有一个 while 循环一直在调用 callback 回调函数，判断这里应该是异步并行调用的，因为我们只是在将 foreach 中的 callback 使用了 async/await 来等待异步返回操作，而本身这个 foreach 并没有使用 async/await 来等待异步返回。

使用 foreach 时其实也就相当于调用了一个封装了 while 或者 for 循环的函数，这个函数本身并没有使用 async/await 来处理异步，所以使用时在回调函数里面加上 async/await 是没有作用的，遍历的方式有很多种，那么我们在需要遍历处理异步的时候，最好还是使用 for 或者 while 来实现，不管是封装一个新的函数，或者是直接使用来遍历都可以避免这个问题。

### es6 in

感觉其实就是 for in 的拆分出来的

```js
!('key' in obj); //不包含
obj.hasOwnProperty('key'); //包含
```

### for of , for in 和 forEach,map 的区别

- for...of 循环：具有 iterator 接口，就可以用 for...of 循环遍历它的成员(属性值)。for...of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、Generator 对象，以及字符串。for...of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。对于普通的对象，for...of 结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。可以中断循环。
- for...in 循环：遍历对象自身的和继承的可枚举的属性, 不能直接获取属性值。可以中断循环。
- forEach: 只能遍历数组，不能中断，没有返回值(或认为返回值是 undefined)
- map: 只能遍历数组，不能中断，返回值是修改后的数组

## 停止 for 循环

break 可以停止 for...in 和 for...of 循环， 不能停止 forEach 循环。

### Iterator 是什么，有什么作用？(重要)

- `Iterator`是`ES6`中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为`ES6`新增了`Set`、`Map`类型，他们和`Array`、`Object`类型很像，`Array`、`Object`都是可以遍历的，但是`Set`、`Map`都不能用 for 循环遍历，解决这个问题有两种方案，一种是为`Set`、`Map`单独新增一个用来遍历的`API`，另一种是为`Set`、`Map`、`Array`、`Object`新增一个统一的遍历`API`，显然，第二种更好，`ES6`也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。`Iterator`正是这样一种标准。或者说是一种规范理念
- 就好像`JavaScript`是`ECMAScript`标准的一种具体实现一样，`Iterator`标准的具体实现是`Iterator`遍历器。`Iterator`标准规定，所有部署了`key`值为`[Symbol.iterator]`，且`[Symbol.iterator]`的`value`是标准的`Iterator`接口函数(标准的`Iterator`接口函数: 该函数必须返回一个对象，且对象中包含`next`方法，且执行`next()`能返回包含`value/done`属性的`Iterator`对象)的对象，都称之为可遍历对象，`next()`后返回的`Iterator`对象也就是`Iterator`遍历器

```js
//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。
//obj.[Symbol.iterator]() 就是Iterator遍历器
let obj = {
  data: ['hello', 'world'],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index < self.data.length) {
          return {
            value: self.data[index++],
            done: false,
          };
        } else {
          return { value: undefined, done: true };
        }
      },
    };
  },
};
```

`ES6`给`Set`、`Map`、`Array`、`String`都加上了`[Symbol.iterator]`方法，且`[Symbol.iterator]`方法函数也符合标准的`Iterator`接口规范，所以`Set`、`Map`、`Array`、`String`默认都是可以遍历的

```js
//Array
let array = ['red', 'green', 'blue'];
array[Symbol.iterator](); //Iterator遍历器
array[Symbol.iterator]().next(); //{value: "red", done: false}

//String
let string = '1122334455';
string[Symbol.iterator](); //Iterator遍历器
string[Symbol.iterator]().next(); //{value: "1", done: false}

//set
let set = new Set(['red', 'green', 'blue']);
set[Symbol.iterator](); //Iterator遍历器
set[Symbol.iterator]().next(); //{value: "red", done: false}

//Map
let map = new Map();
let obj = { map: 'map' };
map.set(obj, 'mapValue');
map[Symbol.iterator]().next(); // {value: Array(2), done: false}
```

for in 是遍历对象的。for in 在高级浏览器中会屏蔽来自原型链的属性，通过 hasOwnProperty 还可以再检察一下。
for of 一般是用来遍历数组，只遍历数组的元素值，不遍历数组对象上挂载的属性。

## hasOwnProperty

### in 和 hasOwnProperty 区别

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果在实例中添加一个与原型中属性同名的属性，则该属性会屏蔽原型中的那个属性。添加的同名属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为`null`，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。

```js
function Person() {}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true

person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true

delete person1.name;
console.log(person1.name); // "Nicholas"
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true
```

`in`操作符只要通过对象能访问到属性就返回`true`。`hasOwnProperty()`只在属性存在于实例中时才返回`true`。

使用`delete`操作符则可以完全删除实例属性，从而让我们能巩固重新访问原型中的属性。

```js
function Person() {
  this.name = 'koewas';
}

// Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
delete person1.name;
console.log(person1.name); // undefined
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // false
```

上面这段代码的 `name` 为实例属性，不属于原型。但却不是私有属性，能被实例访问。

### hasOwnProperty

是不是对象自身下面的属性

```js
var arr = [];
arr.num = 10;
Array.prototype.num2 = 20; //这样写表示所有的数组对象都有了 num2 这个属性

alert(arr.hasOwnProperty('num')); //true 说明num这个属性只属于arr的,是arr独有的
alert(arr.hasOwnProperty('num2')); //false 因为所有的数组对象都拥有了num2,而不仅仅是arr,所以是false
```

判断这个属性是不是对象本身的属性。常用的地方是遍历一个对象的时候。

```js
var item;
for (item in f) {
  if (f.hasOwnProperty(item)) {
    console.log(item);
  }
}
```

### 对象是否存在该属性

```js
'name' in Person;
```

in 缺陷---属性是继承来的时候,仍然返回 true
最好使用 hasOwnProperty()

```js
Person.hasOwnProperty('name');
```

### for in 与 hasOwnProperty 结合使用

与 in 操作符相比，for in 在循环对象的属性时也会遍历原型链，for in 不会读取不可枚举属性，如数组的 length 属性。

```js
for (var i in foo) {
  if (foo.hasOwnProperty(i)) {
    console.log(i);
  }
}
```

推荐在 for in 时，总是使用 hasOwnProperty 进行判断，没人可以保证运行的代码环境是否被污染过。
