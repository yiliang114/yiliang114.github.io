---
title: 循环
date: '2020-10-26'
draft: true
---

<!-- TODO: -->

## for in

```js
const obj = {
  id: 1,
  name: 'yiliang',
  age: 18,
};

for (let key in obj) {
  console.log(key + '---' + obj[key]);
}
```

- 它可与`break`、`continue`和`return`配合使用

### for in 的缺陷

给内置原型 `Object.prototype` 添加属性/方法，`for in` 时也是可遍历的。如果重写了内置属性， 例如 toString 之类的函数，大多数现代浏览器都是会打印出来的。但是 `for in` 不会读取不可枚举属性，如数组的 length 属性。

所以不能依赖于 `for in` 来获取对象的成员名称，一般会配合 `hasOwnProperty` 打印对象的键值，没人可以保证运行的代码环境是否被污染过。

### in 操作符

`in`操作符只要通过对象能访问到属性就返回`true`。 `in` 缺陷---属性是继承来的时候,仍然返回 true. 使用`delete`操作符则可以完全删除实例属性，但不能删除原型链中的属性。

### for-in 遍历数组的问题？

- `for-in`赋给 index 的值不是实际的数字，而是字符串 “0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。
- 作用于数组的 for-in 循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性 myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。

## for of

- 定义：调用`Iterator接口`产生遍历器对象(`for-of`内部调用数据结构的`Symbol.iterator()`)

- 遍历字符串：`for-in`获取`索引`，`for-of`获取`值`(可识别 32 位 UTF-16 字符)

- 遍历数组：`for-in`获取`索引`，`for-of`获取`值`

- 遍历对象：`for-in`获取`键`，`for-of`需自行部署

- 遍历 Set：`for-of`获取`值` => `for (const v of set)`

- 遍历 Map：`for-of`获取`键值对` => `for (const [k, v] of map)`

- 遍历类数组：`包含length的对象`、`Arguments对象`、`NodeList对象`(无`Iterator接口的类数组`可用`Array.from()`转换)

### for of 的原理

`for of` 通过方法调用(遍历器方法)来实现集合的遍历。数组、Maps、Sets 以及其他我们讨论过的对象之间有个共同点：有迭代器方法。

`for of` 工作原理：迭代器(iterator)有一个 next 方法，for 循环会不断调用这个 iterator.next 方法来获取下一个值,直到返回值中的 done 属性为 true 的时候结束循环。

Iterator 的作用有三个：

1. 为各种数据结构， 提供一个统一的、 简便的访问接口。
2. 使得数据结构的成员能够按某种次序排列；
3. ES6 创造了一种新的遍历命令 for of 循环， Iterator 接口主要供 for of 消费。

Iterator 的遍历过程是这样的:

4. 创建一个指针对象， 指向当前数据结构的起始位置。 也就是说， 遍历器对象本质上， 就是一个指针对象。
5. 第一次调用指针对象的 next 方法， 可以将指针指向数据结构的第一个成员。
6. 第二次调用指针对象的 next 方法， 指针就指向数据结构的第二个成员。
7. 不断调用指针对象的 next 方法， 直到它指向数据结构的结束位置。

每一次调用 next 方法， 都会返回数据结构的当前成员的信息。 具体来说， 就是返回一个包含 value 和 done 两个属性的对象。 其中， value 属性是当前成员的值， done 属性是一个布尔值， 表示遍历是否结束。

数组也可以用`for of`遍历，这极大地方便了数组的取值，且避免了很多程序用`for..in`去遍历数组的恶习

## 停止 for 循环

break 可以停止 for in 和 for of 循环， 不能停止 forEach 循环。

### foreach 跳出循环

```js
try {
  arr.forEach((item, index) => {
    if (item === 'b') throw new Error('exist');
    console.log(item);
  });
} catch (e) {
  if (e.message == 'exist') throw e;
} finally {
  console.log('done');
}
```

程序最后可以终止退出循环，所以使用 try...catch 通过抛出异常的方式来终止程序继续执行是可行。

#### foreach 不能异步原因

foreach 源码：

```js
// ...

Array.prototype.forEach = function(callback, thisArg) {
  var len = O.length >>> 0;
  k = 0;
  // 7. Repeat, while k < len
  while (k < len) {
    if (k in O) {
      // ...
      callback.call(T, kValue, k, O);
    }
    k++;
  }
};
// ...
```

可以看到代码中有一个 while 循环一直在调用 callback 回调函数，判断这里应该是异步并行调用的，因为我们只是在将 foreach 中的 callback 使用了 async/await 来等待异步返回操作，而本身这个 foreach 并没有使用 async/await 来等待异步返回。

使用 foreach 时其实也就相当于调用了一个封装了 while 或者 for 循环的函数，这个函数本身并没有使用 async/await 来处理异步，所以使用时在回调函数里面加上 async/await 是没有作用的，遍历的方式有很多种，那么我们在需要遍历处理异步的时候，最好还是使用 for 或者 while 来实现，不管是封装一个新的函数，或者是直接使用来遍历都可以避免这个问题。

## for of, for in 和 forEach, map 的区别

- for in 是遍历对象的。使用 for in 会遍历数组所有的可枚举属性，包括原型。所以**for-in 用于遍历对象更好**，for in 遍历的是数组的索引（即键名）。for in 用于遍历对象更好
- for of 用于遍历数组更好，只遍历数组的元素值，不遍历数组对象上挂载的属性。
- for of 循环：具有 iterator 接口，就可以用 for of 循环遍历它的成员(属性值)。for of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、Generator 对象，以及字符串。for of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。对于普通的对象，for of 结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。可以中断循环。
- for in 循环：遍历对象自身的和继承的可枚举的属性, 不能直接获取属性值。可以中断循环。
- forEach: 只能遍历数组，不能中断，没有返回值(或认为返回值是 undefined)。注意: forEach() 对于空数组是不会执行回调函数的
- map: 只能遍历数组，不能中断，返回值是修改后的数组
