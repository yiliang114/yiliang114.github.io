---
title: 继承
date: '2020-10-26'
draft: true
---

<!-- TODO: -->

## 创建对象

### 对象的几种创建方式

1. 字面量创建（调用内置的构造函数）
2. 构造函数
3. 原型
4. Object.create()

#### 1. 字面量

```js
const obj11 = { name: 'yiliang' };
// 内置对象（内置的构造函数）
const obj12 = new Object({ name: `yiliang` });
```

> 上面的两种写法，效果是一样的。因为，第一种写法，`obj11` 会指向 `Object`。

- 第一种写法是：字面量的方式。
- 第二种写法是：内置的构造函数

内置构造函数

```js
const obj = new Object();
//等同于 const obj = {}
```

> 使用字面量的方式更简单，其实他俩是一样的。
> 优点是足够简单，缺点是每个对象都是独立的。

#### 2. 构造函数

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function() {
    alert(this.name);
  };
}
const person1 = new Person('Nicholas', 29, 'Software Engineer');
const person2 = new Person('Greg', 27, 'Doctor');
```

> 优点是 可以创建特定类型的对象，缺点是多个实例重复创建方法

以这种方式调用构造函数实际上会经历以下 4 个步骤:

1. 创建一个新对象;
2. 将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象);
3. 执行构造函数中的代码(为这个新对象添加属性);
4. 返回新对象。

缺点：使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍

#### 3. 原型

不必在构造函数中定义对象实例的信息，将这些信息直接添加到原型对象

```js
function Person() {}
Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  alert(this.name);
};
const person1 = new Person();
person1.sayName(); //"Nicholas"
const person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

缺点：实例没有属于自己的全部属性的

#### 4. Object.create

`obj3`是实例，`p`是`obj3`的原型（ `name`是 p 原型里的属性），构造函数是`Object`

```js
const p = { name: 'happy' };
//此方法创建的对象，是用原型链连接的
const obj3 = Object.create(p);
```

```js
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  },
};
const me = Object.create(person);
me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten
me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
```

> 传入一个原型对象，创建一个新对象，使用现有的对象来提供新创建的对象的 `__proto__`，实现继承。

Object.create(null) 生成的对象里面没有任何属性，非常“空”，我们称它为字典，这种字典对象适合存放数据，不必担心原型带来的副作用。这也是 Vue 中为什么很多地方都使用了 `Object.create(null)` 的原因。

### 实现 Object.create

`Object.create(parent)`主要完成了三件事情：

- 创建一个对象
- 继承指定父对象
- 为新对象扩展新属性

何时使用 create: 希望在创建对象时就提前指定继承的父对象，并同时扩展新属性时。

```js
Object.myCreate = function(parent,props) {
  const obj = new Object();
  Object.setPrototypeOf(obj,parent);
  Object.defineProperties(obj,props);
  return obj;
}

// 用法
const father={bal:1000,car:"=b="}
// create调用的也是 defineProperty
const hmm=Object.myCreate(father,{
  phone:{//默认为false
    value:"肾6s",
    writable:true,
    enumertable:true,
    configurable:true.
  },
});
```

## 类与继承

继承的本质就是原型链

### 现在有一个函数 A 和函数 B，请你实现 B 继承 A

```js
// 方式 1
function B() {}
function A() {}
B.prototype = new A();

// 方式 2
function A() {}
function B() {
  A.call(this);
}

// 方式 3
function B() {}
function A() {}
B.prototype = new A();

function B() {
  A.call(this);
}
```

### Javascript 如何实现继承？

- 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上

```js
function Cat(name, color) {
  Animal.apply(this, arguments);
  this.name = name;
  this.color = color;
}
```

- 实例继承：将子对象的 prototype 指向父对象的一个实例

```js
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
```

- 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象

```js
function extend(Child, Parent) {
  let p = Parent.prototype;
  let c = Child.prototype;
  for (let i in p) {
    c[i] = p[i];
  }
  c.uber = p;
}
```

- 原型继承：将子对象的 prototype 指向父对象的 prototype

```js
function extend(Child, Parent) {
  let F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
  Child.uber = Parent.prototype;
}
```

- ES6 语法糖 extends：class ColorPoint extends Point {}

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

### JS 继承的 6 种方法

1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 寄生式继承
5. 寄生组合式继承
6. class 继承

#### 1. 原型链继承

基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法, 实现的本质是重写原型对象

```js
function SuperType() {
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.property;
};

function SubType() {
  this.subProperty = false;
}

//继承了 SuperType

SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
  return this.subProperty;
};

let instance = new SubType();

console.log(instance.getSuperValue()); //true
```

存在的问题：

1. 通过原型来实现继承时，原型实际上会变成另一个类型的实例，
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数

`new Child.__proto__ === new Parent()`的结果为`true`

**分析：**

- 这种继承方式，**Child 可以继承 Parent 的原型**，但有个缺点：

> 缺点是：**如果修改 child1 实例的 name 属性，child2 实例中的 name 属性也会跟着改变**。

如下：

![](http://img.smyhvae.com/20180307_1123.png)

> 上面的代码中， `child1`修改了`arr`属性，却发现，`child2`的`arr`属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。

> 造成这种缺点的原因是：`child1`和`child2`共用原型。即：`chi1d1.__proto__ === child2__proto__`是严格相同。而 arr 方法是在 Parent 的实例上（即 Child 实例的原型）的。

#### 2. 借用构造函数继承

在子类型构造函数的内部调用超类型构造函数

```js
function SuperType(){
    this.colors = ["red", "blue", "green”];
}

function SubType(){
		//继承了 SuperType
    SuperType.call(this);

}

let instance1 = new SubType();

instance1.colors.push("black");

console.log(instance1.colors);    //"red,blue,green,black"

let instance2 = new SubType();

console.log(instance2.colors);    //"red,blue,green”
```

以上继承的方式核心是在子类的构造函数中通过 `Parent.call(this)` 继承父类的属性，然后改变子类的原型为 `new Parent()` 来继承父类的函数。

这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。

```js
function Parent1() {
  this.name = 'parent1 的属性';
}

function Child1() {
  Parent1.call(this); //【重要】此处用 call 或 apply 都行：改变 this 的指向
  this.type = 'child1 的属性';
}

console.log(new Child1());
```

> 【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了`Parent1.call(this);`，意思是：**让 Parent 的构造函数在 child 的构造函数中执行**。发生的变化是：**改变 this 的指向**，parent 的实例 --> 改为指向 child 的实例。导致 parent 的实例的属性挂在到了 child 的实例上，这就实现了继承。

打印结果：

![](http://img.smyhvae.com/20180307_1015.png)

> 上方结果表明：`child`先有了 `parent` 实例的属性（继承得以实现），再有了`child` 实例的属性。

**分析**：

> 这种方式，虽然改变了 `this` 的指向，但是，**Child1 无法继承 `Parent1` 的原型**。也就是说，如果我给 `Parent1` 的原型增加一个方法：

```js
Parent1.prototype.say = function() {};
```

> 上面这个方法是无法被 `Child1` 继承的。如下：

![](http://img.smyhvae.com/20180307_1030.png)

#### 3. 组合继承(原型+借用构造)

使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承

```js
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
  console.log(this.name);
};

function SubType(name, age) {
  //继承属性
  SuperType.call(this, name);
  this.age = age;
}

//继承方法

SubType.prototype = new SuperType();

SubType.prototype.constructor = SubType;

SubType.prototype.sayAge = function() {
  console.log(this.age);
};

let instance1 = new SubType('Nicholas', 29);

instance1.colors.push('black');

console.log(instance1.colors); //"red,blue,green,black"

instance1.sayName(); //"Nicholas";

instance1.sayAge(); //29

let instance2 = new SubType('Greg', 27);

console.log(instance2.colors); //"red,blue,green"

instance2.sayName(); //"Greg";

instance2.sayAge(); //27
```

- 这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。
- 这种方式的缺点是：让父亲`Parent`的构造方法执行了两次。
- `ES6`中的继承方式，一带而过即可，重点是要掌握`ES5`中的继承。

#### 4. 寄生式继承:

创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象

```js
function createAnother(original) {
  let clone = object(original); //通过调用函数创建一个新对象
  clone.sayHi = function() {
    ////以某种方式来增强这个对象
    console.log('hi');
  };
  return clone; //返回这个对象
}
let person = {
  name: 'Nicholas',
  friends: ['Shelby', 'Court', 'Van'],
};
let anotherPerson = createAnother(person);
anotherPerson.sayHi(); //"hi"
```

#### 5. 寄生组合式继承:

即通过借用构造函数来继承属性，通过原型链的混成形式来继承

```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
SuperType.prototype.sayName = function() {
  console.log(this.name);
};
function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}
function inheritPrototype(subType, superType) {
  let prototype = object(superType.prototype); //创建对象
  prototype.constructor = subType; //增强对象
  subType.prototype = prototype; //指定对象
}

inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function() {
  console.log(this.age);
};
let p1 = new SubType('Jack', 20);
p1.colors.push('white');
console.log(p1.colors); //["red", "blue", "green", "white"]
let p2 = new SubType('Mark', 18);
console.log(p2.age); //18
```

这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。

```js
function Parent(value) {
  this.val = value;
}
Parent.prototype.getValue = function() {
  console.log(this.val);
};

function Child(value) {
  Parent.call(this, value);
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

const child = new Child(1);

child.getValue(); // 1
child instanceof Parent; // true
```

以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。

![img](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/1672afb8dfa21361.jpg)

#### 6. Class 继承

以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 `class` 去实现继承，并且实现起来很简单

```js
class Parent {
  constructor(value) {
    this.val = value;
  }
  getValue() {
    console.log(this.val);
  }
}
class Child extends Parent {
  constructor(value) {
    super(value);
    this.val = value;
  }
}
let child = new Child(1);
child.getValue(); // 1
child instanceof Parent; // true
```

`class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，因为这段代码可以看成 `Parent.call(this, value)`。

当然了，之前也说了在 JS 中并不存在类，`class` 的本质就是函数。

### Class、extends 是什么，有什么作用？

`ES6` 的`class`可以看作只是一个`ES5`生成实例对象的构造函数的语法糖。它参考了`java`语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。`Class`类可以通过`extends`实现继承。它和 ES5 构造函数的不同点

类的内部定义的所有方法，都是不可枚举的

- `ES6`的`class`类必须用`new`命令操作，而`ES5`的构造函数不用`new`也可以执行。
- `ES6`的`class`类不存在变量提升，必须先定义`class`之后才能实例化，不像`ES5`中可以将构造函数写在实例化之后。
- `ES5` 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面。`ES6` 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。

### 封装一个原生的继承方法

```js
function extendsClass(Parent, Child) {
  function F() {}
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constrctor = Child;
  return Child;
}
```

### javascript 里面的继承怎么实现，如何避免原型链上面的对象共享

用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的 extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量

## new 原理

1. new 关键字会首先创建一个空对象
2. 将这个空对象的原型对象指向构造函数的原型属性，从而继承原型上的方法
3. 将 this 指向这个空对象，执行构造函数中的代码，以获取私有属性
4. 如果构造函数返回了一个对象 res，就将该返回值 res 返回，如果返回值不是对象，就将创建的对象返回

模拟 new 实现：

```js
// 因为 new 是关键字,我用函数的形式来实现，可以将构造函数和构造函数的参数传入
function myNew(Fn, ...args) {
  // 1. 创建一个空对象，并将对象的 __proto__ 指向构造函数的 prototype 这里我两步一起做了
  const obj = Object.create(Fn.prototype);
  // 2. 将构造函数中的 this 指向 obj，执行构造函数代码,获取返回值
  const res = Fn.apply(obj, args);
  // 3. 判断返回值类型
  return res instanceof Object ? res : obj;
}
```

**先创建父类实例** => 改变实例原先的 `__proto__` 转而连接到子类的 `prototype` => 子类的 `prototype` 的 `__proto__` 改为父类的 `prototype`。

### 构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？

- 没有自己的 this，无法调用 call，apply
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 `__proto__`

## 其他

#### ES5 继承

**原型链继承**

缺点：无法向父类构造函数中传递参数；子类原型链上定义的方法有先后顺序问题。需要注意的是 js 中交换原型链，均需要修复`prototype.constructor`指向问题。

```js
function Animal(species) {
  this.species = species;
}
Animal.prototype.func = function() {
  console.log('Animal');
};

function Cat() {}
/**
 * func 方法是无效的, 因为后面原型链被重新指向了 Animal 实例
 */
Cat.prototype.func = function() {
  console.log('Cat');
};

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat; // 修复: 将 Cat.prototype.constructor 重新指向本身
```

**组合继承**

结合绑定构造函数和原型链继承 2 种方式，缺点是：调用了 2 次父类的构造函数。

```js
function Animal(species) {
  this.species = species;
}
Animal.prototype.func = function() {
  console.log('Animal');
};

function Cat() {
  Animal.apply(this, arguments);
}

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
```

**寄生组合继承**

改进了组合继承的缺点，只需要调用 1 次父类的构造函数。**它是引用类型最理想的继承范式**。

```js
/**
 * 寄生组合继承的核心代码
 * @param {Function} Sub 子类
 * @param {Function} Parent 父类
 */
function inheritPrototype(Sub, Parent) {
  // 拿到父类的原型
  let prototype = Object.create(Parent.prototype);
  // 改变 constructor 指向
  prototype.constructor = Sub;
  // 父类原型赋给子类
  Sub.prototype = prototype;
}

function Animal(species) {
  this.species = species;
}
Animal.prototype.func = function() {
  console.log('Animal');
};

function Cat() {
  Animal.apply(this, arguments); // 只调用了 1 次构造函数
}

inheritPrototype(Cat, Animal);
```

#### ES6 继承

本质还是语法糖，还是使用 prototype

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  eat() {
    console.log('eat');
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name);
    this.name = name;
  }
  bark() {
    console.log('bark');
  }
}

const dog = new Dog('哈士奇');
console.log(typeof Dog.prototype); // animal 实例 object
console.log(typeof Dog.prototype.constructor); // Class Dog, 还是一个构造函数

// 这种语法糖形式，看起来和实际原理不一样的东西
typeof Animal; // "function"
// 构造函数的（显式）原型里面默认有一个 constructor 属性，等于构造函数本身
Animal === Animal.prototype.constructor; // true
// 每一个 new 出来的实例，都拥有一个隐式原型，等于构造函数的显式原型
animal.__proto__ === Animal.prototype; // true
```
