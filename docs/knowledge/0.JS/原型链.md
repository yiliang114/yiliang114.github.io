---
title: 原型链与继承
date: '2020-10-26'
draft: true
---

<!-- TODO: -->

## 作用域 & 作用域链

作用域: 就是变量或者是函数能作用的范围。JS 没有块级作用域，只有函数和全局作用域。
作用域链: 就是一层一层向父层寻找没有定义的变量。

**作用域**

ES5 有”全局作用域“和”函数作用域“。ES6 的`let`和`const`使得 JS 用了”块级作用域“。为了解决 ES5 的全局冲突，一般都是闭包（立即执行函数），将变量封装到函数作用域。

**作用域链**

当前作用域没有找到定义，继续向父级作用域寻找，直至全局作用域。**这种层级关系，就是作用域链**。

作用域链的终点是全局对象 window

## 原型 & 原型链

### 原型

- 所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象。
- 所有的函数（除了箭头函数），都有一个 `prototype` 属性，属性值也是一个普通的对象。
- 所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的 `prototype` 属性值。

**注**：ES6 的箭头函数没有 `prototype` 属性，但是有`__proto__`属性。

```js
const obj = {};
// 引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值
console.log(obj.__proto__ === Object.prototype); // output: true
```

### 原型链

几乎所有的 js 对象都是位于原型链顶端的 Object 实例。

原型链的顶端是 `Object.prototype.__proto__` 也就是 `null`

- 只有构造函数才有 prototype 属性
- 构造函数的 prototype，默认情况下就是一个 new Object()还额外添加了一个 constructor 属性
- 除了 Object.prototype 这个对象，其他所有的对象都会有**proto**属性（函数也是对象）

任何一个实例对象通过原型链可以找到它对应的原型对象，原型对象上面的实例和方法都是实例所共享的。

一个对象在查找以一个方法或属性时，他会先在自己的对象上去找，找不到时，他会沿着原型链依次向上查找。

注意： 函数才有 prototype，实例对象只有有**proto**， 而函数有的**proto**是因为函数是 Function 的实例对象

**原型链的基本原理**：任何一个**实例**，通过原型链，找到它上面的**原型**，该原型对象中的方法和属性，可以被所有的原型实例共享。

> `Object`是原型链的顶端。

- 原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：

**原型链的关键**：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。

- 所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象。
- 所有的函数（除了箭头函数），都有一个 `prototype` 属性，属性值也是一个普通的对象。
- 所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的 `prototype` 属性值。

**注**：ES6 的箭头函数没有 `prototype` 属性，但是有`__proto__`属性。

当试图得到一个对象的某个属性的时候，如果这个对象本身没有这个属性，那么就会去它的 `__proto__` 中（即它的构造函数的 prototype 中） 寻找。如果它的构造函数的原型链上也没有的话，就再往构造函数的隐式原型链上去寻找，一直到找不到为止。 这个链式结构叫做原型链。

最顶层是 `Object.prototype.__proto__ === null`

### 原型、构造函数、实例，以及原型链

1. 构造函数通过 `new` 生成实例
2. 构造函数也是函数，构造函数的`prototype`指向原型。（所有的函数有`prototype`属性，但实例没有 `prototype`属性）
3. 原型对象中有 `constructor`，指向该原型的构造函数。
4. 所有的**引用类型**（数组、对象、函数）都有`__proto__`这个属性

### 原型继承的工作原理

```js
function ha() {}
// 构造函数的原型上有一个 constructor 指向该构造函数自身
ha.prototype.constructor === ha; // true
// 构造函数的原型也是一个对象，其 __proto__ 属性指向它的构造函数 Object 的原型
ha.prototype.__proto__ === Object.prototype; // true
// `ha`这个普通的函数，也是一个对象（引用类型），是`Function`构造函数的一个实例
ha.__proto__ === Function.prototype;

Function.__proto__ === Function.prototype; // true
Function.prototype.__proto__ === Object.prototype; // true
Object.prototype.__proto__ === null;
```

构造函数默认自带有一个 prototype 属性，这个 prototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数。
每一个实例都有一个 `__proto__` 属性（隐式原型）指向这个 prototype 对象。

每个函数都有 `prototype` 属性，除了 `Function.prototype.bind()`，该属性指向原型。

原型 `prototype` 的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型。并不是所有函数都有 `prototype` 属性， `Function.prototype.bind()` 就没有这个属性。原型链就是多个对象通过 `__proto__` 的方式连接了起来。

关系：`instance.constructor.prototype = instance.__proto__`

1.  原型对象也是普通的对象，是对象一个自带隐式的 `__proto__` 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
2.  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链

对象可以通过 `__proto__` 来寻找不属于该对象的属性，`__proto__` 将对象连接起来组成了原型链。

原型链的终点是 Object.prototype, `Object.prototype.__proto__ === null`。

### 要点

- js 中的函数也是对象 (即 (function(){}) instanceof Object == true)
- 所有的对象都有自己的构造函数
- 所有的函数都能当作构造函数, 每个函数都有一个 prototype 属性
- 每个对象都有一个隐藏的 o.**proto**属性指内向它的构造函数的 prototype
- 于是所有的函数的原型都是 Function.prototype (即 (function(){}).**proto** === Function.prototype)
- 访问一个对象的属性时, 如果从这个对象里找不到, 就从 obj.**proto**里找, 再找不到就继续从 obj.**proto**.**proto**里找, 最终会容到达 Object.prototype

```js
Function.__proto__ == Object.prototype; //false
Function.__proto__ == Function.prototype; //true
```

总结起来就是以下几点：

- JavaScript 的所有对象中都包含了一个 `__proto__` 内部属性，这个属性所对应的就是该对象的原型
- JavaScript 的函数对象，除了原型 `__proto__` 之外，还预置了 prototype 属性
- 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 `__proto__`。
- `Object` 是所有对象的父级，所有对象都可以通过 `__proto__` 找到它
- `Function` 是所有函数的父级，所有函数都可以通过 `__proto__` 找到它
- 函数的 `prototype` 是一个对象
- 对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链

## instanceof

`instanceof`是通过原型链来进行判断的，所以只要不断地通过访问`__proto__`，就可以拿到构造函数的原型`prototype`, 直到`null`停止。

```js
/**
 * 判断 left 是不是 right 类型的对象
 * @param {*} left
 * @param {*} right
 * @return {Boolean}
 */
function instanceof(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null || left === undefined) {
      return false;
    }
    if (left === prototype) {
      return true;
    }
    left = left.__proto__;
  }
}
```

### instanceof

instanceof 可以准确的判断复杂数据类型，但是不能正确判断基本数据类型。能够判断一个对象与构造函数是否在一个原型链上

```js
const Person = function() {};
const p1 = new Person();
p1 instanceof Person; // true

const str = 'hello world';
str instanceof String; // false

const str1 = new String('hello world');
str1 instanceof String; // true
```

`instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

```js
function instanceof(left, right) {
  // 获得类型的原型
  let prototype = right.prototype;
  // 获得对象的原型
  left = left.__proto__;
  // 判断对象的类型是否等于类型的原型
  while (true) {
    if (left === null) return false;
    if (prototype === left) return true;
    left = left.__proto__;
  }
}
```

以下是对实现的分析：

- 首先获取类型的原型
- 然后获得对象的原型
- 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`

### `instanceof`的原理

- `instanceof`的**作用**：用于判断**实例**属于哪个**构造函数**。
- `instanceof`的**原理**：判断实例对象的`__proto__`属性，和构造函数的`prototype`属性，是否为同一个引用（是否指向同一个地址）。

> - **注意 1**：虽然说，实例是由构造函数 new 出来的，但是实例的`__proto__`属性引用的是构造函数的`prototype`。也就是说，实例的`__proto__`属性与构造函数本身无关。
> - **注意 2**：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找`__proto__`属性。这条链上如果能找到， instanceof 的返回结果也是 true。

比如说：

- `foo instance of Foo`的结果为 true，因为`foo.__proto__ === M.prototype`为`true`。
- **`foo instance of Object`的结果也为 true**，为`Foo.prototype.__proto__ === Object.prototype`为`true`。

> 但我们不能轻易的说：`foo` 一定是 由`Object`创建的实例`。这句话是错误的。

### 判断对象是哪个类的直接实例

使用`对象.constructor`直接可判断。

已知 A 继承了 B，B 继承了 C。怎么判断 a 是由 A**直接生成**的实例，还是 B 直接生成的实例呢？还是 C 直接生成的实例呢？

> 分析：这就要用到原型的`constructor`属性了。

`foo.__proto__.constructor === M`的结果为`true`，但是 `foo.__proto__.constructor === Object`的结果为`false`。

所以，用 `constructor`判断就比用 `instanceof`判断，更为严谨。

```js
function A() {}
const a = new A();
a.__proto__ === A.prototype; // true
A.prototype.constructor === A; // true
a.__proto__.constructor === A; // true
a.constructor === A; // true
A.constructor === Function; // true
```
