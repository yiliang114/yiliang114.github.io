---
title: 原型链与继承
date: '2020-10-26'
draft: true
---

## 作用域 & 作用域链

作用域: 就是变量或者是函数能作用的范围。JS 没有块级作用域，只有函数和全局作用域。
作用域链: 就是一层一层向父层寻找没有定义的变量。

作用域链的终点是全局对象 window

## 原型 & 原型链

### 原型继承的工作原理

构造函数默认自带有一个 prototype 属性，这个 prototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数。
同时每一个实例都有一个 `__proto__` 属性（隐式原型）指向这个 prototype 对象。

每个函数都有 `prototype` 属性，除了 `Function.prototype.bind()`，该属性指向原型。

原型的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型。并不是所有函数都有 `prototype` 属性， `Function.prototype.bind()` 就没有这个属性。原型链就是多个对象通过 `__proto__` 的方式连接了起来。

关系：`instance.constructor.prototype = instance.__proto__`

1.  原型对象也是普通的对象，是对象一个自带隐式的 `__proto__` 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
2.  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链

对象可以通过 `__proto__` 来寻找不属于该对象的属性，`__proto__` 将对象连接起来组成了原型链。

原型链的终点是 Object.prototype, `Object.prototype.__proto__ === null`。

### 原型链

几乎所有的 js 对象都是位于原型链顶端的 Object 实例

- 只有构造函数才有 prototype 属性
- 构造函数的 prototype，默认情况下就是一个 new Object()还额外添加了一个 constructor 属性
- 除了 Object.prototype 这个对象，其他所有的对象都会有**proto**属性（函数也是对象）

任何一个实例对象通过原型链可以找到它对应的原型对象，原型对象上面的实例和方法都是实例所共享的。

一个对象在查找以一个方法或属性时，他会先在自己的对象上去找，找不到时，他会沿着原型链依次向上查找。

注意： 函数才有 prototype，实例对象只有有**proto**， 而函数有的**proto**是因为函数是 Function 的实例对象

**原型链的基本原理**：任何一个**实例**，通过原型链，找到它上面的**原型**，该原型对象中的方法和属性，可以被所有的原型实例共享。

> `Object`是原型链的顶端。

- 原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：

**原型链的关键**：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。

- 所有的引用类型（数组、对象、函数），都有一个`__proto__`属性，属性值是一个普通的对象。
- 所有的函数（除了箭头函数），都有一个 `prototype` 属性，属性值也是一个普通的对象。
- 所有的引用类型（数组、对象、函数），`__proto__`属性值指向它的构造函数的 `prototype` 属性值。

**注**：ES6 的箭头函数没有 `prototype` 属性，但是有`__proto__`属性。

### 原型、构造函数、实例，以及原型链

![](http://img.smyhvae.com/20180306_1540.png)

> PS：任何一个函数，如果在前面加了`new`，那就是构造函数。

![](http://img.smyhvae.com/20180306_2107.png)

1. 构造函数通过 `new` 生成实例
2. 构造函数也是函数，构造函数的`prototype`指向原型。（所有的函数有`prototype`属性，但实例没有 `prototype`属性）
3. 原型对象中有 `constructor`，指向该原型的构造函数。

> 上面的三行，代码演示：

```js
var Foo = function(name) {
  this.name = name;
};

var fn = new Foo('smyhvae');
```

> 上面的代码中，`Foo.prototype.constructor === Foo`的结果是`true`：

![](http://img.smyhvae.com/20180306_2120.png)

4. 实例的`__proto__`指向原型。也就是说，`Foo.__proto__ === M.prototype`。

> 声明：所有的**引用类型**（数组、对象、函数）都有`__proto__`这个属性。

`Foo.__proto__ === Function.prototype`的结果为 true，说明`Foo`这个普通的函数，是`Function`构造函数的一个实例。

### 要点

- js 中的函数也是对象 (即 (function(){}) instanceof Object == true)
- 所有的对象都有自己的构造函数
- 所有的函数都能当作构造函数, 每个函数都有一个 prototype 属性
- 每个对象都有一个隐藏的 o.**proto**属性指内向它的构造函数的 prototype
- 于是所有的函数的原型都是 Function.prototype (即 (function(){}).**proto** === Function.prototype)
- 访问一个对象的属性时, 如果从这个对象里找不到, 就从 obj.**proto**里找, 再找不到就继续从 obj.**proto**.**proto**里找, 最终会容到达 Object.prototype

```js
Function.__proto__ == Object.prototype; //false
Function.__proto__ == Function.prototype; //true
```

总结起来就是以下几点：

- JavaScript 的所有对象中都包含了一个 `__proto__` 内部属性，这个属性所对应的就是该对象的原型
- JavaScript 的函数对象，除了原型 `__proto__` 之外，还预置了 prototype 属性
- 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 `__proto__`。
- `Object` 是所有对象的父级，所有对象都可以通过 `__proto__` 找到它
- `Function` 是所有函数的父级，所有函数都可以通过 `__proto__` 找到它
- 函数的 `prototype` 是一个对象
- 对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链

## instanceof

### instanceof

instanceof 可以准确的判断复杂数据类型，但是不能正确判断基本数据类型。能够判断一个对象与构造函数是否在一个原型链上

```js
const Person = function() {};
const p1 = new Person();
p1 instanceof Person; // true

var str = 'hello world';
str instanceof String; // false

var str1 = new String('hello world');
str1 instanceof String; // true
```

`instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

```js
function instanceof(left, right) {
  // 获得类型的原型
  let prototype = right.prototype;
  // 获得对象的原型
  left = left.__proto__;
  // 判断对象的类型是否等于类型的原型
  while (true) {
    if (left === null) return false;
    if (prototype === left) return true;
    left = left.__proto__;
  }
}
```

以下是对实现的分析：

- 首先获取类型的原型
- 然后获得对象的原型
- 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`

### `instanceof`的原理

- `instanceof`的**作用**：用于判断**实例**属于哪个**构造函数**。
- `instanceof`的**原理**：判断实例对象的`__proto__`属性，和构造函数的`prototype`属性，是否为同一个引用（是否指向同一个地址）。

> - **注意 1**：虽然说，实例是由构造函数 new 出来的，但是实例的`__proto__`属性引用的是构造函数的`prototype`。也就是说，实例的`__proto__`属性与构造函数本身无关。
> - **注意 2**：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找`__proto__`属性。这条链上如果能找到， instanceof 的返回结果也是 true。

比如说：

- `foo instance of Foo`的结果为 true，因为`foo.__proto__ === M.prototype`为`true`。
- **`foo instance of Object`的结果也为 true**，为`Foo.prototype.__proto__ === Object.prototype`为`true`。

> 但我们不能轻易的说：`foo` 一定是 由`Object`创建的实例`。这句话是错误的。

### 判断对象是哪个类的直接实例

使用`对象.constructor`直接可判断。

已知 A 继承了 B，B 继承了 C。怎么判断 a 是由 A**直接生成**的实例，还是 B 直接生成的实例呢？还是 C 直接生成的实例呢？

> 分析：这就要用到原型的`constructor`属性了。

`foo.__proto__.constructor === M`的结果为`true`，但是 `foo.__proto__.constructor === Object`的结果为`false`。

所以，用 `constructor`判断就比用 `instanceof`判断，更为严谨。

```js
function A() {}
const a = new A();
a.__proto__ === A.prototype; // true
A.prototype.constructor === A; // true
a.__proto__.constructor === A; // true
a.constructor === A; // true
A.constructor === Function; // true
```

## 变量提升

- 在 JavaScript 中，函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部
- 声明语句中的赋值部分并不会被提升，只有名称被提升
- 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明
- 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数

## 创建对象

### 对象的几种创建方式

1. 字面量创建（调用内置的构造函数）
2. 构造函数
3. 原型
4. Object.create()

#### 1. 字面量

```js
var obj11 = { name: 'yiliang' };
// 内置对象（内置的构造函数）
var obj12 = new Object({ name: `yiliang` });
```

> 上面的两种写法，效果是一样的。因为，第一种写法，`obj11` 会指向 `Object`。

- 第一种写法是：字面量的方式。
- 第二种写法是：内置的构造函数

内置构造函数

```js
var obj = new Object();
//等同于 var obj = {}
```

> 使用字面量的方式更简单，其实他俩是一样的。
> 优点是足够简单，缺点是每个对象都是独立的。

#### 2. 构造函数

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function() {
    alert(this.name);
  };
}
var person1 = new Person('Nicholas', 29, 'Software Engineer');
var person2 = new Person('Greg', 27, 'Doctor');
```

> 优点是 可以创建特定类型的对象，缺点是多个实例重复创建方法

以这种方式调用构造函数实际上会经历以下 4 个步骤:

1. 创建一个新对象;
2. 将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象);
3. 执行构造函数中的代码(为这个新对象添加属性);
4. 返回新对象。

缺点：使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍

#### 3. 原型

不必在构造函数中定义对象实例的信息，将这些信息直接添加到原型对象

```js
function Person() {}
Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

缺点：实例没有属于自己的全部属性的

#### 4. Object.create

`obj3`是实例，`p`是`obj3`的原型（ `name`是 p 原型里的属性），构造函数是`Object`

```js
var p = { name: 'happy' };
//此方法创建的对象，是用原型链连接的
var obj3 = Object.create(p);
```

```js
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  },
};
const me = Object.create(person);
me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten
me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
```

> 传入一个原型对象，创建一个新对象，使用现有的对象来提供新创建的对象的 `__proto__`，实现继承。

### 实现 Object.create

`Object.create(parent)`主要完成了三件事情：

- 创建一个对象
- 继承指定父对象
- 为新对象扩展新属性

何时使用 create: 希望在创建对象时就提前指定继承的父对象，并同时扩展新属性时。

```js
Object.mycreate = function(parent,props) {
  var obj = new Object();
  Object.setPrototypeOf(obj,parent);
  Object.defineProperties(obj,props);
  return obj;
}

// 用法
var father={bal:1000,car:"=b="}
// create调用的也是 defineproperty
var hmm=Object.mycreate(father,{
  phone:{//默认为false
    value:"肾6s",
    writable:true,
    enumertable:true,
    configurable:true.
  },
});
```

## 类与继承

继承的本质就是原型链

### 现在有一个函数 A 和函数 B，请你实现 B 继承 A

```js
// 方式 1
function B() {}
function A() {}
B.prototype = new A();

// 方式 2
function A() {}
function B() {
  A.call(this);
}

// 方式 3
function B() {}
function A() {}
B.prototype = new A();

function B() {
  A.call(this);
}
```

### Javascript 如何实现继承？

- 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上

```js
function Cat(name, color) {
  Animal.apply(this, arguments);
  this.name = name;
  this.color = color;
}
```

- 实例继承：将子对象的 prototype 指向父对象的一个实例

```js
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
```

- 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象

```js
function extend(Child, Parent) {
  let p = Parent.prototype;
  let c = Child.prototype;
  for (let i in p) {
    c[i] = p[i];
  }
  c.uber = p;
}
```

- 原型继承：将子对象的 prototype 指向父对象的 prototype

```js
function extend(Child, Parent) {
  let F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
  Child.uber = Parent.prototype;
}
```

- ES6 语法糖 extends：class ColorPoint extends Point {}

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

### JS 继承的 6 种方法

1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 寄生式继承
5. 寄生组合式继承
6. class 继承

#### 1. 原型链继承

基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法, 实现的本质是重写原型对象

```js
function SuperType() {
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.property;
};

function SubType() {
  this.subProperty = false;
}

//继承了 SuperType

SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
  return this.subProperty;
};

let instance = new SubType();

console.log(instance.getSuperValue()); //true
```

存在的问题：

1. 通过原型来实现继承时，原型实际上会变成另一个类型的实例，
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数

`new Child.__proto__ === new Parent()`的结果为`true`

**分析：**

- 这种继承方式，**Child 可以继承 Parent 的原型**，但有个缺点：

> 缺点是：**如果修改 child1 实例的 name 属性，child2 实例中的 name 属性也会跟着改变**。

如下：

![](http://img.smyhvae.com/20180307_1123.png)

> 上面的代码中， `child1`修改了`arr`属性，却发现，`child2`的`arr`属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。

> 造成这种缺点的原因是：`child1`和`child2`共用原型。即：`chi1d1.__proto__ === child2__proto__`是严格相同。而 arr 方法是在 Parent 的实例上（即 Child 实例的原型）的。

#### 2. 借用构造函数继承

在子类型构造函数的内部调用超类型构造函数

```js
function SuperType(){
    this.colors = ["red", "blue", "green”];
}

function SubType(){
		//继承了 SuperType
    SuperType.call(this);

}

let instance1 = new SubType();

instance1.colors.push("black");

console.log(instance1.colors);    //"red,blue,green,black"

let instance2 = new SubType();

console.log(instance2.colors);    //"red,blue,green”
```

以上继承的方式核心是在子类的构造函数中通过 `Parent.call(this)` 继承父类的属性，然后改变子类的原型为 `new Parent()` 来继承父类的函数。

这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。

```js
function Parent1() {
  this.name = 'parent1 的属性';
}

function Child1() {
  Parent1.call(this); //【重要】此处用 call 或 apply 都行：改变 this 的指向
  this.type = 'child1 的属性';
}

console.log(new Child1());
```

> 【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了`Parent1.call(this);`，意思是：**让 Parent 的构造函数在 child 的构造函数中执行**。发生的变化是：**改变 this 的指向**，parent 的实例 --> 改为指向 child 的实例。导致 parent 的实例的属性挂在到了 child 的实例上，这就实现了继承。

打印结果：

![](http://img.smyhvae.com/20180307_1015.png)

> 上方结果表明：`child`先有了 `parent` 实例的属性（继承得以实现），再有了`child` 实例的属性。

**分析**：

> 这种方式，虽然改变了 `this` 的指向，但是，**Child1 无法继承 `Parent1` 的原型**。也就是说，如果我给 `Parent1` 的原型增加一个方法：

```js
Parent1.prototype.say = function() {};
```

> 上面这个方法是无法被 `Child1` 继承的。如下：

![](http://img.smyhvae.com/20180307_1030.png)

#### 3. 组合继承(原型+借用构造)

使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承

```js
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
  console.log(this.name);
};

function SubType(name, age) {
  //继承属性
  SuperType.call(this, name);
  this.age = age;
}

//继承方法

SubType.prototype = new SuperType();

SubType.prototype.constructor = SubType;

SubType.prototype.sayAge = function() {
  console.log(this.age);
};

let instance1 = new SubType('Nicholas', 29);

instance1.colors.push('black');

console.log(instance1.colors); //"red,blue,green,black"

instance1.sayName(); //"Nicholas";

instance1.sayAge(); //29

let instance2 = new SubType('Greg', 27);

console.log(instance2.colors); //"red,blue,green"

instance2.sayName(); //"Greg";

instance2.sayAge(); //27
```

- 这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。
- 这种方式的缺点是：让父亲`Parent`的构造方法执行了两次。
- `ES6`中的继承方式，一带而过即可，重点是要掌握`ES5`中的继承。

#### 4. 寄生式继承:

创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象

```js
function createAnother(original) {
  let clone = object(original); //通过调用函数创建一个新对象
  clone.sayHi = function() {
    ////以某种方式来增强这个对象
    console.log('hi');
  };
  return clone; //返回这个对象
}
let person = {
  name: 'Nicholas',
  friends: ['Shelby', 'Court', 'Van'],
};
let anotherPerson = createAnother(person);
anotherPerson.sayHi(); //"hi"
```

#### 5. 寄生组合式继承:

即通过借用构造函数来继承属性，通过原型链的混成形式来继承

```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
SuperType.prototype.sayName = function() {
  console.log(this.name);
};
function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}
function inheritPrototype(subType, superType) {
  let prototype = object(superType.prototype); //创建对象
  prototype.constructor = subType; //增强对象
  subType.prototype = prototype; //指定对象
}

inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function() {
  console.log(this.age);
};
let p1 = new SubType('Jack', 20);
p1.colors.push('white');
console.log(p1.colors); //["red", "blue", "green", "white"]
let p2 = new SubType('Mark', 18);
console.log(p2.age); //18
```

这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。

```js
function Parent(value) {
  this.val = value;
}
Parent.prototype.getValue = function() {
  console.log(this.val);
};

function Child(value) {
  Parent.call(this, value);
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

const child = new Child(1);

child.getValue(); // 1
child instanceof Parent; // true
```

以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。

![img](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/1672afb8dfa21361.jpg)

#### 6. Class 继承

以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 `class` 去实现继承，并且实现起来很简单

```js
class Parent {
  constructor(value) {
    this.val = value;
  }
  getValue() {
    console.log(this.val);
  }
}
class Child extends Parent {
  constructor(value) {
    super(value);
    this.val = value;
  }
}
let child = new Child(1);
child.getValue(); // 1
child instanceof Parent; // true
```

`class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，因为这段代码可以看成 `Parent.call(this, value)`。

当然了，之前也说了在 JS 中并不存在类，`class` 的本质就是函数。

### Class、extends 是什么，有什么作用？

`ES6` 的`class`可以看作只是一个`ES5`生成实例对象的构造函数的语法糖。它参考了`java`语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。`Class`类可以通过`extends`实现继承。它和 ES5 构造函数的不同点

类的内部定义的所有方法，都是不可枚举的

- `ES6`的`class`类必须用`new`命令操作，而`ES5`的构造函数不用`new`也可以执行。
- `ES6`的`class`类不存在变量提升，必须先定义`class`之后才能实例化，不像`ES5`中可以将构造函数写在实例化之后。
- `ES5` 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面。`ES6` 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。

### 封装一个原生的继承方法

```js
function extendsClass(Parent, Child) {
  function F() {}
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constrctor = Child;
  return Child;
}
```

### javascript 里面的继承怎么实现，如何避免原型链上面的对象共享

用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的 extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量

## new 原理

1. 创建一个新对象。
2. 这个新对象会被执行原型连接。
3. 将构造函数的作用域赋值给新对象，即 this 指向这个新对象.
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

字面量创建对象，不会调用 Object 构造函数, 简洁且性能更好;

在调用 `new` 的过程中会发生以上四件事情：

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 返回新对象

模拟 new 实现：

```js
function Foo(name, age) {
  this.name = name;
  this.age = age;
}

var nar = new Foo('tom', 18);
console.log(nar.name);
function OBK() {
  var obj = new Object(), //从Object.prototype上克隆一个对象
    Constructor = [].shift.call(arguments); //取得外部传入的构造器
  console.log(Constructor);
  var F = function() {};
  F.prototype = Constructor.prototype;
  obj = new F(); //指向正确的原型

  var ret = Constructor.apply(obj, arguments); //借用外部传入的构造器给obj设置属性

  return typeof ret === 'object' ? ret : obj; //确保构造器总是返回一个对象
}
var bar = OBK(Foo, 'jim', 15);
console.log(bar.age);
```

**先创建父类实例** => 改变实例原先的 `__proto__` 转而连接到子类的 `prototype` => 子类的 `prototype` 的 `__proto__` 改为父类的 `prototype`。

### 构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？

- 没有自己的 this，无法调用 call，apply
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto
