---
title: 闭包
date: '2020-10-26'
draft: true
---

## 闭包

闭包就是函数中的函数，里面的函数可以访问外面函数的变量。

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。闭包参数和变量不会被垃圾回收机制回收，使用完了后，要立即释放资源，将引用变量指向 null。

### 闭包的使用场景

- 封装变量，收敛权限，模拟私有化。
- cached 对象储存。
- 柯里化参数处理

### 闭包优缺点

闭包封住了变量作用域，有效地防止了全局污染；但同时，它也存在**内存泄漏**的风险：

- 在浏览器端可以通过强制刷新解决，对用户体验影响不大
- 在服务端，由于 node 的内存限制和累积效应，可能会造成进程退出甚至服务器沓机

解决方法是显式对外暴露一个接口，专门用以清理变量。

### 循环中使用闭包解决 `var` 定义函数的问题

```js
for (var i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

解决方法有 3 种

第一种，使用`立即执行函数`方式

```js
for (var i = 1; i < 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

第二种，使用 ES6 的`let`, 因为对于 `let` 来说，他会创建一个块级作用域

```js
for (let i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

相当于

```js
{
  // 形成块级作用域
  let i = 0;
  {
    let ii = i;
    setTimeout(function timer() {
      console.log(ii);
    }, i * 1000);
  }
  i++;
  {
    let ii = i;
  }
  i++;
  {
    let ii = i;
  }
  // ...
}
```

第三种，使用 `setTimeout` 的第三个参数

```js
for (var i = 1; i < 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j);
    },
    i * 1000,
    i,
  );
}
```
