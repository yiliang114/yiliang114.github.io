---
title: 模块化
date: '2020-10-26'
draft: true
---

## 模块化

使用模块化可以给我们带来以下好处

1. 解决命名冲突
2. 提供复用性
3. 提高代码可维护性

实现模块化方式：

- 立即执行函数
- AMD 和 CMD
- CommonJS
- ES Module

- **AMD**：`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
- **CMD**：`seajs` 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近
- **CommonJs**：模块输出的是一个值的 `copy`，运行时加载，加载的是一个对象（`module.exports` 属性），该对象只有在脚本运行完才会生成
- **ES6 Module**：模块输出的是一个值的引用，编译时输出接口，`ES6`模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。

主要是 4 种：

- CommonJS -- node
- AMD(异步模块定义) -- require.js
- CMD(通用模块定义) -- sea.js
- ES6 模块

### 介绍模块化发展历程

可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、`<script type="module">` 这几个角度考虑。

**IIFE**： 使用自执行函数来编写模块化，特点：**在一个单独的函数作用域中执行代码，避免变量冲突**。

```js
(function() {
  return {
    data: [],
  };
})();
```

在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题

**AMD**： 使用 requireJS 来编写模块化，特点：**依赖必须提前声明好**。

```js
define('./index.js', function(code) {
  // code 就是index.js 返回的内容
});
```

**CMD**： 使用 seaJS 来编写模块化，特点：**支持动态引入依赖文件**。

```js
define(function(require, exports, module) {
  var indexCode = require('./index.js');
});
```

可以把 require 写在函数体的任意地方实现延迟加载,推崇依赖就近

**CommonJS**： nodejs 中自带的模块化。

```js
var fs = require('fs');
```

**UMD**：兼容 AMD，CommonJS 模块化语法。

**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。

**ES Modules**： ES6 引入的模块化，支持 import 来引入另一个 js 。

### CommonJS

主要用在服务器端 node.js

`CommonJs` 是 Node 独有的规范，浏览器中使用就需要用到 `Browserify` 解析了。

```js
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;

// b.js
var module = require('./a.js');
module.a; // -> log 1
```

在上述代码中，`module.exports` 和 `exports` 很容易混淆，让我们来看看大致内部实现

```js
var module = require('./a.js');
module.a;
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
  a: 1,
};
// 基本实现
var module = {
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports;
var load = function(module) {
  // 导出的东西
  var a = 1;
  module.exports = a;
  return module.exports;
};
```

再来说说 `module.exports` 和 `exports`，用法其实是相似的，但是不能对 `exports` 直接赋值，不会有任何效果。

对于 `CommonJS` 和 ES6 中的模块化的两者区别是：

- 前者支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
- 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响

- 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- 后者会编译成 `require/exports` 来执行的

CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```js
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;

// b.js
var module = require('./a.js');
module.a; // -> log 1
```

因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析

先说 `require` 吧

```js
var module = require('./a.js');
module.a;
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
  a: 1,
};
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports;
var load = function(module) {
  // 导出的东西
  var a = 1;
  module.exports = a;
  return module.exports;
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。

**Node CommonJS**:

ES6 标准发布后，module 成为标准，标准的使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，我们采用的是 CommonJS 规范，使用 require 引入模块，使用 module.exports 导出接口。

node 的 module 遵循 CommonJS 规范，requirejs 遵循 AMD，seajs 遵循 CMD，虽各有不同，但总之还是希望保持较为统一的代码风格。

```js
// b.js
// ------------ node ---------
var m = require('./a');
m.a();

// ------------ AMD or CMD -------------
define(function(require, exports, module) {
  var m = require('./a');
  m.a();
});
```

ES6 发布的 module 并没有直接采用 CommonJS，甚至连 require 都没有采用，也就是说 require 仍然只是 node 的一个私有的全局方法，module.exports 也只是 node 私有的一个全局变量属性。

###### export

```js
// a.js
export default function() {}
export function a() {}

var b = 'xxx';
export { b }; // 这是ES6的写法，实际上就是{b:b}
setTimeout(() => (b = 'ooo'), 1000);
export var c = 100;
```

###### import

import 的语法跟 require 不同，而且 import 必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。

```js
import $ from 'jquery';
import * as _ from '_';
import { a, b, c } from './a';
import { default as alias, a as a_a, b, c } from './a';
```

###### as 关键字

简单的说就是取一个别名。export 中可以用，import 中其实可以用

```js
// a.js
var a = function() {};
export { a as fun };

// b.js
import { fun as a } from './a';
a();
```

###### default 关键字

在 export 的时候，可能会用到 default，说白了，它其实是别名的语法糖：

```js
// d.js
export default function() {}

// 等效于：
function a() {}
export { a as default };
```

在 import 的时候，可以这样用：

```js
import a from './d';

// 等效于，或者说就是下面这种写法的简写，是同一个意思
import { default as a } from './d';
```

这个语法糖的好处就是 import 的时候，可以省去花括号{}。简单的说，如果 import 的时候，你发现某个变量没有花括号括起来（没有\*号），那么你在脑海中应该把它还原成有花括号的 as 语法。

所以，下面这种写法你也应该理解了吧

```js
import $, { each, map } from 'jquery';
```

`import 后面第一个$是{defalut as $}`的替代写法。

###### \* 符号

\*就是代表所有，只用在 import 中，我们看下两个例子：

```js
import * as _ from '_';
```

在意义上和 `import _ from '_';`是不同的，虽然实际上后面的使用方法是一样的。它表示的是把'*'模块中的所有接口挂载到*这个对象上，所以可以用`_.each` 调用某个接口。

另外还可以通过`*`号直接继承某一个模块的接口：

```js
export * from '_';

// 等效于：
import * as all from '_';
export all;
```

`*`符号尽可能少用，它实际上是使用所有 `export` 的接口，但是很有可能你的当前模块并不会用到所有接口，可能仅仅是一个，所以最好的建议是使用花括号，用一个加一个。

##### 用 require 还是 import？

require 的使用非常简单，它相当于 module.exports 的传送门，module.exports 后面的内容是什么，require 的结果就是什么，对象、数字、字符串、函数……再把 require 的结果赋值给某个变量，相当于把 require 和 module.exports 进行平行空间的位置重叠。

而且 require 理论上可以运用在代码的任何地方，甚至不需要赋值给某个变量之后再使用，比如：

```js
require('./a')(); // a模块是一个函数，立即执行a模块函数
var data = require('./a').data; // a模块导出的是一个对象
var a = require('./a')[0]; // a模块导出的是一个数组
```

你在使用时，完全可以忽略模块化这个概念来使用 require，仅仅把它当做一个 node 内置的全局函数，它的参数甚至可以是表达式：

```js
require(process.cwd() + '/a');
```

但是 import 则不同，它是编译时的（require 是运行时的），它必须放在文件开头，而且使用格式也是确定的，不容置疑。它不会将整个模块运行后赋值给某个变量，而是只选择 import 的接口进行编译，**这样在性能上比 require 好很多**。

从理解上，require 是赋值过程，import 是解构过程，当然，require 也可以将结果解构赋值给一组变量，但是 import 在遇到 default 时，和 require 则完全不同：`var $ = require('jquery');` 和 `import $ from 'jquery'` 是完全不同的两种概念。

上面完全没有回答“改用 require 还是 import？”这个问题，因为这个问题就目前而言，根本没法回答，因为目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require。这也是为什么在模块导出时使用 module.exports，在引入模块时使用 import 仍然起效，因为本质上，import 会被转码为 require 去执行。

### ES Module

目前 js 社区有 4 种模块管理规范：AMD、CMD、CommonJS 和 EsModule。 ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：

- CommonJS 支持动态导入，也就是 require(\${path}/xx.js)，后者目前不支持，但是已有提案
- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 require/exports 来执行的

```js
// 引入模块 API
import XXX from './a.js';
import { XXX } from './a.js';
// 导出模块 API
export function a() {}
export default function() {}
```

### ES Modules 特性

那对于 ES Modules 的学习，可以从两个维度入手。首先，你需要了解它作为一个规范或者说标准，到底约定了哪些特性和语法；其次，你需要学习如何通过一些工具和方案去解决运行环境兼容带来的问题。

按照 ES Modules 的标准，这里的 index.html 可以直接在浏览器中正常工作，但是对于不支持 ES Modules 标准的浏览器，直接使用就会出现错误，所以我们需要使用 Webpack 这样的工具，将我们这里按照模块化方式拆分的 JS 代码再次打包到一起。

### ES6 模块和 CommonJS 模块的差异？

1. ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 模块，运行时加载。
2. ES6 模块自动采用严格模式，无论模块头部是否写了 "use strict";
3. require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。
4. ES6 模块中顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。
5. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

CommonJS 中的 require/exports 和 ES6 中的 import/export 区别:

1. CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。
1. ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
1. import/export 最终都是编译为 require/exports 来执行的。
1. CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
1. export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系

### 听说过 UMD 吗？可以简要介绍一下吗？

### 常见问题

- a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?
- 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 `t = 111` 能否在 a 中直接打印出来?
- 如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题?

### 其他

- npm 包 的 UMD 文件是什么？ UMD 与 webpack 之类的 CommonJS 模块打包器有什么关系，是否只能用 webpack 之类的打包器进行打包？
- require 写在里面是为了清除缓存！！！

实现拖拽功能，比如把 5 个兄弟节点中的最后一个节点拖拽到节点 1 和节点 2 之间
动画：setTimeout 何时执行，requestAnimationFrame 的优点
