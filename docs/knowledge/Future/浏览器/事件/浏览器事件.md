---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

## 浏览器的事件

### 事件冒泡中 ​this 和 event.target 的区别?

js 中事件是会冒泡的，所以 this 是可以变化的，但 event.target 不会变化，它永远是直接接受事件的目标 DOM 元素；

### DOM 元素 e 的 e.getAttribute(propName) 和 e.propName 有什么区别和联系

- e.getAttribute()，是标准 DOM 操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性
- e.propName 通常是在 HTML 文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如 a 标签生成 HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用 getAttribute 进行访问
- e.getAttribute()返回值是源文件中设置的值，类型是字符串或者 null（有的实现返回""）
- e.propName 返回值可能是字符串、布尔值、对象、undefined 等
- 大部分 attribute 与 property 是一一对应关系，修改其中一个会影响另一个，如 id，title 等属性
- 一些布尔属性的检测设置需要 hasAttribute 和 removeAttribute 来完成，或者设置对应 property
- 像 link 中 href 属性，转换成 property 的时候需要通过转换得到完整 URL
- 一些 attribute 和 property 不是一一对应如：form 控件中对应的是 defaultValue，修改或设置 value property 修改的是控件当前值，setAttribute 修改 value 属性不会改变 value property

### js 如何自定义事件？

1. 使用 new Event()
   获取不到 event.detail

```js
let btn = document.querySelector('#btn');
let ev = new Event('alert', {
  bubbles: true, //事件是否冒泡;默认值false
  cancelable: true, //事件能否被取消;默认值false
  composed: false,
});
btn.addEventListener(
  'alert',
  function(event) {
    console.log(event.bubbles); //true
    console.log(event.cancelable); //true
    console.log(event.detail); //undefined
  },
  false,
);
btn.dispatchEvent(ev);
```

2. 使用 createEvent('CustomEvent') (DOM3)

要创建自定义事件，可以调用 createEvent('CustomEvent')，返回的对象有 initCustomEvent 方法，接受以下四个参数:

type: 字符串，表示触发的事件类型，如此处的'alert'
bubbles: 布尔值： 表示事件是否冒泡
cancelable: 布尔值，表示事件是否可以取消
detail: 任意值，保存在 event 对象的 detail 属性中

```js
let btn = document.querySelector('#btn');
let ev = btn.createEvent('CustomEvent');
ev.initCustomEvent('alert', true, true, 'button');
btn.addEventListener(
  'alert',
  function(event) {
    console.log(event.bubbles); //true
    console.log(event.cancelable); //true
    console.log(event.detail); //button
  },
  false,
);
btn.dispatchEvent(ev);
```

3. 使用 new customEvent() (DOM4)
   使用起来比 createEvent('CustomEvent') 更加方便

```js
var btn = document.querySelector('#btn');
/*
 * 第一个参数是事件类型
 * 第二个参数是一个对象
 */
var ev = new CustomEvent('alert', {
  bubbles: 'true',
  cancelable: 'true',
  detail: 'button',
});
btn.addEventListener(
  'alert',
  function(event) {
    console.log(event.bubbles); //true
    console.log(event.cancelable); //true
    console.log(event.detail); //button
  },
  false,
);
btn.dispatchEvent(ev);
```

扩展： 自定义非 DOM 事件(观察者模式)
EventTarget 类型有一个单独的属性 handlers，用于存储事件处理程序（观察者）。
addHandler() 用于注册给定类型事件的事件处理程序；
fire() 用于触发一个事件；
removeHandler() 用于注销某个事件类型的事件处理程序

```js
function EventTarget() {
  this.handlers = {};
}

EventTarget.prototype = {
  constructor: EventTarget,
  addHandler: function(type, handler) {
    if (typeof this.handlers[type] === 'undefined') {
      this.handlers[type] = [];
    }
    this.handlers[type].push(handler);
  },
  fire: function(event) {
    if (!event.target) {
      event.target = this;
    }
    if (this.handlers[event.type] instanceof Array) {
      const handlers = this.handlers[event.type];
      handlers.forEach(handler => {
        handler(event);
      });
    }
  },
  removeHandler: function(type, handler) {
    if (this.handlers[type] instanceof Array) {
      const handlers = this.handlers[type];
      for (var i = 0, len = handlers.length; i < len; i++) {
        if (handlers[i] === handler) {
          break;
        }
      }
      handlers.splice(i, 1);
    }
  },
};
//使用
function handleMessage(event) {
  console.log(event.message);
}
//创建一个新对象
var target = new EventTarget();
//添加一个事件处理程序
target.addHandler('message', handleMessage);
//触发事件
target.fire({ type: 'message', message: 'Hi' }); //Hi
//删除事件处理程序
target.removeHandler('message', handleMessage);
//再次触发事件，没有事件处理程序
target.fire({ type: 'message', message: 'Hi' });
```

### focus/blur 与 focusin/focusout 的区别与联系

1. focus/blur 不冒泡，focusin/focusout 冒泡
2. focus/blur 兼容性好，focusin/focusout 在除 FireFox 外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在 FireFox 下使用事件捕获 elem.addEventListener('focus', handler, true)
3. 可获得焦点的元素：

- window
- 链接被点击或键盘操作
- 表单空间被点击或键盘操作
- 设置 tabindex 属性的元素被点击或键盘操作

### mouseover/mouseout 与 mouseenter/mouseleave 的区别与联系

1. mouseover/mouseout 是标准事件，所有浏览器都支持；mouseenter/mouseleave 是 IE5.5 引入的特有事件后来被 DOM3 标准采纳，现代标准浏览器也支持
2. mouseover/mouseout 是冒泡事件；mouseenter/mouseleave 不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐 mouseover/mouseout 托管，提高性能
3. 标准事件模型中 event.target 表示发生移入/出的元素,vent.relatedTarget 对应移出/如元素；在老 IE 中 event.srcElement 表示发生移入/出的元素，event.toElement 表示移出的目标元素，event.fromElement 表示移入时的来源元素

鼠标从 div#target 元素移出时进行处理，判断逻辑如下

```js
<div id="target"><span>test</span></div>

<script type="text/javascript">
var target = document.getElementById('target');
if (target.addEventListener) {
  target.addEventListener('mouseout', mouseoutHandler, false);
} else if (target.attachEvent) {
  target.attachEvent('onmouseout', mouseoutHandler);
}

function mouseoutHandler(e) {
  e = e || window.event;
  var target = e.target || e.srcElement;

  // 判断移出鼠标的元素是否为目标元素
  if (target.id !== 'target') {
    return;
  }

  // 判断鼠标是移出元素还是移到子元素
  var relatedTarget = event.relatedTarget || e.toElement;
  while (relatedTarget !== target
    && relatedTarget.nodeName.toUpperCase() !== 'BODY') {
    relatedTarget = relatedTarget.parentNode;
  }

  // 如果相等，说明鼠标在元素内部移动
  if (relatedTarget === target) {
    return;
  }

  // 执行需要操作
  //alert('鼠标移出');

}
</script>
```

### 一个原生的`<input>`标签都有些什么事件？在浏览器上 onchange 什么时候触发？

### onchange 是怎么触发的？

当 input 捕获到焦点后，系统储存当前值，当 input 焦点离开后，判断当前值与之前存储的值是否不等，如果为 true 则触发 onchange 事件。非 ie 敲回车也可以实现触发

### 原生的变化如何监听？怎么知道 input 框的值是改变了？

在`<input>`上添加一个属性`defaultValue`,用来做对比，或者将原始值记录下来。

### 事件、IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？

1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
2. 事件处理机制：IE 是事件冒泡、firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；
3. ev.stopPropagation();注意旧 ie 的方法 ev.cancelBubble = true;

### Keyboard 事件

| 属性       | 值     | 描述                   |
| ---------- | ------ | ---------------------- |
| onkeydown  | script | 在用户按下按键时触发。 |
| onkeypress | script | 在用户敲击按钮时触发。 |
| onkeyup    | script | 当用户释放按键时触发。 |

### Mouse 事件

| 属性         | 值     | 描述                                           |
| ------------ | ------ | ---------------------------------------------- |
| onclick      | script | 元素上发生鼠标点击时触发。                     |
| ondblclick   | script | 元素上发生鼠标双击时触发。                     |
| ondrag       | script | 元素被拖动时运行的脚本。                       |
| ondragend    | script | 在拖动操作末端运行的脚本。                     |
| ondragenter  | script | 当元素元素已被拖动到有效拖放区域时运行的脚本。 |
| ondragleave  | script | 当元素离开有效拖放目标时运行的脚本。           |
| ondragover   | script | 当元素在有效拖放目标上正在被拖动时运行的脚本。 |
| ondragstart  | script | 在拖动操作开端运行的脚本。                     |
| ondrop       | script | 当被拖元素正在被拖放时运行的脚本。             |
| onmousedown  | script | 当元素上按下鼠标按钮时触发。                   |
| onmousemove  | script | 当鼠标指针移动到元素上时触发。                 |
| onmouseout   | script | 当鼠标指针移出元素时触发。                     |
| onmouseover  | script | 当鼠标指针移动到元素上时触发。                 |
| onmouseup    | script | 当在元素上释放鼠标按钮时触发。                 |
| onmousewheel | script | 当鼠标滚轮正在被滚动时运行的脚本。             |
| onscroll     | script | 当元素滚动条被滚动时运行的脚本。               |

## 事件概念

### 为什么 JavaScript 是单线程？

JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。

JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

### 解释 JavaScript 并发模型

由于 js 是单线程的，这意味着需要有一个队列保存异步执行的代码
JavaScript 主线程在执行时，如果遇到异步的代码，就会将这些代码加入到异步队列中，然后继续执行同步代码栈中的代码
当同步代码栈被清空后，意味着同步代码已经执行完毕，这时就开始执行异步队列中代码。
异步队列中的代码在执行时，会将其的回调函数和相关的函数调用放到同步代码栈中去执行。当同步代码栈被清空，意味着当前的异步任务已经执行完毕，然后从异步队列中取下一个任务执行，循环往复
以上就是一个基本的 JavaScript 并发模型

### JavaScript 实现异步编程的方法？

- 回调函数
- 事件监听
- 发布/订阅
- Promises 对象
- Async 函数[ES7]

### 异步任务

- setTimeOut、setInterval
- DOM 事件
- Promise

### 关于 setTimeOut、setImmediate、process.nextTick()的比较

#### setTimeout()

将事件插入到了事件队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。
当主线程时间执行过长，无法保证回调会在事件指定的时间执行。
浏览器端每次 setTimeout 会有 4ms 的延迟，当连续执行多个 setTimeout，有可能会阻塞进程，造成性能问题。

#### setImmediate()

事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行。和 setTimeout(fn,0)的效果差不多。
服务端 node 提供的方法。浏览器端最新的 api 也有类似实现:window.setImmediate,但支持的浏览器很少。

#### process.nextTick()

插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。
大致流程：当前”执行栈”的尾部–>下一次 Event Loop（主线程读取”任务队列”）之前–>触发 process 指定的回调函数。
服务器端 node 提供的办法。用此方法可以用于处于异步延迟的问题。
可以理解为：此次不行，预约下次优先执行。

### 请问调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？

https://github.com/Rashomon511/LearningRecord/issues/278

### 任务队列的本质

- 所有同步任务都在主线程上执行，形成一个**执行栈**（execution context stack）。
- 主线程之外，还存在一个”**任务队列**”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。
- 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
- 主线程不断重复上面的第三步。

### mouseover 和 mouseenter 的区别

mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout
mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave

### 如何在 JavaScript 中检测触摸事件？

1. touchstart
   当手指放在屏幕上触发。
2. touchmove
   当手指在屏幕上滑动时，连续地触发。
3. touchend
   当手指从屏幕上离开时触发。
4. touchcancel
   当系统停止跟踪时触发，系统什么时候取消，文档没有明确的说明

- js 的 uglify 如何实现
- Javascript 中 callee 和 caller 的作用？

  - arguments.callee 属性包含当前正在执行的函数。
  - Function.caller 返回一个对函数的引用，该函数调用了当前函数。

- 手指点击可以触控的屏幕时，是什么事件？

### 介绍 DOM0，DOM2，DOM3 事件处理方式区别

- DOM0 级事件处理方式：
  - `btn.onclick = func;`
  - `btn.onclick = null;`
- DOM2 级事件处理方式：
  - `btn.addEventListener('click', func, false);`
  - `btn.removeEventListener('click', func, false);`
  - `btn.attachEvent("onclick", func);`
  - `btn.detachEvent("onclick", func);`
- DOM3 级事件处理方式：
  - `eventUtil.addListener(input, "textInput", func);`
  - `eventUtil` 是自定义对象，`textInput` 是 DOM3 级事件

### 事件的三个阶段

- 捕获、目标、冒泡

### 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？

- 按照 W3C 标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段
- 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数
  - 注意 1：前提是事件被确实触发
  - 注意 2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”
- 事件执行顺序：判断的关键是否目标元素
  - 非目标元素：根据 W3C 的标准执行：捕获->目标元素->冒泡（不依据事件绑定顺序）
  - 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）
  - 最终顺序：父元素捕获->目标元素事件 1->目标元素事件 2->子元素捕获->子元素冒泡->父元素冒泡
  - 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系

### 在一个 DOM 上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？

- 该 DOM 上的事件如果被触发，会执行两次（执行次数等于绑定次数）
- 如果该 DOM 是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获
- 如果该 DOM 是处于事件流中的非目标元素，则先执行捕获，后执行冒泡

### 事件的代理/委托

- 事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件
  - 优点：
    - 可以减少事件注册，节省大量内存占用
    - 可以将事件应用于动态添加的子元素上
  - 缺点：
    使用不当会造成事件在不应该触发时触发
  - 示例：

```
ulEl.addEventListener('click', function(e){
    var target = event.target || event.srcElement;
    if(!!target && target.nodeName.toUpperCase() === "LI"){
        console.log(target.innerHTML);
    }
}, false);
```

### IE 的事件处理和 W3C 的事件处理有哪些区别？

- 绑定事件

  - W3C: targetEl.addEventListener('click', handler, false);
  - IE: targetEl.attachEvent('onclick', handler);

- 删除事件

  - W3C: targetEl.removeEventListener('click', handler, false);
  - IE: targetEl.detachEvent(event, handler);

- 事件对象

  - W3C: var e = arguments.callee.caller.arguments[0]
  - IE: window.event

- 事件目标

  - W3C: e.target
  - IE: window.event.srcElement

- 阻止事件默认行为

  - W3C: e.preventDefault()
  - IE: window.event.returnValue = false

- 阻止事件传播
  - W3C: e.stopPropagation()
  - IE: window.event.cancelBubble = true

### W3C 事件的 target 与 currentTarget 的区别？

- target 只会出现在事件流的目标阶段
- currentTarget 可能出现在事件流的任何阶段
- 当事件流处在目标阶段时，二者的指向相同
- 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)

### 如何派发事件(dispatchEvent)？（如何进行事件广播？）

- W3C: 使用 dispatchEvent 方法
- IE: 使用 fireEvent 方法

```js
var fireEvent = function(element, event) {
  if (document.createEventObject) {
    var mockEvent = document.createEventObject();
    return element.fireEvent('on' + event, mockEvent);
  } else {
    var mockEvent = document.createEvent('HTMLEvents');
    mockEvent.initEvent(event, true, true);
    return !element.dispatchEvent(mockEvent);
  }
};
```

**DOM 事件模型**

> `DOM`事件模型讲的就是**捕获和冒泡**，一般人都能回答出来。

- 捕获：从上往下。
- 冒泡：从下（目标元素）往上。

**DOM 事件流**

> `DOM`事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。

**完整的事件流，分三个阶段：**

1. 捕获：从 `window` 对象传到 目标元素。
2. 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。
3. 冒泡：从**目标元素**传到 `Window` 对象。

![
http://img.smyhvae.com/20180306_1058.png)

![
http://img.smyhvae.com/20180204_1218.jpg)

**描述 DOM 事件捕获的具体流程**

> 很少有人能说完整。

**捕获的流程**

![
http://img.smyhvae.com/20180306_1103.png)

**说明**：捕获阶段，事件依次传递的顺序是：`window` --> `document` --> `html`--> `body` --> 父元素、子元素、目标元素。

- PS1：第一个接收到事件的对象是 **window**（有人会说`body`，有人会说`html`，这都是错误的）。
- PS2：`JS`中涉及到`DOM`对象时，有两个对象最常用：`window`、`doucument`。它们俩也是最先获取到事件的。

代码如下：

```js
window.addEventListener(
  'click',
  function() {
    alert('捕获 window');
  },
  true,
);

document.addEventListener(
  'click',
  function() {
    alert('捕获 document');
  },
  true,
);

document.documentElement.addEventListener(
  'click',
  function() {
    alert('捕获 html');
  },
  true,
);

document.body.addEventListener(
  'click',
  function() {
    alert('捕获 body');
  },
  true,
);

fatherBox.addEventListener(
  'click',
  function() {
    alert('捕获 father');
  },
  true,
);

childBox.addEventListener(
  'click',
  function() {
    alert('捕获 child');
  },
  true,
);
```

**补充一个知识点：**

> 在 `js`中：

- 如果想获取 `body` 节点，方法是：`document.body`；
- 但是，如果想获取 `html`节点，方法是`document.documentElement`。

**冒泡的流程**

> 与捕获的流程相反

**Event 对象的常见 api 方法**

> 用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过`Event`对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：

**方法一**

```js
event.preventDefault();
```

- 解释：阻止默认事件。
- 比如，已知`<a>`标签绑定了 click 事件，此时，如果给`<a>`设置了这个方法，就阻止了链接的默认跳转。

**方法二：阻止冒泡**

> 这个在业务中很常见。

> 有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件`A`，单击父元素做事件 B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件`A`。这个时候，就要用到阻止冒泡了。

> `w3c`的方法：（火狐、谷歌、`IE11`）

```js
event.stopPropagation();
```

> `IE10`以下则是：

```js
event.cancelBubble = true;
```

> 兼容代码如下：

```js
box3.onclick = function(event) {
  alert('child');

  //阻止冒泡
  event = event || window.event;

  if (event && event.stopPropagation) {
    event.stopPropagation();
  } else {
    event.cancelBubble = true;
  }
};
```

> 上方代码中，我们对`box3`进行了阻止冒泡，产生的效果是：事件不会继续传递到 `father`、`grandfather`、`body`了。

**方法三：设置事件优先级**

```js
event.stopImmediatePropagation();
```

这个方法比较长，一般人没听说过。解释如下：

> 比如说，我用`addEventListener`给某按钮同时注册了事件`A`、事件`B`。此时，如果我单击按钮，就会依次执行事件 A 和事件`B`。现在要求：单击按钮时，只执行事件 A，不执行事件`B`。该怎么做呢？这是时候，就可以用到`stopImmediatePropagation`方法了。做法是：在事件 A 的响应函数中加入这句话。

> 大家要记住 `event` 有这个方法。

**属性 4、属性 5（事件委托中用到）**

```js
event.currentTarget; //当前所绑定的事件对象。在事件委托中，指的是【父元素】。
event.target; //当前被点击的元素。在事件委托中，s
```

上面这两个属性，在事件委托中经常用到。

> **总结**：上面这几项，非常重要，但是容易弄混淆。

**自定义事件**

> 自定义事件的代码如下：

```js
var myEvent = new Event('clickTest');
element.addEventListener('clickTest', function() {
  console.log('smyhvae');
});

//元素注册事件
element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest
```

> 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：

```js
var myEvent = new Event('clickTest');

element.addEventListener('clickTest', function() {
  console.log('smyhvae');
});

setTimeout(function() {
  element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest
}, 1000);
```

### IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？

IE 只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获。

阻止冒泡：

- 取消默认操作
  - w3c 的方法是 e.preventDefault()
  - IE 则是使用 e.returnValue = false;
- return false
  - javascript 的 return false 只会阻止默认行为
  - 是用 jQuery 的话则既阻止默认行为又防止对象冒泡。
- 阻止冒泡
  - w3c 的方法是 e.stopPropagation()
  - IE 则是使用 e.cancelBubble = true

```js
function stopHandler(event)
  window.event
  ? window.event.cancelBubble = true
  : event.stopPropagation();
}
```

### 简要介绍事件代理，以及什么时候使用，事件代理发生在事件处理流程的哪个阶段，有什么好处？

事件代理就是说我们将事件添加到本来要添加事件的父节点，将事件委托给父节点来触发处理函数，这通常会在
这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加
点击事件，这时可以使用事件代理，通过判断 e.target.nodeName 来判断发生的具体元素，从而判断是否是在
列表项中触发，这样的好处是可以减少事件绑定，同时动态的 DOM 结构仍然可以监听。事件代理发生在冒泡阶段。

### 什么是事件循环（EVENT LOOP）？

我们常常说 js 是单线程的，是指 js 执行引擎是单线程的，除了这个单线程，还有一个
任务队列，在执行 js 代码的过程中，执行引擎遇到注册的延时方法，如定时器，DOM 事件，
会将这些方法交给相应的浏览器模块处理，当这些延时方法有触发条件去触发的时候，
这些延时方法会被添加至任务队列，而这些任务队列中的方法只有 js 的主线程空闲了才会执行，
这也就是说我们常常用的定时器定的时间参数只是一个触发条件，具体多少时间后执行其实还需要看
js 主线程空闲与否

参考：

[【转向 Javascript 系列】从 setTimeout 说事件循环模型
http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/)

[深入浅出 Javascript 事件循环机制(上)
https://zhuanlan.zhihu.com/p/26229293)

[深入浅出 JavaScript 事件循环机制(下)
https://zhuanlan.zhihu.com/p/26238030)

[并发模型与事件循环
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)

### 如何阻止事件冒泡和默认事件？

标准的 DOM 对象中可以使用事件对象的 stopPropagation()方法来阻止事件冒泡，但在 IE8 以下中 IE 的事件对象通过设置事件对象的 cancelBubble 属性为 true 来阻止冒泡；
默认事件的话通过事件对象的 preventDefault()方法来阻止，而 IE 通过设置事件对象的 returnValue 属性为 false 来阻止默认事件。

### addEventListener 有哪些参数？

有三个参数，第一个是事件的类型，第二个是事件的回调函数，第三个是一个表示事件是冒泡阶段还是捕获阶段捕获的布尔值，true 表示捕获，false 表示冒泡

- browser Event
  ![imagepng
  http://media.zhijianzhang.cn//file/2018/11/121062e1d2054e9d942cebe57ca14ea6_image.png)

  ```js
  window.event; // 事件什么时候能够使用 ？
  ```

### 浏览器事件代理机制的原理是什么？

事件代理又称为事件委托，在祖先级 DOM 元素绑定一个事件，当触发子孙级 DOM 元素的事件时，利用事件冒泡的原理来触发绑定在祖先级 DOM 的事件。因为事件会从目标元素一层层冒泡至 document 对象

为什么要事件代理？

1. 添加到页面上的事件数量会影响页面的运行性能，如果添加的事件过多，会导致网页的性能下降。采用事件代理的方式，可以大大减少注册事件的个数。
   事件代理的当时，某个子孙元素是动态增加的，不需要再次对其进行事件绑定。
2. 不用担心某个注册了事件的 DOM 元素被移除后，可能无法回收其事件处理程序，我们只要把事件处理程序委托给更高层级的元素，就可以避免此问题

当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。

```js
var delegate = function(client, clientMethod) {
  return function() {
    return clientMethod.apply(client, arguments);
  };
};
var agentMethod = delegate(client, clientMethod);
agentMethod();
```

事件绑定和普通事件有什么区别
IE 和 DOM 事件流的区别

- 什么是事件循环 (event loop)？
  - 请问调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？

### 请解释事件代理 (event delegation)。

```
var div1 = document.getElementById('div1')
div1.addEventListener('click',function(e){
	var target = e.target
	if(target.nodeName === 'A'){
		alert(target.innerHTML)
	}
})
```

### 请解释事件委托（event delegation）。

事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器。当触发子元素时，事件会冒泡到父元素，监听器就会触发。这种技术的好处是：

- 内存占用减少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。
- 无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。

### 请描述事件冒泡。

当一个事件在 DOM 元素上触发时，如果有事件监听器，它将尝试处理该事件，然后事件冒泡到其父级元素，并发生同样的事情。最后直到事件到达祖先元素。事件冒泡是实现事件委托的原理（event delegation）。

[[↑] 回到顶部
#js-问题)

### “attribute” 和 “property” 之间有什么区别？

“Attribute” 是在 HTML 中定义的，而 “property” 是在 DOM 上定义的。为了说明区别，假设我们在 HTML 中有一个文本框：`<input type="text" value="Hello">`。

```js
const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello
```

但是在文本框中键入“ World!”后:

```js
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

### 什么是事件循环？调用堆栈和任务队列之间有什么区别？

事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。

### 给一个`<div>`添加点击事件的方法？

- 第一种，可以直接添加`onclick`事件
  `<div onclick="alert('成功')">点击</div>`
- 第二种，DOM 级事件处理

```js
<div id="div">
<script type="text/javascript">
    var divM = document.getElementById("div");
    divM.onclick = function () {
           alert("成功");
       }
 </script>
```

DOM 级事件处理 2

```js
<script type="text/javascript">
 var oDiv = document.getElementById("div");
  oDiv.addEventListener("click", function(){
      alert("成功");
  });
 </script>
```

- 第三种， jQuery 的方式来添加

```js
$('#div').on('click', function() {
  alert('成功');
});
```

### 说说事件流吧

事件流分为两种，捕获事件流和冒泡事件流。
捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点。
冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点。

DOM 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段。

### 解释事件绑定，以及事件阻止 prevent

事件冒泡是指事件在尽可能深的元素处触发，和按嵌套顺序在父元素上的触发器。因此，当单击子元素时可以显示父级激活的处理程序

防止事件冒泡的一种方法是使用 `event.stoppropagation()` 或 `event.cancelbubble` IE < 9

### Failed to load resource 装载资源失败
