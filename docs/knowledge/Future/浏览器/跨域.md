---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

## 跨域

因为浏览器出于安全考虑，有同源策略。域名、协议或者端口有一个不同就是跨域，浏览器请求资源会失败。一个源的文档没有权利去操作另一个源的文档。这个限制体现在：

- `Cookie`、`LocalStorage`和`IndexDB`无法获取。
- 无法获取和操作`DOM`。
- 不能发送`ajax`请求。我们要注意，`ajax`只适合**同源**的通信。

### 出于什么安全考虑才会引入跨域

主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。

也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。

### 请求跨域了，那么请求到底发出去没有？

请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 ajax 就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

### 跨域通信的几种方式

1. `JSONP`
2. `WebSocket`
3. `CORS`
4. `Hash`
5. `postMessage`
6. 通过修改 `document.domain` 来跨子域
7. 使用 `window.name` 来进行跨域

#### 1. JSONP

JSONP 的原理很简单，就是利用 `<script>` 标签没有跨域限制的漏洞。通过 `<script>` 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。

```html
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
  function jsonp(data) {
    console.log(data);
  }
</script>
```

JSONP 使用简单且兼容性不错，但是只限于 `get` 请求。

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现

```js
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement('script');
  script.src = url;
  script.async = true;
  script.type = 'text/javascript';
  window[jsonpCallback] = function(data) {
    success && success(data);
  };
  document.body.appendChild(script);
}
jsonp('http://xxx', 'callback', function(value) {
  console.log(value);
});
```

##### 请解释 JSONP 的工作原理，以及它为什么不是真正的 ajax

JSONP（JSON with Padding）是一种非官方跨域数据交互协议，它允许在服务器端集成< script >标签返回至客户端，通过 javascript 回调的形式实现跨域访问。因为同源策略的原因，我们不能使用 XMLHttpRequest 与外部服务器进行通信，但是< script >可以访问外部资源，所以通过 JSON 与< script >相结合的办法，可以绕过同源策略从外部服务器直接取得可执行的 JavaScript 函数。

原理:
客户端定义一个函数，比如 jsonpCallback，然后创建< script >，src 为 url + ?jsonp=jsonpCallback 这样的形式，之后服务器会生成一个和传递过来 jsonpCallback 一样名字的参数，并把需要传递的数据当做参数传入，比如 jsonpCallback(json)，然后返回给客户端，此时客户端就执行了这个服务器端返回的 jsonpCallback(json)回调。

通俗的说，就是客户端定义一个函数然后请求，服务器端返回的 javascript 内容就是调用这个函数，需要的数据都当做参数传入这个函数了。

优点 - 兼容性好，简单易用，支持浏览器与服务器双向通信
缺点 - 只支持 GET 请求；存在脚本注入以及跨站请求伪造等安全问题

补充一点，JSONP 不使用 XMLHttpRequest 对象加载资源，不属于真正意义上的 AJAX

##### JSONP 的原理是什么？怎么实现的？

- 在`CORS`和`postMessage`以前，我们一直都是通过`JSONP`来做跨域通信的。

> JSONP 的原理：通过`<script>`标签的异步加载来实现的。比如说，实际开发中，我们发现，`head`标签里，可以通过`<script>`标签的`src`，里面放`url`，加载很多在线的插件。这就是用到了`JSONP`。

- 原理是：动态插入`script`标签，通过`script`标签引入一个`js`文件，这个`js`文件载入成功后会执行我们在`url`参数中指定的函数，并且会把我们需要的`json`数据作为参数传入
- 由于同源策略的限制，`XmlHttpRequest`只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过`script`标签实现跨域请求，然后在服务端输出`JSON`数据并执行回调函数，从而解决了跨域的数据请求
- 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持 GET 请求
- `JSONP`：`json+padding`（内填充），顾名思义，就是把`JSON`填充到一个盒子里

**JSONP 的实现：**

> 比如说，客户端这样写：

```html
<script src="http://www.smyhvae.com/?data=name&callback=myjsonp"></script>
```

> 上面的`src`中，`data=name`是 get 请求的参数，`myjsonp`是和后台约定好的函数名。
> 服务器端这样写：

```js
myjsonp({
  data: {},
});
```

> 于是，本地要求创建一个`myjsonp` 的**全局函数**，才能将返回的数据执行出来。

**实际开发中，前端的 JSONP 是这样实现的：**

```html
<script>
  var util = {};

  //定义方法：动态创建 script 标签
  /**
   * [function 在页面中注入js脚本]
   * @param  {[type]} url     [description]
   * @param  {[type]} charset [description]
   * @return {[type]}         [description]
   */
  util.createScript = function(url, charset) {
    var script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    charset && script.setAttribute('charset', charset);
    script.setAttribute('src', url);
    script.async = true;
    return script;
  };

  /**
   * [function 处理jsonp]
   * @param  {[type]} url      [description]
   * @param  {[type]} onsucess [description]
   * @param  {[type]} onerror  [description]
   * @param  {[type]} charset  [description]
   * @return {[type]}          [description]
   */
  util.jsonp = function(url, onsuccess, onerror, charset) {
    var callbackName = util.getName('tt_player'); //事先约定好的 函数名
    window[callbackName] = function() {
      //根据回调名称注册一个全局的函数
      if (onsuccess && util.isFunction(onsuccess)) {
        onsuccess(arguments[0]);
      }
    };
    var script = util.createScript(url + '&callback=' + callbackName, charset); //动态创建一个script标签
    script.onload = script.onreadystatechange = function() {
      //监听加载成功的事件，获取数据
      if (!script.readyState || /loaded|complete/.test(script.readyState)) {
        script.onload = script.onreadystatechange = null;
        // 移除该script的 DOM 对象
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
        // 删除函数或变量
        window[callbackName] = null; //最后不要忘了删除
      }
    };
    script.onerror = function() {
      if (onerror && util.isFunction(onerror)) {
        onerror();
      }
    };
    document.getElementsByTagName('head')[0].appendChild(script); //往html中增加这个标签，目的是把请求发送出去
  };
</script>
```

#### 2. WebSocket

> `WebSocket`的用法如下：

```javascript
//

var ws = new WebSocket('wss://echo.websocket.org'); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。

//把请求发出去
ws.onopen = function(evt) {
  console.log('Connection open ...');
  ws.send('Hello WebSockets!');
};

//对方发消息过来时，我接收
ws.onmessage = function(evt) {
  console.log('Received Message: ', evt.data);
  ws.close();
};

//关闭连接
ws.onclose = function(evt) {
  console.log('Connection closed.');
};
```

> 面试一般不会让你写这个代码，一般是考察你是否了解 `WebSocket`概念，知道有这么回事即可。

#### 3. CORS

CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 `XDomainRequest` 来实现。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求和复杂请求**。

服务器端对于`CORS`的支持，主要就是通过设置`Access-Control-Allow-Origin`来进行的。如果浏览器检测到相应的设置，就可以允许`ajax`进行跨域的访问

- `CORS`需要浏览器和后端同时支持
- 浏览器会自动进行 `CORS` 通信，实现 CORS 通信的关键是后端。只要后端实现了 `CORS`，就实现了跨域。
- 服务端设置 `Access-Control-Allow-Origin` 就可以开启 `CORS`。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

> `CORS` 可以理解成是**既可以同步、也可以异步**的 Ajax。

- fetch`是一个比较新的`API`，用来实现`CORS`通信。用法如下：

```javascript
// url（必选），options（可选）
fetch('/some/url/', {
  method: 'get',
})
  .then(function(response) {
    //类似于 ES6中的promise
  })
  .catch(function(err) {
    // 出错了，等价于 then 的第二个参数，但这样更好用更直观
  });
```

> 另外，如果面试官问：“CORS 为什么支持跨域的通信？”

> 答案：跨域时，浏览器会拦截`ajax`请求，并在`http`头中加`Origin`。

后台响应 options 请求类型

```shell
location ~/cgi-bin {
    if ($request_method = 'OPTIONS' ) {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header Access-Control-Allow-Methods "GET, OPTIONS, POST";
        add_header 'Access-Control-Allow-Credentials' "true";
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range';
        #add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain charset=UTF-8';
        add_header 'Content-Length' 0;
        return 204;
    }
    proxy_pass   http://127.0.0.1:80;
    add_header Access-Control-Allow-Origin '*';
    add_header 'Access-Control-Allow-Credentials' "true";
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
}
```

##### 简单请求

以 ajax 为例，当满足以下条件时，会触发简单请求

1. 使用下列方法之一：
   - `GET`
   - `HEAD`
   - `POST`
2. `Content-Type` 的值仅限于下列三者之一：
   - `text/plain`
   - `multipart/form-data`
   - `application/x-www-form-urlencoded`

请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器； `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。

##### 复杂请求

那么很显然，不符合以上条件的请求就肯定是复杂请求了。

对于复杂请求来说，首先会发起一个预检请求，该请求是 `option` 方法的，通过该请求来知道服务端是否允许跨域请求。

对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑。

以下以 express 框架举例：

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS');
  res.header(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials',
  );
  next();
});
```

该请求会验证你的 `Authorization` 字段，没有的话就会报错。

当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 `next` 方法，因为预检请求并不包含 `Authorization` 字段，所以服务端会报错。

想解决这个问题很简单，只需要在回调中过滤 `option` 方法即可

```js
res.statusCode = 204;
res.setHeader('Content-Length', '0');
res.end();
```

##### options

OPTIONS 方法比较少见，该方法用于请求服务器告知其支持哪些其他的功能和方法。通过 OPTIONS 方法，可以询问服务器具体支持哪些方法，或者服务器会使用什么样的方法来处理一些特殊资源。可以说这是一个探测性的方法，客户端通过该方法可以在不访问服务器上实际资源的情况下就知道处理该资源的最优方式。

客户端发起的这个 OPTIONS 可以说是一个“预请求”，用于探测后续真正需要发起的跨域 POST 请求对于服务器来说是否是安全可接受的，因为跨域提交数据对于服务器来说可能存在很大的安全问题。

一般的处理方式为：设置响应状态码为 204 是为了告知客户端表示该响应成功了，但是该响应并没有返回任何响应体，如果状态码为 200，还得携带多余的响应体，在这种场景下是完全多余的，只会浪费流量。

#### 4. Hash

- `url`的`#`后面的内容就叫`Hash`。**Hash 的改变，页面不会刷新**。这就是用 `Hash` 做跨域通信的基本原理。

> 补充：`url`的`?`后面的内容叫`Search`。`Search`的改变，会导致页面刷新，因此不能做跨域通信。

**使用举例：**

**场景**：我的页面 `A` 通过`iframe`或`frame`嵌入了跨域的页面 `B`。

> 现在，我这个`A`页面想给`B`页面发消息，怎么操作呢？

1. 首先，在我的`A`页面中：

```javascript
//伪代码
var B = document.getElementsByTagName('iframe');
B.src = B.src + '#' + 'jsonString'; //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B
```

2. 然后，在`B`页面中：

```javascript
// B中的伪代码
window.onhashchange = function() {
  //通过onhashchange方法监听，url中的 hash 是否发生变化
  var data = window.location.hash;
};
```

#### 5. postMessage

这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', event => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === 'http://test.com') {
    console.log('验证通过');
  }
});
```

> `H5`中新增的`postMessage()``方法，可以用来做跨域通信。既然是 H5 中新增的，那就一定要提到。

**场景**：窗口 A (`http:A.com`)向跨域的窗口 B (`http:B.com`)发送信息。步骤如下

1. 在`A`窗口中操作如下：向`B`窗口发送数据：

```javascript
// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
Bwindow.postMessage('data', 'http://B.com'); //这里强调的是B窗口里的window对象
```

2. onmessage 事件。在`B`窗口中操作如下：

```javascript
// 在窗口B中监听 message 事件
Awindow.addEventListener(
  'message',
  function(event) {
    //这里强调的是A窗口里的window对象
    console.log(event.origin); //获取 ：url。这里指：http://A.com
    console.log(event.source); //获取：A window对象
    console.log(event.data); //获取传过来的数据
  },
  false,
);
```

#### 6. document.domain

该方式只能用于**二级域名相同**的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。

只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

将子域和主域的`document.domain`设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用`document.domain`进行跨域。主域相同的使用`document.domain`

- 该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。
- 只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

#### 7. 使用 window.name 来进行跨域

`window`对象有个 name 属性，该属性有个特征：即在一个窗口(`window`)的生命周期内,窗口载入的所有的页面都是共享一个`window.name`的，每个页面对 window.name 都有读写的权限，`window.name`是持久存在一个窗口载入过的所有页面中的

### axios 的 cookie 跨域以及相关配置

```js
// 携带cookie
axios.defaults.withCredentials = true;
```

axios 默认是发送请求的时候不会带上 cookie 的，需要通过设置 withCredentials: true 来解决。 这个时候需要注意需要后端配合设置， ：

- header 信息 Access-Control-Allow-Credentials:true
- Access-Control-Allow-Origin 不可以为 `*`，因为 `*` 会和 Access-Control-Allow-Credentials:true 冲突，需配置指定的地址

并不是因为 axios 请求不能携带 cookie，axios 的原理和 ajax 一样，只不过 axios 引入了 promise，之所以不能携带 cookie，是因为后端使用了 CORS 解决了跨域，这种方式默认是不携带 cookie 的，所以需要设置这样一个参数。

开发的环境下我们前端可以自己配置个 proxy 代理就能跨域了，真正的生产环境下还需要后端的配合的。

```js
proxyTable: {
      '/api': {
        target: 'http://10.1.5.11:8080/',
        changeOrigin: true,     //跨域 TODO:
        pathRewrite: {
          '^/api': '/'
        }
      }
}
```

### fetch 发送 2 次请求的原因

fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？

原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求

网路分县站构.4 层,应市层.传输层,网路层和数据链路层.依次是 http 等应用,TCP/UDP.IP 和物理连接.然后又追问了一下 ssl 在哪一层. ssl 是 socket.是单独的一层.如果要算应该算传输层.
