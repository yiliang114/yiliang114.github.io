---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 箭头函数 => 中 this

箭头函数不会创建自己的 this,**它只会从自己的作用域链的上一层继承 this**

### 作用域与变量声明提升

- 在 JavaScript 中，函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部
- 声明语句中的赋值部分并不会被提升，只有名称被提升
- 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明
- 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数

### 函数参数是对象会发生什么问题？

```js
function test(person) {
  person.age = 26;
  person = {
    name: 'yyy',
    age: 30,
  };

  return person;
}
const p1 = {
  name: 'hy',
  age: 25,
};
const p2 = test(p1);
console.log(p1); // -> {name: "hy", age: 26}
console.log(p2); // -> {name: "yyy", age: 30}
```

`person = {}` 这一步操作就将应用与原来的分离了
![地址改变](../images/addressChange.png)

### JavaScript 中，调用函数有哪几种方式？

- 方法调用模式 Foo.foo(arg1, arg2);
- 函数调用模式 foo(arg1, arg2);
- 构造器调用模式 (new Foo())(arg1, arg2);
- call/apply 调用模式 Foo.foo.call(that, arg1, arg2);
- bind 调用模式 Foo.foo.bind(that)(arg1, arg2)();

### 箭头函数与普通函数（function）的区别是什么？为什么

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比区别：

1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，它会从自己的作用域链的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）
2. 箭头函数不可以使用 arguments 对象,，该对象在函数体内不存在，如果要用，可以用 rest 参数代替
3. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数
4. 不绑定 super 和 new.target
5. 不可以使用 new 命令，因为

### 构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？

- 没有自己的 this，无法调用 call，apply
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto

### 箭头函数与普通函数的区别？

1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象
1. 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误
1. 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替
1. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数

### JavaScript 中有哪些不同的函数调用模式

函数调用，方法调用，.call() 和 .apply(),
不同但是改变函数内的 this 指向

### 解释 function foo() {} 与 var foo = function() {} 用法的区别

var foo = function () {}
这种方式是声明了个变量，而这个变量是个方法，变量在 js 中是可以改变的,

function foo() {}
这种方式是声明了个方法，foo 这个名字无法改变

用法：

```js
b(); // 222
console.log(b); // ƒ b(){console.log(222)}
console.log(a); // undefind
a(); //  a is not a function
function b() {
  console.log(222);
}
var a = function() {
  console.log(111);
};
```

b 为函数声明，进行了变量提升( 编译后函数声明和他的赋值都会被提前),函数声明过程在整个程序执行之前的预处理就完成了，所以只要处于同一个作用域，就可以访问到，即使在定义之前调用它也可以
但是 a 只是声明了一个变量，然后进行赋值操作，变量会提升但是赋值不会提升。因为匿名函数只有在被调用时才被初始化

### 纯函数的概念？

从纯函数的概念我们可以知道纯函数具有两个特点：

- 同输入同输出
- 无副作用
  无副作用指的是函数内部的操作不会对外部产生影响（如修改全局变量的值、修改 dom 节点等）

### Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？

`hasOwnProperty`

javaScript 中 hasOwnProperty 函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。

使用方法：
`object.hasOwnProperty(proName)`
其中参数 object 是必选项。一个对象的实例。
proName 是必选项。一个属性名称的字符串值。

如果 object 具有指定名称的属性，那么 JavaScript 中 hasOwnProperty 函数方法返回 true，反之则返回 false。

### 匿名函数的典型应用场景是什么？

匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。

```js
(function() {
  // 一些代码。
})();
```

匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。

```js
setTimeout(function() {
  console.log('Hello world!');
}, 1000);
```

匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。

```js
const arr = [1, 2, 3];
const double = arr.map(function(el) {
  return el * 2;
});
console.log(double); // [2, 4, 6]
```

### 请举出一个匿名函数的典型用例

匿名函数：就是没有函数名的函数。
自执行匿名函数

- 匿名函数的基本形式为(function(){...})();
- 前面的括号包含函数体，后面的括号就是给匿名函数传递参数并立即执行之
- 匿名函数的作用是用于闭包和避免全局变量的污染以及函数名的冲突
  举例：

```js
(function() {
  alert(1);
})()(
  (function() {
    alert(2);
  })(),
);
void (function() {
  alert(3);
})();
```

用途：
匿名函数最大的用途是创建闭包（这是 JavaScript 语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用

### 请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？

function Person(){} 是函数声明
var person = Person()是调用 Person 函数，并把返回的结果保存在变量 person 中
var person = new Person()在创建一个新的 Person 对象,并把对象的引用保存在变量 person 中

这个问题问得很含糊。我猜这是在考察 JavaScript 中的构造函数（constructor）。从技术上讲，`function Person(){}`只是一个普通的函数声明。使用 PascalCase 方式命名函数作为构造函数，是一个惯例。

`var person = Person()`将`Person`以普通函数调用，而不是构造函数。如果该函数是用作构造函数的，那么这种调用方式是一种常见错误。通常情况下，构造函数不会返回任何东西，因此，像普通函数一样调用构造函数，只会返回`undefined`赋给用作实例的变量。

`var person = new Person()`使用`new`操作符，创建`Person`对象的实例，该实例继承自`Person.prototype`。另外一种方式是使用`Object.create`，例如：Object.create(Person.prototype)`。

```js
function Person(name) {
  this.name = name;
}

var person = Person('John');
console.log(person); // undefined
console.log(person.name); // Uncaught TypeError: Cannot read property 'name' of undefined

var person = new Person('John');
console.log(person); // Person { name: "John" }
console.log(person.name); // "john"
```

### caller, callee 和 arguments 分别是什么?

caller,callee 之间的关系就像是 employer 和 employee 之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments 是函数的所有参数列表，它是一个类数组的变量

```js
function parent(param1, param2, param3) {
  child(param1, param2, param3);
}

function child() {
  console.log(arguments); // { '0': 'mqin1', '1': 'mqin2', '2': 'mqin3' }
  console.log(arguments.callee); // [Function: child]
  console.log(child.caller); // [Function: parent]
}

parent('mqin1', 'mqin2', 'mqin3');
```

### js 延迟加载的方式有哪些？

1.  defer 和 async
2.  动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）
3.  按需异步载入 js

### 自执行函数?用于什么场景？好处?

自执行函数:1、声明一个匿名函数 2、马上调用这个匿名函数。
作用：创建一个独立的作用域。

好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理

场景：一般用于框架、插件等场景

### 解释下为什么接下来这段代码不是 IIFE(立即调用的函数表达式)：`function foo(){ }();` 要做哪些改动使它变成 IIFE?

IIFE（Immediately Invoked Function Expressions）代表立即执行函数。 JavaScript 解析器将 `function foo(){ }();`解析成`function foo(){ }`和`();`。其中，前者是函数声明；后者（一对括号）是试图调用一个函数，却没有指定名称，因此它会抛出`Uncaught SyntaxError: Unexpected token )`的错误。

修改方法是：再添加一对括号，形式上有两种：`(function foo(){ })()`和`(function foo(){ }())`。以上函数不会暴露到全局作用域，如果不需要在函数内部引用自身，可以省略函数的名称。

你可能会用到 `void` 操作符：`void function foo(){ }();`。但是，这种做法是有问题的。表达式的值是`undefined`，所以如果你的 IIFE 有返回值，不要用这种做法。例如：

```js
// Don't add JS syntax to this code block to prevent Prettier from formatting it.
const foo = void (function bar() {
  return 'foo';
})();

console.log(foo); // undefined
```

总是将代码包裹成一个 IIFE(Immediately-Invoked Function Expression)，用以创建独立隔绝的定义域。这一举措可防止全局命名空间被污染。
IIFE 还可确保你的代码不会轻易被其它全局命名空间里的代码所修改（i.e. 第三方库，window 引用，被覆盖的未定义的关键字等等）。

以 function 关键字开头的语句会被解析为函数声明，而函数声明是不允许直接运行的。
原因：

- js"预编译"的特点:js 在"预编译"阶段, 会解释函数声明, 但却会忽略表式.
- 当 js 执行到 function() {//code}();时, 由于 function() {//code}在"预编译"阶段已经被解释过, js 会跳过 function(){//code}, 试图去执行();, 故会报错
- 只有当解析器把这句话解析为函数表达式，才能够直接运行

IIFE 的一些作用:

1. 创建作用域，内部保存一些大量临时变量的代码防止命名冲突。
1. 一些库的外层用这种形式包起来防止作用域污染。
1. 运行一些只执行一次的代码

不推荐

```js
var x = 10,
  y = 100;
console.log(window.x + ' ' + window.y);
```

推荐

```js
(function(log, w, undefined) {
  'use strict';
  var x = 10,
    y = 100;
  log((w.x === undefined) + ' ' + (w.y === undefined));
})(window.console.log, window);
```

IIFE（立即执行的函数表达式）:无论何时，想要创建一个新的封闭的定义域，那就用 IIFE。它不仅避免了干扰，也使得内存在执行完后立即释放。所有脚本文件建议都从 IIFE 开始。立即执行的函数表达式的执行括号应该写在外包括号内。虽然写在内还是写在外都是有效的，但写在内使得整个表达式看起来更像一个整体，因此推荐这么做。

不推荐

```js
(function() {})();
```

推荐

```js
(function() {})();
```

so，用下列写法来格式化你的 IIFE 代码：

```js
(function() {
  'use strict';

  // Code goes here

})();
```

如果你想引用全局变量或者是外层 IIFE 的变量，可以通过下列方式传参：

```js
(function($, w, d) {
  'use strict';

  $(function() {
    w.alert(d.querySelectorAll('div').length);
  });
})(jQuery, window, document);
```

### 高阶函数（higher-order）的定义是什么？

高阶函数是将一个或多个函数作为参数的函数，它用于数据处理，也可能将函数作为返回结果。高阶函数是为了抽象一些重复执行的操作。一个典型的例子是`map`，它将一个数组和一个函数作为参数。`map`使用这个函数来转换数组中的每个元素，并返回一个包含转换后元素的新数组。JavaScript 中的其他常见示例是`forEach`、`filter`和`reduce`。高阶函数不仅需要操作数组的时候会用到，还有许多函数返回新函数的用例。`Function.prototype.bind`就是一个例子。

**Map 示例：**

假设我们有一个由名字组成的数组，我们需要将每个字符转换为大写字母。

```js
const names = ['irish', 'daisy', 'anna'];
```

不使用高阶函数的方法是这样：

```js
const transformNamesToUppercase = function(names) {
  const results = [];
  for (let i = 0; i < names.length; i++) {
    results.push(names[i].toUpperCase());
  }
  return results;
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
```

使用`.map(transformerFn)`使代码更简明

```js
const transformNamesToUppercase = function(names) {
  return names.map(name => name.toUpperCase());
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
```

### js 有哪些内置函数

Object Array Boolean Number String Function Date RegExp Error

### 对 Pure functions（纯函数）的理解？

纯函数是满足如下条件的函数：

- 相同输入总是会返回相同的输出。
- 不产生副作用。
- 不依赖于外部状态。

### 请举出一个匿名函数的典型用例？

### 函数传递参数时，参数的获取方法？

> this.argments 的相关问题

### 何为作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，
也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。函数的作用域在函数定义的时候就决定

### Function.proto(getPrototypeOf)是什么？

```js
Function.__proto__ == Object.prototype; //false
Function.__proto__ == Function.prototype; //true
```

### js 字符串转函数

https://blog.csdn.net/mafan121/article/details/95340284

1. eval
2. new Function
3. ...

### js 函数的 arguments 是数组吗？怎么转真实数组
