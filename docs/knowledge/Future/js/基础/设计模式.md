---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

# 设计模式

设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这种方式写的代码可以让别人更加容易阅读、维护以及复用。

生产消费者模式

https://www.cnblogs.com/tugenhua0707/p/5198407.html

至少要知道以下这些设计模式的功能、代码实现、使用场景问题:

- 单例模式
- 原型模式
- 工厂模式
- 观察者模式
- 策略模式
- 代理模式

### 工厂模式

工厂模式分为好几种，这里就不一一讲解了，以下是一个简单工厂模式的例子

```js
class Man {
  constructor(name) {
    this.name = name;
  }
  alertName() {
    alert(this.name);
  }
}

class Factory {
  static create(name) {
    return new Man(name);
  }
}

Factory.create('yck').alertName();
```

当然工厂模式并不仅仅是用来 new 出**实例**。

可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。

工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。

在 Vue 源码中，你也可以看到工厂模式的使用，比如创建异步组件

```js
export function createComponent(
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string,
): VNode | Array<VNode> | void {
  // 逻辑处理...

  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data,
    undefined,
    undefined,
    undefined,
    context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory,
  );

  return vnode;
}
```

在上述代码中，我们可以看到我们只需要调用 `createComponent` 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。

### 单例模式

单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。

单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行，以下是如何实现单例模式的例子

```js
class Singleton {
  constructor() {}
}

Singleton.getInstance = (function() {
  let instance;
  return function() {
    if (!instance) {
      instance = new Singleton();
    }
    return instance;
  };
})();

let s1 = Singleton.getInstance();
let s2 = Singleton.getInstance();
console.log(s1 === s2); // true
```

在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex

```js
let Vue; // bind on install

export function install(_Vue) {
  if (Vue && _Vue === Vue) {
    // 如果发现 Vue 有值，就不重新创建实例了
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}
```

### 适配器模式

适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。

以下是如何实现适配器模式的例子

```
class Plug {
  getName() {
    return '港版插头'
  }
}

class Target {
  constructor() {
    this.plug = new Plug()
  }
  getName() {
    return this.plug.getName() + ' 适配器转二脚插头'
  }
}

let target = new Target()
target.getName() // 港版插头 适配器转二脚插头
```

在 Vue 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 `computed` 来做转换这件事情，这个过程就使用到了适配器模式。

### 装饰模式

装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。

以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法

```
function readonly(target, key, descriptor) {
  descriptor.writable = false
  return descriptor
}

class Test {
  @readonly
  name = 'yck'
}

let t = new Test()

t.yck = '111' // 不可修改
```

在 React 中，装饰模式其实随处可见

```
import { connect } from 'react-redux'
class MyComponent extends React.Component {
    // ...
}
export default connect(mapStateToProps)(MyComponent)
```

### 代理模式

代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。

在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式。

```
<ul id="ul">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
</ul>
<script>
    let ul = document.querySelector('#ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>
```

因为存在太多的 `li`，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。

### 发布-订阅模式

发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。

在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式

```
<ul id="ul"></ul>
<script>
    let ul = document.querySelector('#ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>
```

在 Vue 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 `get` 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。

### 外观模式

外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。

举个例子来说，我们现在需要实现一个兼容多种浏览器的添加事件方法

```
function addEvent(elm, evType, fn, useCapture) {
  if (elm.addEventListener) {
    elm.addEventListener(evType, fn, useCapture)
    return true
  } else if (elm.attachEvent) {
    var r = elm.attachEvent("on" + evType, fn)
    return r
  } else {
    elm["on" + evType] = fn
  }
}
```

对于不同的浏览器，添加事件的方式可能会存在兼容问题。如果每次都需要去这样写一遍的话肯定是不能接受的，所以我们将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 `addEvent` 即可。

### 观察者模式

> 观察者模式:观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。而 js 中最常见的观察者模式就是事件触发机制。

#### 先来个完整的

```js
class EventEmiter {
  constructor() {
    this.eventPool = {
      //  'eventName': []
    };
  }
  listen(eventName, callback) {
    if (this.eventPool[eventName]) {
      if (this.eventPool[eventName].indexOf(callback) === -1) {
        this.eventPool[eventName].push(callback);
      }
    } else {
      this.eventPool[eventName] = [callback];
    }
  }
  // trigger是有参数的
  trigger(eventName, ...args) {
    if (this.eventPool[eventName]) {
      this.eventPool[eventName].forEach(cb => cb(...args));
    }
  }
  remove(eventName, callback) {
    if (this.eventPool[eventName]) {
      let cbIndex = this.eventPool[eventName].indexOf(callback);
      this.eventPool[eventName].splice(cbIndex, 1);
    }
  }
  once(eventName, callback) {
    this.listen(eventName, function _cb(...args) {
      callback(...args);
      this.remove(eventName, _cb);
    });
  }
}
```

[ES5/ES6 实现观察者模式(自定义事件) - 简书](https://www.jianshu.com/p/10a20df72bf2)

#### 先搭架子

1. 要有一个对象，存储着它自己的触发函数。而且这个对象的触发函数可能有很多种，比如一个 onclick 可能触发多个事件，那么 handler 的属性应该是一个数组，每个数组的值都是一个函数。

```js
handler={
  type1:[func1,func2...],
  type2:[func3,func4...],
  ...
}
```

现在这个对象的主体部分已经思考好了，现在就是要它‘动起来’，给它添加各种动作。
一个事件可能有哪些动作呢？

- add：添加事件某种类型的函数，
- remove: 移除某种类型的函数，
- fire：触发某种类型的函数,
- once:触发某种类型的函数，然后移除掉这个函数

现在，自定义事件的架子已经搭建好了

```js
eventOb={
  //函数储存
  handler:{
    type1:[func1,func2...],
    type2:[func2,func4...],
    ...
  },

  //主要事件
  add:function(){},
  remove:function(){},
  fire:function(){},
  once:function(){},
}
```

#### add

添加一个事件监听，首先传入参数应该是 事件类型 type，和触发函数 func，传入的时候检测有没有这个函数，有了就不重复添加。

```js
add:function (type,func) {
  //检测type是否存在
  if(eventOb.handleFunc[type]){
    //检测事件是否存在，不存在则添加
    if(eventOb.handleFunc[type].indexOf(func)===-1){
      eventOb.handleFunc[type].push(func);
    }
  }
  else{
    eventOb.handleFunc[type]=[func];
  }
},
```

#### remove

remove 有一个潜在的需求，就是如果你的事件不存在，它应该会报错。而这里不会报错，index 在 func 不存在的时候是-1；这时候要报错。

```js
remove:function (type,func) {
  try{
    let target = eventOb.handleFunc[type];
    let index = target.indexOf(func);
    if(index===-1) throw error;
    target.splice(index,1);
  }catch (e){
      console.error('别老想搞什么飞机，删除我有的东西！');
  }
},
```

#### fire

触发一个点击事件肯定是要触发它全部的函数，这里也是一样，所以只需要传入 type，然后事件可能不存在，像上面一样处理。

```js
fire:function (type,func) {
  try{
    let target = eventOb.handleFunc[type];
    let count = target.length;
    for (var i = 0; i < count; i++) {
      //加()使立即执行
      target[i]();
    }
  }
  catch (e){
    console.error('别老想搞什么飞机，触发我有的东西！');
  }
},
```

但会有问题，我只想触发并且删除某个事件怎么办，fire 一下就全触发了呀。
所以 fire 的问题就显现出来了。我们还是要给它一个 func，但是可选。

```js
fire:function (type,func) {
  try{
    let target = eventOb.handleFunc[type];
    if(arguments.length===1) {
      //不传func则全部触发
      let count = target.length;
      for (var i = 0; i < count; i++) {
          target[i]();
      }
    }else{
      //传func则触发func
      let index=target.indexOf(func);
      if(index===-1)throw error;
      func();
    }
    //need some code
  }catch (e){
    console.error('别老想搞什么飞机，触发我有的东西！');
    //need some code
  }
},
```

#### once

fire，然后 remove

```js

once (event, callback) {
  this.fire(event, (...args) => {
      callback(...args);
      this.remove(event)
  })
}
```

#### 完整代码

```js
class eventObs {
  constructor() {
    this.handleFunc = {};
  }

  add(type, func) {
    if (this.handleFunc[type]) {
      if (this.handleFunc[type].indexOf(func) === -1) {
        this.handleFunc[type].push(func);
      }
    } else {
      this.handleFunc[type] = [func];
    }
  }

  fire(type, func) {
    try {
      if (arguments.length === 1) {
        let target = this.handleFunc[type];
        let count = target.length;
        for (var i = 0; i < count; i++) {
          target[i]();
        }
      } else {
        let target = this.handleFunc[type];
        let index = target.indexOf(func);
        if (index === -1) throw error;
        func();
      }
      return true;
    } catch (e) {
      console.error('别老想搞什么飞机，触发我有的东西！');
      return false;
    }
  }

  remove(type, func) {
    try {
      let target = this.handleFunc[type];
      let index = target.indexOf(func);
      if (index === -1) throw error;
      target.splice(index, 1);
    } catch (e) {
      console.error('别老想搞什么飞机，删除我有的东西！');
    }
  }

  once(type, func) {
    this.fire(type, func) ? this.remove(type, func) : null;
  }
}
```

### 用过哪些设计模式？

- 工厂模式：
  - 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是 new 关键字。将所有实例化的代码集中在一个位置防止代码重复
  - 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例

```js
function createObject(name, age, profession) {
  //集中实例化的函数var obj = new Object();
  obj.name = name;
  obj.age = age;
  obj.profession = profession;
  obj.move = function() {
    return this.name + ' at ' + this.age + ' engaged in ' + this.profession;
  };
  return obj;
}
var test1 = createObject('trigkit4', 22, 'programmer'); //第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例
```

- 构造函数模式

  - 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于

- 构造函数方法没有显示的创建对象 (new Object());

- 直接将属性和方法赋值给 this 对象;

- 没有 renturn 语句

#### 观察者模式实现 ?

#### 设计模式：什么是 singleton, factory, strategy, decorator

- Singleton(单例) 一个类只有唯一实例，这个实例在整个程序中有一个全局的访问点
- Factory (工厂) 解决实列化对象产生重复的问题
- Strategy(策略) 将每一个算法封装起来，使它们还可以相互替换，让算法独立于使用
- Observer(观察者) 多个观察者同时监听一个主体，当主体对象发生改变时，所有观察者都将得到通知
- Prototype(原型) 一个完全初始化的实例，用于拷贝或者克隆
- Adapter(适配器) 将不同类的接口进行匹配调整，尽管内部接口不兼容，不同的类还是可以协同工作
- Proxy(代理模式) 一个充当过滤转发的对象用来代表一个真实的对象
- Iterator(迭代器) 在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素
- Chain of Responsibility(职责连) 处理请求组成的对象一条链，请求链中传递，直到有对象可以处理

#### 用过哪些设计模式

1）单例模式
定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
实现方法：先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。
适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。
（2）发布/订阅模式
定义：又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。
场景：订阅感兴趣的专栏和公众号。
（3）策略模式
定义：将一个个算法（解决方案）封装在一个个策略类中。
优点：

策略模式可以避免代码中的多重判断条件。
策略模式很好的体现了开放-封闭原则，将一个个算法（解决方案）封装在一个个策略类中。便于切换，理解，扩展。
策略中的各种算法可以重复利用在系统的各个地方，避免复制粘贴。
策略模式在程序中或多或少的增加了策略类。但比堆砌在业务逻辑中要清晰明了。
违反最少知识原则，必须要了解各种策略类，才能更好的在业务中应用。

应用场景：根据不同的员工绩效计算不同的奖金；表单验证中的多种校验规则。
（4）代理模式
定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
应用场景：图片懒加载（先通过一张 loading 图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。）
（5）中介者模式
定义：通过一个中介者对象，其他所有相关对象都通过该中介者对象来通信，而不是互相引用，当其中的一个对象发生改变时，只要通知中介者对象就可以。可以解除对象与对象之间的紧耦合关系。
应用场景： 例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发 change 事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。
（6）装饰者模式
定义：在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法。
应用场景： 有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。

#### js 设计模式

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模

#### 常见设计模式

设计模式 是一种让代码可重用/可拓展/可解偶的拟物化思维，比如接口不同就用适配器之类的。

创建型设计模式
简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式、单例模式

结构型设计模式
外观模式、适配器模式、代理模式、装饰者模式、桥接模式、组合模式、享元模式

行为型设计模式
模板方法模式、观察者模式、状态模式、策略模式、职责链模式、命令模式、访问者模式、中介者模式、备忘录模式、迭代器模式、解释器模式

技巧型设计模式
链模式、委托模式、数据访问对象模式、节流模式、简单模板方式、惰性模式、参与者模式、等待者模式

架构型设计
同步模块模式、异步模块模式、widget 模式、mvc 模式、mvp 模式、mvvm 模式

#### 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景

- 发布-订阅模式就好像报社， 邮局和个人的关系，报纸的订阅和分发是由邮局来完成的。报社只负责将报纸发送给邮局。
- 观察者模式就好像 个体奶农和个人的关系。奶农负责统计有多少人订了产品，所以个人都会有一个相同拿牛奶的方法。奶农有新奶了就负责调用这个方法。

观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知

区别与适用场景:
总的来说，发布-订阅模式适合更复杂的场景。
在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？
在「多对一」或者「多对多」场景下。一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是等所有发布者都更新完毕再通知订阅者？

#### js 常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等

```js
// 1) 单例：　任意对象都是单例，无须特别处理

var obj = { name: 'michaelqin', age: 30 };

// 2) 工厂: 就是同样形式参数返回不同的实例
function Person() {
  this.name = 'Person1';
}
function Animal() {
  this.name = 'Animal1';
}

function Factory() {}
Factory.prototype.getInstance = function(className) {
  return eval('new ' + className + '()');
};

var factory = new Factory();
var obj1 = factory.getInstance('Person');
var obj2 = factory.getInstance('Animal');
console.log(obj1.name); // Person1
console.log(obj2.name); // Animal1

//3) 代理: 就是新建个类调用老类的接口,包一下
function Person() {}
Person.prototype.sayName = function() {
  console.log('michaelqin');
};
Person.prototype.sayAge = function() {
  console.log(30);
};

function PersonProxy() {
  this.person = new Person();
  var that = this;
  this.callMethod = function(functionName) {
    console.log('before proxy:', functionName);
    that.person[functionName](); // 代理
    console.log('after proxy:', functionName);
  };
}

var pp = new PersonProxy();
pp.callMethod('sayName'); // 代理调用Person的方法sayName()
pp.callMethod('sayAge'); // 代理调用Person的方法sayAge()

//4) 观察者: 就是事件模式，比如按钮的onclick这样的应用.
function Publisher() {
  this.listeners = [];
}
Publisher.prototype = {
  addListener: function(listener) {
    this.listeners.push(listener);
  },

  removeListener: function(listener) {
    delete this.listeners[listener];
  },

  notify: function(obj) {
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this.listeners[i];
      if (typeof listener !== 'undefined') {
        listener.process(obj);
      }
    }
  },
}; // 发布者

function Subscriber() {}
Subscriber.prototype = {
  process: function(obj) {
    console.log(obj);
  },
}; // 订阅者
var publisher = new Publisher();
publisher.addListener(new Subscriber());
publisher.addListener(new Subscriber());
publisher.notify({ name: 'michaelqin', ageo: 30 }); // 发布一个对象到所有订阅者
publisher.notify('2 subscribers will both perform process'); // 发布一个字符串到所有订阅者
```
