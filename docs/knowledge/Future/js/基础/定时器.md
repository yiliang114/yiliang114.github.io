---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 定时器

setTimeout 表示间隔一段时间之后执行一次调用；而 setInterval 则是每间隔一段时间循环调用。

clearTimeout, clearInterval 函数用来结束尚未执行的 setTimeout 和 setInterval。

内存方面，setTimeout 只需要进入一次队列，不会造成内存溢出；setInterval 因为不计算代码执行时间，有可能同时执行多次代码，
导致内存溢出。

立即执行函数: setImmediate
该方法用来把一些需要长时间运行的操作放在一个回调函数里,在浏览器完成后面的其他语句后,就立刻执行这个回调函数。类似 setTimeout(func, 0)

### 用 promise 和 setTimeout 实现一个 delay 函数

```js
function delay(delayTime) {
  return new Promise(function(resolve, reject) {
    setTimeout(resolve, delayTime);
  });
}
delay(1000).then(function() {
  console.log('0：执行成功！');
});

delay(2000)
  .then(function() {
    console.log('1：执行成功！');
    return delay(1000);
  })
  .then(function() {
    console.log('2：执行失败！');
  });
```

### setTimeout、setInterval、requestAnimationFrame 各有什么特点？

异步编程当然少不了定时器了，常见的定时器函数有 `setTimeout`、`setInterval`、`requestAnimationFrame`。我们先来讲讲最常用的`setTimeout`，很多人认为 `setTimeout` 是延时多久，那就应该是多久后执行。

其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行。当然了，我们可以通过代码去修正 `setTimeout`，从而使定时器相对准确

```js
let period = 60 * 1000 * 60 * 2;
let startTime = new Date().getTime();
let count = 0;
let end = new Date().getTime() + period;
let interval = 1000;
let currentInterval = interval;

function loop() {
  count++;
  // 代码执行所消耗的时间
  let offset = new Date().getTime() - (startTime + count * interval);
  let diff = end - new Date().getTime();
  let h = Math.floor(diff / (60 * 1000 * 60));
  let hdiff = diff % (60 * 1000 * 60);
  let m = Math.floor(hdiff / (60 * 1000));
  let mdiff = hdiff % (60 * 1000);
  let s = mdiff / 1000;
  let sCeil = Math.ceil(s);
  let sFloor = Math.floor(s);
  // 得到下一次循环所消耗的时间
  currentInterval = interval - offset;
  console.log(
    '时：' + h,
    '分：' + m,
    '毫秒：' + s,
    '秒向上取整：' + sCeil,
    '代码执行时间：' + offset,
    '下次循环间隔' + currentInterval,
  );

  setTimeout(loop, currentInterval);
}

setTimeout(loop, currentInterval);
```

接下来我们来看 `setInterval`，其实这个函数作用和 `setTimeout` 基本一致，只是该函数是每隔一段时间执行一次回调函数。

通常来说不建议使用 `setInterval`。第一，它和 `setTimeout` 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码

```js
function demo() {
  setInterval(function() {
    console.log(2);
  }, 1000);
  sleep(2000);
}
demo();
```

以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。

如果你有循环定时器的需求，其实完全可以通过 `requestAnimationFrame` 来实现

```js
function setInterval(callback, interval) {
  let timer;
  const now = Date.now;
  let startTime = now();
  let endTime = startTime;
  const loop = () => {
    timer = window.requestAnimationFrame(loop);
    endTime = now();
    if (endTime - startTime >= interval) {
      startTime = endTime = now();
      callback(timer);
    }
  };
  timer = window.requestAnimationFrame(loop);
  return timer;
}

let a = 0;
setInterval(timer => {
  console.log(1);
  a++;
  if (a === 3) cancelAnimationFrame(timer);
}, 1000);
```

首先 `requestAnimationFrame` 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 `setTimeout`。

### requestAnimationFrame 原理？是同步还是异步

异步，传入的函数在重绘之前调用
