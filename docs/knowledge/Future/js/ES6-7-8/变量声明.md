---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 为什么 var 可以重复声明

当我们执行代码时，我们可以简单的理解为新变量分配一块儿内存，命名为 a，并赋值为 2，但在运行的时候编译器与引擎还会进行两项额外的操作：判断变量是否已经声明：
首先编译器对代码进行分析拆解，从左至右遇见 var a，则编译器会询问作用域是否已经存在叫 a 的变量了，如果不存在，则招呼作用域声明一个新的变量 a，若已经存在，则忽略 var 继续向下编译，这时 a = 2 被编译成可执行的代码供引擎使用。
引擎遇见 a=2 时同样会询问在当前的作用域下是否有变量 a，若存在，则将 a 赋值为 2（由于第一步编译器忽略了重复声明的 var，且作用域中已经有 a，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量 a 则将其赋值 2，若没有找到，则招呼作用域声明一个变量 a 并赋值为 2

### 全局作用域中，用 const 和 let 声明的变量不在 window 上,那到底在哪里？如何去获取

在 ES5 中，全局变量直接挂载到全局对象的属性上，所以能在 window 上看到 var 声明的变量
在 ES6 中，全局对象的属性和全局变量脱钩，但是为了保持兼容性，旧的不变，所以 var、function 声明的全局变量依然可以在 window 对象上看到，而 let、const 声明的全局变量在 window 对象上看不到

```js
let a = 1;
var b = 2;
let Object = {
  a: 3,
  d: function() {
    console.log(this.b);
    console.log(a);
    console.log(this.a);
  },
};
let ed = Object.d;
ed(); // 2, 1， undefined
```

此时 this 指向 window，通过 window.a 访问为 undefined,由于 const 和 let 声明的变量不在 window 上，所有通过直接访问即可

### var、let 和 const 区别

- var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会
- var 声明变量存在变量提升，let 和 const 不存在变量提升
- let 和 const 声明形成块作用域
- 同一作用域下 let 和 const 不能声明同名变量，而 var 可以
- let 有暂时性死区
  ```js
  var a = 100;
  if (1) {
    a = 10;
    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
    // 而这时，还未到声明时候，所以控制台Error:a is not defined
    let a = 1;
  }
  ```
- const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明
  如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。
- let 和 const 定义的变量不会出现变量提升，而 var 定义的变量会提升。
- let 和 const 是 JS 中的块级作用域
- let 和 const 不允许重复声明(会抛出错误)
- let 和 const 定义的变量在定义语句之前，如果使用会抛出错误(形成了暂时性死区)，而 var 不会。
- const 声明一个只读的常量。一旦声明，常量的值就不能改变(如果声明是一个对象，那么不能改变的是对象的引用地址)

let/const 也存在变量声明提升，只是没有初始化分配内存。 一个变量有三个操作，声明(提到作用域顶部)，初始化(赋默认值)，赋值(继续赋值)
let 是一开始变量声明提升，然后没有初始化分配内存，代码执行到那行初始化，之后对变量继续操作是赋值。因为没有初始化分配内存，所以会报错，这是暂时性死区

### javascript 变量声明优先级

function 声明的优先级比 var 声明高，也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明，如下：

```js
alert(a); //输出：function a(){ alert('我是函数') }

function a() {
  alert('我是函数');
} //
var a = '我是变量';

alert(a); //输出：'我是变量'
```

这代码等效于：

```js
function a() {
  alert('我是函数');
}
var a; //hoisting
alert(a); //输出：function a(){ alert('我是函数') }
a = '我是变量'; //赋值
alert(a); //输出：'我是变量'
```

这短短的代码里面其实说明了两个问题：

function 声明的优先级高于 var 声明：第一个 alert 输出可以看出 var a;被 function a(){}覆盖掉了。
赋值优先于函数声明：第二个 alert 输出可以看出 a='我是变量'又把 function a(){}覆盖掉了。
把一个变量添加到作用域中除有很多方法，如下：

javascript 语言预定义的，比如说 this,arguments
formal parameter(也就是中文说的形参吧)
var 声明并赋值，比如说 var a = 10;
var 声明不赋值，比如说 var a;
function 声明，比如说 function a(){};
我们来看看他们之间的优先级：

var 声明并赋值优先级高于 function 声明 这个上面已经说了。

function 声明优先级高于 formal parameter

```js
function fnTest(a){
alert(a);
function a(){return "我优先"}
}
fnTest(100);//:function a(){return "我优先"}。可以看出 function 声明覆盖了`formal parameter`。
formal parameter 优先级高于预定义变量
function fnTest(arguments){
alert(arguments);
}
fnTest(100);//:100。说明`formal parameter`优先级比预定义的 arguments 高
```

对比以下：

```js
function fnTest(a){
alert(arguments);
}
fnTest(100);//:[Object Arguments] {0:100,length:1}。当没有冲突时输出便是预定义的 arguments
formal parameter 优先级高于 var 声明不赋值
function fnTest(a){
alert(a);
var a;
}
fnTest(100);//:100。很明显，不多说

```

预定义变量优先级高于 var 声明不赋值

```js
function fnTest() {
  alert(arguments);
  var arguments;
}
fnTest(); //:[Object Arguments]。不是 undefined，说明 arguments 没有被 var 声明覆盖
var 声明不赋值优先级高于函数外部作用域的其他所有声明;
function fnTest() {
  alert(fnTest);
  var fnTest;
}
fnTest(); //:undefined。
```

对比如下：

```js
function fnTest() {
  //
  alert(fnTest); //
} //
fnTest(); //输出 function fnTest(){alert(fnTest);}
```

这也正好印证了作用域链查找变量的方式：在局部作用域里查找（若找到则返回，不必往下继续查找） ==> 在上一级作用域里查找... ==> 直到全局作用域（若找不到则返回 typeError）

最后看看下面的综合例子：

```js
function fnTest(arguments) {
  alert(arguments); //function arguments(){return "hello world"}
  var arguments = 99;
  function arguments() {
    return 'hello world';
  }
  alert(arguments); //99
}
fnTest(100);
```

### 请解释变量提升（hoisting）。

变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用`var`关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。我们用几个例子来解释一下。

```js
// 用 var 声明得到提升
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// 用 let/const 声明不会提升
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。

```js
// 函数声明
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// 函数表达式
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```
