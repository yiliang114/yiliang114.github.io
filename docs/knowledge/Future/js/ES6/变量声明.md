---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 为什么 var 可以重复声明

当我们执行代码时，我们可以简单的理解为新变量分配一块儿内存，命名为 a，并赋值为 2，但在运行的时候编译器与引擎还会进行两项额外的操作：

判断变量是否已经声明：首先编译器对代码进行分析拆解，从左至右遇见 var a，则编译器会询问作用域是否已经存在叫 a 的变量了，如果不存在，则招呼作用域声明一个新的变量 a，若已经存在，则忽略 var 继续向下编译，这时 a = 2 被编译成可执行的代码供引擎使用。
引擎遇见 a=2 时同样会询问在当前的作用域下是否有变量 a，若存在，则将 a 赋值为 2（由于第一步编译器忽略了重复声明的 var，且作用域中已经有 a，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量 a 则将其赋值 2，若没有找到，则招呼作用域声明一个变量 a 并赋值为 2

### 全局作用域中，用 const 和 let 声明的变量不在 window 上,那到底在哪里？如何去获取

在 ES5 中，全局变量直接挂载到全局对象的属性上，所以能在 window 上看到 var 声明的变量
在 ES6 中，全局对象的属性和全局变量脱钩，但是为了保持兼容性，旧的不变，所以 var、function 声明的全局变量依然可以在 window 对象上看到，而 let、const 声明的全局变量在 window 对象上看不到

```js
let a = 1;
var b = 2;
let Object = {
  a: 3,
  d: function() {
    console.log(this.b);
    console.log(a);
    console.log(this.a);
  },
};
let ed = Object.d;
ed(); // 2, 1， undefined
```

此时 this 指向 window，通过 window.a 访问为 undefined,由于 const 和 let 声明的变量不在 window 上，所有通过直接访问即可

### var、let 和 const 区别

- var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会
- var 声明变量存在变量提升，let 和 const 不存在变量提升
- let 和 const 声明形成块作用域
- 同一作用域下 let 和 const 不能声明同名变量，而 var 可以
- let 有暂时性死区
  ```js
  var a = 100;
  if (1) {
    a = 10;
    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
    // 而这时，还未到声明时候，所以控制台Error:a is not defined
    let a = 1;
  }
  ```
- const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明
  如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。
- let 和 const 定义的变量不会出现变量提升，而 var 定义的变量会提升。
- let 和 const 是 JS 中的块级作用域
- let 和 const 不允许重复声明(会抛出错误)
- let 和 const 定义的变量在定义语句之前，如果使用会抛出错误(形成了暂时性死区)，而 var 不会。
- const 声明一个只读的常量。一旦声明，常量的值就不能改变(如果声明是一个对象，那么不能改变的是对象的引用地址)

let/const 也存在变量声明提升，只是没有初始化分配内存。 一个变量有三个操作，声明(提到作用域顶部)，初始化(赋默认值)，赋值(继续赋值)
let 是一开始变量声明提升，然后没有初始化分配内存，代码执行到那行初始化，之后对变量继续操作是赋值。因为没有初始化分配内存，所以会报错，这是暂时性死区

### javascript 变量声明优先级

function 声明的优先级比 var 声明高，也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明，如下：

```js
alert(a); //输出：function a(){ alert('我是函数') }

function a() {
  alert('我是函数');
} //
var a = '我是变量';

alert(a); //输出：'我是变量'
```

这代码等效于：

```js
function a() {
  alert('我是函数');
}
var a; //hoisting
alert(a); //输出：function a(){ alert('我是函数') }
a = '我是变量'; //赋值
alert(a); //输出：'我是变量'
```

这短短的代码里面其实说明了两个问题：

function 声明的优先级高于 var 声明：第一个 alert 输出可以看出 var a;被 function a(){}覆盖掉了。
赋值优先于函数声明：第二个 alert 输出可以看出 a='我是变量'又把 function a(){}覆盖掉了。
把一个变量添加到作用域中除有很多方法，如下：

javascript 语言预定义的，比如说 this,arguments
formal parameter(也就是中文说的形参吧)
var 声明并赋值，比如说 var a = 10;
var 声明不赋值，比如说 var a;
function 声明，比如说 function a(){};
我们来看看他们之间的优先级：

var 声明并赋值优先级高于 function 声明 这个上面已经说了。

function 声明优先级高于 formal parameter

```js
function fnTest(a){
alert(a);
function a(){return "我优先"}
}
fnTest(100);//:function a(){return "我优先"}。可以看出 function 声明覆盖了`formal parameter`。
formal parameter 优先级高于预定义变量
function fnTest(arguments){
alert(arguments);
}
fnTest(100);//:100。说明`formal parameter`优先级比预定义的 arguments 高
```

对比以下：

```js
function fnTest(a){
alert(arguments);
}
fnTest(100);//:[Object Arguments] {0:100,length:1}。当没有冲突时输出便是预定义的 arguments
formal parameter 优先级高于 var 声明不赋值
function fnTest(a){
alert(a);
var a;
}
fnTest(100);//:100。很明显，不多说

```

预定义变量优先级高于 var 声明不赋值

```js
function fnTest() {
  alert(arguments);
  var arguments;
}
fnTest(); //:[Object Arguments]。不是 undefined，说明 arguments 没有被 var 声明覆盖
var 声明不赋值优先级高于函数外部作用域的其他所有声明;
function fnTest() {
  alert(fnTest);
  var fnTest;
}
fnTest(); //:undefined。
```

对比如下：

```js
function fnTest() {
  //
  alert(fnTest); //
} //
fnTest(); //输出 function fnTest(){alert(fnTest);}
```

这也正好印证了作用域链查找变量的方式：在局部作用域里查找（若找到则返回，不必往下继续查找） ==> 在上一级作用域里查找... ==> 直到全局作用域（若找不到则返回 typeError）

最后看看下面的综合例子：

```js
function fnTest(arguments) {
  alert(arguments); //function arguments(){return "hello world"}
  var arguments = 99;
  function arguments() {
    return 'hello world';
  }
  alert(arguments); //99
}
fnTest(100);
```

### 请解释变量提升（hoisting）。

变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用`var`关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。我们用几个例子来解释一下。

```js
// 用 var 声明得到提升
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// 用 let/const 声明不会提升
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。

```js
// 函数声明
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// 函数表达式
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```

### var,let,const 区别

- 全局申明的 var 变量会挂载在 window 上，而 let 和 const 不会
- var 声明变量存在变量提升，let 和 const 不会
- let、const 的作用范围是块级作用域，而 var 的作用范围是函数作用域
- 同一作用域下 let 和 const 不能声明同名变量，而 var 可以
- 同一作用域下在 let 和 const 声明前使用会存在暂时性死区
- const
  - 一旦声明必须赋值,不能使用 null 占位
  - 声明后不能再修改
  - 如果声明的是复合类型数据，可以修改其属性

let 和 const 都是对变量的声明，都有块级作用域的概念，不同的是 const 是对常量的声明，因此声明同时必须赋值，且之后不能更改，而 let 则可以。

用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let 和 const 是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。

```js
function foo() {
  // 所有变量在函数中都可访问
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';

  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}

console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

// 用 var 声明的变量在函数作用域上都可访问
console.log(bar); // bar
// let 和 const 定义的变量在它们被定义的语句块之外不可访问
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。

console.log(foo); // undefined

var foo = 'foo';

console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization

let baz = 'baz';

console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization

const bar = 'bar';
// 用var重复声明不会报错，但let和const会。

var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"

let baz = 'baz';
let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared
// let和const的区别在于：let允许多次赋值，而const只允许一次。

// 这样不会报错。
let foo = 'foo';
foo = 'bar';

// 这样会报错。
const baz = 'baz';
baz = 'qux';
```

### let 有什么用，有了 var 为什么还要用 let？

在`ES6`之前，声明变量只能用`var`，`var`方式声明变量其实是很不合理的，准确的说，是因为`ES5`里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如`for`循环`var`变量泄露，变量覆盖等问题。`let`声明的变量拥有自己的块级作用域，且修复了`var`声明变量带来的变量提升问题。

### let，const

`let` 产生块级作用域（通常配合 `for` 循环或者 `{}` 进行使用产生块级作用域），`const` 申明的变量是常量（内存地址不变）

### var、let 及 const 区别

什么是提升？什么是暂时性死区？var、let 及 const 区别？

对于这个问题，我们应该先来了解提升（hoisting）这个概念。

```
console.log(a) // undefined
var a = 1
```

从上述代码中我们可以发现，虽然变量还没有被声明，但是我们却可以使用这个未被声明的变量，这种情况就叫做提升，并且提升的是声明。

对于这种情况，我们可以把代码这样来看

```
var a
console.log(a) // undefined
a = 1
```

接下来我们再来看一个例子

```
var a = 10
var a
console.log(a)
```

对于这个例子，如果你认为打印的值为 `undefined` 那么就错了，答案应该是 `10`，对于这种情况，我们这样来看代码

```
var a
var a
a = 10
console.log(a)
```

到这里为止，我们已经了解了 `var` 声明的变量会发生提升的情况，其实不仅变量会提升函数也会被提升。

```
console.log(a) // ƒ a() {}
function a() {}
var a = 1
```

对于上述代码，打印结果会是 `ƒ a() {}`，即使变量声明在函数之后，这也说明了函数会被提升，并且优先于变量提升。

说完了这些，想必大家也知道 `var` 存在的问题了，使用 `var` 声明的变量会被提升到作用域的顶部，接下来我们再来看 `let` 和 `const` 。

我们先来看一个例子：

```
var a = 1
let b = 1
const c = 1
console.log(window.b) // undefined
console.log(window. c) // undefined

function test(){
  console.log(a)
  let a
}
test()
```

首先在全局作用域下使用 `let` 和 `const` 声明变量，变量并不会被挂载到 `window` 上，这一点就和 `var` 声明有了区别。

再者当我们在声明 `a` 之前如果使用了 `a`，就会出现报错的情况

![img](./images/1672730318cfa540.jpg)

你可能会认为这里也出现了提升的情况，但是因为某些原因导致不能访问。

首先报错的原因是因为存在暂时性死区，我们不能在声明前就使用变量，这也是 `let` 和 `const` 优于 `var` 的一点。然后这里你认为的提升和 `var` 的提升是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。

那么到这里，想必大家也都明白 `var`、`let` 及 `const` 区别了，不知道你是否会有这么一个疑问，为什么要存在提升这个事情呢，其实提升存在的根本原因就是为了解决函数间互相调用的情况

```
function test1() {
    test2()
}
function test2() {
    test1()
}
test1()
```

假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 `test1` 在 `test2` 前面然后 `test2` 又在 `test1` 前面。

总结：

- 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部
- `var` 存在提升，我们能在声明之前使用。`let`、`const` 因为暂时性死区的原因，不能在声明前使用
- `var` 在全局作用域下声明变量会导致变量挂载在 `window` 上，其他两者不会
- `let` 和 `const` 作用基本一致，但是后者声明的变量不能再次赋值

### let const var 的区别？

| 声明方式 | 变量提升 | 作用域 | 初始值 | 重复定义                          |
| -------- | -------- | ------ | ------ | --------------------------------- |
| var      | 是       | 函数级 | 不必须 | 允许                              |
| let      | 否       | 块级   | 不必须 | 不允许                            |
| const    | 否       | 块级   | 必须   |  复合类型的变量可以，其他并不可以 |

> `const`对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。

Q：为什么 const 一旦声明常量，就必须立即初始化，不能留到以后再赋值？

Q： `const obj = {a: 1};`那么 a 还能赋值为其他值吗？为什么？

> A: </br>obj.a = 2;这是完全正确的。因为`const`对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。</br>
> 常量 obj 存储的是一个地址，指向一个对象。不可变的只是这个地址，即不能把 obj 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

Q: 有什么办法可以让`const obj = {a: 1};`的值不可变？

> A: </br>如果真的想讲对象冻结，应该使用 `Object.freeze` 方法。
> `const foo = Object.freeze({}); foo.prop= 123;` // 不起作用

### 变量提升

var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用 var 关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。

### 变量提升，请解释变量声明提升 (hoisting)。

变量的定义和函数的声明（注意这里和函数表达式的区别），都会被提前，所以在执行上下文中会导致在主观上的声明被提升的现象，看起来像是变量和函数可以先调用再声明。
