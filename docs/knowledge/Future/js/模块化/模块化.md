---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 说说你对 AMD CMD Commonjs 的理解

https://segmentfault.com/a/1190000012419990

- CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数
- AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的

**模块化开发怎么做？**

- 立即执行函数,不暴露私有成员

```js
var module1 = (function() {
  var _count = 0;
  var m1 = function() {
    //...
  };
  var m2 = function() {
    //...
  };
  return {
    m1: m1,
    m2: m2,
  };
})();
```

**AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？**

- Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中

```js
// CMD
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  // 此处略去 100 行
  var b = require('./b'); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(['./a', './b'], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

**对前端模块化的认识**

- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出
- CMD 是 SeaJS 在推广过程中对模块定义的规范化产出
- AMD 是提前执行，CMD 是延迟执行
- AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的

#### 对前端模块化的认识

> AMD 是 `RequireJS` 在推广过程中对模块定义的规范化产出。
> CMD 是 `SeaJS` 在推广过程中对模块定义的规范化产出。
> `AMD` 是提前执行，`CMD` 是延迟执行。
> `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的。
> CMD 模块方式

```js
define(function(require, exports, module) {
  // 模块代码
});
```

JS 模块化的实践
require.js 的实现原理（如果使用过 webpack，进一步会问，两者打包的异同及优缺点）

项目模块的切分原则：

### 从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module 等模块化介绍发展历程

模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。

IIFE： 使用自执行函数来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突。

```js
(function() {
  return {
    data: [],
  };
})();
```

AMD： 使用 requireJS 来编写模块化，特点：依赖必须提前声明好。

```js
define('./index.js', function(code) {
  // code 就是index.js 返回的内容
});
```

CMD： 使用 seaJS 来编写模块化，特点：支持动态引入依赖文件。

```js
define(function(require, exports, module) {
  var indexCode = require('./index.js');
});
```

CommonJS： nodejs 中自带的模块化。

```js
var fs = require('fs');
```

UMD：兼容 AMD，CommonJS 模块化语法。

webpack(require.ensure)：webpack 2.x 版本中的代码分割。

ES Modules： ES6 引入的模块化，支持 import 来引入另一个 js 。

```js
import a from 'a';
```

https://blog.csdn.net/dadadeganhuo/article/details/86777249

### AMD、CMD 的分别

CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数，是 SeaJS 在推广过程中对模块定义的规范化产出

AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的,是 RequireJS 在推广过程中对模块定义的规范化产出

- 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
- CMD 推崇依赖就近，AMD 推崇依赖前置。
- AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。

require 与 import 的区别:

- require 支持 动态导入，import 不支持，正在提案 (babel 下可支持)
- require 是 同步 导入，import 属于 异步 导入
- require 是 值拷贝，导出值变化不会影响导入值；import 指向 内存地址，导入值会随导出值而变化

CommonJS 是服务端模块的规范，Nodejs 采用了这个规范。根据 CommonJS 规范，一个单独的文件就是一个模块，每个模块都是采用一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象属性。
CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数，由于 nodejs 主要用于服务端编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不同考虑非同步加载的方式，所以 CommonJS 规范比较适用。
但是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。

### ES6 模块和 CommonJS 模块的差异？

1. ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 模块，运行时加载。
2. ES6 模块自动采用严格模式，无论模块头部是否写了 "use strict";
3. require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。
4. ES6 模块中顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。
5. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

CommonJS 中的 require/exports 和 ES6 中的 import/export 区别:

1. CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。
1. ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
1. import/export 最终都是编译为 require/exports 来执行的。
1. CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
1. export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系

### 对 js 模块化的理解

在 ES6 出现之前，js 没有标准的模块化概念，这也就造成了 js 多人写作开发容易造成全局污染的情况，以前我们可能会采用立即执行
函数、对象等方式来尽量减少变量这种情况，后面社区为了解决这个问题陆续提出了 AMD 规范和 CMD 规范，这里不同于 Node.js 的
CommonJS 的原因在于服务端所有的模块都是存在于硬盘中的，加载和读取几乎是不需要时间的，而浏览器端因为加载速度取决于网速，
因此需要采用异步加载，AMD 规范中使用 define 来定义一个模块，使用 require 方法来加载一个模块，现在 ES6 也推出了标准的模块
加载方案，通过 export 和 import 来导出和导入模块。

### 如何实现一个 JS 的 AMD 模块加载器

AMD 是解决 JS 模块化的规范，实现这样的一个模块加载器的关键在于解决每个模块依赖的解析。首先我们需要有一个模块的入口，也就是主模块，比如我们使用
一个 use 方法作为入口，之后以数组的形式列出了主模块的依赖，这时候我们要想到的是如何解析这一个一个的依赖，也就是如何解析出一个个 js 文件的绝对地址，
我们可以制定一个规则，如默认为主模块的路径为基准，也可以像 requirejs 一样使用一个 config 方法来指定一个 baseurl 和为每一个模块指定一个 path，最后就是
模块的问题，我们需要暴露一个 define 方法来定义模块，也就是模块名，依赖以及每个模块的各自代码。其中每个模块的代码都应该在依赖加载完之后执行，这就是一个
回调函数，模块的依赖、回调函数、状态、名字、模块导出等可以看做是一个模块的属性，因此我们可以使用一个对象来保存所有的模块，然后每个模块的各个属性存放在一个对象中。
最后我们来考虑一下模块加载的问题，上面我们说到 use 方法，use 方法的逻辑就是遍历依赖，然后对每个模块进行加载，也就是解析地址然后使用插入 script，我们假设
使用 loadModule 方法来加载依赖，那么这个函数的逻辑就应该是检查我们的模块是否已经加载过来判断是否需要加载，如果这个模块还有依赖则调用 use 方法继续解析，模块依赖中我们
还没有提到的问题就是每个模块的依赖是需要被传进模块里来使用的，解决方法就是每个模块的 callback 方法执行后的返回的 export 记录下来然后使用 apply 之类的方法将这些参数传递进去。
大致就是这样子的。

参考：

[动手实现一个 AMD 模块加载器(一)](https://github.com/huruji/blog/issues/13)

[动手实现一个 AMD 模块加载器(二)](https://github.com/huruji/blog/issues/16)

[动手实现一个 AMD 模块加载器(三)](https://github.com/huruji/blog/issues/17)

### AMD 与 CMD 的区别有哪些？

### 听说过 UMD 吗？可以简要介绍一下吗？

**模块化开发怎么做？**

- 不暴露私有成员

```
var module1 = (function(){
　　　　var _count = 0;
　　　　var m1 = function(){
　　　　　　//...
　　　　};
　　　　var m2 = function(){
　　　　　　//...
　　　　};
　　　　return {
　　　　　　m1 : m1,
　　　　　　m2 : m2
　　　　};
　　})();
```

**AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？**

- Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中
- 区别：

  - 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible
  - CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

```js
// CMD
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  // 此处略去 100 行
  var b = require('./b'); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(['./a', './b'], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

### 为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

模块化可以给我们带来以下好处

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

实现模块化方式：

- 立即执行函数
- AMD 和 CMD
- CommonJS
- ES Module

### 不用的时候和用 RequireJs 的时候代码大概怎么写？

### 分别说说同步和异步模块化的应用场景，说下 AMD 异步模块化实现的原理？

### 如何将项目里面的所有的 require 的模块语法换成 import 的 ES6 的语法？

### 使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的？

### import 和 require 的区别。 module.exports 以及 exports

### 解释 “JavaScript 模块模式” 以及你在何时使用它。

- 如果有提到无污染的命名空间，可以考虑加分。
- 如果你的模块没有自己的命名空间会怎么样？

### 你怎么看 AMD vs. CommonJS？

"异步模块定义"

```js
require(['math'], function(math) {
  math.add(2, 3);
});
```

### 说说你对 AMD 和 CommonJS 的了解。

它们都是实现模块体系的方式，直到 ES2015 出现之前，JavaScript 一直没有模块体系。CommonJS 是同步的，而 AMD（Asynchronous Module Definition）从全称中可以明显看出是异步的。CommonJS 的设计是为服务器端开发考虑的，而 AMD 支持异步加载模块，更适合浏览器。

我发现 AMD 的语法非常冗长，CommonJS 更接近其他语言 import 声明语句的用法习惯。大多数情况下，我认为 AMD 没有使用的必要，因为如果把所有 JavaScript 都捆绑进一个文件中，将无法得到异步加载的好处。此外，CommonJS 语法上更接近 Node 编写模块的风格，在前后端都使用 JavaScript 开发之间进行切换时，语境的切换开销较小。

我很高兴看到 ES2015 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和 Node 中完全推出，但是我们可以使用代码转换工具进行转换

### 如何在文件之间共用代码？

这取决于执行 JavaScript 的环境。

在客户端（浏览器环境）上，只要变量或函数在全局作用域（`window`）中声明，所有脚本都可以引用它们。或者，通过 RequireJS 采用异步模块定义（AMD）以获得更多模块化方法。

在服务器（Node.js）上，常用的方法是使用 CommonJS。每个文件都被视为一个模块，可以通过将它们附加到`module.exports`对象来导出变量和函数。

ES2015 定义了一个模块语法，旨在替换 AMD 和 CommonJS。 这最终将在浏览器和 Node 环境中得到支持。

### js 的模块化

requirejs
commonjs
amd

require
import

module.export.xxx
exports.xxx

### requireJS 的原理是什么

### 模块化

在有 Babel 的情况下，我们可以直接使用 ES6 的模块化

```js
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}

import { a, b } from './a.js';
import XXX from './b.js';
```

#### CommonJS

`CommonJs` 是 Node 独有的规范，浏览器中使用就需要用到 `Browserify` 解析了。

```js
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;

// b.js
var module = require('./a.js');
module.a; // -> log 1
```

在上述代码中，`module.exports` 和 `exports` 很容易混淆，让我们来看看大致内部实现

```js
var module = require('./a.js');
module.a;
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
  a: 1,
};
// 基本实现
var module = {
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports;
var load = function(module) {
  // 导出的东西
  var a = 1;
  module.exports = a;
  return module.exports;
};
```

再来说说 `module.exports` 和 `exports`，用法其实是相似的，但是不能对 `exports` 直接赋值，不会有任何效果。

对于 `CommonJS` 和 ES6 中的模块化的两者区别是：

- 前者支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
- 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响

- 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- 后者会编译成 `require/exports` 来执行的

#### AMD

AMD 是由 `RequireJS` 提出的

```js
// AMD
define(['./a', './b'], function(a, b) {
  a.do();
  b.do();
});
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  var b = require('./b');
  b.doSomething();
});
```

**模块化开发怎么做？**

- 封装对象作为命名空间 -- 内部状态可以被外部改写
- 立即执行函数(IIFE) -- 需要依赖多个 JS 文件，并且严格按顺序加载
- 使用模块加载器 -- require.js, sea.js, EC6 模块

**通行的 Javascript 模块的规范有哪些？**

- CommonJS -- 主要用在服务器端 node.js

```javascript
var math = require('./math');
math.add(2, 3);
```

- AMD(异步模块定义) -- require.js

```javascript
require(['./math'], function(math) {
  math.add(2, 3);
});
```

- CMD(通用模块定义) -- sea.js

```javascript
var math = require('./math');
math.add(2, 3);
```

- ES6 模块

```javascript
import { math } from './math';
math.add(2, 3);
```

**AMD 与 CMD 规范的区别？**

- 规范化产出：

  - AMD 由 RequireJS 推广产出
  - CMD 由 SeaJS 推广产出

- 模块的依赖:

  - AMD 提前执行，推崇依赖前置
  - CMD 延迟执行，推崇依赖就近

- API 功能:

  - AMD 的 API 默认多功能（分全局 require 和局部 require）
  - CMD 的 API 推崇职责单一纯粹（没有全局 require）

- 模块定义规则：

  - AMD 默认一开始就载入全部依赖模块

```javascript
define(['./a', './b'], function(a, b) {
  a.doSomething();
  b.doSomething();
});
```

- CMD 依赖模块在用到时才就近载入

```javascript
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  var b = require('./b');
  b.doSomething();
});
```

**requireJS 的核心原理是什么？**

- 每个模块所依赖模块都会比本模块预先加载

### 其他

- npm 包 的 UMD 文件是什么？ UMD 与 webpack 之类的 CommonJS 模块打包器有什么关系，是否只能用 webpack 之类的打包器进行打包？
- require 写在里面是为了清除缓存！！！

### 模块化

为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

#### 立即执行函数

在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题

```
(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
```

#### AMD 和 CMD

鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。

```
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
```

#### CommonJS

CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```
// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析

先说 `require` 吧

```
var module = require('./a.js')
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。

#### ES Module

ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别

- CommonJS 支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 `require/exports` 来执行的

```
// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
```

### module、export、import 是什么，有什么作用？

- `module`、`export`、`import`是`ES6`用来统一前端模块化方案的设计思路和实现方案。`export`、`import`的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的`AMD/CMD`、`requireJS`、`seaJS`、`commondJS`等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，`JS`也能更加能实现大型的应用程序开发。
- `import`引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。
- `import`引入`export`导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值

### AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点

- **AMD**：`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
- **CMD**：`seajs` 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近
- **CommonJs**：模块输出的是一个值的 `copy`，运行时加载，加载的是一个对象（`module.exports` 属性），该对象只有在脚本运行完才会生成
- **ES6 Module**：模块输出的是一个值的引用，编译时输出接口，`ES6`模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。

**Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？**

- 两等号判等，会在比较时进行类型转换；
- 三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回 false）；
- Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true
- Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。

* [使用箭头函数需要注意的地方有哪些？]()
* [let 和 const 的区别是什么]()
* [说说你对 set 数据结构的理解]()
* [说说你对 class 的理解]()
* [rest 参数你有了解吗]()
* [谈谈你对 es6 的 module 体系的理解]()
* [手写一个 promise 方法]()

图片懒加载
实现页面加载进度条
实现 extend 函数

实现拖拽功能，比如把 5 个兄弟节点中的最后一个节点拖拽到节点 1 和节点 2 之间
动画：setTimeout 何时执行，requestAnimationFrame 的优点

手写 parseInt 的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用 JS 原生的字符串转数字的 API，比如 Number()

### JS 模块化 Commonjs,UMD,CMD 规范的了解，以及 ES6 的模块化跟其他几种的区别，以及出现的意义。
