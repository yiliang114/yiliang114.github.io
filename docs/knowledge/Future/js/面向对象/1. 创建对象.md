---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 对象的几种创建方式

1.  字面量创建（调用内置的构造函数）
2.  构造函数
3.  原型
4.  Object.create()
5.  工厂模式
6.  组合模式
7.  动态原型模式
8.  寄生构造函数模式
9.  稳妥构造函数模式

#### 1. 字面量

```js
var obj11 = { name: 'smyh' };
// 内置对象（内置的构造函数）
var obj12 = new Object({ name: `smyh` });
```

> 上面的两种写法，效果是一样的。因为，第一种写法，`obj11`会指向`Object`。

- 第一种写法是：字面量的方式。
- 第二种写法是：内置的构造函数

内置构造函数

```js
var obj = new Object();
//等同于 var obj = {}
```

> 使用字面量的方式更简单，其实他俩是一样的。
> 优点是足够简单，缺点是每个对象都是独立的。

#### 2. 构造函数

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function() {
    alert(this.name);
  };
}
var person1 = new Person('Nicholas', 29, 'Software Engineer');
var person2 = new Person('Greg', 27, 'Doctor');
```

> 优点是 可以创建特定类型的对象，缺点是 多个实例重复创建方法

以这种方式调用构造函数实际上会经历以下 4 个步骤:

1. 创建一个新对象;
2. 将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象);
3. 执行构造函数中的代码(为这个新对象添加属性);
4. 返回新对象。
   缺点：使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍

#### 3. 原型

不必在构造函数中定义对象实例的信息，将这些信息直接添加到原型对象

```js
function Person() {}
Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

缺点：实例没有属于自己的全部属性的

#### 4. Object.create

`obj3`是实例，`p`是` obj3的``原型（ `name`是p原型里的属性），构造函数是`Object`

```js
var p = { name: 'happy' };
//此方法创建的对象，是用原型链连接的
var obj3 = Object.create(p);
```

```js
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  },
};
const me = Object.create(person);
me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten
me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
```

> 传入一个原型对象，创建一个新对象，使用现有的对象来提供新创建的对象的**proto**，实现继承。

#### 5. 工厂模式

```js
function createPerson(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  };
  return o;
}

var person1 = createPerson('Nicholas', 29, 'Software Engineer');
var person2 = createPerson('Greg', 27, 'Doctor');
```

优点是 可以解决创建多个相似对象的问题，缺点是 无法识别对象的类型。

#### 6. （构造函数+原型）组合模式

组合使用构造函数模式与原型模式。构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性

```js
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.friends = ["Shelby", "Court”];
}
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
person1.friends.push("Van");
alert(person1.friends);    //"Shelby,Count,Van"
alert(person2.friends);    //"Shelby,Count"
alert(person1.friends === person2.friends);//false
alert(person1.sayName === person2.sayName);//true
```

> 优点 多个实例引用一个原型上的方法 比较常用

#### 7. 动态原型

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  if (typeof this.sayName != 'function') {
    Person.prototype.sayName = function() {
      alert(this.name);
    };
  }
}
var person = new Person('小红', 15);
console.log(person);
//Person {name: "小红", age: 15} 动态创建sayName: ƒ ()
```

> 优点 可以判断某个方法是否有效，来决定是否需要初始化原型，if 只会在仅在碰到第一个实例调用方法
> 时会执行，此后所有实例共享此方法，需要注意的一点是，不能重新原型对象。

#### 8. 寄生构造函数模式

创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象

```js
function Person(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name);
  };
  return o;
}
var friend = new Person('her', 18, 'Front-end Engineer');
friend.sayName();
//her
```

> 除了使用`new`操作符，其他的和工厂函数一样，可以为对象创建构造函数。

#### 9. 稳妥模式

```js
function Person(name, age){
    var o={};
    o.sayName=function(){ alert(name) }
    return o;
}
var person = ('小亮'，24);
person.sayName();//’小亮‘
```

> 除了使用`person.sayName()`之外 ，没有办法在访问到 name 的值，适合在某些安全执行环景下使用。

### 如何实现一下 Object.create()?

`Object.create(parent)`主要完成了三件事情：

- 创建一个对象
- 继承指定父对象
- 为新对象扩展新属性

何时使用 create: 希望在创建对象时就提前指定继承的父对象，并同时扩展新属性时。

```js
Object.mycreate = function(parent,props) {
  var obj = new Object();
  Object.setPrototypeOf(obj,parent);
  Object.defineProperties(obj,props);
  return obj;
}

// 用法
var father={bal:1000,car:"=b="}
// create调用的也是 defineproperty
var hmm=Object.mycreate(father,{
  phone:{//默认为false
    value:"肾6s",
    writable:true,
    enumertable:true,
    configurable:true.
  },
});

```
