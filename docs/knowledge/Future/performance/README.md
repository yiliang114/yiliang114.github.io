---
layout: CustomPages
title: performance
date: 2020-11-21
aside: false
draft: true
---

# 性能优化

### 总结

1. 减少 HTTP 请求，资源压缩合并，开启 gzip 压缩， 使用 CDN 加速静态资源
2. DNS 预解析
3. 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
4. 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
5. 当需要设置的样式很多时设置 className 而不是直接操作 style。
6. 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。
7. 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)。
8. 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
9. 非核心代码的异步加载
   1. 异步加载方式
   2. 异步加载的区别
10. 利用浏览器缓存
    1. 缓存分类
    2. 缓存原理
11. 避免空的 src 和 href
12. 为文件头指定 Expires
13. 使用 gzip 压缩内容
14. 把 CSS 放到顶部，把 JS 放到底部，避免使用 CSS 表达式
15. 将 CSS 和 JS 放到外部文件中
16. 避免跳转
17. 可缓存的 AJAX
18. 使用 GET 来完成 AJAX 请求

### 常见的网页性能优化方法

- 减少 HTTP 请求。使用雪碧图、内联图片，合并脚本和样式表。
- 使用内容分发网络（CDN）
- 添加 Expires 头
- 压缩组件。压缩样式表和脚本，开启 gzip 压缩大概减少 70%的大小
- 样式表放在顶部
- 将脚本放在底部
- 避免 CSS 表达式
- 使用外部 JavaScript 和 CSS
- 减少 DNS 查找
- 精简 JavaScript
- 避免重定向。网站中除了域名首页外缺少斜杠将引起 301 重定向，个人测试工作室网站这个重定向消耗的时间在 30ms 左右
- 删除重复脚本
- 配置 ETag
- 使 Ajax 可缓存

### 你有用过哪些前端性能优化的方法？

- 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。
- 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
- 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
- 当需要设置的样式很多时设置 className 而不是直接操作 style
- 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作
- 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)
- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳
- 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢
- 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如 join 查询），减少磁盘 IO 指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的

### 你如何对网站的文件和资源进行优化？

1. 文件合并
2. 文件最小化/文件压缩
3. 使用 CDN 托管
4. 缓存的使用（多个域名来提供缓存）
5. 其他

### 谈一谈你知道的前端性能优化方案有哪些？

##### 客户端优化

- 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。
- 使用 CSS 雪碧图（CSS Sprites）CSS Sprites 一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的 HTTP 请求。
- 减少 DOM 操作次数，优化 javascript 性能。
- 少用全局变量、减少 DOM 操作、缓存 DOM 节点查找的结果。减少 IO 读取操作。
- 延迟加载 | 延迟渲染
- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
- 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。

##### 服务端优化

- 尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，压缩 css 和 js；或加快文件读取速度，优化服务端的缓存策略。
- 客户端优化 dom、css 和 js 的代码和加载顺序；或进行服务器端渲染，减轻客户端渲染的压力。
- 优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。

##### 缓存

http 缓存 设置好 cache-control expires Last-modified；
前端缓存 对于一些页面今天配置直接存储到 localStorage 中；对于长期不发生改变的代码可以直接通过 server-work 存储到本地；

##### 优化加载

webpack 开启 tree-shaking 减少代码体积
通过 preload prefetch 优化加载资源的时间
import('').then()异步加载资源
图片小于 30k 的图片直接做成 base64；
对于首屏的样式可以直接内嵌到 html 中；

##### 服务端渲染

SSR
对于首页可以直接通过 node jade 模板引擎输出，其他页面继续使用前端渲染，优化首屏、SEO

### 如何进行网站性能优化

- content 方面

  - 减少 HTTP 请求：合并文件、CSS 精灵、inline Image
  - 减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询
  - 避免重定向：多余的中间访问
  - 使 Ajax 可缓存
  - 非必须组件延迟加载
  - 未来所需组件预加载
  - 减少 DOM 元素数量
  - 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
  - 减少 iframe 数量
  - 不要 404

- Server 方面
  - 使用 CDN
  - 添加 Expires 或者 Cache-Control 响应头
  - 对组件使用 Gzip 压缩
  - 配置 ETag
  - Flush Buffer Early
  - Ajax 使用 GET 进行请求
  - 避免空 src 的 img 标签
- Cookie 方面

  - 减小 cookie 大小
  - 引入资源的域名不要包含 cookie

- css 方面

  - 将样式表放到页面顶部
  - 不使用 CSS 表达式
  - 不使用 IE 的 Filter

- Javascript 方面

  - 将脚本放到页面底部
  - 将 javascript 和 css 从外部引入
  - 压缩 javascript 和 css
  - 删除不需要的脚本
  - 减少 DOM 访问
  - 合理设计事件监听器

- 图片方面

  - 优化图片：根据实际颜色需要选择色深、压缩
  - 优化 css 精灵
  - 不要在 HTML 中拉伸图片
  - 保证 favicon.ico 小并且可缓存

- 移动方面
  - 保证组件小于 25k
  - `Pack Components into a Multipart Document`

**谈谈性能优化问题**

- 代码层面：避免使用 css 表达式，避免使用高级选择器，通配选择器
- 缓存利用：缓存 Ajax，使用 CDN，使用外部 js 和 css 文件以便缓存，添加 Expires 头，服务端配置 Etag，减少 DNS 查找等
- 请求数量：合并样式和脚本，使用 css 图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载
- 请求带宽：压缩文件，开启 GZIP

**代码层面的优化**

- 用 hash-table 来优化查找

- 少用全局变量

- 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能

- 用 setTimeout 来避免页面失去响应

- 缓存 DOM 节点查找的结果

- 避免使用 CSS Expression

- 避免全局查询

- 避免使用 with(with 会创建自己的作用域，会增加作用域链长度)

- 多个变量声明合并

- 避免图片和 iFrame 等的空 Src。空 Src 会重新加载当前页面，影响速度和效率

- 尽量避免写在 HTML 标签中写 Style 属性

**前端性能优化最佳实践？**

- 性能评级工具（PageSpeed 或 YSlow）
- 合理设置 HTTP 缓存：Expires 与 Cache-control
- 静态资源打包，开启 Gzip 压缩（节省响应流量）
- CSS3 模拟图像，图标 base64（降低请求数）
- 模块延迟(defer)加载/异步(async)加载
- Cookie 隔离（节省请求流量）
- localStorage（本地存储）
- 使用 CDN 加速（访问最近服务器）
- 启用 HTTP/2（多路复用，并行加载）
- 前端自动化（gulp/webpack）

### 谈谈性能优化问题

代码层面：避免使用 css 表达式，避免使用高级选择器，通配选择器。

缓存利用：缓存 Ajax，使用 CDN，使用外部 js 和 css 文件以便缓存，添加 Expires 头，服务端配置 Etag，减少 DNS 查找等

请求数量：合并样式和脚本，使用 css 图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。

请求带宽：压缩文件，开启 GZIP，

> 代码层面的优化

- 用`hash-table`来优化查找

- 少用全局变量

- 用`innerHTML`代替`DOM`操作，减少`DOM`操作次数，优化`javascript`性能

- 用`setTimeout`来避免页面失去响应

- 缓存 DOM 节点查找的结果

- 避免使用 CSS Expression

- 避免全局查询

- 避免使用 with(with 会创建自己的作用域，会增加作用域链长度)

- 多个变量声明合并

- 避免图片和 iFrame 等的空 Src。空 Src 会重新加载当前页面，影响速度和效率
- 尽量避免写在 HTML 标签中写 Style 属性

### 移动端性能优化

- 尽量使用 css3 动画，开启硬件加速。
- 适当使用`touch`事件代替`click`事件。
- 避免使用`css3`渐变阴影效果。
- 可以用`transform: translateZ(0)`来开启硬件加速。
- 不滥用 Float。Float 在渲染时计算量比较大，尽量减少使用
- 不滥用 Web 字体。Web 字体需要下载，解析，重绘当前页面，尽量减少使用。
- 合理使用 requestAnimationFrame 动画代替 setTimeout
- CSS 中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发 GPU 渲染，请合理使用。过渡使用会引发手机过耗电增加
- PC 端的在移动端同样适用

> 相关阅读：[如何做到一秒渲染一个移动页面](https://github.com/cssmagic/blog/issues/20)

### 异步加载和延迟加载

1. 异步加载的方案： 动态插入 script 标签
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行
3. script 标签上添加 defer 或者 async 属性
4. 创建并插入 iframe，让它异步执行 js
5. 延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的

## 网络优化

压缩传输内容，用好缓存

### 合并资源文件，减少 HTTP 请求

浏览器并发的 HTTP 请求是由数量限制的（比如桌面浏览器并发请求可能是 8 个，手机浏览器是 6 个），如果一下子并发的几十个请求那么会有很多请求会停下来等，等前面的请求好了下一个再进去，这样就延长了整个页面的加载时间

### 压缩资源文件减小请求大小

文件大小越小当然加载速度就越快。
可对代码进行压缩，去掉空格、注释、变量替换，在传输时，使用 gzip 等压缩方式也可以降低资源文件的大小。

### 利用缓存机制，尽可能使用缓存减少请求

浏览器是有缓存机制的，在返回资源的时候设置一个 cache-control 设置过期时间，在过期时间内浏览器会默认使用本地缓存。

但缓存机制也存在一定的问题，因为网站开发是阶段性的，隔一段时间会发布一个新的版本。因为 HTTP 请求是根据 url 来定位的，如果资源文件名的 url 没有发生更改那么浏览器还是会使用缓存，这个时候怎么办那？
这时就需要一个缓存更新机制来让修改过的文件具有一个新的名字。
最简单的方法就是在 url 后加一个时间戳，但是这会导致只要有新的版本发布就会重新获取所有的新资源。
一个现代流行的方法就是根据文件计算一个 hash 值，这个 hash 值是根据文件的更新变化而变化的。 当浏览器获取文件时如果这个文件名有更新那么就会请求新的文件。

### 使用 HTTP / 2.0

- 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间
- 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小

### DNS 预解析

- DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP

现代浏览器在 DNS Prefetch 上做了两项工作：

1. html 源码下载完成后，会解析页面的包含链接的标签，提前查询对应的域名

2. 对于访问过的页面，浏览器会记录一份域名列表，当再次打开时，会在 html 下载的同时去解析 DNS

**自动解析**

浏览器使用超链接的 href 属性来查找要预解析的主机名。当遇到 a 标签，浏览器会自动将 href 中的域名解析为 IP 地址，这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在 HTTPS 页面中不会自动解析

**手动解析**

```html
预解析某域名
<link rel="dns-prefetch" href="//img.alicdn.com" />

强制开启HTTPS下的DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on" />
```

### CDN

CDN 的原理是尽可能的在各个地方分布机房缓存数据。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

- CDN 是一种部署策略，根据不同的地区部署类似 nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在静态资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源
- (CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理 4 个要件

### 负载均衡

当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力

### 预加载

- 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载
- 预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com" />
```

> 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好

### 预渲染

> 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

- 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

### 使用 Cookie 隔离

- 通过将一些静态资源或者不需要通过鉴权的请求转移到非主域名下去，因为跨域的限制，主域名的一些 cookie 就不会带上，降低请求头的大小，节省流量，降低时延。
- server 不会接收到 cookie ， 因此也减少了 server 对 cookie 的处理时间，提高 server 的请求解析速度。

## 缓存

缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。

通常浏览器缓存策略分为两种：强缓存和协商缓存。

### 强缓存

实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200

```js
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

`Expires` 是 HTTP / 1.0 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

```js
Cache-control: max-age=30
```

`Cache-Control` 出现于 HTTP / 1.1，优先级高于 `Expires` 。该属性表示资源会在 30 秒后过期，需要再次请求。

### 协商缓存

如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。

协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。

#### Last-Modified 和 If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP / 1.1 出现了 `ETag` 。

#### ETag 和 If-None-Match

`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。

### 选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

## 文件优化

- CSS 文件放在 `head` 中
- 服务端开启文件压缩功能
- 将 `script` 标签放在 `body` 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 `script` 标签放在任意位置然后加上 `defer` ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 `async` ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。
- 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 `Webworker`。`Webworker` 可以让我们另开一个线程执行脚本而不影响渲染。

### CDN

静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

### 图片加载优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG

## 优化渲染过程

### 懒执行

- 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒

### 懒加载

- 懒加载就是将不关键的资源延后加载

> 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载

- 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等

懒加载就是根据用户的浏览需要记载内容，也就是在用户即将浏览完当前的内容时进行继续加载内容，这种技术常常用来加载图片的时候使用。我们判断用户是否即将浏览到底部之后进行在家内容
这时候可能会需要加载大量的内容，可以使用 fragment 来优化一下，因为大部分是使用滑动和滚轮来触发的，因此很有可能会不断触发，可以使用函数节流做一个优化，防止用户不断触发。

## 其他

### 节流

考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。

理解了节流的用途，我们就来实现下这个函数

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0;
  return function(...args) {
    // 当前时间
    let now = +new Date();
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now;
      func.apply(this, args);
    }
  };
};

setInterval(
  throttle(() => {
    console.log(1);
  }, 500),
  1,
);
```

### 防抖

考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

理解了防抖的用途，我们就来实现下这个函数

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0;
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
};
```

### 使用 Webpack 优化项目

- 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
- 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 base64 的方式写入文件中
- 按照路由拆分代码，实现按需加载
- 给打包出来的文件名添加哈希，实现浏览器缓存文件

### 首屏加载优化

- Vue-Router 路由懒加载（利用 Webpack 的代码切割）
- 使用 CDN 加速，将通用的库从 vendor 进行抽离
- Nginx 的 gzip 压缩
- Vue 异步组件
- 服务端渲染 SSR
- 如果使用了一些 UI 库，采用按需加载
- Webpack 开启 gzip 压缩
- 如果首屏为登录页，可以做成多入口
- Service Worker 缓存文件处理
- 使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

### 对组件库的优化

- 提供按需加载
- 图片、样式等走 cdn，懒加载等
- table list 海量数据，虚拟列表
- 页面加载海量数据
  - https://juejin.im/post/5ae17a386fb9a07abc299cdd

### 前端性能优化的考虑 2020.11.02

1. 网页长度超出一个窗口屏幕比较多的时候，需要考虑图片、接口的懒加载
2. webpack 的 code split 拆分 bundle 包大小之后，由于大多引用的是 min.js 文件 cdn 因此对于错误的堆栈不清晰，采用上传 sourcemap 恢复真实的行数的形式，类似 sentry 的操作。
3. 前端组件的 keep-alive ，页面退出及时 cancel 未完成的请求（封装 axios）
