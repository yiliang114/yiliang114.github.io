---
layout: CustomPages
title: performance
date: 2020-11-21
aside: false
draft: true
---

### 总结

1. 减少 HTTP 请求，资源压缩合并，开启 gzip 压缩， 使用 CDN 加速静态资源
2. DNS 预解析
3. 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
4. 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
5. 当需要设置的样式很多时设置 className 而不是直接操作 style。
6. 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。
7. 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)。
8. 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
9. 非核心代码的异步加载
   1. 异步加载方式
   2. 异步加载的区别
10. 利用浏览器缓存
    1. 缓存分类
    2. 缓存原理
11. 避免空的 src 和 href
12. 为文件头指定 Expires
13. 使用 gzip 压缩内容
14. 把 CSS 放到顶部，把 JS 放到底部，避免使用 CSS 表达式
15. 将 CSS 和 JS 放到外部文件中
16. 避免跳转
17. 可缓存的 AJAX
18. 使用 GET 来完成 AJAX 请求

### 如何进行网站性能优化

- content 方面

  1. 减少 HTTP 请求：合并文件、CSS 精灵、inline Image
  2. 减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询
  3. 避免重定向：多余的中间访问
  4. 使 Ajax 可缓存
  5. 非必须组件延迟加载
  6. 未来所需组件预加载
  7. 减少 DOM 元素数量
  8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
  9. 减少 iframe 数量
  10. 不要 404

- Server 方面
  1. 使用 CDN
  2. 添加 Expires 或者 Cache-Control 响应头
  3. 对组件使用 Gzip 压缩
  4. 配置 ETag
  5. Flush Buffer Early
  6. Ajax 使用 GET 进行请求
  7. 避免空 src 的 img 标签
- Cookie 方面
  1. 减小 cookie 大小
  2. 引入资源的域名不要包含 cookie
- css 方面
  1. 将样式表放到页面顶部
  2. 不使用 CSS 表达式
  3. 使用<link>不使用@import
  4. 不使用 IE 的 Filter
- Javascript 方面
  1. 将脚本放到页面底部
  2. 将 javascript 和 css 从外部引入
  3. 压缩 javascript 和 css
  4. 删除不需要的脚本
  5. 减少 DOM 访问
  6. 合理设计事件监听器
- 图片方面
  1. 优化图片：根据实际颜色需要选择色深、压缩
  2. 优化 css 精灵
  3. 不要在 HTML 中拉伸图片
  4. 保证 favicon.ico 小并且可缓存
- 移动方面
  1. 保证组件小于 25k
  2. Pack Components into a Multipart Document

### 你如何对网站的文件和资源进行优化？

    期待的解决方案包括：
     文件合并
     文件最小化/文件压缩
     使用 CDN 托管
     缓存的使用（多个域名来提供缓存）
     其他

### 请说出三种减少页面加载时间的方法。

1. 优化图片
2. 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）
3. 优化 CSS（压缩合并 css，如 margin-top,margin-left...)
4. 网址后加斜杠（如 www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）
5. 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）
6. 减少 http 请求（合并文件，合并图片）。

### 面试题

**如何渲染几万条数据并不卡住界面**

这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 `requestAnimationFrame` 来每 16 ms 刷新一次。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      控件
    </ul>
    <script>
      setTimeout(() => {
        // 插入十万条数据
        const total = 100000;
        // 一次插入 20 条，如果觉得性能不好就减少
        const once = 20;
        // 渲染数据总共需要几次
        const loopCount = total / once;
        let countOfRender = 0;
        let ul = document.querySelector('ul');
        function add() {
          // 优化性能，插入不会造成回流
          const fragment = document.createDocumentFragment();
          for (let i = 0; i < once; i++) {
            const li = document.createElement('li');
            li.innerText = Math.floor(Math.random() * total);
            fragment.appendChild(li);
          }
          ul.appendChild(fragment);
          countOfRender += 1;
          loop();
        }
        function loop() {
          if (countOfRender < loopCount) {
            window.requestAnimationFrame(add);
          }
        }
        loop();
      }, 0);
    </script>
  </body>
</html>
```

- 你会用什么工具来查找代码中的性能问题？
- 你会用什么方式来增强网站的页面滚动效能？
- 请解释 layout、painting 和 compositing 的区别。

Form [Front-end-Developer-Interview-Questions](https://github.com/h5bp/Front-end-Developer-Interview-Questions)

- [Yahoo Best Practices for Speeding Up Your Web Site](https://developer.yahoo.com/performance/rules.html)
- [Google 使用 RAIL 模型评估性能](https://developers.google.com/web/fundamentals/performance/rail)
- [前端性能优化最佳实践](https://csspod.com/frontend-performance-best-practices/)

1. 前端长列表的性能优化

只渲染页面用用户能看到的部分。并且在不断滚动的过程中去除不在屏幕中的元素，不再渲染，从而实现高性能的列表渲染。
借鉴着这个想法，我们思考一下。当列表不断往下拉时，web 中的 dom 元素就越多，即使这些 dom 元素已经离开了这个屏幕，不被用户所看到了，这些 dom 元素依然存在在那里。导致浏览器在渲染时需要不断去考虑这些 dom 元素的存在，
造成 web 浏览器的长列表渲染非常低效。因此，实现的做法就是捕捉 scroll 事件，当 dom 离开屏幕，用户不再看到时，就将其移出 dom tree。

### 插入几万个 DOM，如何实现页面不卡顿？

肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。部分人应该可以想到通过 `requestAnimationFrame` 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：**虚拟滚动**（virtualized scroller）。

这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

![滚动](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/vScroll.png)

从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这发问题。如果你想了解更多的内容可以了解下这个 [react-virtualized](https://github.com/bvaughn/react-virtualized)。

项目中使用过哪些优化方法
优化中会提到缓存的问题，问：静态资源或者接口等如何做缓存优化
页面 DOM 节点太多，会出现什么问题？如何优化？

### a.b.c.d 和 a['b']['c']['d']，哪个性能更高？

[参考链接](https://github.com/airuikun/Weekly-FE-Interview/issues/19)

### 2 万小球问题：在浏览器端，用 js 存储 2 万个小球的信息，包含小球的大小，位置，颜色等，如何做到对这 2 万条小球信息进行最优检索和存储

思路：

- 用 ArrayBuffer 实现极致存储
- 哈夫曼编码 + 字典查询树实现更优索引
- 用 bit-map 实现大数据筛查
- 用 hash 索引实现简单快捷的检索
- 用 IndexedDB 实现动态存储扩充浏览器端虚拟容量
- 用 iframe 的漏洞实现浏览器端 localStorage 无限存储，实现 2 千万小球信息存储

扩展：如何尽可能流畅的实现这 2 万小球在浏览器中，以直线运动的动效显示出来. 提供几个思路：

- 使用 GPU 硬件加速
- 使用 webGL
- 使用 assembly 辅助计算，然后在浏览器端控制动画帧频
- 用 web worker 实现 javascript 多线程，分块处理小球
- 用单链表树算法和携程机制，实现任务动态分割和任务暂停、恢复、回滚，动态渲染和处理小球

### 100 亿排序问题：内存不足，一次只允许你装载和操作 1 亿条数据，如何对 100 亿条数据进行排序

- 把这 100 亿的 int 型数据以文件形式存储到 100 个小文件中
- 对这 100 个小文件分别读取后排序再存入
- 遍历排序后对 100 个小文件，每个小文件里面取第一个数字, 组成一个 100 大数的堆
- new 个空的大文件存最后的结果
- 之后出 100 个数的那个堆,找到对应的小文件取数字,写入大文件, 记得 flash, gc 之类的
- 循环 3, 等所有的小文件都取完, 大文件就是存的最后结果

### 页面大量图片，如何优化加载，优化用户体验

图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
如果图片为 css 图片，可以使用 CSSsprite，SVGsprite 等技术。
如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。

### 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少

![image](https://user-images.githubusercontent.com/21194931/57821866-bd9d2a80-77c4-11e9-8c27-c38ed2752197.png)

数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)
消耗时间几乎一致，差异可以忽略不计

### Vue react 项目的路由懒加载

### 图片懒加载，vue-lazyload 的实现原理

### 图片 base64 处理， 说一说 base64 做的处理是什么？

### chrome 75 之后 img 可以直接被懒加载 loading=lazy

### 如果一个页面要做性能优化，从哪方面考察，从哪些地方优化

### 项目中使用过哪些优化方法

### 优化中会提到缓存的问题，问：静态资源或者接口等如何做缓存优化

### 服务部署到同一个区域，能加速；静态资源使用 cdn

### 雪碧图处理： 直接通过 wbepack 插件进行处理。 小于多大的自动创建雪碧图。我记得是。

### 请解释 layout、painting 和 compositing 的区别。

### 性能优化

### 减少 http 请求数

- 使用 grophl ，最佳的解决方案

### vue 中 code spilt ，路由懒加载。

### css，js 放置位置， 异步加载 js

### 代码压缩、图片压缩

### 雪碧图

### cdn 原理

### 懒加载原理

### localstorage 等离线缓存

### 域名收敛和发散 也是一种优化

### 图片进行懒加载

### 一个页面中需要请求很多个接口才能获取到需要的所有数据，通过 graphQL 将接口进行聚合。列表类的接口通常可以设置成懒加载（如果不是设置成翻页的话）

### h5 中如何优化首屏

### 如何优化 vue 项目的 bundlejs 体积， webpack-bundle-analyzer 打包依赖分析。

### 接口 waiting 时间很长， 请求到是很快

### vuex 的封装，希望一个接口请求之后，能够灵活得触发额外的几个异步接口

### vuex 动态加载 namespace， 整个 store 树一起加载会很慢

- 首先，vuex 里面并不推荐使用 redux 的状态机，success error 等状态，都能够触发不同的自定义异步事件，至于 loading 的状态，应该是根据 vuex getter 中获取的数据，是否符合预期，符合预期就显示，如果不符合预期，比如报错了，如果不适用全局通知的话怎么全局显示 是一个问题？这就是状态机的必要之处吧？ 想一想这里如何进行处理。 如果能用全局通知的话，状态机似乎就真的没啥用了。

### window.performce 这个 api 的使用，以及哪一些数据能够被用来采集上报等

### 分析 emonitor 的实现和上报的原理

### 加快页面的加载速度的方式

### cdn 的用法是什么？什么时候用到？

### 浏览器的页面优化？

### 如何优化 DOM 操作的性能

### 单页面应用有什么 SEO 方案？

### 单页面应用首屏显示比较慢，原因是什么？有什么解决方案？

### 谈谈你对前端性能优化的理解:

a. 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域
b. 请求带宽：开启 GZip，精简 JavaScript，移除重复脚本，图像优化，将 icon 做成字体
c. 缓存利用：使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使
AjaX 可缓存
d. 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出
e. 代码校验：避免 CSS 表达式，避免重定向
参考《前端工程与性能优化》

### 请说出三种减少页面加载时间的方法

a. 尽量减少页面中重复的 HTTP 请求数量
b. 服务器开启 gzip 压缩
c. css 样式的定义放置在文件头部
d. Javascript 脚本放在文件末尾
e. 压缩合并 Javascript、CSS 代码
f. 使用多域名负载网页内的多个文件、图片
参考《减低页面加载时间的方法》

### 你都使用哪些工具来测试代码的性能？

JSPerf, Dromaeo

### 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用

户更好的体验。
a. 图片懒加载，滚动到相应位置才加载图片。
b. 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。
c. 使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术，如果图片为 css 图片的话。
d. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。

### 图片懒加载与预加载

图片懒加载的原理就是暂时不设置图片的 src 属性，而是将图片的 url 隐藏起来，比如先写在 data-src 里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的 url 放进 src 属性里面，从而实现图片的延迟加载

图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在 css 的 background 的 url 属性里面，一种是通过 javascript 的 Image 对象设置实例对象的 src 属性实现图片的预加载。相关代码如下：
css 实现

```css
#preload-01 {
  background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px;
}
#preload-02 {
  background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px;
}
#preload-03 {
  background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px;
}
```

Javascript 预加载图片的方式：

```js
function preloadImg(url) {
  var img = new Image();
  img.src = url;
  if (img.complete) {
    //接下来可以使用图片了
    //do something here
  } else {
    img.onload = function() {
      //接下来可以使用图片了
      //do something here
    };
  }
}
```

预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。
两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。
懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力

### cdn 的用法是什么？什么时候用到？

### 前端性能

### 性能优化，除了雅虎 13 条军规，还有哪些

### resize 和 scroll 事件的性能优化

### 看了一下你的几个项目，能告诉我你在遇到问题是怎么解决的吗?（问题主要在最后的性能问题上。自己首先会尝试调优一下自己的代码，然后再去从文件打包上去思考，如果无法自己解决，会去参考下别人的博客或者是社区。）

### 开启 gzip

### 如何加快页面加载速度？（减少 HTTP 访问次数、CDN、minify、服务器增加缓存、CSS 放前面 JS 放后面、图片压缩、CSS Sprite（我之前一直以为是 Spirit ）等。）

### 为什么要减少 HTTP 访问次数？（浏览器进程请求链接的数目是有限的，如果有很多 HTTP 请求，有些就得等着；另外，建立 HTTP 链接的开销比较大，需要三次握手之类，而相对地，一次连接中文件大小的边际成本就很小。）

### 文件合并

### css 精灵

### 避免页面跳转

### JavaScript 延迟加载

### 减少 dom 元素数量：会加大页面加载和脚本执行的效率

### 浏览器一般对于同一个域的下载连接数有所限制，按照域名划分下载内容可以使得浏览器增大并行下载链接，但是注意控制域名使用在 2-4 个之间，不然 dns 查询也是个问题。

### 一般网站规划会将静态资源放在类似于 static.example.com，动态内容放在 www.example.com 上，这样做还有一个好处是可以在静态的域名上避免使用 cookie，后面会在 cookie 的规则中提到。

### （静态资源 static.example.com 和动态内容 www.example.com 这个例子有点小问题，很多大型网站由于存在分站（比如网易的 news.163.com），cookie 是写在.example.com 下的，静态资源域名需要彻底剥离，比如淘宝的 tbcdn.com）

### 404 我们都不陌生，代表服务器没有找到资源，我们需要特别注意 404 的情况 下不要在我们提供的网页资源上，客户端发送一个请求但是服务器却反悔一个无用- 的结果，时间浪费掉了。

### 使用 cdn

### 利用缓存： cache-control 和 expires

### gzip 压缩传输文件

### 配置 etag

### 避免空的 src： 空的图- 然会使浏览器发送请求到服务器，这样完全是浪费事件，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请- 求造成的伤害不容忽略。

### 减少 cookie 的大小： cookie 被用来做认证或者个性化设置，其信息被包含在 http 报文头中，对于 cookie 我们需要注意以下几点，来提高请求的响应速度。

### Gzip

差不多能压缩 1/4 的体积
https://blog.csdn.net/baidu_35407267/article/details/77141871
es6 以上不支持 uglify 需要压缩代码的话，要使用 babel 的 minify

### css 样式表置顶： 经样式表（css）放在网页的 head 这种会让网页的加载速度更快，因为这样做可以使浏览器逐步加载已经下载的网页内容。这对内容比较多的网页尤其重要，用户不用一直等待在一个白屏上而是可以先看已经下载的内容。如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在- 实现时都努力避免重绘，样式表中的内容是绘制网页的关键信息，没有下载下来之前只好对不起观众了。

### 文件合并（目的是减少 http 请求）

### 文件压缩：目的是直接减少文件下载的体积

### 使用 CDN （内容分发网络）来托管资源

### 缓存的使用（并且多个域名来提供缓存）

### GZIP 压缩你的 JS 和 CSS 文件

### 减少 http 请求（合并文件、合并图片）

### 优化图片文件，减小其尺寸，特别是缩略图，图片懒加载

### 压缩 Javascript、CSS 代码

### 从雪碧图到 svg

### 从 promise 到 await

### vue react 从生命周期中考虑的避免 rerender 的优化

### cdn 加速

### webpack 压缩

### 图片资源的压缩，换格式啥的

### 添加缓存 expires 头进行缓存，或者为 HTML 指定 Cache-Control

### 配置 Etag 和 Last-Modified

### 使用 ajax 可缓存（在进行 Ajax 请求的时候，可以选择尽量使用 get 方法，这样可以使用客户端的缓存，提高请求速度。）

### 静态资源不同域名存放（同一个域名并行下载文件数量有限）

### https://www.jianshu.com/p/ead7dab72cd6?mType=Group

#### TODO: react vue jquery 的图片懒加载、背景图片懒加载的功能

https://github.com/lzxb/lazy-load-img
https://github.com/tuupola/jquery_lazyload/blob/2.x/lazyload.js
https://www.cnblogs.com/careyyibu/p/8695205.html
https://blog.csdn.net/baidu_24024601/article/details/76167082
http://www.techug.com/post/photoshop-beauty-experiment.html
http://www.webhek.com/post/background-image-lazy-load.html
https://code.i-harness.com/zh-CN/q/b7540e
https://github.com/ApoorvSaxena/lozad.js/blob/master/src/lozad.js
https://segmentfault.com/a/1190000011527281

https://juejin.im/post/5d548b83f265da03ab42471d

### 单页面首屏加载慢，原因是什么，有什么解决方案

### react-loadable

react-loadable 用来创建动态路由，能够根据路由进行 code spliting。

但是，所有有切换状态的组件上，都使用 react-loadable 会造成 js 文件过多的问题么？

### 常见的网页性能优化方法

- 减少 HTTP 请求。使用雪碧图、内联图片，合并脚本和样式表。
- 使用内容分发网络（CDN）
- 添加 Expires 头
- 压缩组件。压缩样式表和脚本，开启 gzip 压缩大概减少 70%的大小
- 样式表放在顶部
- 将脚本放在底部
- 避免 CSS 表达式
- 使用外部 JavaScript 和 CSS
- 减少 DNS 查找
- 精简 JavaScript
- 避免重定向。网站中除了域名首页外缺少斜杠将引起 301 重定向，个人测试工作室网站这个重定向消耗的时间在 30ms 左右
- 删除重复脚本
- 配置 ETag
- 使 Ajax 可缓存

### 你有用过哪些前端性能优化的方法？

- 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。
- 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
- 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。
- 当需要设置的样式很多时设置 className 而不是直接操作 style
- 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作
- 避免使用 CSS Expression（css 表达式)又称 Dynamic properties(动态属性)
- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳
- 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢
- 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如 join 查询），减少磁盘 IO 指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的

### 你如何对网站的文件和资源进行优化？

1. 文件合并
2. 文件最小化/文件压缩
3. 使用 CDN 托管
4. 缓存的使用（多个域名来提供缓存）
5. 其他

### 谈一谈你知道的前端性能优化方案有哪些？

##### 客户端优化

- 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。
- 使用 CSS 雪碧图（CSS Sprites）CSS Sprites 一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的 HTTP 请求。
- 减少 DOM 操作次数，优化 javascript 性能。
- 少用全局变量、减少 DOM 操作、缓存 DOM 节点查找的结果。减少 IO 读取操作。
- 延迟加载 | 延迟渲染
- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
- 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。

##### 服务端优化

- 尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，压缩 css 和 js；或加快文件读取速度，优化服务端的缓存策略。
- 客户端优化 dom、css 和 js 的代码和加载顺序；或进行服务器端渲染，减轻客户端渲染的压力。
- 优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。

##### 缓存

http 缓存 设置好 cache-control expires Last-modified；
前端缓存 对于一些页面今天配置直接存储到 localStorage 中；对于长期不发生改变的代码可以直接通过 server-work 存储到本地；

##### 优化加载

webpack 开启 tree-shaking 减少代码体积
通过 preload prefetch 优化加载资源的时间
import('').then()异步加载资源
图片小于 30k 的图片直接做成 base64；
对于首屏的样式可以直接内嵌到 html 中；

##### 服务端渲染

SSR
对于首页可以直接通过 node jade 模板引擎输出，其他页面继续使用前端渲染，优化首屏、SEO

### 如何进行网站性能优化

- content 方面

  - 减少 HTTP 请求：合并文件、CSS 精灵、inline Image
  - 减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询
  - 避免重定向：多余的中间访问
  - 使 Ajax 可缓存
  - 非必须组件延迟加载
  - 未来所需组件预加载
  - 减少 DOM 元素数量
  - 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
  - 减少 iframe 数量
  - 不要 404

- Server 方面
  - 使用 CDN
  - 添加 Expires 或者 Cache-Control 响应头
  - 对组件使用 Gzip 压缩
  - 配置 ETag
  - Flush Buffer Early
  - Ajax 使用 GET 进行请求
  - 避免空 src 的 img 标签
- Cookie 方面

  - 减小 cookie 大小
  - 引入资源的域名不要包含 cookie

- css 方面

  - 将样式表放到页面顶部
  - 不使用 CSS 表达式
  - 不使用 IE 的 Filter

- Javascript 方面

  - 将脚本放到页面底部
  - 将 javascript 和 css 从外部引入
  - 压缩 javascript 和 css
  - 删除不需要的脚本
  - 减少 DOM 访问
  - 合理设计事件监听器

- 图片方面

  - 优化图片：根据实际颜色需要选择色深、压缩
  - 优化 css 精灵
  - 不要在 HTML 中拉伸图片
  - 保证 favicon.ico 小并且可缓存

- 移动方面
  - 保证组件小于 25k
  - `Pack Components into a Multipart Document`

**谈谈性能优化问题**

- 代码层面：避免使用 css 表达式，避免使用高级选择器，通配选择器
- 缓存利用：缓存 Ajax，使用 CDN，使用外部 js 和 css 文件以便缓存，添加 Expires 头，服务端配置 Etag，减少 DNS 查找等
- 请求数量：合并样式和脚本，使用 css 图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载
- 请求带宽：压缩文件，开启 GZIP

**代码层面的优化**

- 用 hash-table 来优化查找

- 少用全局变量

- 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能

- 用 setTimeout 来避免页面失去响应

- 缓存 DOM 节点查找的结果

- 避免使用 CSS Expression

- 避免全局查询

- 避免使用 with(with 会创建自己的作用域，会增加作用域链长度)

- 多个变量声明合并

- 避免图片和 iFrame 等的空 Src。空 Src 会重新加载当前页面，影响速度和效率

- 尽量避免写在 HTML 标签中写 Style 属性

**前端性能优化最佳实践？**

- 性能评级工具（PageSpeed 或 YSlow）
- 合理设置 HTTP 缓存：Expires 与 Cache-control
- 静态资源打包，开启 Gzip 压缩（节省响应流量）
- CSS3 模拟图像，图标 base64（降低请求数）
- 模块延迟(defer)加载/异步(async)加载
- Cookie 隔离（节省请求流量）
- localStorage（本地存储）
- 使用 CDN 加速（访问最近服务器）
- 启用 HTTP/2（多路复用，并行加载）
- 前端自动化（gulp/webpack）

### 谈谈性能优化问题

代码层面：避免使用 css 表达式，避免使用高级选择器，通配选择器。

缓存利用：缓存 Ajax，使用 CDN，使用外部 js 和 css 文件以便缓存，添加 Expires 头，服务端配置 Etag，减少 DNS 查找等

请求数量：合并样式和脚本，使用 css 图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。

请求带宽：压缩文件，开启 GZIP，

> 代码层面的优化

- 用`hash-table`来优化查找

- 少用全局变量

- 用`innerHTML`代替`DOM`操作，减少`DOM`操作次数，优化`javascript`性能

- 用`setTimeout`来避免页面失去响应

- 缓存 DOM 节点查找的结果

- 避免使用 CSS Expression

- 避免全局查询

- 避免使用 with(with 会创建自己的作用域，会增加作用域链长度)

- 多个变量声明合并

- 避免图片和 iFrame 等的空 Src。空 Src 会重新加载当前页面，影响速度和效率
- 尽量避免写在 HTML 标签中写 Style 属性

### 移动端性能优化

- 尽量使用 css3 动画，开启硬件加速。
- 适当使用`touch`事件代替`click`事件。
- 避免使用`css3`渐变阴影效果。
- 可以用`transform: translateZ(0)`来开启硬件加速。
- 不滥用 Float。Float 在渲染时计算量比较大，尽量减少使用
- 不滥用 Web 字体。Web 字体需要下载，解析，重绘当前页面，尽量减少使用。
- 合理使用 requestAnimationFrame 动画代替 setTimeout
- CSS 中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发 GPU 渲染，请合理使用。过渡使用会引发手机过耗电增加
- PC 端的在移动端同样适用

> 相关阅读：[如何做到一秒渲染一个移动页面](https://github.com/cssmagic/blog/issues/20)

### 异步加载和延迟加载

1. 异步加载的方案： 动态插入 script 标签
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行
3. script 标签上添加 defer 或者 async 属性
4. 创建并插入 iframe，让它异步执行 js
5. 延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的

## 网络优化

压缩传输内容，用好缓存

### 合并资源文件，减少 HTTP 请求

浏览器并发的 HTTP 请求是由数量限制的（比如桌面浏览器并发请求可能是 8 个，手机浏览器是 6 个），如果一下子并发的几十个请求那么会有很多请求会停下来等，等前面的请求好了下一个再进去，这样就延长了整个页面的加载时间

### 压缩资源文件减小请求大小

文件大小越小当然加载速度就越快。
可对代码进行压缩，去掉空格、注释、变量替换，在传输时，使用 gzip 等压缩方式也可以降低资源文件的大小。

### 利用缓存机制，尽可能使用缓存减少请求

浏览器是有缓存机制的，在返回资源的时候设置一个 cache-control 设置过期时间，在过期时间内浏览器会默认使用本地缓存。

但缓存机制也存在一定的问题，因为网站开发是阶段性的，隔一段时间会发布一个新的版本。因为 HTTP 请求是根据 url 来定位的，如果资源文件名的 url 没有发生更改那么浏览器还是会使用缓存，这个时候怎么办那？
这时就需要一个缓存更新机制来让修改过的文件具有一个新的名字。
最简单的方法就是在 url 后加一个时间戳，但是这会导致只要有新的版本发布就会重新获取所有的新资源。
一个现代流行的方法就是根据文件计算一个 hash 值，这个 hash 值是根据文件的更新变化而变化的。 当浏览器获取文件时如果这个文件名有更新那么就会请求新的文件。

### 使用 HTTP / 2.0

- 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间
- 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小

### DNS 预解析

- DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP

现代浏览器在 DNS Prefetch 上做了两项工作：

1. html 源码下载完成后，会解析页面的包含链接的标签，提前查询对应的域名

2. 对于访问过的页面，浏览器会记录一份域名列表，当再次打开时，会在 html 下载的同时去解析 DNS

**自动解析**

浏览器使用超链接的 href 属性来查找要预解析的主机名。当遇到 a 标签，浏览器会自动将 href 中的域名解析为 IP 地址，这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在 HTTPS 页面中不会自动解析

**手动解析**

```html
预解析某域名
<link rel="dns-prefetch" href="//img.alicdn.com" />

强制开启HTTPS下的DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on" />
```

### CDN

CDN 的原理是尽可能的在各个地方分布机房缓存数据。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

- CDN 是一种部署策略，根据不同的地区部署类似 nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在静态资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源
- (CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理 4 个要件

### 负载均衡

当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力

### 预加载

- 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载
- 预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com" />
```

> 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好

### 预渲染

> 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

- 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

### 使用 Cookie 隔离

- 通过将一些静态资源或者不需要通过鉴权的请求转移到非主域名下去，因为跨域的限制，主域名的一些 cookie 就不会带上，降低请求头的大小，节省流量，降低时延。
- server 不会接收到 cookie ， 因此也减少了 server 对 cookie 的处理时间，提高 server 的请求解析速度。

## 缓存

缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。

通常浏览器缓存策略分为两种：强缓存和协商缓存。

### 强缓存

实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200

```js
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

`Expires` 是 HTTP / 1.0 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

```js
Cache-control: max-age=30
```

`Cache-Control` 出现于 HTTP / 1.1，优先级高于 `Expires` 。该属性表示资源会在 30 秒后过期，需要再次请求。

### 协商缓存

如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。

协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。

#### Last-Modified 和 If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP / 1.1 出现了 `ETag` 。

#### ETag 和 If-None-Match

`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。

### 选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

## 文件优化

- CSS 文件放在 `head` 中
- 服务端开启文件压缩功能
- 将 `script` 标签放在 `body` 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 `script` 标签放在任意位置然后加上 `defer` ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 `async` ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。
- 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 `Webworker`。`Webworker` 可以让我们另开一个线程执行脚本而不影响渲染。

### CDN

静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

### 图片加载优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG

## 优化渲染过程

### 懒执行

- 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒

### 懒加载

- 懒加载就是将不关键的资源延后加载

> 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载

- 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等

懒加载就是根据用户的浏览需要记载内容，也就是在用户即将浏览完当前的内容时进行继续加载内容，这种技术常常用来加载图片的时候使用。我们判断用户是否即将浏览到底部之后进行在家内容
这时候可能会需要加载大量的内容，可以使用 fragment 来优化一下，因为大部分是使用滑动和滚轮来触发的，因此很有可能会不断触发，可以使用函数节流做一个优化，防止用户不断触发。

## 其他

### 节流

考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。

理解了节流的用途，我们就来实现下这个函数

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0;
  return function(...args) {
    // 当前时间
    let now = +new Date();
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now;
      func.apply(this, args);
    }
  };
};

setInterval(
  throttle(() => {
    console.log(1);
  }, 500),
  1,
);
```

### 防抖

考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

理解了防抖的用途，我们就来实现下这个函数

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0;
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
};
```

### 使用 Webpack 优化项目

- 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
- 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 base64 的方式写入文件中
- 按照路由拆分代码，实现按需加载
- 给打包出来的文件名添加哈希，实现浏览器缓存文件

### 首屏加载优化

- Vue-Router 路由懒加载（利用 Webpack 的代码切割）
- 使用 CDN 加速，将通用的库从 vendor 进行抽离
- Nginx 的 gzip 压缩
- Vue 异步组件
- 服务端渲染 SSR
- 如果使用了一些 UI 库，采用按需加载
- Webpack 开启 gzip 压缩
- 如果首屏为登录页，可以做成多入口
- Service Worker 缓存文件处理
- 使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

### 对组件库的优化

- 提供按需加载
- 图片、样式等走 cdn，懒加载等
- table list 海量数据，虚拟列表
- 页面加载海量数据
  - https://juejin.im/post/5ae17a386fb9a07abc299cdd

### 前端性能优化的考虑 2020.11.02

1. 网页长度超出一个窗口屏幕比较多的时候，需要考虑图片、接口的懒加载
2. webpack 的 code split 拆分 bundle 包大小之后，由于大多引用的是 min.js 文件 cdn 因此对于错误的堆栈不清晰，采用上传 sourcemap 恢复真实的行数的形式，类似 sentry 的操作。
3. 前端组件的 keep-alive ，页面退出及时 cancel 未完成的请求（封装 axios）

## HTML 标签上可做的优化

### script 标签：调整加载顺序提升渲染速度

由于浏览器的底层运行机制，渲染引擎在解析 HTML 时，若遇到 script 标签引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至 JavaScript 引擎来执行对应代码，代码执行完成之后切换至渲染引擎继续渲染页面。

在这一过程中可以看到，页面渲染过程中包含了请求文件以及执行文件的时间，但页面的首次渲染可能并不依赖这些文件，这些请求和执行文件的动作反而延长了用户看到页面的时间，从而降低了用户体验。

为了减少这些时间损耗，可以借助 script 标签的 3 个属性来实现。

- **async 属性**。立即请求文件，但不阻塞渲染引擎，而是文件加载完毕后阻塞渲染引擎并立即执行文件内容。

- **defer 属性**。立即请求文件，但不阻塞渲染引擎，等到解析完 HTML 之后再执行文件内容。

- **HTML5 标准 type 属性**，对应值为“module”。让浏览器按照 ECMA Script 6 标准将文件当作模块进行解析，默认阻塞效果同 defer，也可以配合 async 在请求完成后立即执行。

具体效果可以参看下图：

![1583465393011-810652f489ca6136.png](https://s0.lgstatic.com/i/image/M00/07/0E/Ciqc1F647iiAZx3cAAB1ewBzlh0431.png)

其中，绿色的线表示执行解析 HTML ，蓝色的线表示请求文件，红色的线表示执行文件。

从图中可以得知，采用 3 种属性都能减少请求文件引起的阻塞时间，只有 defer 属性以及 type="module" 情况下能保证渲染引擎的优先执行，从而减少执行文件内容消耗的时间，让用户更快地看见页面（即使这些页面内容可能并没有完全地显示）。

除此之外还应当注意，当渲染引擎解析 HTML 遇到 script 标签引入文件时，会立即进行一次渲染。所以这也就是为什么构建工具会把编译好的引用 JavaScript 代码的 script 标签放入到 body 标签底部，因为当渲染引擎执行到 body 底部时会先将已解析的内容渲染出来，然后再去请求相应的 JavaScript 文件。如果是内联脚本（即不通过 src 属性引用外部脚本文件直接在 HTML 编写 JavaScript 代码的形式），渲染引擎则不会渲染。

### link 标签：通过预处理提升渲染速度

在我们对大型单页应用进行性能优化时，也许会用到按需懒加载的方式，来加载对应的模块，但如果能合理利用 link 标签的 rel 属性值来进行预加载，就能进一步提升渲染速度。

- **dns\-prefetch**。当 link 标签的 rel 属性值为“dns\-prefetch”时，浏览器会对某个域名预先进行 DNS 解析并缓存。这样，当浏览器在请求同域名资源的时候，能省去从域名查询 IP 的过程，从而减少时间损耗。下图是淘宝网设置的 DNS 预解析。

![1583466667742-993b502f80fa3567.png](https://s0.lgstatic.com/i/image/M00/07/0E/Ciqc1F647jWAHmc_AAAiNGoHmY8154.png)

- **preconnect**。让浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析、TLS 协商、TCP 握手，通过消除往返延迟来为用户节省时间。

- **prefetch/preload**。两个值都是让浏览器预先下载并缓存某个资源，但不同的是，prefetch 可能会在浏览器忙时被忽略，而 preload 则是一定会被预先下载。

- **prerender**。浏览器不仅会加载资源，还会解析执行页面，进行预渲染。

这几个属性值恰好反映了浏览器获取资源文件的过程，在这里我绘制了一个流程简图，方便你记忆。

![1583470467405-1d2eb8baf7568d31.png](https://s0.lgstatic.com/i/image/M00/07/0E/Ciqc1F647j-AFiBtAABWh7ld3uA965.png)

浏览器获取资源文件的流程
