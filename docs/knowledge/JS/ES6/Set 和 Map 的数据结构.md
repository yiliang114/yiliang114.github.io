---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### Set

`Set`是`ES6`引入的一种类似`Array`的新的数据结构，`Set`实例的成员类似于数组`item`成员，区别是`Set`实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重

没有重复值得 Array,重复值会被自动过滤掉

### Map

`Map`是`ES6`引入的一种类似`Object`的新的数据结构，`Map`可以理解为是`Object`的超集，打破了以传统键值对形式定义对象，对象的`key`不再局限于字符串，也可以是`Object`。可以更加全面的描述对象的属性。Map 解决的是 Object 的键值对中键只能是字符串的问题。Map 是 Es6 提供的新的数据结构，是键值对的集合。Map 的“键”不限于字符串。各种类型的值（包括对象）都可以当做键。

对象缺陷: key 必须是字符串

Map 就是支持全类型的 key(如:number)

```js
var m = new Map([
  ['Michael', 95],
  ['Bob', 75],
  ['Tracy', 85],
]);
m.get('Michael'); // 95

var m = new Map(); // 空 Map
m.set('Adam', 67); // 添加新的 key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在 key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除 key 'Adam'
m.get('Adam'); // undefined
```

### WeakMap

WeakMap 结构与 Map 结构基本类似，唯一的区别就是 WeakMap 只接受对象作为键名（null 除外），而且键名所指向的对象不计入垃圾回收机制。

WeakMap 专用场景：它的键所对应的对象可能会在将来消失。

典型应用：一个对应 DOM 元素的 WeakMap 结构，当某个 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。

有时候我们会把对象作为一个对象的键用来存放属性值，普通集合类型比如简单对象会阻止垃圾回收器对这些作为属性键存在的对象的回收，有造成内存泄漏的危险。而 WeakMap,WeakSet 则更加安全些，这些作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。

### 介绍下 Set、Map、WeakSet 和 WeakMap 的比较

Set

1. 成员不能重复
2. 只有健值，没有键名，有点类似数组。
3. 可以遍历，方法有 add,delete,has

weakSet

1. 成员都是对象
2. 成员都是弱引用，随时可以消失。 可以用来保存 DOM 节点，不容易造成内存泄漏
3. 不能遍历，方法有 add,delete,has

Map

1. 本质上是健值对的集合，类似集合
2. 可以遍历，方法很多，可以干跟各种数据格式转换

weakMap

1. 直接受对象作为键名（null 除外），不接受其他类型的值作为键名
2. 键名所指向的对象，不计入垃圾回收机制
3. 不能遍历，方法同 get,set,has,delete

### Set

##### Set

- 定义：类似于数组的数据结构，成员值都是唯一且没有重复的值
- 声明：`const set = new Set(arr)`
- 入参：具有`Iterator接口`的数据结构
- 属性
  - **constructor**：构造函数，返回 Set
  - **size**：返回实例成员总数
- 方法
  - **add()**：添加值，返回实例
  - **delete()**：删除值，返回布尔值
  - **has()**：检查值，返回布尔值
  - **clear()**：清除所有成员
  - **keys()**：返回以属性值为遍历器的对象
  - **values()**：返回以属性值为遍历器的对象
  - **entries()**：返回以属性值和属性值为遍历器的对象
  - **forEach()**：使用回调函数遍历每个成员

> 应用场景

- 去重字符串：`[...new Set(str)].join("")`
- 去重数组：`[...new Set(arr)]`或`Array.from(new Set(arr))`
- 集合数组
  - 声明：`const a = new Set(arr1)`、`const b = new Set(arr2)`
  - 并集：`new Set([...a, ...b])`
  - 交集：`new Set([...a].filter(v => b.has(v)))`
  - 差集：`new Set([...a].filter(v => !b.has(v)))`
- 映射集合
  - 声明：`let set = new Set(arr)`
  - 映射：`set = new Set([...set].map(v => v * 2))`或`set = new Set(Array.from(set, v => v * 2))`

> 重点难点

- 遍历顺序：插入顺序
- 没有键只有值，可认为键和值两值相等
- 添加多个`NaN`时，只会存在一个`NaN`
- 添加相同的对象时，会认为是不同的对象
- 添加值时不会发生类型转换(`5 !== "5"`)
- `keys()`和`values()`的行为完全一致，`entries()`返回的遍历器同时包括键和值且两值相等

##### WeakSet

- 定义：和 Set 结构类似，成员值只能是对象
- 声明：`const set = new WeakSet(arr)`
- 入参：具有`Iterator接口`的数据结构
- 属性
  - **constructor**：构造函数，返回 WeakSet
- 方法
  - **add()**：添加值，返回实例
  - **delete()**：删除值，返回布尔值
  - **has()**：检查值，返回布尔值

> 应用场景

- 储存 DOM 节点：DOM 节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏
- 临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在`WeakSet结构`中的引用就会自动消

> 重点难点

- 成员都是`弱引用`，垃圾回收机制不考虑`WeakSet结构`对此成员的引用
- 成员不适合引用，它会随时消失，因此 ES6 规定`WeakSet结构不可遍历`
- 其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于`WeakSet结构`中

### Map

##### Map

- 定义：类似于对象的数据结构，成员键可以是任何类型的值
- 声明：`const set = new Map(arr)`
- 入参：具有`Iterator接口`且每个成员都是一个双元素数组的数据结构
- 属性
  - **constructor**：构造函数，返回 Map
  - **size**：返回实例成员总数
- 方法
  - **get()**：返回键值对
  - **set()**：添加键值对，返回实例
  - **delete()**：删除键值对，返回布尔值
  - **has()**：检查键值对，返回布尔值
  - **clear()**：清除所有成员
  - **keys()**：返回以键为遍历器的对象
  - **values()**：返回以值为遍历器的对象
  - **entries()**：返回以键和值为遍历器的对象
  - **forEach()**：使用回调函数遍历每个成员

> 重点难点

- 遍历顺序：插入顺序
- 对同一个键多次赋值，后面的值将覆盖前面的值
- 对同一个对象的引用，被视为一个键
- 对同样值的两个实例，被视为两个键
- 键跟内存地址绑定，只要内存地址不一样就视为两个键
- 添加多个以`NaN`作为键时，只会存在一个以`NaN`作为键的值
- `Object结构`提供`字符串—值`的对应，`Map结构`提供`值—值`的对应

##### WeakMap

- 定义：和 Map 结构类似，成员键只能是对象
- 声明：`const set = new WeakMap(arr)`
- 入参：具有`Iterator接口`且每个成员都是一个双元素数组的数据结构
- 属性
  - **constructor**：构造函数，返回 WeakMap
- 方法
  - **get()**：返回键值对
  - **set()**：添加键值对，返回实例
  - **delete()**：删除键值对，返回布尔值
  - **has()**：检查键值对，返回布尔值

> 应用场景

- 储存 DOM 节点：DOM 节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏
- 部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏

> 重点难点

- 成员键都是`弱引用`，垃圾回收机制不考虑`WeakMap结构`对此成员键的引用
- 成员键不适合引用，它会随时消失，因此 ES6 规定`WeakMap结构不可遍历`
- 其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于`WeakMap结构`中
- 一旦不再需要，成员会自动消失，不用手动删除引用
- 弱引用的`只是键而不是值`，值依然是正常引用
- 即使在外部消除了成员键的引用，内部的成员值依然存在
