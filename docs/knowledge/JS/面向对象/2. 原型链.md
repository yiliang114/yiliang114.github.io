---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 如何理解原型？如何理解原型链？

当我们创建一个对象时 `let obj = { age: 25 }`，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？

当我们在浏览器中打印 `obj` 时你会发现，在 `obj` 上居然还有一个 `__proto__` 属性，那么看来之前的疑问就和这个属性有关系了。

其实每个 JS 对象都有 `__proto__` 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 `[[prototype]]` 来实现的一个东西。

讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 `__proto__` 里面有什么吧。

![](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/1671d15f45fcedea.jpg)

![](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/1671d2c5a6bcccc4.jpg)

看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 `obj` 来说，可以通过 `__proto__` 找到一个原型对象，在该对象中定义了很多函数让我们来使用。

在上面的图中我们还可以发现一个 `constructor` 属性，也就是构造函数

![](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/1671d329ec98ec0b.jpg)

打开 `constructor` 属性我们又可以发现其中还有一个 `prototype` 属性，并且这个属性对应的值和先前我们在 `__proto__` 中看到的一模一样。所以我们又可以得出一个结论：原型的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型，但是并不是所有函数都具有这个属性，`Function.prototype.bind()` 就没有这个属性。

其实原型就是那么简单，接下来我们再来看一张图，相信这张图能让你彻底明白原型和原型链

![](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/1671d387e4189ec8.jpg)

看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 `__proto__` 的方式连接了起来。为什么 `obj` 可以访问到 `valueOf` 函数，就是因为 `obj` 通过原型链找到了 `valueOf` 函数。

对于这一小节的知识点，总结起来就是以下几点：

- `Object` 是所有对象的爸爸，所有对象都可以通过 `__proto__` 找到它
- `Function` 是所有函数的爸爸，所有函数都可以通过 `__proto__` 找到它
- 函数的 `prototype` 是一个对象
- 对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链

并不是所有函数都有 `prototype` 属性，然后引申出原型链的概念，提出如何使用原型实现继承，继而可以引申出 ES6 中的 `class` 实现继承。

我们知道在 es6 之前，js 没有类和继承的概念，js 是通过原型来实现继承的。

在 js 中一个构造函数默认自带有一个 prototype 属性，这个的属性值是一个对象，同时这个 prototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数，同时每一个实例都有一个 `__proto__` 属性指向这个 prototype 对象，我们可以将这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有则会继续向上查找这个 prototype 对象是否有这个方法，刚刚我们说到 prototype 是一个对象，
那么也即是说这个是一个对象的实例，那么这个对象同样也会有一个 `__proto__` 属性指向对象的 prototype 对象。

- JavaScript 的所有对象中都包含了一个 `__proto__` 内部属性，这个属性所对应的就是该对象的原型
- JavaScript 的函数对象，除了原型 `__proto__` 之外，还预置了 prototype 属性
- 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 `__proto__`。

- 原型特点：

  - JavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变

1.  原型对象也是普通的对象，是对象一个自带隐式的 **proto** 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
2.  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链

- 每个对象都会在其内部初始化一个属性，就是 prototype(原型)，当我们访问一个对象的属性时
- 如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念
- 关系：`instance.constructor.prototype = instance.__proto__`
- 特点：

  - JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

- 当我们需要一个属性的时，Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的
- 就会查找他的 Prototype 对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象

### 原型

![prototype](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-042625.png)

每个函数都有 `prototype` 属性，除了 `Function.prototype.bind()`，该属性指向原型。

每个对象都有 `__proto__` 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 `[[prototype]]`，但是 `[[prototype]]` 是内部属性，我们并不能访问到，所以使用 `_proto_` 来访问。

对象可以通过 `__proto__` 来寻找不属于该对象的属性，`__proto__` 将对象连接起来组成了原型链。

### 原型链

js 第对象都有一个[[prototype]]的属性，他指向它的原型对象，原型对象也有一个[[prototype]]的属性，以此循环，最终指向 null,原型链是由原型对象组成，每个对象都有 proto 属性，指向了创建该对象的构造函数的原型，proto 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。

- 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 Object.prototype，如还是没找到，则输出 undefined；
- 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。

- 当一个对象调用的属性/方法自身不存在时，就会去自己 `__proto__` 关联的前辈 prototype 对象上去找
- 如果没找到，就会去该 prototype 原型 `__proto__` 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”

例子

```js
function SuperType() {
  this.name = 'li';
}
const instance = new SuperType();
console.log(instance.__proto__ === SuperType.prototype); //true
console.log(SuperType.prototype.__proto__ === Object.prototype); //true
console.log(Object.prototype.__proto__ === null); //true
console.log(instance.constructor === SuperType); //true instance没有实例属性，会想原型对象上寻找
console.log(SuperType.prototype.constructor === SuperType); //true
console.log(Object.getPrototypeOf(instance) === SuperType.prototype); //true
console.log(SuperType.prototype.isPrototypeOf(instance)); //true
```

几乎所有的 js 对象都是位于原型链顶端的 Object 实例

- 只有构造函数才有 prototype 属性
- 构造函数的 prototype，默认情况下就是一个 new Object()还额外添加了一个 constructor 属性
- 除了 Object.prototype 这个对象，其他所有的对象都会有**proto**属性（函数也是对象）

任何一个实例对象通过原型链可以找到它对应的原型对象，原型对象上面的实例和方法都是实例所共享的。

一个对象在查找以一个方法或属性时，他会先在自己的对象上去找，找不到时，他会沿着原型链依次向上查找。

注意： 函数才有 prototype，实例对象只有有**proto**， 而函数有的**proto**是因为函数是 Function 的实例对象

**原型链的基本原理**：任何一个**实例**，通过原型链，找到它上面的**原型**，该原型对象中的方法和属性，可以被所有的原型实例共享。

> `Object`是原型链的顶端。

- 原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：

```js
//给Foo的原型添加 say 函数
Foo.prototype.say = function() {
  console.log('');
};
```

**原型链的关键**：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。

### Javascript 作用链域?

- 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节
- 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找
- 直至全局函数，这种组织形式就是作用域链

### javascript 里面的继承怎么实现，如何避免原型链上面的对象共享

用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的 extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量

### 判断对象是哪个类的直接实例

使用`对象.construcor`直接可判断

### 原型、构造函数、实例，以及原型链

![](http://img.smyhvae.com/20180306_1540.png)

> PS：任何一个函数，如果在前面加了`new`，那就是构造函数。

### 原型、构造函数、实例三者之间的关系

![](http://img.smyhvae.com/20180306_2107.png)

1. 构造函数通过 `new` 生成实例
2. 构造函数也是函数，构造函数的`prototype`指向原型。（所有的函数有`prototype`属性，但实例没有 `prototype`属性）
3. 原型对象中有 `constructor`，指向该原型的构造函数。

> 上面的三行，代码演示：

```js
var Foo = function(name) {
  this.name = name;
};

var fn = new Foo('smyhvae');
```

> 上面的代码中，`Foo.prototype.constructor === Foo`的结果是`true`：

![](http://img.smyhvae.com/20180306_2120.png)

4. 实例的`__proto__`指向原型。也就是说，`Foo.__proto__ === M.prototype`。

> 声明：所有的**引用类型**（数组、对象、函数）都有`__proto__`这个属性。

`Foo.__proto__ === Function.prototype`的结果为 true，说明`Foo`这个普通的函数，是`Function`构造函数的一个实例。

### 原型链是什么？

### 原型是什么

JavaScript 中对象有一个特殊的[[Prototype]]内置属性，其实就是对其他对象的引用。

### 原型链是什么

如果要访问对象中并不存在的一个属性，[[Get]]操作就会查找对象内部的[[Prototype]]关联的对象。这个关联关系实际上定了一条“原型链”，在属性查找时会对它进行遍历。

### 介绍一下你所了解的作用域链,作用域链的尽头是什么，为什么？

当前作用域没有定义的变量，叫做“自由变量”。函数体中没有定义的变量，会去函数定义时的父级作用域寻找该变量。作用域链其实就是自由变量的查找。
函数和全局作用域。Jq 所有的变量都定义在一个大的函数里。作用域链就是一层一层向父层寻找没有定义的变量。
作用域链的终点是全局对象 window

### 原型链

原型对象也是普通的对象，是对象一个自带隐式的 **proto** 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链。原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。原型链的终点是 Object.prototype

### Zepto 或其他框架中如何使用原型链

```js
function Elem(id) {
  // body...
  this.elem = document.getElementById(id);
}

Elem.prototype.html = function(val) {
  var elem = this.elem;
  if (val) {
    elem.innerHTML = val;
    return this;
  } else {
    return elem.innerHTML;
  }
};

Elem.prototype.on = function(type, fn) {
  var elem = this.elem;
  elem.addEventListener(type, fn);
  return this;
};

var div1 = new Elem('div1');
div1.html('<p>hello</p>').on('click', function() {
  alert('clicked');
});
```

### 介绍一下你所了解的作用域链,作用域链的尽头是什么,为什么?

### Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？

`hasOwnProperty`

javaScript 中 hasOwnProperty 函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。

使用方法：
`object.hasOwnProperty(proName)`
其中参数 object 是必选项。一个对象的实例。
proName 是必选项。一个属性名称的字符串值。

如果 object 具有指定名称的属性，那么 JavaScript 中 hasOwnProperty 函数方法返回 true，反之则返回 false。

### 内容

- js 中的函数 zd 也是对象 (即 (function(){}) instanceof Object == true)
- 所有的对象都有自己的构筑函数
- 所有的函数都能当作构筑函数, 每个函数都有一个 prototype 属性
- 每个对象都有一个隐藏的 o.**proto**属性指内向它的构筑函数的 prototype
- 于是所有的函数的原型都是 Function.prototype (即 (function(){}).**proto** === Function.prototype)
- 访问一个对象的属性时, 如果从这个对象里找不到, 就从 obj.**proto**里找, 再找不到就继续从 obj.**proto**.**proto**里找, 最终会容到达 Object.prototype

### 何为作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，
也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。函数的作用域在函数定义的时候就决定
