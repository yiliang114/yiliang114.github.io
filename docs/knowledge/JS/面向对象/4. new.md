---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### new 原理

- 创建一个新对象。
- 这个新对象会被执行[[原型]]连接。
- 将构造函数的作用域赋值给新对象，即 this 指向这个新对象.
- 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。
  字面量创建对象，不会调用 Object 构造函数, 简洁且性能更好;
  new Object() 方式创建对象本质上是方法调用，涉及到在 proto 链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式。
  通过对象字面量定义对象时，不会调用 Object 构造函数

模拟 new 实现：

```js
function Foo(name, age) {
  this.name = name;
  this.age = age;
}

var nar = new Foo('tom', 18);
console.log(nar.name);
function OBK() {
  var obj = new Object(), //从Object.prototype上克隆一个对象
    Constructor = [].shift.call(arguments); //取得外部传入的构造器

  var F = function() {};
  F.prototype = Constructor.prototype;
  obj = new F(); //指向正确的原型

  var ret = Constructor.apply(obj, arguments); //借用外部传入的构造器给obj设置属性

  return typeof ret === 'object' ? ret : obj; //确保构造器总是返回一个对象
}
var bar = OBK(Foo, 'jim', 15);
console.log(bar.age);
```

### new

new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？

在调用 `new` 的过程中会发生以上四件事情：

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 返回新对象

根据以上几个过程，我们也可以试着来自己实现一个 `new`

```
function create() {
  let obj = {}
  let Con = [].shift.call(arguments)
  obj.__proto__ = Con.prototype
  let result = Con.apply(obj, arguments)
  return result instanceof Object ? result : obj
}
```

以下是对实现的分析：

- 创建一个空对象
- 获取构造函数
- 设置空对象的原型
- 绑定 `this` 并执行构造函数
- 确保返回值为对象

对于对象来说，其实都是通过 `new` 产生的，无论是 `function Foo()` 还是 `let a = { b : 1 }` 。

对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。

```
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 }
// 这个字面量内部也是使用了 new Object()
```

### new

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 返回新对象

在调用 `new` 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 `new`

```js
function create() {
  // 创建一个空的对象
  let obj = new Object();
  // 获得构造函数
  let Con = [].shift.call(arguments);
  // 链接到原型
  obj.__proto__ = Con.prototype;
  // 绑定 this，执行构造函数
  let result = Con.apply(obj, arguments);
  // 确保 new 出来的是个对象
  return typeof result === 'object' ? result : obj;
}
```

对于实例对象来说，都是通过 `new` 产生的，无论是 `function Foo()` 还是 `let a = { b : 1 }` 。

对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。

```js
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 };
// 这个字面量内部也是使用了 new Object()
```

对于 `new` 来说，还需要注意下运算符优先级。

```js
function Foo() {
  return this;
}
Foo.getName = function() {
  console.log('1');
};
Foo.prototype.getName = function() {
  console.log('2');
};

new Foo.getName(); // -> 1
new Foo().getName(); // -> 2
```

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-042626.png)

从上图可以看出，`new Foo()` 的优先级大于 `new Foo` ，所以对于上述代码来说可以这样划分执行顺序

```js
new (Foo.getName())();
new Foo().getName();
```

对于第一个函数来说，先执行了 `Foo.getName()` ，所以结果为 1；对于后者来说，先执行 `new Foo()` 产生了一个实例，然后通过原型链找到了 `Foo` 上的 `getName` 函数，所以结果为 2。

### new 操作符具体干了什么呢?

1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型
2. 属性和方法被加入到 this 引用的对象中
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this

```js
var obj = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
```

> 当`new Foo()`时发生了什么：

- 创建一个**新的空对象实例**。
- 将此空对象的隐式原型指向其构造函数的显示原型。
- 执行构造函数（传入相应的参数，如果没有参数就不用传），同时 `this` 指向这个新实例。
- 如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。

### 构造函数，new 时发生了什么？

```js
var obj = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
```

1. 创建一个新的对象 obj;
2. 将这个空对象的**proto**成员指向了 Base 函数对象 prototype 成员对象
3. Base 函数对象的 this 指针替换成 obj, 相当于执行了 Base.call(obj);
4. 如果构造函数显示的返回一个对象，那么则这个实例为这个返回的对象。 否则返回这个新创建的对象

### 如何实现一个 new

```js
function _new(fn, ...arg) {
  const obj = Object.create(fn.prototype);
  const ret = fn.apply(obj, arg);
  return ret instanceof Object ? ret : obj;
}
```

### 构造函数，new 时发生了什么？

```js
var obj = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
```

1. 创建一个新的对象 obj;
2. 将这个空对象的**proto**成员指向了 Base 函数对象 prototype 成员对象
3. Base 函数对象的 this 指针替换成 obj, 相当于执行了 Base.call(obj);
4. 如果构造函数显示的返回一个对象，那么则这个实例为这个返回的对象。 否则返回这个新创建的对象
