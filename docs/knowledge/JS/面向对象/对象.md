---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 请指出 JavaScript 宿主对象和原生对象的区别？

原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如`String`、`Math`、`RegExp`、`Object`、`Function`等等。
宿主对象是指 DOM 和 BOM，宿主对象是由运行时环境（浏览器或 Node）提供，比如`window`、`XMLHTTPRequest`等等。

### 介绍 js 有哪些内置对象？

- Object 是 JavaScript 中所有对象的父对象
- 数据封装类对象：Object、Array、Boolean、Number 和 String
- 其他对象：Function、Arguments、Math、Date、RegExp、Error
- ES6 新增对象：Symbol、Map、Set、Promises、Proxy、Reflect

### 数组负数下标

数组对象其实是一个特殊对象，他拥有普通对象的全部特性，所以不止负索引，小数索引，连字符串索引都是可以的，只是用这些索引向数组添加属性时，数组的 length 不会增加罢了，而只有当索引是正整数或其对应数字串时，length 才会增加，仅此而已。

### Object.create(null) 与 普通的 {} 的区别？

为什么 vue 有些地方需要使用前者，有些地方不需要？

### 为什么 0.1 + 0.2 != 0.3

因为 JS 采用 IEEE 754 双精度版本（64 位），并且只要采用 IEEE 754 的语言都有该问题。

我们都知道计算机是通过二进制来存储东西的，那么 `0.1` 在二进制中会表示为

```js
// (0011) 表示循环
0.1 = 2 ^ (-4 * 1.10011(0011));
```

我们可以发现，`0.1` 在二进制中是无限循环的一些数字，其实不只是 `0.1`，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。

IEEE 754 双精度版本（64 位）将 64 位分为了三段

- 第一位用来表示符号
- 接下去的 11 位用来表示指数
- 其他的位数用来表示有效位，也就是用二进制表示 `0.1` 中的 `10011(0011)`

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 `0.1` 不再是 `0.1` 了，而是变成了 `0.100000000000000002`

```js
0.100000000000000002 === 0.1; // true
```

那么同样的，`0.2` 在二进制也是无限循环的，被裁剪后也失去了精度变成了 `0.200000000000000002`

```js
0.200000000000000002 === 0.2; // true
```

所以这两者相加不等于 `0.3` 而是 `0.300000000000000004`

```js
0.1 + 0.2 === 0.30000000000000004; // true
```

那么可能你又会有一个疑问，既然 `0.1` 不是 `0.1`，那为什么 `console.log(0.1)` 却是正确的呢？

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

```js
console.log(0.100000000000000002); // 0.1
```

那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题

```js
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3; // true
```

### in 和 hasOwnProperty 区别

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果在实例中添加一个与原型中属性同名的属性，则该属性会屏蔽原型中的那个属性。添加的同名属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为`null`，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。

```js
function Person() {}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true

person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true

delete person1.name;
console.log(person1.name); // "Nicholas"
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true
```

`in`操作符只要通过对象能访问到属性就返回`true`。`hasOwnProperty()`只在属性存在于实例中时才返回`true`。

使用`delete`操作符则可以完全删除实例属性，从而让我们能巩固重新访问原型中的属性。

```js
function Person() {
  this.name = 'koewas';
}

// Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
delete person1.name;
console.log(person1.name); // undefined
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // false
```

上面这段代码的`name`为实例属性，不属于原型。但却不是私有属性，能被实例访问。

### hasOwnProperty

是不是对象自身下面的属性

```js
// hasOwnProperty(): 看是不是对象自身下面的属性
var arr = [];
arr.num = 10;
Array.prototype.num2 = 20; //这样写表示所有的数组对象都有了num2这个属性

alert(arr.hasOwnProperty('num')); //true 说明num这个属性只属于arr的,是arr独有的
alert(arr.hasOwnProperty('num2')); //false 因为所有的数组对象都拥有了num2,而不仅仅是arr,所以是false

var a1 = new Aaa();
alert(a1.hasOwnProperty == Object.prototype.hasOwnProperty); //true
```

### for in 与 hasOwnProperty 结合使用

与 in 操作符相比，for in 在循环对象的属性时也会遍历原型链，for in 不会读取不可枚举属性，如数组的 length 属性。

```js
// 扩展 Object.prototype
Object.prototype.bar = 1;
var foo = { moo: 2 };
for (var i in foo) {
  console.log(i); // 输出 bar 和 moo
}
```

我们不可能改变 for in 循环的行为，当需要对循环体内某些属性进行过滤时，可以利用 Object.prototype 的 hasOwnProperty 方法来完成。提示：因为 for in 循环总是遍历整个原型链，所以当遍历多继承的对象时效率较低。使用 hasOwnProperty 进行过滤

```js
// 仍旧针对上例的foo对象
for (var i in foo) {
  if (foo.hasOwnProperty(i)) {
    console.log(i);
  }
}
```

例子中因为使用了 hasOwnProperty，最终输出 moo；如果忽略 hasOwnProperty ，代码将会输出非预期结果，因为本地原型（如 Object.prototype）已经被扩展了。

Prototype 框架就是扩展 Javascript 原始对象的一个类库，并被广泛使用，其缺点也很明显，当框架引入后，如果不使用 hasOwnProperty 进行过滤判断，输出结果保证不是你想要的。

最佳实践

推荐在 for in 时，总是使用 hasOwnProperty 进行判断，没人可以保证运行的代码环境是否被污染过。

hasOwnProperty
为了检查某个对象是否拥有不在原型链上的自定义属性，就有必要用到 hasOwnProperty 方法，任何一个对象都具有该方法，它继承自 Object.prototype。

提示：我们无法完全检测某个属性是否是 undefined，因为属性有可能存在，但其值为 undefined。hasOwnProperty 是 Javascript 中唯一一个可以处理对象属性而不遍历原型链的方法。

```js
// 扩展 Object.prototype
Object.prototype.bar = 1;
var foo = { goo: undefined };

foo.bar; // 1
'bar' in foo; // true

foo.hasOwnProperty('bar'); // false
foo.hasOwnProperty('goo'); // true
```

只有 hasOwnProperty 给出了正确的预期结果，当遍历对象的属性时这是很有必要的，没有其它办法来排除定义在对象原型链上的属性。

hasOwnProperty 作为属性

Javascript 并没有保护 hasOwnProperty 为关键字或保留字，因此，如果某个对象拥有同名的属性，就有必要利用扩展的 hasOwnProperty 来获取正确结果。

```js
var foo = {
hasOwnProperty: function() {
return false;
},
bar: 'Here be dragons'
};
foo.hasOwnProperty('bar'); // 总是返回 false
// 使用另一个 hasOwnProperty 并将 this 设置为 foo 来调用它
{}.hasOwnProperty.call(foo, 'bar'); // true
```

### 分析下列输出结果

```js
// example 1
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 2
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 3
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

对象键名的转换：

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。
  example 1，c 的键名转换成字符串将 b 键覆盖输出 c
  example 2，任何一个 Symbol 类型的值都是不相等的，所以 b 键和 c 键都不会被覆盖，输出 b
  example 3，对象都会被转换为字符串 [object Object]，因此 c 键会覆盖 b 键，输出 c

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

### Object.defineProperty()

- 对象属性描述符
- configurable
- enumerable
- 数据描述符
  - value
  - writable
- 存取描述符
  - get
  - set

#### defineProperty, hasOwnProperty, propertyIsEnumerable 都是做什么用的？

Object.defineProperty(obj, prop, descriptor)用来给对象定义属性,有 value,writable,configurable,enumerable,set/get 等.defineProperty 用于检查某一属性是不是存在于对象本身，继承来的父亲的属性不算．propertyIsEnumerable 用来检测某一属性是否可遍历，也就是能不能用 for..in 循环来取到

### Object.is() 与原来的比较操作符 ===、== 的区别？

- == 相等运算符，比较时会自动进行数据类型转换
- === 严格相等运算符，比较时不进行隐式类型转换
- Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理

```
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

### JS 中有那些内置对象

- 数据封装类对象
  - String、Array、Object、Boolean、Number
- 其他对象
  - Math、Date、RegExp、Error、Function、Arguments
- ES6 新增对象
  - Promise、Map、Set、Symbol、Proxy、Reflect

### js 对象校验是否含有多个键值

```js
['id', 'name', 'check'].every(key => Object.keys(project).includes(key));
```

### Set、Map、WeakSet 和 WeakMap 的区别？

#### Set

- 表示有没有，成员的值都是唯一的，没有重复的值
- 可以接受一个数组（或可迭代的数据结构）作为参数
- 注：两个对象总是不相等的

属性：

- Set.prototype.constructor：构造函数，默认就是 Set 函数。
- Set.prototype.size：返回 Set 实例的成员总数。

方法：

- add(value)：添加某个值，返回 Set 结构本身。
  - `s.add(1).add(2).add(2)`;
- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
- has(value)：返回一个布尔值，表示该值是否为 Set 的成员。
- clear()：清除所有成员，没有返回值。

遍历方法

- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回键值对的遍历器
- forEach()：使用回调函数遍历每个成员

#### WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但与 Set 有几个区别：

- WeakSet 的成员**只能是对象**，而不能是其他类型的值
- WeakSet 中的对象都是弱引用
  - 如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存
  - 垃圾回收机制依赖引用计数，如果一个值的引用次数不为 0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
- WeakSet 不可遍历
  - 由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的
- WeakSet 结构中没有 clear 方法。

#### Map

类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，**各种类型的值（包括对象）都可以当作 Map 的键**。

遍历方法
Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- keys()：返回键名的遍历器。
- values()：返回键值的遍历器。
- entries()：返回所有成员的遍历器。
- forEach()：遍历 Map 的所有成员。

#### WeakMap

WeakMap 的设计目的在于: 有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用，而一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放被引用对象占用的内存。

基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。

一个典型应用**场景**是，在网页的 DOM 元素上添加数据，就可以使用 WeakMap 结构。当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。

### 你使用什么语句遍历对象的属性和数组的元素？

**对象：**

- `for`循环：`for (var property in obj) { console.log(property); }`。但是，这还会遍历到它的继承属性，在使用之前，你需要加入`obj.hasOwnProperty(property)`检查。
- `Object.keys()`：`Object.keys(obj).forEach(function (property) { ... })`。`Object.keys()`方法会返回一个由一个给定对象的自身可枚举属性组成的数组。
- `Object.getOwnPropertyNames()`：`Object.getOwnPropertyNames(obj).forEach(function (property) { ... })`。`Object.getOwnPropertyNames()`方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。

**数组：**

- `for` loops：`for (var i = 0; i < arr.length; i++)`。这里的常见错误是`var`是函数作用域而不是块级作用域，大多数时候你想要迭代变量在块级作用域中。ES2015 引入了具有块级作用域的`let`，建议使用它。所以就变成了：`for (let i = 0; i < arr.length; i++)`。
- `forEach`：`arr.forEach(function (el, index) { ... })`。这个语句结构有时会更精简，因为如果你所需要的只是数组元素，你不必使用`index`。还有`every`和`some`方法可以让你提前终止遍历。

大多数情况下，我更喜欢`.forEach`方法，但这取决于你想要做什么。`for`循环有更强的灵活性，比如使用`break`提前终止循环，或者递增步数大于一。

### 如何防止在 JavaScript 中修改对象 ?

```js
var employee = {
  name: 'yiliang',
};

//Freeze the object
Object.freeze(employee);

// Seal the object
Object.seal(employee);

console.log(Object.isExtensible(employee)); // false
console.log(Object.isSealed(employee)); // true
console.log(Object.isFrozen(employee)); // true

employee.name = 'xyz'; // fails silently unless in strict mode
employee.age = 30; // fails silently unless in strict mode
delete employee.name; // fails silently unless it's in strict mode
```

#### Object.freeze 和 Object.seal 的区别

Object.preventExtension：禁止对象添加新属性并保留已有属性;
Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;
Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。

### 合并两个对象

```js
const merge = (toObj, fromObj) => Object.assign(toObj, fromObj);
```

```js
function merge(toObj, fromObj) {
  // Make sure both of the parameter is an object
  if (typeof toObj === 'object' && typeof fromObj === 'object') {
    for (var pro in fromObj) {
      // Assign only own properties not inherited properties
      if (fromObj.hasOwnProperty(pro)) {
        // Assign property and value
        toObj[pro] = fromObj[pro];
      }
    }
  } else {
    throw 'Merge function can apply only on object';
  }
}
```

```js
/**
 * 判断对象是否为函数，如果当前运行环境对可调用对象（如正则表达式）
 * 的typeof返回'function'，采用通用方法，否则采用优化方法
 *
 * @param {Any} arg 需要检测是否为函数的对象
 * @return {boolean} 如果参数是函数，返回true，否则false
 */
function isFunction(arg) {
  if (arg) {
    if (typeof /./ !== 'function') {
      return typeof arg === 'function';
    } else {
      return Object.prototype.toString.call(arg) === '[object Function]';
    }
  } // end if
  return false;
}
```

### 检查一个对象是否含有某一个键.

```js
var person = {
  name: 'yiliang',
  age: 24,
};

console.log('name' in person); // checking own property print true
console.log('salary' in person); // checking undefined property print false

console.log(person.hasOwnProperty('toString')); // print false
console.log(person.hasOwnProperty('name')); // print true
console.log(person.hasOwnProperty('salary')); // print false
```

### JavaScript 中的不可枚举属性是什么?如何创建一个不可枚举属性?

Object can have properties that don't show up when you iterate through object using for...in loop or using Object.keys() to get an array of property names. This properties is know as non-enumerable properties.

Let say we have following object

```js
var person = {
  name: 'John',
};
person.salary = '10000$';
person['country'] = 'USA';

console.log(Object.keys(person)); // ['name', 'salary', 'country']
```

As we know that person object properties `name`, `salary` ,`country` are enumerable hence it's shown up when we called Object.keys(person).

To create a non-enumerable property we have to use **Object.defineProperty()**. This is a special method for creating non-enumerable property in JavaScript.

```js
var person = {
  name: 'John',
};
person.salary = '10000$';
person['country'] = 'USA';

// Create non-enumerable property
Object.defineProperty(person, 'phoneNo', {
  value: '8888888888',
  enumerable: false,
});

Object.keys(person); // ['name', 'salary', 'country']
```

In the example above `phoneNo` property didn't show up because we made it non-enumerable by setting **enumerable:false**

Now let's try to change value of `phoneNo`

```js
person.phoneNo = '7777777777';
```

Changing non-enumerable property value will return error in `strict mode`. In non-strict mode it won't through any error but it won't change the value of phoneNo.

**Bonus**

**Object.defineProperty()** is also let you create read-only properties as we saw above, we are not able to modify phoneNo value of a person object.

### name 的值是多少？

```js
function A(name) {
  this.name = name || 'Tom';
  this.msg = "use 'this.' set in function";
}

function B() {}
B.prototype = A;

var b = new B();

console.log(b.name);
console.log(b.msg);
// A
// undefined
```

#### 分析

`b.name`返回 `A`，是因为`b`上面没有`name`属性，他就会沿着原型链向上查找，然而 `b.__proto__` 为`函数A`，每一个函数都有一个属性为 name，其值是函数的名字。

```js
function abc() {
  /* 这是一个名为'abc'的函数 */
}
abc.name; // -> 'abc'
```

`b.msg` 为什么是`undefined`哪？ 因为`b.__proto__` 是 `函数A`，那怎么修改才能拿到`msg`哪？

```js
B.prototype = new A();
```

修改后的输出：

```
Tom
VM731:12 use 'this.' set in function
```

### 其他

```js
var length = 10;
function fn() {
  alert(this.length);
}
var obj = {
  length: 5,
  method: function() {
    fn();
  },
};
obj.method(); //？
```

```js
function Foo() {
  this.value = 42;
}
Foo.prototype = {
  method: function() {
    return true;
  },
};
function Bar() {
  var value = 1;
  return {
    method: function() {
      return value;
    },
  };
}
Foo.prototype = new Bar();
console.log(Foo.prototype.constructor); //
console.log(Foo.prototype instanceof Bar); //
var test = new Foo();
console.log(test instanceof Foo); //
console.log(test instanceof Bar); //
console.log(test.method()); //
```

```js
function SINA() {
  return 1;
}
var SINA;
console.log(typeof SINA); //
```

```js
var sinaNews = {
  name: 'sinNewsName',
  test: function() {
    console.log('this.name:', this.name, '//');
  },
};
setTimeout(sinaNews.test, 500); //
```

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // ?
foo(); // ?
```

```js
a = 1;
b = 1;
a == b; // ?
name1 = { a: 1 };
name2 = { a: 1 };
name1 == name2; //?
```

```js
let obj = {
  fun1: () => {
    console.log('111');
  },
  fun2: () => {
    this.fun1();
  },
};

obj.fun2();
```

```js
let arr = [1, 2, 3, 4];
let it1 = arr[Symbol.iterator](); // 遍历器接口
let res = it1.next();
console.log(res);
```

结果是：

```js
{
  done: false,
  value: 1
}
```

### 异步

```js
// Qunar.com
setTimeout(() => {
  console.log(1);
}, 0);

new (resolve => {
  console.log(2);
  resolve();
  console.log(3);
}).then(() => {
  console.log(4);
});

console.log(5);
```

结果是：
2 3 5 4 1

```js
var p1 = new (function(resolve, reject) {
  setTimeout(() =>reject(new Error('p1 中failure')) , 3000);
})

var p2 = new (function(resolve, reject){
  setTimeout(() => resolve(p1), 1000);
});
var p3 = new (function(resolve, reject) {
  resolve(2);
});
var p4 = new (function(resolve, reject) {
  reject(new Error('error  in  p4'));
});

1. p3.then(re => console.log(re)); //?
2. p4.catch(error => console.log(error));//?

3. p2.then(null,re => console.log(re));//?
4. p2.catch(re => console.log(re));//?
```

打印的顺序是：2， "error in p4 "这是立即打印出来的。

而 3S 后会打印出两个'p1 中 failure'。

如果 3 直接写成`p2.then(re => console.log(re));`是会报错，说没有捕捉到错误。

```js
var p1 = .resolve(1)
var p2 = new (resolve => {
  setTimeout(() => resolve(2), 100)
})
var v3 = 3
var p4 = new ((resolve, reject) => {
  setTimeout(() => reject('oops'), 10)
})

var p5 = new (resolve => {
  setTimeout(() => resolve(5), 0)
})
var p1 = .resolve(1)
.race([v3, p1, p2, p4, p5]).then(val => console.log(val)) //?
.race([p1, v3, p2, p4, p5]).then(val => console.log(val)) // ?
.race([p1, p2, p4, p5]).then(val => console.log(val)) // ?
.race([p2, p4, p5]).then(val => console.log(val)) //?
```

打印顺序是：6 3 1 1 5

```js
function 1() {
  return new (function(resolve, reject) {
    for (let i = 0; i < 2; i++) {
      console.log('111')
    }
    resolve(true)
  })
}
function 2() {
  return new (function(resolve, reject) {
    for (let i = 0; i < 2; i++) {
      console.log('222')
    }
    resolve(true)
  })
}

setTimeout(function() {
  console.log('333')
}, 0) // 这是是会执行的。考察的是异步执行，js的任务队列

.all([1(), 2()]).then(function() {
  console.log('All Done!')
})
```

> 结果是：

```js
'111';
'111';
'222';
'222';
'All Done!';
'333';
```

### 赋值

#### 函数名与变量名同名

```js
var foo = 1;
function bar() {
  foo = 10;
  return;
  function foo() {}
}
bar();
alert(foo);
```

- 1
- 10
- Function
- undefined
- Error

答案：1，function 的定义会提前到当前作用域之前，所以等同于：

```js
var foo = 1;
function bar() {
  function foo() {}
  foo = 10;
  return;
}
bar();
alert(foo);
```

所以，在 foo=10 的时候，foo 是有定义的，属于局部变量，影响不到外层的 foo。

```js
function bar() {
  return foo;
  foo = 10;
  function foo() {}
  var foo = 11;
}
alert(typeof bar());
```

- number
- function
- undefined
- Error

答案：function，与上题类似，等同于：

```js
function bar() {
  function foo() {}
  return foo;
  foo = 10;
  var foo = 11;
}
alert(typeof bar());
```

在 return 之后声明和赋值的 foo 都无效，所以返回了 function。

补充，这个解答有问题：

> @尤里卡 Eureka：JS 中 function 声明和 var 声明都会被提前，最终得到结果为 function，是因为*名称解析顺序-Name Resolution Order*(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~

#### 数组长度

```js
var arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr.foo = 'c';
alert(arr.length);
```

答案：2，数组的原型是 Object，所以可以像其他类型一样附加属性，不影响其固有性质。

#### arguments

```js
function foo(a) {
  arguments[0] = 2;
  alert(a);
}
foo(1);
```

答案：2，实参可以直接从 arguments 数组中修改。
