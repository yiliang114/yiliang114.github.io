---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 数组负数下标

数组对象其实是一个特殊对象，他拥有普通对象的全部特性，所以不止负索引，小数索引，连字符串索引都是可以的，只是用这些索引向数组添加属性时，数组的 length 不会增加罢了，而只有当索引是正整数或其对应数字串时，length 才会增加，仅此而已。

### Object.create(null) 与 普通的 {} 的区别？

为什么 vue 有些地方需要使用前者，有些地方不需要？

### 为什么 0.1 + 0.2 != 0.3

因为 JS 采用 IEEE 754 双精度版本（64 位），并且只要采用 IEEE 754 的语言都有该问题。

我们都知道计算机是通过二进制来存储东西的，那么 `0.1` 在二进制中会表示为

```js
// (0011) 表示循环
0.1 = 2 ^ (-4 * 1.10011(0011));
```

我们可以发现，`0.1` 在二进制中是无限循环的一些数字，其实不只是 `0.1`，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。

IEEE 754 双精度版本（64 位）将 64 位分为了三段

- 第一位用来表示符号
- 接下去的 11 位用来表示指数
- 其他的位数用来表示有效位，也就是用二进制表示 `0.1` 中的 `10011(0011)`

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 `0.1` 不再是 `0.1` 了，而是变成了 `0.100000000000000002`

```js
0.100000000000000002 === 0.1; // true
```

那么同样的，`0.2` 在二进制也是无限循环的，被裁剪后也失去了精度变成了 `0.200000000000000002`

```js
0.200000000000000002 === 0.2; // true
```

所以这两者相加不等于 `0.3` 而是 `0.300000000000000004`

```js
0.1 + 0.2 === 0.30000000000000004; // true
```

那么可能你又会有一个疑问，既然 `0.1` 不是 `0.1`，那为什么 `console.log(0.1)` 却是正确的呢？

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

```js
console.log(0.100000000000000002); // 0.1
```

那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题

```js
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3; // true
```

### in 和 hasOwnProperty 区别

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果在实例中添加一个与原型中属性同名的属性，则该属性会屏蔽原型中的那个属性。添加的同名属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为`null`，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。

```js
function Person() {}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true

person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true

delete person1.name;
console.log(person1.name); // "Nicholas"
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true
```

`in`操作符只要通过对象能访问到属性就返回`true`。`hasOwnProperty()`只在属性存在于实例中时才返回`true`。

使用`delete`操作符则可以完全删除实例属性，从而让我们能巩固重新访问原型中的属性。

```js
function Person() {
  this.name = 'koewas';
}

// Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
delete person1.name;
console.log(person1.name); // undefined
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // false
```

上面这段代码的`name`为实例属性，不属于原型。但却不是私有属性，能被实例访问。

### hasOwnProperty

是不是对象自身下面的属性

```js
// hasOwnProperty(): 看是不是对象自身下面的属性
var arr = [];
arr.num = 10;
Array.prototype.num2 = 20; //这样写表示所有的数组对象都有了num2这个属性

alert(arr.hasOwnProperty('num')); //true 说明num这个属性只属于arr的,是arr独有的
alert(arr.hasOwnProperty('num2')); //false 因为所有的数组对象都拥有了num2,而不仅仅是arr,所以是false

var a1 = new Aaa();
alert(a1.hasOwnProperty == Object.prototype.hasOwnProperty); //true
```

### 对象是否存在该属性

```js
'name' in Person;
```

in 缺陷---属性是继承来的时候,仍然返回 true
最好使用 hasOwnProperty()

```js
Person.hasOwnProperty('name');
```

### for in 与 hasOwnProperty 结合使用

与 in 操作符相比，for in 在循环对象的属性时也会遍历原型链，for in 不会读取不可枚举属性，如数组的 length 属性。

```js
for (var i in foo) {
  if (foo.hasOwnProperty(i)) {
    console.log(i);
  }
}
```

推荐在 for in 时，总是使用 hasOwnProperty 进行判断，没人可以保证运行的代码环境是否被污染过。

### 分析下列输出结果

```js
// example 1
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 2
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 3
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

对象键名的转换：

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。
  example 1，c 的键名转换成字符串将 b 键覆盖输出 c
  example 2，任何一个 Symbol 类型的值都是不相等的，所以 b 键和 c 键都不会被覆盖，输出 b
  example 3，对象都会被转换为字符串 [object Object]，因此 c 键会覆盖 b 键，输出 c

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

### Object.defineProperty()

- 对象属性描述符
- configurable
- enumerable
- 数据描述符
  - value
  - writable
- 存取描述符
  - get
  - set

#### defineProperty, hasOwnProperty, propertyIsEnumerable 都是做什么用的？

Object.defineProperty(obj, prop, descriptor)用来给对象定义属性,有 value,writable,configurable,enumerable,set/get 等.defineProperty 用于检查某一属性是不是存在于对象本身，继承来的父亲的属性不算．propertyIsEnumerable 用来检测某一属性是否可遍历，也就是能不能用 for..in 循环来取到

### Object.is() 与原来的比较操作符 ===、== 的区别？

- == 相等运算符，比较时会自动进行数据类型转换
- === 严格相等运算符，比较时不进行隐式类型转换
- Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理

```
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

### 如何防止在 JavaScript 中修改对象 ?

```js
var employee = {
  name: 'yiliang',
};

//Freeze the object
Object.freeze(employee);

// Seal the object
Object.seal(employee);

console.log(Object.isExtensible(employee)); // false
console.log(Object.isSealed(employee)); // true
console.log(Object.isFrozen(employee)); // true

employee.name = 'xyz'; // fails silently unless in strict mode
employee.age = 30; // fails silently unless in strict mode
delete employee.name; // fails silently unless it's in strict mode
```

#### Object.freeze 和 Object.seal 的区别

Object.preventExtension：禁止对象添加新属性并保留已有属性;
Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;
Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。

### 合并两个对象

```js
const merge = (toObj, fromObj) => Object.assign(toObj, fromObj);
```

```js
function merge(toObj, fromObj) {
  // Make sure both of the parameter is an object
  if (typeof toObj === 'object' && typeof fromObj === 'object') {
    for (var pro in fromObj) {
      // Assign only own properties not inherited properties
      if (fromObj.hasOwnProperty(pro)) {
        // Assign property and value
        toObj[pro] = fromObj[pro];
      }
    }
  } else {
    throw 'Merge function can apply only on object';
  }
}
```

### 检查一个对象是否含有某一个键

```js
var person = {
  name: 'yiliang',
  age: 24,
};

console.log('name' in person); // checking own property print true
console.log('salary' in person); // checking undefined property print false

console.log(person.hasOwnProperty('toString')); // print false
console.log(person.hasOwnProperty('name')); // print true
console.log(person.hasOwnProperty('salary')); // print false
```

### name 的值是多少？

```js
function A(name) {
  this.name = name || 'Tom';
  this.msg = "use 'this.' set in function";
}

function B() {}
B.prototype = A;

var b = new B();

console.log(b.name);
console.log(b.msg);
// A
// undefined
```

#### 分析

`b.name`返回 `A`，是因为`b`上面没有`name`属性，他就会沿着原型链向上查找，然而 `b.__proto__` 为`函数A`，每一个函数都有一个属性为 name，其值是函数的名字。

```js
function abc() {
  /* 这是一个名为'abc'的函数 */
}
abc.name; // -> 'abc'
```

`b.msg` 为什么是`undefined`哪？ 因为`b.__proto__` 是 `函数A`，那怎么修改才能拿到`msg`哪？

```js
B.prototype = new A();
```

修改后的输出：

```
Tom
VM731:12 use 'this.' set in function
```

### 其他

```js
var sinaNews = {
  name: 'sinNewsName',
  test: function() {
    console.log('this.name:', this.name, '//');
  },
};
setTimeout(sinaNews.test, 500); //
```

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // ?
foo(); // ?
```

```js
let arr = [1, 2, 3, 4];
let it1 = arr[Symbol.iterator](); // 遍历器接口
let res = it1.next();
console.log(res);
```

结果是：

```js
{
  done: false,
  value: 1
}
```

### 异步

```js
// Qunar.com
setTimeout(() => {
  console.log(1);
}, 0);

new (resolve => {
  console.log(2);
  resolve();
  console.log(3);
}).then(() => {
  console.log(4);
});

console.log(5);
```

结果是：
2 3 5 4 1

```js
var p1 = new (function(resolve, reject) {
  setTimeout(() =>reject(new Error('p1 中failure')) , 3000);
})

var p2 = new (function(resolve, reject){
  setTimeout(() => resolve(p1), 1000);
});
var p3 = new (function(resolve, reject) {
  resolve(2);
});
var p4 = new (function(resolve, reject) {
  reject(new Error('error  in  p4'));
});

1. p3.then(re => console.log(re)); //?
2. p4.catch(error => console.log(error));//?

3. p2.then(null,re => console.log(re));//?
4. p2.catch(re => console.log(re));//?
```

打印的顺序是：2， "error in p4 "这是立即打印出来的。

而 3S 后会打印出两个'p1 中 failure'。

如果 3 直接写成`p2.then(re => console.log(re));`是会报错，说没有捕捉到错误。

```js
var p1 = .resolve(1)
var p2 = new (resolve => {
  setTimeout(() => resolve(2), 100)
})
var v3 = 3
var p4 = new ((resolve, reject) => {
  setTimeout(() => reject('oops'), 10)
})

var p5 = new (resolve => {
  setTimeout(() => resolve(5), 0)
})
var p1 = .resolve(1)
.race([v3, p1, p2, p4, p5]).then(val => console.log(val)) //?
.race([p1, v3, p2, p4, p5]).then(val => console.log(val)) // ?
.race([p1, p2, p4, p5]).then(val => console.log(val)) // ?
.race([p2, p4, p5]).then(val => console.log(val)) //?
```

打印顺序是：6 3 1 1 5

```js
function 1() {
  return new (function(resolve, reject) {
    for (let i = 0; i < 2; i++) {
      console.log('111')
    }
    resolve(true)
  })
}
function 2() {
  return new (function(resolve, reject) {
    for (let i = 0; i < 2; i++) {
      console.log('222')
    }
    resolve(true)
  })
}

setTimeout(function() {
  console.log('333')
}, 0) // 这是是会执行的。考察的是异步执行，js的任务队列

.all([1(), 2()]).then(function() {
  console.log('All Done!')
})
```

> 结果是：

```js
'111';
'111';
'222';
'222';
'All Done!';
'333';
```

### 赋值

#### 函数名与变量名同名

```js
var foo = 1;
function bar() {
  foo = 10;
  return;
  function foo() {}
}
bar();
alert(foo);
```

- 1
- 10
- Function
- undefined
- Error

答案：1，function 的定义会提前到当前作用域之前，所以等同于：

```js
var foo = 1;
function bar() {
  function foo() {}
  foo = 10;
  return;
}
bar();
alert(foo);
```

所以，在 foo=10 的时候，foo 是有定义的，属于局部变量，影响不到外层的 foo。

```js
function bar() {
  return foo;
  foo = 10;
  function foo() {}
  var foo = 11;
}
alert(typeof bar());
```

- number
- function
- undefined
- Error

答案：function，与上题类似，等同于：

```js
function bar() {
  function foo() {}
  return foo;
  foo = 10;
  var foo = 11;
}
alert(typeof bar());
```

在 return 之后声明和赋值的 foo 都无效，所以返回了 function。

补充，这个解答有问题：

> @尤里卡 Eureka：JS 中 function 声明和 var 声明都会被提前，最终得到结果为 function，是因为*名称解析顺序-Name Resolution Order*(http://t.cn/8kcIRts导致的function声明优先级大于var声明，而不是由return语句退出导致最后的结果~

```js
function SINA() {
  return 1;
}
var SINA;
console.log(typeof SINA); // function
```

#### 数组长度

```js
var arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr.foo = 'c';
alert(arr.length);
```

答案：2，数组的原型是 Object，所以可以像其他类型一样附加属性，不影响其固有性质。

#### arguments

```js
function foo(a) {
  arguments[0] = 2;
  alert(a);
}
foo(1);
```

答案：2，实参可以直接从 arguments 数组中修改。

### 如何判断一个对象是空的？

- 第一种： `const isEmptyObject = obj => Object.getOwnPropertyNames(obj).length === 0`
- 第二种： `Object.keys(obj).length == 0`
