---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

## 类与继承

继承的本质就是原型链

### JS 继承的 6 种方法

1.  原型链继承
2.  借用构造函数继承
3.  组合继承(原型+借用构造)
4.  寄生式继承
5.  寄生组合式继承
6.  class 继承

#### 1. 原型链继承

基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法, 实现的本质是重写原型对象

```js
function SuperType() {
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.property;
};

function SubType() {
  this.subProperty = false;
}

//继承了 SuperType

SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
  return this.subProperty;
};

let instance = new SubType();

console.log(instance.getSuperValue()); //true
```

存在的问题：

1. 通过原型来实现继承时，原型实际上会变成另一个类型的实例，
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数

`new Child.__proto__ === new Parent()`的结果为`true`

**分析：**

- 这种继承方式，**Child 可以继承 Parent 的原型**，但有个缺点：

> 缺点是：**如果修改 child1 实例的 name 属性，child2 实例中的 name 属性也会跟着改变**。

如下：

![](http://img.smyhvae.com/20180307_1123.png)

> 上面的代码中， `child1`修改了`arr`属性，却发现，`child2`的`arr`属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。

> 造成这种缺点的原因是：`child1`和`child2`共用原型。即：`chi1d1.__proto__ === child2__proto__`是严格相同。而 arr 方法是在 Parent 的实例上（即 Child 实例的原型）的。

#### 2. 借用构造函数继承

在子类型构造函数的内部调用超类型构造函数

```js
function SuperType(){
    this.colors = ["red", "blue", "green”];
}

function SubType(){
		//继承了 SuperType
    SuperType.call(this);

}

let instance1 = new SubType();

instance1.colors.push("black");

console.log(instance1.colors);    //"red,blue,green,black"

let instance2 = new SubType();

console.log(instance2.colors);    //"red,blue,green”
```

以上继承的方式核心是在子类的构造函数中通过 `Parent.call(this)` 继承父类的属性，然后改变子类的原型为 `new Parent()` 来继承父类的函数。

这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。

```js
function Parent1() {
  this.name = 'parent1 的属性';
}

function Child1() {
  Parent1.call(this); //【重要】此处用 call 或 apply 都行：改变 this 的指向
  this.type = 'child1 的属性';
}

console.log(new Child1());
```

> 【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了`Parent1.call(this);`，意思是：**让 Parent 的构造函数在 child 的构造函数中执行**。发生的变化是：**改变 this 的指向**，parent 的实例 --> 改为指向 child 的实例。导致 parent 的实例的属性挂在到了 child 的实例上，这就实现了继承。

打印结果：

![](http://img.smyhvae.com/20180307_1015.png)

> 上方结果表明：`child`先有了 `parent` 实例的属性（继承得以实现），再有了`child` 实例的属性。

**分析**：

> 这种方式，虽然改变了 `this` 的指向，但是，**Child1 无法继承 `Parent1` 的原型**。也就是说，如果我给 `Parent1` 的原型增加一个方法：

```js
Parent1.prototype.say = function() {};
```

> 上面这个方法是无法被 `Child1` 继承的。如下：

![](http://img.smyhvae.com/20180307_1030.png)

#### 3. 组合继承(原型+借用构造)

使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承

```js
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

SuperType.prototype.sayName = function() {
  console.log(this.name);
};

function SubType(name, age) {
  //继承属性
  SuperType.call(this, name);
  this.age = age;
}

//继承方法

SubType.prototype = new SuperType();

SubType.prototype.constructor = SubType;

SubType.prototype.sayAge = function() {
  console.log(this.age);
};

let instance1 = new SubType('Nicholas', 29);

instance1.colors.push('black');

console.log(instance1.colors); //"red,blue,green,black"

instance1.sayName(); //"Nicholas";

instance1.sayAge(); //29

let instance2 = new SubType('Greg', 27);

console.log(instance2.colors); //"red,blue,green"

instance2.sayName(); //"Greg";

instance2.sayAge(); //27
```

- 这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。
- 这种方式的缺点是：让父亲`Parent`的构造方法执行了两次。
- `ES6`中的继承方式，一带而过即可，重点是要掌握`ES5`中的继承。

#### 4. 寄生式继承:

创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象

```js
function createAnother(original) {
  let clone = object(original); //通过调用函数创建一个新对象
  clone.sayHi = function() {
    ////以某种方式来增强这个对象
    console.log('hi');
  };
  return clone; //返回这个对象
}
let person = {
  name: 'Nicholas',
  friends: ['Shelby', 'Court', 'Van'],
};
let anotherPerson = createAnother(person);
anotherPerson.sayHi(); //"hi"
```

#### 5. 寄生组合式继承:

即通过借用构造函数来继承属性，通过原型链的混成形式来继承

```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
SuperType.prototype.sayName = function() {
  console.log(this.name);
};
function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}
function inheritPrototype(subType, superType) {
  let prototype = object(superType.prototype); //创建对象
  prototype.constructor = subType; //增强对象
  subType.prototype = prototype; //指定对象
}

inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function() {
  console.log(this.age);
};
let p1 = new SubType('Jack', 20);
p1.colors.push('white');
console.log(p1.colors); //["red", "blue", "green", "white"]
let p2 = new SubType('Mark', 18);
console.log(p2.age); //18
```

这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。

```js
function Parent(value) {
  this.val = value;
}
Parent.prototype.getValue = function() {
  console.log(this.val);
};

function Child(value) {
  Parent.call(this, value);
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

const child = new Child(1);

child.getValue(); // 1
child instanceof Parent; // true
```

以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。

![img](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/1672afb8dfa21361.jpg)

#### 6. Class 继承

以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 `class` 去实现继承，并且实现起来很简单

```js
class Parent {
  constructor(value) {
    this.val = value;
  }
  getValue() {
    console.log(this.val);
  }
}
class Child extends Parent {
  constructor(value) {
    super(value);
    this.val = value;
  }
}
let child = new Child(1);
child.getValue(); // 1
child instanceof Parent; // true
```

`class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，因为这段代码可以看成 `Parent.call(this, value)`。

当然了，之前也说了在 JS 中并不存在类，`class` 的本质就是函数。

#### YUI 式继承

由原型链继承延伸而来，避免了实例对象的 prototype 指向同一个对象的缺点（Dog.prototype 包含一内部指针指向 Animal.prototype，同时 Dog 的所有实例也都包含一内部指针指向 Dog.prototype，那么任何对 Dog 实例上继承自 Animal 的属性或方法的修改，都会反映到 Dog.prototype）。让 Dog 跳过 Animal，直接继承 Animal.prototype，这样省去执行和创建 Animal 实例，提高了效率。利用一个空对象作为媒介，空对象几乎不占用内存，示例如下：

```js
function Animal() {}
Animal.prototype.feeling = 'happy';

function extend(Child, Parent) {
  var F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
}

extend(Dog, Animal);

var dog = new Dog('二狗', '哈士奇');
print(dog.feeling); // happy
```

#### 拷贝继承（浅拷贝和深拷贝）

把父对象的属性和方法，全部拷贝给子对象，也能实现继承。

① 浅复制

```js
function Animal() {}
Animal.prototype.feeling = 'happy';

function extend(Child, Parent) {
  var p = Parent.prototype;
  var c = Child.prototype;
  for (var i in p) {
    c[i] = p[i];
  }
}

extend(Dog, Animal);

var dog = new Dog('二狗', '哈士奇');
print(dog.feeling); // happy
```

但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能, 比如在上例中适当位置添加如下代码会发现：

```js
Animal.prototype.colors = ['red', 'green', 'blue'];

Dog.colors.push('black');

print(Dog.colors); // red,green,blue,black
print(Animal.colors); // red,green,blue,black
```

当然，这也是 jquery 早期实现继承的方式。

② 深复制

```js
function Animal() {}
Animal.prototype.feeling = 'happy';

function deepCopy(Child, Parent) {
  var p = Parent.prototype;
  var c = Child.prototype;
  for (var i in p) {
    if (typeof p[i] === 'object') {
      c[i] = p[i].constructor === Array ? [] : {};
      deepCopy(p[i], c[i]);
    } else {
      c[i] = p[i];
    }
  }
}

deepCopy(Dog, Animal);

var dog = new Dog('二狗', '哈士奇');
print(dog.feeling); // happy
```

深拷贝，能够实现真正意义上的数组和对象的拷贝。这时，在子对象上修改属性（引用类型），就不会影响到父元素了。这也是目前 jquery 使用的继承方式。

### Class、extends 是什么，有什么作用？

`ES6` 的`class`可以看作只是一个`ES5`生成实例对象的构造函数的语法糖。它参考了`java`语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。`Class`类可以通过`extends`实现继承。它和 ES5 构造函数的不同点

类的内部定义的所有方法，都是不可枚举的

```js
///ES5
function ES5Fun(x, y) {
  this.x = x;
  this.y = y;
}
ES5Fun.prototype.toString = function() {
  return '(' + this.x + ', ' + this.y + ')';
};
let p = new ES5Fun(1, 3);
p.toString();
Object.keys(ES5Fun.prototype); //['toString']

//ES6
class ES6Fun {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}

Object.keys(ES6Fun.prototype); //[]
```

- `ES6`的`class`类必须用`new`命令操作，而`ES5`的构造函数不用`new`也可以执行。
- `ES6`的`class`类不存在变量提升，必须先定义`class`之后才能实例化，不像`ES5`中可以将构造函数写在实例化之后。
- `ES5` 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面。`ES6` 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。

### 借用构造函数法

在构造函数中 使用`Parent.call(this)`的方法继承父类属性。

原理： 将子类的 this 使用父类的构造函数跑一遍

缺点： Parent 原型链上的属性和方法并不会被子类继承

```js
function Parent() {
  this.name = 'parent';
}

function Child() {
  Parent.call(this);
  this.type = 'child';
}
```

### 原型链实现继承

原理：把子类的 prototype（原型对象）直接设置为父类的实例

缺点：因为子类只进行一次原型更改，所以子类的所有实例保存的是同一个父类的值。
当子类对象上进行值修改时，如果是修改的原始类型的值，那么会在实例上新建这样一个值；
但如果是引用类型的话，他就会去修改子类上唯一一个父类实例里面的这个引用类型，这会影响所有子类实例

```js
function Parent() {
  this.name = 'parent';
  this.arr = [1, 2, 3];
}

function Child() {
  this.type = 'child';
}

Child.prototype = new Parent();
let c1 = new Child();
let c2 = new Child();
c1.__proto__ === c2.__proto__;
```

### 组合继承方式

组合构造函数中使用 call 继承和原型链继承。

原理： 子类构造函数中使用`Parent.call(this);`的方式可以继承写在父类构造函数中 this 上绑定的各属性和方法；
使用`Child.prototype = new Parent()`的方式可以继承挂在在父类原型上的各属性和方法

缺点： 父类构造函数在子类构造函数中执行了一次，在子类绑定原型时又执行了一次

```js
function Parent() {
  this.name = 'parent';
  this.arr = [1, 2, 3];
}

function Child() {
  Parent.call(this);
  this.type = 'child';
}

Child.prototype = new Parent();
```

### 组合继承方式 优化 1：

因为这时父类构造函数的方法已经被执行过了，只需要关心原型链上的属性和方法了

```js
Child.prototype = Parent.prototype;
```

缺点：

- 因为原型上有一个属性为`constructor`，此时直接使用父类的 prototype 的话那么会导致 实例的 constructor 为 Parent，即不能区分这个实例对象是 Child 的实例还是父类的实例对象。
- 子类不可直接在 prototype 上添加属性和方法，因为会影响父类的原型

注意：这个时候 instanseof 是可以判断出实例为 Child 的实例的，因为 instanceof 的原理是沿着对象的**proto**判断是否有一个原型是等于该构造函数的原型的。这里把 Child 的原型直接设置为了父类的原型，那么: 实例.**proto** === Child.prototype === Child.prototype

### 组合继承方式 优化 2 - 添加中间对象【最通用版本】：

```js
function Parent() {
  this.name = 'parent';
  this.arr = [1, 2, 3];
}

function Child() {
  Parent.call(this);
  this.type = 'child';
}

Child.prototype = Object.create(Parent.prototype); //提供__proto__
Child.prototype.constrctor = Child;
```

Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的\*\*proto

### 封装一个原生的继承方法

```js
/
 * 继承
 * @param Parent
 * @param Child
 */
function extendsClass(Parent, Child) {
  function F() {}
  F.prototype = Parent.prototype
  Child.prototype = new F()
  Child.prototype.constrctor = Child
  return Child
}
```

### [ES5/ES6 的继承除了写法以外还有什么区别？](https://github.com/Advanced-Frontend/Daily-Note-Question/issues/20)

- class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
- class 声明内部会启用严格模式。
- class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
- class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
- 必须使用 new 调用 class。
- class 内部无法重写类名。

### 原型继承

A:原型继承的基础是原型链查找。
原型链查找基本概念：

1. 每一个函数 F 都有一个原型对象（prototype）F.prototype
2. 每一个函数都可以通过 new 关键字化身成为一个类构造函数，new F 会产生一个对象 O
3. 在调用对象的某个属性或者方法，比如 http://O.xxx 的时候，会首先查找对象自身是否有这个方法或者属性，如果没找到就会去对象的构造函数的原型对象中查找（注意有两个定语），也就是查找 O 的构造函数 F 的原型对象 http://F.prototype.xxx
4. F.prototype 也是一个对象，查找 http://F.prototype.xxx 的时候会重复第 3 步的过程

### JavaScript 如何实现一个类，怎么实例化这个类？

- 构造函数法（this + prototype） -- 用 new 关键字 生成实例对象
  - 缺点：用到了 this 和 prototype，编写复杂，可读性差

```js
function Mobile(name, price) {
  this.name = name;
  this.price = price;
}
Mobile.prototype.sell = function() {
  console.log(this.name + '，售价 $' + this.price);
};
let iPhone7 = new Mobile('iPhone7', 1000);
iPhone7.sell();
```

- Object.create 法 -- 用 Object.create() 生成实例对象
- 缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据

```js
let Person = {
  firstname: 'Mark',
  lastname: 'Yun',
  age: 25,
  introduce: function() {
    console.log('I am ' + Person.firstname + ' ' + Person.lastname);
  },
};

let person = Object.create(Person);
person.introduce();

// Object.create 要求 IE9+，低版本浏览器可以自行部署：
if (!Object.create) {
  Object.create = function(o) {
    function F() {}
    F.prototype = o;
    return new F();
  };
}
```

- 极简主义法（消除 this 和 prototype） -- 调用 createNew() 得到实例对象
  - 优点：容易理解，结构清晰优雅，符合传统的"面向对象编程"的构造

```js
let Cat = {
  age: 3, // 共享数据 -- 定义在类对象内，createNew() 外
  createNew: function() {
    let cat = {};
    // let cat = Animal.createNew(); // 继承 Animal 类
    cat.name = '小咪';
    let sound = '喵喵喵'; // 私有属性--定义在 createNew() 内，输出对象外
    cat.makeSound = function() {
      console.log(sound); // 暴露私有属性
    };
    cat.changeAge = function(num) {
      Cat.age = num; // 修改共享数据
    };
    return cat; // 输出对象
  },
};

let cat = Cat.createNew();
cat.makeSound();
```

- ES6 语法糖 class -- 用 new 关键字 生成实例对象

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}

let point = new Point(2, 3);
```

### Javascript 如何实现继承？

- 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上

```js
function Cat(name, color) {
  Animal.apply(this, arguments);
  this.name = name;
  this.color = color;
}
```

- 实例继承：将子对象的 prototype 指向父对象的一个实例

```js
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
```

- 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象

```js
function extend(Child, Parent) {
  let p = Parent.prototype;
  let c = Child.prototype;
  for (let i in p) {
    c[i] = p[i];
  }
  c.uber = p;
}
```

- 原型继承：将子对象的 prototype 指向父对象的 prototype

```js
function extend(Child, Parent) {
  let F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
  Child.uber = Parent.prototype;
}
```

- ES6 语法糖 extends：class ColorPoint extends Point {}

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

### Javascript 如何实现继承？

- 构造继承
- 原型继承
- 实例继承
- 拷贝继承

- 原型 prototype 机制或 apply 和 call 方法去实现较简单，建议使用构造函数与原型混合方式

```
 function Parent(){
        this.name = 'wang';
    }

    function Child(){
        this.age = 28;
    }
    Child.prototype = new Parent();//继承了Parent，通过原型

    let demo = new Child();
    console.log(demo.age);
    console.log(demo.name);//得到被继承的属性
  }
```

### js 继承方式及其优缺点

- 原型链继承的缺点

  - 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。

- 借用构造函数（类式继承）

  - 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承

- 组合式继承
  - 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。

### 请解释原型继承（prototypal inheritance）的工作原理。

这是一个非常常见的 JavaScript 问题。所有 JS 对象都有一个`prototype`属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。这种行为是在模拟经典的继承，[但是与其说是继承，不如说是委托（delegation）](https://davidwalsh.name/javascript-objects)。

### 继承

在 ES5 中，我们可以使用如下方式解决继承的问题

```js
function Super() {}
Super.prototype.getNumber = function() {
  return 1;
};

function Sub() {}
let s = new Sub();
Sub.prototype = Object.create(Super.prototype, {
  constructor: {
    value: Sub,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});
```

以上继承实现思路就是将子类的原型设置为父类的原型

在 ES6 中，我们可以通过 `class` 语法轻松解决这个问题

```js
class MyDate extends Date {
  test() {
    return this.getTime();
  }
}
let myDate = new MyDate();
myDate.test();
```

但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。

如果你使用编译过得代码调用 `myDate.test()` 你会惊奇地发现出现了报错

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-042628.png)

因为在 JS 底层有限制，如果不是由 `Date` 构造出来的实例的话，是不能调用 `Date` 里的函数的。所以这也侧面的说明了：**ES6 中的 `class` 继承与 ES5 中的一般继承写法是不同的**。

既然底层限制了实例必须由 `Date` 构造出来，那么我们可以改变下思路实现继承

```js
function MyData() {}
MyData.prototype.test = function() {
  return this.getTime();
};
let d = new Date();
Object.setPrototypeOf(d, MyData.prototype);
Object.setPrototypeOf(MyData.prototype, Date.prototype);
```

以上继承实现思路：**先创建父类实例** => 改变实例原先的 `_proto__` 转而连接到子类的 `prototype` => 子类的 `prototype` 的 `__proto__` 改为父类的 `prototype`。

通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。

### ES5/ES6 的继承除了写法以外还有什么区别？

es6 继承

```js
class A extends B {}
A.__proto__ === B; //继承属性
A.prototype.__proto__ == B.prototype; //继承方法
```

es5 继承

```js
function Super() {}
function Sub() {}

Sub.prototype = new Super();
Sub.prototype.constructor = Sub;

let sub = new Sub();

Sub.__proto__ === Function.prototype;
```

ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。
ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。

#### 扩展：ES6 中的 class 和 ES5 的类有什么区别？

1. ES6 class 内部所有定义的方法都是不可枚举的;
2. ES6 class 必须使用 new 调用;
3. ES6 class 不存在变量提升;
4. ES6 class 默认即是严格模式;
5. ES6 class 子类必须在父类的构造函数中调用 super()，这样才有 this 对象;ES5 中类继承的关系是相反的，先有子类的 this，然后用父类的方法应用在 this 上。

### 现在有一个函数 A 和函数 B，请你实现 B 继承 A

```
// 方式1
function B(){}
function A(){}
B.prototype = new A();

// 方式2
function A(){}
function B(){
  A.call(this);
}

// 方式3
function B(){}
function A(){}
B.prototype = new A();

function B(){
  A.call(this);
}
```

### 刚刚你在 Q5 中说的几种继承的方式，分别说说他们的优缺点

方式 1：简单易懂，但是无法实现多继承，父类新增原型方法/原型属性，子类都能访问到
方式 2：可以实现多继承，但是只能继承父类的实例属性和方法，不能继承原型属性/方法
方式 3：可以继承实例属性/方法，也可以继承原型属性/方法，但是示例了两个 A 的构造函数

### 实现一个动物类，动物有吃饭，吼叫的方法，有眼睛、鼻子属性。动物类有子类：猫和狗。猫的叫声是喵喵，猫的眼睛是蓝色的，狗得见叫声是汪汪，狗的眼睛是棕色的。请用代码实现上述描述。

```js
class Animal {
  constructor(eye, nose) {
    this.eye = eye;
    this.nose = nose;
  }
  eat() {
    return '吃东西';
  }

  howl() {
    return '吼叫';
  }
}

class Dog extends Animal {
  constructor() {
    super('棕色');
  }

  howl() {
    return 'wangwang';
  }
}

class Cat extends Animal {
  constructor() {
    super('blue');
  }

  hol = () => '喵喵喵';
}

let dog = new Dog();
console.log(dog.eye, dog.howl());

let cat = new Cat();
console.log(cat.eye, cat.howl());
```

### 指出下列代码的区别：

```js
function Person() {}
var person = Person();
var person = new Person();
```

A: 第一行是定义了一个函数 Person()；第二行代码是执行函数 Person() 并将其返回值复制给变量 person，如果 Person() 是一个构造器函数的话，新的对象将不会被创建，并且 this 将被绑定到全局对象上；第三行代码是用构造函数 Person() 构造一个实例对象 person。

### ES5/ES6 的继承除了写法以外还有什么区别？

1. `class` 声明会提升，但不会初始化赋值。`Foo` 进入暂时性死区，类似于 `let`、`const` 声明变量。

```js
const bar = new Bar(); // it's ok
function Bar() {
  this.bar = 42;
}

const foo = new Foo(); // ReferenceError: Foo is not defined
class Foo {
  constructor() {
    this.foo = 42;
  }
}
```

1. `class` 声明内部会启用严格模式。

```js
// 引用一个未声明的变量
function Bar() {
  baz = 42; // it's ok
}
const bar = new Bar();

class Foo {
  constructor() {
    fol = 42; // ReferenceError: fol is not defined
  }
}
const foo = new Foo();
```

1. `class` 的所有方法（包括静态方法和实例方法）都是不可枚举的。

```js
// 引用一个未声明的变量
function Bar() {
  this.bar = 42;
}
Bar.answer = function() {
  return 42;
};
Bar.prototype.print = function() {
  console.log(this.bar);
};
const barKeys = Object.keys(Bar); // ['answer']
const barProtoKeys = Object.keys(Bar.prototype); // ['print']

class Foo {
  constructor() {
    this.foo = 42;
  }
  static answer() {
    return 42;
  }
  print() {
    console.log(this.foo);
  }
}
const fooKeys = Object.keys(Foo); // []
const fooProtoKeys = Object.keys(Foo.prototype); // []
```

1. `class` 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有`[[construct]]`，不能使用 `new` 来调用。

```js
function Bar() {
  this.bar = 42;
}
Bar.prototype.print = function() {
  console.log(this.bar);
};

const bar = new Bar();
const barPrint = new bar.print(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
  print() {
    console.log(this.foo);
  }
}
const foo = new Foo();
const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor
```

1. 必须使用 `new` 调用 `class`。

```js
function Bar() {
  this.bar = 42;
}
const bar = Bar(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
}
const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new'
```

1. `class` 内部无法重写类名。

```js
function Bar() {
  Bar = 'Baz'; // it's ok
  this.bar = 42;
}
const bar = new Bar();
// Bar: 'Baz'
// bar: Bar {bar: 42}

class Foo {
  constructor() {
    this.foo = 42;
    Foo = 'Fol'; // TypeError: Assignment to constant variable
  }
}
const foo = new Foo();
Foo = 'Fol'; // it's ok
```
