---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 介绍模块化发展历程

可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、`<script type="module">` 这几个角度考虑。

模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。

**IIFE**： 使用自执行函数来编写模块化，特点：**在一个单独的函数作用域中执行代码，避免变量冲突**。

```js
(function() {
  return {
    data: [],
  };
})();
```

**AMD**： 使用 requireJS 来编写模块化，特点：**依赖必须提前声明好**。

```js
define('./index.js', function(code) {
  // code 就是index.js 返回的内容
});
```

**CMD**： 使用 seaJS 来编写模块化，特点：**支持动态引入依赖文件**。

```js
define(function(require, exports, module) {
  var indexCode = require('./index.js');
});
```

**CommonJS**： nodejs 中自带的模块化。

```js
var fs = require('fs');
```

**UMD**：兼容 AMD，CommonJS 模块化语法。

**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。

**ES Modules**： ES6 引入的模块化，支持 import 来引入另一个 js 。

```js
import a from 'a';
```

### 模块化

在 ES6 出现之前，js 没有标准的模块化概念，这也就造成了 js 多人写作开发容易造成全局污染的情况，以前我们可能会采用立即执行函数、对象等方式来尽量减少变量这种情况，后面社区为了解决这个问题陆续提出了 AMD 规范和 CMD 规范，这里不同于 Node.js 的 CommonJS 的原因在于服务端所有的模块都是存在于硬盘中的，加载和读取几乎是不需要时间的，而浏览器端因为加载速度取决于网速，因此需要采用异步加载，AMD 规范中使用 define 来定义一个模块，使用 require 方法来加载一个模块，现在 ES6 也推出了标准的模块加载方案，通过 export 和 import 来导出和导入模块。

随着前端项目复杂性不断提高，JS 的代码量变的越来越大，必须做拆分。

使用模块化可以给我们带来以下好处

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

但如果仅是拆成几个 js 文件，然后在用`script`标签去引入这些文件又会使导致以下几个问题：

- 影响加载速度
  - JS 文件变多，加载 JS 文件数量过多导致页面加载速度编码
- 代码的引入次序
  - 使用 script 标签引入 JS 时还必须控制 JS 的顺序。在单个 JS 文件编写的时候，如果要使用其他的 JS 文件中的一些变量和函数，不能直观的知道这个变量或函数是在哪个文件定义的。
- 命名空间污染
  - JS 虽然拆开了，但实际上在浏览器运行时就像把所有文件都何在一起了一样

模块化可以解决上面的问题，但是模块化后的代码是使用`import`或`export`这样的写法来实现的，浏览器不能识别，所以需要一个打包工具。

在有 Babel 的情况下，我们可以直接使用 ES6 的模块化

```js
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}

import { a, b } from './a.js';
import XXX from './b.js';
```

实现模块化方式：

- 立即执行函数
- AMD 和 CMD
- CommonJS
- ES Module

- **AMD**：`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
- **CMD**：`seajs` 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近
- **CommonJs**：模块输出的是一个值的 `copy`，运行时加载，加载的是一个对象（`module.exports` 属性），该对象只有在脚本运行完才会生成
- **ES6 Module**：模块输出的是一个值的引用，编译时输出接口，`ES6`模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。

主要是 4 中：

- CommonJS -- node
- AMD(异步模块定义) -- require.js
- CMD(通用模块定义) -- sea.js
- ES6 模块

### 1. 立即执行函数

在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题

```js
(function(globalVariable) {
  globalVariable.test = function() {};
  // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable);
```

### 2. AMD 和 CMD

鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。

```js
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do();
  b.do();
});
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a');
  a.doSomething();
});
```

### 3. CommonJS

主要用在服务器端 node.js

`CommonJs` 是 Node 独有的规范，浏览器中使用就需要用到 `Browserify` 解析了。

```js
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;

// b.js
var module = require('./a.js');
module.a; // -> log 1
```

在上述代码中，`module.exports` 和 `exports` 很容易混淆，让我们来看看大致内部实现

```js
var module = require('./a.js');
module.a;
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
  a: 1,
};
// 基本实现
var module = {
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports;
var load = function(module) {
  // 导出的东西
  var a = 1;
  module.exports = a;
  return module.exports;
};
```

再来说说 `module.exports` 和 `exports`，用法其实是相似的，但是不能对 `exports` 直接赋值，不会有任何效果。

对于 `CommonJS` 和 ES6 中的模块化的两者区别是：

- 前者支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
- 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响

- 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- 后者会编译成 `require/exports` 来执行的

CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```
// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析

先说 `require` 吧

```
var module = require('./a.js')
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。

**Node CommonJS**:

ES6 标准发布后，module 成为标准，标准的使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，我们采用的是 CommonJS 规范，使用 require 引入模块，使用 module.exports 导出接口。

node 的 module 遵循 CommonJS 规范，requirejs 遵循 AMD，seajs 遵循 CMD，虽各有不同，但总之还是希望保持较为统一的代码风格。

```js
// b.js
// ------------ node ---------
var m = require('./a');
m.a();

// ------------ AMD or CMD -------------
define(function(require, exports, module) {
  var m = require('./a');
  m.a();
});
```

ES6 发布的 module 并没有直接采用 CommonJS，甚至连 require 都没有采用，也就是说 require 仍然只是 node 的一个私有的全局方法，module.exports 也只是 node 私有的一个全局变量属性。

###### export

```js
// a.js
export default function() {}
export function a() {}

var b = 'xxx';
export { b }; // 这是ES6的写法，实际上就是{b:b}
setTimeout(() => (b = 'ooo'), 1000);
export var c = 100;
```

###### import

import 的语法跟 require 不同，而且 import 必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。

```js
import $ from 'jquery';
import * as _ from '_';
import { a, b, c } from './a';
import { default as alias, a as a_a, b, c } from './a';
```

###### as 关键字

简单的说就是取一个别名。export 中可以用，import 中其实可以用

```js
// a.js
var a = function() {};
export { a as fun };

// b.js
import { fun as a } from './a';
a();
```

###### default 关键字

在 export 的时候，可能会用到 default，说白了，它其实是别名的语法糖：

```js
// d.js
export default function() {}

// 等效于：
function a() {}
export { a as default };
```

在 import 的时候，可以这样用：

```js
import a from './d';

// 等效于，或者说就是下面这种写法的简写，是同一个意思
import { default as a } from './d';
```

这个语法糖的好处就是 import 的时候，可以省去花括号{}。简单的说，如果 import 的时候，你发现某个变量没有花括号括起来（没有\*号），那么你在脑海中应该把它还原成有花括号的 as 语法。

所以，下面这种写法你也应该理解了吧

```js
import $, { each, map } from 'jquery';
```

`import 后面第一个$是{defalut as $}`的替代写法。

###### \* 符号

\*就是代表所有，只用在 import 中，我们看下两个例子：

```js
import * as _ from '_';
```

在意义上和 `import _ from '_';`是不同的，虽然实际上后面的使用方法是一样的。它表示的是把'*'模块中的所有接口挂载到*这个对象上，所以可以用`_.each` 调用某个接口。

另外还可以通过`*`号直接继承某一个模块的接口：

```js
export * from '_';

// 等效于：
import * as all from '_';
export all;
```

`*`符号尽可能少用，它实际上是使用所有 `export` 的接口，但是很有可能你的当前模块并不会用到所有接口，可能仅仅是一个，所以最好的建议是使用花括号，用一个加一个。

##### 用 require 还是 import？

require 的使用非常简单，它相当于 module.exports 的传送门，module.exports 后面的内容是什么，require 的结果就是什么，对象、数字、字符串、函数……再把 require 的结果赋值给某个变量，相当于把 require 和 module.exports 进行平行空间的位置重叠。

而且 require 理论上可以运用在代码的任何地方，甚至不需要赋值给某个变量之后再使用，比如：

```js
require('./a')(); // a模块是一个函数，立即执行a模块函数
var data = require('./a').data; // a模块导出的是一个对象
var a = require('./a')[0]; // a模块导出的是一个数组
```

你在使用时，完全可以忽略模块化这个概念来使用 require，仅仅把它当做一个 node 内置的全局函数，它的参数甚至可以是表达式：

```js
require(process.cwd() + '/a');
```

但是 import 则不同，它是编译时的（require 是运行时的），它必须放在文件开头，而且使用格式也是确定的，不容置疑。它不会将整个模块运行后赋值给某个变量，而是只选择 import 的接口进行编译，**这样在性能上比 require 好很多**。

从理解上，require 是赋值过程，import 是解构过程，当然，require 也可以将结果解构赋值给一组变量，但是 import 在遇到 default 时，和 require 则完全不同：`var $ = require('jquery');` 和 `import $ from 'jquery'` 是完全不同的两种概念。

上面完全没有回答“改用 require 还是 import？”这个问题，因为这个问题就目前而言，根本没法回答，因为目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require。这也是为什么在模块导出时使用 module.exports，在引入模块时使用 import 仍然起效，因为本质上，import 会被转码为 require 去执行。

### 4. ES Module

目前 js 社区有 4 种模块管理规范：AMD、CMD、CommonJS 和 EsModule。 ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：

- CommonJS 支持动态导入，也就是 require(\${path}/xx.js)，后者目前不支持，但是已有提案
- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 require/exports 来执行的

```js
// 引入模块 API
import XXX from './a.js';
import { XXX } from './a.js';
// 导出模块 API
export function a() {}
export default function() {}
```

### 说说你对 AMD CMD Commonjs 的理解

- CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数
- AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的

**模块化开发怎么做？**

- 立即执行函数,不暴露私有成员

```js
var module1 = (function() {
  var _count = 0;
  var m1 = function() {
    //...
  };
  var m2 = function() {
    //...
  };
  return {
    m1: m1,
    m2: m2,
  };
})();
```

**AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？**

- Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中

```js
// CMD
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  // 此处略去 100 行
  var b = require('./b'); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(['./a', './b'], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

**对前端模块化的认识**

- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出
- CMD 是 SeaJS 在推广过程中对模块定义的规范化产出
- AMD 是提前执行，CMD 是延迟执行
- AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的

#### 对前端模块化的认识

> AMD 是 `RequireJS` 在推广过程中对模块定义的规范化产出。
> CMD 是 `SeaJS` 在推广过程中对模块定义的规范化产出。
> `AMD` 是提前执行，`CMD` 是延迟执行。
> `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的。
> CMD 模块方式

```js
define(function(require, exports, module) {
  // 模块代码
});
```

JS 模块化的实践
require.js 的实现原理（如果使用过 webpack，进一步会问，两者打包的异同及优缺点）

项目模块的切分原则：

### AMD、CMD 的分别

CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数，是 SeaJS 在推广过程中对模块定义的规范化产出

AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的,是 RequireJS 在推广过程中对模块定义的规范化产出

- 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
- CMD 推崇依赖就近，AMD 推崇依赖前置。
- AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。

require 与 import 的区别:

- require 支持 动态导入，import 不支持，正在提案 (babel 下可支持)
- require 是 同步 导入，import 属于 异步 导入
- require 是 值拷贝，导出值变化不会影响导入值；import 指向 内存地址，导入值会随导出值而变化

CommonJS 是服务端模块的规范，Nodejs 采用了这个规范。根据 CommonJS 规范，一个单独的文件就是一个模块，每个模块都是采用一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象属性。
CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数，由于 nodejs 主要用于服务端编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不同考虑非同步加载的方式，所以 CommonJS 规范比较适用。
但是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。

### 你怎么看 AMD vs. CommonJS？

"异步模块定义"

```js
require(['math'], function(math) {
  math.add(2, 3);
});
```

它们都是实现模块体系的方式，直到 ES2015 出现之前，JavaScript 一直没有模块体系。CommonJS 是同步的，而 AMD（Asynchronous Module Definition）从全称中可以明显看出是异步的。CommonJS 的设计是为服务器端开发考虑的，而 AMD 支持异步加载模块，更适合浏览器。

我发现 AMD 的语法非常冗长，CommonJS 更接近其他语言 import 声明语句的用法习惯。大多数情况下，我认为 AMD 没有使用的必要，因为如果把所有 JavaScript 都捆绑进一个文件中，将无法得到异步加载的好处。此外，CommonJS 语法上更接近 Node 编写模块的风格，在前后端都使用 JavaScript 开发之间进行切换时，语境的切换开销较小。

我很高兴看到 ES2015 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和 Node 中完全推出，但是我们可以使用代码转换工具进行转换

### ES6 模块和 CommonJS 模块的差异？

1. ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 模块，运行时加载。
2. ES6 模块自动采用严格模式，无论模块头部是否写了 "use strict";
3. require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。
4. ES6 模块中顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。
5. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

CommonJS 中的 require/exports 和 ES6 中的 import/export 区别:

1. CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。
1. ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
1. import/export 最终都是编译为 require/exports 来执行的。
1. CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
1. export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系

### 如何实现一个 JS 的 AMD 模块加载器

AMD 是解决 JS 模块化的规范，实现这样的一个模块加载器的关键在于解决每个模块依赖的解析。首先我们需要有一个模块的入口，也就是主模块，比如我们使用
一个 use 方法作为入口，之后以数组的形式列出了主模块的依赖，这时候我们要想到的是如何解析这一个一个的依赖，也就是如何解析出一个个 js 文件的绝对地址，
我们可以制定一个规则，如默认为主模块的路径为基准，也可以像 requirejs 一样使用一个 config 方法来指定一个 baseurl 和为每一个模块指定一个 path，最后就是
模块的问题，我们需要暴露一个 define 方法来定义模块，也就是模块名，依赖以及每个模块的各自代码。其中每个模块的代码都应该在依赖加载完之后执行，这就是一个
回调函数，模块的依赖、回调函数、状态、名字、模块导出等可以看做是一个模块的属性，因此我们可以使用一个对象来保存所有的模块，然后每个模块的各个属性存放在一个对象中。
最后我们来考虑一下模块加载的问题，上面我们说到 use 方法，use 方法的逻辑就是遍历依赖，然后对每个模块进行加载，也就是解析地址然后使用插入 script，我们假设
使用 loadModule 方法来加载依赖，那么这个函数的逻辑就应该是检查我们的模块是否已经加载过来判断是否需要加载，如果这个模块还有依赖则调用 use 方法继续解析，模块依赖中我们
还没有提到的问题就是每个模块的依赖是需要被传进模块里来使用的，解决方法就是每个模块的 callback 方法执行后的返回的 export 记录下来然后使用 apply 之类的方法将这些参数传递进去。
大致就是这样子的。

### 听说过 UMD 吗？可以简要介绍一下吗？

**模块化开发怎么做？**

- 不暴露私有成员

```
var module1 = (function(){
　　　　var _count = 0;
　　　　var m1 = function(){
　　　　　　//...
　　　　};
　　　　var m2 = function(){
　　　　　　//...
　　　　};
　　　　return {
　　　　　　m1 : m1,
　　　　　　m2 : m2
　　　　};
　　})();
```

**AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？**

- Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中
- 区别：

  - 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible
  - CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

```js
// CMD
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  // 此处略去 100 行
  var b = require('./b'); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(['./a', './b'], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

### 如何在文件之间共用代码？

这取决于执行 JavaScript 的环境。

在客户端（浏览器环境）上，只要变量或函数在全局作用域（`window`）中声明，所有脚本都可以引用它们。或者，通过 RequireJS 采用异步模块定义（AMD）以获得更多模块化方法。

在服务器（Node.js）上，常用的方法是使用 CommonJS。每个文件都被视为一个模块，可以通过将它们附加到`module.exports`对象来导出变量和函数。

ES2015 定义了一个模块语法，旨在替换 AMD 和 CommonJS。 这最终将在浏览器和 Node 环境中得到支持。

### module、export、import 是什么，有什么作用？

- `module`、`export`、`import`是`ES6`用来统一前端模块化方案的设计思路和实现方案。`export`、`import`的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的`AMD/CMD`、`requireJS`、`seaJS`、`commondJS`等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，`JS`也能更加能实现大型的应用程序开发。
- `import`引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。
- `import`引入`export`导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值

### 常见问题

- a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?
- 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 `t = 111` 能否在 a 中直接打印出来?
- 如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题?

### 其他

- npm 包 的 UMD 文件是什么？ UMD 与 webpack 之类的 CommonJS 模块打包器有什么关系，是否只能用 webpack 之类的打包器进行打包？
- require 写在里面是为了清除缓存！！！

**Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？**

- 两等号判等，会在比较时进行类型转换；
- 三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回 false）；
- Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true
- Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。

图片懒加载
实现页面加载进度条
实现 extend 函数

实现拖拽功能，比如把 5 个兄弟节点中的最后一个节点拖拽到节点 1 和节点 2 之间
动画：setTimeout 何时执行，requestAnimationFrame 的优点

手写 parseInt 的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用 JS 原生的字符串转数字的 API，比如 Number()
