---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 介绍模块化发展历程

可从 IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、`<script type="module">` 这几个角度考虑。

模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。

**IIFE**： 使用自执行函数来编写模块化，特点：**在一个单独的函数作用域中执行代码，避免变量冲突**。

```js
(function() {
  return {
    data: [],
  };
})();
```

**AMD**： 使用 requireJS 来编写模块化，特点：**依赖必须提前声明好**。

```js
define('./index.js', function(code) {
  // code 就是index.js 返回的内容
});
```

**CMD**： 使用 seaJS 来编写模块化，特点：**支持动态引入依赖文件**。

```js
define(function(require, exports, module) {
  var indexCode = require('./index.js');
});
```

**CommonJS**： nodejs 中自带的模块化。

```js
var fs = require('fs');
```

**UMD**：兼容 AMD，CommonJS 模块化语法。

**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。

**ES Modules**： ES6 引入的模块化，支持 import 来引入另一个 js 。

```js
import a from 'a';
```

### 模块化

在 ES6 出现之前，js 没有标准的模块化概念，这也就造成了 js 多人写作开发容易造成全局污染的情况，以前我们可能会采用立即执行函数、对象等方式来尽量减少变量这种情况，后面社区为了解决这个问题陆续提出了 AMD 规范和 CMD 规范，这里不同于 Node.js 的 CommonJS 的原因在于服务端所有的模块都是存在于硬盘中的，加载和读取几乎是不需要时间的，而浏览器端因为加载速度取决于网速，因此需要采用异步加载，AMD 规范中使用 define 来定义一个模块，使用 require 方法来加载一个模块，现在 ES6 也推出了标准的模块加载方案，通过 export 和 import 来导出和导入模块。

随着前端项目复杂性不断提高，JS 的代码量变的越来越大，必须做拆分。

使用模块化可以给我们带来以下好处

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

但如果仅是拆成几个 js 文件，然后在用`script`标签去引入这些文件又会使导致以下几个问题：

- 影响加载速度
  - JS 文件变多，加载 JS 文件数量过多导致页面加载速度编码
- 代码的引入次序
  - 使用 script 标签引入 JS 时还必须控制 JS 的顺序。在单个 JS 文件编写的时候，如果要使用其他的 JS 文件中的一些变量和函数，不能直观的知道这个变量或函数是在哪个文件定义的。
- 命名空间污染
  - JS 虽然拆开了，但实际上在浏览器运行时就像把所有文件都何在一起了一样

模块化可以解决上面的问题，但是模块化后的代码是使用`import`或`export`这样的写法来实现的，浏览器不能识别，所以需要一个打包工具。

在有 Babel 的情况下，我们可以直接使用 ES6 的模块化

```js
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}

import { a, b } from './a.js';
import XXX from './b.js';
```

实现模块化方式：

- 立即执行函数
- AMD 和 CMD
- CommonJS
- ES Module

- **AMD**：`requirejs` 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
- **CMD**：`seajs` 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近
- **CommonJs**：模块输出的是一个值的 `copy`，运行时加载，加载的是一个对象（`module.exports` 属性），该对象只有在脚本运行完才会生成
- **ES6 Module**：模块输出的是一个值的引用，编译时输出接口，`ES6`模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。

主要是 4 中：

- CommonJS -- node
- AMD(异步模块定义) -- require.js
- CMD(通用模块定义) -- sea.js
- ES6 模块

### 1. 立即执行函数

在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题

```js
(function(globalVariable) {
  globalVariable.test = function() {};
  // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable);
```

### 2. AMD 和 CMD

鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。

```js
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do();
  b.do();
});
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a');
  a.doSomething();
});
```

### 3. CommonJS

主要用在服务器端 node.js

`CommonJs` 是 Node 独有的规范，浏览器中使用就需要用到 `Browserify` 解析了。

```js
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;

// b.js
var module = require('./a.js');
module.a; // -> log 1
```

在上述代码中，`module.exports` 和 `exports` 很容易混淆，让我们来看看大致内部实现

```js
var module = require('./a.js');
module.a;
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
  a: 1,
};
// 基本实现
var module = {
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports;
var load = function(module) {
  // 导出的东西
  var a = 1;
  module.exports = a;
  return module.exports;
};
```

再来说说 `module.exports` 和 `exports`，用法其实是相似的，但是不能对 `exports` 直接赋值，不会有任何效果。

对于 `CommonJS` 和 ES6 中的模块化的两者区别是：

- 前者支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
- 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响

- 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- 后者会编译成 `require/exports` 来执行的

CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```
// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析

先说 `require` 吧

```
var module = require('./a.js')
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。

**Node CommonJS**:

ES6 标准发布后，module 成为标准，标准的使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，我们采用的是 CommonJS 规范，使用 require 引入模块，使用 module.exports 导出接口。

node 的 module 遵循 CommonJS 规范，requirejs 遵循 AMD，seajs 遵循 CMD，虽各有不同，但总之还是希望保持较为统一的代码风格。

```js
// b.js
// ------------ node ---------
var m = require('./a');
m.a();

// ------------ AMD or CMD -------------
define(function(require, exports, module) {
  var m = require('./a');
  m.a();
});
```

ES6 发布的 module 并没有直接采用 CommonJS，甚至连 require 都没有采用，也就是说 require 仍然只是 node 的一个私有的全局方法，module.exports 也只是 node 私有的一个全局变量属性。

###### export

```js
// a.js
export default function() {}
export function a() {}

var b = 'xxx';
export { b }; // 这是ES6的写法，实际上就是{b:b}
setTimeout(() => (b = 'ooo'), 1000);
export var c = 100;
```

###### import

import 的语法跟 require 不同，而且 import 必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。

```js
import $ from 'jquery';
import * as _ from '_';
import { a, b, c } from './a';
import { default as alias, a as a_a, b, c } from './a';
```

###### as 关键字

简单的说就是取一个别名。export 中可以用，import 中其实可以用

```js
// a.js
var a = function() {};
export { a as fun };

// b.js
import { fun as a } from './a';
a();
```

###### default 关键字

在 export 的时候，可能会用到 default，说白了，它其实是别名的语法糖：

```js
// d.js
export default function() {}

// 等效于：
function a() {}
export { a as default };
```

在 import 的时候，可以这样用：

```js
import a from './d';

// 等效于，或者说就是下面这种写法的简写，是同一个意思
import { default as a } from './d';
```

这个语法糖的好处就是 import 的时候，可以省去花括号{}。简单的说，如果 import 的时候，你发现某个变量没有花括号括起来（没有\*号），那么你在脑海中应该把它还原成有花括号的 as 语法。

所以，下面这种写法你也应该理解了吧

```js
import $, { each, map } from 'jquery';
```

`import 后面第一个$是{defalut as $}`的替代写法。

###### \* 符号

\*就是代表所有，只用在 import 中，我们看下两个例子：

```js
import * as _ from '_';
```

在意义上和 `import _ from '_';`是不同的，虽然实际上后面的使用方法是一样的。它表示的是把'*'模块中的所有接口挂载到*这个对象上，所以可以用`_.each` 调用某个接口。

另外还可以通过`*`号直接继承某一个模块的接口：

```js
export * from '_';

// 等效于：
import * as all from '_';
export all;
```

`*`符号尽可能少用，它实际上是使用所有 `export` 的接口，但是很有可能你的当前模块并不会用到所有接口，可能仅仅是一个，所以最好的建议是使用花括号，用一个加一个。

##### 用 require 还是 import？

require 的使用非常简单，它相当于 module.exports 的传送门，module.exports 后面的内容是什么，require 的结果就是什么，对象、数字、字符串、函数……再把 require 的结果赋值给某个变量，相当于把 require 和 module.exports 进行平行空间的位置重叠。

而且 require 理论上可以运用在代码的任何地方，甚至不需要赋值给某个变量之后再使用，比如：

```js
require('./a')(); // a模块是一个函数，立即执行a模块函数
var data = require('./a').data; // a模块导出的是一个对象
var a = require('./a')[0]; // a模块导出的是一个数组
```

你在使用时，完全可以忽略模块化这个概念来使用 require，仅仅把它当做一个 node 内置的全局函数，它的参数甚至可以是表达式：

```js
require(process.cwd() + '/a');
```

但是 import 则不同，它是编译时的（require 是运行时的），它必须放在文件开头，而且使用格式也是确定的，不容置疑。它不会将整个模块运行后赋值给某个变量，而是只选择 import 的接口进行编译，**这样在性能上比 require 好很多**。

从理解上，require 是赋值过程，import 是解构过程，当然，require 也可以将结果解构赋值给一组变量，但是 import 在遇到 default 时，和 require 则完全不同：`var $ = require('jquery');` 和 `import $ from 'jquery'` 是完全不同的两种概念。

上面完全没有回答“改用 require 还是 import？”这个问题，因为这个问题就目前而言，根本没法回答，因为目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require。这也是为什么在模块导出时使用 module.exports，在引入模块时使用 import 仍然起效，因为本质上，import 会被转码为 require 去执行。

### 4. ES Module

目前 js 社区有 4 种模块管理规范：AMD、CMD、CommonJS 和 EsModule。 ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：

- CommonJS 支持动态导入，也就是 require(\${path}/xx.js)，后者目前不支持，但是已有提案
- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 require/exports 来执行的

```js
// 引入模块 API
import XXX from './a.js';
import { XXX } from './a.js';
// 导出模块 API
export function a() {}
export default function() {}
```

### 说说你对 AMD CMD Commonjs 的理解

- CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数
- AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的

**模块化开发怎么做？**

- 立即执行函数,不暴露私有成员

```js
var module1 = (function() {
  var _count = 0;
  var m1 = function() {
    //...
  };
  var m2 = function() {
    //...
  };
  return {
    m1: m1,
    m2: m2,
  };
})();
```

**AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？**

- Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中

```js
// CMD
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  // 此处略去 100 行
  var b = require('./b'); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(['./a', './b'], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

**对前端模块化的认识**

- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出
- CMD 是 SeaJS 在推广过程中对模块定义的规范化产出
- AMD 是提前执行，CMD 是延迟执行
- AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的

#### 对前端模块化的认识

> AMD 是 `RequireJS` 在推广过程中对模块定义的规范化产出。
> CMD 是 `SeaJS` 在推广过程中对模块定义的规范化产出。
> `AMD` 是提前执行，`CMD` 是延迟执行。
> `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的。
> CMD 模块方式

```js
define(function(require, exports, module) {
  // 模块代码
});
```

JS 模块化的实践
require.js 的实现原理（如果使用过 webpack，进一步会问，两者打包的异同及优缺点）

项目模块的切分原则：

### AMD、CMD 的分别

CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数，是 SeaJS 在推广过程中对模块定义的规范化产出

AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的,是 RequireJS 在推广过程中对模块定义的规范化产出

- 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
- CMD 推崇依赖就近，AMD 推崇依赖前置。
- AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。

require 与 import 的区别:

- require 支持 动态导入，import 不支持，正在提案 (babel 下可支持)
- require 是 同步 导入，import 属于 异步 导入
- require 是 值拷贝，导出值变化不会影响导入值；import 指向 内存地址，导入值会随导出值而变化

CommonJS 是服务端模块的规范，Nodejs 采用了这个规范。根据 CommonJS 规范，一个单独的文件就是一个模块，每个模块都是采用一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象属性。
CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数，由于 nodejs 主要用于服务端编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不同考虑非同步加载的方式，所以 CommonJS 规范比较适用。
但是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。

### 你怎么看 AMD vs. CommonJS？

"异步模块定义"

```js
require(['math'], function(math) {
  math.add(2, 3);
});
```

它们都是实现模块体系的方式，直到 ES2015 出现之前，JavaScript 一直没有模块体系。CommonJS 是同步的，而 AMD（Asynchronous Module Definition）从全称中可以明显看出是异步的。CommonJS 的设计是为服务器端开发考虑的，而 AMD 支持异步加载模块，更适合浏览器。

我发现 AMD 的语法非常冗长，CommonJS 更接近其他语言 import 声明语句的用法习惯。大多数情况下，我认为 AMD 没有使用的必要，因为如果把所有 JavaScript 都捆绑进一个文件中，将无法得到异步加载的好处。此外，CommonJS 语法上更接近 Node 编写模块的风格，在前后端都使用 JavaScript 开发之间进行切换时，语境的切换开销较小。

我很高兴看到 ES2015 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和 Node 中完全推出，但是我们可以使用代码转换工具进行转换

### ES6 模块和 CommonJS 模块的差异？

1. ES6 模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 模块，运行时加载。
2. ES6 模块自动采用严格模式，无论模块头部是否写了 "use strict";
3. require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。
4. ES6 模块中顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。
5. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

CommonJS 中的 require/exports 和 ES6 中的 import/export 区别:

1. CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。
1. ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
1. import/export 最终都是编译为 require/exports 来执行的。
1. CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
1. export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系

### 如何实现一个 JS 的 AMD 模块加载器

AMD 是解决 JS 模块化的规范，实现这样的一个模块加载器的关键在于解决每个模块依赖的解析。首先我们需要有一个模块的入口，也就是主模块，比如我们使用
一个 use 方法作为入口，之后以数组的形式列出了主模块的依赖，这时候我们要想到的是如何解析这一个一个的依赖，也就是如何解析出一个个 js 文件的绝对地址，
我们可以制定一个规则，如默认为主模块的路径为基准，也可以像 requirejs 一样使用一个 config 方法来指定一个 baseurl 和为每一个模块指定一个 path，最后就是
模块的问题，我们需要暴露一个 define 方法来定义模块，也就是模块名，依赖以及每个模块的各自代码。其中每个模块的代码都应该在依赖加载完之后执行，这就是一个
回调函数，模块的依赖、回调函数、状态、名字、模块导出等可以看做是一个模块的属性，因此我们可以使用一个对象来保存所有的模块，然后每个模块的各个属性存放在一个对象中。
最后我们来考虑一下模块加载的问题，上面我们说到 use 方法，use 方法的逻辑就是遍历依赖，然后对每个模块进行加载，也就是解析地址然后使用插入 script，我们假设
使用 loadModule 方法来加载依赖，那么这个函数的逻辑就应该是检查我们的模块是否已经加载过来判断是否需要加载，如果这个模块还有依赖则调用 use 方法继续解析，模块依赖中我们
还没有提到的问题就是每个模块的依赖是需要被传进模块里来使用的，解决方法就是每个模块的 callback 方法执行后的返回的 export 记录下来然后使用 apply 之类的方法将这些参数传递进去。
大致就是这样子的。

### 听说过 UMD 吗？可以简要介绍一下吗？

**模块化开发怎么做？**

- 不暴露私有成员

```
var module1 = (function(){
　　　　var _count = 0;
　　　　var m1 = function(){
　　　　　　//...
　　　　};
　　　　var m2 = function(){
　　　　　　//...
　　　　};
　　　　return {
　　　　　　m1 : m1,
　　　　　　m2 : m2
　　　　};
　　})();
```

**AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？**

- Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中
- 区别：

  - 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible
  - CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

```js
// CMD
define(function(require, exports, module) {
  var a = require('./a');
  a.doSomething();
  // 此处略去 100 行
  var b = require('./b'); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(['./a', './b'], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

### 如何在文件之间共用代码？

这取决于执行 JavaScript 的环境。

在客户端（浏览器环境）上，只要变量或函数在全局作用域（`window`）中声明，所有脚本都可以引用它们。或者，通过 RequireJS 采用异步模块定义（AMD）以获得更多模块化方法。

在服务器（Node.js）上，常用的方法是使用 CommonJS。每个文件都被视为一个模块，可以通过将它们附加到`module.exports`对象来导出变量和函数。

ES2015 定义了一个模块语法，旨在替换 AMD 和 CommonJS。 这最终将在浏览器和 Node 环境中得到支持。

### module、export、import 是什么，有什么作用？

- `module`、`export`、`import`是`ES6`用来统一前端模块化方案的设计思路和实现方案。`export`、`import`的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的`AMD/CMD`、`requireJS`、`seaJS`、`commondJS`等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，`JS`也能更加能实现大型的应用程序开发。
- `import`引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。
- `import`引入`export`导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值

### 常见问题

- a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?
- 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 `t = 111` 能否在 a 中直接打印出来?
- 如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题?

### 其他

- npm 包 的 UMD 文件是什么？ UMD 与 webpack 之类的 CommonJS 模块打包器有什么关系，是否只能用 webpack 之类的打包器进行打包？
- require 写在里面是为了清除缓存！！！

**Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？**

- 两等号判等，会在比较时进行类型转换；
- 三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回 false）；
- Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true
- Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。

图片懒加载
实现页面加载进度条
实现 extend 函数

实现拖拽功能，比如把 5 个兄弟节点中的最后一个节点拖拽到节点 1 和节点 2 之间
动画：setTimeout 何时执行，requestAnimationFrame 的优点

手写 parseInt 的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用 JS 原生的字符串转数字的 API，比如 Number()

### Module

- 命令

  - export

    ：规定模块对外接口

    - **默认导出**：`export default Person`(导入时可指定模块任意名称，无需知晓内部真实名称)
    - **单独导出**：`export const name = "Bruce"`
    - **按需导出**：`export { age, name, sex }`(推荐)
    - **改名导出**：`export { name as newName }`

  - import

    ：导入模块内部功能

    - **默认导入**：`import Person from "person"`
    - **整体导入**：`import * as Person from "person"`
    - **按需导入**：`import { age, name, sex } from "person"`
    - **改名导入**：`import { name as newName } from "person"`
    - **自执导入**：`import "person"`
    - **复合导入**：`import Person, { name } from "person"`

  - 复合模式

    ：

    ```
    export命令
    ```

    和

    ```
    import命令
    ```

    结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量

    - **默认导入导出**：`export { default } from "person"`
    - **整体导入导出**：`export * from "person"`
    - **按需导入导出**：`export { age, name, sex } from "person"`
    - **改名导入导出**：`export { name as newName } from "person"`
    - **具名改默认导入导出**：`export { name as default } from "person"`
    - **默认改具名导入导出**：`export { default as name } from "person"`

- 继承：`默认导出`和`改名导出`结合使用可使模块具备继承性

- 设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量

- 严格模式：ES6 模块自动采用严格模式(不管模块头部是否添加`use strict`)

> 模块方案

- **CommonJS**：用于服务器(动态化依赖)
- **AMD**：用于浏览器(动态化依赖)
- **CMD**：用于浏览器(动态化依赖)
- **UMD**：用于浏览器和服务器(动态化依赖)
- **ESM**：用于浏览器和服务器(静态化依赖)

> 加载方式

- 运行时加载
  - 定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)
  - 影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化
- 编译时加载
  - 定义：直接从模块中获取需要的属性和方法进行加载(按需加载)
  - 影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(**本身不是对象**)，可拓展 JS 高级语法(**宏和类型校验**)

> 加载实现

- 传统加载

  ：通过

  ```
  <script>
  ```

  进行同步或异步加载脚本

  - 同步加载：``
  - Defer 异步加载：``(顺序加载，渲染完再执行)
  - Async 异步加载：``(乱序加载，下载完就执行)

- **模块加载**：``(默认是 Defer 异步加载)

> CommonJS 和 ESM 的区别

- ```
  CommonJS
  ```

  输出

  ```
  值的拷贝
  ```

  ，

  ```
  ESM
  ```

  输出

  ```
  值的引用
  ```

  - `CommonJS`一旦输出一个值，模块内部的变化就影响不到这个值
  - `ESM`是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值

- ```
  CommonJS
  ```

  是运行时加载，

  ```
  ESM
  ```

  是编译时加载

  - `CommonJS`加载模块是对象(即`module.exports`)，该对象只有在脚本运行完才会生成
  - `ESM`加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成

> Node 加载

- 背景：`CommonJS`和`ESM`互不兼容，目前解决方案是将两者分开，采用各自的加载方案

- 区分：要求

  ```
  ESM
  ```

  采用

  ```
  .mjs
  ```

  后缀文件名

  - `require()`不能加载`.mjs文件`，只有`import命令`才可加载`.mjs文件`
  - `.mjs文件`里不能使用`require()`，必须使用`import命令`加载文件

- 驱动：`node --experimental-modules file.mjs`

- 限制：Node 的`import命令`目前只支持加载本地模块(`file:协议`)，不支持加载远程模块

- 加载优先级

  - 脚本文件省略后缀名：依次尝试加载四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)
  - 以上不存在：尝试加载`package.json`的`main字段`指定的脚本
  - 以上不存在：依次尝试加载名称为`index`四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)
  - 以上不存在：报错

- 不存在的内部变量：`arguments`、`exports`、`module`、`require`、`this`、`__dirname`、`__filename`

- CommonJS 加载 ESM

  - 不能使用`require()`，只能使用`import()`

- ESM 加载 CommonJS

  - 自动将`module.exports`转化成`export default`
  - `CommonJS`输出缓存机制在`ESM`加载方式下依然有效
  - 采用`import命令`加载`CommonJS模块`时，不允许采用`按需导入`，应使用`默认导入`或`整体导入`

> 循环加载

- 定义：`脚本A`的执行依赖`脚本B`，而`脚本A`的执行又依赖`脚本B`
- 加载原理
  - CommonJS：`require()`首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取
  - ESM：`import命令`加载变量不会被缓存，而是成为一个指向被加载模块的引用
- 循环加载
  - CommonJS：只输出已经执行的部分，还未执行的部分不会输出
  - ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)

> 重点难点

- ES6 模块中，顶层`this`指向`undefined`，不应该在顶层代码使用`this`
- 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取
- `export命令`输出的接口与其对应的值是`动态绑定关系`，即通过该接口可获取模块内部实时的值
- `import命令`大括号里的变量名必须与被导入模块对外接口的名称相同
- `import命令`输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口
- `import命令`命令具有提升效果，会提升到整个模块的头部，首先执行
- 重复执行同一句`import语句`，只会执行一次
- `export default`命令只能使用一次
- `export default命令`导出的整体模块，在执行`import命令`时其后不能跟`大括号`
- `export default命令`本质是输出一个名为`default`的变量，后面不能跟`变量声明语句`
- `export default命令`本质是将后面的值赋给名为`default`的变量，可直接将值写在其后
- `export default命令`和`export {}命令`可同时存在，对应`复合导入`
- `export命令`和`import命令`可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域
- `import()`加载模块成功后，此模块会作为一个对象，当作`then()`的参数，可使用`对象解构赋值`来获取输出接口
- 同时动态加载多个模块时，可使用`Promise.all()`和`import()`相结合来实现
- `import()`和结合`async/await`来书写同步操作的代码

> 单例模式：跨模块常量

```js
// 常量跨文件共享
// person.js
const NAME = 'Bruce';
const AGE = 25;
const SEX = 'male';
export { AGE, NAME, SEX };

// file1.js
import { AGE } from 'person';
console.log(AGE);

// file2.js
import { AGE, NAME, SEX } from 'person';
console.log(AGE, NAME, SEX);
```

> 默认导入互换整体导入

```
import Person from "person";
console.log(Person.AGE);

import * as Person from "person";
console.log(Person.default.AGE);

```

### 模块化规范的出现

除了模块加载的问题以外，目前这几种通过约定实现模块化的方式，不同的开发者在实施的过程中会出现一些细微的差别，因此，为了统一不同开发者、不同项目之间的差异，我们就需要制定一个行业标准去规范模块化的实现方式。

再接合我们刚刚提到的模块加载的问题，我们现在的需求就是两点：

- 一个统一的模块化标准规范
- 一个可以自动加载模块的基础库

提到模块化规范，你可能会想到 CommonJS 规范，它是 Node.js 中所遵循的模块规范，该规范约定，一个文件就是一个模块，每个模块都有单独的作用域，通过 module.exports 导出成员，再通过 require 函数载入模块。现如今的前端开发者应该对其有所了解，但是如果我们想要在浏览器端直接使用这个规范，那就会出现一些新的问题。

如果你对 Node.js 的模块加载机制有所了解，那么你应该知道，CommonJS 约定的是以同步的方式加载模块，因为 Node.js 执行机制是在启动时加载模块，执行过程中只是使用模块，所以这种方式不会有问题。但是如果要在浏览器端使用同步的加载模式，就会引起大量的同步模式请求，导致应用运行效率低下。

所以在早期制定前端模块化标准时，并没有直接选择 CommonJS 规范，而是专门为浏览器端重新设计了一个规范，叫做 AMD （ Asynchronous Module Definition） 规范，即异步模块定义规范。同期还推出了一个非常出名的库，叫做 Require.js，它除了实现了 AMD 模块化规范，本身也是一个非常强大的模块加载器。

在 AMD 规范中约定每个模块通过 define() 函数定义，这个函数默认可以接收两个参数，第一个参数是一个数组，用于声明此模块的依赖项；第二个参数是一个函数，参数与前面的依赖项一一对应，每一项分别对应依赖项模块的导出成员，这个函数的作用就是为当前模块提供一个私有空间。如果在当前模块中需要向外部导出成员，可以通过 return 的方式实现。

![](https://s0.lgstatic.com/i/image3/M01/89/DC/Cgq2xl6YeWWAZhc-AAIVA96nDrk023.png)

除此之外，Require.js 还提供了一个 require() 函数用于自动加载模块，用法与 define() 函数类似，区别在于 require() 只能用来载入模块，而  define() 还可以定义模块。当 Require.js 需要加载一个模块时，内部就会自动创建 script 标签去请求并执行相应模块的代码。

![](https://s0.lgstatic.com/i/image3/M01/03/97/CgoCgV6YeWWAZBOiAAFbOHcA3-o771.png)

目前绝大多数第三方库都支持 AMD 规范，但是它使用起来相对复杂，而且当项目中模块划分过于细致时，就会出现同一个页面对 js 文件的请求次数过多的情况，从而导致效率降低。在当时的环境背景下，AMD 规范为前端模块化提供了一个标准，但这只是一种妥协的实现方式，并不能成为最终的解决方案。

同期出现的规范还有淘宝的 Sea.js，只不过它实现的是另外一个标准，叫作 CMD，这个标准类似于 CommonJS，在使用上基本和 Require.js 相同，可以算上是重复的轮子。但随着前端技术的发展，Sea.js 后来也被 Require.js 兼容了。如果你感兴趣可以课后了解一下  Seajs 官网。

![](https://s0.lgstatic.com/i/image3/M01/10/C6/Ciqah16YeWWAHUDmAAI62LbE3vI465.png)

### 模块化的标准规范

尽管上面介绍的这些方式和标准都已经实现了模块化，但是都仍然存在一些让开发者难以接受的问题。

随着技术的发展，JavaScript 的标准逐渐走向完善，可以说，如今的前端模块化已经发展得非常成熟了，而且对前端模块化规范的最佳实践方式也基本实现了统一。

- 在 Node.js 环境中，我们遵循 CommonJS 规范来组织模块。
- 在浏览器环境中，我们遵循 ES Modules 规范。

![](https://s0.lgstatic.com/i/image3/M01/89/DC/Cgq2xl6YeWWAQftyAAFnRTB-PpI302.png)

而且在最新的 Node.js 提案中表示，Node 环境也会逐渐趋向于 ES Modules 规范，也就是说作为现阶段的前端开发者，应该重点掌握 ES Modules 规范。

因为 CommonJS 属于内置模块系统，所以在 Node.js 环境中使用时不存在环境支持问题，只需要直接遵循标准使用 require 和 module 即可。

但是对于 ES Modules 规范来说，情况会相对复杂一些。我们知道 ES Modules 是 ECMAScript 2015（ES6）中才定义的模块系统，也就是说它是近几年才制定的标准，所以肯定会存在环境兼容的问题。在这个标准刚推出的时候，几乎所有主流的浏览器都不支持。但是随着 Webpack 等一系列打包工具的流行，这一规范才开始逐渐被普及。

经过 5 年的迭代， ES Modules 已发展成为现今最主流的前端模块化标准。相比于 AMD 这种社区提出的开发规范，ES Modules 是在语言层面实现的模块化，因此它的标准更为完善也更为合理。而且目前绝大多数浏览器都已经开始能够原生支持 ES Modules 这个特性了，所以说在未来几年，它还会有更好的发展，短期内应该不会有新的轮子出现了。

综上所述，如何在不同的环境中去更好的使用 ES Modules 将是你重点考虑的问题。

### ES Modules 特性

那对于 ES Modules 的学习，可以从两个维度入手。首先，你需要了解它作为一个规范或者说标准，到底约定了哪些特性和语法；其次，你需要学习如何通过一些工具和方案去解决运行环境兼容带来的问题。

按照 ES Modules 的标准，这里的 index.html 可以直接在浏览器中正常工作，但是对于不支持 ES Modules 标准的浏览器，直接使用就会出现错误，所以我们需要使用 Webpack 这样的工具，将我们这里按照模块化方式拆分的 JS 代码再次打包到一起。
