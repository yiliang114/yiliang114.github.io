---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 请指出 JavaScript 宿主对象和原生对象的区别？

原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如`String`、`Math`、`RegExp`、`Object`、`Function`等等。

宿主对象是指 DOM 和 BOM，宿主对象是由运行时环境（浏览器或 Node）提供，比如`window`、`XMLHTTPRequest`等等。

### 介绍 js 有哪些内置对象？

- Object 是 JavaScript 中所有对象的父对象
- 数据封装类对象：Object、Array、Boolean、Number 和 String
- 其他对象：Function、Arguments、Math、Date、RegExp、Error
- ES6 新增对象：Symbol、Map、Set、Promises、Proxy、Reflect

### 数组负数下标

数组对象其实是一个特殊对象，他拥有普通对象的全部特性，所以不止负索引，小数索引，连字符串索引都是可以的，只是用这些索引向数组添加属性时，数组的 length 不会增加罢了，而只有当索引是正整数或其对应数字串时，length 才会增加，仅此而已。

### Object.create(null) 与 普通的 {} 的区别？

为什么 vue 有些地方需要使用前者，有些地方不需要？

### String 和 string 有什么区别？

String 是构造函数，而"string"是变量的一种类型

```js
typeof String; // "function"
typeof string; // "undefined"
typeof 'string'; // "string"
```

### 为什么 0.1 + 0.2 != 0.3

因为 JS 采用 IEEE 754 双精度版本（64 位），并且只要采用 IEEE 754 的语言都有该问题。

我们都知道计算机是通过二进制来存储东西的，那么 `0.1` 在二进制中会表示为

```js
// (0011) 表示循环
0.1 = 2 ^ (-4 * 1.10011(0011));
```

我们可以发现，`0.1` 在二进制中是无限循环的一些数字，其实不只是 `0.1`，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。

IEEE 754 双精度版本（64 位）将 64 位分为了三段

- 第一位用来表示符号
- 接下去的 11 位用来表示指数
- 其他的位数用来表示有效位，也就是用二进制表示 `0.1` 中的 `10011(0011)`

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 `0.1` 不再是 `0.1` 了，而是变成了 `0.100000000000000002`

```js
0.100000000000000002 === 0.1; // true
```

那么同样的，`0.2` 在二进制也是无限循环的，被裁剪后也失去了精度变成了 `0.200000000000000002`

```js
0.200000000000000002 === 0.2; // true
```

所以这两者相加不等于 `0.3` 而是 `0.300000000000000004`

```js
0.1 + 0.2 === 0.30000000000000004; // true
```

那么可能你又会有一个疑问，既然 `0.1` 不是 `0.1`，那为什么 `console.log(0.1)` 却是正确的呢？

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

```js
console.log(0.100000000000000002); // 0.1
```

那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题

```js
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3; // true
```

### in 和 hasOwnProperty 区别

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果在实例中添加一个与原型中属性同名的属性，则该属性会屏蔽原型中的那个属性。添加的同名属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为`null`，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。

```js
function Person() {}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};

let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true

person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true

delete person1.name;
console.log(person1.name); // "Nicholas"
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // true
```

`in`操作符只要通过对象能访问到属性就返回`true`。`hasOwnProperty()`只在属性存在于实例中时才返回`true`。

使用`delete`操作符则可以完全删除实例属性，从而让我们能巩固重新访问原型中的属性。

```js
function Person() {
  this.name = 'koewas';
}

// Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
person1.name = 'Greg';
console.log(person1.name); // "Greg"
console.log(person1.hasOwnProperty('name')); // true
console.log('name' in person1); // true
delete person1.name;
console.log(person1.name); // undefined
console.log(person1.hasOwnProperty('name')); // false
console.log('name' in person1); // false
```

上面这段代码的`name`为实例属性，不属于原型。但却不是私有属性，能被实例访问。

### hasOwnProperty

是不是对象自身下面的属性

```js
// hasOwnProperty(): 看是不是对象自身下面的属性
var arr = [];
arr.num = 10;
Array.prototype.num2 = 20; //这样写表示所有的数组对象都有了num2这个属性

alert(arr.hasOwnProperty('num')); //true 说明num这个属性只属于arr的,是arr独有的
alert(arr.hasOwnProperty('num2')); //false 因为所有的数组对象都拥有了num2,而不仅仅是arr,所以是false

var a1 = new Aaa();
alert(a1.hasOwnProperty == Object.prototype.hasOwnProperty); //true
```

### for in 与 hasOwnProperty 结合使用

与 in 操作符相比，for in 在循环对象的属性时也会遍历原型链，for in 不会读取不可枚举属性，如数组的 length 属性。

```js
// 扩展 Object.prototype
Object.prototype.bar = 1;
var foo = { moo: 2 };
for (var i in foo) {
  console.log(i); // 输出 bar 和 moo
}
```

我们不可能改变 for in 循环的行为，当需要对循环体内某些属性进行过滤时，可以利用 Object.prototype 的 hasOwnProperty 方法来完成。提示：因为 for in 循环总是遍历整个原型链，所以当遍历多继承的对象时效率较低。使用 hasOwnProperty 进行过滤

```js
// 仍旧针对上例的foo对象
for (var i in foo) {
  if (foo.hasOwnProperty(i)) {
    console.log(i);
  }
}
```

例子中因为使用了 hasOwnProperty，最终输出 moo；如果忽略 hasOwnProperty ，代码将会输出非预期结果，因为本地原型（如 Object.prototype）已经被扩展了。

Prototype 框架就是扩展 Javascript 原始对象的一个类库，并被广泛使用，其缺点也很明显，当框架引入后，如果不使用 hasOwnProperty 进行过滤判断，输出结果保证不是你想要的。

最佳实践

推荐在 for in 时，总是使用 hasOwnProperty 进行判断，没人可以保证运行的代码环境是否被污染过。

hasOwnProperty
为了检查某个对象是否拥有不在原型链上的自定义属性，就有必要用到 hasOwnProperty 方法，任何一个对象都具有该方法，它继承自 Object.prototype。

提示：我们无法完全检测某个属性是否是 undefined，因为属性有可能存在，但其值为 undefined。hasOwnProperty 是 Javascript 中唯一一个可以处理对象属性而不遍历原型链的方法。

```js
// 扩展 Object.prototype
Object.prototype.bar = 1;
var foo = { goo: undefined };

foo.bar; // 1
'bar' in foo; // true

foo.hasOwnProperty('bar'); // false
foo.hasOwnProperty('goo'); // true
```

只有 hasOwnProperty 给出了正确的预期结果，当遍历对象的属性时这是很有必要的，没有其它办法来排除定义在对象原型链上的属性。

hasOwnProperty 作为属性

Javascript 并没有保护 hasOwnProperty 为关键字或保留字，因此，如果某个对象拥有同名的属性，就有必要利用扩展的 hasOwnProperty 来获取正确结果。

```js
var foo = {
hasOwnProperty: function() {
return false;
},
bar: 'Here be dragons'
};
foo.hasOwnProperty('bar'); // 总是返回 false
// 使用另一个 hasOwnProperty 并将 this 设置为 foo 来调用它
{}.hasOwnProperty.call(foo, 'bar'); // true
```

### reduce

[mdn](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

> `arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])` 如果没有提供 initialValue 则第一个值除外

发现一个有意思的东西？

```js
var files = ['111', '222', '333', '444'];
var result = files.reduce((content, filename) => {
  console.log('content', content);
  console.log('filename', filename);
  return content + filename;
}, '');
console.log(result);
```

```js
var files = ['111', '222', '333', '444'];
var result = files.reduce((content, filename) => {
  console.log('content', content);
  console.log('filename', filename);
  return content + filename;
});
console.log(result);
```

reduce

### 分析下列输出结果

```js
// example 1
var a = {},
  b = '123',
  c = 123;
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 2
var a = {},
  b = Symbol('123'),
  c = Symbol('123');
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);

// example 3
var a = {},
  b = { key: '123' },
  c = { key: '456' };
a[b] = 'b';
a[c] = 'c';
console.log(a[b]);
```

对象键名的转换：

- 对象的键名只能是字符串和 Symbol 类型。
- 其他类型的键名会被转换成字符串类型。
- 对象转字符串默认会调用 toString 方法。
  example 1，c 的键名转换成字符串将 b 键覆盖输出 c
  example 2，任何一个 Symbol 类型的值都是不相等的，所以 b 键和 c 键都不会被覆盖，输出 b
  example 3，对象都会被转换为字符串 [object Object]，因此 c 键会覆盖 b 键，输出 c

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```
