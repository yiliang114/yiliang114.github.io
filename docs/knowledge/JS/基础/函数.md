---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 函数表达式和函数声明

```js
// 函数声明 这种方式是声明了个方法，foo 这个名字无法改变
function funDeclaration(type) {
  return type === 'Declaration';
}
// 函数表达式 这种方式是声明了个变量，而这个变量是个方法，变量在 js 中是可以改变的,
var funExpression = function(type) {
  return type === 'Expression';
};
```

### 箭头函数与普通函数（function）的区别是什么？为什么

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比区别：

1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，它会从自己的作用域链的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）
2. 箭头函数不可以使用 arguments 对象,，该对象在函数体内不存在，如果要用，可以用 rest 参数代替
3. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数
4. 不绑定 super 和 new.target
5. 不可以使用 new 命令，因为

### 构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？

- 没有自己的 this，无法调用 call，apply
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto

### JavaScript 中有哪些不同的函数调用模式

函数调用，方法调用，.call() 和 .apply(),
不同但是改变函数内的 this 指向

### 匿名函数的典型应用场景是什么？

匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。

```js
(function() {
  // 一些代码。
})();
```

匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。

用途：
匿名函数最大的用途是创建闭包（这是 JavaScript 语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用

### Function.proto(getPrototypeOf)是什么？

```js
Function.__proto__ == Object.prototype; //false
Function.__proto__ == Function.prototype; //true
```

### 实现 compose

<!-- compose([a, b, c])('参数') => a(b(c('参数'))) -->

```js
function compose(funcs) {
  var len = funcs.length;
  var index = len - 1;

  for (let i = 0; i < len; i++) {
    if (typeof funcs[i] !== 'function') {
      throw new TypeError('Expected a function');
    }
  }

  return function(...args) {
    let result = funcs[index](...args); // 第一次
    while (--index >= 0) {
      result = funcs[index](result);
    }
    return result;
  };
}
```

```js
function mul(x) {
  return function(y) {
    // anonymous function
    return function(z) {
      // anonymous function
      return x * y * z;
    };
  };
}

console.log(mul(2)(3)(4)); // output : 24
console.log(mul(4)(3)(4)); // output : 48
```
