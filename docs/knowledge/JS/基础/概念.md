---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### js 单线程的理解？

JS 的单线程是指一个浏览器进程中只有一个 JS 的执行线程，同一时刻内只会有一段代码在执行。

作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

### Javascript 是一种弱类型语言，它分别有什么优点和缺点？

优点：弱类型使用简单，更灵活多变。
缺点：因为不包含类型信息，所以在代码的上下文中，可能会进行隐含的类型转换，比如把字符串转整型，整型转字符串，这样会稍损性能，并且可能会不符合程序本意。

### JavaScript 的组成

由以下三部分组成：

- ECMAScript（核心）：JavaScript 语言基础
- DOM（文档对象模型）：规定了访问 HTML 和 XML 的接口
- BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法

### eval 是做什么的？

它的功能是把对应的字符串解析成 JS 代码并运行
应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）
由 JSON 字符串转换为 JSON 对象的时候可以用 eval，var obj =eval(‘(‘+ str +’)’)

它的功能是把对应的字符串解析成 JS 代码并运行；
应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。

### JS 是如何运行的？

JS 是单线程运行的，这里就可以说说你理解的线程和进程的区别。然后讲到执行栈，接下来的内容就是涉及 Eventloop 了，微任务和宏任务的区别，哪些是微任务，哪些又是宏任务，还可以谈及浏览器和 Node 中的 Eventloop 的不同，最后还可以聊一聊 JS 中的垃圾回收。

### javascript 的运行机制

- 由于 js 是单线程，js 将所有任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
- 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
- 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线- 程执行。
- 在所有同步任务执行完之前，任何的异步任务是不会执行的
- 异步执行的运行机制如下：

  1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
  2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
  3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
  4. 主线程不断重复上面的第三步。
     主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制

- 一般来说，有以下四种会放入异步任务队列:
  1. setTimeout 和 setlnterval
  1. DOM 事件
  1. ES6 中的 Promise
  1. Ajax 异步请求

### 什么是哈希表？

哈希表是根据关键字（Key value）而直接访问在内存存储位置的数据结构。也就是说，它通过把键值通过一个函数的计算，映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

### JavaScript 对象生命周期的理解？

- 当创建一个对象时，JavaScript 会自动为该对象分配适当的内存
- 垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量
- 如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收

### 用转译成 JavaScript 的语言写 JavaScript 有什么优缺点？

Some examples of languages that compile to JavaScript include CoffeeScript, Elm, ClojureScript, PureScript and TypeScript.
这些是转译成 JavaScript 的语言，包括 CoffeeScript、Elm、ClojureScript、PureScript 和 TypeScript。

**优点：**

- 修复了 JavaScript 中的一些长期问题，并摒弃了 JavaScript 不好的做法。
- 在 JavaScript 的基础上提供一些语法糖，使我们能够编写更短的代码，我认为 ES5 缺乏语法糖的支持，但 ES2015 非常好。
- 对于需要长时间维护的大型项目，静态类型非常好用（针对 TypeScript）。

**缺点：**

- 由于浏览器只运行 JavaScript，所以需要构建、编译过程，在将代码提供给浏览器之前，需要将代码转译为 JavaScript。
- 如果 source map 不能很好地映射到预编译的源代码，调试会很痛苦。
- 大多数开发人员不熟悉这些语言，需要学习它。如果将其用于项目，会增加团队成本。
- 社区比较小（取决于语言），这意味着资源、教程、图书和工具难以找到。
- 可能缺乏 IDE（编辑器）的支持。
- 这些语言将始终落后于最新的 JavaScript 标准。
- 开发人员应该清楚代码正在被编译到什么地方——因为这是实际运行的内容，是最重要的。

实际上，ES2015 已经大大改进了 JavaScript，编写体验很好。我现在还没有真正看到对 CoffeeScript 的需求。

### 递归和迭代的区别是什么，各有什么优缺点？

程序调用自身称为递归，利用变量的原值推出新值称为迭代，递归的优点
大问题转化为小问题，可以减少代码量，同时应为代码精简，可读性好，
缺点就是，递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。迭代的好处
就是代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销，
缺点就是代码不如递归简洁。 迭代举例就是 for, while 循环

### 重载和重写有什么区别

方法重写(overriding)：

- 也叫子类的方法覆盖父类的方法，要求返回值、方法名和参数都相同。
- 子类抛出的异常不能超过父类相应方法抛出的异常。(子类异常不能超出父类异常)
- 子类方法的的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)。
  方法重载(overloading):
- 重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同，最常见的重载的例子就是类的构造函数

### 垃圾回收

JavaScript 自动回收，注意一点，尽量解除不适用的全局变量。
尽可能的去使用局部变量，因为函数使用之后就会销毁掉，少用全局变量。全局变量查找的时候，从内部往外找，会有一定的影响。

### delete

将一个属性给删除：

1. 将这个属性定义为 null
2. 将这个属性赋值为 undefined
3. 使用 delete 关键字：delete obj.name 能够删除复杂变量的属性和方法，但是不能够删除变量本身，如果使用，会删除失败。

### JS 代码报错，后续代码还会执行吗

### JS 某个地方出错，怎么让页面正常显示

### js 跨域捕获不了错误

https://www.cnblogs.com/jiebba/p/9591534.html

### 默认参数如何工作？

1. 基本用法

```js
function first(x = 1, y = 2) {
  console.log('x：' + x, 'y：' + y);
}
first();
first(100);
```

2. 与解构赋值默认值结合

```js
function second({ x, y = 2 }) {
  console.log('x：' + x, 'y：' + y);
}
second({});
second({ x: 100 });
second({ x: 100, y: 200 });
```

3. 双重默认值

```js
function third({ x = 1, y = 2 } = {}) {
  console.log('x：' + x, 'y：' + y);
}
third();
third({ x: 100, y: 200 });
third({ x: 100 });
```

### 如何实现数组的随机排序？

- 方法一：

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
function randSort1(arr) {
  for (var i = 0, len = arr.length; i < len; i++) {
    var rand = parseInt(Math.random() * len);
    var temp = arr[rand];
    arr[rand] = arr[i];
    arr[i] = temp;
  }
  return arr;
}
console.log(randSort1(arr));
```

- 方法二：

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
function randSort2(arr) {
  var mixedArray = [];
  while (arr.length > 0) {
    var randomIndex = parseInt(Math.random() * arr.length);
    mixedArray.push(arr[randomIndex]);
    arr.splice(randomIndex, 1);
  }
  return mixedArray;
}
console.log(randSort2(arr));
```

- 方法三：

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function() {
  return Math.random() - 0.5;
});
console.log(arr);
```

### 清空一个 js 数组

```js
var arrayList = ['a', 'b', 'c', 'd', 'e', 'f'];

// 1
arrayList = [];
// 2
arrayList.length = 0;
// 3
arrayList.splice(0, arrayList.length);
// 4
while (arrayList.length) {
  arrayList.pop();
}
```

### 评价一下三种方法实现继承的优缺点,并改进

```
function Shape() {}

function Rect() {}

// 方法1
Rect.prototype = new Shape();

// 方法2
Rect.prototype = Shape.prototype;

// 方法3
Rect.prototype = Object.create(Shape.prototype);

Rect.prototype.area = function () {
  // do something
};
```

方法 1：

1. 优点：正确设置原型链实现继承
2. 优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值
3. 缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改
4. 缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置
5. 总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化

方法 2：

1. 优点：正确设置原型链实现继承
2. 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类

方法 3：

1. 优点：正确设置原型链且避免方法 1.2 中的缺点
2. 缺点：ES5 方法需要注意兼容性

改进：

1. 所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化

```
function Rect() {
    Shape.call(this);
}
```

2. 用新创建的对象替代子类默认原型，设置`Rect.prototype.constructor = Rect;`保证一致性
3. 第三种方法的 polyfill：

```
function create(obj) {
    if (Object.create) {
        return Object.create(obj);
    }

    function f() {};
    f.prototype = obj;
    return new f();
}
```

### js 浮点数运算不精确 如何解决?

### js urldecode

https://www.cnblogs.com/z-one/p/6542955.html

### 位运算

### 强制类型转换和 2 种隐式类型转换?

### 静态属性怎么继承

### 在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？

伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用 getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪数组。可以使用 Array.prototype.slice.call(fakeArray)将数组转化为真正的 Array 对象。

假设接第八题题干，我们要给每个 log 方法添加一个"(app)"前缀，比如'hello world!' ->'(app)hello world!'。方法如下：

```js
function log() {
  var args = Array.prototype.slice.call(arguments); //为了使用 unshift 数组方法，将 argument 转化为真正的数组
  args.unshift('(app)');

  console.log.apply(console, args);
}
```

### JavaScript 如何判断一个对象是空的？

- 第一种： `const isEmptyObject = obj => Object.getOwnPropertyNames(obj).length === 0`
- 第二种： `Object.keys(obj).length == 0`

### 堆，栈，队列的区别

申请方式
内存中的堆和栈第一个区别就是申请方式的不同：栈是系统自动分配空间的，而堆则是程序员根据需要自己申请的空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。
申请效率的比较：栈由系统自动分配，速度较快。但程序员是无法控制的。堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。

申请大小的限制：
栈：在 Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 2M（也有的说是 1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

### 其他

- 0.1 + 0.2 为啥不等于 0.3
- js number 最大和最小的数是多少？ 超出该如何表示？js 中最大能表示的数是多少？最小的数是多少？ 一个字符串占几个字节， 一个 number 类型占多少字节
- 只要为 img 标签设置了 src 属性，无论是 display: none 还是 visibility: hidden 都会产生请求；把图片设置为不存在的属性，比如 data-src 此时 display: none 还是 visibility: hidden 都不会产生请求
- 如何创建一个真正的 private 方法
- 什么是 undefined x 1 ？
- unicode utf8 gbk 编码的了解，乱码的解决
