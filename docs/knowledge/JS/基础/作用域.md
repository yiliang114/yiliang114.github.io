---
title: 作用域
date: '2020-10-26'
draft: true
---

### 变量与函数同名的情况

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})(); //[Function b]
```

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。
在严格模式下 b 函数相当于常量，无法进行重新赋值，在非严格模式下函数声明优先变量声明

#### 简单改造下面的代码，使之分别打印 10 和 20

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

- 打印 20

```js
var b = 10;
(function b() {
  var b = 20;
  console.log(b);
})(); // 20 在自执行函数中重新定义一个变量，
```

```js
var b = 10;
(function a() {
  b = 20;
  console.log(b);
})();
```

```js
var b = 10;
(function() {
  b = 20;
  console.log(b);
})();
```

- 打印 10

```js
var b = 10;
(function b() {
  b = 20;
  console.log(window.b);
})();
```

在自执行函数中访问 window，window 中的 b 值为 10 2.

```js
var b = 10;
(function() {
  console.log(b);
  b = 20;
})();
```

```js
var b = 10;
(function b(b) {
  console.log(b);
  b = 20;
})(b);
```

### 作用域

```js
var a = 10;
(function() {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

### 下面的输出是什么？

```js
pi = 0;
radius = 1;
function circum(radius) {
  radius = 3;
  pi = 3.14;
  console.log(2 * pi * radius); // 18.14
  console.log(arguments[0]); // 3
}
circum(2);
console.log(pi); // 3.14
console.log(radius); // 1

// 函数内修改了radius 修改的是形式参数，修改的 pi 是全局的 window or global 中的 pi
```

```js
var pi = 0;
var radius = 1;
function circum(radius) {
  radius = 3;
  pi = 3.14;
  console.log(2 * pi * radius); // 18.84
  console.log(arguments[0]); // 3
}

circum(radius);

console.log(pi); // 3.14
console.log(radius); // 1
```

```js
function foo(a, b) {
  arguments[0] = 9;
  arguments[1] = 99;
  console.log(a, b); //9, 99
}
foo(1, 10);

function foo(a, b) {
  a = 8;
  b = 88;
  console.log(arguments[0], arguments[1]); //8, 88
}
foo(1, 10);

// ES6的默认函数不会改变arguments类数组对象值
function foo(a = 1, b = 10) {
  arguments[0] = 9;
  arguments[1] = 99;
  console.log(a, b); //1, 10
}
foo();

// 实例
function f2(a) {
  console.log(a);
  var a;
  console.log(a);
  console.log(arguments[0]);
}
f2(10);

// 经过变量提升后：
function f2(a) {
  var a;
  console.log(a);
  console.log(a);
  console.log(arguments[0]);
}
f2(10);

// var a会被归纳，由于a已经有值，故不会变为undefined
```

```js
var a = {};
var b = { name: 'ZS' };
var c = {};
c[a] = 'demo1';
c[b] = 'demo2';

console.log(c[a]); // demo2
console.log(c); // Object {[object Object]: "demo2"}
```

c[a]、c[b]隐式的将对象 a，b 使用了 toString（）方法进行了转换，然后再对属性赋值。
即：Object.prototype.toString.call(a) ==> [object Object]
因此，c = { [object Object]: 'demo1'} ==> c = {[object Object]: 'demo2' }

```js
var array1 = Array(3);
array1[0] = 2;
var result = array1.map(elem => '1');

// ['1', empty * 2]
```

```js
var setPerson = function(person) {
  person.name = 'kevin';
  person = { name: 'Nick' };
  console.log(person.name); // Nick
  person.name = 'Jay';
  console.log(person.name); // Jay
};
var person = { name: 'Alan' };
setPerson(person);
console.log(person.name); // Kevin
```

```js
var execFunc = () => console.log('a');
setTimeout(execFunc, 0);
console.log('000');
execFunc = () => console.log('b');

// '000', 'a'
```

`window.setTimeout(hello(userName),3000);`
这将使 hello 函数立即执行，并将'返回值'作为调用句柄传递给 setTimeout 函数

方法 1：
使用'字符串形式'可以达到想要的结果:
`window.setTimeout("hello(userName)",3000);`
但是，此处的 username 变量必须处于全局环境下

```js
// 方法2：
function hello(_name) {
  alert('hello,' + _name);
}
// 创建一个函数，用于返回一个无参数函数
function _hello(_name) {
  return function() {
    hello(_name);
  };
}
window.setTimeout(_hello(userName), 3000);
// 使用_hello(userName)来返回一个不带参数的函数句柄，从而实现了参数传递的功能
```

```js
for (var i = { j: 0 }; i.j < 5; i.j++) {
  (function(i) {
    setTimeout(function() {
      console.log(i.j);
    }, 0);
  })(JSON.parse(JSON.stringify(i)));
}

// 0, 1, 2, 3, 4

for (var i = { j: 0 }; i.j < 5; i.j++) {
  (function(i) {
    setTimeout(function() {
      console.log(i.j);
    }, 0);
  })(i);
}

// 5, 5, 5, 5, 5
```

```js
var name = 'Tom';
(function() {
  if (typeof name == 'undefined') {
    var name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
// Goodbye Jack
```

```js
var name = 'Tom';
(function() {
  if (typeof name == 'undefined') {
    name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

### 下面代码分别输出什么？

```js
function foo() {
  'use strict';
  console.log(this.a);
}

function bar() {
  console.log(this.a);
}

var a = "this is a 'a'";

bar(); // "this is a 'a'"
foo(); // "TypeError: Cannot read property 'a' of undefined
```

接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么?因为在本 例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。

bar() 调用使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined

### 下面这段代码的执行结果是什么？

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
```

继续问，怎么实现期望一共返回 1-5，5 个值，并且一秒返回一个值？

> 这段代码,我们预期的结果是：分别输出数字 1~5，每秒一次，每次一个。但是实际结果却是：这段代码在运行时会以每秒一次的频率输出五次 6。

> 这是为什么？

> 首先解释 6 是从哪里来的。这个循环的终止条件是 `i` 不再 `<=5`。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。仔细想一下，这好像又是显而易见的，<u>延迟函数的回调会在循环结束时才执行</u>。事实上， 当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，<u>所有的回调函数依然是在循 环结束后才会被执行</u>，因此会每次输出一个 6 出来。

因为外层作用域中只有一个`i`，这个`i`被封闭进去，而不是每个迭代的函数会封闭一个新的`i`.

> ---以上解释来自《你不知道的 JavaScript（上卷）》第五章

这样就可以实现期望一共返回 1-5，5 个值，并且一秒返回一个值

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}

// or

for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, j * 1000);
  })(i);
}

// or

for (var i = 1; i <= 5; i++) {
  let j = i;
  setTimeout(function timer() {
    console.log(j);
  }, j * 1000);
}
```

let 声明只属于作用域块。`for`循环头部的`let i`不只是为 for 循环本身声明了一个`i`，而是为循环的每一次迭代都重新声明了一个新的`i`。这意味着 loop 迭代内部创建的闭包封闭的是每次迭代中的变量，就像期望的那样。

或者

```js
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的
作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。
