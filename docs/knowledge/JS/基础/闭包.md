---
title: 闭包
date: '2020-10-26'
draft: true
---

### 闭包

闭包是指有权访问另一个函数作用域中的变量的函数。

当内部函数被保存到外部时，将会生成闭包。生成闭包后，内部函数依旧可以访问其所在的外部函数的变量。

**闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量**。

闭包是函数和声明该函数的词法环境的组合。词法作用域中使用的域，是变量在代码中声明的位置所决定的。闭包是即使被外部函数返回，依然可以访问到外部（封闭）函数作用域的函数。

闭包是就是函数中的函数，里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。
闭包的作用：

1. 使用闭包可以访问函数中的变量。
2. 可以使变量长期保存在内存中，生命周期比较长。

闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向 null。

- 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在 js 中，函数即闭包，只有函数才会产生作用域的概念

- 闭包有三个特性：
  1. 函数嵌套函数
  2. 函数内部可以引用外部的参数和变量
  3. 参数和变量不会被垃圾回收机制回收

详细解释：

当函数执行时，会创建一个称为**执行期上下文的内部对象**，执行期上下文定义了一个函数执行时的环境。
函数还会获得它所在作用域的**作用域链**，是存储函数能够访问的所有执行期上下文对象的集合，即这个函数中能够访问到的东西都是沿着作用域链向上查找直到全局作用域。

函数每次执行时对应的执行期上下文都是独一无二的，当函数执行完毕，函数都会失去对这个作用域链的引用，JS 的垃圾回收机制是采用引用计数策略，如果一块内存不再被引用了那么这块内存就会被释放。

但是，当闭包存在时，即内部函数保留了对外部变量的引用时，这个作用域链就不会被销毁，此时内部函数依旧可以访问其所在的外部函数的变量，这就是闭包。

闭包就是一个函数对另一个函数变量的引用（有权访问另一个函数作用域的函数都是闭包），因为变量一直被引用所以不会被回收，这就会增加内存消耗，导致内存泄漏。

闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。
可以把闭包简单理解成 "定义在一个函数内部的函数"，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包有如下特性：

1. JavaScript 允许你使用在当前函数以外定义的变量
2. 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量
3. 闭包可以更新外部变量的值
4. 用闭包模拟私有方法
   由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```js
function A() {
  let a = 1;
  window.B = function() {
    console.log(a);
  };
}
A();
B(); // 1
```

很多人对于闭包的解释可能是函数嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点。

在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。

闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

```js
function A() {
  let a = 1;
  function B() {
    console.log(a);
  }
  return B;
}
```

你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。

### 闭包的使用场景

- 创建特权方法用于访问控制
- 事件处理程序及回调
- 利用闭包实现数据私有化或模拟私有方法。这个方式也称为模块模式（module pattern）
- 部分参数函数（partial applications）柯里化（currying）
- 函数作为一个返回值
- 函数作为参数传递
- 封装变量，收敛权限。在函数外面根本没有接口修改私有变量和函数，保证了数据的安全。
- 自执行函数就是不用调用只要定义完成就立即执行的函数。
- cached 对象储存。
- 封装私有变量

  ```js
  function Counter() {
    let count = 0;
    this.plus = function() {
      return ++count;
    };
    this.minus = function() {
      return --count;
    };
    this.getCount = function() {
      return count;
    };
  }

  const counter = new Counter();
  counter.puls();
  counter.puls();
  console.log(counter.getCount());
  ```

- 实现一个计数器。 实现一个 foo 函数 可以这么使用

  ```js
  a = foo();
  b = foo();
  c = foo();
  // a === 1;b === 2;c === 3;
  foo.clear();
  d = foo(); //d === 1;
  ```

  ```js
  function myIndex() {
    var index = 1;

    function foo() {
      return index++;
    }

    foo.clear = function() {
      index = 1;
    };
    return foo;
  }

  var foo = myIndex();
  ```

### 循环中使用闭包解决 `var` 定义函数的问题

```js
for (var i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

解决方法有 3 种

第一种，使用`立即执行函数`方式

```js
for (var i = 1; i < 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

第二种，使用 ES6 的`let`

```js
for (let i = 1; i < 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

因为对于 `let` 来说，他会创建一个块级作用域，相当于

```js
{ // 形成块级作用域
  let i = 0
  {
    let ii = i
    setTimeout( function timer() {
        console.log( ii );
    }, i*1000 );
  }
  i++
  {
    let ii = i
  }
  i++
  {
    let ii = i
  }
  ...
}
```

第三种，使用`setTimeout的第三个参数`

```js
for (var i = 1; i < 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j);
    },
    i * 1000,
    i,
  );
}
```
