---
title: 懒加载的实现原理
date: '2020-10-26'
draft: true
---

### 什么是函数式编程

- 函数式编程是一种"编程范式"，主要思想是把运算过程尽量写成一系列嵌套的函数调用
- 例如：var result = subtract(multiply(add(1,2), 3), 4);

- 函数式编程的特点：
  - 函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值
  - 只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值
  - 没有"副作用"：所有功能只为返回一个新的值，不修改外部变量
  - 引用透明：运行不依赖于外部变量，只依赖于输入的参数
- 函数式编程的优点：
  - 代码简洁，接近自然语言，易于理解
  - 便于维护，利于测试、除错、组合
  - 易于“并发编程“，不用担心一个线程的数据，被另一个线程修改
  - 可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机

### 函数式编程 compose

实现以下功能：

```js
compose([a, b, c])('参数')
=>
a( b( c('参数') ) )
```

```js
function compose(funcs) {
  var len = funcs.length;
  var index = len - 1;

  for (let i = 0; i < len; i++) {
    if (typeof funcs[i] !== 'function') {
      throw new TypeError('Expected a function');
    }
  }

  return function(...args) {
    let result = funcs[index](...args); // 第一次
    while (--index >= 0) {
      result = funcs[index](result);
    }
    return result;
  };
}
```

测试：

```js
function a(str) {
  return `a ${str}`;
}
function b(str) {
  return `b ${str}`;
}
function c(str) {
  return `c ${str}`;
}

const abc = compose([a, b, c]);
abc('huyao');
```

### 什么是函数柯里化 Currying)

```js
function curry(fn) {
  const args = Array.prototype.slice.call(arguments, 1);
  return function() {
    const innerArgs = Array.prototype.slice.call(arguments);
    const finalArgs = args.concat(innerArgs);
    return fn.apply(null, finalArgs);
  };
}
```

- 柯里化：

  - 通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数
  - 期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程
  - 柯里化的作用：延迟计算；参数复用；动态创建函数

- 柯里化的缺点：
  - 函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等）

实现一个 add 方法，使计算结果能够满足如下预期：

```js
add(1)(2)(3) = 6;
add(1, 2)(3) = 10;
```

实现方法： 做一个闭包，返回一个函数，这个函数每次执行会改写闭包里面记录参数的数组。当这个函数判断参数个数够了，就去执行它。

```js
function curry(func) {
  // 存储已传入参数
  let _args = [];

  // 做一个闭包
  function _curry(...args) {
    // 把参数合并
    _args = _args.concat(args);

    // 如果参数够了就执行
    if (_args.length >= func.length) {
      const result = func(..._args);
      _args = [];
      return result;
    }
    // 继续返回此函数
    else {
      return _curry;
    }
  }
  return _curry;
}
```

```js
// 测试代码
function add1(a, b, c) {
  return a + b + c;
}
let testAdd = curry(add1);
console.log(testAdd(1)(2)(3));
console.log(testAdd(1, 2)(3));
console.log(testAdd(1)(2, 3));
```

### 你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？

柯里化（currying）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。这种技术帮助编写函数式风格的代码，使代码更易读、紧凑。值得注意的是，对于需要被 curry 的函数，它需要从一个函数开始，然后分解成一系列函数，每个函数都需要一个参数。

```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }

  function _curried(depth, args) {
    return function(newArgument) {
      if (depth - 1 === 0) {
        return fn(...args, newArgument);
      }
      return _curried(depth - 1, [...args, newArgument]);
    };
  }

  return _curried(fn.length, []);
}

function add(a, b) {
  return a + b;
}

var curriedAdd = curry(add);
var addFive = curriedAdd(5);

var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

```js
console.log(mul(2)(3)(4)); // output : 24
console.log(mul(4)(3)(4)); // output : 48

function mul(x) {
  return function(y) {
    // anonymous function
    return function(z) {
      // anonymous function
      return x * y * z;
    };
  };
}
```
