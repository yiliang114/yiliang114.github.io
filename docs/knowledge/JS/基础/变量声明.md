---
title: ES6
date: '2020-10-26'
draft: true
---

### 为什么 var 可以重复声明

当我们执行代码时，我们可以简单的理解为新变量分配一块儿内存，命名为 a，并赋值为 2，但在运行的时候编译器与引擎还会进行两项额外的操作：

判断变量是否已经声明：首先编译器对代码进行分析拆解，从左至右遇见 var a，则编译器会询问作用域是否已经存在叫 a 的变量了，如果不存在，则招呼作用域声明一个新的变量 a，若已经存在，则忽略 var 继续向下编译，这时 a = 2 被编译成可执行的代码供引擎使用。
引擎遇见 a=2 时同样会询问在当前的作用域下是否有变量 a，若存在，则将 a 赋值为 2（由于第一步编译器忽略了重复声明的 var，且作用域中已经有 a，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量 a 则将其赋值 2，若没有找到，则招呼作用域声明一个变量 a 并赋值为 2

### 全局作用域中，用 const 和 let 声明的变量不在 window 上

在 ES5 中，全局变量直接挂载到全局对象的属性上，所以能在 window 上看到 var 声明的变量
在 ES6 中，全局对象的属性和全局变量脱钩，但是为了保持兼容性，旧的不变，所以 var、function 声明的全局变量依然可以在 window 对象上看到，而 let、const 声明的全局变量在 window 对象上看不到

### var、let 和 const 区别

- var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会
- let 有暂时性死区
- let 和 const 定义的变量不会出现变量提升，而 var 定义的变量会提升。
- let 和 const 是 JS 中的块级作用域
- 同一作用域下 let 和 const 不允许重复声明(会抛出错误)
- let 和 const 定义的变量在定义语句之前，如果使用会抛出错误(形成了暂时性死区)，而 var 不会。
- const 声明一个只读的常量。一旦声明，常量的值就不能改变(如果声明是一个对象，那么不能改变的是对象的引用地址)

let/const 也存在变量声明提升，只是没有初始化分配内存。 一个变量有三个操作，声明(提到作用域顶部)，初始化(赋默认值)，赋值(继续赋值)
let 是一开始变量声明提升，然后没有初始化分配内存，代码执行到那行初始化，之后对变量继续操作是赋值。因为没有初始化分配内存，所以会报错，这是暂时性死区

```js
function foo() {
  // 所有变量在函数中都可访问
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';

  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}

console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

// 用 var 声明的变量在函数作用域上都可访问
console.log(bar); // bar
// let 和 const 定义的变量在它们被定义的语句块之外不可访问
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。

console.log(foo); // undefined

var foo = 'foo';

console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization

let baz = 'baz';

console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization

const bar = 'bar';
// 用var重复声明不会报错，但let和const会。

var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"

let baz = 'baz';
let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared
// let和const的区别在于：let允许多次赋值，而const只允许一次。

// 这样不会报错。
let foo = 'foo';
foo = 'bar';

// 这样会报错。
const baz = 'baz';
baz = 'qux';
```

### let 有什么用，有了 var 为什么还要用 let？

在`ES6`之前，声明变量只能用`var`，`var`方式声明变量其实是很不合理的，准确的说，是因为`ES5`里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如`for`循环`var`变量泄露，变量覆盖等问题。`let`声明的变量拥有自己的块级作用域，且修复了`var`声明变量带来的变量提升问题。

总结：

- 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部
- `var` 存在提升，我们能在声明之前使用。`let`、`const` 因为暂时性死区的原因，不能在声明前使用
- `var` 在全局作用域下声明变量会导致变量挂载在 `window` 上，其他两者不会
- `let` 和 `const` 作用基本一致，但是后者声明的变量不能再次赋值

### 变量声明提升

`js` 代码在运行前都会进行 `AST` 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 `AST` 解析，这里也可以说是形成词法作用域的主要原因

### 请解释变量提升 hoisting

变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用`var`关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。我们用几个例子来解释一下。

```js
// 用 var 声明得到提升
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// 用 let/const 声明不会提升
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。

```js
// 函数声明
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// 函数表达式
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```

### javascript 变量声明优先级

function 声明的优先级比 var 声明高，也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明，如下：

```js
alert(a); //输出：function a(){ alert('我是函数') }

function a() {
  alert('我是函数');
} //
var a = '我是变量';

alert(a); //输出：'我是变量'
```

这代码等效于：

```js
function a() {
  alert('我是函数');
}
var a; //hoisting
alert(a); //输出：function a(){ alert('我是函数') }
a = '我是变量'; //赋值
alert(a); //输出：'我是变量'
```

这短短的代码里面其实说明了两个问题：

function 声明的优先级高于 var 声明：第一个 alert 输出可以看出 var a;被 function a(){}覆盖掉了。
赋值优先于函数声明：第二个 alert 输出可以看出 a='我是变量'又把 function a(){}覆盖掉了。
把一个变量添加到作用域中除有很多方法，如下：

javascript 语言预定义的，比如说 this,arguments
formal parameter(也就是中文说的形参吧)
var 声明并赋值，比如说 var a = 10;
var 声明不赋值，比如说 var a;
function 声明，比如说 function a(){};
我们来看看他们之间的优先级：

var 声明并赋值优先级高于 function 声明 这个上面已经说了。

function 声明优先级高于 formal parameter

```js
function fnTest(a) {
  alert(a);
  function a() {
    return '我优先';
  }
}
fnTest(100); //:function a(){return "我优先"}。可以看出 function 声明覆盖了`formal parameter`。
// formal parameter 优先级高于预定义变量
function fnTest(arguments) {
  alert(arguments);
}
fnTest(100); //:100。说明`formal parameter`优先级比预定义的 arguments 高
```

对比以下：

```js
function fnTest(a) {
  alert(arguments);
}
fnTest(100); //:[Object Arguments] {0:100,length:1}。当没有冲突时输出便是预定义的 arguments
// formal parameter 优先级高于 var 声明不赋值
function fnTest(a) {
  alert(a);
  var a;
}
fnTest(100); //:100。很明显，不多说
```

预定义变量优先级高于 var 声明不赋值

```js
function fnTest() {
  alert(arguments);
  var arguments;
}
fnTest(); //:[Object Arguments]。不是 undefined，说明 arguments 没有被 var 声明覆盖
// var 声明不赋值优先级高于函数外部作用域的其他所有声明;
function fnTest() {
  alert(fnTest);
  var fnTest;
}
fnTest(); //:undefined。
```

对比如下：

```js
function fnTest() {
  //
  alert(fnTest); //
} //
fnTest(); //输出 function fnTest(){alert(fnTest);}
```

这也正好印证了作用域链查找变量的方式：在局部作用域里查找（若找到则返回，不必往下继续查找） ==> 在上一级作用域里查找... ==> 直到全局作用域（若找不到则返回 typeError）

最后看看下面的综合例子：

```js
function fnTest(arguments) {
  alert(arguments); //function arguments(){return "hello world"}
  var arguments = 99;
  function arguments() {
    return 'hello world';
  }
  alert(arguments); //99
}
fnTest(100);
```

### freeze 冻结对象

有什么办法可以让`const obj = {a: 1};`的值不可变？

> A: </br>如果真的想讲对象冻结，应该使用 `Object.freeze` 方法。
> `const foo = Object.freeze({}); foo.prop= 123;` // 不起作用
