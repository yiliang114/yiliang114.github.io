---
title: JS 基本类型
date: '2020-10-26'
draft: true
---

### JS 数据类型

6 种原始类型（基本类型）：

1. undefined
2. null
3. number
4. boolean
5. string
6. symbol

**注意： 原始类型不包含 Object**

引用类型：

1. Object
2. Array
3. Function
4. String(很多场景下 string 会被强制转化成 String 类型，但其实也是对象类型)

除了会在必要的情况下强转类型以外，原始类型还有一些坑。

原始类型与引用类型存储的方式也不同，原始数据类型存储在栈中，而引用数据类型存储在堆中。

原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()。此时你肯定会有疑问，这不对呀，明明 '1'.toString() 是可以使用的。其实在这种情况下，'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。

基本类型存储的是值类型。

在 JS 中的 number 类型是浮点类型，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3。

null 是基本类型而不是 Object 类型，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

#### 类型差别

值类型和引用类型 值类型存储的是值 赋值之后原变量的值不改变 引用类型存储的是地址 赋值之后是把原变量的引用地址赋值给新变量 新变量改变原来的会跟着改变

栈：原始数据类型（undefined，null，boolean，number、string、symbol）
堆：引用数据类型（object、array、function）

两种类型的区别是：存储位置不同；
原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

Object 是 JavaScript 中所有对象的父对象
数据封装类对象：Object、Array、Boolean、Number 和 String
其他对象：Function、Arguments、Math、Date、RegExp、Error

### JS 中使用 typeof 能得到哪些类型？

typeof null 的结果是 object, 实际这是 typeof 的一个 bug, null 是原始值，非引用类型。因为设计的时候`null`是全 0，而对象是`000`开头，所以有这个误判。

1. boolean
2. number
3. string
4. undefined
5. symbol
6. object
7. function

### JS 对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？

在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

```js
const a = [];
```

对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001，再看以下代码

```js
const a = [];
const b = a;
b.push(1);
```

当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变。

接下来我们来看函数参数是对象的情况:

```js
function test(person) {
  person.age = 26;
  person = {
    name: 'yyy',
    age: 30,
  };

  return person;
}
const p1 = {
  name: 'yiliang114',
  age: 25,
};
const p2 = test(p1);
console.log(p1); // -> ?
console.log(p2); // -> ?

// {name: "yiliang114", age: 26}
// {name: "yyy", age: 30}
```

对于以上代码，你是否能正确的写出结果呢？接下来让我为你解析一番：

1. 首先，函数传参是传递对象指针的副本
1. 到函数内部修改参数的属性这步，我相信大家都知道，当前 p1 的值也被修改了
1. 但是当我们重新为 person 分配了一个对象时就出现了分歧

所以最后 person 拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的。

### 如何判断某变量是否为数组数据类型

在 ECMA Script5 中定义了新方法 Array.isArray(), 保证其兼容性，最好的方法如下

```js
if (typeof Array.isArray === 'undefined') {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```

### 类型转换

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

1. 转换为布尔值
1. 转换为数字
1. 转换为字符串

#### 转 Boolean

在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

#### 对象转原始类型

对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
  [Symbol.toPrimitive]() {
    return 2;
  },
};
1 + a; // => 3
```

#### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

1. 运算中其中一方为字符串，那么就会把另一方也转换为字符串
1. 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + '1'; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
- 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
- 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

```js
'a' + +'b'; // -> "aNaN"
```

因为 + 'b' 等于 NaN，所以结果为 "aNaN"，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```js
4 * '3'; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

#### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
1. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
};
a > -1; // true
```

在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。

### undefined 和 null 的区别

在 Javascript 中，null 是一个赋值，可以赋值给一个表示该值的变量，它没有价值。另一方面，Undefined 表示已经声明了一个变量，但是没有与之相关的价值。

### null，undefined 的区别？

- undefined 表示不存在这个值。
- undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined
- 例如变量被声明了，但没有赋值时，就等于 undefined

- null 表示一个对象被定义了，值为“空值”
- null : 是一个对象(空对象, 没有任何属性和方法)
- 例如作为函数的参数，表示该函数的参数不是对象；

- 在验证 null 时，一定要使用　=== ，因为 == 无法分别 null 和　 undefined

### == 和 === 有什么区别？

=== 是一个严格的操作符。' == '和' === '之间的关键区别在于严格的运算符匹配值和类型，而不仅仅是值对于 `==` 来说，如果对比双方的类型**不一样**的话，就会进行**类型转换**.

```js
// Example of comparators
0 == false; // true
0 === false; // false

2 == '2'; // true
2 === '2'; // false
```

假如我们需要对比 `x` 和 `y` 是否相同，就会进行如下判断流程：

1. 首先会判断两者类型是否**相同**。相同的话就是比大小了
2. 类型不相同的话，那么就会进行类型转换
3. 会先判断是否在对比 `null` 和 `undefined`，是的话就会返回 `true`
4. 判断两者类型是否为 `string` 和 `number`，是的话就会将字符串转换为 `number`

   ```js
   1 == '1'
         ↓
   1 ==  1
   ```

5. 判断其中一方是否为 `boolean`，是的话就会把 `boolean` 转为 `number` 再进行判断

   ```js
   '1' == true
           ↓
   '1' ==  1
           ↓
    1  ==  1
   ```

6. 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断

   ```js
   '1' == { name: 'yiliang114' }
           ↓
   '1' == '[object Object]'
   ```

如果你觉得记忆步骤太麻烦的话，我还提供了流程图供大家使用：

![](https://wire.cdn-go.cn/wire-cdn/b23befc0/blog/images/167c4a2627fe55f1.jpg)

对于 `===` 来说就简单多了，就是判断两者类型和值是否相同。

== 和 === 的工作原理是一样的，== 和 === 都会检查操作数的类型。

== 允许在相等比较中进行强制类型转换，然后进行值的比较，
而 === 不允许，只有类型相同并且值相等时，才返回 true。

== 如果两者类型不同，首先需要进行类型转换。然后比较值是否相等，具体流程如下:

1. 首先判断两者类型是否相同，如果相等，判断值是否相等.
2. 如果类型不同，进行类型转换
3. 判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .
4. 判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number
5. 判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断
6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断

引用下 winter 的总结就是：**只要记住 `null` 只和`undefined` 相等，有 `number` 都转 `number`，有 `boolean` 也转 `number`，有 `string` 都转 `string`，对象互相不等，`NaN` 互相不等就可以了**。

扩展：
0.1 + 0.2 === 0.3 // false
0.1 + 0.2 // 0.30000000000000004
原因：计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数，但不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差
为了·解决这个问题可以使用 toFixed()
(0.1 + 0.2).toFixed(10) // 0.3

### `==`和`===`的区别是什么？

`==`是抽象相等运算符，而`===`是严格相等运算符。`==`运算符是在进行必要的类型转换后，再比较。`===`运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回`false`。使用`==`时，可能发生一些特别的事情，例如：

```js
1 == '1'; // true
1 == [1]; // true
1 == true; // true
0 == ''; // true
0 == '0'; // true
0 == false; // true
```

我的建议是从不使用`==`运算符，除了方便与`null`或`undefined`比较时，`a == null`如果`a`为`null`或`undefined`将返回`true`。

```js
var a = null;
console.log(a == null); // true
console.log(a == undefined); // true
```

### Object.is() 与比较操作符 ===、== 有什么区别

以下情况，Object.is 认为是相等

- 两个值都是 undefined
- 两个值都是 null
- 两个值都是 true 或者都是 false
- 两个值是由相同个数的字符按照相同的顺序组成的字符串
- 两个值指向同一个对象
- 两个值都是数字并且
- 都是正零 +0
- 都是负零 -0
- 都是 NaN
- 都是除零和 NaN 外的其它同一个数字

Object.is() 类似于 ===，但是有一些细微差别

1. NaN 和 NaN 相等
1. -0 和 +0 不相等

#### null 和 undefined 的区别？

1. `null`是一个表示"无"的对象，转为数值时为 0；`undefined`是一个表示"无"的原始值，转为数值时为`NaN`。
2. 当声明的变量还未被初始化时，变量的默认值为`undefined`。
3. `null`用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
4. `undefined`表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：
   1. 变量被声明了，但没有赋值时，就等于 undefined。
   2. 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
   3. 对象没有赋值的属性，该属性的值为 undefined。
   4. 函数没有返回值时，默认返回 undefined。
5. `null`表示"没有对象"，即该处不应该有值。典型用法是：
   1. 作为函数的参数，表示该函数的参数不是对象。
   2. 作为对象原型链的终点。

### 描述以下变量的区别：`null`，`undefined` 或 `undeclared`？该如何检测它们？

`undefined`是 Js 语言类型，而`undeclared`是一种 Js 语法错误。在 JavaScript 中，有两个表示‘空’的值`undefined`和`null`，`undefined`是一个值为`undefined` 的类型。JavaScript 语言也定义了一个全局变量，它的值是 `undefined`，这个变量也被称为`undefined`。 但是这个变量不是一个常量，也不是一个关键字。这意味着它的值可以轻易被覆盖。为了避免可能对`undefined`值的改变，一个常用的技巧是使用一个传递到匿名包装器的额外参数。在调用时，这个参数不会获取任何值。如下例子：

```js
var undefined = 123;
(function(something, foo, undefined) {
  // 局部作用域里的 undefined 变量重新获得了 `undefined` 值
})('Hello World', 42);
```

### 从内存来看 null 和 undefined 本质的区别是什么？

给一个全局变量赋值为 null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为 null，或者局部变量赋值为 null,相当于给这个属性分配了一块空的内存，然后值为 null， JS 会回收全局变量为 null 的对象。

给一个全局变量赋值为 undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为 undefined，说明这个值为空值

在验证 null 时，一定要使用　=== ，因为 ==无法分别 null 和　 undefined

扩展：null，undefined 或 undeclared？该如何检测它们
未定义的属性、定义未赋值的为 undefined，JavaScript 访问不会报错；null 是一种特殊的 object；NaN 是一种特殊的 number；undeclared 是未声明也未赋值的变量，JavaScript 访问会报错

### JavaScript 中 undefined 和 not defined 的区别是什么

```js
var x; // declaring x
console.log(x); // output: undefined
```

```js
var x; // Declaration
typeof x === 'undefined'; // Will return true
```

```js
console.log(y); // Output: ReferenceError: y is not defined
```

### == 运算符判断相等的流程是怎样的

1. 如果两个值类型相同，按照===比较方法进行比较
2. 如果类型不同，使用如下规则进行比较
3. 如果其中一个值是 null，另一个是 undefined，它们相等
4. 如果一个值是**数字**另一个是**字符串**，将**字符串转换为数字**进行比较
5. 如果有布尔类型，将**true 转换为 1，false 转换为 0**，然后用==规则继续比较
6. 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较
7. **其他所有情况都认为不相等**

### 对象到字符串的转换步骤

1. 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果
2. 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果
3. 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError

### 对象到数字的转换步骤

1. 如果对象有 valueOf()方法并且返回元素值，javascript 将返回值转换为数字作为结果
2. 否则，如果对象有 toString()并且返回原始值，javascript 将返回结果转换为数字作为结果
3. 否则，throws a TypeError

### <,>,<=,>=的比较规则

所有比较运算符都支持任意类型，但是**比较只支持数字和字符串**，所以需要执行必要的转换然后进行比较，转换规则如下:

1. 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错
2. 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）
3. 否则，如果有一个操作数不是字符串，**将两个操作数转换为数字**进行比较

### +运算符工作流程

1. 如果有操作数是对象，转换为原始值
2. 此时如果有**一个操作数是字符串**，其他的操作数都转换为字符串并执行连接
3. 否则：**所有操作数都转换为数字并执行加法**

```js
'100' + 100; // "100100"
100 + '100'; // "100100"
100 + true; // 101
100 + false; // 100
100 + undefined; //NaN
100 + null; // 100
// + 会自动转换后面跟随的值类型
```

### 函数内部 arguments 变量有哪些特性,有哪些属性,如何将它转换为数组

- arguments 所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象
- arguments[index]分别对应函数调用时的实参，并且通过 arguments 修改实参时会同时修改实参
- arguments.length 为实参的个数（Function.length 表示形参长度）
- arguments.callee 为当前正在执行的函数本身，使用这个属性进行递归调用时需注意 this 的变化
- arguments.caller 为调用当前函数的函数（已被遗弃）
- 转换为数组：<code>var args = Array.prototype.slice.call(arguments, 0);</code>

### JS 能表示最大的数和最小的数

64 位浮点型，符号位 1 位， 指数位 11 位， 尾数 52 位。在 JavaScript 中，2^53 是最大的值，没有比这更大的值了。

### array、null、object 数据如何判断？

typeof 方法判断`array、null、object`类型的数据，都会返回`object`。

设变量为`i` ,那么`i== null`为 true,则 i 为 null;
i.constructor.name 如果是`Array`则为数组，如果是`Object`则是简单的 object 类型数据。

还可以`b.constructor == Array`来进行是否是数组的判断；
还可以`b.constructor == Object`来进行是否是对象的判断；
