---
title: JS 基本类型
date: '2020-10-26'
draft: true
---

### 数据类型

6 种原始类型（基本类型）：

1. undefined
2. null
3. number
4. boolean
5. string
6. symbol

**注意： 原始类型不包含 Object**

引用类型：

1. Object
2. Array
3. Function
4. String(很多场景下 string 会被强制转化成 String 类型，但其实也是对象类型)

原始类型与引用类型存储的方式也不同，原始数据类型存储在栈中，而引用数据类型存储在堆中。

原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()。此时你肯定会有疑问，这不对呀，明明 '1'.toString() 是可以使用的。其实在这种情况下，'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。

在 JS 中的 number 类型是浮点类型，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3。

null 是基本类型而不是 Object 类型，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

#### 类型差别

值类型和引用类型 值类型存储的是值 赋值之后原变量的值不改变 引用类型存储的是地址 赋值之后是把原变量的引用地址赋值给新变量 新变量改变原来的会跟着改变

栈：原始数据类型（undefined，null，boolean，number、string、symbol）
堆：引用数据类型（object、array、function）

两种类型的区别是：存储位置不同；
原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

Object 是 JavaScript 中所有对象的父对象
数据封装类对象：Object、Array、Boolean、Number 和 String
其他对象：Function、Arguments、Math、Date、RegExp、Error

### 使用 typeof 能得到哪些类型？

typeof null 的结果是 object, 实际这是 typeof 的一个 bug, null 是原始值，非引用类型。因为设计的时候`null`是全 0，而对象是`000`开头，所以有这个误判。

1. boolean
2. number
3. string
4. undefined
5. symbol
6. object
7. function

### 类型转换

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

1. 转换为布尔值
1. 转换为数字
1. 转换为字符串

#### 转 Boolean

在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

#### 对象转原始类型

对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
  [Symbol.toPrimitive]() {
    return 2;
  },
};
1 + a; // => 3
```

#### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

1. 运算中其中一方为字符串，那么就会把另一方也转换为字符串
1. 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + '1'; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
- 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
- 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

```js
'a' + +'b'; // -> "aNaN"
```

因为 + 'b' 等于 NaN，所以结果为 "aNaN"，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```js
4 * '3'; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

#### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
1. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
};
a > -1; // true
```

在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。

#### 对象到字符串的转换步骤

1. 如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果
2. 如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果
3. 否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError

#### 对象到数字的转换步骤

1. 如果对象有 valueOf()方法并且返回元素值，javascript 将返回值转换为数字作为结果
2. 否则，如果对象有 toString()并且返回原始值，javascript 将返回结果转换为数字作为结果
3. 否则，throws a TypeError

#### <,>,<=,>=的比较规则

所有比较运算符都支持任意类型，但是**比较只支持数字和字符串**，所以需要执行必要的转换然后进行比较，转换规则如下:

1. 如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错
2. 经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）
3. 否则，如果有一个操作数不是字符串，**将两个操作数转换为数字**进行比较

#### +运算符工作流程

1. 如果有操作数是对象，转换为原始值
2. 此时如果有**一个操作数是字符串**，其他的操作数都转换为字符串并执行连接
3. 否则：**所有操作数都转换为数字并执行加法**

```js
'100' + 100; // "100100"
100 + '100'; // "100100"
100 + true; // 101
100 + false; // 100
100 + undefined; //NaN
100 + null; // 100
// + 会自动转换后面跟随的值类型
```

### undefined 和 null 的区别

null 是一个赋值，可以赋值给一个表示该值的变量，它没有价值。另一方面，Undefined 表示已经声明了一个变量，但是没有与之相关的价值。

- undefined 表示不存在这个值。
- undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined
- 例如变量被声明了，但没有赋值时，就等于 undefined

- null 表示一个对象被定义了，值为“空值”
- null : 是一个对象(空对象, 没有任何属性和方法)
- 例如作为函数的参数，表示该函数的参数不是对象；

- 在验证 null 时，一定要使用　=== ，因为 == 无法分别 null 和　 undefined

### undefined 和 not defined 的区别是什么

```js
var x; // declaring x
console.log(x); // output: undefined
```

```js
var x; // Declaration
typeof x === 'undefined'; // Will return true
```

```js
console.log(y); // Output: ReferenceError: y is not defined
```

### == 和 === 有什么区别？

=== 是一个严格的操作符。' == '和' === '之间的关键区别在于严格的运算符匹配值和类型，而不仅仅是值对于 `==` 来说，如果对比双方的类型**不一样**的话，就会进行**类型转换**.

```js
// Example of comparators
0 == false; // true
0 === false; // false

2 == '2'; // true
2 === '2'; // false
```

假如我们需要对比 `x` 和 `y` 是否相同，就会进行如下判断流程：

1. 首先会判断两者类型是否**相同**。相同的话就是比大小了
2. 类型不相同的话，那么就会进行类型转换
3. 会先判断是否在对比 `null` 和 `undefined`，是的话就会返回 `true`
4. 判断两者类型是否为 `string` 和 `number`，是的话就会将字符串转换为 `number`

   ```js
   1 == '1'
         ↓
   1 ==  1
   ```

5. 判断其中一方是否为 `boolean`，是的话就会把 `boolean` 转为 `number` 再进行判断

   ```js
   '1' == true
           ↓
   '1' ==  1
           ↓
    1  ==  1
   ```

6. 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为原始类型再进行判断

   ```js
   '1' == { name: 'yiliang114' }
           ↓
   '1' == '[object Object]'
   ```

== 允许在相等比较中进行强制类型转换，然后进行值的比较，
而 === 不允许，只有类型相同并且值相等时，才返回 true。

== 如果两者类型不同，首先需要进行类型转换。然后比较值是否相等，具体流程如下:

1. 首先判断两者类型是否相同，如果相等，判断值是否相等.
2. 如果类型不同，进行类型转换
3. 判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .
4. 判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number
5. 判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断
6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断

**只要记住 `null` 只和`undefined` 相等，有 `number` 都转 `number`，有 `boolean` 也转 `number`，有 `string` 都转 `string`，对象互相不等，`NaN` 互相不等就可以了**。

### == 运算符判断相等的流程是怎样的

1. 如果两个值类型相同，按照===比较方法进行比较
2. 如果类型不同，使用如下规则进行比较
3. 如果其中一个值是 null，另一个是 undefined，它们相等
4. 如果一个值是**数字**另一个是**字符串**，将**字符串转换为数字**进行比较
5. 如果有布尔类型，将**true 转换为 1，false 转换为 0**，然后用==规则继续比较
6. 如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较
7. **其他所有情况都认为不相等**

### 0.1 + 0.2 === 0.3

0.1 + 0.2 === 0.3 // false
0.1 + 0.2 // 0.30000000000000004
原因：计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数，但不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差
为了·解决这个问题可以使用 toFixed()

(0.1 + 0.2).toFixed(10) // 0.3

#### null 和 undefined 的区别？

1. `null`是一个表示"无"的对象，转为数值时为 0；`undefined`是一个表示"无"的原始值，转为数值时为`NaN`。
2. 当声明的变量还未被初始化时，变量的默认值为`undefined`。
3. `null`用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
4. `undefined`表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：
   1. 变量被声明了，但没有赋值时，就等于 undefined。
   2. 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
   3. 对象没有赋值的属性，该属性的值为 undefined。
   4. 函数没有返回值时，默认返回 undefined。
5. `null`表示"没有对象"，即该处不应该有值。典型用法是：
   1. 作为函数的参数，表示该函数的参数不是对象。
   2. 作为对象原型链的终点。

### JS 能表示最大的数和最小的数

64 位浮点型，符号位 1 位， 指数位 11 位， 尾数 52 位。在 JavaScript 中，2^53 是最大的值，没有比这更大的值了。
