---
title: 设计模式
date: '2020-10-26'
draft: true
---

## 常用设计模式的有哪些 ？

## 设计模式

设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这种方式写的代码可以让别人更加容易阅读、维护以及复用。

至少要知道以下这些设计模式的功能、代码实现、使用场景问题:

- 单例模式
- 原型模式
- 工厂模式
- 观察者模式
- 策略模式
- 代理模式

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模

### 1. 单例模式

单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。

单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行，以下是如何实现单例模式的例子

```js
class Singleton {
  constructor() {}
}

Singleton.getInstance = (function() {
  let instance;
  return function() {
    if (!instance) {
      instance = new Singleton();
    }
    return instance;
  };
})();

let s1 = Singleton.getInstance();
let s2 = Singleton.getInstance();
console.log(s1 === s2); // true
```

在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex

```js
let Vue; // bind on install

export function install(_Vue) {
  if (Vue && _Vue === Vue) {
    // 如果发现 Vue 有值，就不重新创建实例了
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}
```

```js
const Singleton = function(name) {
  this.name = name;
  this.instance = null;
};

singleton.prototype.getName = function() {
  console.log(this.name);
};

singleton.getInstance = function(name) {
  if (!this.instance) {
    // 关键语句
    this.instance = new Singleton(name);
  }
  return this.instance;
};

// test
const a = singleton.getInstance('a'); // 通过 getInstance 来获取实例
const b = singleton.getInstance('b');
console.log(a === b);

// 弹框层的实践
const createLoginLayer = function() {
  const myDiv = document.createElement('div');
  myDiv.innerHTML = '登入浮框';
  // myDiv.style.display = 'none'
  document.body.appendChild(myDiv);
  return myDiv;
};

// 使单例模式和创建弹框代码解耦
const getSingle = function(fn) {
  let result = null;
  return function() {
    if (!result) {
      result = fn.apply(this, arguments);
    }
    return result;
  };
};

const createSingleLoginLayer = getSingle(createLoginLayer);

document.getElementById('loginBtn').onclick = function() {
  createSingleLoginLayer();
};
```

### 2. 工厂模式

工厂模式分为好几种，这里就不一一讲解了，以下是一个简单工厂模式的例子

```js
class Man {
  constructor(name) {
    this.name = name;
  }
  alertName() {
    alert(this.name);
  }
}

class Factory {
  static create(name) {
    return new Man(name);
  }
}

Factory.create('yiliang114').alertName();
```

当然工厂模式并不仅仅是用来 new 出**实例**。

可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。

工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。

在 Vue 源码中，你也可以看到工厂模式的使用，比如创建异步组件

```js
export function createComponent(
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag,
): VNode | Array<VNode> | void {
  // 逻辑处理...

  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data,
    undefined,
    undefined,
    undefined,
    context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory,
  );

  return vnode;
}
```

在上述代码中，我们可以看到我们只需要调用 `createComponent` 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。

### 适配器模式

适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。

以下是如何实现适配器模式的例子

```js
class Plug {
  getName() {
    return '港版插头';
  }
}

class Target {
  constructor() {
    this.plug = new Plug();
  }
  getName() {
    return this.plug.getName() + ' 适配器转二脚插头';
  }
}

let target = new Target();
target.getName(); // 港版插头 适配器转二脚插头
```

在 Vue 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 `computed` 来做转换这件事情，这个过程就使用到了适配器模式。

```js
/**
 * Created by lin on 2018/8/17.
 */
// 老接口
const oldCity = (function() {
  return [
    {
      name: 'hangzhou',
      id: 11,
    },
    {
      name: 'jinhua',
      id: 12,
    },
  ];
})();

// 新接口希望是下面形式
// {
//     hangzhou: 11,
//     jinhua: 12
// }

// 这时候就可采用适配者模式
const adaptor = function(oldCity) {
  const obj = {};
  for (const city of oldCity) {
    obj[city.name] = city.id;
  }
  return obj;
};

console.log(adaptor(oldCity));
```

### 装饰模式

装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。

以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法

```js
function readonly(target, key, descriptor) {
  descriptor.writable = false;
  return descriptor;
}

class Test {
  @readonly
  name = 'yiliang114';
}

let t = new Test();

t.yck = '111'; // 不可修改
```

在 React 中，装饰模式其实随处可见

```js
import { connect } from 'react-redux';
class MyComponent extends React.Component {
  // ...
}
export default connect(mapStateToProps)(MyComponent);
```

### 代理模式

代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。

在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式。

```html
<ul id="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
  let ul = document.querySelector('#ul');
  ul.addEventListener('click', event => {
    console.log(event.target);
  });
</script>
```

因为存在太多的 `li`，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。

```js
/**
 * Created by lin on 2018/8/15.
 */
// 虚拟代理实现图片预加载
const myImage = (function() {
  const imgNode = document.createElement('img');
  document.body.appendChild(imgNode);
  return {
    setSrc(src) {
      imgNode.src = src;
    },
  };
})();

const proxyImage = (function() {
  const img = new Image();
  img.onload = function() {
    // http 图片加载完毕后才会执行
    myImage.setSrc(this.src);
  };
  return {
    setSrc(src) {
      myImage.setSrc('loading.jpg'); // 本地 loading 图片
      img.src = src;
    },
  };
})();

proxyImage.setSrc('http://loaded.jpg');

// 缓存代理实现乘积计算
const mult = function() {
  let a = 1;
  for (let i = 0, l; (l = arguments[i++]); ) {
    a = a * l;
  }
  return a;
};

const proxyMult = (function() {
  const cache = {};
  return function() {
    const tag = Array.prototype.join.call(arguments, ',');
    if (cache[tag]) {
      return cache[tag];
    }
    cache[tag] = mult.apply(this, arguments);
    return cache[tag];
  };
})();

proxyMult(1, 2, 3, 4); // 24
```

### 发布-订阅模式

发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。

在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式

```html
<ul id="ul"></ul>
<script>
  let ul = document.querySelector('#ul');
  ul.addEventListener('click', event => {
    console.log(event.target);
  });
</script>
```

在 Vue 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 `get` 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。

```js
/**
 * Created by lin on 2018/8/13.
 */
/*
 *发布-订阅模式（观察者模式）
 */
function pubsub() {
  const _pubsub = {}, // 全局对象，即发布订阅对象
    _topics = {}; // 回调函数存放的数组
  let _subUid = 0;

  // 发布方法
  _pubsub.publish = function(topic) {
    if (!_topics[topic]) {
      return false;
    }
    const args = [].slice.call(arguments, 1);
    setTimeout(function() {
      const subscribers = _topics[topic];
      for (let i = 0, j = subscribers.length; i < j; i++) {
        subscribers[i].callback.apply(null, args);
      }
    }, 0);
    return true;
  };
  // 订阅方法
  _pubsub.subscribe = function(topic, callback) {
    if (!_topics[topic]) {
      _topics[topic] = [];
    }
    const token = (++_subUid).toString();
    _topics[topic].push({
      token,
      callback,
    });
    return token;
  };
  // 退订方法
  _pubsub.unsubscribe = function(token) {
    for (const m in _topics) {
      if (_topics[m]) {
        for (let i = 0, j = _topics[m].length; i < j; i++) {
          if (_topics[m][i].token === token) {
            _topics[m].splice(i, 1);
            return token;
          }
        }
      }
    }
    return false;
  };

  return {
    subscribe: _pubsub.subscribe,
    publish: _pubsub.publish,
    unsubscribe: _pubsub.unsubscribe,
  };
}
```

### 外观模式

外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。

举个例子来说，我们现在需要实现一个兼容多种浏览器的添加事件方法

```
function addEvent(elm, evType, fn, useCapture) {
  if (elm.addEventListener) {
    elm.addEventListener(evType, fn, useCapture)
    return true
  } else if (elm.attachEvent) {
    var r = elm.attachEvent("on" + evType, fn)
    return r
  } else {
    elm["on" + evType] = fn
  }
}
```

对于不同的浏览器，添加事件的方式可能会存在兼容问题。如果每次都需要去这样写一遍的话肯定是不能接受的，所以我们将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 `addEvent` 即可。

### 观察者模式

> 观察者模式:观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。而 js 中最常见的观察者模式就是事件触发机制。

#### 先来个完整的

```js
class EventEmitter {
  constructor() {
    this.eventPool = {
      //  'eventName': []
    };
  }
  listen(eventName, callback) {
    if (this.eventPool[eventName]) {
      if (this.eventPool[eventName].indexOf(callback) === -1) {
        this.eventPool[eventName].push(callback);
      }
    } else {
      this.eventPool[eventName] = [callback];
    }
  }
  // trigger是有参数的
  trigger(eventName, ...args) {
    if (this.eventPool[eventName]) {
      this.eventPool[eventName].forEach(cb => cb(...args));
    }
  }
  remove(eventName, callback) {
    if (this.eventPool[eventName]) {
      let cbIndex = this.eventPool[eventName].indexOf(callback);
      this.eventPool[eventName].splice(cbIndex, 1);
    }
  }
  once(eventName, callback) {
    this.listen(eventName, function _cb(...args) {
      callback(...args);
      this.remove(eventName, _cb);
    });
  }
}
```

#### 先搭架子

1. 要有一个对象，存储着它自己的触发函数。而且这个对象的触发函数可能有很多种，比如一个 onclick 可能触发多个事件，那么 handler 的属性应该是一个数组，每个数组的值都是一个函数。

```js
handler={
  type1:[func1,func2...],
  type2:[func3,func4...],
  ...
}
```

现在这个对象的主体部分已经思考好了，现在就是要它‘动起来’，给它添加各种动作。
一个事件可能有哪些动作呢？

- add：添加事件某种类型的函数，
- remove: 移除某种类型的函数，
- fire：触发某种类型的函数,
- once:触发某种类型的函数，然后移除掉这个函数

现在，自定义事件的架子已经搭建好了

```js
eventOb={
  //函数储存
  handler:{
    type1:[func1,func2...],
    type2:[func2,func4...],
    ...
  },

  //主要事件
  add:function(){},
  remove:function(){},
  fire:function(){},
  once:function(){},
}
```

#### add

添加一个事件监听，首先传入参数应该是 事件类型 type，和触发函数 func，传入的时候检测有没有这个函数，有了就不重复添加。

```js
add:function (type,func) {
  //检测type是否存在
  if(eventOb.handleFunc[type]){
    //检测事件是否存在，不存在则添加
    if(eventOb.handleFunc[type].indexOf(func)===-1){
      eventOb.handleFunc[type].push(func);
    }
  }
  else{
    eventOb.handleFunc[type]=[func];
  }
},
```

#### remove

remove 有一个潜在的需求，就是如果你的事件不存在，它应该会报错。而这里不会报错，index 在 func 不存在的时候是-1；这时候要报错。

```js
remove:function (type,func) {
  try{
    let target = eventOb.handleFunc[type];
    let index = target.indexOf(func);
    if(index===-1) throw error;
    target.splice(index,1);
  }catch (e){
      console.error('别老想搞什么飞机，删除我有的东西！');
  }
},
```

#### fire

触发一个点击事件肯定是要触发它全部的函数，这里也是一样，所以只需要传入 type，然后事件可能不存在，像上面一样处理。

```js
fire:function (type,func) {
  try{
    let target = eventOb.handleFunc[type];
    let count = target.length;
    for (var i = 0; i < count; i++) {
      //加()使立即执行
      target[i]();
    }
  }
  catch (e){
    console.error('别老想搞什么飞机，触发我有的东西！');
  }
},
```

但会有问题，我只想触发并且删除某个事件怎么办，fire 一下就全触发了呀。
所以 fire 的问题就显现出来了。我们还是要给它一个 func，但是可选。

```js
fire:function (type,func) {
  try{
    let target = eventOb.handleFunc[type];
    if(arguments.length===1) {
      //不传func则全部触发
      let count = target.length;
      for (var i = 0; i < count; i++) {
          target[i]();
      }
    }else{
      //传func则触发func
      let index=target.indexOf(func);
      if(index===-1)throw error;
      func();
    }
    //need some code
  }catch (e){
    console.error('别老想搞什么飞机，触发我有的东西！');
    //need some code
  }
},
```

#### once

fire，然后 remove

```js

once (event, callback) {
  this.fire(event, (...args) => {
      callback(...args);
      this.remove(event)
  })
}
```

#### 完整代码

```js
class eventObs {
  constructor() {
    this.handleFunc = {};
  }

  add(type, func) {
    if (this.handleFunc[type]) {
      if (this.handleFunc[type].indexOf(func) === -1) {
        this.handleFunc[type].push(func);
      }
    } else {
      this.handleFunc[type] = [func];
    }
  }

  fire(type, func) {
    try {
      if (arguments.length === 1) {
        let target = this.handleFunc[type];
        let count = target.length;
        for (var i = 0; i < count; i++) {
          target[i]();
        }
      } else {
        let target = this.handleFunc[type];
        let index = target.indexOf(func);
        if (index === -1) throw error;
        func();
      }
      return true;
    } catch (e) {
      console.error('别老想搞什么飞机，触发我有的东西！');
      return false;
    }
  }

  remove(type, func) {
    try {
      let target = this.handleFunc[type];
      let index = target.indexOf(func);
      if (index === -1) throw error;
      target.splice(index, 1);
    } catch (e) {
      console.error('别老想搞什么飞机，删除我有的东西！');
    }
  }

  once(type, func) {
    this.fire(type, func) ? this.remove(type, func) : null;
  }
}
```

### 策略模式

```js
/**
 * Created by lin on 2018/8/15.
 */
const strategy = {
  S(salary) {
    return salary * 4;
  },
  A(salary) {
    return salary * 3;
  },
  B(salary) {
    return salary * 2;
  },
};

const calculateBonus = function(level, salary) {
  return strategy[level](salary);
};

calculateBonus('A', 10000); // 30000

// 策略模式的使用常常隐藏在高阶函数中
const S = function(salary) {
  return salary * 4;
};

const A = function(salary) {
  return salary * 3;
};

const B = function(salary) {
  return salary * 2;
};

const calculateBonus2 = function(func, salary) {
  return func(salary);
};

calculateBonus2(A, 10000); // 30000
```

### 命令模式

```js
/**
 * Created by lin on 2018/8/16.
 */
const setCommand = function(button, command) {
  button.onClick = function() {
    command.excute();
  };
};

// --------------------  上面的界面逻辑由A完成，下面的由B完成

const menu = {
  updateMenu() {
    console.log('更新菜单');
  },
};

const updateCommand = function(receive) {
  return {
    excute: receive.updateMenu,
  };
};

const updateCommandMenu = updateCommand(menu); // 创建命令

const button1 = document.getElementById('button1');
setCommand(button1, updateCommandMenu);
```

### 模板方法模式

```js
/**
 * Created by lin on 2018/8/16.
 */

const Drinks = function() {};

Drinks.prototype.firstStep = function() {
  console.log('烧开水');
};

Drinks.prototype.secondStep = function() {};

Drinks.prototype.thirdStep = function() {
  console.log('倒入杯子');
};

Drinks.prototype.fourthStep = function() {};

Drinks.prototype.init = function() {
  // 模板方法模式核心：在父类上定义好执行算法
  this.firstStep();
  this.secondStep();
  this.thirdStep();
  this.fourthStep();
};

const Tea = function() {};

Tea.prototype = new Drinks();

Tea.prototype.secondStep = function() {
  console.log('浸泡茶叶');
};

Tea.prototype.fourthStep = function() {
  console.log('加柠檬');
};

const Coffee = function() {};

Coffee.prototype = new Drinks();

Coffee.prototype.secondStep = function() {
  console.log('冲泡咖啡');
};

Coffee.prototype.fourthStep = function() {
  console.log('加糖');
};

const tea = new Tea();
tea.init();

// 烧开水
// 浸泡茶叶
// 倒入杯子
// 加柠檬

const coffee = new Coffee();
coffee.init();

// 烧开水
// 冲泡咖啡
// 倒入杯子
// 加糖

// 假如客人不想加佐料(糖、柠檬)怎么办，这时可以引人钩子来实现之，实现逻辑如下：
// ...

Drinks.prototype.ifNeedFlavour = function() {
  // 加上钩子
  return true;
};

Drinks.prototype.init = function() {
  // 模板方法模式核心：在父类上定义好执行算法
  this.firstStep();
  this.secondStep();
  this.thirdStep();
  if (this.ifNeedFlavour()) {
    // 默认是 true，也就是要加调料
    this.fourthStep();
  }
};

// ...
const Coffee2 = function() {};

Coffee2.prototype = new Drinks();
// ...

Coffee2.prototype.ifNeedFlavour = function() {
  return window.confirm('是否需要佐料吗？'); // 弹框选择是否佐料
};
```

### 迭代器模式

```js
/**
 * Created by lin on 2018/8/16.
 */
// 实现一个内部的迭代器
function each(arr, fn) {
  for (let i = 0; i < arr.length; i++) {
    fn(i, arr[i]);
  }
}

each([1, 2, 3], function(i, n) {
  console.log(i); // 0 1 2
  console.log(n); // 1 2 3
});

// 可以看出内部迭代器在调用的时候非常简单，使用者不用关心迭代器内部实现的细节，但这也是内部迭代器的缺点。
// 比如要比较两数组是否相等，只能在其回调函数中作文章了，代码如下：
const compare = function(arr1, arr2) {
  each(arr1, function(i, n) {
    if (arr2[i] !== n) {
      console.log('两数组不等');
      return;
    }
  });
  console.log('两数组相等');
};

const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];
compare(arr1, arr2); // 两数组相等

// 实现一个外部的迭代器
const iterator = function(arr) {
  let current = 0;
  const next = function() {
    current = current + 1;
  };
  const done = function() {
    return current >= arr.length;
  };
  const value = function() {
    return arr[current];
  };
  return {
    next,
    done,
    value,
  };
};

const newArr1 = [1, 2, 3];
const newArr2 = [1, 2, 3];
const iterator1 = iterator(arr1);
const iterator2 = iterator(arr2);

const compare2 = function(iterator1, iterator2) {
  while (!iterator1.done() && !iterator2.done()) {
    if (iterator1.value() !== iterator2.value()) {
      console.log('两数组不等');
      return;
    }
    iterator1.next(); // 外部迭代器将遍历的权利转移到外部
    iterator2.next();
  }
  console.log('两数组相等');
};

compare2(iterator1, iterator2);
```

### 享元模式

```js
/**
 * Created by lin on 2018/8/16.
 */
// 方案1
const Model1 = function(gender, underwear) {
  this.gender = gender;
  this.underwear = underwear;
};

Model1.prototype.takephoto = function() {
  console.log(`${this.gender}穿着${this.underwear}`);
};

for (let i = 1; i < 51; i++) {
  const maleModel = new Model1('male', `第${i}款衣服`);
  maleModel.takephoto();
}

for (let i = 1; i < 51; i++) {
  const female = new Model1('female', `第${i}款衣服`);
  female.takephoto();
}

// 方案2（使用享元模式）
const Model2 = function(gender) {
  this.gender = gender;
};

Model2.prototype.takephoto = function() {
  console.log(`${this.gender}穿着${this.underwear}`);
};

const maleModel = new Model2('male');
const femaleModel = new Model2('female');

for (let i = 1; i < 51; i++) {
  maleModel.underwear = `第${i}款衣服`;
  maleModel.takephoto();
}

for (let i = 1; i < 51; i++) {
  femaleModel.underwear = `第${i}款衣服`;
  femaleModel.takephoto();
}

// 对比发现：方案一创建了 100 个对象，方案二只创建了 2 个对象，在该 demo 中，gender(性别) 是内部对象，underwear(穿着) 是外部对象。
// 当然在方案二的 demo 中，还可以进一步改善：
// 一开始就通过构造函数显示地创建实例，可用工场模式将其升级成可控生成
// 在实例上手动添加 underwear 不是很优雅，可以在外部单独在写个 manager 函数
const Model3 = function(gender) {
  this.gender = gender;
};

Model3.prototype.takephoto = function() {
  console.log(`${this.gender}穿着${this.underwear}`);
};

const modelFactory = (function() {
  // 优化第一点
  const modelGender = {};
  return {
    createModel(gender) {
      if (modelGender[gender]) {
        return modelGender[gender];
      }
      modelGender[gender] = new Model(gender);
      return modelGender[gender];
    },
  };
})();

const modelManager = (function() {
  const modelObj = {};
  return {
    add(gender, i) {
      modelObj[i] = {
        underwear: `第${i}款衣服`,
      };
      return modelFactory.createModel(gender);
    },
    copy(model, i) {
      // 优化第二点
      model.underwear = modelObj[i].underwear;
    },
  };
})();

for (let i = 1; i < 51; i++) {
  const maleModel = modelManager.add('male', i);
  modelManager.copy(maleModel, i);
  maleModel.takephoto();
}

for (let i = 1; i < 51; i++) {
  const femaleModel = modelManager.add('female', i);
  modelManager.copy(femaleModel, i);
  femaleModel.takephoto();
}
```

### 装饰者模式

```js
/**
 * Created by lin on 2018/8/16.
 */
let wear = function() {
  console.log('穿上第一件衣服');
};

const _wear1 = wear;

wear = function() {
  _wear1();
  console.log('穿上第二件衣服');
};

const _wear2 = wear;

wear = function() {
  _wear2();
  console.log('穿上第三件衣服');
};

wear();

// 穿上第一件衣服
// 穿上第二件衣服
// 穿上第三件衣服
// 这种方式有以下缺点：1：临时变量会变得越来越多；2：this 指向有时会出错

// AOP装饰函数
// 前置代码
Function.prototype.before = function(fn) {
  const self = this;
  return function() {
    fn.apply(this, arguments);
    return self.apply(this, arguments);
  };
};

// 后置代码
Function.prototype.after = function(fn) {
  const self = this;
  return function() {
    self.apply(this, arguments);
    return fn.apply(this, arguments);
  };
};

const wear1 = function() {
  console.log('穿上第一件衣服');
};

const wear2 = function() {
  console.log('穿上第二件衣服');
};

const wear3 = function() {
  console.log('穿上第三件衣服');
};

const newWear = wear1.after(wear2).after(wear3);
newWear();

// 穿上第一件衣服
// 穿上第二件衣服
// 穿上第三件衣服

// 但这样子有时会污染原生函数，可以做点通变
const after = function(fn, afterFn) {
  return function() {
    fn.apply(this, arguments);
    afterFn.apply(this, arguments);
  };
};

const new2Wear = after(after(wear1, wear2), wear3);
new2Wear();
```

### 组合模式

```js
/**
 * Created by lin on 2018/8/16.
 */
// Demo1-宏命令
const macroCommand = function() {
  return {
    lists: [],
    add(task) {
      this.lists.push(task);
    },
    excute() {
      // ①：组合对象调用这里的 excute，
      for (let i = 0; i < this.lists.length; i++) {
        this.lists[i].excute();
      }
    },
  };
};

const command1 = macroCommand(); // 基本对象

command1.add({
  excute: () => console.log('煮咖啡'), // ②：基本对象调用这里的 excute，
});

const command2 = macroCommand(); // 组合对象

command2.add({
  excute: () => console.log('打开电视'),
});

command2.add({
  excute: () => console.log('打开音响'),
});

const command3 = macroCommand();

command3.add({
  excute: () => console.log('打开空调'),
});

command3.add({
  excute: () => console.log('打开电脑'),
});

const macroComm = macroCommand();
macroComm.add(command1);
macroComm.add(command2);
macroComm.add(command3);

macroCommand.excute();

// 煮咖啡
// 打开电视
// 打开音响
// 打开空调
// 打开电脑

// Demo2-扫描文件夹
const Folder = function(folder) {
  this.folder = folder;
  this.lists = [];
};

Folder.prototype.add = function(resource) {
  this.lists.push(resource);
};

Folder.prototype.scan = function() {
  console.log('开始扫描文件夹：', this.folder);
  for (let i = 0, folder; (folder = this.lists[i++]); ) {
    folder.scan();
  }
};

const File = function(file) {
  this.file = file;
};

File.prototype.add = function() {
  throw Error('文件下不能添加其它文件夹或文件');
};

File.prototype.scan = function() {
  console.log('开始扫描文件：', this.file);
};

const folder = new Folder('根文件夹');
const folder1 = new Folder('JS');
const folder2 = new Folder('life');

const file1 = new File('深入React技术栈.pdf');
const file2 = new File('JavaScript权威指南.pdf');
const file3 = new File('小王子.pdf');

folder1.add(file1);
folder1.add(file2);

folder2.add(file3);

folder.add(folder1);
folder.add(folder2);

folder.scan();

// 开始扫描文件夹： 根文件夹
// 开始扫描文件夹： JS
// 开始扫描文件： 深入React技术栈.pdf
// 开始扫描文件： JavaScript权威指南.pdf
// 开始扫描文件夹： life
// 开始扫描文件： 小王子.pdf
```
