---
title: 前端测试
date: 2020-09-11
category: 前端
draft: true
tags:
  - 测试
---

## 前端测试

### 单元测试

单元测试是对软件基本组成单元（软件设计的最小单位）进行正确性检验的测试工作，如函数、过程(function,procedure)或一个类的方法(method)。

常用工具：

- Jest
- ava

#### Jest

几个指标

- %stmts 是语句覆盖率（statement coverage）：是不是每个语句都执行了？
- %Branch 分支覆盖率（branch coverage）：是不是每个 if 代码块都执行了？
- %Funcs 函数覆盖率（function coverage）：是不是每个函数都调用了？
- %Lines 行覆盖率（line coverage）：是不是每一行都执行了？

#### AVA

TODO:

#### Snapshot Testing

https://jestjs.io/docs/zh-Hans/snapshot-testing

#### 测试覆盖率 coverage

npm run test -- --coverage

使用的 travis.yml

```yml
sudo: required
dist: trusty
language: node_js
node_js:
  - '11'
install:
  - npm install -g codecov
  - npm install
script:
  - npm run ci
  - codecov
notifications:
  email: false
```

### 集成测试：

集成测试是在单元测试的基础上，将所有模块按照概要设计要求组装成为子系统或系统，验证组装后功能以及模块间接口是否正确的测试工作。集成测试也叫组装测试、联合测试、子系统测试或部件测试。

### 其他

- 通过为前端代码编写单元测试(Unit Test)来测试前端代码
- Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码
- BDD：行为驱动开发 -- 业务需求描述产出产品代码的开发方法
- TDD：测试驱动开发 -- 单元测试用例代码产出产品代码的开发方法
- 单元测试框架：

```js
// mocha 示例
describe('Test add', function() {
  it('1 + 2 = 3', function() {
    expect(add(1, 2)).to.be.equal(3);
  });
});

// jest 示例
describe('Test add', function() {
  it('1 + 2 = 3', function() {
    expect(add(1, 2)).toEqual(3);
  });
});
```

## 测试相关问题

### 对代码进行测试的有什么优缺点？

写作单元测试代码的好处

熟悉单元测试技术，了解相关的基本原理；
掌握代码，积累代码编写经验，积累调试经验，积累分析问题、解决问题的经验；
训练动手能力，单元测试代码不是业务代码，开发、维护过程中不需要特别关注质量要求，底限是达到验证业务代码逻辑性的目的，因而比修改代码要省心、省事；
不需要准备项目运行环境，单元测试代码在运行时的外部依赖比较少，执行验证、调试代码的代价会很低；
降低新手程序员进入项目的门槛，有助于积累信心。

单元测试的缺点
单元测试并不万能，并不能解决所有问题，受限于测试范围和场景以及数据，只能满足单模块内部的功能验证的需求；
单元测试覆盖分支，系统测试覆盖场景，二者可能存在重叠，另由于着眼点不同，二者不能相互替代，测试覆盖率有不同的含义；
部分之和不等于整体，单纯追求覆盖率是可笑的，覆盖率只是衡量测试投入的指标，和代码质量并没有直接的关联，另外当覆盖率达到一定程序之后，继续提升覆盖率时投入和产出可能不成正比，效益可能会下降；

### 单元测试编写有哪些原则

为了提高开发人员的代码质量，编写高质量的单元测试，要遵守 3R（Responsible, Reliable, Repeative）原则，具体含义如下：

- Responsible: 谁开发谁负责测试，在哪里开发就在哪里测试。
- Reliable: 测试 case 要可靠，并且是值得信赖的，对于底层的任何改动都要能够及时感知。
- Repeative: 所有单元测试用例都要能够重复运行。能够重复运行就能够进行回归测试、覆盖率统计等等

## 为什么写测试？

Web 应用越来越复杂，意味着更可能出错。测试是提高代码质量、降低错误的最好方法之一。

- 测试可以确保得到预期结果。
- 加快开发速度。
- 方便维护。
- 提供用法的文档。

对于长期维护的项目，测试会大大加快开发速度，减轻维护难度。

## 测试的类型

- 单元测试（unit testing）
- 功能测试（feature testing）
- 集成测试（integration testing）
- 端对端测试 (End-to-End testing）

## 以测试为导向的开发模式

- TDD：测试驱动的开发（Test-Driven Development）
- BDD：行为驱动的开发（Behavior-Driven Development）

## TDD vs. BDD

两者侧重点不一样

- TDD：基于开发者角度，重点测试函数的输入输出
- BDD：基于使用者角度，重点测试对用户行为的反应

比如，有一个计数器函数`counter`，TDD 测试的是输入 1，输出的应该是 2；BDD 测试的是用户访问以后，计数器应该增加一次。

## Mocha

Mocha 是目前最常用的测试框架。

## 功能测试

功能测试指的是，站在外部用户的角度，测试软件的某项功能。

与内部代码实现无关，只测试功能是否正常。

很多时候，单元测试都可以通过，但是整体功能会失败。

## 前端的功能测试

功能测试必须在真正浏览器做，现在有四种方法。

- 使用本机安装的浏览器
- 使用 Selenium Driver
- 使用 PhantomJS
- 使用 Electron

## 测试方法

### 黑盒测试

黑盒测试 (Black-box Testing), 测试应用程序的功能, 而不是其内部结构或运作. 测试者不需了解代码、内部结构等, 只需知道什么是应用应该做的事, 即当键入特定的输入, 可得到一定的输出. 测试者通过选择`有效输入`和`无效输入`来验证是否正确的输出. 此测试方法可适合大部分的软件测试, 例如集成测试 (Integration Testing) 以及系统测试 (System Testing).

### 白盒测试

白盒测试 (White-box Testing) 测试应用程序的内部结构或运作, 而不是测试应用程序的功能 (即黑盒测试). 在白盒测试时, 以编程语言的角度来设计测试案例. 白盒测试可以应用于单元测试 (Unit Testing)、集成测试 (Integration Testing) 和系统的软件测试流程, 可测试在集成过程中每一单元之间的路径, 或者主系统跟子系统中的测试.

## 单元测试

单元测试 (Unit Testing) 是白盒测试的一种, 用于针对程序模块进行正确性检验的测试工作. 单元 (Unit) 是指**最小可测试的部件**. 在过程化编程中, 一个单元就是单个程序、函数、过程等; 对于面向对象编程, 最小单元就是方法, 包括基类、抽象类、或者子类中的方法.

另外, 每次修改代码之后, 通过单元测试来验证比把整个应用启动/重启验证要更快/更简单.

### 覆盖率

测试覆盖率 (Test Coverage) 是指代码中各项逻辑被测试覆盖到的比率, 比如 90% 的覆盖率, 是指代码中 90% 的情况都被测试覆盖到了.

覆盖率通常由四个维度贡献:

- 行覆盖率 (line coverage) 是否每一行都执行了？
- 函数覆盖率 (function coverage) 是否每个函数都调用了？
- 分支覆盖率 (branch coverage) 是否每个 if 代码块都执行了？
- 语句覆盖率 (statement coverage) 是否每个语句都执行了？

常用的测试覆盖率框架 [istanbul](https://github.com/gotwarlost/istanbul).

当然覆盖率并不完全是由单元测试贡献, 在单元测试之上还有集成测试等.

### Mock

Mock 主要用于单元测试中. 当一个测试的对象可能依赖其他 (也许复杂/多个) 的对象. 为了确保其行为不受其他对象的影响, 你可以通过模拟其他对象的行为来隔离你要测试的对象.

当你要测试的单元依赖了一些很难纳入单元测试的情况时 (例如要测试的单元依赖数据库/文件操作/第三方服务 等情况的返回时), 使用 mock 是非常有用的. 简而言之, Mock 是模拟其他依赖的 behaviour.

### 常见测试工具

- [Mocha](https://github.com/mochajs/mocha)
- [ava](https://github.com/avajs/ava)
- [Jest](https://github.com/facebook/jest)

#### 什么是 Jest?

*Jest*是一个由 Facebook 基于 Jasmine 创建的 JavaScript 单元测试框架，提供自动模拟创建和`jsdom`环境。它通常用于测试组件。

#### Jest 对比 Jasmine 有什么优势?

与 Jasmine 相比，有几个优点：

- 自动查找在源代码中要执行测试。
- 在运行测试时自动模拟依赖项。
- 允许您同步测试异步代码。
- 使用假的 DOM 实现（通过`jsdom`）运行测试，以便可以在命令行上运行测试。
- 在并行流程中运行测试，以便更快完成。

#### 举一个简单的 Jest 测试用例

让我们为`sum.js`文件中添加两个数字的函数编写一个测试：

```js
const sum = (a, b) => a + b;

export default sum;
```

创建一个名为`sum.test.js`的文件，其中包含实际测试：

```js
import sum from './sum';

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

然后将以下部分添加到`package.json`：

```json
{
  "scripts": {
    "test": "jest"
  }
}
```

最后，运行`yarn test`或`npm test`，Jest 将打印结果：

```
$ yarn test
PASS ./sum.test.js
✓ adds 1 + 2 to equal 3 (2ms)
```

## 集成测试

集成测试也称综合测试、组装测试、联合测试, 将程序模块采用适当的集成策略组装起来, 对系统的接口及集成后的功能进行正确性检测的测试工作. 集成测试可以是黑盒的, 也可以是白盒的, 其主要目的是检查软件单位之间的接口是否正确, 而集成测试的对象是**已经经过单元测试的模块**.

例如你可以在本地将项目中的 web app 启动, 并模拟接口调用:

```js
describe('Path API', () => {
  // ...

  describe('GET /v2/path/:_id', () => {
    it('should return 200 GET /v2/path/:_id', () => {
      return request
        .get('/v2/path/' + pathId)
        .set('Cookie', 'common_user=xxx')
        .expect(200);
    });
  });

  describe('POST /v2/path', () => {
    it('should return 412 POST /v2/path lost params path', () => {
      return request
        .post('/v2/path')
        .set('Cookie', 'common_user=xxx')
        .expect(412);
    });

    it('should return 409 POST /v2/path when path exist', () => {
      return request
        .post('/v2/path')
        .send({ path: '/' })
        .set('Cookie', 'common_user=xxx')
        .expect(409);
    });

    it('should return 200 POST /v2/path successfully', () => {
      return request
        .post('/v2/path')
        .send({ path: '/comment' })
        .set('Cookie', 'common_user=xxx')
        .expect(200);
    });
  });

  // ...
});
```

## 基准测试

目前 Node.js 中流行的白盒级基准测试工具是 [benchmark](https://benchmarkjs.com/docs).

```js
const Benchmark = require('benchmark');
const suite = new Benchmark.Suite();

suite
  .add('RegExp#test', function() {
    /o/.test('Hello World!');
  })
  .add('String#indexOf', function() {
    'Hello World!'.indexOf('o') > -1;
  })
  .on('cycle', function(event) {
    console.log(String(event.target));
  })
  .on('complete', function() {
    console.log('Fastest is ' + this.filter('fastest').map('name'));
  })
  // run async
  .run({ async: true });
```

你可以将同一个功能的不同实现基于同一个标准来比较不同实现的速度, 从而得到最优解.

黑盒级别的基准测试, 则推荐 [Apache ab](https://httpd.apache.org/docs/2.4/programs/ab.html) 以及 [wrk](https://github.com/wg/wrk) 等, 例如执行:

```
ab -n 100 -c 10 https://ele.me/
```

可以得到如下的详细数据:

```
Server Software:        Tengine/2.1.1
Server Hostname:        ele.me
Server Port:            443
SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES256-GCM-SHA384,2048,256

Document Path:          /
Document Length:        284 bytes

Concurrency Level:      10
Time taken for tests:   1.775 seconds
Complete requests:      100
Failed requests:        0
Non-2xx responses:      100
Total transferred:      62400 bytes
HTML transferred:       28400 bytes
Requests per second:    56.33 [#/sec] (mean)
Time per request:       177.511 [ms] (mean)
Time per request:       17.751 [ms] (mean, across all concurrent requests)
Transfer rate:          34.33 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       88  116  26.0    104     234
Processing:    33   55  39.6     47     394
Waiting:       33   54  39.0     46     394
Total:        124  171  48.1    152     491

Percentage of the requests served within a certain time (ms)
  50%    152
  66%    184
  75%    193
  80%    199
  90%    224
  95%    242
  98%    288
  99%    491
 100%    491 (longest request)
```

与前者相比, ab 等工具可以设置规模以及并发情况. 在比规模不大/需求不复杂的情况下, ab 以及 wrk 也可以用于做压力测试.

## 压力测试

压力测试 (Stress testing), 是保证系统稳定性的一种测试方法. 通过预估系统所需要承载的 QPS, TPS 等指标, 然后通过如 [Jmeter](http://jmeter.apache.org/) 等压测工具模拟相应的请求情况, 来验证当前应能能否达到目标.

对于比较重要, 流量较高或者后期业务量会持续增长的系统, 进行压力测试是保证项目品质的重要环节. 常见的如负载是否均衡, 带宽是否合理, 以及磁盘 IO 网络 IO 等问题都可以通过比较极限的压力测试暴露出来.

## Assert

断言 (Assert) 是快速判断并对不符合预期的情况进行报错的模块. 是将:

```js
if (condition) {
  throw new Error('Sth wrong');
}
```

写成:

```js
assert(!condition, 'Sth wrong');
```

等等情况的一种简化. 并且提供了丰富了 `equal` 判断, 对于对象类型也有深度/严格判断等情况支持.

Node.js 中内置的 `assert` 模块也是属于断言模块的一种, 但是官方在文档中有注明, 该内置模块主要是用于内置代码编写时的基本断言需求, 并不是一个通用的断言库 (**not intended to be used as a general purpose assertion library**)

### 常见断言工具

- [Chai](https://github.com/chaijs/chai)
- [should.js](https://github.com/shouldjs/should.js)
