(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{218:function(t,e,a){"use strict";a.r(e);var n=a(0),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"mobx-4-x-严格模式下-array-map-的一点问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mobx-4-x-严格模式下-array-map-的一点问题"}},[t._v("#")]),t._v(" mobx@4.x 严格模式下 Array.map 的一点问题")]),t._v(" "),a("p",[t._v("背景是 React + mobx@4.x + antd 的项目，并且打开了严格模式的情况下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("configure({ enforceActions: true })\n")])])]),a("p",[t._v("大概我的需求是， 将 store 中的一个数组（dataSource）在 stateless Component 中进行渲染，那么自然就想到了 Array 的 map 方法，然后再 JSX 中直接将数组转成 JSX 代码块。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const wrapperItem = (title, list) => {\n  const result = list.map((item, index) => <Row>\n    <Col span={2}>\n      {index}\n    </Col>\n    <Col span={2}>\n      {item}\n    </Col>\n  </Row>)\n  return (\n    <div>\n      <h4>{title}</h4>\n      {result}\n    </div>\n  )\n}\n")])])]),a("p",[t._v("上面的 demo 代码中的第二个参数 list 会传入 observable 属性----是一个数组。")]),t._v(" "),a("p",[t._v("然后浏览器狂报错误:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[mobx] Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: SupernatantStore@13.data.baseInfo\n")])])]),a("p",[t._v("然后看一下 下面的简单代码排查错误吧：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var list = [{'a': 1},{'a': 2}];\nvar newList = list.map(function(index){\n    return index.a += 1;\n});\nconsole.log(newList,'newList',list,'list');\n// newList 和 list 都改变了。先修改了list的单个key值，再将key值返回，自然就修改了两个\n\nvar list = [{'a': 1},{'a': 2}];\nvar newList = list.slice(0).map(function(index){\n    return index.a += 1;\n});\nconsole.log(newList,'newList',list,'list');\n// newList 和 list 也都改变了，关键很不理解，明明 list 跟 list.slice(0) 已经不是指向同一个数组，为什么list.slice(0) 修改内容还会引发list 也改变？\n\n\n// wa ...\n// 难受的一批。。。\n// slice() concat() 都是浅拷贝，整个数组的指向是不同的了，但是，里面的对象的指向是同一个，所以其实在map里执行的函数，操作的对象还是同一个。。。\nlist.slice(0)[0] === list[0] // truw\nlist.slice(0) === list // false\n")])])]),a("p",[t._v("同样的，es6 的解构赋值，也只是浅拷贝：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    var a = {b: {c:111},d:{d:2222}}\n    var {b} = a\n    b === a.b\n    // true\n")])])]),a("p",[t._v("所以说，mobx 严格模式下一直再警告我不能修改 observable 的值。")]),t._v(" "),a("hr"),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  constructor() {\n    this.initData()\n  }\n  @action initData = async () => {\n\n     this.baseInfo = await getBaseInfo()\n     this.extractInfo = await getExtractInfo()\n     this.extractInfo = await getExtractStatus()\n\n  }\n")])])]),a("p",[t._v("我之前的代码是这样的，其实，我觉得连"),a("code",[t._v("@action")]),t._v(" 也不要，因为就算在严格模式下"),a("code",[t._v("constructor")]),t._v("函数中也是可以修改 observable 中的值的。")]),t._v(" "),a("p",[t._v("那为什么一直报不能在"),a("code",[t._v("action")]),t._v("之外修改 observable 属性的错误呢？")]),t._v(" "),a("p",[t._v("action 仅影响当前运行的函数,而不会影响异步函数，这意味着如果你有 setTimeout,promise, then 或 异步的 constructor ,在回调更多的状态改变,这些回调应包装在 runInAction 中。。。。")]),t._v(" "),a("p",[t._v("写在最后：")]),t._v(" "),a("ol",[a("li",[t._v("我之前真的没有好好注意这个问题，对于以前没有任何限制引用值的 "),a("code",[t._v("set")]),t._v(" 的时候，我往往只关心我得到的值（return 出来的）是不是我想要的。。。。")]),t._v(" "),a("li",[t._v("说明我对于什么 "),a("code",[t._v("slice")]),t._v(","),a("code",[t._v("concat()")]),t._v(" 产生一个新的数组这一个概念的理解，只停留于表面。。。。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);