(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{210:function(e,v,_){"use strict";_.r(v);var t=_(0),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h3",{attrs:{id:"浏览器的强缓存和协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的强缓存和协商缓存"}},[e._v("#")]),e._v(" 浏览器的强缓存和协商缓存")]),e._v(" "),_("blockquote",[_("p",[e._v("原文链接：https://github.com/yiliang114/Blog/issues/6")])]),e._v(" "),_("p",[e._v("这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。")]),e._v(" "),_("p",[e._v("浏览器缓存主要有以下几个优点：")]),e._v(" "),_("ol",[_("li",[e._v("减少重复数据请求，避免通过网络再次加载资源，节省流量。")]),e._v(" "),_("li",[e._v("降低服务器的压力，提升网站性能。")]),e._v(" "),_("li",[e._v("加快客户端加载网页的速度， 提升用户体验。")])]),e._v(" "),_("p",[e._v("浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：")]),e._v(" "),_("ol",[_("li",[e._v("如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。")]),e._v(" "),_("li",[e._v("在 "),_("code",[e._v("chrome")]),e._v(" 中强缓存（虽然没有发出真实的 "),_("code",[e._v("http")]),e._v(" 请求）的请求状态码返回是 "),_("code",[e._v("200 (from cache)")]),e._v("；而协商缓存如果命中走缓存的话，请求的状态码是 "),_("code",[e._v("304 (not modified)")]),e._v("。 不同浏览器的策略不同，在 "),_("code",[e._v("Fire Fox")]),e._v("中，"),_("code",[e._v("from cache")]),e._v(" 状态码是 304.")])]),e._v(" "),_("blockquote",[_("p",[e._v("其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。\n"),_("img",{attrs:{src:"https://user-images.githubusercontent.com/11473889/57010212-249bda80-6c2e-11e9-8500-afe8c449e35f.png",alt:"image.png"}})])]),e._v(" "),_("h4",{attrs:{id:"请求流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#请求流程"}},[e._v("#")]),e._v(" 请求流程")]),e._v(" "),_("p",[e._v("浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：")]),e._v(" "),_("ol",[_("li",[e._v("浏览器会获取该缓存资源的 "),_("code",[e._v("header")]),e._v(" 中的信息，根据 "),_("code",[e._v("response header")]),e._v(" 中的 "),_("code",[e._v("expires")]),e._v(" 和 "),_("code",[e._v("cache-control")]),e._v(" 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。")]),e._v(" "),_("li",[e._v("如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 "),_("code",[e._v("IF-Modified-Since")]),e._v(" 或者 "),_("code",[e._v("IF-None-Match")]),e._v(", 它们的值分别是第一次请求返回 "),_("code",[e._v("Last-Modified")]),e._v("或者 "),_("code",[e._v("Etag")]),e._v("，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。")])]),e._v(" "),_("p",[e._v("借用网上的一张图片")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://user-images.githubusercontent.com/11473889/57010205-16e65500-6c2e-11e9-8334-ce884274e529.png",alt:"image.png"}})]),e._v(" "),_("h4",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),_("p",[e._v("强缓存是根据返回头中的 "),_("code",[e._v("Expires")]),e._v(" 或者 "),_("code",[e._v("Cache-Control")]),e._v(" 两个字段来控制的，都是表示资源的缓存有效时间。")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("Expires")]),e._v(" 是 "),_("code",[e._v("http 1.0")]),e._v(" 的规范，值是一个"),_("code",[e._v("GMT")]),e._v(" 格式的时间点字符串，比如 "),_("code",[e._v("Expires:Mon,18 Oct 2066 23:59:59 GMT")]),e._v(" 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 "),_("code",[e._v("Expires")]),e._v(" 在实际使用中会带来一些麻烦。")]),e._v(" "),_("li",[_("code",[e._v("Cache-Control")]),e._v("这个字段是 "),_("code",[e._v("http 1.1")]),e._v(" 的规范，一般常用该字段的 "),_("code",[e._v("max-age")]),e._v(" 值来进行判断，它是一个相对时间，比如 ."),_("code",[e._v("Cache-Control:max-age=3600")]),e._v(" 代表资源的有效期是 3600 秒。并且返回头中的 "),_("code",[e._v("Date")]),e._v(" 表示消息发送的时间，表示当前资源在 "),_("code",[e._v("Date ~ Date +3600s")]),e._v(" 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 "),_("code",[e._v("max-age")]),e._v(" 之后，在 "),_("code",[e._v("max-age")]),e._v(" 时间内重新访问资源却会返回 "),_("code",[e._v("304 not modified")]),e._v(" ，这是由于服务器的时间与本地的时间不同造成的。当然 "),_("code",[e._v("Cache-Control")]),e._v(" 还有其他几个值可以设置， 不过相对来说都很少用了：\n"),_("ul",[_("li",[_("code",[e._v("no-cache")]),e._v(" 不使用本地缓存。需要使用协商缓存。")]),e._v(" "),_("li",[_("code",[e._v("no-store")]),e._v("直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 "),_("code",[e._v("network")]),e._v(" 中的 "),_("code",[e._v("disabled cache")]),e._v("。")]),e._v(" "),_("li",[_("code",[e._v("public")]),e._v(" 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。")]),e._v(" "),_("li",[_("code",[e._v("private")]),e._v(" 只能被终端用户的浏览器缓存。")])])])]),e._v(" "),_("p",[e._v("如果 "),_("code",[e._v("Cache-Control")]),e._v("与 "),_("code",[e._v("Expires")]),e._v(" 同时存在的话， "),_("code",[e._v("Cache-Control")]),e._v(" 的优先级高于 "),_("code",[e._v("Expires")]),e._v(" 。")]),e._v(" "),_("h4",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),_("p",[e._v("协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, "),_("code",[e._v("Last-Modified")]),e._v(" 或者 "),_("code",[e._v("Etag")]),e._v("，则后续请求则会带上对应的请求字段 "),_("code",[e._v("If-Modified-Since")]),e._v("或者 "),_("code",[e._v("If-None-Match")]),e._v("，若响应头没有 "),_("code",[e._v("Last-Modified")]),e._v(" 或者 "),_("code",[e._v("Etag")]),e._v(" 字段，则请求头也不会有对应的字段。")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("Last-Modified/If-Modified-Since")]),e._v(" 二者的值都是 GMT 格式的时间字符串， "),_("code",[e._v("Last-Modified")]),e._v(" 标记最后文件修改时间， 下一次请求时，请求头中会带上 "),_("code",[e._v("If-Modified-Since")]),e._v(" 值就是 "),_("code",[e._v("Last-Modified")]),e._v(" 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 "),_("code",[e._v("304 Not Modified")]),e._v(" ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 "),_("code",[e._v("304 Not Modified")]),e._v(" 的响应时，"),_("code",[e._v("response header")]),e._v(" 中不会再添加的 "),_("code",[e._v("Last-Modified")]),e._v(" 去试图更新本地缓存的 "),_("code",[e._v("Last-Modified")]),e._v("， 因为既然资源没有变化，那么 "),_("code",[e._v("Last-Modified")]),e._v(" 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 "),_("code",[e._v("Last-Modified")]),e._v(" 会在 "),_("code",[e._v("response header")]),e._v(" 返回，并在下次请求之前更新本地缓存的 "),_("code",[e._v("Last-Modified")]),e._v("，下次请求时，"),_("code",[e._v("If-Modified-Since")]),e._v("会启用更新后的 "),_("code",[e._v("Last-Modified")]),e._v("。")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("Etag/If-None-Match")]),e._v("， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 "),_("code",[e._v("ETag")]),e._v("字段返回给浏览器，接收到 "),_("code",[e._v("If-None-Match")]),e._v(" 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 "),_("code",[e._v("Last-Modified")]),e._v(" 不一样的是，当服务器返回 "),_("code",[e._v("304 Not Modified")]),e._v(" 的响应时，由于在服务器上"),_("code",[e._v("ETag")]),e._v(" 重新计算过，"),_("code",[e._v("response header")]),e._v("中还会把这个 "),_("code",[e._v("ETag")]),e._v(" 返回，即使这个 "),_("code",[e._v("ETag")]),e._v(" 跟之前的没有变化。")])])]),e._v(" "),_("blockquote",[_("p",[e._v("HTTP 中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。")])]),e._v(" "),_("h4",{attrs:{id:"为什么要有-etag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有-etag"}},[e._v("#")]),e._v(" 为什么要有 Etag")]),e._v(" "),_("p",[_("code",[e._v("HTTP1.1")]),e._v(" 中 "),_("code",[e._v("Etag")]),e._v(" 的出现主要是为了解决几个 "),_("code",[e._v("Last-Modified")]),e._v(" 比较难解决的问题：")]),e._v(" "),_("ul",[_("li",[e._v("一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；")]),e._v(" "),_("li",[e._v("某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，"),_("code",[e._v("If-Modified-Since")]),e._v(" 能检查到的粒度是秒级的，使用 "),_("code",[e._v("Etag")]),e._v(" 就能够保证这种需求下客户端在 1 秒内能刷新 N 次 cache。")]),e._v(" "),_("li",[e._v("某些服务器不能精确的得到文件的最后修改时间。")])]),e._v(" "),_("h4",{attrs:{id:"优先级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[e._v("#")]),e._v(" 优先级")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v(" Cache-Control  > expires > Etag > Last-Modified\n")])])]),_("h4",{attrs:{id:"用户行为对缓存的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户行为对缓存的影响"}},[e._v("#")]),e._v(" 用户行为对缓存的影响")]),e._v(" "),_("p",[_("s",[e._v("简单说就是 F5 刷新的时候，会暂时禁用强缓存")])]),e._v(" "),_("p",[e._v("经过对 qq、fire fox 、safari 、chrome 这几个浏览器的访问同一个页面测试我发现，不同的浏览器在 F5 刷新的时候 ，同一个文件 qq 、fire fox 浏览器会返回 "),_("code",[e._v("304 Not Nodified")]),e._v("，在请求头中不携带 "),_("code",[e._v("Expires/Cache-Control")]),e._v("； 而 chrome 和 safari 刷新的时候，会返回 "),_("code",[e._v("200 from cache")]),e._v('， 没有真正发起请求，走强缓存。可见不同的浏览器反馈是不一致的，所以下面表格中"F5 刷新"时 '),_("code",[e._v("Expires/Cache-Control")]),e._v(" 会无效我认为是存在一定争议的。")]),e._v(" "),_("p",[e._v("而 Ctrl + F5 强制刷新的时候，会暂时禁用强缓存和协商缓存。")]),e._v(" "),_("blockquote",[_("p",[e._v("在写这篇博客时，对于我仅仅测试了一个浏览器之后便写了无效(因为网上大多数帖子写了无效，我也以为我验证通过了)，对指出这个问题的群友，表示感谢，希望其他人不会被我误导。")])]),e._v(" "),_("table",[_("thead",[_("tr",[_("th",[e._v("用户操作")]),e._v(" "),_("th",[e._v("Expires/Cache-Control")]),e._v(" "),_("th",[e._v("Last-Modied/Etag")])])]),e._v(" "),_("tbody",[_("tr",[_("td",[e._v("地址栏回车")]),e._v(" "),_("td",[e._v("有效")]),e._v(" "),_("td",[e._v("有效")])]),e._v(" "),_("tr",[_("td",[e._v("页面链接跳转")]),e._v(" "),_("td",[e._v("有效")]),e._v(" "),_("td",[e._v("有效")])]),e._v(" "),_("tr",[_("td",[e._v("新开窗口")]),e._v(" "),_("td",[e._v("有效")]),e._v(" "),_("td",[e._v("有效")])]),e._v(" "),_("tr",[_("td",[e._v("前进回退")]),e._v(" "),_("td",[e._v("有效")]),e._v(" "),_("td",[e._v("有效")])]),e._v(" "),_("tr",[_("td",[e._v("F5 刷新")]),e._v(" "),_("td",[e._v("无效(有争议，不同浏览器反馈不一致)")]),e._v(" "),_("td",[e._v("有效")])]),e._v(" "),_("tr",[_("td",[e._v("Ctrl+F5 强制刷新")]),e._v(" "),_("td",[e._v("无效")]),e._v(" "),_("td",[e._v("无效")])])])]),e._v(" "),_("h4",{attrs:{id:"如何设置强缓存和协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何设置强缓存和协商缓存"}},[e._v("#")]),e._v(" 如何设置强缓存和协商缓存")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("后端服务器，写入代码逻辑中：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("res.setHeader('max-age': '3600 public')\nres.setHeader(etag: '5c20abbd-e2e8')\nres.setHeader('last-modified': Mon, 24 Dec 2018 09:49:49 GMT)\n")])])])]),e._v(" "),_("li",[_("p",[_("code",[e._v("Nginx")]),e._v(" 配置")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v('add_header Cache-Control "max-age=3600"\n')])])]),_("p",[e._v("一般来说，通过 nginx 静态资源服务器，会默认给资源带上强缓存、协商缓存的 header 字段。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://user-images.githubusercontent.com/11473889/57010188-fae2b380-6c2d-11e9-974e-6d2cb4eee219.png",alt:"image.png"}})])])]),e._v(" "),_("h4",{attrs:{id:"两个示例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两个示例"}},[e._v("#")]),e._v(" 两个示例")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("如果在 "),_("code",[e._v("cache-control")]),e._v("定义的 "),_("code",[e._v("max-age")]),e._v(" 时间之内，"),_("code",[e._v("js")]),e._v(", "),_("code",[e._v("css")]),e._v(" 文件会走强缓存，"),_("code",[e._v("http")]),e._v(" 状态码是 200， 跟服务器也并不会有交互。但是第一个文件 "),_("code",[e._v("index.html")]),e._v(" 文件, 每次回车或者刷新都是状态码都是 304 ，因为它的请求头中默认每次都携带了 "),_("code",[e._v("Cache-Control: max-age=0")]),e._v(" 。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://user-images.githubusercontent.com/11473889/57023165-e9b49980-6c63-11e9-9184-577bf610cc26.png",alt:"image.png"}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://user-images.githubusercontent.com/11473889/57023171-ede0b700-6c63-11e9-9f3a-7ba52004e009.png",alt:"image.png"}})])]),e._v(" "),_("li",[_("p",[_("code",[e._v("js")]),e._v(" "),_("code",[e._v("css")]),e._v(" 文件 "),_("code",[e._v("cache-control")]),e._v(" 超时之后，重新按回车会走协商缓存，请求服务器发现资源没有改变，于是返回 304 ，浏览器从缓存中获取内容，从 "),_("code",[e._v("size")]),e._v(" 中也可以看出端倪， 几百 B 的包不是静态资源的体积。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://user-images.githubusercontent.com/11473889/57023233-0c46b280-6c64-11e9-9ab2-69d727432034.png",alt:"image.png"}})])])]),e._v(" "),_("h4",{attrs:{id:"三级缓存原理（大白话）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三级缓存原理（大白话）"}},[e._v("#")]),e._v(" 三级缓存原理（大白话）")]),e._v(" "),_("p",[e._v("最后总结一下浏览器的三级缓存原理：")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("先去内存看，如果有，直接加载")])]),e._v(" "),_("li",[_("p",[e._v("如果内存没有，择取硬盘获取，如果有直接加载")])]),e._v(" "),_("li",[_("p",[e._v("如果硬盘也没有，那么就进行网络请求")])]),e._v(" "),_("li",[_("p",[e._v("加载到的资源缓存到硬盘和内存")])])]),e._v(" "),_("h4",{attrs:{id:"参考文档"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[e._v("#")]),e._v(" 参考文档")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/jpfss/p/9242797.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("from disk cache 与 from memory cache"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/wonyun/p/5524617.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http 协商缓存 VS 强缓存"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=a.exports}}]);